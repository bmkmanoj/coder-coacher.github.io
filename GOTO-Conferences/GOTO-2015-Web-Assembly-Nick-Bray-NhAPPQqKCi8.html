<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Web Assembly • Nick Bray | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Web Assembly • Nick Bray - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Web Assembly • Nick Bray</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NhAPPQqKCi8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Nick Bray I work at google on chrome
and lately I've been working on a new
technology called web assembly I've been
working on this with a handful of
co-workers and other software engineers
at other companies web assembly is
designed to run native code on the web
run it quickly run it efficiently run it
safely run performant Lee and by
themselves we've seen this all before
when I say no code I mean C C++ or
anything that compiles down to a machine
architecture and native code naturally
runs fast right well getting this all
together getting it to run on the web is
we've had pieces of the puzzle for a
long time but web assembly I believe is
going to be the first thing that puts
all the pieces together so the two
reasons I'm very interested in web
assembly are everyone's talking about it
or i should say the major browser
vendors are talking together about it
now this is a far way away from actually
being a standard this is a far way away
from everyone committing to it but the
fact that we're talking is a very good
sign for what's coming the other thing
that I'm very excited about is that it
has shared memory multi now there's a
lot of front-end developers in here and
front-end developers please raise the
hand so I know who I'm talking to and
then people with experience with native
code okay so it looks like we have bit
of a split with a little biased towards
the native code so i will explain shared
memory multi in a bit especially for the
front-end developers but this is very
very important to get native code to
work and work very well
so we've been down this road before road
before his native code on the web is
we've been trying at it for I don't know
about five years now and it's never
quite work but there have been some
things which have been really impressive
in my view one of the things that's
occurring nowadays is game engines on
the web is unity on Unreal is they're
taking their game engine which is
currently targeted at desktops on mobile
and then they're adding components so
they can run on the web and this shows a
sort of cross-platform strategy is
you're looking for all the distribution
channels you can for your content and
the web is just another one currently
it's a little tough because the web is
weird as we'll get into in a moment but
if it was less weird if you could just
target everything at once more
opportunities for revenue more
opportunities for delivery imagine if
you could just send a link to someone to
the game your friend clinks on the link
then you're there in the game
immediately no install they're right
next to you just works there's been some
interesting interesting experiments with
running different languages on the web
right now you can use any language you
want on the web as long as it's
JavaScript and there's a website called
repli twitch has been using technology
to compile native code do javascript to
run things like Python and a web page
run things like C sharp on a web page
even crazier people are emulating entire
operating systems there's a website
called dosbox where you can run all your
favorite old games if you're that old
j/s Linux is someone run an entire Linux
machine and translate it to Java in a
web page so you can do linux in a web
page one of my co-workers set up an
entire development environment inside a
Native Client module so you can run GCC
inside of a web page the crazy stuff
impressive stuff and people have
experiment with PDF viewing is that you
could actually compile PDF viewer and
run it inside a web page traditionally
PDF viewers are part of the web browser
but they actually made it a web app and
similar with media decoding is there
some places that people have taken media
decoders audio decoders and run them
inside the web page again traditionally
these things are part of
the web browsers if you want a decode
video you say well my program isn't
going to do that so I'm going to
delegate to the web browser and there's
a lot of reasons for this that the web
browser just isn't fast enough in a lot
of case is or either i should say web
apps are not fast enough but i mean they
are fast enough in the throughput sense
but sometimes they just aren't reliable
enough you know if you're trying to
decode audio you have to do it exactly
when the audio is needed or else there's
gaps there's pops so performance is more
than throughput it's also reliability of
performance so right now all these
things are very interesting and they
work in many cases and almost work in
some cases but they are the product of
very dedicated people and if we lower
the bar to entry things like this will
become much more common much more
pervasive so the problem with the web is
that it had its own evolutionary history
is it responded to a different set of
forces than the native platform did and
ended up in a different place with an
entirely different set of properties now
different isn't bad but when we're
asking how can we do multi platform
development how can we take legacy code
and move it to the web it becomes much
harder that's different so one big
property of the web which is different
is this asynchronous is that if you ever
want to ask the system for something say
load a file you say hey I want a load
file the system says that's great give
me a call back so you give it a call
back and it says okay I'll get back to
you later now if you're executing still
executing you'll never get the response
in fact the only way you can get a
response when you're running JavaScript
is that you stop execution you unwind
your entire call stack go back to the
event loop the event loop may do a few
things in the meantime you have no
control over what it's doing and then
eventually they'll call you back and say
oh yeah here's the file your request
across the network negative code on the
other hand like synchronous interfaces
this is a legacy of how the operating
systems first were is you go the
operating system and say hey I want to
file it says stop right there for a
moment goes gets the file then says
here's the file resume so the
interesting thing here is that you don't
unwind the call stack you have the
entire function call chain you get the
file and then you can resume execution
immediately from where you're at so if
you're trying to translate a synchronous
program into an asynchronous program
this ends up being a lot of work because
you have to cut
the entire call stack you have to change
things so every time you had what used
to be a synchronous operation it becomes
an asynchronous operation that turns
into a call back another aspect that
makes porting to the web fairly hard is
that there are no threads with shared
state so if you're familiar with the web
platform there are web workers which are
technically threads but they have their
entire own JavaScript contacts they have
their own set of objects and you can
never have an object that is
simultaneously modifiable with two
threads where when you have something
like the native platform when you have
threads you can freely pass data to them
and you can actually access data at the
same time which is usually a bad idea
unless you're very very careful even the
people I work with who are expert at
threads when you ask them how does this
work they're like let me think about
that for a moment and that is called
wisdom as people realize they are not as
smart as they think they are on threads
are tricky so when you're porting native
programs you want threads because they
despite being you know despite the fact
you're juggling hand grenades is they
give you things that you need they give
you performance they give you reliable
performance they are essentially the
primitives that the CPU uses so you
can't really get any more efficient than
that you can't get any more reliable
than that and a lot of ways you can
debate whether you actually want threads
as a programming model is they are
dangerous but they are very very useful
so having a platform that provides them
to you and lets you build things on top
of them lets you build better
abstractions on top of it that's pretty
important another weird thing about the
web is inconsistent consistent
performance is JavaScript was designed
to be easy to use and it's only over
time that we've been able to make it run
faster and faster and this is in part
due to the heroic efforts of the people
implementing javascript is they've
gotten cleverer and clever and the
JavaScript engine has gotten more
complex and more complex so when you ask
why does my JavaScript application
perform the way it does the answer is
not very clear so there's all sorts of
just-in-time compilers which start at
the beginning saying well I know nothing
about your program other than its text
then it starts executing it for a while
then says oh wait this is an um
I can do a little better so that it runs
faster than it says oh I know the type
of this then it can run better then it
says oh I got new information that says
this could be a number of string roof I
don't know what I'm doing so let's run
slower so you can actually have through
the lifetime of your program that run
faster than run slower than run faster
in it's because of the heuristics and
the tuning and the magic which on
average makes the web go better but for
your specific application it may result
in bizarre behavior that you can't
explain another thing is garbage
collection is JavaScript provides the
abstraction that you don't have to deal
with memory so if you're done c or c++
manually saying i'm done with this
object it's very error-prone you know if
you do c++ for long enough you sort of
get in the habits you know how to do it
but ultimately when you get it wrong
that becomes the worst bug in the world
to deal with so garbage collection fixes
all this by saying the system will
figure it out for you but the cost of
this is that occasionally the system has
to come in stop the world and say let me
clean up after you then resume the world
and this is GC pauses is when you have a
JavaScript application or any
application with them with a real or any
application with memory management is if
you're trying to do rendering 60 frames
a second or rendering audio in the worst
case you could be interrupted and there
could be a bit of a hiccup so altogether
porting code to the web is currently
painful no matter how you do it and the
question is how can we do better so you
might think that maybe the web just
isn't worth it is there's all these
things that makes pouring native code to
the web hard so let's just not do this
lets the web set on its own strengths
but it has a lot of interesting
strengths for other developers it's open
so you want to ship a nap all you have
to do is get a cloud server somewhere
load it on there boom you're a nap
publisher there's also multiple vendors
who have different browsers you never
have to worry about vendor lock-in for
any web standards because there's
multiple implementations of it it's
secure now there should be an asterisk
next to this is technically every
platform as secure but they have a
different definition of security and the
web has a fairly unique definition of
security that it's as safe as a document
so the history of the way
started with viewing HTML documents and
the security model keeps going from that
so when someone hands a document you
don't have to worry about it picking
your pocket you know it's it's not going
to harm you in any way as your eyes
aren't going to explode is a document is
safe there's nothing anyone can do to
damage you by giving you a document
other platforms they have a more a
different approach to this and this has
caused legacy problems like operating
systems assume any program is operating
on your behalf so therefore if it wants
to take your tax return and upload it to
some strange server in some foreign
country that's a perfectly fine thing to
do because that's you doing it which
isn't true for many apps which are
loaded across the network another thing
is it's portable again this is a tribute
to deserve an asterisk next to it is it
is portable in the sense that anywhere
there's a web browser web content can
run and the same program should run the
same anywhere so if you're used to
native code you spend a lot of time
porting it and native code is portable
in the sense that you can make it run on
any machine fast but there may be
behavior differences between it so
things are a little different between
platforms so there's two distinct
different versions of portability and
the web version of portability is that
consistent behavior no matter what the
operating system no matter what the CPU
another nice property which sort of
Springs from the security and
portability is ephemerality is you don't
have to install it you just point your
web browser at the app you are up and
running instantly and as it turns out
when you have to ask users oh can I have
permission to do bad things to you but
honestly I will not this sort of reduces
the user by and it adds friction and
makes it harder to convince them to use
your app similarly ephemerality allows
the idea of evergreen apps is that every
time someone goes to your web server
they get the newest version you have to
worry less about tech support for
someone who's using the application
that's two years old and then you're
scratching your head figuring out why
did that such a weird thing going on so
when it'd be nice if we could get all
these properties of the web and all of
the good properties of native in one
bundle that's kind of the question
that's motivating web assembly and i
should say at this point i'm going to
refer to it as am at some points w
to ASM and that's just habit because
we've been talking about internally so
long and we have jargon so to understand
how we got here it's we should briefly
look at the history and as I was saying
that in the first there's hypertext
markup language which was just a
document and then few years later people
figured out interactive documents are
cooler than just documents so this is
where JavaScript came from is you can
click on it and that's an event and you
respond to the event and then you return
to the event loop but people wanted more
so they immediately saying hey we have
this nice document distribution platform
so what if we could have other kinds of
documents like PDF documents or vector
graphics or we could embed Word
documents so there's this profusion of
plug-in technologies or people said hey
we want to do more on the web browser
but instead of doing it inside the web
browser let's just bolt this chunk of
code onto the web browser and the legacy
is still with us today 20 years is we're
finally dealing with but the problem of
this is there is severe security
problems is that because you weren't
inside the web browser because you
weren't thinking about how to behave as
web content because you're your entire
own stack you could have just different
rules for what was secure and it was
sort of like when you had the two
parents and you're like hey can I do
this no hey can I do this okay and you
know once you're in that situation it's
very hard to be secure and there is
surface area complexity issues so in
some ways we were we had the best of
intentions in this era but we didn't
quite understand all the nice properties
of the web i said earlier around 2000 a
we there is a renewed interest in
javascript performance chrome came out
mozilla started really pushing their jit
and sun li javascript became fast it
became practical to think about building
large-scale applications in javascript
there is an exponential take off and
everyone was like magic javascript elves
are making things faster all the time
but I actually know those JavaScript
elves and as it turns out this is very
very hard and the amount of complexity
involved is huge and so this exponential
will take off we saw around the 2008 era
is not sustainable is there is a certain
ceiling where we're going to slow down
progress and slow down progress and the
question is how do we keep going how do
we keep getting
performance and web assembly kind of
answers that by saying we do it by being
simpler is we make the browser's life
easier in order to make it run fast a
project that I worked on was Native
Client is google said hey what we're
going to do is we're going to take a
native programming environment figure
out how to make it safe by making sure
it can only talk to the op or only talk
to the browser not talk to that brain
system and there you got native code on
the web unfortunately they did not get
buy-in from other vendor render browser
browser vendors is in my point of view
from my point of view it's the right
technical solution but it never got the
craw the multi-party by in the cross
browser solution and this always made it
very hard sell for web developers is you
know you got chrome great but what about
the other fifty percent or so that's
very hard thing to overcome web
developers want to run everywhere they
want it to be a web technology they want
it to be fully open and fully portable
so around 2010 M scripting came on the
scene and at first blush this is a truly
horrifying idea is that you take native
code and compile it into JavaScript now
this was just after JavaScript started
becoming fast or fast so people were
still in the mindset of JavaScript isn't
that slow but due to some very careful
engineering decisions it was able to run
shockingly fast and it actually just
worked a lot of the time the big
limitation of Emscripten is that because
it was being compiled to JavaScript it
couldn't do threads effectively it had
to use Java scripts concurrency model is
you had to have the event loop you had
the be asynchronous you could not block
so there is always a bit of porting
friction where you had to rework your
model your applications model to work
inside JavaScript application model so
this brings us to web assembly is what
if we could have the nice pervasiveness
of Emscripten but at the same time have
shared memory concurrency so this is
kind of a summary of that a somewhat
long-winded history thing is if you look
at the top that's the plug-in era and
the obvious problems there are security
and another thing that came along is
because there's security there's sort of
grudging acceptance of things
NPAPI so when the mobile browsers came
out they said that's technically not
part of the standard web so we're not
going to support that so apples decision
not to support flash for instance that
was a real big impetus to sort of
re-examine these technologies and
because of that they aren't really cross
browser anymore even though one version
of Chrome supports flash the mobile
version does not then if you look at the
right corner or the right column this is
the one that particular interests me is
there's really no platform right now
that both runs in every browser and
supports shared memory multi and that's
one of the big things making it easy to
run native apps on the web so web
assembly potentially so enough history
how does web assembly actually work and
the answer in some ways is very simple
and very boring is that you're used to a
normal web app and that web app takes in
an HTML page takes in JavaScript sources
takes in data files like images CSS
things along those lines and the web
assembly when the browser supports web
assembly there's just going to be a
binary is it's going to be a binary
produced by a C compiler from C source
files and then you just load the browser
much like you would JavaScript has its
own vm turns into a bunch of functions
turns into much a code inside the
browser now i'm lying a little bit in
fact as an implementation issue a lot of
the people who are planning on
implementing this are planning to fuse
the javascript in the web assembly bits
so when you actually have a web assembly
file what's going on is you're taking it
and you're shoving it into your
javascript engine just in a much lower
level is the web assembly file you know
more about it from the beginning so you
can skip all of the dynamic and adaptive
compilation things where you're trying
to figure out is this an integer or is
this a string you know from the
beginning but this is an implementation
detail from the users point of view you
don't know you don't care what's
actually inside this binary file it's
rather hard to make slides about binary
so here's a image to illustrate it so if
you have an example you're calling the
function foo and you have you know one
argument which is a plus 7 another
which is be both a and B are locals if
this was JavaScript you'd initially say
well I know nothing about this I don't
exactly know what function i'm calling
you know I don't know if a is an integer
I don't know if it's a string so this
addition operation it could do a lot of
things it could concatenate it could add
etc etc but the in the web assembly
version is you have a tree of operations
in each of those operations you can
exactly and for what it's going to do so
when you have an addition operation that
says this is the type of it it's an in
32 operation so the inputs are both
going to be 32-bit integers the output
is going to be a 32-bit integer and this
allows you to have good performance from
the beginning the binary format itself
is important because it allows us to be
smaller so if you just take a JavaScript
application you know compiled to as MJ s
and then transcode at the binary one of
the software engineers at Mozilla did
this experiment and found that they
could reduce the file to about the third
the original size but this is before
compression if you actually compress it
there's sort of an entropy argument and
play that it's still the same program so
it's still going to be about the same
size but nonetheless they were able to
shave off about a quarter of the size
now size is very important especially on
the web because it's data is it's how
much do you have to download and this
also affects how fast you start up it
also affects how often can you update
your app and things along those lines so
the smaller you can get it it pays
dividends in all sorts of other ways and
i should say at this point I've you know
harped on performance and again
performance is one of these things that
is more than just as how fast you run
its mobile battery it is the difference
between four frames a second ha nice
hack and 40 frames a second oh this
could actually work so performance is a
feature it isn't just the same
application running faster another
interesting thing about the binary
format is that it's about 23 times
faster to parse than text so because
it's binary because it's not designed to
be human readable human writable you can
lay it out in such a way that the
machine
doesn't have to think too hard when it
sucks it in and parsing the javascript
is actually a fairly large component of
start-up and JavaScript engines do
things like overlap it with the download
to try to amortize it but it's
fundamentally expensive so what's
actually going on under the hood I've
wave my hands about binary encoding and
things like that but what does it
actually do and when I first did this
slide I was like wow this is kind of
boring is that wisdom you get a big
chunk of memory a big bunch of bytes and
you take bites out of it you do
operations on them and you shove bites
back into it there are no objects there
are no strings this does not look like
anything you expect to be a programming
language especially if you're coming
from the JavaScript world but after
thinking about for a while I realize the
important thing here is this is not a
programming language what this is is it
is a portable machine architecture it's
kind of equivalent to a cpu in a sense
the CPU has a bunch of memory as it can
do arithmetic operations it can move
things in and out of memory you build
programming languages on top of this so
you take something like see it gets
compiled in terms of this you take
something like C++ it gets compiled in
terms of this so for example if you have
a sea program with its nice manual
memory management whenever you create a
new structure a new object it boils down
to say hey I want to allocate enough
bytes to hold the data structure in so I
want to allocate a hundred bytes and
then it does some bookkeeping your
program itself says I know I have this
big chunk of memory and based on
bookkeeping I know this area is free so
here have the address of these 100 bytes
and then you can load numbers in and out
of that specific region and that
corresponds to fields on your data
structures for example another thing
going on here is that you have a limited
amount of memory is hopefully large but
still limited because this is running
inside a process with a lot of other
things so this chunk of memory is going
to be next to the JavaScript runtime
it's going to be next to the document
object model so any time you try to go
out of this chunk there's going to be
checks that say oh wait you can't do
that
that isn't safe so that is how security
is maintained is that whenever you're
doing memory accesses you only can
access memory you're allowed to access
another very important part of web
assembly is foreign function invocation
so it isn't just its own thing it's
designed to integrate with JavaScript so
JavaScript can call into web assembly
and web assembly can call back out to
JavaScript and this means that you can
build hybrid applications is you could
for example build your front end or your
UI in the DOM and then they'll delegate
to web assembly to do some heavy lifting
like video decoding or game logic or
whatever you want so if you if you've
done any Android development it's sort
of along the same lines is that you have
to define what the interfaces between
the two languages that's the top of the
slide in us just declaring two functions
as the entry points and exit points and
then from that point you're two
different languages can interoperate
with each other now here's where some of
the evil genius comes into play is
because the web is a multi-party
platform everyone's invested everyone's
standardizing everyone has their own
implementation doing something new is
difficult it takes time so how do you
get people to adopt a technology when
there's a one two three maybe all the
browsers don't support it natively yet
so the first version of web assembly is
going to be designed to be translatable
to javascript is semantically speaking
you can just take this web assembly
binary spit out a javascript file and
run it directly in the browser this
means that browsers you don't implement
can run it but it'll just be slower so
if you have a native implementation you
can take in the binary file directly
it'll load faster and it will run faster
this is roughly what it looks like is
you know you start out with a see
function this just does two loads from
memory adds it together and returns it
and then in the web assembly version
hand-waving this is binary is it has an
operation tree which essentially is the
same thing just explicitly naming
whatever
and then the JavaScript version this is
Azam's is if you're familiar with that
is the first two lines or just saying
well the the inputs are integers the two
arguments are integers and you see the
or 0 logically that does nothing but as
a quirk of JavaScript that actually
turns what was a floating point number
into a 32-bit integer because you can't
do boolean operations on floating point
numbers and whenever you have a memory
operation instead it says there's this
giant array it's an array buffer and
we're going to treat it like the heap
that we see elsewhere another thing to
note is that in the web assembly version
there are no pointers so what was used
to be a pointer gets turned into a
32-bit integer and it's the same as
there's other data types like eight bit
integers which aren't represented
directly they're just emulated on top of
this so it's designed to be minimal in
the sense there are certain things which
you'd think would be part of the
platform but don't need to be and it's
designed sort of like a CPU is that you
just have bits that you're shuffling and
computing on so a lot of talking let's
see it in action so before I get too far
into this I have to say that all the
numbers i am going to quote are actually
completely unfair and i am being unfair
for a reason sort of illustrate the
point so this is all early work this is
a patched version of chrome it isn't in
chrome yet this right here is a rate
race fear and it's running entirely in
JavaScript and it's in running entirely
on the CPU no GPU involved which in
modern terms is kind of silly but at
least it shows what the CPU can do up in
the right-hand corner running about 30
32 frames a second and the program here
is just a textual version of the binary
format I whipped up so we could do some
prototypes with it's not the official
syntax or anything along those lines
it's on my github account if you're
interested there will be a link later on
so it's about 30 frames a second and now
the question is what happens when I
click this box and I go into the native
version of the back end and we'll see
that suddenly it's in like 80 90 frames
a second range
now note that I said this is unfair you
know if I could claim a 2x performance
advantage over JavaScript you know there
is the sales point there but the truth
of matter is actually a more subtle so
this example uses a 32-bit floating
point math whereas naturally JavaScript
works in terms of 64-bit floating-point
math so when you have a number for
example that's a 64-bit quantity goes
theft PU and when you have less bits for
the floating-point numbers you can do
them faster because you need less
precision it takes less clocks to pump
them through now javaScript could do
32-bit floating point math fast is
there's ways you can hint it you know
there's a javascript function called
math dot F round and so every time you
do a floating point function you can
immediately do math that F round after
it and then the JavaScript engine can
say well because you're dropping those
bits I don't need to compute them in the
first place so if it is really smart and
some JavaScript engines are this smart
it could look at a sequence of math
operations with F round and say I will
just generate the most optimal code
possible for but as it turns out this
optimization has not been implemented
yet in this particular JavaScript engine
and this is an issue of triage as
there's just more important things to do
at the time so in theory JavaScript
could run just this fast it could run 85
frames a second but the fact is that it
doesn't and it doesn't because of
complexity and time so the real win for
web assembly is that it's simpler it's
simpler and easier to get the
performance and it takes less effort to
get to the point where you have full
performance but I have full faith that
JavaScript could do this if you throw
enough engineers and enough money on it
another interesting thing I can't get
this to reliably reproduce but I'll try
anyways is will flip back to JavaScript
so and I did that it just regenerated a
new JavaScript program compiled and
started running it so it's entirely
different code and then I flip back to
the native code same performance flip
back to JavaScript there we go so now
you'll see that I am down to 24 frames a
second whereas previously I was at 32
friends a second now I haven't bothered
investigating exactly why this is
this is the sort of stuff you get all
the time is I was doing something weird
is I was just throwing more and more
JavaScript at it and at some point the
JavaScript engine was like okay whatever
I've reached some threshold and I'm not
going to try as hard anymore and now
it's running slower and this is what
we're talking about is predictable
performance is on the road to this I did
things like prototypes with shared
memory where I was trying to do fluid
simulation another parallel computation
in JavaScript and actually I ran into
all sorts of weird bugs that took a lot
of time to understand why was it running
slower like some of them involved
invisible fields that were added to the
objects to give them a hash ID because I
was sending it to another process and it
needed the hash ID to know if there are
cycles in the object graph so is
entirely invisible entirely part of the
underlying um underlying implementation
so that in a nutshell is web assembly of
an uncle who's a salesman and one of his
quotes is anyone can sell the future so
the question is when is this actually
going to be available now all these
numbers are very very tentative and
possibly optimistic they were sort of at
the threshold where I said what about
2016 and no one laughed out loud but you
know things are still under development
these are not a promise so despite
previously I was saying assured our
shared memory multi-element thing to
make native code on the web work version
one isn't going to have it so version
one is going to be more canonicalization
of what would happen if you translate it
to javascript is you have a single
thread you have an event loop but what
you get is you get it to load faster and
run faster and have more reliable
performance then as soon as possible
after that we're going to add shared
memory multi and why not make that part
of version 1 and the answer is is that
threading is complicated as a user but
it's even more complicated as someone
trying to specify how it works so this
is one of these like Quagmire's where
you send soldiers in and they never
leave alive is everyone who has try
the spec threads in shared memory has
had a tough time of it now we can learn
from everything that they did and we
definitely are you know seeing what the
c++ standards committee does but we are
being very cautious and not saying that
we're going to block the release on this
and that's why the most important
feature in my mind is actually not going
to be part of the initial version and
then from whether or not there's all
sorts of interesting things to add one
of the big ones for me is going to be
dynamic linking is right now when you
have a web assembly binder it's just
going to be one binary so the question
is how do you share functionality
between apps how do you potentially
update part of your app but not all of
it at once so you can have a partial
download and dynamic linking is a
technique from native code which if you
use to javascript is like what it
doesn't do that all the time is where
you just have multiple files that get
loaded and turned into a single program
so that is all the prepared contents and
let's do questions we can get as
technical as you want I was just trying
to spare you I'd love to talk about it
but we'll see what people want to ask
and what does the expect that the
Bolognese about uh we're going to try to
get as close as possible and for example
when you're translating to JavaScript
you know just like compiling native code
to JavaScript you can sometimes get like
within it varies on the app you can like
get within two percent in like the best
cases where I think you're pure numeric
so if it can look at the program and
says oh this is a bunch of math it can
just generate the math and run directly
on the CPU but then when you start doing
something with memory accesses it has to
validate all of those memory accesses
and make sure they're on the right bound
so there's more friction or if you have
a call stack I'll leave through the
translate to JavaScript but Wasel it'll
be less of an overhead like the call
stack also has overhead so it's very
mixed is translate to JavaScript I've
seen on fast JavaScript implementations
be pretty much neck-and-neck with native
code or sometimes be like twenty thirty
percent slower on bad JavaScript my
should say bad but on JavaScript
implementations that weren't tuned for
this workload is you can
x be like a factor of 10 slower Native
Client the experience was I we told
people around ten twenty percent and
your expectations would be reasonable
and in some ways this is the cost of
portability like one thing I didn't get
into is like bit shifting is how does
that work when your number is too big so
you have like a 32-bit integer and you
want to shift it by 33 bets as it turns
out different hardware does this
differently you know and if you want
something truly portable then you have
to sort of tighten that down and say
well when you're out of range it does
exactly this and then that adds cost to
every bit shifting operation so security
is going to cost you and portability in
the sense that your program functions
the same everywhere is going to cost you
but not cost you that much especially
when you consider you're getting threads
and sim doubt of the deal eventually
because you'll make up for it ah yes so
the question was are there any touching
points was the phrase used between web
assembly and GWT is GWT still of
interest any Google interest to Google
so for those of you use we don't know I
believe that GWT is a technology which
trans piles Java into JavaScript and i
believe it's used for applications such
as Gmail I'm not not gmail um AdWords
okay yes and I cannot speak for is this
of interest to Google is I'm just
sitting on the web platform part you
know I'm trying to make this work so
there's people I cannot speak for from
our vision eventually we would want to
support this case so if you're cross
compiling Java it's a little more
complicated because Java is a memory
safe language and especially I in in the
first version is web assembly is not
designed to have efficient support for
garbage collection you could do it
it's not going to be as efficient as
saying mapping onto JavaScript objects
and relying on the JavaScript garbage
collector itself so eventually version 2
we're going to think about memory safe
languages but version 2 as far as I'm
concerned does not exist is right now
we're only focusing on the you gotta
bucket of bytes type languages and
things that are implemented directly
there of like Python so okay one more
from the audience the question is
typescript it has types could web
assembly be useful in that case I
personally would not use it so there's
an interesting point right here where
you know the binary format has all sorts
of types and it would be nice to be able
to say hey I have something that's
JavaScript but it has types but that's
going to be different than saying I have
a big chunk of memory that I manually
manage so you know typescript is sort of
in between and you know version two
where there's a memory safe language
that might be worthwhile but I mean a
lot of these things that are transposed
the JavaScript were designed with
javascript in mind is they have exactly
the same concurrency model they have you
know shared memory etc etc so I think
they're always going to be best on top
of JavaScript so okay do we have any
more questions on the app okay no more
so there's someone raising hand them
back hmm the other browser vendors how
how in on the web getting
is it going to be a real standard or are
we going to end up with everybody doing
their own different implementation of it
and it will be the same Messrs
JavaScript undergarment over the acid in
right so one of these tricky lines to
walk is I cannot speak for other browser
vendors however this link at the bottom
of the page you know github.com / web
assembly is that sort of being used as a
staging area for people to discuss
things to write things down and you can
go there and see for yourself who's
participating I think that if anything
we're coordinating a little too much as
we're planning to many things out I
personally want to see more prototyping
but in terms of lack of coordination i
can say that that's not a problem at
this point so the question is who do I
see as the target audience I'm repeating
this because it's being recorded and I'm
not sure you're being recorded I think
everyone heard him this is a rather
tough question is I mean in the
beginning like all the game engine
developers who are trying to target
multiple platforms is these are very
dedicated people you know very
technically skilled people and there's
always going to be those people who say
I can use this technology no matter what
but when we think about the web today
there's a lot of a lot of long tail is
you know pretty much anyone can get
involved in the web you know it's fairly
easy to learn JavaScript it's you know
fairly easy to start writing
applications and when you're looking at
something like native code you're losing
some of the features that make it all
easier to on board is you have to have a
compiler in the loop and I think over
time things like grunt you know could be
adapted to like rerun the compiler and
regenerate your binary but yeah so I
have native developers in the audience
of front-end developers sometimes when
we're talking about shared memory
concurrency on the web some of the
JavaScript people get a little concerned
and say well we don't see see any need
for this on the platform so it's one of
these until it's actually there it's
hard to understand how the environment
is going to involve and I think that one
of the things that
you know personally de-stresses me is
how you know how different the web
platform is and the other platforms so I
think right now they're very separate
ecosystems and it's a little hard to see
what's going to happen when they start
merging but when you're asking things
like codex is like as a web developer
you could use a native library or some
like it looks just like importing
JavaScript but it provides some high
performance video encoding functionality
or video decoding functionality and it's
just running in the browser so you may
not write it yourself but you can still
use him okay so he's a native developer
he's using open al and lube vorbis so
lib vorbis is pretty simple because
that's just a codec it's just
computation so you compile it and it
magically works and it's magically high
performance no problem there open ale is
a little more complicated because that
interacts with the system it's an audio
library so you're saying hey I want to
play the sound well how does it get
there so one thing I wave my hands over
and then go too deep into is that for
version 1 you you don't have any api's
you just call out to javascript so for
view future versions we want to have web
api is directly bound to web assembly
but fundamentally they're going to be
different api's so it's going to be the
same issue whether you have them
directly or going to javascript is
you're going to have to write some sort
of compatibility library on top of it so
someone somewhere is going to write a
library that says oh here's the open al
interface here's how i implement it in
terms of the web AP is for doing audio
and there's probably going to like 40
pinal because it's 3d because the web
currently doesn't have 3d there's going
to have to be some emulations of you
know all the spatialization stuff on top
of that so ultimately you compile your
code and you thunk into the web AP is
like OpenGL into WebGL you know that's
going to be a fairly simple one does
that answer your question it
sufficiently anyone else
okay thank you for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>