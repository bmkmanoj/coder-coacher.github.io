<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Visualise, Document &amp; Explore your Software Architecture • Simon Brown | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Visualise, Document &amp; Explore your Software Architecture • Simon Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Visualise, Document &amp; Explore your Software Architecture • Simon Brown</b></h2><h5 class="post__date">2016-11-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0o9_zjZeJuE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so visualizing document and documenting
and exploring software architecture and
we're gonna start here so imagine we've
invented teleporters and I'll teleport
you here where are you
France close but not quite so yeah it
says LaRue do something this is what
happens when we drop new join us into a
code base we kind of drop them straight
in the middle of it and they're a bit
lost how do we solve this problem how do
we figure out where we are we zoom out
we use technology we open up the maps up
on our on our phone and we start zooming
out any better not zoomed out enough
where you can now see the name the road
but we're not quite sure still where we
are we zoom up one more time yeah there
we go so there's Jersey that's that's
where I live there's a lot of clustering
on this map isn't there it's not very
very clear to see what's going on so
with things like Google Maps we can
reduce the amount of information like
that gets a bit clearer now we can start
to see some the place names and and
where some of the bits and pieces are if
you've never heard of Jersey before this
is still confused to so you have to
pinch zoom at one more time and again
and again so now they go there coz it's
a small island just off the coast front
now if you come and visit Jersey which
you should because it's lovely when you
come through the airport you'll get a
map and this is a traditional kind of
Vista map thing and it shows you
information like this the maps broken up
into 4 into four quarters and it kind of
tells you enough information to get
around tells you enough information to
you know go and find the major sites and
that sort of thing it doesn't tell you
everything though it's not listening
every street it's not listening every
building and every street either there's
a zoom in part for town the main city
and we've got a little bit more detail
on there but there's still it's a it's a
representation it's not quite accurate
so this thing here this blue bit that
the
heíd actually goes out there so if you
if you pull integers you know boat new
park there you will find it dry at some
point and also this bathing pool here it
looks like it never gets refreshed with
water but it does which is useful
because I'm sure kids peeing it in the
summer the thing these maps have in
common is that they show points of
interest right so what do I really want
to go and see when I visit Jersey
contrast this with like an ordinate
Survey map this is very very very very
detailed representation of Jersey we've
got contours and different types of land
and all sorts of things going on here
and you need a bit of intelligence and
you know some help to get started
interpreting this thing both maps are
shown selected highlights as well and
and that's a really interesting thing
here selected highlights so when you
come to Shaheen actually on your summer
holiday you'll probably drive past this
big castle it's called Elizabeth castles
on the south coast in sea and it's a you
know 16th century castle some beautiful
granite block work and it was basically
built to stop the French and English
taking Jesse over and when you walk
around this castle we kind of get to the
top in the middle and things start to
change and you've got this like
beautiful granite stone thing with this
weird concrete thing stuck on top for
some reason and you like that looks
really weird
what's all that about and history is
important here so when you're walking
around the castle it tells you that in
World War 2 when the Germans occupied
Jersey they refortified some of the
existing fortifications so that's what
that big concrete thing is on the top
and there's lots of gun emplacements and
so on and so forth of course all of this
stuff is described in guidebooks and
there are lots of them out there and of
course if you want to be a bit hipster
you can use the website we have the
internet now so that's my quick
introduction and sales pitch for Jersey
I guess I'm going to come back to say so
right so visualization one of the things
I do with software teams around the
world is I'd run a visualization
workshop and we give people some
requirements so we say right you have 90
minutes in groups to go draw some
pictures and these are the types of
pictures people actually draw I promise
I've not made any
I'm not sure I could make these things
up
these look like diagrams you see you and
your whiteboards yes I have another 15
gigabytes I could show you but I went
sometimes when I'm running this workshop
I actually hear people say this right so
they're drawing a box or a shape and
they say this doesn't make sense but
we'll explain it later when we do our
presentation or something and that's
fine but we don't always present our
diagrams do we you know if we're drawing
a picture out our system we don't always
stand there and present it and a nasty
trick I like to do is I like to have two
teams swap diagrams and guess what
happens because they weren't part of
that conversation creating those
diagrams I have no idea what's going on
and then this is kind of a whack moment
and they mode about the color coding and
the shapes and the lines and basically
none of the notation elements make any
sense whatsoever when you ask people you
know was this an easy exercise they say
well actually it was and then say well
why your diagram such a mess I go oh
yeah good point we don't really know
what to draw we're not sure what sort of
diagrams we should draw levels of detail
shapes notation should we use UML who
here uses UML that's a really small
number like four or five people
so what's every else doing something
else I've asked this question around the
world and UML is massively falling out
of fashion I have no evidence to back
any of this up this is all completely
anecdotal but I'm seeing more and more
teams who have no UML skills and in in
the teams anymore
I do use UML but I use it sparingly for
small parts of a software system right
when I want to show a very small part of
say our class class hierarchy or
something Google doesn't help if you go
to Google and ask it what it thinks the
software architecture diagram looks like
you get this right page after page after
page of essentially pretty colored block
pictures the sort of thing is you can do
in Visio a PowerPoint and we laugh at
these things but these are exactly a
type of diagram so I see when I go
through organizations
you know you open up there compliments
pages or whatever banging you get this
sort stuff and a half the pic just just
don't make any sense at all this is hard
I think I've run this workshop for about
10,000 people now all around the world
and nobody does it sufficiently well
first time around believe it or not and
the irony here is agile so one of the
great things a July on is it's made us
more visual whenever I go and visit
agile organizations you've got their
camera boards and the story walls and
the information dashboards so we've got
awesome at visualizing essentially
processing the way we work
but we've totally forgotten how to draw
stuff you know draw pictures of the
things we're building and this is just
about good communication you know if you
want to move fast as a team if you want
business agility then you need to
communicate well that's it
so there are some some really simple
tips here around notation that I can
give you and you know it's just stuff
like put titles and pictures make sure
your arrows are annotated make sure
arrows point one way and so on and so
forth and the notation around drawing
architectural diagrams is really really
easy to fix one of my key points is this
one here responsibilities we often joke
that naming is hard and software so it
doesn't make sense that most of our
architecture diagrams are essentially
just a collection named boxes because
the diagrams contain a huge amount of
ambiguity so my simple tip is add more
text to your diagrams then here's a
really simple example this is the same
diagram the version on the right has
more text and that what that additional
text allows us to see things like the
responsibilities of those building
blocks there's a lot more information
there in terms of content you know when
we're drawing architectural diagrams you
can't show everything on a single
picture and this is why people do talk
about things like views and viewpoints
and perspectives and there are lots and
lots of different ways to do this Owen
mentioned Phillip Christians four plus
one model Owen has a book that details a
whole bunch of ways to do this and there
are more the thing is all of those view
catalogs have this logical view of a
system separate to the development
of the system so the logical view is
often either the functional logical
conceptual building blocks and then
there's something else that refers to
how we're building these things why why
do we do this I don't get it because
whenever I go to organizations and I see
their nice fluffy logical architecture
diagrams they never match the code and
that's kind of the point here if I'm
drawing architecture diagrams I need
them to match the code otherwise they're
just lying to me George Fairbanks was
sick in the back because it's the model
code Gavin is in his awesome book when
we're having architected discussion
we're using abstract concepts like
modules and components and services but
we don't have those things same things
in our programming languages quick show
of hands who's a Java developer here
right so in Java is there a layer
keyword no in Java is there a component
keyword no but we create components of
layers by assembling classes and
interfaces and packages and things
together so what I'm trying to get to is
a set of diagram to accurately reflect
the code here that's my ultimate goal
before we can even attempt to solve this
problem we have a bigger problem and
that is a lack of any sort of consistent
standard language yeah even in 2016 we
don't have a consistent vocab ritu talk
about software architecture we think we
do but I don't think we do quiz time
what's this it's a map of London right
what's the blue thing it's a river so
River Thames what is a river body of
water flowing 100 other direction
perfect so we know what a river is and
we can go and find other rivers using
our knowledge what's that
so a floor plan for a bathroom what's
this thing here it's a toilet what is a
toilet right you know what it all is and
again we could use the our knowledge of
what a toilet is to go and find more
toilets and the electrical people here
magical engineers a couple of ways to
refer to circuit diagrams you've got a
funny cartoony pictorial thing or a
schematic version
what's that squiggly line there at the
bottom so resistor what's a resistor it
was this stuff it slows current down
earth of the year if I had a box of
electrical components here at the front
with capacitors and switches and
resistors could you come to the front
and find me a resistor in that box right
so you know how to identify a resistor
in it if you know the color cone you can
work out how strong it is right this
quiz is too easy let's ramp up the
complexity on an exponential scale
what's that so we have two UML component
diagrams one is a one point X version
one is a two point X version don't ask
me which ones which I've forgotten what
are the boxes on these diagrams there
are components correct what is a
component I don't know it's a logical
abstract functional building block thing
and and these components are all very
different so this one down here is an ax
is a stereotyped database and there's a
JDBC interface so that sounds like a
database component these ones are you
eyes or applications what's the stuff in
the middle
business components where do they run in
the database as part of the app are they
micro services this diagram is open to
lots and lots of interpretation look
more text on diagram if this diagram had
more text at least we know what these
things were to put this very very simply
imagine we're building a really simple
system consisting for a web app in a
database the word component means part
of for some people the web app is a
component of the entire system for
others something like a logging
component is a component of the web app
same word different levels of
abstraction
it's the ubiquitous language thing now
we've been going on for years about DDD
and having this ubiquitous language
between us and the business people we
don't have that your pictures language
for ourselves and that's the problem we
need to solve here UML tried to do too
much it was a standard notation and a
stance of abstraction and it kind of
failed on both counts and I think for
where we are currently in
industry.we needs that standard set of
abstractions I would like to get to
something like electrical engineering in
the future so we have a standard set of
funny symbols to represent things but
let's get the language nailed first and
the thing here is that the language we
create need to reflect the technology
that we're using so I want to merge the
logical and development views back
together again collapse them so we have
real terminology that maps to real
technology now I don't know how we do
this on a global scale but what we can
do within the boundaries of this room is
I can show you how I do this and for me
very simply when I'm discussing about a
software system that software system is
made up of containers a container is
just something that stores data or runs
code in real terms it's a web app a
mobile app a standalone app a window
service a database schema and so on if
you open up the containers they are made
up of components so I want to use the
word component to mean something running
inside a runtime environment essentially
it's a nice cohesive grouping of stuff
with a nice clean interface and we're
done
because I mostly deal with Java and
c-sharp my components are built for
classes that's it it's a really simple
hierarchical tree structure to describe
the static structure of software system
if using JavaScript this makes no sense
so maybe its modules and objects or
modules and functions same with
functional languages modules and
functions if you're using a database
technology maybe its components or
procedures so again you have to take the
same hierarchical approach and map it to
the text that you're using and this is
really about creating a single simple
static model of a software system from
the system as a black box down to the
code with a couple of levels in between
so that's the language to find that and
once you define a language you can draw
some diagrams really simply and and this
is what I often refer to as my c4 model
it's a context diagram you zoom in to
see the containers you zoom in to see
the components and you can't go down to
code if you want to but I don't normally
do this especially if I'm trying to
describe the existing code base for
example really quick example I create a
site called tech drives when I moved
back to Jersey and it's just a simple
content aggregator for the local tech
industry this is a context
diagram for tech tribes the thing when
the monkey is the system I built there
are different types of users and
different system dependencies if this
was an interactive Google map we could
select pinch to zoom in we see the
containers inside the system boundary we
select a container we pinch to zoom in
we show the components beside it and
someone so forth it's just a really
simple set of hierarchical diagrams the
map onto that language and ultimately we
get to the code and ultimately ideally
there's a nice clean mapping between all
of these layers and and this actually
does reflect what the code looks like so
for me diagrams and maps well that's a
summary all of this stuff basically
diagrams and maps and you need different
types of maps depending on how much
information you have about the thing you
want to learn about or the audience that
you're speaking to so business people
non-technical people a nice high-level
view works well me as a developer
something low level maybe some
operations people something in the
middle I don't want you to take away any
tips around a notation this is the
notation I use just because it's very
very simple and I tend to use things
like color coding and shapes to
supplement an existing diagram that
already makes sense so this is the same
diagram one version has some shapes
which ones you prefer probably the one
with shapes but fundamentally there's no
more information on either diagram it's
just an aesthetic thing I also think
it's worth just pointing out that there
were lots of other things you might want
to consider when you're describing your
software architecture and this is where
although the views and viewpoints and
perspectives stuff comes into play and I
will point you a fillip Christians work
as well and Owen winters book this c4
thing is not a design process it's just
a set of diagrams and it's a set of
diagrams that you can use during an
upfront design exercise or even
retrospectively so if you have an
existing code base with no documentation
this is a really good starting point yes
I get this question a lot what Tony do
you recommend
please don't say Vizio again because
this is just a set of boxes and lines
any general-purpose diagramming tool
will do Visio OmniGraffle Gliffy
whatever you choose but come on this is
2016 there was an interesting plea for
help from Twitter recently what what
tools are there for creating
architecture slides nobody responded
with a modeling tool it was all
general-purpose diagramming tools which
i think is just nuts
and if you look at the building industry
the building in suite does not use Visio
the building industry creates a
three-dimensional model of their
building and they surface different
views from it the RN again of course is
we build these tools for the building
sector and we can't do this ourselves so
I'm trying to solve lots of problems
here and and one of my approaches this
is a set of tooling called structure
item I start trying to is part it's kind
of SAS product part open-source it's
very simplest form you can write a
simple domain-specific language to
create some diagrams so this is
religious and implementation of the
people software systems containers
components thing I briefly showed you
before it's like we've seen things
diagrams if you've seen that this is
great for sketching up something small
and simple single diagram at time but
it's not really where we want to go if I
have an existing code base why can't I
just alter generate diagrams has then we
tried this what happens you just get
chaos is that because your code base is
chaos sometimes but often not often it's
just showing too much detail so one of
the things I've done recently with
structure Iser so structure is all
cloud-based and lots of my potential
customers like it but they don't want to
send their software architecture long as
up to the cloud so I built very simple
on-premises API because structure is the
constructor Iser is essentially a
JavaScript app running in the browser if
you install an API that you can reach
locally you can store the data locally
it's about less than thousands lines of
code and this is what
that code looks like if you ought to
generate a UML class diagram in some
tooling it's not particularly useful is
it it's showing us all of the code level
elements and all of the relationships
between them and it's hard to really
pick out what the important parts of
this code base are and this is a really
really small app like less than
thousands lines of code what happens if
you point this at a hundred thousand or
a million lines of code you just get
crazy crazy diagrams and the reason is
that these diagramming tools see codes
not components these diagramming tools
are usually unable to zoom up to show
you bigger abstractions it's essentially
the model code gap thing again and we
can trace this problem right back in
time there was a paper about that this
problem in the 90s the first two opening
paragraphs basically say if you ask an
engineer to draw a picture of their
software system you get a nice
high-level view if you reverse engineer
a diagram from the code you get
something totally totally different the
reverse engineer diagrams super accurate
of course but it's not how the engineer
thinks about the world and it all comes
back to this question well what is a
component if I want to draw a component
diagram I need to understand what a
component is and if we go back to my
little class diagram here these two
boxes of highlights is really what I
consider to be the components in this
little API app I've built there's a Java
servlet handling API request and there's
a workspace component that's dealing
with the structure Iser workspaces
you've heard of service this is
framework lists this is like the
simplest implementation you could
possibly write and all of these other
code things are just parts of those two
components and again this is what the
code structure looks like so I've got
two major components with a bunch of
helper code essentially now we often say
that the code is a single point of truth
the code is the final embodiment of all
the architectural ideas can we get that
information back out of an existing code
base and the answer is not really so if
you were to give me your code base could
I generate something like a context
diagram automatically by looking for
references to people and software
systems in your code base and the answer
is no because they don't really exist we
don't have this information in our code
bases meant much at the time the same
with containers can I get
list of the containers just by scraping
data from your codebase there's some
information in there but it's kind of
hard to find when I get down to the
component level this is really the level
I want to generate automatically because
it's the most volatile and it changes
the most frequently George Fairbanks to
the rescue
George Fairbanks says we should adopt an
architectural encoding style anyway
you're doing this you should it's a
really a George's fantastic so it's a
really really simple technique and it's
simply about embedding information into
your code base so that your code base
reflects your architectural ideas and
intent this sounds very kind of high
level and and wofully in concrete terms
it's just stuff like naming conventions
so if you have a log in components on
your architecture diagram make sure
there's something in your code base
called a log in component maybe it's
about our name spacing or packaging
convention you know one folder one name
space one package per box on the diagram
or maybe it's machine readable metadata
annotating stuff to be this is important
this is a component for example and and
by using this we can then extract really
useful information from a code base and
supplement it where that information is
not possible and I want to move away
from drawing diagrams in Visio there's
something called an architected
description language I'm guessing no
one's ever heard of it and no one's ever
used it and it's because it's never
really entered mainstream industry but
an architecture description language is
essentially a textual description of say
the static structure of a software
system there are a bunch of them out
there Darwin Darwin or koala for example
but the syntax is are horrible and you
have to teach developers another
weird-looking language just so they can
describe the piece of software that
they're building but this is a fantastic
concept because we're not dealing with
pictures with dealing with text and as
developers we like text we can diff text
we have two liters for text so let's
take all of these things chuck them in a
pot stir it around and come up with an
art architecture description language
using code using general purpose code
the same code we
using to build our systems and that's
the other piece of structure Isis so
there are two open-source libraries and
basically they are a very simple
implementation of the c4 stuff again
there's a bunch of classes in both one
for Java one for dotnet
and and they let you create people and
software systems and containers and
components and wire them together to
describe your software architecture so
let's have a go using this for
describing my little API thing so as a
user a person the person the software
developer is using my structure eyes of
product and structure eyes he uses the
API to deter store information locally
so again we can just write up some code
to create that little model and then I
can create a system context view by
adding the appropriate things to my to
my diagram and the net result is very
simply you get a picture like this from
code like this this is a very very
simple way to describe the high-level
structures of a software system we go
down to containers it's just the same
deal so from a container perspective
essentially all I have is a little API
server it's a web app as a java web app
destroying information on a file system
so again we can create a cup of
containers we wire them together which
is using some method calls and we can
create some diagrams so basically you
write code to get pictures this is great
for the high level stuff once you get
down to components you don't want to
have to do that so this is why the
open-source libraries have some
component of things in and the component
finders find components see names are
not hard after all now the question
becomes how do we find components and
the answer is it's up to you because
every code base is different and this
comes back to the architectural evident
coding style thing so if you have a
naming convention that your team's
adopted you can go and find components
based upon that naming convention if you
used a framework like spring you can go
and find spring annotations and call
them components and so on and so forth
so lots of different strategies you can
plug in to find components this is the
code I use to find the components in my
little API application got a couple of
different strategies here I want to find
the things ending with the word servlet
and I want to find the things
that I've annotated with my own special
act component annotation find them why
them together and actually there's some
some some logic behind the scenes in the
framework that goes and finds the inter
component dependencies and that's sort
of diagram you get from that so that's
the API servlet component that it found
and that's the workspace component and
it's identified the relationship between
them you might be wondering how did that
text get on there and the answer is you
have to add some more metadata to your
codebase to do that
this is really about creating a model so
I want to get people away from using
diagrams and back to using modeling as
an approach for describing software and
because once you have a model you can do
lots of really interesting things like
generate diagram keys automatically yay
and then will hold one notation we don't
understand because this is a model we
can do things like hyperlink the model
to the code so if you go online and you
find these diagrams you can double click
any of the components it takes you right
to github it takes you to the exact
implantation of that thing and again it
comes back to the maps thing right
diagrams and maps this is a funny tweet
388,000 pixel wide picture my reason for
including this tweet is basically does
such an approach scale and there's no if
you use it naively so this is what
happens when I through my own tooling at
one of my own web apps all of these
things are web app controllers and these
things are components my goodness is
horrible I don't think the codes
horrible the diagram is horrible and of
course making the diagram canvas larger
does not help one bit because you still
have the mess it's just spread out but
because this is the model you can do
some interesting things like don't show
me everything show me a slice through
the system so for example we can say
what's a slice well maybe it's a slice
starting from a web app controller an
entry point to your system and show me
that slice until you drop out at the
bottom of the app so basically you can
create a larger number of much much
simpler pictures so that's my approach
for dealing with complexity and scale
once you have a model you can throw it
in
lots of other types of tolling so if
you're a graph is fan part of the jar
open source library as a graph is
exporter so that a crates a dot file you
thought of dot finds graph is it auto
generates diagrams for you if you hook
all of this stuff up to your build
process guess what happens your
documentation your diagrams remain up to
date when your code changes and that's
ultimately what I'm trying to get to
here so the title of this talk was
visualized document Explorer so we
should talk about documentation really
quickly a lot of people are no longer
documenting anything I know that sounds
a bit extremist we have our friend the a
da manifesto to thank for that it's all
rather people's misinterpretation what
the agile manifesto says about
documentation and of course if I did
drop you into a project that's
unfamiliar to you a code base that
you've never seen before you do get that
kind of where am I in this leafy lane
and you have to start zooming around and
exploring and trying to figure out where
you are and this takes time that Lane I
dropped in right at the start you could
keep walking until you met somebody and
ask them where am I
where's the nearest X for example but
it's just gonna take some time and of
course once you explore in the code base
the code base actually doesn't tell you
everything you want to know the code
doesn't tell you the entire story
especially around things like rationale
and intent you know why were these
decisions made that's often missing from
the code base and often teams have lots
of tribal knowledge kicking around as
well you know specialisms and experts in
particular parts of the code base and
that's financed all those people leave
or they get run over by the proverbial
London bus the thing is the bus factor
as we call it is not just about buses
you know imagine you have a small team
here one does get run over by a
double-decker bus by by someone goes on
sabbatical for a year and we have to
fire somebody because they're useless
and now we have a smaller team and the
smaller team starts saying things like
you know that thing there that we have
to run every week what is it oh right
and again that's a kind of extreme thing
but that III have seen situations like
that occur so how do we fix our
documentation problems will we write
some documentation and this is where
those sad comes into play and it's
called the sad because it makes you sad
and there are lots of templates out
there for this sort of thing every
consulting company I've ever worked at
its created their own rap has one there
are lots of them out there and these
sort of software architecture documents
normally includes some really
interesting insightful information how
do we get to the design what were the
design decisions what is the
architecture how do we look after it but
these documents tend to be just horrible
hundreds of pages use you know
out-of-date totally useless how do we
fix this well it turns out naming as our
friend what I do is I just rename the
document and all the problems go away
and they call it a guidebook like the
Jersey guide bit thing I talked about
the start you know if you go if you come
to Jersey you buy a guidebook it has a
bunch of maps to help you navigate an
unfamiliar environment it shows you the
sights and the itineraries the points of
interest the things you really should
come and see it talks about the history
in the culture how did you get to where
it is today
and there's all the practical stuff and
again if you take that metaphor and
apply it to a software system you get a
really really interesting set of
documentation so it Maps the diagrams
you know show me what the code looks
like how do we explore the code base
which parts of the code base are useful
to understand which parts are important
because most stuff isn't how did the
code base evolve to where it is today
and how do we look after it this is my
single tip for documentation just
describe what you can't get from the
code base that's it it's as simple as
that right knock it up a level of
abstraction and make these things small
you know don't have hundreds and
hundreds of pages of stuff that becomes
out-of-date you know make these things
as small lean as possible
they're really kind of living breathing
evolving style documents this isn't the
big upfront design we must create a sign
up front sort of approach this is a
supplementary piece of documentation
that sits alongside the code base and
it's a product related document a
software system a document supplementary
document this doesn't mean you can't do
project documentation as well but every
software system should
have a user guide essentially how does
the software work you choose and okay
it's the tooling thing again you know
what Tony do you recommend for documents
a lot of people so we use word that's
fine
SharePoint if you really have to lots of
people using confluence but I'm seeing
more and more teams the tops of things I
asked your doc a markdown and they're
creating nice little you know
documentation files and their stick in
the documentation files next their
source code in source code control and
then they do stuff at Build time you
know generate HTML uploading to websites
and wiki's and so on so there's a lot of
opportunities for using different
tooling here and again there's something
I'm trying to do is structure I want to
create a software architecture model
that contains both the model the
visualization stuff and the
documentation so this is the code I
wrote to document my little API
application it's a bunch of simple
markdown files you upload it as part of
the model and some documentation is
basically generated for you that's it so
again are trying to keep all of this
stuff and what in one place and you can
also embed diagrams in your
documentation so again these things are
together where they belong there are
some other purchased documentation so
this guy's seeing lots of really
interesting stuff around living
documentation he's got a whole bunch of
little tools open source of github that
you can use for creating documentation
from code for example and these guys in
Germany have a software architecture
document they call arc 42 and it's a
really really nice lightweight lean
approach to documenting software systems
it's very similar to the approach I I
typically take and there's lots of
content lots of free content that you
can grab on our 42 people say how long
should a document be and that's the
wrong question to ask well how many
pages is the wrong question to ask if I
join your team what I'm really looking
for is a document I can consume in like
one or two hours over coffee or two to
get a good jump off point into the code
so I can go and explore in a much more
structured way much more structured
manner but speaking of exploring once
you start to model your software you can
do some really interesting stuff with it
so you can do things like you know
create a Java Script d3 visualization of
the static
it's just a tree structure so this is a
model of at one of the sample
applications from the spring team it's
called the spring pet clinic and this is
just the software system containers
components you can do things like let's
find all of the interesting component
dependencies you know incoming and
outgoing dependencies you can do things
like let's rate our components based
upon size from complexity so again once
you have a model you can do some cool
stuff with it you can throw it into
neo4j if you really want to why not you
know the software architects well
there's just a directed graph he
threatened to neo4j you can query it was
cipher right people are actually doing
this there there's a there's a whole set
of tooling called JQ assistant that lets
you do this run it against your source
code you set up some rules and basically
it pops it in to neo behind the scenes
it's awesome and these guys em peer
they've created a set of tooling that
runs against your source code
repositories and not only they doing
static analysis but they're also
superimposing the human aspects on top
as well so they can look for things like
we have this one thing here and it's
always changed by these two different
teams why is that
you know maybe we've got the component
boundaries incorrect in this particular
instance so again this is a really cool
technology there in summary there was a
virtual panel about software architects
documentation from 2009 some people you
might know one hero in woods on here of
course and it says things like we should
be able to see the architecture in the
code we should be able to embed this
information in the code we should be
able to get the documentation from a
click of a button for example you know
it's really about automating as much
this documentation as possible I don't
think we're there yet but I think we can
get there and we are starting together
of course my summary is really that
diagrams and maps treat your software
architecture diagrams as a set of simple
maps that describe your codebase at
different levels of abstraction any
documentation you create should describe
what the code doesn't it's as simple as
that
and yeah the 1990s cording they want
they're talking back right stop using
Visio please stop using Visio and if
you're gonna say we don't use Visio we
use Gliffy it's the same thing stop
using that as well stop man
during boxes and lines to describe
software architecture all of the tooling
aside my final closing comment is very
very that very very simple
whenever you're describing software make
sure within your team you have a
ubiquitous language to do so that's me
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>