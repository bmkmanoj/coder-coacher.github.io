<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Massive Acceleration through the Many-core Processor • Jesper Mosegaard | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Massive Acceleration through the Many-core Processor • Jesper Mosegaard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Massive Acceleration through the Many-core Processor • Jesper Mosegaard</b></h2><h5 class="post__date">2013-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zqCa52EJpQY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk is is going to be about GPUs
I'm going to talk about the history of
why deepu's came to be what they are
today I'm going to talk about this
because it shapes the way we program
them when we do it through khuda aur
opencl or whatever kind of way you want
to do it I'm going to show you some
cases of how we've been using the GPUs
for for a couple of our project in
collaboration with the companies and
then I'm going to speculate just a bit
about the future of it so where are we
heading and is this something you should
use if you have a product a software
product you want to accelerate it and
and what is it you want to think about
what kind of questions do we want to ask
yourself and so just a word of caution
this is not going to be a lecture about
CUDA so you're not going to go from here
and having learned CUDA you're not going
to go from here have you learned opencl
I'm not going to go into that kind of
detail but I am going to go through a
number of projects and because I'm a
graphics person i'm going to show you a
lot of pictures and i'm going to talk
about what kind of an experience did we
have building these products and and
what are the potential pitfalls and what
it is what is it you're going to try and
look for if you want to accelerate stuff
on the GPU so the historical review
before the Avenue of the of the GPO
before the GPU even came up before there
was anything called hardware accelerated
graphics cards there were games and
these games were incredible so this is
in my youth so I love playing games i
played all these games and the games
experimented a lot with the way they
showed graphics so i took two examples
and these might not be the best you
might have your favorite game how many
of you play games okay very good I'm
happy how many of you play games still
ah very good so so these two games I I
put up here because they're special and
they're special and in the way they show
graphics and this will make more sense
when I talk about how graphics is shown
today so on your file if you have the
game called outcast okay was an
incredible game didn't really get the
attention span that that was actually
that it could have gotten because it was
great but the thing I want
you to take from this is that their
graphics engine was based on height
fields for the terrain and they use the
technique called ray casting so casting
rays into this height field to determine
where the surface is and this is this is
a bit different from what you usually do
in graphics on the other side we have a
game called Comanche total overkill
something like along those lines a great
helicopter game this game was based on
the vocalization of the entire game
world so everything you see up there you
can almost actually spot it is made up
of small cubes and these small cubes
have colors and and then you want to
build a graphics engine that can that
can display all these cubes very fast or
make the choice of which groups to show
very fast so these two examples are
meant to be examples of the creative
freedom that the gaming industry had at
this point in time and then
unfortunately came the dark time of the
hardware accelerated graphics cards let
me give this touch up this is a
comparison between software rendering
and for a game called havoc in 95 and
then the hardware acceleration on a
graphics called called the graphics card
called the s3 verge and this was
actually the first graphics card that I
had in my machine when I got my pc so
this is this is a kind of hardware
accelerated graphics a you might see at
the time so it looks good this is a
software renderer and it looks horrible
in some sense so what the what the
hardware acceleration at this point gave
was very high resolution stuff that was
essentially what you got because
essentially those graphics cards could
Hotwire the kind of computation needed
to be done to show something on screen
so we could have very high resolution
graphics unfortunately it also meant
that we lost the the ability to
experiment with the graphic scented so
you couldn't really efficiently make a
voxel engine you couldn't make a raycast
at hyde engine as in the two previous
examples so in my mind all the games
although they were very exciting they
they also kind of look the same so
everything looked like triangles with
the we
the something painted on top of it in
essence textures oh by the way ask
questions I mean just interrupt me ask
questions if there's anything you want
to know or details of it I mean such as
how far did I get into battlefield 1942
so then came along the GPU in 1999 so
everything important kind of happened
along along or in the in the in between
the year 99 and 2000 so that was really
a great time so the GeForce 256 was the
world's first GPU at least I was a
marketing term of it so Nvidia came up
with this term the GPU to to emphasize
that this could really do something or
this was a computing engine but actually
there was nothing programmable at this
time you couldn't do anything really
flexible with it it had a something
called integrated texture and lightning
so where you could all of a sudden a lot
of the graphics things that you had been
doing on the cpu was pushed onto the the
TPU and in essence this meant that that
things got even more tightly bound so
there was only so much you could you you
could do but then you got a lot of
features so you could do environment
mapping meaning that you could get
reflective surfaces and then I truly
don't know but this is the marketing
material again from Nvidia so without a
GPU you have one kind of truck and then
it magically turns into another kind of
truck if you have to TV I don't know I
mean and they really like trucks and
cars maybe because they are so clean and
shiny and it fits nicely into what they
could do so but then came came the first
programmable cards so this was in
2000-2001 they started by being not very
programmable actually we started by with
having something called register
combiners in which you could do
something very very simple on I'm trying
to combine different parts of the
pipeline but then came actual
programming languages or or in the
beginning actually this was more more
along the lines of assembly language and
in 2002 we got something that was truly
programmable so what did it mean it
meant that as vertices are transformed
into pixels on the screen
each of the steps in doing this can be
programmed or these some of them so for
each vertex you need to do something
with it you need to transform it in
space either because you move your head
around or because you want the object to
move at this part so for each vertex we
could actually allocate a program it
would be the same program running for
each of the vertices we can program it
ourselves also for each of the fragments
that is a final color run on the screen
at least for the topmost fragment we can
also program this one again in an
assembly kind of language I gave i have
here an example of kind of for you to
get the feel of it so it was it was it
was quite fun because there this is this
is something you cannot see from this
but there were a lot of limitations of
what you could do and I mean for those
of you who who kind of love that feeling
of working with it within tight
boundaries there were a lot of type
ivories here and that was really fun so
actually I was one of the guys who
thought that it was kind of sad when we
got the high level languages because all
of a sudden you could do anything and
anyone could do anything but then again
i'm going to talk positively about this
in just a few moments so we're having
the power of doing fully programmable
parts of the graphics pipeline meant
meant that you could do magnificent 3d
graphics effects so this is one
particular demo I didn't bring a video
unfortunately but just for you to get a
picture of a nice lady who can all of
the sudden be shown in in great d a
great amount of detail because we have
the programmable parts of the vertex
pipeline and and the fragment programs
and this this means that we can get the
accurate details in the way she moves
the way she's skinned and also the
appearance of the skin and of course
doing programmable graphics this way all
the sudden opens up for the
possibilities that we had before the
hardware accelerated graphics cards so
all of a sudden we had the creative
freedom pac which was nice because it
meant many of the games and and I didn't
bring pictures of it but many of the
games from that point and on look
incredible because there is a lot of
freedom in how you express your graphics
engine and then how your content guys so
the graphic scientists can actually
produce stuff so there are of course a
lot of books
there are a couple of high-level
languages that came along this period so
2002 and two thousand four you got
various versions of high-level shading
languages so CG hlsl are more or less
the same in video and Microsoft
cooperated on these and also there is
you can call them more widely or
possibly more more widely adopted
version of this called years a GL SL
which is a acronis standard there's the
standard standardization government for
for opengl stuff so you got high level
languages so all of a sudden you could
write things that were much easier to
both read and and right so things could
also be very simple if you just wanted
to do the multiplication of matrices and
something coming today the the the
graphics pipeline is very programmable
in the sense that there are various
elements in what is the graphics
pipeline is programmable so you can have
programmable vertex shading fragment
shading but also stuff that has to do
with how you can tessellate stuff and a
geometry shader and you can pass
different information through the system
and back into the pipeline again to work
on it in an iterative manner you can
have a offline memory that you can work
on not show and then use as some kind of
temporary storage and it and it seems to
be getting more and more general a
before before jumping into what you can
use these programmable graphics cards
for in general i'm going to show you
some examples of what you can use them
for their or what they're meant to be
used for initially so these are some of
our projects so we work together with
Lego to be to to help them get from the
three point O to the 4.0 version of
what's called lego Digital Designer in a
lego Digital Designer you can you can
construct lEGO models digitally it's a
it's a piece of software that's freely
available and then when you've designed
your entire piece or your entire model
you can press on the buy button and then
they
will tell take all your money and give
you a 3d model that you can that you can
assemble at home this was a great
product upgrade project because I could
play with Lego and of course we had to
have real Lego bricks and of course I
had to choose the biggest one of them
all so there was this was fun the taj
mahal took about a week to build using
using an hour to each evening so this
was a link of digital designer this is
kind of your standard 3d graphics
there's nothing fancy about it it's just
a basic basic lighting of a very soft
surfaces there's no texture or anything
on it this was kind of the look that
Lego wanted at this point in time but
then again if you want to build with
Lego bricks it's something that is
normally very tactile it's something you
have in your hands it's something you
feel you feel the bricks Monday click
together and you also know where you can
put different bricks because of what
they feel like or because of what you
see having things on screen leaves a lot
to be wanted so there are a lot of
things I cannot see because I'm I'm
blind on the 1i also there are no
indication of what is close by the no
shadows there's no kind of reflections
of things so it's very difficult to see
anything so we help they go do this so I
hope you can see the difference beyond
the fact that it's darker so we put in a
lot of shadows soft shadows just to
emphasize the fact that things are
closer by or are further away from each
other we also put in reflections down
here for example all we put in the
darker shadows of along the tree in
essence what we calculate it and put on
top of what they already had was this
image so this image is a lot of shadow
and it is a lot of green and red which
is just a reflection of stuff now we're
in order to calculate this we actually
need the the possibility of doing
programmable graphics because if you
want to simulate this accurately and I'm
going to talk about that in a moment
it's something that takes a lot of time
it's something that's difficult to do so
instead we cheat so what we actually do
here is to make a height map
of the screen so we had have the height
of each pixel and then for each picture
to try and ask for the neighboring
pixels okay so am I in a crease am I
deep down in some pocket in that case I
want shadow am I on top of something am
I on a rich in that case I want to
highlight the same goes for the color
reflections okay am I nearby some kind
of red surface then I should be red mi
nearby something that's green then okay
I should be green so the only thing I
actually need here is for each pixel
program to be able to to read what is a
color value of anything else that's
around it and what's the height value of
anything that's around it and and again
to be able to program that so that query
of what's around me and the choice or
what kind of a color I want to be you
need the programmability of graphics
card to get that we worked a bit a bit
more on this and and in our field we are
very inspired by what happens in there
in the gaming industry not because we
can always use it but because sometimes
there are actually some very very nifty
tricks so one of these nifty tricks is
in a paper by by the gaming company
Crytek this is something called cascaded
light propagation volumes for real-time
indirect illumination we also want long
titles so this was a method that could
enable these kind of color bleeding and
also these kind of of almost glossy
reflections which is something that's
normally very difficult to do the way
it's done is that you have a big grid of
values of light it's actually encoded in
something called spherical harmonics
doesn't really matter but you have a lot
of light in a big volume and and then
you just propagate light through this
volume so if you know the direction of
light is this then you can propagate it
on in that direction in this big volume
of values of life but you could also
propagate it into an object and this is
what we did here this is called this
effect is called subsurface scattering
it's if the view is running I could show
it to you so when light hits a surface
are the video is running very slowly but
one frame per ah ok so believe me this
could run in in real time it's just a
video and so in essence we take the
light when it hits the surface and
propagate into the object and that is
what subsurface scattering is so it's
the light hitting something for example
my skin and then it will exit the
surface add another position on on my
skin and that's what gives this a very
smooth appearance and actually a lot a
lot of what you see in the face of
another person is subsurface scattering
because we have a lot of pores you don't
see those you don't see those because of
the very soft light the subsurface
scattering gives to the skin going to
show you the last project again to
emphasize the way the programmability
gave us a lot of power in doing doing
stuff in in graphics directly for
graphics so this is a molecular
visualization and this is made for a
company at first because they just
wanted this stick and ball a kind of
visualization but it was too slow so we
accelerated it 500 times by using a
special technique that is based on
calculating these shapes analytically
then we can put some additional surfaces
on top of it this is called a connolly
surface it has a specific definition
that's not very important here but
basically we can calculate it based on
the distribution of atoms and
specifically a specific kind of energy
but the calculation of this is done on
the GPU so this is just just generating
geometry you can do that as part of the
pipeline and then you can feed this kind
of geometry back into the pipeline and
show it again so this is what is
happening here well also mixing with
with this kind of foggy coloring so this
is another kind of technique that you
can use it's called volume rendering
it's a big grid of data values and we
want to show them somehow and in this
case we are going to march through this
big grid of data values and collect up
the colors and then mix it with the with
the traditional triangular graphics here
so all this kind of of programmable
graphics gave us and is still giving us
a lot of lot of possibilities for
being a nifty kind of things in graphics
you all know this probably I hope you do
you all know the multi-core crisis and
everyone was up in arms again around the
year two thousand and and ahead and I
don't know why this came as a surprise
but they came as a surprise to everyone
I guess so now we're trying to catch up
we're trying to find out oh okay what
are we going to do and we have a cover
of good suggestions for how to program
stuff in general so I'm not I'm not
particularly interested in this graph at
this presentation anyway I'm interested
in this one so this is a graph for
approximately part of the same period
anyway showing the the performance of a
traditional cpu and GPU so what I really
want to want you to see here is the way
the GPU just shines okay so the
potential power of the TPU is is really
really great I'm not going to go into a
lot of details of why it is so great it
of course has to do with with the with
the parallelization of it so essentially
a lot of pixels are going to be drawn at
the same time it means that the same
programming is running for a lot of data
it means that you can save cash it also
means that you can overlay different
kinds of memory requests with other kind
of computations so essentially the GPU
is just massively parallel and and it's
a it so if you can fit your problem into
what the GPU can actually do you have a
lot of power you can harness so right
now I think I had a quick look at what
the nvidia is reporting at the moment
they have this website where people can
can put in their their program and they
can tell you how much they actually
accelerated it and I don't know how much
of it to trust because part of it is
marketing part of it is how much energy
did you put into your CPU implementation
but anyway please people are reporting
stuff like a thousand times faster okay
so that might be a bit too much but in
our experience you can definitely get a
factor of 50 so something that is 50
times faster and that in our case is
that at least have opened up entirely
new possibilities of how to actually
explore
it or how to actually use these kind of
programs so I kind of feel like this
little guy so yeah I exploited the GPU I
got this crazy speed up so what what on
earth am I going to use it for so before
before talking about that I want to talk
about just a bit about how I got into
this because because at some point in
time there was a guy called Mike Harris
he was a PhD student he did a paper
called physically-based visual
simulation on graphics hardware he was
one of the pioneers of this field I just
want to mention his name here he is now
he's now hired by Nvidia he's doing a
lot of TV stuff there so they reported
this crazy 25 times speedup this was a
very very early period of doing a TPU
computation so I thought that was cool I
want to do stuff like this and I was
just starting my my PhD so it's a long
time ago the receding hairline was not
quite so receiving as it is now I had a
bit more hair and for some reason bad
webcam photos was something that was a
fashion so I did a PhD and surgical
simulators for procedures on children
with malformed hearts it meant that I
went into the operating theatre so a lot
of very exciting stuff learnt to
actually cooperate with different kinds
of people from different kinds of fields
but it also meant that I got to do a
program that could actually do this kind
of surgical simulation so this is a this
is a video showing you parts of the
final results of it I hope so the idea
is that we would take a patient a child
into an MRI scan we would do a semi
automatic segmentation of the entire
heart get the 3d shape of it and now we
wanted to give the surgeon's tool to
prepare for the actual surgical
procedure we started out just
implementing everything on the cpu and
for the amount of detail that the
surgeon wanted it was simply running too
slow so this was meant to be an
interactive tool this was meant to be
something they could take into the hands
and use because that is the way surgeons
work so they go into the operating
theater and they do take things into
their hands are like a
Adventist in that sense but we did get
it up running interactively both for the
physics system for the visualization for
the integration with these instruments
that are actually force feedback devices
which you cannot see right here and we
got it up and running because we used
the GPU and this was a quite early so a
lot of what we did was to fight with the
limitations of the TPU and I thought
that was very very fun and I actually
took a hold of the assembly kind of
language for maybe a bit too long
because I found it very fun so this is
in essence the the the representation of
our physics system at that time so where
you might imagine that each of the lines
are Springs connecting small pieces of
mass that's essentially what this is
meaning that you want some kind of local
memory access to to know where where are
the particles that I'm connected to
right now and what does it mean for me I
mean how much should I move towards
anyone else so we had to fight a lot
with the way you can actually represent
data at the deep you at this point in
time so we still had this was around the
time when we got the CD language so
where we've actually we could we could
program high level stuff but we still
needed to map everything to the way the
graphics card works this is one of the
at this point in time major pitfalls of
doing TPU because doing GPU meant that
you needed to know a lot about graphics
and you needed to know a lot about how
to layout things in memory how to and
this the small drawing down here you'll
probably never ever see again because we
were fighting with a problem that's
simply not there anymore so they're at
this point in time there was a
distinction between what was called
independent and dependent vertex lookups
it meant that if we from a previous
stage in the pipeline could could give
an addressing format to a step in the
pipeline that will come after it and and
get it interpolated so just line early
interrelated we will get the speed up
okay so then it's not something you
normally think about how should I how
should I use some kind of interpreter to
interpolate memory addresses okay that's
not a feature you normally have in CPU
programming and unfortunately I mean
it's not something you you will ever
have to do today so those kind of smart
tricks just invalid and that's actually
true for a lot of the research that was
published at this time that that a lot
of the tips and tricks are just simply
invalid today so because the harp i
changed i'm so glad i did something in a
surgical simulation because i can still
show the simulator and say oh i I've
done something with heart so I really
put my heart into it this is just
another image of what we did with the
with the hot simulator and how it laid
out in graphics the reason this is still
a kind of important today I'm going to
re-emphasize this point later on is that
because of the difficulties of doing
something in cooler or in OpenGL
sometimes you actually want to do it in
graphics or through the graphics API
still because the graphics API is
specifically OpenGL and diuretics are
widely supported so that it's very
standardized what kind of a system you
have what is the capabilities of it and
you know that if I have it Daria x11
something something car then it is going
to run the the specific version of the
shader I need and that is something
that's actually a bit more difficult
when it comes to the very high level
languages such as good a noble zeal that
we're going to come back to in a moment
so at this point in time you might say I
don't like graphics you might not like
graphics because it's not pretty in that
case I want to show you some more
pictures just to make you make you feel
that images are pretty but there are a
lot of reason not to like the graphics
API so the very limited memory
capabilities of just working with
textures is just irritating to say say
the least you have some some severe
limitations on the shaders you have a
lack of doing integer or bitwise
operations at least at this point in
time also the communication between
pixels was a non-existing all these
direct communication was non existing
and you don't have the option to write
anywhere you wanted to in memory
actually the place you wanted to write
to was pre allocated by the pixel number
your hand and that was a very very
severe limitation in the way you needed
to program stuff so the last one the no
scanner operation that's what we call
when we can write any way we want
actually that is actually one of the in
my in my mind one of the biggest things
that came up with the some of the more
modern languages
so we can program graphics without the
graphics API which is great there was a
lot of early academic work of course the
brook GPU did not in its original form
become cooler but many of the guys
working on the brook keep you came into
the cooler work by by Nvidia but
actually the guys who started it all
kind of started it was a TI with what
they call close to the metal so I was at
the I was at the the session where they
where they introduced this close to the
met close to the metal and it felt like
this Oh big epiphany of we can do
anything we want now we can get access
to the actual hardware because behind
the graphics API you also feel kind of
handicap that you don't you don't have
diarrhea taxes as to what is actually
happening underneath but AG I gave us
complete access to what is happening
underneath unfortunately they they just
gave I mean they just gave us pure
access to it they didn't bring along any
nice tools they didn't specifically put
come along with a high level language
for doing anything so it kind of felt as
if they knew that in video were working
on cuda and they wanted to be the first
ones to get this out so this close to
the metal kind of way of doing it is not
something you do today then cuda came in
video came out with cuda and and
probably many of you have heard about
cooler and i'm going to talk just a very
little bit about it as in it is this
high-level language that is not attached
to the graphics API and you can program
your diffuse and you can hon as this a
massively parallel kind of workload and
opencl came out in 2008 it's a it's a
essentially the same as as cooler but
they try to make it run on on a lot of
platforms so it's it's an governed by
Cronus again and then each of the chip
fabricants such as Intel AMD Nvidia they
produce their own the own compilers for
it so we're cool send for this computer
unified device architecture so it's
something that runs on all the nvidia
cards and that is the most limiting
factor of it right now just to say it
and I
going to say it again it runs great it's
relatively easy to program it looks kind
of like see you have to get used to some
kind of parallel structure to initialize
your computation but it's it's
relatively easy to do and you get a big
speed up but it only runs on nvidia
graphics cards which is unfortunate to
say the least if you if you have a
product that is meant to run on the
consumers machine because they might not
have an nvidia graphics card and it it
works in a way that you you have this
abstraction called a colonel and and a
colonel is just an execution of a huge
number of threats each of these threats
if you come from a cpu way of thinking
are extremely lightweight but you want a
lot of them to actually take advantage
of the the GPU and in essence you want
to have one computation and a lot of
data going through this computation so
that's what i call seemed but mostly
because because it's it's it's kind of
different if you want to go into the
details of it the way the computations
are arranged is that you have a grid of
blocks of threats and threats are what
are going to do the actual computation
so the reason they actually divide it
into this blog is that there are
differences in the way that you can that
you can synchronize stuff there are
differences in ways you can that you can
manage memory and communicate and I am
NOT going to go into detail details on
this so this is not a CUDA tutorial
session this is a I want to inspire you
with some projects and what can we
actually do session so just one more
slide on on some of the internal
workings of it one of the things that
you can all of Sun get access to through
CUDA is a series of memory layers in so
in the graphics API we only had texture
and we had off screen and we had a
off-screen memory for writing writing
the final color but but in reality there
is a lot of different kind of layers of
memories that you that you can now get
access to and that's nice especially if
you look at the top part of it we have
this shared memory in and that's nice
because all of a sudden these
pixels can directly communicate open
seal is more or less the same again I'm
not going to go into details of it and
so I got interviewed for a Danish to
called the initial newspaper on the on
the web cultivation two and one of the
comments down along the lines was said
okay open CL and cooler I'm all is the
same because you can just do a direct
translate and that's essentially correct
kula can do a lot more than the OpenGL
OpenGL can it has a lot of a lot of more
features but those features are nvidia
only so it's because nvidia decides
anything they want about cuda and all
the features that they want to implement
but in essence you could do kind of a
translation between between the two and
i'm going to come back to to to some of
my some of my opinions of what you
should do if you're in a certain
situation so i want to talk about three
examples here of where we did TV DP you
work at the Xavier Institute for a
couple of different companies and you
might notice that these kind of projects
are not that different from the kind of
projects I just showed you where we use
the graphics card for doing graphics
because in many of these cases there is
going to be graphics again or the end
result is going to be graphics and but
the way we generated is in a general way
and that's important part so where one
of my colleagues called the Caston he's
one referred down in the paper here he
has been doing a lot of registration in
in medical images and this image is a
case or if you want to do radiotherapy
and you want to do radiotherapy on the
on a tumor but when you want to do that
you want to know where the tumor has
moved and you might say okay the tumor
doesn't move but yes it does because in
the stomach for example everything is
soft so it moves around if you have
eaten a lot if you've not eaten a lot
and it just moves around if you push
your stomach of it so you actually want
these images prior to actually doing the
radiotherapy to overlap perfectly so
that the treatment plan can also be
mapped perfectly to whether two minutes
right now and and you can do these kind
of mappings it's called registration you
can do these kind of mappings
a technique called the optical flow
estimation you can see I put this slide
in ah ok I'm sorry it was supposed to
stay there say 40 times speedup 48 times
sorry so again we gotta speed up this
speed up is important because when you
want to do the treatment plan you are
going to try a lot of different kind of
you're going to try a lot of different
things so you want to get there you want
to get an update as fast as possible and
I really really think this is getting an
update as fast as possible is an eye
opening for a lot of different kind of
feels so if you could put the creativity
back in the guy who actually wants to
use it he can actually produce a lot
more he can Bruce a lot more of a better
quality and and that holds true for
doing a radiation therapy planning as
well and there is some there is a math
here the math in itself is not that
important what's important is that what
we want to calculate is a 3d grid of
displacements this one down down here is
what we want to optimize so we want to
optimize this it's a it's it's it's
essentially not possible to do
analytically so we want to do it we want
to do something so that we can express
it on the graphics cards and in in
essence the e is the energy we want to
minimize under the terms described below
what we then do is to take a number of
steps and again each of these are not
that important what I want you to get
from this is a kind of feel of what it
is you want to do to express something
on the TPU so we took this energy term
and described it in what's called the
euler-lagrange frame of reference it
means that we go from an integral to a
differential equation this is something
we can solve we can use a scheme called
the final finite difference scheme to
actually discretize it and this is very
important because we want to represent
anything of course we want to
discretized and also we can make this
work on a an iterative local update
scheme so this is in essence what you
see down here so if I want to update
this part of the of the of the grid
containing these these vectors that
describe going from one image to the
other I own
need to visit my neighbors this is
something the graphics card is very good
at just visiting to the neighbors and
actually this is exactly the same that I
did in the hot surgical subi they're
just visiting my local neighbors I want
the information I'm going to write a new
value there's a lot more going on
underneath of course but in essence
that's it so we already had this
registration algorithms running about 40
times faster than a normal optical flow
algorithm and we were approached by a
company called brain reader so there
they are spinoff from the University the
CEO is called Jimmy Lee she did she did
a lot of research on the relationship
between the hippocampus that's what you
see and right so inside your brain the
relationship between the hippocampus and
the probability of having Alzheimer's
because because it turns out that there
is a correlation here so what they want
to do is that they want to find out what
is the shape what is the size of the
hippocampus in order to predict whether
or not you have the high probability of
getting getting Alzheimer's in order to
do that they need to map some kind of
scan of a patient to an idealized model
because or what we call an atlas because
the resolution of the hippocampus inside
the brain is going to be very low with
the kind of image mortality we have
today so they need to do a registration
they used a open source program called
mink and mint just gives you a basic
registration tool kit but it took about
four hours to get the result they wanted
to build a business upon this so they
wanted to build this or still want to
build this as a business where you have
web access to a service where you put up
your data and then you get the result
back but four hours is a long time
especially if you want to do the
treatment plan so instead we use the
existing registration algorithm and we
took the time down to about to about two
minutes that's absolutely doable but
still I actually want it to be faster
because two minutes is still where you
go and and take coffee so I wanted snap
so maybe we should set up a distributor
cluster of GPUs
I'm going to show you some more graphics
so this is absolutely not gaming
graphics this is not something you see
when you're gaming but this is something
we can calculate so so where we can set
up again some equations that govern the
way light moves around in a room and the
way material interact with light and we
can write this into a formula it's
actually something that's a bit hairy
too to try and solve so we should raise
out into into the scene we find out
where do these rays of either light or
seen from the camera where do they
interact with anything in the scene and
and what you need to be aware of here is
that a lot of the light or a lot of the
material you actually see is indirectly
illuminated so even if we closed all the
or turn off all the lights in this room
turn off the projector the room was not
is not going to be completely done
because just a bit of light is going to
shine through the curtain just a bit of
light is going going to come from the
hallway and the reason we can actually
see it is that the the individual
photons bounce around in this scene like
like crazy and it means that each of
these photons are going to interact with
a surface of the geometry representation
of such a room a lot of times so there
are a lot of a raised surface queries so
if you want to do images such as this
you need to do a lot of queries of of
the spatial arrangement of this scene
and this guy does a lot of that he's the
guy on the left is called the hillock
vengeance and he is a in our field he's
a famous Danish guy because he did a lot
of the techniques for the skin rendering
in golem and also participated in the
skin rendering of the avatar movies so
he's kind of a graphics hero he has a
company called lukien together with his
brother they're actually located here in
oz and also in a California where and
Ike is living at the moment and they do
a product called keyshot so keyshot
delivers a lot of beautiful images and
you can you can you can interact with
these very very beautiful images
interactively and you can choose
different kind of materials and it's
kinda
I've heard Henrik say that it's kind of
an ipod for rendering but beneath this
is a spatial data structure because we
want to do a lot of queries between rays
of light and geometry and in essence you
don't want to run through all the
elementary primitives usually triangles
and ask for each of them ok so they
intersect you to intersect you to
intersect you firmly all know this you
want to do some kind of tree structure
where you can sort big part of it away
and one kind of example of this is a
bounding volume here a key in essence if
I'm pointing my finger here and I have a
tree representation I can see from the
way B and C are divided or if I want to
point out this that I don't need to
check up on all the primitives over here
I can just check up on what is inside C
and that's the basic idea of spatial
data structures this has been done a lot
for for what is called the ray tracing
so doing these kind of images but the
thing that's not been done a lot is to
try and do it interactively and the
reason we want to do it interactively is
because I mean things move things move
around and again to give the biggest
amount of power to the guys who actually
need to create something either because
I want to create an image or because
they want to create a marvelous movies
such as avatar you want to give them as
many as much creative power as possible
so you want things to run fast and you
also want this spatial actuation
structure to be able to rebuild fast now
if you're not within the if you're not
within the or if you don't love graphics
you can think about this as something
that has to do with the GPS location or
I want a query who is nearby me or I
want to do a propagation of sound or I
want to have a building information
modeling system and I want to know what
is nearby me or I want to know which
services are nearby me if I have
location so all of these things need a
query of some sort now when we did some
some study and on this these kind of
acceleration structures where you can
rebuild things fast and it's based on a
series of paper from from a conference
called high-performance graphics
actually the subsurface scattering
algorithm that we came up with was also
published at this conference so it
started out with something called a
hierarchical lph construction for
real-time ray tracing of dynamic scenes
and this guy called pencil I only came
up came up with the the specific idea
and it's based on another idea called
the called the space filling curve or a
space filling curve called the molten
sequence and how many of you know the
molten sequence not just a couple of you
you should all know it it's marvelous I
think it's it's it's a great because
it's a way of filling your space with a
curve that goes through all the cells of
your space and you can just follow it
from one end to the other it's also a
way of sorting things in space along one
curve and in essence it's these sea
shapes that can be repeated if you look
at the far right up top that are
repeated again and again and again for
various levels of this mortal sequence
the way you constructed is also very
very nice because if you if you just
take your Y and X component of or x and
y component of any coordinate if you
then in to leave the bits just in to
leave them then you're going to get the
mortal number that that's kind of magic
and probably you'll need to sit down and
look at the screen and convince yourself
that this is correct but that's
essentially the way it works and then
what you do is that you sort your
primitives so you sort along the modern
sequence now what you want to what do
you want is what you want to notice is
that each time you shift into another
part of this quadrant you shift part of
the bits as well so I can distinguish
things on top of this line and on the
bottom of this line by looking at the
first bit and and we can do this
consecutively for different kind of
levels of this mortal sequence so if I
go back and look at my very simple
example so I have some primitives number
or 029
and they have they have a modern
sequence or motto number each of them
then I can look at where is where is the
first one and that's going to be the
first splitting in my in my acceleration
structure and I can go down and down for
the next level in this modern sequence
and look at where do they split as well
and this is the basis for an algorithm
in which you want to build part of the
tree as you go along now where I'm both
I both used a lot of time I can see I
have about one minute left so i'm going
to skip a couple of slides but also i
want to show you this one and that when
we read this paper all the hard things
in it were left to the readers an
example so there was so the code and you
probably know this if you if you read
academic papers ever that a lot of the
detail is missing and a lot a lot of the
dhitha was missing here so we didn't
have a deep Parker we didn't have any
source code from the author each time we
got a segmentation fault we got a full
reboot of the system so that was a kind
of way you work with the cuda at that
time and then we wrote to a guy called
kudelka answer so he did the second
version of this one and he is saying she
said to I said wow did you implement it
I didn't I just made something that was
faster and simpler ok so we he did he
did make something that was fast and
simply some of the things you want to
think about when you go ahead and you
want to choose ok so I want to do
something in opencl I want to do
something in CUDA I want to do something
with the graphics API hey you want to
think about you want of course to think
about some things and these might be I
mean very simple or or you might want to
go into some more details of it so
essentially if you want to use any of
these technologies you need to port your
code and you can use what was presented
in the in the last session or you can
code for one of the one of the things
about there now opencl cooler or
something but you really really want to
think about performance because in our
experience we also try to take some
cooler code and then convert it into
some opencl code we also took some
opencl code from some of the main
vendors and try to compile it for some
of the different vendors and in essence
it breaks down almost every
time so you don't get the performance
you actually want it in some cases
simply does not work because even though
you did not mean it you actually took
into account the kind of halfway acted
architecture you're writing to so you
accidentally wrote something that only
runs on gpus although you wrote it in
opencl so it has to do with the with
often the way you were memory is
structured and the way you do
synchronization between things that are
parallel you can actually write
something that works perfectly fine and
actually some of the nvidia examples of
doing a prefix um as as far as i
remember compiled and work perfectly on
the nvidia platform did not work when we
compile it for intel through opencl so
that's just I mean a huge headache so
you you really want to make your choice
what is it I need what kind of platform
do I need here do I need or can I decide
my platform for my consumers can I say
this is going to be cooler only it's
going to be a service on the web and I
can decide what kind of a server I have
or is it something where you want a wide
wide adoption of whatever kind of
acceleration want then you should
probably go for opencl but then you
still want a code path that leads to
optimization for each of the individual
hardware architectures or you could go
for only going through the graphics API
and then it would be more standardized
but you wouldn't get all the
possibilities of actually going into
cooler and the opencl so that's actually
my my one of my last point is that ok so
even though we go for opencl we go for
cadet because it's it's a new plaque
it's a new really great thing use the
cell you should still consider the
normal graphics API for actually doing
these kind of accelerated computations
because you can get a lot of power from
those as well and actually if you want
to go for the web because right now
there is stuff going on there so you
want to do web-dl WebGL which is
essentially whip open the Alpha web but
if you want to do computations on there
you you could look at something called
web CL which is OpenGL for for web again
so that is a great opportunity to
actually do something where you harness
whatever kind of power you have and you
do it just through your browser so I've
already used up my time in a bit more
I'm sorry for that and if you have any
questions I would be very willing to us
it's it's not just programming of the
shaders it's a it's using the GPU for
doing ray tracing so I really wanted to
show this to you so this is real-time
ray tracing just the way we do it and
this is a change essentially also what
they do in keyshot but this is not
through the normal graphics API this is
utilizing the graphics card as something
other than a graphics card but for
graphics and still same time for Katya
so it via nvidia is offering something
called objects for example and then the
objects so is a basic library for doing
raytrace kind of things but you can use
it for for many things so you can use it
for for also asking for visibility in in
in in graphics as well we actually used
it for lego universe with lego i really
wanted to show you that but
sometimes yes but it depends on the way
you paralyzed actually many of the
algorithms that are paralyzed today
might not actually scale that good with
the number of course that are going to
be available so one of the last part of
this spatial acceleration structure that
again I didn't get into a they actually
push toward maximizing the number of
concurrent things that are parallel
things that are going to run because
that is going to be an issue so I mean
right now you you need to think about
thousands of things that run at the same
time but but that curve is just going to
go up so if for example you try to
paralyze something in a tree structure
where you go through the first leaves
first then you have a very very little
occupancy of your parallel processes at
first so some algorithms just mean scale
pulley even though they scale 2,000 of
processes at moment of what you can use
it for and so I know there of course
you've there has been done a lot on pure
math so just I mean matrix computations
because that's something you could
definitely use for as a basic game basic
part of your computations most of what
we've been doing is always graphics
related and and the way I would always
present stuff is that there is some kind
of visualization I can put on top of it
so on top of my mind I don't know bank
but they've been doing a stock what's it
called calculations that have to do with
the value of a stock and they've still
been doing this on the GPU because in
when you want to do very very quick I
forgot the English word for if you want
to do very quick stock calculations to
buy and sell stocks with in very small
amounts of time then then what matters
is latency so you want your data server
or your data center to be close to where
you get the information but you also
want to be quick and the GPUs are sent
you very very quick so it has been down
but with trying to yeah cryptographic
attacks thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>