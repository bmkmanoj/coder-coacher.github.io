<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Deep Dive into Git • Edward Thomson | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Deep Dive into Git • Edward Thomson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Deep Dive into Git • Edward Thomson</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dBSHLb1B8sw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">again my name is Cedric Thompson and
today I'm going to take you through a
deep dive and to get get of course being
the very popular get version control
system how many people are using git
right now at their day job in an
open-source project okay let's make that
easier how many people aren't using it
yet okay so I'm gonna try to keep this
at a level where if you've never used
git before you can still kind of jump in
but I'm not gonna we're not gonna you
know have a getting started with git
session I'm not gonna tell you how to
clone a repository I'm not gonna we're
actually going to crack open a
repository and look at what's inside I
think that if you use git you'll get a
lot of value out of this I think that if
you don't then we're talking about the
internals of a version control system so
there's a lot of great tracks here at
the conference so if this is really
boring feel free to get up and leave
don't don't stay bored at this
conference it's a great conference real
quickly about myself like Lars said I'm
a software engineer at Microsoft who on
earth would have thought when I started
at Microsoft a couple years ago that I
would be talking about get it like
Claire said it's been an interesting way
to get here I hope to see you later this
week and I'll tell you all about it at
code I work on the the visual studio in
Visual Studio online sort of the git
integration into that and I do that I
kind of work at the low-level twiddling
bits inside the repository I work on a
project called Lib get 2 which is a
reimplementation of get in C and then
why do we reimplemented of things like
Malik Malik Malik exit if you want to
put that into Visual Studio you get
Malik Malik Malik don't exit and all of
a sudden Visual Studio is taking up all
your RAM and crashing so lib get to is
made to not do that to be a nice library
that you can call from any application
and then there's front-ends for it for
different languages like so
like Ruby Java so get a nice idiomatic
way so that if you if you want to like
pythonic way to call get you can use
packet and that talks to Lib get to
we're really happy about Liggett - I've
got stickers if you want to put get into
your application come get a little get
to sticker I've got some afterwords and
I talked about get I write about get and
I'm branching out into some video
training about get if you're using get
in visual studio this is a more this is
more beginner approach maybe and maybe
not as nuts and bolts as what you're
about to see but if your team is
thinking about ramping up on get and
your visual studio users I check it out
get for visual studio comm you can sign
up to be alerted when it's finished but
like I said we're not talking about how
to use get in visual studio we're gonna
talk about how git actually works under
the covers why should we care about that
you know I've been doing version control
for a long time nobody ever wanted to
talk to me about the relative merits of
Berkeley DB inside subversion or how the
TFS table layout works but everybody
wants to know how it works why is that
well so if you rewind a little bit
so how git was created it was created
about ten years ago by a guy named Linus
Torvalds if that name sounds familiar
it's because he wrote the Linux kernel
and he wrote it to help him write the
Linux kernel he was tired of the version
control systems that he had been using
and if you go back to sort of the goals
that line is set when he started
creating yet he wanted to be fast he
wanted it to be distributed he wanted it
to have some sort of semblance of
stability in the face of or at least he
would know if there was corruption
what's not on this list is making it
easy to use and in fact he one of his
other points was take any design
decision that the CVS project made and
do the opposite and that's you know
there's there's there's some humor in
that but he was really serious when he
did that and for all of its weaknesses
one thing that the CBS team did was that
they really cared about an internally
consistent and at least understandable
system that they were building get it on
the other hand it has some strange
commands these last four are my favorite
check out does four different things
depending on what kind of arguments you
feed it and if you get them wrong well
it can give you some strange error
messages and if you want to try to avoid
this and read the man pages read the
documentation it's not necessarily
helpful I I work on get like I I deal
with the bits in the get repository on a
daily basis I don't know what the first
one means if you told me that a command
was gonna forward port local commits to
the updated upstream head I would look
at you like you'd grown another head
that makes no sense to me and I know
exactly what that command does that's
the rebase command by the way so I think
honesty with you is important I don't
want to get up here and lie to you too
much but I'm gonna lie to you twice in
this presentation and this is one of
them one of these messages is not a real
not a real thing from the get
documentation the get documentation is
so bad that somebody has actually taken
all of the documentation set it into a
Markov chain and put a website up that
fit makes fake get man pages and they're
almost you almost can't tell that
they're fake if you haven't seen it go
check it out if you're curious it's the
it's the reveal all downstream commits
below the sent upstream paths that's the
fake one I died
yeah it's kind of hard to tell the last
ones particularly onerous because update
remote rests along with associated
objects it should have just been upload
your changes right so I love get gets
like a great tool but it can be hard to
use fundamentally when Linus built git
and when Junio Junio ha mono is the
current maintainer of get great guy very
smart Junio and linus are both way
smarter than i am which is one of the
problems i have when i use git because
the git commands are really just a leaky
abstraction on top of the data model so
understanding how the data model works
can be really important to to using git
okay so how does it work let's let's
back up to the very beginning git is a
distributed version control system that
was one of Linus's goals what does it
mean to be a distributed version control
system distributed version control
systems became popular in the open
source world because you know if I go
into my day job I'm sitting in an office
next to all of my co-workers we're
talking to a central server down the
hall which is good because in
centralized version control you have to
be offline sorry you have to be online
connected to the network available
talking to the server to do everything
if you want to look at history you ask
the yes the server for the history the
server sends it down and you the UI
client you just draw it on the screen
for the user it was a lot easier to
write version control clients back in
those days with a distributed version
control system everything is local
although my commits all of my history
everything is local if I want to if I
want to look at history I just open up
the the repository on my hard drive if I
want to check out another branch all
those branches all the files throughout
history are on my local hard drive I can
also commit locally which is which is
sort of sort of fascinating that allows
me to to work independently of one of my
co-workers because I can commit locally
it actually allows me to do that
independently of my co-workers so I get
a nice parallel model for development so
if I'm working and my coworker Alice is
working we can both commit changes to
our local repositories and then we sync
those up later down the road whenever we
want whenever we're connected to the
network we can send those changes and we
can we can merge our changes together
that's actually a really really powerful
part of git is this this sort of model
and it's the git repository the actual
file formats that really enable this to
work so what does the git repository
look like how does it enable this this
parallel workflow this is this
independent distributed workflow
so this is just an example let's say
I've got up at the top this is my
repository I've checked out something
from the server and it's got three
commits on it so I've got commit 1 2 3
on my server Alice has done the same
thing on her hard drive she's got
commits 1 commit to commit 3 ok now if
we both want to start making changes I
can make a change and commit it to my
local repository it's built on top of
those last ones analyst does the same
thing at the same time now when I want
Alice's changes I want to bring those
into my repository so I'll fetch them
from the server where she's put them and
I'll bring them into my repository
unlike a centralized version control
system where at this point the server
would figure out our changes and merge
them together for us and then give us
back some sort of amalgamation of the
two that it's figured out it doesn't do
that right i download Alice's commit and
it's built on top of commit three still
it's not it has nothing to do with my
commit they're not in any way
intertwined until I actually explicitly
merge them and I get a commit that's the
that's the combination of those two
changes and this is kind of key to how
history is modeled and get let's see if
I can figure out how to do this
excellent so here I've got that
repository that I've been showing you
and I'm going to use if I just look at
the git log it just looks like this is
what you see if you just run the git log
command which is how you look at history
this is what you see on github this is
what you see on Visual Studio online
this is what you see on these websites
and it's just a flat list of commits and
it doesn't really elucidate that sort of
sort of flow that I was showing you so
instead if you use this command git log
- - graph - - one-line you actually can
see how history sort of branches off and
I make my change Alice makes her change
they're both they both point to that
original commit
that they that they both started from
and then they come back together in that
that merged commit that includes both of
our changes okay you can use other tools
you know there's get K there's get X
which opened up way behind here and
pardon me didn't realize I had audio and
they'll also show you this graph so it's
it's really just you know the websites
and the default catalog that tries to
show you this this linear list of
history that that's helpful I like
looking at the graph so because I think
it really illustrates what get is
actually doing okay there we go
so so get actually you know we've we've
seen this graph we talked about this
graph get actually stores its data in
this graph it's called a directed
acyclic graph I failed graph theory so
I'm gonna try to walk you through what
that means it's directed an undirected
graph nodes are just connected to each
other
in a directed graph one node actually
points to the next and so that's so get
actually has direction in its graph and
it's a cyclic if it had a cycle a node
could be pointing back to itself you
know then you have a cycle from one to
two to three back to one you can't do
that so these are actually building off
each other pointing to their parents
commit to builds on commit one commit
three builds on commit to you can't have
commit one building back on the future
which makes sense you know time we at
least perceive it as linear so this this
jives with our our understanding of time
this is the second line I think this is
the last line I'm gonna tell you I hope
so
if so the rest are unintentional we've
talked about these commit IDs as being
one two three and when when I made a
change I got commit for when Alice made
a change she got number five how did we
know who got foreign who got five well
you know in a centralized server it
would just you know determine
who gets the next commit ID and in guid
it's not so easy because there is no
central server so you can't just do one
two three four five we need a better
strategy and get we could use a random
number we could use a gooood
what get actually does is really clever
it actually takes a sha-1 hash of the
contents of the commit and that becomes
the commit ID sha-1 is a hundred and
sixty bit hash so that's 20 bytes so
when you turn that into a hexadecimal
string so that it's nice and easy to
work with so that you're not talking
binary it's actually 40 characters long
so 40 characters in hexadecimal they get
a little unwieldly instead we usually
talk about just the first seven
characters we talk about just enough to
uniquely identify that commit in our
history and that's a little better we're
still talking about a five zero a VCF
which is not which is kind of a mouthful
but it's not that much worse my TFS
server has a million change sets on it
so it's not that much worse than a seven
digit number really what do I mean when
I say that we hashed the contents of the
commit what does that mean a commit is a
snapshot of the entire repository if
you've worked with get a lot of times if
you run git show on your on your commits
or if you upload it to github you see a
diff so it's very easy to think of git
as storing patches from one revision to
another that's not actually how git
stores its data gets stores a commit a
snapshot of the entire repository at
every point in time and especially if
you've got every file in every commit it
sounds like that gets very expensive
very quickly it doesn't and here's how
here's how git gets around that expense
when get builds a commit it builds this
snapshot it points to what it calls tree
objects and blob objects trees are files
blob I'm sorry trees are directories
blobs are files if I have just my first
commit
my first commit in history I'm adding
one file file1 dot txt I have a commit
and it points to a tree that's my root
directory for my repository inside that
directory I have just one blob one file
called file one dot txt and you'll
notice light commits have IDs the other
objects blobs and trees also have IDs so
when we build this when we build our
repository when we build our first
commit we're adding file 1 dot txt we
take file 1 dot txt and we hash it with
sha-1 same same mechanism that we use
for commits and we get its ID and that
becomes its blob ID and then we build a
tree that points to that blob by its ID
in its file name and we hash that that
becomes the tree ID and then we put that
into a commit and we hash it and that
becomes our commit ID when we add
another file so we're taking snapshots
when we add another file our next commit
let's say we add file to text and commit
it we hash file to text and create a
blob out of that file 1 didn't change
its blob ID stays the same so we don't
have a new object for file 1 dot text so
ultimately we're only storing the
changes even though we get a snapshot of
the full tree when we actually look at
the commit when we look at the tree and
of course our tree ID changed because
the it now lists a second file from
before ok let's take a let's take a look
at that let's look at just this second
commit which is 6 9 a 4 6 F see it is a
little unwieldy to talk about them
pardon me there we go so if we if we
look at this is what you typically work
with and I get repository this is our
working directory right I've just got it
checked out I've got a couple of files
file 1 dot txt file 2 dot txt I've kept
adding a few more
and then there's a dot git folder if
you're on Windows this is hidden by
default it's got the hidden attribute so
you can't see it unless you show hidden
files
I always unhide these because I love
actually getting inside they get
directory I mean you know maybe don't
make changes in there without knowing
what you're doing but you know let's
let's poke around right so inside the
dot git directory I have a bunch of
other directories this is actually my
repository this is the database this is
how my repository works and one of these
directories is the objects directory and
inside there I've got a bunch of two
character directory names I said I was
looking at object six nine something so
the first two characters correspond to
the first two characters of the object
ID that's stored there
so my objects were actually just stored
on disk object six nine eight four six F
is just in a file called object / 6 9 /
a 84 six out we can't really look at
that directly if I just open the file up
it's a binary file
it's actually just a compressed file so
instead I'm going to use a git command
called cat file get cat file will
actually just extract this file and just
dump it to the screen so I can see
exactly what get is storing for a commit
and I only again I only have to give it
the first couple characters just enough
of the commit ID just enough to be able
to uniquely find it in the repository
and this is actually our commit again it
points to a tree that actually has all
the changes it points to its parent
that's how it builds the directed
acyclic graph a commit store is a
pointer to its parent there's some
metadata and then a commit message you
know who created the commit and when if
I want to look at the tree that this
commit points to I can use camp file
tree and I'll be really disappointed if
I do it turns out the tree is one of the
very few
formats in the git repository that's
binary just for a little bit of a
speed-up in parsing it I can use a
different command called LS tree and
again I just give it the ID and really
all it does is store the hierarchy of
the filesystem I've got two files in
here file one dot txt file to text and I
can go back to cat file to look at blobs
since nothing binary about them and if I
run cat file blob I just get the
contents of the file so there are these
very very simple file formats that are
combined to make a very powerful system
again if I want to these all these file
formats these commits these you know
text files basically actually build the
structure of our repository if I want to
if I look at my most recent commit it's
a merge commit it's got two parents so
it actually when you walk when you
display the get grant it just starts at
the tip you know your most recent commit
finds the parents and keeps drawing them
that's actually how it draws the graph
okay great
the commits are great but it turns out
that being able to commit in a version
control system is not really so helpful
unless you can also branch if you only
have one branch if you will
everything's going into master and if
you're checking in while you're working
on a feature and Bob needs to ship some
really important bug fix your features
getting shipped to production to and
that's not good so we have branches so
that I can work on my feature Bob can
work on his super critical bug fix and
he can ship that branch to production
while I still keep working and I don't
have to you know live under the tyranny
of Bob's bug fix
branches and get our really clever
branches their entire goal is to
for parallel development we've seen that
get supports parallel development and it
does that in the repository structure
right that I can make a change and Alice
can make a change independently is
parallel development so git takes
advantage of that in its branching
structure get branches they exist at the
repository level so unlike some
centralized version control systems like
TFS or SVN where you've got like a trunk
folder and then you create a branch next
to it another folder get branches exist
at the repository level and they exist
just as pointers within this graph that
we've been creating so they're
exceptionally lightweight they're very
easy to work with that encourages you to
branch often and get you know in team
foundation server you have to be an
administrator to create a branch which
is terrible but you know and get you can
create a branch it only exists on your
local file system nobody else has to see
it if you don't want you know the
experiment that you've done in that
branch you can just throw it away okay
they're really just a pointer in the
graph so if we extend this this this
repository we've been looking at when I
merged Alice's changes which were on her
branch into mine they moved into my
branch okay to see just how lightweight
they really are here in my dot git
folder
there we go here in my Doggett folder
next to the objects directory which is
where all our objects are stored is a
directory called wraps and rest is kind
of a terrible name but there are two
directories inside that heads and tags
tags are for tags which makes sense
heads are for branches which doesn't but
if you can put the the bad name aside if
we go into our heads directory and look
at what's inside we've got a final
called Alice and a file called mine and
these actually correspond to the
branches in my repository right now and
if I get my trusty git log back out and
I run get log - - graph - - one-line - -
decorate and if you get really tired of
typing this this is my favorite get
logged command is my favorite way to
look at history is - - graph - -
one-line - - decorate if you get really
tired of typing this make an alias i've
aliased get lol is what a lot of people
do makes me smile every time I run it so
I can run get lol and so this is what we
saw before except we are now decorating
the branches and width so you can see
Alice points to that commit my branch
points - to that commit and if we look
at these two files that are in this refs
heads directory we can see how that
works
the Alice file just contains a commit ID
the mime file also just contains a
commit ID these are really just pointers
into the graph when I create a new
commit that that number will advance so
it moves me forward if I go back into my
working directory and let's edit file 3
dot txt let's get excited about file 3
text let's change that period into an
exclamation point
so when I do that if we zoom in it tells
us that on the mind branch we've updated
commit number to 3 f9 d 0 6 and if we
actually look inside our refs heads mine
it points now 2 to 3 F whatever so it's
actually advancing that pointer every
time we do a commit ok there's another
special sort of meta branch pointer and
git which is called head that's what
keeps track of what branch here on and
that's also just a text file inside the
git repository so if I look at this file
get head it's so important that it
doesn't even it doesn't even go into a
directory a subdirectory inside dock yet
and actually that's true this is the
only file that has to exist for you to
be a git repository if get seized a file
called head in all caps your get
repository if it doesn't you are not I
don't know what you are it doesn't
matter if you have an object's directory
and a rest rectory you can have all that
other stuff if you don't have a head you
are not a get repository head is just
also a pointer and it just encodes the
name of the repository sorry the name of
the branch that you're on in this case
I'm on the mine branch if I switch
branches can use the git checkout come
in to check out Alice's branch switch to
the Alice branch now if I look at head
point stylist so git switches branches
just by updating that file and then
checking out the differences it's very
very efficient I'm going to switch back
to mine
what happens if I if I create a new
commit let's say we advance VI I can't
even see I changed that exclamation
point back to a period so again
mine the pointer to my branch is updated
to point to the new commit head still
stays pointing to mine so the only time
head changes is when you check out a new
branch and if I look at my my git log
you can see that head has advanced
forward mine has advanced forward ok so
that's that's a the quickest
introduction I can give you to get
branches and how they're stored locally
and branches are great but branches
don't really do anything for you unless
you can merge them right otherwise we're
just working in separate repositories
really and Allison my changes will never
coexist so that's where merging comes in
we've seen merging we've actually you
know sort of Illustrated merging between
Allison and myself already but we didn't
talk about what happens to the branch
pointers when we do that when we want to
merge Alice's changes into ours we
actually create a new commit and update
the pointer to that and we so git merge
is basically a three-way merge algorithm
much like what you're used to seeing it
finds all the files well sorry first it
finds the common ancestor so if I'm
merging my branch into let's go back if
we're merging my branch into Alice's
branch we find our common ancestor super
easy and get an Team Foundation server
and subversion you've got to keep track
of which branches have been merged when
and get you just look in the graph this
this information is encoded within the
graph the last point at which these two
branches were merged or the last point
or the the point at which they first
I've urged is your common ancestor and
you can use this for all three way merge
calculations so to do a three-way merge
you look at the files that are different
in my branch versus aalverson the common
ancestor and the files that are
different between Alice's branch of the
common ancestor and then you have to
auto merge those so you look at the
lines that are different and you just
kind of go step by step finding the
differences that gives you a new commit
and we update the pointers to match okay
what does that actually look like in the
repository great so I'm going to right
now we've we've we've already done this
merge I'm gonna reset my self to the
point at which my branch existed
analysis branch existed and we had not
yet merged them what another great thing
about get I can just run get reset and
that will set my branch pointer back to
any point in time if I run git log now
you can see I don't have Alice's change
right this only has my change I've got a
nice linear history I've I've had the
first three commits that we had in
common and I've created a new commit on
top of that when I run git merge Alice
I'm prompted for a merge message alright
one sorry accidentally typed the wrong
thing I'm gonna create a merge message
and when I do I get that new updated
branch and again it creates this nice
graphical history for me okay
so there's a special kind of merge and
get and that's called a fast-forward
merge and this is something that can
really only exist in a distributed
version control system that uses a graph
to underlie its data store what if I
hadn't made any changes so what if I
checked out a branch and Alice had
checked out of branch and she'd made
some change on it right there had been
some change going into my future branch
and I wanted to merge these two branches
it looks really trivial when you look at
it like this right there's there's not a
lot to do here
and so what git does is it just moves
the branch pointer forward right I don't
I don't have to do the the three-way
merge algorithm because there's no three
ways right there's a common ancestor and
there's my commit they're the same thing
so instead of trying to do some
calculation about which files have
changed in which branch it knows
nothing's changed in our branch so it
can just move those pointers forward and
that's what it does so if you've ever
seen that message a fast-forward merge
has occurred you'll see that a lot when
you do a pull if you have the workflow
where you have let's say a master branch
is usually your your main branches name
let's say you have a master branch and
you keep that exactly up to date with
the server and you only create future
branches you only work in future
branches you never do any work for
yourself and master you'll often want to
up you know get yourself up to date with
the server he'll do a pull from your
master from servers master into your
master and it'll tell you it's not a
fast-forward merge that's what it's
doing when it does that okay so if I
actually go back
if I go back to our common ancestor this
is commit number three that we've been
looking at and I want to merge Alice's
branch into ours
if I run git merge Alice it tells us
that it did a fast-forward okay all it
did was update the branch pointers so
now we're B three zero zero nine was
Alice before now it points mine to that
as well okay
it hasn't created a new commit it hasn't
it hasn't actually created a merge in in
your graph history but it's done the
same thing
effectively in terms of what's in your
working directory it's brought Alice's
changes into ours if you really don't
want to do that you can avoid it and
sometimes you don't right sometimes you
actually want to see how changes were
made if we if we reset back to that you
can say - - no FF when you do a merge
and that will force get to actually
create a merge commit you can see it
says merge done by the recursive
strategy if I look at my git log it
actually it actually does make a new
commit for that okay there's some value
in being able to see how your commits
have been made how your merges have been
made and the actual practice of what's
happened in your repository as opposed
to just using fast-forward convinced I
would only do this on integrations
personally you know if I'm doing a pull
you don't want to create a merge commit
every time you do a pull into master
probably but this is this can be useful
if you're trying to merge a feature
branch into master and you've maybe
rebased it that's a that's a scary word
for a lot of people rebase it shouldn't
be
what is rebasing actually do well
there's there's actually a couple forms
of rebase there's relase Interactive and
then there's just regular old rebase
rebase interactive is a special kind of
a beast but regular old rebase is
actually really straightforward rebase
unfortunately rebase is one of those
commands that I used in the example of
bad get documentation commands we're at
forward ports local commits on to I
forget what it I totally forget the
mechanism behind rebase is actually
really simple here we've got the same
repository we've been looking at where I
have a change Alice has a change we
could merge these commits and doing so
we would get that nice you know
graphical history but if we didn't want
that if we actually wanted our commits
to look more like a centralized version
control system where our commits were in
a straight line that might be easier to
follow it might sort of be easier to
understand when you're looking at
history obviously in this you know five
six commits everything is easy to follow
but in a real workflow where you've got
a lot of people working independently
side by side your graph can get really
gnarly and so rebasing excuse me
rebasing is a way to keep good hygiene
for your graph if you will and so what
you can do is you can actually take this
commit and instead of you know this this
divergence in history you can just pluck
it right there how does that actually
work
what git does in this case is it looks
at the changes between your commits or
commits you can you can rebase several
commits and the common ancestor and it
creates patch files for each one of them
so it creates a patch to get to this
commit from the common ancestor then it
checks out Alice's change and applies
that patch file with you know get apply
patch this is a sort of strange way to
do things
but it's actually really effective and
what it does is creating that patch
isolated only the changes that you had
made in your branch and then checking
out Alice's branch you can apply those
changes
if they apply cleanly great you've got
those changes now on Alice's branch if
they don't you have conflicts and you
have to go resolve them and resolving
rebase conflicts is particularly
terrible because like I said you can
rebase multiple commits at a time and so
you can have to resolve the same
conflicts over and over and over again
so rebasing is not without some amount
of pain from time to time let's take a
look at what actually happens so I can
so at this point I'm still just on the
mine branch and if I want to take my
commit just this one commit that I've
made independently of Alice's and kind
of bring it to Alice's on top of Alice's
branch I can run git rebase Alice and
can I do no commit here
I cannot alas that's too bad
let's actually let's force a conflict
shall we
pardon me so I'm gonna add the same file
at Alice's at it this is guaranteed to
conflict when I try to rebase if I run
git rebase Alice what it's gonna do it
says that it gave a lot of output it
says the first thing it says it's
rewinding headed to replay your work on
top of it which is one of those messages
and get where it's like I don't
understand what that means so what it's
actually done there is its created a
patch file of of all of the the the
commits in my branch that it wants to
apply on to Alice's then it's rewound
the head meaning it's checked out
Alice's branch it then tries to apply
one at the first patch it made which was
my first commit and that succeeded it
had tried to apply the second patch
which we knew would conflict because we
created the same file at the same time
and now we're in conflict
okay if we actually look I'm serious
let's take a look at inside the gate
directory there's this rebase apply
directory and inside there there's a
bunch of stuff and one of those let's do
you think I'm joking is a patch file
that actually this is an old-school UNIX
patch file that describes how to get
from from my first commit to my second
commit and it tries to apply that now on
top of what's on Alice's branch and of
course I can fix up my commits if I'm
old-school and UNIX II I just get a file
with a bunch of arrows in it and I pick
which one I want I can of course invoke
a real free way merge tool if I am not
so UNIX II but you know I work at
Microsoft I'm very UNIX II sorry rebase
continue and and I did a commit in the
middle of my rebase which puts me in a
terrible terrible state and instead of
talking too much about that I'm gonna
reset my way right out of it hey oh my
god I didn't reset my way out of it okay
i'll rebase abort hey there we go we'll
just hand wave and pretend that didn't
happen I ended up accidentally putting
myself in a detached head state which it
in like all good get things is a
terrible thing actually you know what I
usually don't don't dwell too much on
detached heads what does it mean it has
anybody seen this message you're in a
detached head state did you it did keep
your hand up if you knew what it meant
there's a couple of people alright so
what does it mean to be in a detached
head state generally speaking we've
looked at this head file before right
this is the pointer to art your current
branch if you if you detach your head so
to speak oh cheese get there's a bunch
of ways you can do it the easiest way
the most common way that happens is when
you accidentally screw up in the middle
of a rebase because when git does that
rewinding head
it actually detaches your head oh my god
I I'm sorry I can t believe I'm saying
these words out loud they don't even
make sense to me but what it's done is
it's actually checked out just to commit
it doesn't check out a branch it checks
out a commit and that's something you
can do and get if you just run git
checkout with a commit ID it'll give you
this huge warning about how you're in a
detached head state and what actually
happens is your head file instead of
containing a branch it's now it now
looks like a normal branch where it
points to a commit ID instead and so the
same thing happens if I were to you know
edit a file and commit it my head
pointer still moves forward right I
still created a commit on top of the old
one my branch pointer my head pointer
still moves forward but now it's still
just pointing to that next commit which
is really unsatisfying so I'm not really
on a branch and it's really easy to lose
changes this way because there's no
branch pointer pointing to it so if I
check out mine it gives me this big
warning that I'm losing my changes
because they were made on a detached
head so don't don't get into a detached
head state if you do it's easy to get
out of without losing your changes so
right now I'm in a detached head only
head is pointing to my commit I don't
have a branch pointer pointing to it a
real branch pointer
I can totally create an easy branch of
branch okay so now I'm recovered from my
detached head state I haven't lost
anything okay so that's rebasing
real quick we've talked about how the
repository works under the hood real
quickly let's talk about the working
directory and importantly the index the
index contains a list of all of your
files and I can use another fun get
built-in boy
pardon me let's see how I can get out of
this one there we go I can use another
fun built-in called LS files and so this
is my index when you run git add when
you run git RM it manipulates this file
the index is unique to get and it's
actually one of the most powerful things
this is what actually gets turned into
my next commit so if I edit some file
and I run git status it tells me that
this file is now untracked if I run git
LS files - - stage this is probably not
something you want to do on a regular
basis but if you like playing with the
index that's fine and you can look it
you can see that I've still got file1
file2 file 3 if I run get add it adds
file for text to the index so it
actually hashes file for text so when I
run get add it puts the object into my
object database it hashes it it goes in
to get objects 2 5 7 see blah blah blah
and it puts that in the index now when I
run get status it tells me it's about to
be committed so what's actually going on
here is when get shows you status it's
showing you the unstaged changes which
is actually just running the diff
between what's in your working directory
and what's in your index so when we
create a file for on disk it was in our
working directory not in our index it
was an unstaged change when we add it to
the index it becomes a stage change and
it computes that by calculating the
difference between the index and what's
in your head okay
that's the index in a total nutshell it
turns out it uses the index for a lot of
other things but like when you merge all
that goes into the index we're gonna
gloss over that for now sadly we're
running out of time
if there are any questions I will be
hanging around after I apologize I
didn't get to him here probably outside
because I want to give the next speaker
plenty of time to set up but I hope that
you know by cracking open the gate
repository we've seen kind of what's
inside and it's not not such a scary
place really and using it using the git
commands is really just a veneer over
manipulating these objects so by seeing
how some of this works
I hope that you've seen maybe how it
works a little bit better for you please
do rate this session if you didn't like
it let me know why I actually give this
talk a lot so I'd love to know you know
if you don't like it but thank you
thanks for making this your first you
know session here at go-to I hope you
have a great rest of the week so thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>