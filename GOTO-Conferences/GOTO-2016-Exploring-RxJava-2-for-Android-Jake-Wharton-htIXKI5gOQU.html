<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Exploring RxJava 2 for Android • Jake Wharton</b></h2><h5 class="post__date">2016-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/htIXKI5gOQU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so this talk well first let me
start how many people are familiar with
what rx Java is how many people
currently use it in their app okay so
I'm going to start with kind of a little
introduction about why reactive is
becoming such a big thing on Android and
I'm going to do that through kind of
talking about some concepts of why we
need to think reactively and then we'll
start moving into our X Java and how it
actually helps us model model these
things in our apps so I specifically
specifically be looking at examples
using our java 2 which is coming out in
about a month
alright so why is reactive suddenly
becoming something that you know you
hear a lot of people talking about you
see a lot of people starting to use I'm
going to postulate that unless you can
model your entire system of your app in
a synchronous fashion having a single
asynchronous source will ultimately
break the traditional imperative style
programmer we're used to and that's
that's not break in a sense that it
stops working it's break in the sense
that it really pushes a lot of the
complexity onto you and you start losing
the things that imperative programming
is actually really good at so let's look
at this through an example to kind of
understand why I think this is such a
big problem start with a simple class
that has that can get us a user object
and has some mutaters on it now if we're
living in a synchronous world a single
threaded world we can use this totally
fine and we can rely on it to behave
exactly as we expect create an instance
print out the user modify some of its
properties print out the user this
behaves exactly as you expect the
problem comes when we have to start
modeling things in an asynchronous
fashion so let's say that when we change
these properties we now need to reflect
them on the server side so these bottom
two methods now need to become
asynchronous so how do we how would we
change our code in order to
like this one thing you could do is
nothing you can basically just assume
that the asynchronous call to update the
server will succeed and you can make the
change locally so that it's reflected
instantly when we print out the user
object obviously this is not a good idea
networks are flaky the server might
return an error and now you have to
reconcile dealing with your state
locally we could do simple things like
maybe providing a runnable that gets
called whenever this async call succeeds
and now we're actually kind of being
reactive where we're only updating the
data that's displayed when we ensured
that it was successfully changed however
we aren't modeling any problems that
could occur like if the network ends up
failing so maybe we create our own
listener so when an error actually does
happen we could do something with that
we could report it to the user we could
automatically retry and stuff like this
works and it's what people usually the
Avenue people go down when they need to
mix in asynchronous code with code
that's just kind of running on a single
thread which is traditionally the
Android main thread but where the
problems start arising is when you
really have to do more you have to
support multiple calls happening the
users changing you know multiple
properties in your app while filling out
a form or maybe there's maybe there's
like flows of these asynchronous calls
where this the success of the first one
has to then trigger another asynchronous
call which can also succeed or fail we
also have to remember that this is in
the context of Android and so there's a
lot of additional considerations that we
have to take into account so for example
in our success callback maybe we're
propagating information directly into
the UI but I haven't really defined
whether or not or sorry the problem here
is that activities on Android are
ephemeral they might disappear at any
time either you get a phone call and
your app disappears maybe the user
presses home or simply they press
and so if they say synchronous call
returns after the UI has been torn down
you're going to run into problems now
there are imperative ways to work around
this we can you know check some state
before we end up modifying the view so
that's not too bad we also have this
we're creating this anonymous type and
so this will ultimately lead into a
short-term memory leak because it's
going to retain a reference to our
activity and if that activity disappears
asynchronous calls still happening in
the background if you want to know more
about why this is such a big deal peer
is giving a talk later today about
memory leaks which I encourage you to go
to the last thing is that we didn't
define what threads these callbacks are
running on maybe they come back on the
background thread and so now it becomes
our responsibility to imperative ly
write a code write code that does the
thread hopping back onto the main thread
and so we've cluttered we've cluttered
this activity with a bunch of things
that are really unrelated to the intent
of the code which is simply to start
this asynchronous work and handle the
asynchronous result and so this this is
only setting you know eagerly calling
this asynchronous request we're not
dealing with things like disabling user
input handling you know button clicks
multiple fields so when you have code
like this that deals with only the
simple case and then suddenly you start
to turn it into a real app all these
problems can pound and you're left with
managing a bunch of state a bunch of
checks in your activities so this is why
we need to think reactively in our app
because everything in it essentially is
in some way asynchronous it's
asynchronous by default we have our
network which we're sending requests to
and whose responses are returning after
a large period of time
we can't block the main thread for that
so it has to be done on a background
thread we have things like the file
system where there's databases writing
storage even shared preferences where we
can't block the main thread for that so
we have to do them
background threads the user is also
somewhat of an asynchronous source of
data we we push data to them in the UI
and then they react using button clicks
or maybe changing inputs in text fields
and those things happen asynchronously
we're not synchronously pulling user for
data we're waiting until they do
something and this just goes to show
that basically the UI is another piece a
lot of people turn think that you know
you can write these single threaded apps
which by default on the main thread but
really the UI is a piece of asynchronous
source so even if you don't have the the
data component or the network component
the user itself is an asynchronous piece
of information you have to react to
their input in ways that make sense to
them so here's just an example of a
bunch of data flowing through the app
and this is not all happening
synchronously these things happen based
on network speeds happens on disk speeds
happens when the user is clicking
buttons it's just data that's flowing
through the app at different times and
the app has to be receptive and reactive
to that so that you don't wind up in a
state where either the main thread is
blocked or some piece of data comes in
asynchronously when you weren't
expecting it and the app either doesn't
reflect it or just crashes and
ultimately your code in the middle here
is what's responsible for managing
everything this is where the complexity
ends up lying you have you have to
maintain all this state in your
activities fragments or whatever to
reconcile the fact that these multiple
asynchronous sources are producing and
consuming data potentially different
rates and that doesn't even take into
account Android itself Android is a
fundamentally asynchronous platform we
have things like push notifications we
have broadcasts throughout the system
even things like a configuration change
when the user rotates the device may
come at any time and if your code is not
expecting that to come in
you'll run into you'll run into crashes
and you'll run into cases where the app
just starts misbehaving because some
state gotten some state gotten to us a
certain configuration where your app
just completely stops stops reacting so
just to go back to this point if I'm
postulating that a single asynchronous
source ends up breaking imperative
programming if Android by default is
something asynchronous we have Network
requests hard to find an app without
Network requests that's fundamentally
asynchronous you have the disk in
database a fundamentally asynchronous
source and then the UI itself should
ultimately be thought as an asynchronous
source so by default basically
everything in Android is already
asynchronous so by clinging to more
traditional imperative programming and
state management techniques you're
ultimately harming yourself what we need
to do is take this model where our code
sits in the middle as the arbiter of
state and trying to coordinate all these
asynchronous things and instead of
having that we can remove our
responsibility by hooking these things
up directly so we can change the UI to
subscribe directly to the database and
just react when the data changes we can
change the database and the network call
to just react when the button is clicked
instead of us having to receive that
click and then dispatch it
similarly the network response comes
back it'd be nice if that just updated
the data and when we know now that when
the data updates the UI automatically
updates and so we've removed our
responsibility for doing that
if Android does something asynchronously
like starts rotating sends a broadcast
it would be nice if that was just
automatically reflected in the UI or
automatically started or stops some
background job and ultimately this
removes a lot of the code that we had to
write in order to maintain those states
ourselves we're still writing code
there's still code here but all we're
doing is now connecting the bits
together in a way that makes sense
instead of trying to manage the state of
all of them emitting and consuming
events
so ultimately this is where we get to
our X Java and this has become the
de-facto of reactive library for Android
mostly due to the fact that it was one
of the first available for Java that was
really comprehensive and also for our X
Java 2 because it retains support for
all the versions of Java that we need on
Android it comes down to providing three
major things it's a set of types for
representing these sources of data and
then we have a set of types for
subscribing to that data and listening
to when it changes and then finally the
most powerful part is a bunch of methods
which allow you to combine compose
transform that data so we can end up
creating those links between the
different asynchronous sources of data
and the things that want to subscribe
and display it let's start with looking
at what the first two what the first two
look like in the API so a source of data
usually what will happen is it will
start or stop doing some work when you
start listening to it you can think of
this like a network request that's not
going to fire until you start listening
for a response and when you if you
ultimately end up unsubscribing from
that source of data before it completes
it could potentially do work by saying
canceling the network requests these can
be both synchronous and asynchronous and
so you can model something like a
network request which is blocking but
running on a backward background thread
or it can be asynchronous which is
something like something like calling
out to Android and expecting an activity
result or even like clicks in the UI or
can be thought of as asynchronous you're
not blocking waiting for a click you're
just reacting to the fact that a click
happened
usually these can produce a single item
or perhaps many items until like a
network response would be a single item
for a single request but a stream of
button clicks would be potentially
infinite as long as your UI is there
even though you're only you know
subscribing to a single button these
also can be empty and so there's the
idea of a source that really only
succeeds or fails and doesn't actually
have any items you can think of this
like writing to a database or writing to
a file it doesn't really have a response
it doesn't really have an item that it
can you know return to you it really
just kind of completes or fails and so
that completion and failure aspect is
actually modeled by sources in our Java
with these so called terminal events
which are it either completes
successfully or it errors this is
similar to you know a method that can
return normally or throw an exception it
also may never terminate so to go back
to the button click example if we were
modeling button clicks as a source of
data that will never end as long as your
UI is there and when your UI disappears
you're probably unsubscribing from that
source of button clicks it's not
actually completing really this this all
amounts to just an implementation of the
traditional observer pattern we have
some thing that can produce data and
then we have a contract of what that
data looks like and all we're doing is
just wanting to observe that we want to
add a listener to it and get notified
when things happen the two main types
that are going to represent this in our
java two is observable and flowable and
these both actually end up modeling the
same types of data and that can be 0 to
n items so I can you know be empty can
have a single item or potentially many
and then they terminate either
successfully or they terminate with an
error but why do we need two types to
represent the same structure of data
this comes down to something called
backpressure
I don't really want to dive into too
much what backpressure is because it's a
complex topic but I'm going to try and
show you an example which should
illustrate the difference that pressure
is there to allow you to slow down a
source of data you know we're living on
these systems that have
finite resources and you can only
process so much at a time back pressure
is a way to just basically tell the
people sending you data so to slow down
that you can't process it as fast as
they they're sending our Excel one had
back pressure but it was implemented
fairly late in the API process and so
everything every type in the system had
back pressure instead of rx Java to
where we have two types and where this
became a disadvantage is that while all
types expose the idea of back pressure
the idea that you could slow them down
not all sources actually implemented it
so you would ultimately get a crash that
it was unsupported at runtime and this
is because back pressure like you know
like inheritance you have to really
design for it has to be a thing that you
account for up front instead of
something that something that just gets
mixed in later and this this is really
why we have two separate types in rx
Java 2 because you can now dictate in
the type system whether back pressure is
supported or not because if it's not
that's something that's fine but it's
also something that you need to expose
in the API the way the example that
would show this is if we have a source
of data which is say touch events the
user puts their finger on the screen and
they drag it along and this produces a
series of touch events now this is
something that we we can't really slow
down we can't really tell the user you
know draw half of your curve and then
stop and wait while I catch up drawing
and then you can continue the rest of
your curve we want them to we can
potentially do this through other ways
such as like disabling buttons and
displaying other UI to try and slow them
down but the the source of data itself
is not one that can be slowed down if
they've already drawn that curve with a
bunch of events we can't tell the system
to slow down sending them you can
compare that to something like a
database where we have a large result
set and maybe we will only want to pull
out certain rows at
I could say oh I only want the first
four rows okay now give me three more
rows okay now give me five more rows a
database can model this really well as
the concept of cursors but a touch event
a stream of touch events can't model
this at all because there's no way to
push back and slow down the users finger
and so in our example one you would see
both of these types implemented as
observables and what would happen is at
runtime you might try and apply back
pressure and you ultimately get an
exception in your app crashes so this is
the reason why in our java two we model
them as different types because one
fundamentally can support back pressure
and one fundamentally cannot there are
ways of converting between the two which
is basically just applying a strategy of
how back pressure works but I'm not
going to go into that so because these
are two different types they have to
expose this back pressure in some way
but because they also model the same
type of data they also have to kind of
appear the same way in terms of how data
gets pushed into your callbacks so the
two interfaces for listening to events
from these sources look fairly similar
the first method is called on next and
this is the method where items are going
to be delivered and so as long as
they're more is more than is one or more
items being produced by the observable
or flowable this method will be called
for for each one allowing you to do
whatever do whatever processing you want
to do with the items this also could be
infinite right I talked about infinite
observables like button clicks so if
you're listening to a button click this
on next method will basically be called
every single time the user clicks a
button for non infinite sources sources
that actually end we have those two
terminal events we either can complete
where complete indicates success or they
can error where error indicates that
either processing the on next callback
resulted in an exception being thrown
or that the source of data where we're
listening to events from had a problem
and had to deliver an error and both
uncompleted and on error what's called
terminal events which means you'll never
get another callback after you get
either one of those and so where they
differ is in this last method called on
subscribe if you're if you know our
shovel one this is something that's
fairly new and it's basically the idea
that when you subscribe to either an
observable or flowable you're really
creating a like a resource and resources
often need cleaned up when you're done
with them and so this on subscribe
callback will be immediately called as
soon as you start listening to an
observable or flowable and it's going to
hand you one of these two types for
observable what this type allows you to
do is call the dispose method which
essentially says I am done with this
resource I don't want any more callbacks
and so if we have you know a network
request this would potentially cancel
the network request if you're listening
to that infinite stream of button clicks
this would basically say that you no
longer want to receive those and it
would unset the listener on the view now
the same is true for the type on
flowable even though it has a different
name the use is the same it has this
cancel method which is essentially the
same as disposables dispose the
difference here is that it has a second
method called request and this is where
backpressure
shows itself in the api this request
method is how you tell the flowable that
you want more items so i'm going to
build up a little chart here of how
these things relate to each other so we
have we basically can represent any you
know any type of emissions could be zero
could be one could be many and it
potentially could complete or
potentially error and the only
difference between the two is that one
has back pressure and one does not just
really quickly I want to touch on why
why the disposable and subscribe
subscription types are named so
differently and why their methods
one is disposed and one is canceled
instead of perhaps being you know one
extending the other and just adding the
request method the reason is because
there's this thing called the reactive
stream specification it was basically an
initiative where a bunch of companies
got together and said let's make a
standard set of interfaces for reactive
libraries in Java and they wound up with
these four classes for interfaces rather
and so you'll see the the subscriber
type and the subscription type in the
middle there these are actually part of
the specification and so that's why they
have a name that's so different than the
ones the disposable type and the
observer type they're different because
they're part of a standard and we can't
really change that the advantage though
is that because it is a standard
although this doesn't happen frequently
on Android but if you had to use two
different libraries for streams if they
both implement the standard you can
convert between them seamlessly and so
I'm going to change my left column here
to actually be types that implement the
reactive stream specification and the
types on the right are which implies
that back pressure is supported and the
types on the right are those which do
not have back pressure if we go back to
our user manager before we were kind of
pulling users out of this class and then
displaying them when we thought it was
most appropriate and now while what we
can do is model this as instead a
observable of user it's a source of user
objects that whenever the user changes
will be notified of that change and can
react to the change by displaying it
instead of trying to guess when the most
appropriate time is based on other
events happening in the system there's a
couple specialized sources in our Java
and it's basically a subset of the
observable so there's three of them
first one's called single this either
has a single item or an error so it's
less of a less of a stream and more just
like a potentially asynchronous source
of a single
and it also does not have back pressure
the way to think about this is kind of
like a scaler so you call a method you
get a return type you get a return value
or that method throws an exception
single essentially models the same
concept you subscribe to a single you
either get back your item or you get an
error the difference being that it's
reactive completable similar to a method
that is declares a void return type so
it completes with no data or it throws
an exception has an error kind of think
of this is like a reactive runnable it's
a set of code that you can run and while
either complete successfully or fail a
new type in our java 2 compared to our
java one it's called a maybe and this
either has an item errors or potentially
has no items the way to think of this is
it's kind of like an optional so a
method that returns an optional value
will always return something if it
doesn't throw an exception but that
optional may or may not have a value and
so we'll see where these are going to be
used in a second but this is similar to
the optional concept except just
reactive so there's no types that
actually model that that are reactive
streams compliant in archetype of two
they're only modeled in the observable
and backpressure free side so if our set
name and set age calls are asynchronous
they either complete or fail they don't
really return data and so what we want
to do is model those as completable I'm
going to go through this really quickly
just to show how these sources are
created and how you can wrap the things
that you're already using in reactive
sources all the types have static
methods that allow you to create them
with like scalar values you can also
create them from things like arrays or
anything that's iterable but there's two
that are really useful
I think our going to be the most used
for adapting the methods and the the
actions that you're already doing in
either synchronous or asynchronous way
the first one is called from Kabul from
Kabul was essentially modeling some
synchronous behavior that returns a
single value in this case I'm delegating
to some hypothetical method called get
name and the nice thing about from Kabul
is that you're allowed to throw an
exception from a callable which is a
standard Java interface this means that
we can model things that would
potentially fail using a checked
exception so if we have a HTTP request
that we want to make which could throw
an i/o exception we can now put that
inside it from Colleyville and the
returned observable when subscribed to
will execute that request and if that
request throws an exception we'll get an
on-air if that request completes we'll
get the the response and on next from
call balls available on on all five
types and so these are for modeling
synchronous sources of a single piece of
data it's what you would use a method
for in an imperative world a method that
returns a return value in the reactive
world from Kabul is what you use to
model that there's also two additional
methods on both maybe and completable
and those allow you to model things that
don't return a value so like I said
basically just a runnable except that
runnable is now all reactive the most
powerful method for creating observables
is aptly named create if you use rx
travel one you may know that create is
this horrible method that you really
should never be using an arc shovel one
in our Java two that's been fixed so
that the create method is actually one
of the most useful methods and should be
used for wrapping sources we create it
with a callback and so this callback
gets called whenever there's a new
subscriber and we're given this thing
called an emitter and the emitter is
basically just the person that's
listening so we can take day
and we can send it to the emitter and in
this example what I'm doing is I'm just
sending a piece of data synchronously
and then I'm completing the stream
because it completed successfully I'm
going to convert this to a lambda to
clean up some of the boilerplate here so
I can send more than one piece of piece
of data
unlike from cobble I have the ability to
call on next multiple times
the other advantage of this is that we
can now model asynchronous pieces of
data if I take H TDP requests and
instead of executing it synchronously
executed asynchronously I can call that
on next method in the emitter from the
HTTP callback another nice advantage of
this create method is allows you to do
things when the person unsubscribes
so if someone stops listening to the
HTTP request there's no reason for it to
continue executing we can now add a
cancellation action which cancels the
HTTP request and cleans up the resources
this is also super useful for Android
because it's how we model interactions
with the UI when you subscribe to an
observable we want to say start
listening to button clicks and then when
you unsubscribe we want to remove that
listener so we don't end up you know
leaking a reference leaking that
reference to the view creating
observables works on all that they're
creating observables with this emitter
works on all five types let's quickly
look at observing sources so I showed
these two interfaces earlier and I
showed that that fourth method which is
kind of new and is a little weird you
actually don't use these interfaces
directly when you subscribe to an
observable subscribe being the method
that that starts listening because of
that fourth method you're put in a weird
place where well what do I do with this
object and how do i how do i you know
unsubscribe instead we have a type
called disposable observer and this will
automatically handle that that fourth
method for you and allow you to only be
concerned about the actual notifications
from the observable itself but how do we
dispose here if we no longer have that
callback how do we how do we unsubscribe
how do we tell the resource that we want
it to go away one thing you could do is
hold on to that observer it actually
implements disposable so you can call
the dispose method and it will take care
of forwarding it to you
up the chain but there's a new method in
our kravitz you called subscribe with
and so this allows you to use it in a
similar way that you would do if you're
using archival one which is that it now
returns you the thing that you can then
call dispose on in archival one this is
called a subscription it's also called a
subscription in the flowable world but
in the observable world it's a
disposable for people that know of
composite subscription there's a
composite disposable and this basically
allows you to subscribe to multiple
streams take those just return
disposables and add them to what is
essentially a list of disposables and
you can unsubscribe from multiple
streams at once you'll see this a lot in
android where you have a single
composite disposable for you know an
activity a fragment or whatever and your
unsubscribing in the you know on destroy
or whatever life cycle callback is most
appropriate so you have these on all
four for non back pressure where it
types the ones that use observer and
there actually is one on global even
though flowable uses the subscription
callback not the not the disposable one
the type we provide in our java to
actually allows you to model it in the
same way so you get a disposable back
from all five types even though flowable
is kind of a little bit different the
way to think of this is like you would
think of anything that's a resource a
file a cursor on a database you wouldn't
open a file without having some way to
close it you wouldn't open a cursor on a
database without eventually closing it
never subscribe to an observable without
managing the disposable and ultimately
unsubscribing from it okay so those were
the types let's really really quickly
look at the methods that allow you to
compose and and change data we call
these operators and they do basically
three things manipulate or combine data
they change the threading semantics
or they can start and stop emissions
we're really only going to look at the
first two and just like we took
something that was imperative like a
synchronous method call and turned it
reactive operators basically do the same
thing so here we're applying an
operation to a string and getting back a
new string in the reactive world we
would have an observable and we would
apply that operation via an operator in
this case map is the operator which is
allowing us to take data being emitted
and apply some operation to it to create
a new type of that data I'm actually
going to skip this one so if we look at
our user object we defined that
originally the callbacks were coming
back on a background thread and we had
to explicitly move to the main thread
there's actually a built-in operator
that allows you to do that and allows
you to do it in a much more declarative
way so we can say I want to observe
emissions from this observable on a
different thread and so the things
coming from user will be on the
background thread but the things coming
out of main thread user will now be on
the main thread observe on being the
operator here and so this because we're
changing threads the order that you
apply these operators really matters
similar need to observe on we can change
the where the work of the observable
happens so if we're doing a network
request that network request is still
going to be done synchronously but we
don't want it to happen on the main
thread so what we do is we can apply an
operator that changes where we subscribe
to be observable and where we subscribe
is where the work ultimately happens so
now when we subscribe to our background
response it will change to the
background thread that IO is just a
thread pool of threads you can use and
so it will do work on that thread pool
and then send out the notification to
whoever is listening subscribe on here
being the operator to change where the
work happens
and what's nice is that because these
all returned you know new observable and
all the observable all these methods
exist on observable we can compose them
and chain them together so what you
normally see is that we don't have
intermediate variables for these we're
just applying the operators in a certain
order so we want a response or sorry we
want to request the execute on a
background thread we want to observe the
result of that request on the main
thread and we want to say change the
response into you know a string we want
to read the string except again order
here matters so because I applied the
map operator after observe on that's
going to run on androids main thread and
we don't want to be reading from HTTP
response on the main thread we want that
to be happening before we change to the
main thread and so the request comes in
and it's you know omits the response
down the observable chain we map that
into the result string and then we
change threads to the main thread where
we can ultimately subscribe and show it
in the UI and then we there's other
operators I skipped flat map so just
keep it here so where we see some of
those other types so you'll notice that
these were all observable there's other
operators we've actually which actually
take observable and return it into a
different type and so an operator like
first is going to take the first element
that's emitted from a stream and return
it to you in our example one we got back
and observable that only emitted one
item this is kind of weird because if
you have a list of items and you call
get on it to get the first item you
don't get back a list with only one item
what you get back is a scalar and we
know that well now we have a type that
models a scalar in the reactive world
so in our java 2 when you call this
first operator which is guaranteed to
only return one element you get back a
single if the observable is empty this
will actually result in an error because
we know a single either has an item or
errors and so there's other operators
like first element
is actually going to return you now a
maybe and so when a maybe or when the
observable is empty maybe can actually
model that by completing without an
error there's ones that also return
completable so if you're just ignoring
the elements all you care about whether
it completes or fails that now returns
completable which that's exactly what
completable models all these exists on
flowable as well so they all have the
same operators they all return these
same specialized types this is a chart
that kind of shows some of the operators
and the upper right-hand corner of this
is basically where the types narrow so
when you call something like you want to
count the number of items in a stream
account is always a single value so you
get a narrower type like single and then
we also have operators which do the
opposite which is you know take a type
and turn it into something more broad so
you could take a single and turn it into
an observable okay back to our original
example if we want to be reactive with
it we can you know subscribe to our user
say I want notifications on the main
thread and then I want to shove that
into the UI display that user anytime
the user changes this code is
automatically going to run you will
automatically see updates and we no
longer have to worry about managing this
ourselves however we do have to remember
to manage the disposable that gets
returned because we're in or in the
Android world and when our activity
disappears we want this code to stop
running so a non destroy we would you
know dispose of this dispose of the
disposables similarly when we ultimately
make an asynchronous request to change
data we want that to happen on a
background thread we want to observe the
result on the main thread whether it
succeeds or fails and you know in the
success callback we could you know
potentially like re-enable the text box
or whatever and again because you
wouldn't open a file without closing it
you wouldn't subscribe without managing
the disposable so we add this to our
disposable list
I'm actually going to skip this just
because I'm a little low on time but a
nice thing about our Java - compared to
our Java one is that there's a
fundamental architecture shift and what
that affords on Android specifically is
that there's just less intermediate
objects being created so when you create
these streams every operator you call
has to return a new observable that
implements that behavior when you call
map you get a new observable that takes
the old one runs a function and you know
emits the new data and so that requires
a bunch of objects intermediate objects
be allocated in order to to model that
stream rx Java to actually changed how
this works in a way that we actually get
less intermediate objects created oops I
wanted to so you get less allocation to
actually create the stream which is call
the operators each one actually results
in one less object being created there's
also less overhead when subscribing to a
stream there's less method dispatch that
has to happen and so ultimately what we
get is a faster less GC causing less GC
version of the library without any
compromise in the API so rx travel - is
basically this idea that we want to take
these things which are fundamentally
asynchronous in Android whether it be
the network Android itself database even
the UI modeled as an asynchronous source
and write code that reacts to changes in
these sources instead of trying to cope
with changes and manage state ourselves
right now it's in a Developer Preview
release so we're basically finalizing
the API and in about a month it will
have its final release where it will be
available I mean it's already available
to put in your app but the API might
change and the final release solidifies
the API so that things like libraries
can start using it and exposing these
types automatically if you do use rx
double one there's actually a project
which allows you to convert between the
types
and so this will allow you to
incrementally update your app if you're
interested in that here's the link and
so your dependencies for that will
ultimately look like this
and so where I want to end is basically
our X travel to is not something new
reactive programming is is not new by
any stretch but Android itself for
whatever reason is this highly reactive
world that we've been taught to model in
very imperative stateful fashion and
just try and cope with the fact that we
have to manage all these things
ourselves and reactive programming in
our Java in general allows us to model
it in the proper way which is that it is
asynchronous
embrace the asynchronicity of these
sources and instead of trying to manage
all the state ourselves compose them
together such that our app becomes truly
reactive and now really all we're
concerned about is how to build those
arrows and not actually how to manage
the state of the data that's flowing
through the system and so that's all I
have for you thanks everyone for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>