<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • The Future of C# • Mads Torgersen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • The Future of C# • Mads Torgersen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • The Future of C# • Mads Torgersen</b></h2><h5 class="post__date">2014-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dwdJ0GC5md0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so those of you who don't know
I'm éstos and I'm son of this city it's
good to be back and I'm gonna talk about
I work for Microsoft okay um so on the
team that is making c-sharp and visual
basic and f-sharp and we we have some
new stuff in the works that I'm gonna
I'm going to share with you I do have a
few slides because I want to make sure
that something for the managers in the
room but we got to spend most of the
time in Visual Studio showing some of
the stuff and and talking about the
principles in it so I hope you don't
mind that I'll try to make room for
questions a couple of places along the
way you know raise your hand if I don't
see it
shout out and then we'll see if we can
get the question on the recording as
well either by a microphone being rushed
to your place or buy me repeating the
question but I'm happy to take questions
I'm going to tell you when to stop
if we don't movie free running out of
time so the main sort of theme for us
and the c-sharp team has been for the
last like five years or so really sort
of a deep deep revamp of the c-sharp
compiler we've given at a complete
overhaul we've actually rewritten it
from scratch this time in a proper
programming language and you can guess
which one that is
and we've done that for several reasons
some of them just us becoming more
productive and trusting our codebase
better and so on but a lot of it has
been about opening up the c-sharp
compiler so why does the compiler really
well sort of in a in a traditional
mindset it's a black box that you shove
source code into and some executable
code comes out but that's not really
much of the truth these days a compiler
is really sort of the it's the deep
logic that understands what the source
code means and you want to use that
knowledge that understanding from many
purposes not just for producing the
source code in particular you're
probably all spent your whole day inside
of tools inside of developer tools and
it's important to use that that tool
understands what the code is about and
gives you intelligent feedback you know
from from auto-completion to
two on the fly errors two refactorings
and so on you want to understand your
code and we want to take that
understanding and we want to build our
all our own tooling on top of that but
we also want to make it public we want
everybody else to have a chance to
access that understanding of c-sharp
source code so we have this API very
rich object model of the syntax and
semantics of c-sharp that it's just
automatically available when you're in
Visual Studio you can plug in and use
that and ask all kinds of questions
about the code and we take it upon
ourselves to make it easy to plug in at
the tool level and in particular to make
this API robust and efficient and and
intuitive and and give you open up these
opportunities that previously we only
we've had and I am fully aware that
there are other other tools out there
that have been doing this for a while so
we've learned a lot from that we also
made we took the she sharp compiler and
we put it open source so if you want to
add a new feature to c-sharp you know go
ahead we even take pull requests though
probably not of new language features
just right now but go play with it see
how we implement it and then we also we
also added a few new language features
sort of as a side show this whole
opening up with the compilers the main
thing we're working on for the next
Visual Studio but we didn't want to sort
of take a theme of let's see how many
little features we can put in in our
spare time that help sort of small
features that help reduce boilerplate
and help just make code nicer to look at
so we'll have a look at some of that as
well so if you think about who are we
for this is sort of the this is for the
managers how many managers are how many
okay how many developers okay good I
think we I think we did the right
advertising so the developers really we
just want a better end-user product
right we want a richer IDE we want to
keep evolving the language and so on
that's been a main purpose here too
we kind of take the idea experience in
particular to the next step and then we
envision that a lot of people like
really a lot of people we really tried
to make it easy
we'll go and enrich this experience as
well based on on this new understanding
of the tools so maybe you'll make your
own Diagnostics and in a minute actually
we'll build a diagnostic together or
I'll do it and you'll watch we're just
to show how easy it is to plug into the
tool in a very deep way and and have it
react in the same way too with the kind
of things you're interested in showing
about the code in the same way as as the
built in compiler and rules do of course
we as a team have a better architecture
to evolve on and we think this is sort
of an investment for the next many years
for us that that we can stay vibrant
because we now have a productive well
architected efficient source code so we
also as I said we're also open source
and I think that kind of just expands
the target audience on all these levels
here we certainly already have have good
good vibes between us and whatever other
vendors of c-sharp are out there one is
one is present here in all who's this a
marine and and we talk about how can we
how can we make use of the fact that the
the c-sharp compiler is now open source
and and can be can be adjusted to fit on
different platforms for instance and
serve different needs and we don't have
to be the ones doing all of it
so that's the that's the quick spiel
what I'm going to do now is then go into
Visual Studio we'll look at some of
these IDX periences just a little bit
we'll build a custom analyzer and then
we looks on your language features all
right
you're supposed to say yes teacher yeah
okay thank you
Oh at before I I'm gonna forget to come
back to this so if you want to play with
this there's a there's a technical
preview out there we actually put out we
put out a new one every six weeks or so
I think it's probably anyone coming out
one of these days to search go to your
favorite search engine and search for
Visual Studio see
TP and you can download a version of
Visual Studio that's kind of a preview
with all this stuff and that's a public
preview I'm gonna use today also if
you're interested in the open source
we're on code clicks the project was
called Roslyn or it's called Roslyn so
if you go look for that on CodePlex and
you can look at these beautiful pictures
in bing when you go search for it it's
really the most beautiful search page
you can go to ok so questions will take
later but I will go now into Visual
Studio and talk a little about things in
the proper context of real code so
here's some hits um I just play code
that will be looking at a little bit
today and so one of so one of the things
that I want to emphasize is that we've
sort of taken people people like Visual
Studio okay and but it has a lot it has
lots of features lots of bells and
whistles but what people sometimes tell
tell us is that it doesn't one thing
that it lacks a little is it doesn't
feel like it understands my code quite
as well as some of the other other tools
it's like it doesn't quite get when I'm
where I'm trying to do and that's really
why we want to try to get it so I just
want to show a few things that I built
on top of on your compiler API we all
our ID features are built on the public
API I want to say we have no secret
communication with the compiler you
could do everything we can do so an
obvious thing is you know realizing when
something isn't used we can grade it out
if we take let's use something else
system.com actually I'm gonna sneak peek
101 of new language features is you can
import a static type and then its
members become into scope directly so
let me do that you can see I'm not I'm
not using any obvious members but now
you also see that the static type that I
imported becomes grayed out here and I
can highlight it and and and fix all the
occurrences of simplify the type and we
have I'm not going to go too deep into
deep insight but we have really good
logic for realizing when can you
simplify something with
about it changing its meaning let's also
go and let's go and look in here and
look at one of these things that we are
the only ones who don't have yet
it's an inline rename experience where
you drop into a variable and you oh
there we are it's a little it's a little
too late here and you just you just type
some stuff in here and and you know it
live updates everywhere so it kind of
that's kind of that's kind of basic but
they the the interesting thing is that
it really knows how to fix up the other
places in such a way that they don't
change their meaning even if the name is
a little odd or has other meaning in
that and that place I've used a keyword
it figures out how to escape the keyword
in other places if you use a let's say
you use a name that as you can see a
little further down their user name that
happens to be in scope at that point it
knows how to put this in front and so on
so it's just that language understanding
that that we're finally getting to right
if I use something that it's already a
member it'll tell you this this
refactoring will introduce conflicts and
let you know about it so it's that kind
of experience and we and then we want
you to be able to build a similar kind
of experience and that's sort of that's
sort of what I'm going to show now so if
we leave this code behind and go go here
so I'm gonna build a diagnostic that's
gonna look at some source code look at
source code in Visual Studio and tell
you that something is wrong with it or
could be fixed with it and then my going
to buy to build a code fix to fix it I'm
just gonna give you the sort of in a
sense of how easy that is using a good
object model of the code and we can talk
about some aspects of how what that
looks like as we go along and so what I
just did here is is going to file new
file new project and select the kind of
project that's called a diagnostic with
code fix and if you create a project
like that it'll come there'll be a fully
fledged project that has a
it's a silly diagnostic but a fully
working diagnostic already in there
I've deleted that code from the one I
have here and the project you can build
that in two ways you can build a visual
studio extension and v6 or you can build
a new gate file and either way you can
so you can either install the extension
or you can have that new gate file and
and you can reference that and then
those Diagnostics will apply to your
project only you can build these guys
and install them share them out and do
all that kind of stuff so let's try to
do one of those the it this is the the
analyzer part the diagnostic part I am a
most of this was generated for me I'm
just implementing an interface I'm
saying I'm I want the kind of diagnostic
that looks at certain kinds of syntax
notes I'm a syntax note analyzer I just
have to declare which kinds of syntax
notes am i interested in and then the
tool will call us whenever it needs
especially essentially on every
keystroke where your code is in is
visible on the screen it will it will
call us with the syntax note that that
might have changed here so the if
statements and else clauses are the ones
I'm interested in
if I hit f5 in here if I go to debug
mode inside of this kind of project
it'll start another version it run
another version of Visual Studio with my
code installed and so I can see it
working so the debugging experience is
running you're running you were
diagnosed again the tool so if I do that
here you can see that I open our before
I I don't have a diagnostic yet so it's
not going to do anything but that I can
use this to tell you what kind of
diagnostic I'm going to write so it's as
a matter of style it's it's bad for more
some people considered bad form to have
a statement in and if that isn't
surrounded by Curly's that isn't a block
and so we want to identify those places
and offer to fix them and a similar else
clauses except if it's an else--if then
we don't want the if to be in braces so
so let's write the logic to to deal with
that so i'll go back to my project here
all I have to do really is I declare my
interest in the in if statements and and
else clauses and then all I have to do
down here is to see am I in the in the
situation that I want to and I want to
give a diagnostic and if so create the
diagnostic so we want to just start by
getting there you can see I get called
with various things I get called with a
syntax note and then some semantic
information I'm going to I'm not going
to use that but you get all kinds of
binding information and so on so you can
actually not just look at the shape of a
syntax tree but but I had add how does
how do things bind what do they mean and
and you setting your diagnostic so we're
going to just take that note that we got
and see is it actually an if statement
so we take it as an if statement syntax
and if that is not know then we're sort
of in there then we're in the right
vicinity here in the right neighborhood
and so let's let's think about what are
they what is the logic for establishing
that we want to highlight this as a
problem well if it so one of the things
we have to think about is that most of
the time you're in the tool your code
isn't correct right you're typing ahead
it's only actually it's the exceptional
cases when your code actually even
parses or let alone compiles so we of
course we have to deal with a model that
has error tolerance and so we have
really good heuristics for building out
a tree when when the code isn't quite
correct and if we find us we just want
to check I can't actually remember if
you can ever get yourself into a
situation where the if statement the
nested statement is null but let's just
assume you can so let's check that it
isn't and then we're interested in the
places where it isn't already a block so
if not the if statement is the if
statements statement is a block we
haven't is kind operator here syntax
kind that blocks a visitor block already
then we want to tell people that it
should be and we just do that by
creating an a diagnostic and and saying
exactly where where to put a little
squiggle line underneath
so let's get a location for the squiggle
if we squiggle just the
say we squiggle just the if keyword in
the if statement so we say that if if
statement dot if keyword you can see
it's an object model of the if statement
I can just stop my way in we can get the
location of that so that'll be a
two-character span somewhere in a source
code and then we want to create a
diagnostic from that equals what did I
do wrong
oh I didn't do anything wrong it's just
a little slow equals diagnostic dot
create so it's all just like standard
level coding here I already have a
descriptor that I created further up
there we just got the location and we
have a message up here we want to say
what the arc argument is that is if
statement it's an if statement my if
statement must have braces created a
diagnostic and I would just have to add
that diagnostic by calling a delicate
that was passed into us here so now I've
done everything I need to do this is all
I need to do now to plug into the tool
and to see that let's let's run this in
the debugger and you can kind of see
what we achieved so what we hope to see
is that now our if our ifs in there our
squiggled with a little green squiggle
of course this takes a little time here
we go it's warming up now it now it will
show little squiggles that represent
exactly what we asked for right so that
wasn't bad right it's not bad and you
can actually see sorry for hover here
it'll even Italy them give me some
options one of them unfortunately all
the options here I just suppressed the
warning that we just created so what we
want to do now is to build a diagnostic
or build a code fix that can that can go
into this menu and offer the opportunity
to to fix the problem so if we go out of
here again we will oh I should have also
fixed it so you can see that it went
away but I hope you'll trust me on that
first of all let's do this that's just
paste in some code that does the same
analysis for ELLs classes
and then let's go and build a code fix
provider and it's the same kind of idea
we that's a method that gets called
whenever this code there's some
mumbo-jumbo to associate this fix with
the diagnostic you saw before whenever
the diagnostic is this code fix gets
called and and we get a method invoked
here with the document that's an object
model of the whole piece of code in
there and and the text span for where
the diagnostic is so that little if
there and now we can go now we go
digging through the document we get the
syntax the root of the syntax tree we
ask for the token in the I already wrote
some of the code here we ask for the if
token in there we find its parent the if
statement we check that it is an if
statement and now we have the if
statement again so now it becomes
interesting how do i how do I actually
do the change of code and here comes the
the important principle here is that all
syntax trees and all our data structures
are immutable okay we have an immutable
object model so so every time you hit a
key you get a fresh new syntax tree
that's almost like the old one but it's
slightly different all right
and we do all the work behind the scenes
to make that efficient by doing sharing
and being lazy and all kind of stuff
we've that's what we spent five years on
getting this stuff efficient and and so
what I so that means that if I have to
create a new version of I actually have
to create a new version of the all these
notes I can't just modify them with with
the assignment right so I have to create
a new if statement if statement so why
is it why is this interesting you'll
hear more talks tomorrow about
immutability if you're interested in
those patterns but why is it interesting
to do it like this well you think it's
hopelessly inefficient but it's actually
great because when you have immutable
data structures you can paralyze the
heck out of things and we do that when
we compile but it also means that you
can have multiple versions of these
trees alive at the same time without
there being conflicts and we're going to
see that actually in effect so what you
often do this is a common pattern with
with immutable data structures you have
Withers where you can you could call to
get a version that is slightly different
where you where you replace one of the
things in there so we can replace the
statement with a block statement by
going to sin we have a syntax Factory
where we can get a block and inside of
that block we are going to put the
statement that we had before if
statement at state
all right now we haven't a new if
statement what are we going to do with
it well we have to put it into a new
syntax root so we have to say new
because and we have to create a new
syntax tree for the whole thing where we
replace the same principle again where
we replace the old if statement with the
new if statement so we're going to say
root duh replace replace node we replace
the if statement with the new if
statement but again once you get the
hang of this style of programming it's
really super easy and now we need to
stick that new root into a new document
that's just like the old document except
that it has a new syntax tree inside of
it new document equals document dot now
we say with syntax root and use in your
Road and now we've created an
alternative syntax tree for the hole
buffer that's just a little different
and now all we have to do is install
that as a code action so we create a
code action sorry bar code a code action
equals code action create we have a
string that says add braces this is the
stuff that will go in there in the menu
that we select our fixes from and now we
need a new new document here and now
we've told the the code action
everything we need to know we just need
to return it we turn it in an array
because there can be more than one code
action associated with a given dragon
diagnostic so we just return an array of
one here okay
and that's gone run that and so that's
all you do and that that's you can
imagine doing this yourself you can
imagine building thing building
Diagnostics that maintain the styles
that you want inside of your company and
handing them out to everyone with code
fixes you can imagine I think this is an
important scenario you can imagine
writing libraries to think about JSON
dotnet or other libraries that come with
code fixes and Diagnostics that help you
use those those libraries directly it's
kind of like dark comments on steroids
right you do you get not just
documentation with the library you get
automated guidance to how to use it and
I think that's going to be I think
that's gonna be an important scenario
for this so now with a little help for
my friends I think that I have now an
extra menu item here add braces and you
see it actually has a preview of the
code over here it's not that pretty
because we didn't add formatting I'm not
going to do that for it's very it's an
extra line of code to add to format this
correctly but you can see that in the
preview
there are Curly's around the around the
if statements statement here you can
also see that where is this preview come
from where do you think it comes from
it's it's a rendering of that
alternative tree that we built we have
so by having these two different syntax
trees two versions of it you can you can
show one in a preview you can have a
peek into the alternate universe that
will come true if I select this code
action right you can see that it even
even it even shows squiggle let me even
show squiggles for the other things
because it's running our analyzer
recursively in there so a good thing
that I can't click here and get a
lightbulb right because otherwise you
could get all the way into the rabbit
hole since that that's one of the really
strong aspects of having this immutable
model of code so that's all I'm gonna
say about Diagnostics and I want to
pause quickly for questions here and see
if you if you have a few we'll spend
about five minutes if you have questions
and this
our comments and you do so let's see if
we can so JetBrains so the question is
about JetBrains and if we have any
interaction with them of course this is
sort of getting into jetbrains territory
and coderush territory and we've had
different we their partners we interact
we good friends however they make their
living JetBrains make their living from
having a very detailed model of code
that that they understand and building
tooling on top of that that people want
to pay for and now what we're
essentially doing is making a model
somewhat like that and making it
available to everyone so we're kind of
like threatening them a little from
below in that sense now everybody can do
some of what they do but I think for
JetBrains they have some very advanced
things and that they're gonna survive
just fine because they because they're
going to be better than anyone at
building those those tooling things on
top even if there's an a public model as
far as I know they block that they will
not actually switch over to use our our
model underneath they'll keep running
their own analysis and doing their own
which can be a bit of a performance
problem I think but we'll see maybe they
can do some kind of hybrid thing or
whatever to to speed it up a code rush
they actually announced that they are
going to switch over to our model and
and just build on top of that but it's
an interesting I mean it's kind of
changing the game instead of having a
few providers we have a closed we have a
closed box that nobody can use of a
valuable language knowledge if you will
and then there are these proprietary
tools that build their own analysis and
work on that and now we're democratizing
that analysis and making it available to
everyone and at least sort of at the low
end or midlow to MIT and everybody can
play it very easily and that's gonna
change the game I think very
significantly
okay it was a yeah
can you turn it into a compliant macro
facility yeah you probably can you need
a macro language on top and and then
work with these models that sort of
falls into the category of meta
programming you could imagine all kinds
of different meta programming various
generative mechanisms that would produce
code or transform code or add things to
code and that's actually how that was
the original motivation for even
starting this project but along the way
we decided okay now is not the time to
address meta programming so we scoped it
out and decided to address tooling and
and sort of the core value props for the
millions but I think that that's
definitely a place to go in the future
with this and we I I am confident that
there'll be lots of people out there
that will tweak this whichever way they
can and we will look at them and see
what are the things they're trying to do
that they can't quite do yet or that
they're doing in a very arkla fashion
and consider whether we should support
that more directly in a future version
so I think that's a really interesting
space we just this is a step towards it
we're not quite there yet probably some
things can can be done already but not
all and we certainly haven't designed
for it yet okay I think anyway I don't
see hands let's light in my face I don't
see hands so I'll go on to the next bit
so the the other thing that I told you I
promised you I would talk about a little
is the new set of language features seen
in c-sharp it's kind of light and and
and we admit to that we this isn't that
major focus we didn't want to have a big
theme it's crazy enough as it is with
this with the the API level stuff so
we're essentially just looking for
opportunities to to remove some
boilerplate code and make things a
little easier and I'm gonna show you
some of those and I have to say that
this is sort of work in progress I I
know that some of the things I'm I'm
gonna show you will probably not
actually come all the way to product and
I also know that some things around the
way that aren't in this prototype yet so
take it with lots of grains of salt
you already saw one language feature the
the using of static members here we can
do another one using system that math
you know that's going to be a common one
I want to be able to say square root
instead of math the square root
especially if I'm doing a lot of math
see math the square roots down here it
is now grayed out
isn't it wonderful to take it and just
dump it in the trash right there all
right and so certainly you know just the
ability to get top level functions
essentially that that's sort of been
missing for a long while other languages
have this this is a program that just
creates a series of points turn some
into Jason and and to incent back again
so it's a really uninteresting program
and then the more interesting part is
just looking at what are the things we
can do inside of this this class
declaration here so one thing we've
played with and I have to admit that
this is probably the thing that may not
make it for cost reasons down the road
is putting putting constructive
parameters directly on the class we call
this primary constructors and allowing
you to just put parameters in scope and
initialize directly from them in the
class and get rid of the get rid of the
constructor so that's kind of a nice a
nice kind of saving up space but we do
want to go a little further one of the
things that I think with c-sharp we for
a long time we sort of been you saw me
do all this stuff with an immutable
object model it was great writing that
immutable object model is a bit of a
pain in c-sharp actually it's much
easier when you're mutable we have all
kinds of things object initializers and
auto properties and so on that helped
the immutable go help the mutable folks
right and what we want to do also here
is try to level the playing field a bit
and get make it easier to be immutable
okay and so where previously if you
wanted to not have a backing field
explicitly in your code but have it
generated you had to have an auto
property and in order to say to you then
you need to have a setter and what
people do is sometimes and make the set
of private so it's kind of like it
wasn't there
what we are now adding instead is the
ability to just have a getter only auto
property and you can get a value in
there
by initializing it for instance so I can
initialize it directly here because we
also now have initializes in Auto
problems so things get a little more a
little more terse here and now we can
look this is the prototype okay I did
not want that to happen okay
did I freeze here always happens when
they're recording right okay time to
tell jokes
this-this-this froze pretty badly I have
not seen this before okay
it needs needed to discover that it was
having trouble
it is now restarting so the general
thing here just allow you to it's not so
much about adding new concepts last time
we added the concept of async the time
before that we had the concept of
dynamic though they were both what am I
asking for recover files yeah I think so
this time around it's not about adding
new concepts it's just about making more
clear what you already have so hopefully
these new features should kind of melt
into the background let's see how much
it remembers of what I did not a lot i
remembers the the constructor parameters
out there so let's go in turn these into
auto properties again and see if it gets
us into trouble again okay there we go
so these things to just make the code
look lighter and express your intent in
a more terse way that's kind of what we
were after okay so this is now valid
c-sharp code and much lighter than what
you had before another thing is that you
have these you often have these very
simple methods and properties that are
essentially just a single return
statement with an expression in so
there's a lot of fluff around that
single expression to see what it
actually does and in actually in lambda
expressions for many releases we've had
the choice between do I want a full
statement body or do you just want an
expression for the result and now we're
adding that choice
to all function members so I think this
is quite this is gonna quite
significantly change what it looks like
when you glance over a class and again
it's it's really just syntactic sugar
but being able to use the lambda arrow
again I hope you like it and being able
to just say this instead where you just
say two string is a function that
returns the result of this expression I
think that's kind of nice and with
properties this is a computed property
right I only has a getter the getter is
evaluated every time just a single
expression in there we actually go a
step further and we let you just
eliminate both where you say get and
where you have all the Curly's and
returns and so on so I get our only auto
property again sorry a computed property
now can look just like this all right
just it's still property you can hover
over here and you can see this property
with the getter but it's super turf like
just say whenever people ask for dist
give them the result of this okay so
expression bodied function members we
call this okay show the let's talk about
the null conditional operators alright
so for better or worse we have nullable
reference types and only nullable
reference types and see sure we're not
going to change that we're not going to
add a concept of none nullable reference
types because that's a pain we've tried
can't figure it out you can it's easy to
design a language from scratch with that
but it's really hard to add after the
fact but what we can do is to make it
easier for you to deal with when you
have nulls so let's say that this try
get int method here which tries to take
some jason and turn it into an int let's
say that it we want its you can see it's
not robust here if it's if it gets a
knowledge is returns false well maybe we
could get rid of all these lines of null
checking that we have all over the code
and just say well let's switch let's say
that this reduce a question dot version
of the dot which says if jason is not
null then dot into it and return the
otherwise return all right so now you
get type here is a it's a struct here
now you get the nullable version of that
struct but you can switch in nullable
things so now it would just fall into
the default case here because in case
jason to sell itself is null then it'll
just fall into the default case we can
actually take the assignment here and
put it down there because we now have a
total switch and everything that jason
can be so we call this some people call
this the Elvis operators and a few other
languages can you see the the two eyes
and the cowlick if you kind of look at
this as an emoticon so that's why that's
why it's called the Elvis operator so
you can also do that for other things
the method that calls the method we saw
before here try get int you can also you
can also do question indexing so you're
saying the result here of this
expression is null if jason is null
otherwise it's the result of being
indexing into it with with x here and
there the right hand side does not get
evaluated unless unless the the left
hand side was not null and you can chain
these so the whole chain of dots and and
indexing and invocations actually of
methods and stuff so that whole chain is
is only evaluated if you didn't have an
all out front you can imagine that for
one of the most annoying things in
c-sharp i don't have an example of it in
here is the the thread safe way to to
trigger an event all right how many
people are c-sharp programmers and and
and curse this the thread safe no curse
event triggering no sheesh are
programmers okay let's start with that
some you have to check if the delegate
you're invoking is null then you have to
make sure you have to take a copy of it
because it has to be thread safe so if
so you don't check it's null and then it
becomes none null before you decide not
to do it or the other way around now you
can just do it in one single statement
with a question dot operator okay
let's see we have okay we have 10
minutes left said right little over 10
good
so let's look here at this async method
I have a bunch of stuff in here but one
of the things that so the main concept
I've introduced in a previous version of
language was acing so you can now
Express asynchronous methods easily by
there to return a task like a future
which is something you can then await in
another async method I'm awaiting one
here and and you so you sort of just get
suspended until that thing is complete
and then you get resumed that's all very
nice but we didn't complete it
we didn't there are few places where we
couldn't figure out how to how to
implement a weight and we at first we
thought well that just it doesn't make
any sense it's not possible it can't be
done and then we shipped and then we
figured out actually did make sense and
but it was hard to implement but then we
just did it anyway so now
so in catch and finally blocks you can
imagine so a weight turns into a state
machine by the compiler it's a really
complicated state machine you can
imagine so it's something like when the
let's try to do it here so let's what we
want to do in here is to is to call a
logging method so if I say repository
dot log async here I want to wait that
call I'm logging that there was an
exception but that in itself is acing
and you want to be able to wait the
completion of something async inside of
a catch block right in this case here
but what if you can imagine kind of the
the the pains to implement something
like that because well this one isn't
actually let's talk about finally here
and wait repository dock closed so you
think that's a better one these are now
allowed so what essentially we do is we
generate a method behind the scenes
that's like this method except it gets
call it gets called from the beginning
every time and then it has a bunch of
ifs and branches and stuff to get you to
the place you
the last time okay so it's a method that
pretends that it kicks off where it was
but behind the scenes there's all this
logic to get you back to where you were
that based on some state that's saved
well the problem with it finally is that
it's not just about getting back to
where you were it's also about
remembering where you were headed so
figuring out keeping track of where we
where were we going after the finally
where we're going to drop out of it and
execute the next statement or were we
returning from this method or were we
actually in the middle of an exception
coming out or were we actually coming
out with a go-to and keeping track of
all those locations and switching on
which one of them am I going to and so
it's just a mess but it works and now
you don't have to do it we could we do
it for you in the complainer okay
other little things we have now
exception filters so you can other
languages on dotnet already have this
supported let's say that I only want to
own sometimes when I catch this
exception here of course I can catch it
and see if I wanted it and throw it
again if I didn't but then I'd blown the
call stack and the treta traces are out
of whack and and if I'll if there's a
dump later I can't see where the
exception originally come from came from
so now you can just say if and then a
condition in here so if either
occurrences it's greater than three or
something like that then the exception
only gets caught if that's the case and
then you can have multiple now we can
have multiple catch blocks with the same
type but different conditions on there
if you want to okay I think that is a
good place to stop so this is kind of a
now I want to show one more which I
haven't actually we haven't actually
implemented yet but it looks like we
will have time to implement also string
interpolation which is becoming popular
in these you know these modern languages
like JavaScript and so on so in in
c-sharp you have to call string that
format if you want to do something fancy
string that format you have a
placeholder a number that corresponds to
the thing in the argument list to the
thing that you want to put in there
later you can also do various
formally specify a justification and
various formatting things or whatever
you want to do here we want it allow you
to just put expressions inside of the
string little directly so I think the
syntax will land on this if you if you
so instead of saying string that format
and all that you can just say a string
literal and if you put if you put back
slashes in front of the Curly's here
then they become holes in this it holes
in the string where you can put an
expression so I can just say X here and
Y and they get they would get colorized
nicely of course once it's implemented
they would get evaluated and and paste
it in there and thinks are a little
nicer you can still do the the -3 thing
or whatever you can still like it will
still call string or format and have all
that expressiveness but in a much nicer
way and that gets us to five minutes
before the end of the session and I want
to ask you if you have more questions
about this or anything you heard
hopefully you do because otherwise we
have five minutes and then you're gonna
have to listen to me talk some more yes
yes the new features are quite minor
yeah yes that's a great question what do
we have any ideas what we want to do
next yeah I can I could talk a little
about what our ideas are we don't this
may totally go away okay but I maybe I
did I didn't say this very clearly in
the beginning but we've taken we started
taking a very different approach to how
we talk about the future of the language
instead of sitting in what Gilad bracha
called smoke-filled rooms and and just
figuring out the future secretly we
started we're designing in the open the
design notes are actually up on the
codeplex side I talked about before
search for rustling codeplex you can see
the c-sharp language design notes as
they go out so I'm happy to talk about
it
currently the and actually up there you
can find also a draft proposal for
full-on records features and pattern
matching in c-sharp so that's one one
direction I want to go in there's more
and more need to to code with plain old
data essentially
and having instead of having you know
objects are great for some things but
instead of having functionality wrapped
with with data we'll often times you
just want a little data type like the
point up here actually and it's more
important how its transformed and passed
through external functions than it is
what it can do itself and and for that
having pattern matching being able to
decomposition right being able to easily
combine switching logic and
decomposition logic and and have
essentially have your control flow
follow the shape of the of the data if
you will that's something that
functional languages have it's very nice
it's also in Swift so it's starting to
creep into the mainstream and there's a
very nice proposal up there for that so
that's one theme that we'll be looking
at they made there may be others I'm
kind of a little interested in maybe
looking at some of c-sharp is generally
generally has good performance but I
think there are some places where the
semantics of the language forced you to
write code that is that doesn't perform
very well a lot there's a lot of
defensive defensive copying of arrays
and stuff like that we can think about
are there features we can add to let you
write more efficient code and that's
another theme that we'll be
investigating for sure a third theme
that we might be looking at asynchrony
is currently for single values can we do
something with asynchronous collections
of streams where you get things down
over the wire maybe one at a time or in
chunks and you have just as easy access
to two language features to deal with
that it's another thing that is on the
table and you may not never see it come
but that's that's on our mind okay yep
in are you looking at that by the way
what's that what was I supposed to do
that I can see that happening I did not
experience I did I experienced ort of a
subtle recursion but I will say that we
have had analysis that were each other's
inverses where you would always get a
squiggle
I mean note you can specify the severity
of it you can make them just infos
they'll just tell you things you can
silence them and stuff but here's a
great example half of the world love VAR
and the other half hated okay
I think the lover half is probably
bigger I'm in it but people have
opinions there and what we will do might
be to offer an analysis and fix to take
var away and want to introduce it in all
the cases where it applies and you can
see that's where semantics comes in
because var can only be used sometimes
and so it will do it will be a fancy
thing that will say oh you could
actually use var here if you want to and
that will get you into this flip-flop
but we will also make it so you can turn
Diagnostics on and off so what people
will do is turn one of them on and one
of them off and they will get the right
behavior no no because the ID doesn't go
into as you saw I couldn't click one
level down right so it's only going to
and it's only going to apply the code
fix when you ask for it it by at least
hovering on in the menu over that item
so I'm gonna apply one at a time even if
you have multiple code fixes in the menu
you can only hover on one at a time and
you'll have different alternative
universes for each so even if they are
if they're contrary to each other
they're not gonna affect each other all
right I think we started through but if
you can come with an example that be
really fun
yep never this is we often get this like
when is c-sharp going to turn into C++
in the sense that it has so much baggage
that people tend to camp out in
different dialects of the language and
no no don't ever use the whole language
and that that may happen one day so we
have essentially we have a delay in
language evolution we have a dilemma do
we keep the language the way it is small
and then people in a little it'll to
stop being relevant right people love
most of what we introduce to the
language since it was created we have to
add things to stay relevant but one day
you will grow too big what do you do
then do you keel over and die or do you
start removing stuff the problem with
removing stuff is we have a strong
backwards compatibility commitment
currently we're really committed to
being able to compile C short 100 code
all the way up there are tiny tiny
quirks that we know about but I dare you
to find any of them and that is that's a
strong value proposition for us it's we
have a lot of I mean a lot of our
customers on enterprise right they they
want to have be able to just upgrade
visual studio and not worry about their
source code all of a sudden not
compiling and having to go around and
fixing a million different little things
because we thought ah that's not that's
not cool anymore you know you know I
thought it was methods that is so you
know mid-2000s you know now we use
lambdas so let's just throw that other
thing out that totally wouldn't work and
it's it's just know we have to either
evolve or die and then we'll see what
happens when we get too too big
hopefully we can delay it by trying to
design our features so they fit in with
the existing language as well as
possible so that the concepts fit
together as much as possible so that the
conceptual burden if you will is minimal
hopefully and try not to create separate
ways of using C sharp we already created
one from the beginning which is unsafe
code that's already one of those and we
want to try not to get into more of that
where you have a mode where you in a
different kind of different kind of
world we're very hot-headed about that
it has to be
yeah cool well thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>