<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Test Driven Development (by Controlling Dependencies) • Jorge D. Ortiz Fuentes | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Test Driven Development (by Controlling Dependencies) • Jorge D. Ortiz Fuentes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Test Driven Development (by Controlling Dependencies) • Jorge D. Ortiz Fuentes</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qYpURmZcCKs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as an instructor and a consultant
occasionally it always amazes me how
reluctant is our people to do testing
for the code that they write and I don't
know why they write code and they only
tried with their devices and send it to
the customer and ask the customer to try
their code it's like asking the customer
you go first
you take care of this you tell me how it
works and if it works fine and I just
want to know if there is any problem
probably some of you would be thinking
that it is not that important to do
testing for small things for small apps
because after all what we're doing is
just apps for mobile devices they are
not that important well actually they
are but even the smallest things that we
used require some testing sometimes we
want to be sure that these small things
work perfectly before we use them also
we consider ourselves professionals at
least that's what I want to think of
myself and if we are professionals we
would like to compare ourselves with
companies like NASA like the
presentation we had today for the
keynote I mean like they do a lot of
testing they were able to put this a
robbery Mars so precisely because they
were doing a lot of testing before they
were doing unit testing they were not
doing the integration testing because as
she explained to us it is not possible
to test everything before sending the
stuff to Mars but at least they were
trying to put all the pieces together to
have them ready and tested before
sending them to Mars because it's
expensive it is also expensive for our
companies to create software and to send
them to customers without having tried
that somewhere before so I would ask you
to not consider yourself as an artist or
a gardener who cannot test the results
of their outcome but to consider some to
consider yourself a professional and try
to prove that what you are doing is
completely right so today I'm going to
talk to you about TDD and how to do TDD
by controlling dependencies and well as
I said my name is Kirk your teeth and
this is going to be I talk about how
architecture helped us to do TDD we will
talk about TDD first then how real life
gets into TDD and spoils the results of
our good will and then how sweet helped
us to have a bear a architecture that
can be fully tested and helped us to do
TDD when we are developing for mobile
devices and for OS 10 so let's start
with TDD and because I don't want to be
one of these people who starts talking
about acronyms without explaining what
TDD is I know that probably everybody
here knows what TDD is but let me tell
you let me remind you that TDD is
test-driven development and these
test-driven development means that we
write the tests before we do any actual
coding that means that we know what we
want to prove before we write a code and
well that is very important because now
we are changing the paradigm and we'll
instead of writing the code and trying
to demonstrate that it works perfectly
what we do instead is create that
that we know that this code will have to
pass and then we will write a code in
order to make it work I don't know how
long all of you have been working in
development probably many years for us
there has been a lot of progress and we
started with this sensation of writing
something and typing something on a
keyboard and write in a small program
and it does something okay that is kind
of progress but then we would change to
the stage of being able to do what we
wanted to so our programs were not only
doing something but we what we expected
them to do the next stage from that is
testing I can prove that the program
does what I want it to do but there is
even more you can go and do TDD and then
you can say I'm going to say what this
get param is going to do and it will
prove that is going to doing that
because it's passing the tests this is
the path to Nirvana okay so once you
have gone through all these steps you
get to stage where you know that your
code is doing everything that you were
planning to because it's passing all the
tests that you have plan in advance how
do you do that how do you write the
tests in order to make them pass and to
fully cover the scope of your
application well the first thing that
you have to keep in mind is that you
only have to test your code and that is
something very important if you're
writing a core data
application probably you don't want will
probably know surely you don't want to
test that an execute fetch request that
is code that Apple has written for us is
working properly you don't want that it
is apples business it will work fine you
only want to write a test like that if
you want to prove that they are doing
something wrong okay but that's not
usually the case usually when you find a
bag like 99 percent out of 100 it is
your fault let's assume that okay so
here what you want to do is just test
the code that you are going to write
only one level of abstraction which
means I'm going to focus on the a top
API the level of API that I am serving
to other modules so if this is a class
there is a public interface that is
offering methods to other classes and
this is going to these are the methods
that I am going to try the methods that
I'm going to develop tests for only the
public methods people usually think oh
this method this is very important I
want to know that it works properly but
this is private so how do I try that the
thing that you have to do is to try the
public method that uses that one
so you exercise that method the private
one but you only have to focus on
testing the public ones if a method is
private and you don't access to that you
don't have any access to that it makes
no point in it's no sense to have that a
trick that tests running for you it even
makes no sense to have the private a
method so only public methods one
assertion per test well that's not
actually true assertion is what you
suspect that the the test to do
sometimes you can have more than one but
the thing that you have to keep in mind
is that it if a test fail fails it must
fail because of guess one reason so you
you need a test
a failing telling you that that
something is wrong but guess one thing
because if a test is failing and is
offering you a lot of things that it can
go wrong then it is harder for you to
find out what was the problem in the
first place finally the test must be
independent of sequence and a state if
you run the tests in a different order
or if the test the X the class that
you're exercising the class that you're
testing has some previous state you will
have to inject that a state in the test
that needs to be run not as a result of
previous tests ok these are general
rules I think that they are fairly easy
to comply but then it starts the TDD
dance and the TDV dance is what you do
when you want to develop TDD in TDD you
start by writing as I said the tests so
when you write a test you have something
that well it fails
I mean it's read then the test a the
code is written to pass the test and
then hopefully you get something that is
green the test has passed then you have
the chance to improve your code you can
refactor and refactor sorry and refactor
means that hope refactor means that the
code will be doing the same and all of
the tests should be still passing but
you can do changes to your code that are
required that help the readability of
your code that helps the code to be more
concise that anything that a fulfills
your purpose and you can refactor in
order to have a method that avoids
repetition things like that but every
test has to be still passing after
the stage of refactoring what are the
process of doing TDD well the processor
the first Pro is that you will have code
that is 100% covered which means that
you have code sorry you have tests for
every line of your code if you don't get
that when you're doing TDD is because
you're cheating on yourself you're
saying well I don't need to test that
then that's not covered but if you do
TDD properly and you do you refrain
yourself from writing any line of code
before having a test for that everything
will be covered because you are thinking
about the tests you are more sensitive
to the edge cases you're also more
sensitive to things that you were not
planning in advance so what you have is
the ability to detect scenarios that if
you don't do the test before you
wouldn't notice the progress that you do
when you're doing tivities is can be
measured I mean like you know that
you're doing some progress because you
have more tests that are passing every
time that you're writing and it is
easier to introduce changes because when
you introduce a change you know
immediately how it affects to the rest
of your code some people complain about
how long it takes to write the tests and
I agree that it takes some time to do
testing properly but it is also true
that since you are doing the testing
beforehand the time you spend on the
bagging is less and that helps you on
your productivity it's also true that
you are able to get a more decoupled
code explicit dependencies single
responsibility in within the classes you
can do autopilot parameter that
it is essential for people that don't
sleep much I mean you know that the code
is working properly because you're
writing a test and it is passing the
test okay also also you get to a simpler
design because one of the things that
you try to do when you're doing testing
is what is called as jack knee you ain't
gonna need it
you don't put things in your program
that are not required yet so whatever
you write in your program is something
that is required instantly and that's
why you test it the truth is that the
things from the right side are not
actually true always but they are true
most of the times and they at least they
help you to have a to get them easier
okay what are the cons well the cons are
people wouldn't they start thinking
about TDD the first time that you tell
people our TDD they think that this is
putting the horse before before a cart
and now have to think how to test
something that I haven't even written
yet so well that is actually not true
because when you want to go to a
restaurant and you want to order you
don't know how the food is going to be
or how a fool are you going to feel
after eating the food so you go through
the menu and you ask for some dishes and
you eat them and hopefully they pass the
test okay
another complaints are that it takes
longer but as I said before it takes
longer initially but it is not true that
it takes longer all the time because you
have to take into account the time that
you don't spend in the debugger which I
don't know about you but for me spending
time in the divider is tiring because
well I mean like sometimes this I run
this again yes the problem is there but
I don't know how to solve it so I try
again again and again and I don't get
to solve the problem well when I'm
writing the test I know why is not
passing okay there's an initial
investment I agree on that I think that
you have to do more stuff to get a basic
case running but well it pays off
afterwards and I think it's worth
spending that time some people and there
was a very nice series of videos in
YouTube with David Hannah Mayer and
Martin folder and came back and that the
title is is tdd dead and it is a very
nice series and one of the points was if
I'm doing TDD
I don't have a the big-picture mind so
my design is not as good as it would be
if I spend some time working on the
design and then doing the development
but the truth is that there's nothing in
TDD that tells you not to work in the
design me for starting with TDD so I
don't think that's an issue either it is
true it is actually true that if the
requirements change the tests must be
reading to not only the code but the
tests and this takes longer also it is
true that you need more tests that unit
tests till it is only about unit tests
and there's it you probably will need
integration tests you will need a any
other kind of test like loading low like
performance testing and here you're only
a focusing on the unit testing but
that's not bad about TDD I mean that's
something that you will have to do
anyhow finally people say well if I
write TDD my code is going to be better
well your code is going to be as good as
your test I mean if you
right code that is not readable and your
code is bad your TD your TDD tests are
going to be bad that's that's not going
to change how well how good your code is
so my point is that if you do TDD and
you want to and develop these
applications that you're working in on
in the future in a TDD fashion you will
get to a final result by improving
continuously the code that you write
while do you exercise the tests okay but
let's go into real-life probably some of
you if not how many of you have tried
TDD at least once
well okay cool so how many of you do TDD
most of the time well good so what I'm
saying is that yes we try we like this
is going to be my next break we're
starting from scratch I'm going to write
the next class and I'm going to write it
using TDD but that life gets in the
middle of that and you wanted to do the
tests but somebody is asking you to have
the class ready you have a deadline it
doesn't pass the first test you don't
know why but it's not working so well
okay let's forget about TDD and let's do
it as we did before well some of the
things that are tougher to tests are the
UI the visual part of your application
and people sometimes start trying to do
the testing of the UI and well we think
live this is too tough how do I emulate
the touches how do I know the
information that is required to be
test their do I test whether the color
is that or not do I test the font do I
test the size of the of the view what do
I have to test there we will discuss a
little bit about that in a moment
another thing that might be tough to
test is persistence
at least our relation with persistence
most of our applications are using some
kind of data that's a fact but then in
order to try your business logic you
need to have some sets of data you want
to know that this data is going to be
available and that the data fulfills the
requirement to test that part of the
logic and then you start having small
sets of data and then you start having
well what do i do do I leave the data
there do I have two pieces of data the
one for production and the one that I
that I'm using for testing mmm get stuff
so we will discuss a little bit about
how to solve that finally and this is
this is for people who have been working
with Swift or with other languages how
many of you have been using Swift too at
least for fun oh okay how many of you
have used protocol extensions great okay
so protocol extensions are in Scala they
are called traits for those of you who
have tried Scala too and they provide
the classes with additional
functionality that can be complementary
to the one that you have from
inheritance we thought having all the
thing that you get from inheritance so
it is an advantage it provides with a
clean cleaner design pattern for some
stuff and he avoids more
of the multiple inheritance problems
that you have in other languages so
trades are very cool the problem is that
trades are a protocol extension and a
protocol as you already know is
something that doesn't have an instance
is this yes a declaration of intentions
you tell by using a protocol one methods
you are committing to a implement but
you don't have any code for those
methods yet when you add a protocol
extension for those you're saying well
this is a generic implementation and I'm
going to be able to use this generic
implementation for these classes you
have restrictions in order to apply the
protocol but this code is not going to
have any instance unless you apply this
protocol to an actual class so how do
you test something that doesn't have any
instance who will discuss also about
this one so let's talk about TDD and
swift and I put a small - there is
meaning that the one that I'm telling is
not Swift square Swift - so let's talk
about how to do the testing of the UI so
well probably all of you know that Xcode
was offering you the ability to write a
unit testing so sorry not unit testing
UI testing I believe it was scored five
can anybody correct me on that you were
using javascript now you can use Swift
from Xcode 7 on and well this is not
unit testing this is integration testing
because what you are actually doing is
you're running the whole application and
you're trying to push that button read
that label or swipe on that cell
that is completely different from unit
testing this is not wrong I'm not saying
that this cannot be good for your
application I'm just saying that this is
not unit testing and this doesn't help
us to do TDD okay so we have the same
problem with other frameworks for
testing we give for calabash or cucumber
our integration testing so since TDD is
about unit testing about isolation of
our module and testing that model the
module isolated how do we work with that
well if we use an architecture that
decouples all of our a logic then it is
easier for us to be able to work with
the view in a separate way so the view
is going to be mostly passive passive
and it is only going to accept a
commands from the rest of our logic and
provide the presenter with the events
that happen on the view and well some of
you might be thinking well another
architecture well this is not mine
architecture this isn't not my idea but
this is the idea that comes from Uncle
Bob's cleaning architecture that also is
an improvement on other architectures
like the onion architecture or the
hexagonal one so what all of these smart
people have been thinking about is well
we really have to focus on having single
responsibilities and having single
responsibilities and a good way to
communicate things is tough initially
but if you do this properly is very much
easier to test and
if you have this view completely
isolated and without any logic in it it
is very much easier to test I don't want
you to take my word for it I want to
show you some code of how to do that so
this is a say your table cell is a
subclass of a UI table cell as you can
see here and this is actually an actual
so it is a the one that I will be
showing at the workshop in two days and
as you can see here you have three
outlets and the three outlets are for
the each of the three labels that are
going to be presented in these table
cell I have three methods and these
three methods are implemented here and
they are declared in this protocol that
is the protocol that is going to be used
by the presenter so these methods are in
order to change these three fields the
name the title and the date and notice
something that is very important here
the date I could pass an inner state for
example which is the object that
provides a date within Coco but I'm not
doing that because I don't want my
viewcontroller my view to be smart
enough to translate the date into
something that can be used in a view I
only want the view to display text or
colors or things that are done enough
okay so when I have that is very much
easier to test that I don't know how
well this reads from back but let me
help you with this I have a method here
there is the one actually doing the
testing and what I do is I create a
label that is based on this mock that I
have written this is Swift
you know that Swift is
not as good as objective-c in terms of a
dynamic dispatch in so all of the
mocking libraries mocking frameworks
that we were used to and we loved before
can they cannot be used in Swift but
that is not a big issue because we can
write our own mocks in our test cases
and this is what i'm doing here i'm
creating a label mock which is a
subclass of UI label i'm over ray
overriding the text property that is the
one that is displayed when you have an a
label and here what i'm saying is well
if this property said after it has been
said i want to set this flag to two to
true what i'm saying here is that i want
to know if this property has been used
has been set okay so that's very easy
here what I do is okay I want to use
this label mock as the date label notice
that is this this is the one that I was
mentioning that it has no intelligence
to provide any formatting of the of the
date but it just displays the text that
you provided with what I do here is I
exercise I use the method that I want to
test which is the display date submitted
and I use these which is a constant that
I have defined before here then I have
gets to check whether the label has been
used this the text has been set and well
the value is the proper one that's it
very easy to test and it works not only
with these cells but with a view
controller the table view controller can
be tested that's hey this and the only
requirements that you define the proper
protocols in order to abstract the
communications between the different
classes
the persistence same thing here I mean
like it is a requirement for the things
that we do to have the persistence to
have the proper objects available for us
there but but we don't actually need the
objects to be persisted in order to be
able to test that so what we want is to
provide an abstract class a protocol
that will provide us with the data that
we need at that moment in time for that
test so this is a little bit more
elaborated version of the architecture
that I show you before this was the view
that I was mentioning that is not only
the view but the view controller also
this is the presenter responsibilities
of the presenter as I said is listening
to the events that come from the view
and doing all the presentation logic as
the name implies the presentation logic
can be something like the date is
formatted like for Europeans or for
Americans which is different or it can
be even something like the date is
formatted formatted in a relative way so
for example if you use any Twitter
application use sometimes who prefer to
have the date represented as 30 seconds
ago or two days ago instead of at that
moment in time I prefer to have to know
how long has passed since this tweet
than having something presented to me as
the actual time date and time for that
event so here you have a presentation
logic you can change that behavior and
this logic will happen here in the
presenter the interactor the interactor
is the logic the business logic of our
application this is where the use case
the use story lists happens and this
interactor a is agnostic of the
persistence that we use and the
presentation that we are going to do
with it so it only takes care of the
business logic of what we want to do
then we have this repository pattern
this is a class that obstructs access to
our data and it can be using a web
service connector so I'm gonna be using
an API from somewhere else or it can be
used in local persistence here or a
combination of both or I can be used a
mash-up I can be using a mash-up of many
web services
these will abstract the information that
comes from there let's say that I want
to be able to rent a bike if there is
Sun in some place so I'm not accessing
an API for the bike renting service and
another one for the weather service so I
can I don't know how mashup these
information and send it to the user in a
way that is useful to them ok so what I
will do in order to test my business
logic despite of the persistence is to
isolate this interactor which I will do
by having protocols that define the
abstractions of these two layers and
this is how it's done this is a very
easy interactor and this is in order to
present a list of speakers and what I'm
having here is the name of the
interactor it has a relationship with
the entity gateway and it has another
relationship with the presenter and as
you can see here I only have an
initializer that will take the data the
connection to the entity gateway and
this is the method that takes care of my
business logic what I do here is method
says what is going to do is show all the
speakers and it gets their entities from
the entity gateway by fetching the data
from this repository and then it
converts this data into something that
can be used by the presenter which
an abstraction is an abstract is a value
that will be passed on to the presenter
in order for each to modified and tell
it tell the view what it has to do very
easy so how do I test that well so
there's no thing not much that I have to
do here I can create a new memory
repository that has an object and I can
check whether this is passed on to the
presenter properly so I have mock for
the presenter and then I will be
checking whether these data matches the
data that I have in there in this fake
repository notice here that I ignore the
case and this is using a guard statement
ignore the case in which both a lists
both arrays don't have the same number
of elements because it makes no sense I
mean if I have three speakers I want to
show three speakers to the final
presenter very easy to test I don't need
anything related to a core data in order
or a web service it is crazy to write a
unit test that talks to a web service
and provides you with the data from the
web service in and exercises that
because the delays of the web services
probably all of you have noticed that
running tests in Swift at least for me
it takes longer than then it did for
objective-c because well the compiling
process is well can be better okay then
also it is true that it takes a while at
least for me to to have this running
into the simulator or maybe my machine
is getting old but it's only 1/2 years
old so I don't know but the thing is
that this is not the case that we want
to have something that goes to the
network brings the data and we exercise
this data into the application
so what we do want to have is an
abstraction of this information that can
be fed into this a use case and that we
can test properly here finally the
testing of the traits and I didn't want
to have a protocol that you're not
familiar with so and I didn't want to
spend a lot of time explaining what
protocol extension could be so I decided
to use the one that is explained at the
WWDC talk of this year the talk is
called swift in practice and it allows
you to have enumerations for the segways
in your view controllers I think it's a
nice idea and if you want an explanation
of how this protocol station works you
can go and view this talk which I think
it's a very nice one so the
implementation that I have here is
straight from this talk and is a
protocol that it just defines this type
alias is a say segue identifier that it
has to be real representable which means
that it had in my every case will have a
row case a row value and this a these
are the two methods that is suffering
the one is in order to perform a segue
with an identifier by using one of these
inin cases and another one here is the
segue identifier for this segue case for
this enum value that will be used in
order to have a switch that goes through
the cases instead of the strings of the
identifiers so how do you test that well
it is quite easy the things that you
have to do here are to have a class that
uses that code and how do you do that
you do a mock that is the class that you
want to
that will implement that protocol here
so here this is the mock class and is
not only implemented UAV control which
was one of the requirements of the
protocol of the local station Suri
but it is also implementing these
protocols tension that I mentioned so
what I have here is these two
identifiers for these two segues
fictitious ones obviously but I also
have a method here that is overridden
and that will be a the one that records
the the call to this perform segue with
identifier you know the difference
between mocks and stubs stab is
something that tells you what you want
to hear and a mock is something that
tells you what you want to hear and
records what you said okay so this these
are called nanny cams in States and I
like the ones that you have in a bear
that you have a nanny with the babies
and you want to see what she's doing
with the babies
so these nanny cams are closer to mocks
okay so this mark here is recording the
parameters of the of that have been used
with this call and what we do then is to
check whether these perform segue with
identifier invokes the classic version
so it talks to the actual method and
whether the parameters are the right
ones so it uses this the first segue
identifier in first case and uses the
second one in the second case very easy
then I've been testing my protocol
extension besides a I mean in despite it
not been applied until it has a class I
don't need to have the actual class
there I mean I don't have to try this
protocol station for every class that it
is applied to I instead test the
protocol station by itself
so that value of the results of these
tests can be applied to every other view
controller that I apply to this
particular station too so let me
summarize and then I will take as many
questions as you wish after all these
tests that we have been talking about
the thing that you do is that you
continuously improve the resource of
your application by running a new test a
new test that covers more cases more of
your use case and that takes you to a
higher level and all these tests can be
applied to these a different parts of
the architecture so if you have an
architecture that is define as the one
that I showed to you and that
differentiates and that isolates each
part of the application each
responsibility of your application it is
easier to write all those tests let me
show you
because sometimes unlike people when we
you do something like that
so this is a view controller yes a view
controller and as you can see here I
don't know if you can read that
these are 92 tests okay but notice here
that these are the tests for the
appdelegate
these are the tests for the memory
repository here this is a connector I
didn't talk about those here the this is
the the protocol station that I
mentioned the interactor and also the
classes that I use for displaying the
data so when I run this test suit then I
get a very nice message saying test
succeeded which means that every one of
mine 92 tests have passed and that this
view controller is fully tested and
don't take my word for that you go here
oh yes a second
this is to get the go there coverage
data and I have to run the test again
and for this piece of code that I'm
showing to you
this is the coverage Oh my class okay so
well not bad you can do fully tests of
your view controllers you can fully test
your persistence you can fully test your
business logic okay so let me go back to
the presentation
thank you very much yeah I would love to
get questions and I will try to answer
them as well as I can in any case if you
want to do any tweets afterwards please
include this hashtag so I can look for
it and try to answer if you think of a
question
after session and please please do rate
this session I would love to know what
you think about what I told you thank
you well not really I mean like the
thoughts about BDD BDD let's start with
that BD DS behavior driven development
and one of the goals of BDD is to be
able to express how the application
should behave in terms of something that
can be written most of the times in a
way that even the user can express
clearly most of the times I don't think
this really works somewhere like these
domain-specific languages are not really
that expressive for the common users so
we finally end doing something that is
like well ok you know that what the use
of one so do you translate it to this
language and then we use that
information in a way that can be used as
the definition of the test nothing wrong
with that but I don't think that it
helps that much if you do want to do
testing I mean like I'm all for it I
mean if we did is your thing go for it I
don't have anything against BDD what I'm
just saying is that I don't think that
the common user the business people can
use these languages to express what the
application have to do
any more questions are you testing like
that do you get like 100% coverage no
who do you love - really are you gonna
try who's coming to the workshop in
today's rate okay so there we will be
trying to do TDD and we will be trying
to do this improvement of the of the
architecture in order to have these
tests running sorry if you have
something first thing is that well you
actually can test the decor data a stack
if you want to I've been doing this for
some time and I think that is perfectly
feasible and what you don't actually
have to do is to test the data itself I
mean like I don't think it's a good idea
to test that they can take the the
contents of the database are what you
expect it is not also a good idea to do
the fetch of the data based on said that
you have created and yes check that the
fetch is properly done because as I said
at the beginning this is Apple's code
and you should test apples code the
thing that you could do instead is to be
able to create some a memory persistent
store which is very easily done and what
you do then is you pass you create this
stack as a fake one the stack that you
do you use for testing and then each
subclass of a managed object will be run
within the this new stack this new stack
will be any memory persist
and store it will share the the the mom
I don't remember the meaning of the
letters the the managed object model
thank you so the managed object model
will be shared by both stacks the only
difference the only actual difference
will be that for the real one you will
be persisting the data in a file or in
many while in the data that you use for
testing the data is not going to be
persistent because it will be created in
memory my recommendation is that you
create this stack for each of the tests
so when you do the setup and the
teardown of your test case you create a
stack you run your test then you destroy
the stack and again it looks like a lot
of work it probably is it takes longer
than yes a variable but since it's
happening in memory it is very fast so I
have a lot of tests running core data
and I don't think that's an issue you
can really run them properly but this
what I what I was saying is that these
will have to happen at the persistence
layer while this is completely unrelated
to what happens at the business logic
and completely unrelated to what happens
at the persistence and the presentation
logic you can you must be able to test
each one of these layers separately the
requirements for writing a good clean
architecture is that the layers that you
use have a dependency that can only go
inwards so in the out outer layer of
your a code you have things that you may
be willing to change in the future like
for example the UI or the database if
let's say that now you want to change
from core data
- real or the other way around or you
want to use police because you have
realized that you don't need that much
power there same thing happens with the
UI and probably you say okay I'm using
the UI the one that apple provides me
with for the mobile phone yeah and now
you want to address the Apple TV and now
you want to address the watch OS so if
you have your views completely separated
from your business logic this is going
to be very much easier a lot okay
because your view layer can be even a
different one for each of your targets
so your targets will be using a
different view depending on whether you
are addressing the Watchers or the Apple
TV or the mobile phone I'm all set okay
so did you solve the old question so
thank you very much feel free to calling
me any mess
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>