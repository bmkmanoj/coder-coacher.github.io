<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Continuous Delivery for Embedded Systems • Mike Long | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Continuous Delivery for Embedded Systems • Mike Long - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Continuous Delivery for Embedded Systems • Mike Long</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DcFe6cEvnGQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I run my name is not Mark Coleman and
I'm not talking about marketing driven
development so if you are hoping to see
that talk this would be a good time to
either learn about how we do continuous
delivery for embedded systems or find
somewhere else to be because
unfortunately I know nothing about
marketing so I'm a continuous delivery
consultant but that's not my that's not
been my career actually I spent most of
my career working with embedded systems
and for me the interesting thing in the
last ten years is how much that's
changed I mean when I started and in
2004 making embedded systems that was a
very different industry than it is today
and most of that's to do with what we
would call continuous delivery these
days and that's what I want to talk
about just out of interest how many
people here currently work on embedded
systems projects or product development
or have done in the past
okay cool I didn't expect that there is
an app there are buttons on it
push them all so this is what I'm going
to talk about what is continuous to the
rate I think I'm going to go through
this really fast because this might be
the tenth explanation of what is
continuous delivery today and then we'll
talk about you know the embedded stuff
so going back to 2004 I was a
bright-eyed and bushy-tailed recent
graduate from University and I was I
joined a company and I was I was the
sole software engineer on a product the
idea was we were going to build a
drilling tool for the oil and gas
industry that you could steer as it's
spun around we would steer it through
the through the through the ground and
eventually hit oil I didn't know
anything about professional software
development at this stage so I took a
lot of notes and I'm gonna share them
with you today so I managed to reverse
engineer what professional software
development was from
that very interesting project so the
first thing you do is you want to take a
copy of this code base for an existing
product this is a great way to start
because it's already been tested and you
know you're professional and you don't
want to cause any harm to the existing
product so you make your own little
sandbox coffee then you carefully
document all of its current algorithms
because you don't really know what it's
supposed to do or how it works so I mean
this is a really important thing to get
right so spend a few months on this and
then because you want to hopefully merge
your changes back into the original code
base that you copied from you add all
your change is surrounded by F deaths
and of course if you put it surrounded
by F devs everyone will know what code
to look at and then you you test and you
test and you test and you go to the
field and you test and you test a new
test and then eventually you get to the
stage where you're kind of happy it will
probably work you can met the code at
this stage this is when you have to
figure out what a version control system
is you have to find out how to add code
to a version control system and so you
add all that stuff and maybe you put it
in a zip file that might be easier but
that's what you do and then of course
now it's ready so you have to compile it
on your laptop because that's what you
test it so you have to have the same
environment and then you ship it you put
it into the the product database for the
tool manufacturing go off and make a
thousand to them has anyone ever done
professional software development well I
know I have and the reason I knew is
professional was because we had a
software development process that I
followed to the letter and that was part
of the product development process which
was in turn part of the product
management governance system so I this
was professional software development of
course I'm being sarcastic but actually
this was how that's this was having my
very first project and Industry was and
I think this is completely typical in
the embedded systems world
as far as I've seen I've seen a lot of
projects and this is more typical than
any other software development process
we might have heard of Eugene Spofford
he's a professor at the University and
he's talking about the changes that we
have in attitudes towards the the way we
implement these systems these typically
safety-critical systems and he tells a
story about the this was around the
1990s when there was the start of the
fly-by-wire systems and airplanes and
there was a there was always a joke
amongst engineers because Boeing that
Airbus would use a lot of formal testing
formal methods formal testing and then
the guys at Boeing they would instead
focus on peer review and and they would
also send the engineers on test flights
so they thought that you know that would
give them the added incentive to get
things right and but and back in the 90s
they would the joke was well I'd rather
fly Boeing because you know they had
their necks on the line right but I
think things have changed now where we'd
rather see that the there was a formal
proof to show that the these systems
work and that's just another example of
the changes that have happened so we
know that continuous delivery is quite a
recent name but it comes from the agile
manifesto the of the principle one in
principle seven from now ja manifesto
kind of where the were that we're the
names for these things came from we know
that continuous integration as as this
code good enough to share with my
colleagues and we know continuous
delivery as as this code potentially
shippable so you just push them together
and that's that's the story of what
continuous delivery is now continuous
delivery as a concept is very easy to
grasp - especially amongst anyone that
comes from some kind of engineering or
management backgrounds I mean it's
simple you have basically a bunch of
checkpoints and if you go through the
mold and your code is okay the challenge
is with I think a lot of times the tools
and the context because
as a concept it's very easy but on the
implementation side it's much more
difficult so one of the one of the
things that's always like the the
central tenets of continuous integration
is that you're integrating right we were
always integrating with all your other
colleagues so then we have to think
about how we do version control so we
end up going towards a release train
where you have only one long-lived
branch instead of for instance making a
copy of a codebase you would always live
in the same version control system
always have one source of truth now this
there's a great book from Hewlett
Packard actually it's printed by
addison-wesley but it's about the story
of the HP laserjet business line and the
the transformation they went through
from 2006 to 2011 and the that's an
example of also how to change very
embedded systems and the way you deliver
them and there's a great story in this
about what they call product variants
and I think this is also something very
common in in the embedded systems world
is that you use these use branches and a
very very wrong way and that we take a
new branch for each product and then
we'll cherry-pick changes around when we
need to so in the end you have 12
products you have 12 branches and you
never know what's fixed where so if you
if you are living in that world I
recommend trying to do something about
it as soon as possible because it causes
an awful lot of waste in your system and
if you are interested at all in embedded
systems this is a great book but then
the thing about embedded systems is
there are challenges that we don't see
and any of the other talks we saw today
actually and it's I think it's to do a
lot with the tools as well the the
people making web apps or making iPhone
apps or so on there's millions of
developers all working on these systems
so they have huge tooling support and
that's that's something that we're
really lacking in the embedded system
space but as well as the two
there's there's the fact that we're
nearly always working on our own and
yeah that's that's true that we we we
don't get all the feedback from other
people but we also lose the chance to
learn from from bigger pieces of
software and making them making them
together to think about these things
what we tend to do is instead to have
these kind of fire-and-forget Pro code
bases where we're trying as best as we
can to to make a product that we end up
manufacturing somewhere abroad which we
make a thousand a hundred thousand a
million of these devices and we never
touch that code again and I think that's
part of the reason why we struggle with
quality it's also partly like why would
you invest and making good automated
tooling support when you know that in
two months no one's going to change this
code again so that's one side of the
coin but the other side of the coin is
actually a lot of embedded systems are a
long-lived and they are product lines
that go on for a long long time this is
their this is the iOS product line but
I've been on actually when I was working
in marine seismic acquisition we would
build systems with a twenty to thirty
year timeline horizon so when you build
embedded systems in that environment you
have a very different approach to what
is a good investment in terms of the
long term another challenge we have as
generally we don't have we don't have
the the hardware that the software is
going to run and so as you start
developing it you don't really know what
your target environment is going to be
like nevermind how to automate and
deploy how to automate testing all these
things are very difficult this so this
is life over and he's one of my
programming hero heroes and he's my
programming hero for never have written
a line of code in an entire year he was
brought in as a specialist to try and
solve a very difficult bug we had and
one of our systems that was very
intermittent and you would
almost never see it but when you had
thousands of these things out there
running in production that would happen
all the time so anyway he spent three
months in the lab just trying to figure
out what the problem was how to
reproduce it because it was weird he
would add on a printf and all of a
sudden the bug would appear and he would
shuffle a couple of lines of code down
and the bug would disappear and it
seemed like there was some kind of ghost
in the machine so eventually he made it
so that it could actually reproduce this
thing at will and then it became quite a
lot easier to get to the problem not
simple what turned out to be the issue
was the operating system the had some
registers for when you did context
switching from coronel to to tasks so
when you when you did a context switch
it would save all the registers didn't
go into the interrupt context and so on
but it wouldn't save them all and there
was one one little flag in one register
that determined whether a loop should
terminate so the way this bug would
manifest itself was all of a sudden you
would exit a while true loop and nobody
could figure out how that was even
possible and it was just because we had
no control over that so we had two
problems one is that the compiler vendor
had gone out of business so we had no
luck there and to the operating system
company had been bought by another
operating system company and
discontinued the product so in both
cases there was no solution except we
were very lucky and that at the end of
the the routine that was saving the
registers the compiler had inserted
seven no op instructions as that often
does - to get memory alignment nice so
we were able to patch the binary just to
save that one register and that's why
life over is my programming hero but I
mean this is another example of where
the tools and the systems we use are
really a pain and
systems and I think that this story is
also a large motivation for why nowadays
we're moving more and more to using
open-source tools and the embedded
systems when we can we're going for free
our toast we're going for GCC compilers
were going for really standard arm
architectures where we can the other
problem we have of course is right here
is the the license management all of our
tools they cost $30,000 and they come
with this big big license so to have an
extra license just for test automation
is actually quite a hard sell in a lot
of organizations so versioning is an
interesting one embedded systems because
it actually matters it matters a lot
more than it doesn't and for instance
cloud environments where the ideas you
just keep moving forward like Google is
never going to try and reproduce the
exact build that happened six months ago
they're just going to build something
new but they don't care but for embedded
systems you really care because if you
made a product is shipped 10,000 radars
to to a supplier and you won't they come
back with a problem two years later and
say you know we're getting this cook
error we need to be able to reproduce
that exact build with in order to be
able to help them so like getting there
it's yeah it's you have to start right
from the very beginning what is a
version thankfully I mean we have a lot
of help now with semantic versioning I
think nobody's mentioned semantic
versioning today so I'll just give a
brief introduction there's a website
semver org it just gives a brief
overview but the idea behind semantic
versioning is that you use the version
numbers mean something and you can you
can use the numbers to relate to
dependencies so first of all you have
whatever the artifact is and then the
major minor patch numbers which is your
normal software approach the important
thing is like and this semantic
versioning major means breaking changes
minor means non breaking changes and
patch levels means
fix's then you can have some pre-release
version after it if you so choose alpha
beta rc1 or nothing then err everything
after the plus sign you are free to do
what whatever you really want so a
typical thing I would do is to add a
build number and then the get short
shaft for the the source version where
it came from in the version control
repository is anyone using semantic
versioning just now only this side of
the room what do you guys did so you can
also specify snapshot versions for like
the ruling builds and so on so what we
do and embedded systems is we we want to
get all that information not only on the
file name it's not enough to have it on
the phone name because we never see the
file once we've shipped the product we
need to build it into the binary so that
we can either read it out through a
debug port or we can we can look at the
flash and use strings on it or something
but the important thing is this
information has to be stamped and to the
binaries so I mean this is a typical
thing you would do you have a build dot
H where you doing in your Jenkins build
or whatever you would you would stump in
the real information there and then you
have a version header file which kind of
brings it all together
nothing nothing too strange here the
important thing is that during your
build you include this and you find a
way to tell the world about it once you
once you're in runtime
now then there this is an old an old
story I think maybe even 15 years old
this blog post is from Jeff Atwood and
it was talking about back then after a
lot of developers f5 button was their
build process and it was a nightmare
because it only worked on one
developer's machine and a build on one
machine was different from another
machine so he wrote this very good blog
post about getting your build process
out of the ID and putting it into a
script and that's great it's really good
advice
it's still something we struggle with in
embedded systems but it's just as valid
today
but there's still a couple of things
missing from that equation is like the
traceability is even if you put it in a
build script how can you find out
exactly the build environment for this
build and this the second thing is
reproducibility even if you have it as a
script can you build the thing again
with the same results and as engineers
or we say okay well what I've seen
people talk at conferences about
continuous delivery I know I just have
to put this in Jenkins
and so they create a Jenkins job with
all that information and that is an
improvement because then you have at
least one place where you have that
global context but there is still a
problem that in a sense this is still
pressing f5 in your IDE because you've
got no control over what someone does in
that and that job configuration they
could come along and change that like
the build a build job today could be
have been completely different six
months ago and even the the build
machine at ran on could have changed so
a common next step would be to use like
something like job DSA where you can
define your jobs as code and version
that alongside your your source code
anybody using job DSL or Jenkins
workflow oh and you should check it out
it's a really great system and then
beyond that it's okay now you've got
some automation how about the rest of
your ecosystem what about the context
that all this builds run and how do you
trace the version of in the source code
to your your tracker there was a guy
from Atlassian talking about how they do
it in their system there's a lot of ways
to track your your work to your code to
your build to your build environment to
the artifacts that were made to the way
they were deployed their solutions
everywhere but in the end the whole idea
is the same you want to get all of your
all of your configuration everything
that's a context around your build
system ask code so that you can version
it alongside your your-your-your code
and you can go back in time because it's
it's quite common into the embedded
systems
we need we produced this prototype a
year ago it's been some suppliers have
tried it for a few four six months nine
months they've actually built a product
director but now they want a hundred
thousand to them but can you just change
these few things and only those few
things so the configuration is code can
really help with that that's enough
about that now then testing testing is
hard it's always been hard that's why we
don't do it but it is possible I mean we
still have a test pyramid there's lots
of different test pyramids this is why
not use martin fowler's we don't have a
UI usually sometimes we do but we still
have a system and we still want to do
fill system tests we in order to do
system tests we have to overcome a lot
of things though right we need to be
able to control power we need to be able
to program the device you know download
the things onto flash we need to control
physical actuators we need to sense the
results somehow we have to crack open
the black box and control its codes
bounded context and these are all solve
problems it's just work right we
generally don't have a service-oriented
architecture either but we do have
components and it's really valent to do
component tests if you have a signal
processing library let me take each step
in that signal processing chain and and
have a test harness around don't have a
vise so that you know if the noise floor
changes you're not going to get into
trouble and unit tests or unit tests and
they're applicable you should use them
everywhere they're great so you might be
thinking why do I have all those unit is
why do I need fill system tests or if I
have system tests that test my whole
thing as a box why do I need to bother
with writing all those unit tests isn't
a duplication and I used to worry about
that quite a lot when I was a young man
and it wasn't until I read this but
growing object-oriented good guided by
tests that I actually I really grasped
the meaning behind us and it was that
the point is that different kinds of
tests give you different kinds of
feedback so unit tests give you an awful
lot of feedback about the internal
quality of the code how easy it is to
change how internally correct it is how
well understood it is from the
programmers point of view but on the
tells you nothing about whether the
system as it's as a whole meets the the
requirements of the customer or as a
whole does it work as a product on the
other hand the fill system tests tell
you heaps about that and tells you as a
whole the system does what the customer
wants but it tells you nothing about how
safe and quickly you can change it so
that's why you need both so test
everywhere test on your hosts because
that's fast it's a really fast way to
develop while you're doing your unit
tests away from hardware on the host
that's a great way to have a productive
development environment but also test on
the target because on the target things
are different things can behavior can
change in different ways we've got
different compilers we've got different
hardware behavior and some customers
that I know they actually ship their the
unit test as part of their product
builds I know Cisco does this at least
and so that if they get a customer call
and said we were having trouble with
this machine they can access H into the
device and run the unit test and see if
anything looks a bit spooky because
sometimes it could be just that there's
a dodgy memory or the flash is flaky you
know you never know obviously shipping
your tests really depends on what the
device is I mean not everybody has room
at least for those things a company I've
been doing some work with a very
interesting company they make a radar
system tiny little radar like this very
low power and they solved
a very interesting testing problem was
that how do you test like how do you
test a radar system and a reproducible
manner like they make these things that
can detect presence in a room or see how
fast you're breathing check like
creating baby monitors and so on and one
of their engineers actually figured out
that actually if you take a ball bearing
about 0.9 centimeters in size and rotate
it like this so a radar that looks just
like the chest cavity of a baby and you
know you make a bigger ball bearing it's
an adult chest a smaller ball bearing
it's a premature baby and what they
figured out is well actually Lego it's
plastic so it doesn't get much
reflection on a radar so why don't we
why don't we set up a lab with with all
this hell this Lego and ball bearings
and they have an automation system
around that so I mean it's a nice story
but it a kind of every time I've seen a
interest a full system entrance test on
an embedded system it's always required
a bit of out-of-the-box thinking that's
that's why another reason why we often
don't do it but it's really valuable
thing if you can automate all that
systems you can get a lot of feedback
about your about your software okay some
some tips avoid using the preprocessor
at least for product variants it will
mean you have to build lots of different
systems like you basically have to build
for every different type instead of
having one file built one time you can
have one built one file built 17 times
depending on how your product variants
interact it also lowers the cohesion
because when you're looking at the code
you don't know actually
if this isn't if this is included if
that's included it's really easy to make
mistakes only build your binaries once
as well because what you want to do is
make sure whatever you build is the same
thing you test and it's the same thing
you ship there's no sense in
building something doing a bunch of
tests and then doing another build later
maybe when you stamp the version that's
just a waste it's a way that errors can
leak into your system just about
everything to do with continuous
delivery is about a feedback loop
basically you want to get more and more
feedback from your system so you can go
faster
so the TDD gives you feedback that as a
developer I'm writing the code that I'm
actually think I'm writing that F
statement actually is the F statement I
wrote and then you go to continuous
integration you say well actually that
code that I wrote actually works with
Dave's code or John's code and then
start to think further up the system you
get to like the the build measure learn
of customer feedback and like the the
product I made and shipped to the
customers as giving me this feedback on
the market so we should do more of that
and another thing is that the
development environment is I mean more
and more companies see it as a
competitive advantage not just in terms
of we can use this to go faster but I
know people I know it's really common
for engineers to say I want to work at
it I don't want to work for them because
it takes it takes two days to get a code
committed well I don't want to work in a
system that I don't want to work in an
old version control system and and these
things are really important when it
comes to recruitment but also add
matters a lot to customers customers
care a lot about how quickly you can get
this stuff to market and I want to give
some examples of that
does anyone here drive our test law no
no me either I wish I did but one of the
really nice features of the Tesla is
that it has this over-the-air update
system so over in the night it will get
new software and it will run some self
tests and then in the morning you'll get
into the car and they'll say ok and
there was the famous story is that there
was a user who was really upset on the
product forums because when he was at a
stop sign on on a hill it
his foot off the brake and put it on the
accelerator the car would go back a
little bit it's like this is ridiculous
lots of cars have got he'll start
features you should be able to keep the
brake depressed of it efforts on a hill
and okay somebody in I guess in product
marketing saw this and then it went
through the the engineering division I
hope it was tested but eventually who is
step to somebody's car and can you
imagine you know how happy he'd be
getting into his car
three months after complaining on the
forum and putting on his car saying oh
you've got a he'll start feature that's
kind of that's one that's like the
poster child of how it could be or
things cool great but there's also
another side right is that security
experts hack your product oh no and
that's that's a big problem for a lot of
embedded systems especially if you ship
like bash for instance or SSL or
anything that has all kinds of
vulnerabilities that get discovered
after it's been shipped this actually
turned out to be quite a positive story
for Tesla yes the headline is not pretty
but actually further Darren into the
article they say that the researchers
that found this problem they were
actually gave a lot of praise to Tesla
because when the security researchers
came to them they said okay great thank
you for finding this we'll fix it they
fixed it and pushed it over the air to
all the cars right there's a flipside as
the Fiat Chrysler had to recall one
point four million vehicles because of
bugs found on their onboard systems and
okay this is this isn't fear-mongering
but I mean an RIA product recall can
cost an awful lot of money and so being
able to have a update system and a
continuous delivery system can really
make a big difference and your and your
in your business okay so that was a
quick kind of to or through embedded
systems and continuous delivery and how
those things go together do you guys
have any questions for me I think we
have time
okay so the question is could good
customers be upset if they they get new
features that or at least the
functionality that they had before
changes and I think that's definitely a
risk you know it's the risk with every
kind of update of any kind like as soon
as you're starting to move people's
cheese there's a chance that they're
going to be upset so I think that the
for Tesla at least that they've managed
to make their customers really happy
because they feel like they're they're
basically getting added value they
didn't buy a car and then that was that
and then they have to get the next one
two years later they bought a car that
was continuously improving and I think
that's one of the reasons why customers
really you like it and especially when
it comes to like these stories of
security vulnerabilities and new
features that you really wanted but they
didn't have at the beginning I think
that in general it's a positive thing so
the question is about how how do I feel
about simulators and and I guess
emulators as well so again the they're
all they can be useful tools and as long
as they improve your feedback cycle then
there's no reason why not to use them
and to use them during a testing phase
especially if you don't have hardware
yet because quite often it's quite late
and the the the development process when
we finally get our hands on this on the
Unreal hardware so using simulators
early on is very helpful and writing
test systems around simulators can be
very helpful as well because once the
hardware arrives you can replace the
simulator for the real hardware and
you'll have a full test suite ready
actually when I started with TDD a while
ago that was because I was I was writing
a power supply controller and I didn't
have the hardware the hardware was not
ready yet and rather than sit and write
documentation I actually wrote the the
power supply controller with unit tests
off target on the host and with just
with mock mocking out the actual
hardware interaction and then when it
came along I just I just ran it on on
target and it seemed to work fine and
after that management gave me a lot of
support to try and
spread this through different other
parts of the systems because they could
see that actually they got working
software faster then than they did from
just hoping that the this the datasheet
that got sent was the correct
information so the question is about
risk adversity and and in the industry
and how that relates to continuous
delivery and I think there is a lot of
risk would there is a there is a fear
and the industry for sure but I think
that and in general the embedded
software industry seems to address the
risk I think it's more like they're
trying to get quality by being careful
so they build these very fancy
development processes and very strict
review processes and then they'll
they'll take Misra C and then make sure
that you have to do this and you have to
do that and seventeen people have to
look at each line of code and it becomes
like this quality by being careful and
it's not really it's kind of there's no
real security in that and I think that
once an organization starts to adopt
more automated processes around testing
especially that they start to see that
okay this is much more valuable in the
end you you're as a developer you always
just adding code right whether it's
going into something that is
continuously tested or not it doesn't
really matter
I mean after it shipped when you're
doing updates that's another risk factor
as well but I think in general having
all those safety nets that the testing
is where I've seen it happen people have
really valued it so the question is how
does does TDD and BDD and these things
help improve software design and hard
and hardware design I haven't seen it
actually impact hardware design at all
in fact I've I've seen very little
evidence that software engineers have
any ability to to make any affect on
hardware design at all but in terms of
the software yes a huge huge improvement
and the software design because one is
that you have to stop relying on the
preprocessor for doing
a lot of kind of ugly hacks yeah because
otherwise you can't test your code and
then you have to be really clean about
your your dependencies when you start
using testing so even if you're using C
and so on you really want to have
isolated modules and you want to control
what what is public and what is private
what is a you know what is static all
these things really help and I I mean
I've only seen maybe ten maybe even not
that many ten embedded systems and
projects that have really dived into TDD
but they've all had really excellent
code quality okay well thanks remember
to rate the session and enjoy the rest
of the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>