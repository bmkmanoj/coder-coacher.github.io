<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Why Backend for Frontend Is Key to Your Microservices Journey • B. Grant &amp; K. Ramanathan | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Why Backend for Frontend Is Key to Your Microservices Journey • B. Grant &amp; K. Ramanathan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Why Backend for Frontend Is Key to Your Microservices Journey • B. Grant &amp; K. Ramanathan</b></h2><h5 class="post__date">2017-09-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PwgQZ8eCGxA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we in this talk we're gonna talk
about why back end for friend and is key
to your microservices journey this is
specifically a Morningstar's use case
it's a perspective from a mobile team on
how they leverage this architectural
pattern so before the logistics please
do go and raid this session in the app
we highly value that so I want to
introduce this Brian hey so I'm the
second half of the talk my name is Brian
grant I started programming
professionally about 2005 and joined
Morningstar in late 2012 I have kind of
significant contributions to the design
and the implementation of the BFF that
we're going to be discussing today and
I'm currently a technology manager on
morningstar's
individual investor mobile team and I'm
Christian Ramanathan and director of
engineering at Morningstar I've been in
the software industry for 18 plus years
coding leading managing and architecting
software systems I'm passionate about
micro services DevOps AI and machine
learning so let's get started who we are
Morningstar at core is a investment
research firm and our mission is to
create great products for that help
investors research financial goals so
now I talked about investors we have
client segments ranging from individual
investors like you and me your products
for them to clients like financial
advisors to products in retirement space
and also asset management we spread
across 27 countries and we are roughly
42 hundred plus employees and we are
headquartered in Chicago
so we are local how we serve our clients
so the key to any investment is having
access to quality data and making an
informed decision using that so the baby
cell clients is providing data at the
foundation for us and then going up the
pyramid we provide value addition on top
so we provide software products and
visualization Honda lytx and also access
to analyst about all investments at a
higher level of the value proposition we
also provide advice so we we do manage
investments we manage the portfolio both
from the investment perspective also
from the retirement retirement accounts
let's go to the talk back end for friend
end so I took this description from snap
Newman's blog post he's the author of
building micro services he did a great
talk yesterday our on feature toggle and
and feature branching it was pretty
interesting so you know he's also the
host of micro services track today so he
came up with this description and he
also credits this architectural pattern
to Philly Kyle Cairo so the idea behind
this pattern is instead of having a
central core back-end API either use the
you focus more on building a back-end
for a particular user experience so in
this case the diagram on the Left we
have two back-end for front-end so the
desktop client you build up have a
back-end for it and similarly for your
mobile app you have a back-end for that
user experience the diagram on the right
is a slight variation of it you would
see that you you can't have a back-end
for your Android
different than a vacuum experience or a
user experience for an Android so
basically you have two separate back-end
for friend it for your Android and one
for your iOS the key driver to use these
pad and is typically you would see the
mobile space you have the you you
generally tend to have less data the
user experience is slightly different
and also you you have view specific
back-end you need a view specific
back-end to cater for your user
experience so I'm going to walk through
our journey how we started probably ten
years back we had this desktop product
which we built which I would say he's a
key b2b product I can't disclose the
name right now but it was primarily a
BFF we started off with the BFF at that
time you can also call it a monolith the
whole idea behind that was we we
basically we may have an API layer that
caddis for all the user experience at
the desktop app and ad is back what we
did is there was a need for developing
launching three more products so what we
did was we stretched the product API and
allowed three more products to launch
quickly and and this was the kind of the
design pattern we chose at that time so
it kind of reused the API we meant to
market quicker but guess what happens
soon after the team that built product
beep C and D got dispersed and then you
you end up in the situation where any
change to the code product P now needs
kind of a kind of it becomes very
difficult to make those changes because
now your impact
three more products so that was kind of
the case probably eight years back we
even though we were able to reuse but
soon after the maintenance became a
problem because any small change impact
at all three four products now probably
a roughly around four years back what we
did was we got our acts together and we
applied this BFF concept and building
all products so we expanded in two
dimensions one is we added more services
and like if you see here since we deal
with securities so we build API specific
to securities we have AP is specific to
a real-time data and we have API
specific to portfolios kind of a
capability driven or moving towards a
more microservices architecture and at
the same time we also ask product teams
to have their own back-end so this kind
of a gradual evolution allowed us to
kind of move towards more modern
architecture so roughly what happens
typically in kind of teams is you have
most of the teams that build these
services after two or three years they
realize that hey my back-end is outdated
the technology is outdated I want to
build a new version of it so that was
that's what happened for us as well so a
lot of teams the back-end services teams
they started building a new version of
their api's and and we kind of expanded
our our challenges got more another
version so now all each product team has
to now deal with all API and the new API
so what do we do so the back end
forefront and architecture helped us in
this and you're going to see more when
Brian goes into the detail of how we
implemented so I'm going to talk about
our mobile journey so we have eight
apps on App Store on the iOS side and
one app on the Android so we are more
kind of iOS focused right now because of
most based on the user research we have
more iOS users than Android so in in the
mobile journey probably five years back
we the the key app all of the eight apps
retail iPad app one of the was one of
the key app for us in the retail segment
so we there was already a website dub
dub dub morningstar.com which was a web
at that time it was a monolith it was
doing many things and it was serving our
desktop users via browser so what we did
was on the get-go we started off
building our mobile app having this
mobile service as a BFF layer it was
quite natural for us at that time we
didn't know about this pattern at that
time but we it just fell naturally at
that time because the we couldn't reuse
any of the legacy web application there
was some services available at that time
but nothing was reusable because it was
very tied to the UI it was a dotnet MVC
app at that time so this is how we
started our mobile app journey so yeah
so we already had BFF to get to start
with so and four years probably a year
later soon here we kind of wanted to
build a smartphone user experience so to
get to the smartphone user experience we
we leverage the existing BFF
so remember when I described the BFF
architecture there's two variations of
it one is you could have same BFF for
both your Android and iOS or your
smartphone or your an iPad or you could
have a separate user experience except
rate back-end for friend and for a diff
for your Android which is separate than
your iOS so we chose this route because
of the benefits we got some brand is
going to go in deep what talking about
this so now yeah I'm gonna switch to
Brian to go to the implementation
alright thanks for Sean so I'm gonna
spend the first part of my time here
talking about some of the the
implementation details of this BFF and
comes kind of some of the things that we
tried to address in our in our service
so this service is not just a
pass-through for data it's not just the
app calling the service and then getting
data out of out of the data providers so
that's one of the things to consider as
I'm talking through here there's a lot
of kind of normalization going on in
this service and sort of massaging data
and fetching you know doing things in a
particular way so show of hands for
people who've written read domain driven
design by Eric Evans all right probably
not enough for me to just skip these
slides so I'll go ahead and do them so a
domain driven design Eric Evans
introduces a concept of a bounded
context and I'll read the quote in red
there at the top a bounded context
delimits the applicability of a
particular model so that the team
members have a clear and shared
understanding of what has to be
consistent and how it relates to other
contexts so the benefit of the bonding
context in this in this case is that it
creates a space for the team to operate
within so all of our apps have a have
some similar domain modeling concepts
naming and that sort of thing and the
BFF helps to maintain that those
relationships and there are certainly a
you know there are cases where there's a
one-to-one relationship between the
bounding context that we're operating
within and the data that we're consuming
from our data providers but where there
are mismatches the BFF helps to kind of
massage that data and transform that
data into a space where we're able to
use kind of
don't consistent domain modeling within
the both the service and the apps I'm so
a bounded context gives you the
flexibility to produce the model that's
right for your application so we have a
couple of different cases where I'll
call a hybrid data model where we have
data models represented in the
application that actually pull together
data from multiple systems so in this in
this screenshot here from our smartphone
application we have this list of content
summaries on the left and that comes out
of one system and those the URL or sorry
the URLs for those thumbnails come out
of a different system so the BFF kind of
pulls that information together and
returns that in one uniform consistent
response for the applications to use and
news news is confusing news
so we consume data from a service an
internal service called new service and
as anyone would do we called the stuff
coming out of news service news and as
we're working with the news we started
doing some work with kind of deeper
categorization and allowing allowing
users to sort of filter into different
categories of news and we started
working with analysis news and video
news and commentary news and news news
which was kind of messy and but the fact
that we had all this naming and stuff
controlled within this bounded context
we were able to do some course
correction admittedly it was our problem
in the first place but you know if we
had been you know dependent on the data
provider to sort of correct some of that
stuff it would have been a lot messier
than us just sort of changing the names
and adjusting api's and things like that
and naming is hard and their names are
wrong you know we all know that naming
is hard and and even when we give it our
best try you know we get some of that
stuff wrong from time to time and that
happens with our data providers as well
and so it's nice to have this space in
which you
say you're like these damn names don't
make sense for us these models don't
make sense for us so we're gonna sort of
reshape that stuff into names and models
that we that make more sense for us and
and I mean honestly like who doesn't
love like a good Friday afternoon
two-hour conversation about you know
naming models and why would you want to
leave that kind of fun the table when
you could say okay so the next kind of
general concern that we handle in the
BFF is some performance related stuff so
in terms of caching we use a distributed
in memory cache for a number of
different things one of the one of the
main things a lot of our Security's data
is reusable across a request so if you
request if you want to take a look at
morning stars star rating for Apple and
Google and then I come along and I want
to view that same data it's not any
different for the two of us so so we
typically lazy load this data into into
our cache so you know the request comes
in we check the cache if it's not there
we go fetch the data from the data
provider stick it back in the cache and
then when that and those next requests
come along we can reuse it from the
cache we also do some kind of batch
batch processes for sticking stuff in
the cache this is that same same screen
that we're looking at before the process
for going through this is to for
assembling this list it's way more than
you'd want to do in the client-side
application basically we call one API to
get a list of document IDs that we want
to display here and then we have to go
to our data provider and make sure that
we have access to all of them because
there are some cases where there's
either Windows where they're not
available to us or or we're not
available or they'll never be never be
available to us so we want to make sure
that we're not throwing stuff up in the
app that a user's not gonna actually be
able to tap on and read and then we
stitch a couple of other things together
stick that stuff in the cache and then
when the apps call for this data called
the API for this data it just comes
right out of the cache so we're doing
some some of the heavier heavier lifting
that just wouldn't be pragmatic to do in
especially in multiple applications
we use HTTP cache headers fair bit again
kind of reusable stuff the same stuff
that we would be storing in the
server-side in-memory cache we would put
HTTP cache headers on for you know for
reusability there and then private cache
control headers so if I want to look at
my portfolio of securities that's
private data for me but the app can
store that in its local cache and if I'm
you know moving around in the app and I
come back to that view and the view
wants to refresh it it's stored in the
local the local HTTP cache and so it
doesn't need to fetch all that data
again so I'm gonna take a brief detour
from the discussion of performance to
talk about rest let's just take a minute
you could turn to somebody who's next to
you or you could break up into smaller
groups and just discuss see if you can
come up with the definition of what a
rest service looks like just I'll give
you like 45 seconds talk amongst
yourselves
maybe about ten more seconds
alright I'm glad to see the no
fistfights broke out over that over that
discussion does anybody maybe anybody
want to share the definition they came
up with all right yes good okay all
right yeah use of HTTP HTTP verbs and
crowd names and that kind of thing
alright so this is a bit of a trick
question because there's the the the
discussion around what rest is and how
you do it and whether you're doing it
right is it's so convoluted at times
look two minutes would never be enough I
mean we could probably spend half a day
talking about it from the discussions
that that's you that I've been a part of
at least so if you have a strong opinion
on rest I'm this is a warning I'm gonna
talk about rest a little bit you may not
agree with the words that I use or the
way I describe rest that probably
doesn't make me a bad person
and you know even if we disagree
I'm otherwise pretty easy to get along
with and you know I just think you know
let's not let this kind of a
disagreement prevent us from becoming
lifelong friends okay so as we were
built as we were building our BFF
service we tried to adopt a number of
different kind of restful architecture
principles and this this Richardson
maturity model was sort of our guiding
guiding light with respect to our
implementation Martin Fowler has a
really good blog post on discussing this
model and sort of picking apart the
different stages and talking about some
of the some of the pros and cons but the
basic idea is that you you know adopt
these different stages and you obtain
I'm not the glory of rest so we're not
we're not there yeah I don't know what
happens when you get there maybe you you
know cease to exist from this plane of
existence or I don't know I'll let you
know when we get there
so so just a couple of comments on the
way we sort of leverage these ideas in
our in our BFF so level one in the
Richardson maturity model is is use of
resources so if you want to address a
resource there's sort of a contextual
path to getting there including you know
names of groups of resources plus the
resource IDs so if you want a
information about a security can you see
the pointer okay or quotes or articles
for security you can use a path like
this with the security ID and similarly
if you're a customer and you want access
to your holdings for a particular
portfolio you would use a URI like this
level two HTTP verbs indeed so these are
kind of the ones that we make the most
use of any use any options users in the
house options all right okay yeah all
right yeah I can't forget about options
because nobody knows that it exists and
then it's kind of the big one level
three is the use of hyper media controls
hyper media controls are generally links
embedded in the server response telling
the client maybe what actions they can
perform on a given a given resource so
if I fetch a resource there would be
links in there saying you know am I
allowed to delete it am I allowed to
make changes to it that kind of a thing
and also links for associated data so if
I'm pulling down one piece of
information and there's maybe three or
four other associated pieces of data
there would be links to those telling me
you know how how I'm able to access
those particular resources so the name
for this is hyper media as the engine as
the engine of application state or hatty
Oz or Hetty O's or however you want to
pronounce that I'm not gonna take a
fight about the pronunciation we use
this very very little so we have not
ascended to the glory of rest and I'll
come back and talk to talk a little bit
about kind of where this fits in an hour
BFF journey and then we use some
try to generally use HTTP headers and
response response codes and we use a
little bit of custom headers here and
there and we use some general as
endpoints and I'll talk about this in
the coming slides
so we now return you to our regularly
scheduled program so one of the
performance concerns that we try that
we've worked to address in our API is
our BFF API is is to reduce the
chattiness of the client application so
basically where there's an opportunity
for us to kind of ship off a whole bunch
of data that makes sense in a particular
view we'll do that so I would call these
kind of like view specific API so if if
you look in a strict Rhett in a more
strict restful approach you might if
you're looking for information on your
holdings you might get an array of
holding objects with associated links
for additional security data additional
quote data so then it's the client
client applications job to say you know
if you've got 50 securities in this or
50 holdings here to make the next 100
requests to fetch that data but because
we know what the views look like in
these applications we have to we have
tended to build in some cases these more
kind of view specific api's so instead
of including all those links we would
embed the security data and the quote
data and whatever whatever other kind of
Associated data right in the response so
the client doesn't have to be making all
those additional round trips for the
information that we know that it needs
for that for those views anyway they in
some of our more generalized api's we we
do were finance company we do a lot of
stuff with market data and and
securities stocks that kind of stuff
we've updated or we we've written our
security related and and API is to
support multiple security IDs so it's
fairly common for a view to you know
show information about multiple
securities at a time if you want to
compare you know two or three different
securities and their performance and how
Morningstar has rated them that sort of
thing the client application could could
simply make a request for if I want the
quotes a comma-separated list of Apple
and Google and Facebook and then the the
last kind of performance related thing
again because we're trying to use the
BFF service to do as much of the heavy
lifting for the applications as we can
we do a lot of try to make use of
parallelism and asynchronous operations
wherever we can this so we use the
diplay framework any play framework
users in the house good one over there
so play has a really really nice API for
doing a synchronous asynchronous
operations and this is sort of a pseudo
code II example of one one that we do
today we have a basically an API where
you want to send the client wants to
send a request for a number of different
securities and get back one piece of
Morningstar analysis
Morningstar commentary third-party news
and Morningstar video the problem is
that our data providers and support
querying like this we so so what we end
up having to do is for every security we
fire off four of these requests
asynchronously and then the the
frameworks API is help us to you know
kind of let us know when all that data
is available and and and then act on it
when when it's ready so then we collect
all the stuff into these promised
objects and it allows us to say you know
if I'm asking for this information for
you know a dozen different securities we
can fire these requests off in batches
of four for you know for each of these
securities so so you know doing a lot of
that heavy lifting that would be fairly
onerous to deal with on the client side
especially across especially across
multiple applications it's been a big
benefit for us so the last
implementation topic I'm going to talk
about is error-handling and I'm gonna
use a rather cool term I think is cool
from Eric Evans this is the the anti
corruption layer so it's gonna read the
quote here but when the other side of
the boundary starts to leak through the
translation the layer may take on a more
defensive tone so domain-driven design
is about business modeling domain
modeling naming consistency that kind of
stuff but when you work with especially
when you work with lots of different
data providers you know a lot of
different styles of responses and that
kind of thing you really need to think
kind of at a core level about your error
handling strategy and how you're going
to be you know you and you probably want
to build that kind of stuff into your
modeling so Sun Microsystems told us the
network is the computer and I'm telling
you that the network is a bag of angry
cats that's that I think you know
working in a disability in a distributed
environment you see all these weird
things you know network problems when
you're talking with one data provider
and and you know who knows what they're
doing behind the scenes to get the data
that you're asking for so lots of room
for failure so we ended up building this
kind of custom web service integration
layer you could kind of think of it as
like a dao for web service calls if
you're into da OS where we basically
excuse me handle a lot of boilerplate
error handling timeouts things like that
so that where you were sort of capturing
these potential problems that we that we
would get with you know interacting with
different data service providers so and
of course because the different data
service providers have different styles
of error handling our themselves we kind
of normalized that stuff so you know we
have a quite a few of them that do
standard HTTP code responses that we can
look at very easily everybody loves this
one everything the HTTP header tells you
that everything's okay but then you look
at the response body and as
turns out everything's not okay and then
other weird corner cases where you
called a JSON API and you get redirected
to an HTML page it happens
not very often fortunately and then so
with respect to our API is responses to
our client applications we've kind of
standardized on a few different you know
few HTTP response response types partial
content is interesting if we've got you
know let's say the client application
asks from one thing and under the covers
were maybe calling two different data
providers and stitching that information
together but you know if part of that
information doesn't return for whatever
reason we would use two of sex 206 to
say hey you asked for this I didn't get
all of it but I'm giving you what I was
able to get and the other the other two
that are interesting to highlight our
503 basically if we make a call to a
data data provider and something goes
wrong they're down they timed out they
gave us HTML when we want to JSON that
kind of stuff then we return a 503 to
our client applications and then that's
just kind of built into the contract of
how we're you know how the client
applications are consuming these this is
sort of a signal is like something went
wrong not our fault try again later kind
of a thing and it's worth drawing
attention to the fact that we never
produce 500 errors or 500 results
intentionally those are reserved for our
programming mistakes and null pointer
exceptions and things like that so if
our API isn't returning 500s we know
we've got some serious problem to
address because we're we're basically
falling over so I'm going to talk a
little bit about lessons learned these
are you know blessin's learned from
building this BFF from from supporting
multiple client applications over the
years so you know you build a system you
build a service and every once in a
while you find you know especially as
we're all talking
about micro services like Oh micro
services are cool
am i a monolith should I be a monolith
like am i concerned about that kind of
stuff
what can I split off and be be more
micro service II so we've definitely run
into some situations where where we
realize we built some stuff into our
service that doesn't really belong there
like the most I think the most obvious
example is that when somebody buys a
subscription to Morningstar data through
our iPad app that goes to the Apple
Store they send their information to one
of our systems internally and then that
system actually talks through us through
our BFF back to Apple doesn't belong
there it's it doesn't really fit into
that service it's still there today
we'll probably you know break that out
as a separate service in the future but
it's one of those things that you know
when we look at that service we kind of
scratch our heads and go yeah why don't
we do that
and it you know we've built a number of
different applications on on this BFF
three of them are very very similar
experiences and so like it doesn't I
think the the general idea of the BFF
pattern holds for those different
experiences but when we've built other
applications or when we're thinking
about building other applications it's a
question of like should we do this
should we spin this off of something
else should we you know break this into
a separate service and have those
services call each other but that you
know those are just conversations that
we've had over time when we're building
new things and then there's the
inevitable question as Krishna and
mentioned about this question of reuse
by other teams we've been approached by
a couple of different teams over the
years about you know hey we want to use
your service because you have this nice
integration with these secure data
providers for Security's data it's
consistent you did the work already can
we just use it and and we kind of
decided to draw a line in the sand and
say you know we don't want to support
that we don't want to we want to be able
to make changes to this that are right
for our application and not be you know
burdened by supporting a bunch of other
products but the applications in source
control you
free to fork it and you know take a take
a whack at building something with it if
you want a the the BFF has been a really
great place to buffer change so because
we have a number of different
applications mobile applications you
know if we need if we want to or we need
to cut over to a new service provider if
we're adding data or subtracting data or
moving data around and our modeling and
that kind of thing the the the the BFF
service is kind of a one-stop shop for
you know managing that change rather
than having to you know make changes in
four different apps and try to get those
out to app stores and and in in a timely
fashion and because we control the
release schedule on that BFF we can kind
of do we can kind of do those introduce
those changes whenever we want to do
that so if there's a you know if
somebody's deprecating an API next week
we can or you know we can build build
kind of a bridge feature today and
deploy that and then when when things we
know when things make that formal
transition we just handle it on the back
end and helping client side developers
move faster well it's kind of an
interesting one
so when we're building new API is of
course old in a lot of cases if we're
integrating with a new data provider or
something like that either the work has
to be done in the BFF service or the
work may have to be done in the data
provider service as well
so you know there's lag time there until
all that work gets done before the
client developers can build you know
their features and that kind of thing so
what we what we've ended up doing in
numerous cases is just adding stub data
to our BFF service so you know agreeing
on an API contract between the server
and client side developers what this
data needs to look like you know just
stub some data out that the client-side
developers can begin working with
immediately and then in the best case
scenarios which is admittedly not all
the scenarios when that work on the
offside integration with the data
provider is done the real data just
starts flowing through and you know
somebody picks the app up in QA one day
and sees real data instead of the stub
data one of the I mentioned this this
balance of general-purpose api's and
view specific API is I feel like we've
done a reasonably good job of that I
think when we when we start building a
new API we're generally we're thinking
about it as we want this to be as
general-purpose as we can because we're
supporting a number of different
applications it's kind of like well even
if it's even if this application needs
to use this this way today it would be
good to build this in a relatively
general way so that you know if this
other app wants to use it tomorrow it
can just call these same endpoints and
and get the same data and yeah I
mentioned the the view specific API so
that's we do try to try to do a little
bit less of that and be yeah we have a
number of different experiences using
these api's so I said I would come back
to Haiti oohs hey do zip like Cheerios
thank you thank you explaining the joke
always makes the joke better so as I
said we have not achieved the the glory
of rest we're not using we're not using
hypermedia very extensively at all where
we have used it I think we're really
glad that we did and we definitely see
that we've I think we've made some
mistakes where if we'd used it more
there wouldn't be quite so much
client-side application logic where you
know oh I got this data I know how to
pick one of these data points and build
a URL out of it and get some additional
data so the client applications are all
sort of even they all have this logic
sprinkled throughout so if we use
this approach a little bit more than I
think you know we would have a little
bit less less of that stuff and if we
want to move date if we want to move or
migrate data within these api's then
then those would just be server side
changes because the client wouldn't
really know or care where that specific
data would come from it just has to know
to call an API and so kind of back to
could sort of close off that restful
conversation some people would say that
if you're not using radios you're not
restful and that's fine I don't have I'm
not you know super super committed to
whether or not we're restful I think
that approach and requiring that
approach maybe makes a bit more sense
for generalized you know more
general-purpose api's but in this BFF
service taking more sort of pragmatic
approach you know it doesn't hurt me if
if you know we get together afterwards
and say you know this service is not
restful it's it's worked well for us and
and you know it's it yeah we're tailored
to specifically to our client
applications I think to you make heavy
use of this or to insist that we use it
in all of our API eyes so I want to open
the floor up to some QA right so the
question is did we we're where we drew
the line for reuse was it but just with
the BFF or the Gateway API as well so so
yeah the the BFF is is really our
gateway API so our our mobile
applications are calling the BFF service
and that is you know kind of you know a
gateway API as well so that's the the
applications gateway to all this data
that it's different than the API gateway
we talked about in Amazon oh yes which
is or we do have our own API gateway
called apogee we use within our data
center so that's that's kind of a
cross-cutting it's a gateway for all of
our back-end services
but this BFF is different that it
connects directly it's very closely tied
to the user experience which is the
client apps right so the question is do
we find ourselves duplicating basically
duplicating stuff in the BFF that
basically the there's sort of a
one-to-one relationship between between
the BFF api's and the data provider API
is I don't think there have been too
many of those there there have been
there have been some and that is and
that's kind of the even in cases where
where we have done that I there's enough
of this kind of consistent error
handling consistent response you know
standardization where I think we get
we've the client application development
has been a benefits from that kind of
stuff thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>