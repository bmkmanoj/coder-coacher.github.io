<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Challenges Chances In Polyglot Programming • Stefan Tilkov | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Challenges Chances In Polyglot Programming • Stefan Tilkov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Challenges Chances In Polyglot Programming • Stefan Tilkov</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VUr_JTNKAFo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay everybody so I think I'm going to
start my name is Stefan tilaka I'm here
to keep you awake after lunch I want to
talk not about a single programming
language but about more than one
programming language more than one
programming language in the head of a
single developer and more than one
programming language in a system I'm not
here because I'm a language designer
because I'm not I'm not here to pitch
any particular programming language
because I like many programming
languages I like to think I'm here
because I am a user of programming
languages I like to explore new things I
like to try out new languages and see
how they're different from what I know
and I'm also very very often in the I
very often have the task of selling of
selling decisions to decision makers of
selling ideas to them so that they turn
them into a decision so this talk is
mostly going to be about some some
technical things some soft things and
about whether or not this whole idea of
using more than one programming language
is a good one or a bad one and I have
seven thesis around this seven things
but I've gathered I'd like to I wanted
to come up with 10 but I couldn't find
10 so it's 7 is the next magical number
that I could pick so you'll have to bear
with me with me for those seven things
and they vary a lot from from the level
and from the amount of time that I'm
going to spend with them and as I said
some of them are more technical and some
of them are more soft so let's see let's
start with the first one the first one I
think is is one that's very obvious if
you're if you're looking at any
particular programming language with at
any particular programming programming
language which is how and why is this
different from what I know aren't all
languages we use equal anyway and of
course they are right so languages are
equal in a certain sense because we can
with any reasonable language we can do
anything that we can do with any other
reasonable language but as soon as it's
Turing complete we can do everything
with it but they are not equal which is
my first thesis if you look at the
number of languages that we have
available this is just a very small list
of things you will probably agree there
is a pretty big difference between
assembler and what do I have here or
maybe Haskell those are very different
if
in languages I can write well not me but
somebody who is capable in those
languages will probably be able to write
any program to do anything in both of
those languages but it's not going to be
the same program and I don't mean that
concerned with the number of characters
or the number of lines it will have to
type it's going to be a different
program because to some degree the
programming language we use influences
what we can do this is known as the
sapir-whorf hypothesis hypothesis which
is a something from linguistics so these
two people superior and Worf came up
with the idea that language influences
thought write the the vocabulary that
you have the patterns that you have the
idioms that are available to you
influence what you can think write the
interesting thing is that in linguistics
that's been officially disproven right
so linguists don't believe that anymore
but I think it's very true in
programming languages I think there is a
huge influence the programming language
has on what we can actually think of if
we know just a single programming
language I think we're very limited
that's one thing that I want to get
across today there's a nice thought
experiment done by a guy called Paul
grayham which some of you may know which
is the blob language how many of you
know the blob language anybody here okay
so let me explain that very briefly this
is a language that's that's that's been
called blob to not offend anybody right
so this could be your favorite language
it assumes that every developer has a
favorite language it's the language that
you like to use and that you're very
familiar with it's the one that you use
in your day-to-day work the one that you
don't have to think about right and this
language sits at this in this continuum
at a certain level of complexity or a
certain level of number of features that
it has but this is this is your language
it has certain features and it doesn't
have others because there are other
programming languages right there may be
a programming language that has fewer
features for example your language might
be object-oriented in this language X
isn't it doesn't have objects and there
are other languages which are further to
the right this language for example
might have a feature of your Lang which
doesn't have for example coders
lambdas right might have something that
you don't have right now and if you are
the typical programmer I just assume
you're not because you're attending a
conference like this but let's assume
you were the typical programmer then
your immediate opinion of those
languages will be well everything down
here is something that's hopelessly
limited how am I supposed to work with
that right my language is way more
powerful I have all of those things and
if I had to work with that language I
would build all that stuff myself for
example object-orientation I would
because I that's how I think right so
I'll add object orientation to the
language that doesn't have it many
people have done that for example with C
and of course everything on the other
side is full of features that nobody
needs right I mean who would who would
need that because you don't need it
right here in your day to day work you
don't need that feature so you tend to
view languages that have additional
things that's first your language as
unnecessary complex bloated and full of
academic stuff that nobody wants and
languages you don't either have fewer
features as useless that's the key but
the key idea I'm not going to read all
of this to you you can read it in his
blog post and I think there's a lot of
truth to that I think we we have a
different mindset depending on the
programming language we use a C
programmer things differently than a
Ruby programmer or a Java programmer of
course they are both building programs
in a turing-complete programming
language so some point in time and some
level this is going to be equal but it's
not the same way that's approach
languages differ a lot languages differ
in many different aspects right there
are many things that can differ from
language to language the paradigms in
support is it a functional language is a
procedural language does it have does it
support object orientation right does it
support generic programming they're the
verbosity required to express something
right how much stuff do I have to write
that do I have to spell out all of the
types or other in fear or are there
maybe no static types at all so the type
system is a major different
differentiating factor between different
programming languages then the amount of
ceremony I think Neil for calling this
term we're going to see some examples of
that how much how much boiler boiler
play do I have to write to get something
to work right that's another another
aspect we have the speed both the
development speed as well as the runtime
speed of what we're while we're building
it and when we're running it right
that's that's a major difference between
the languages and often these are
inversely related so if it's something
that lets you build something quicker it
may not run it as fast and if it's hard
to do then maybe your program will be
faster although we'll get to that I'm
not entirely sure I agree with this
assumption then we'll just have a very
different learning curve right maybe
very steep maybe not a problem at all to
learn the language if you know another
one all right so the stability can be a
difference the language may change
because it's very actively developed a
two point nine release may be very
different from a two point eight release
in some languages right so that can't
happen I think there's there's a lot of
difference in those languages and some
of us are not aware of that so I don't
know how many in this audience are Java
programmers and you raise your hand if
you're programming Java so it's I would
expect that's the majority so don't feel
offended um if I put up this slide by a
guy that's a quote from a guy called
Steve Agee
where as a great blog post called the
kingdom of nouns and he made he made
this observation which i think is is at
least partially true think specifically
the java world has a tendency to to see
well again maybe not this audience but
the many many java developers tend to
see java is the one language the one
thing you don't even know anything else
and you don't even aware of many other
ideas that are around there and let me
show you with an example how different
that is this one is is inspired by a
video a talk that ola beanie did this is
a bit of java code some I can't do the
game right now but maybe you can tell me
what this does does anybody know what
this does so I'm still counting what
does this do why does it take you so
long to find out what this does I mean
maybe you're all shy and you don't want
to shout out with us sorry too many
words that's a very good comment there
are so many words on that slide right
orders what by length it orders the
strings by lengths right and what does
it do with them
print them out comma-separated excellent
answer that's exactly what this code
does I'm I'm not I'm not a currently I'm
not a Java programmer so maybe there's a
more efficient way to write this but I
don't think it can get way more
efficient than that now compare that to
the equivalent Ruby code that is a lot
less words right a lot fewer words it
says here is a list now sort them by
length and join them with a comma now of
course this is a bit of cheating right
I'm not using the same level of
libraries that I have in both languages
it's different in Java in Ruby I could
easily build myself a join method on
some utility class and maybe import make
it static so that I can import it in red
and narrow down make my java code
shorter but it shows there's a
difference in the languages right I'm
not even arguing that one language is
better than the other because they're
the the major thing I want argue is that
they're different but it's not the same
thing take a look at another example of
Ruby code this is from the documentation
from the rails framework which is sort
of a yeah Java EE framework for free
Ruby at least it's a full-stack
framework it has a lot of things in it
and one of the one of the things that it
has is a way to express relationships
between entities so what you're seeing
here almost looks like a DSL right it
you could call it we could reasonably
call it an internal DSL because it's
very readable and very close to the
domain right it says that a project
belongs to our portfolio and has one
project manager and belongs to one or
many categories that's readable and
that's that's that's something that Ruby
makes very easy to do it's very it's
very easy to build internal vs else in
Ruby again you can build something
similar in other languages you can build
something similar in Java or C sharp but
again it's it's a it's a part of the
culture a part of the way programs are
built in Ruby that allows us to do this
and there are other lots and lots more
examples of that this is a node.js
JavaScript program that is a full HTTP
file server no that's just the complete
server and it's full I'm not even going
to to explain everything that's on this
slide but it you can see that mechanisms
that are available in JavaScript are
being used like anonymous functions
right we're passing an anonymous
function to the function that creates a
server and that anonymous function is
responsible for handling requests and
responses right so this
that's that's them that's something
that's that JavaScript makes very easy
this event oriented callback oriented
programming I'm not saying that if this
if you if you have a thousand lines of
this that this is not going to be a
complete mess we can argue about that
separately but it's again it's it's a
different set of options that you have
available a different way to express
your thoughts depending on the
programming language I can continue with
this for a long long time this is a
colder example it's a complete grep
command line replaced well not a
complete but somewhat of a grep command
line replacement right and you can even
though you can not see all the details
and though it's a bit tough to expect
that you are able to follow all of that
if you've never seen closure which is as
you've guessed list running on the JVM
you can see it in some some things some
areas the different way of approaching
stuff so for example we have something
of there a function called a print
matches that now let's take grep in
files which uses apply and merge and map
right those are higher-order functions
available in a functional programming
language that allow you and be in the
the example of map to map a function
over a list right that's a that's a
common idiom in a functional programming
language and leads me to write this
problem in a very different way very
differently different from what I what I
do in a non functional language there is
more to life than objects when we're
using an object-oriented programming
language of the main stream program
language we're used to having this one
abstraction right we're building the
type language building classes class and
types that's the thing we construct
right we build more and more and more of
them because that's the main abstraction
we have because if we don't have
something we have to build it using the
facilities that we have so for example
if we don't have a closure
we'll use a class and use a pattern to
to do that I'll I'll give you some more
closure because I want you to get used
to that to seeing that because I love
the language so much right think about
how you would how would you wooden caps
it the how you would work with data
structures in a programming language
such as Java let's say I want to do a
small library that deals with points
then this is probably what I'd start
doing right I'll start whether it was a
very small class that encapsulates this
single the single type the single
information object a point whereas in a
language like closure I would
something like this now again this is a
totally unfair comparison and system
it's this is because this is not doing
the same thing which is what I'm getting
at right it's not doing the same thing
because using this different language
you would do things differently this
other language you would simply reuse an
existing data structure a persistent
data structure in this case it's a
vector right so we'll create a vector
with two elements to represent a point
if we do that we get some benefits
because these data structures in this
example language closure have certain
have certain traits that are valuable to
most programs they're immutable they're
reusable we'll see that they're
compatible because this is just a
generic data structure right I'm using
this to encapsulate their information so
instead of like I would do it in the
Java world adding a method in this case
to to calculate I'm a distance to the
class that I have never never understood
why it belongs there but whatever that's
probably where you'd put it in your Java
program in the in the closure variant
you'd have the same the same code the
same logic of course because that's just
math right but you'd put it in a
different place it would be in a
function right now this function can
calculate the distance between two
points and now I think they're
interesting things I have this data
structure approach and now I can do
stuff that closure can do with data
structures because these are generic the
generic functions work with this stuff
right so I have something in culture
that's that's a very nice thing which is
an infinite sequence it's an infinite
sequence in this case an infinite
sequence sequence of random numbers
right so maybe if I want to write a
function that allows me to you to create
random points I'll now use this to build
pairs of random points now this is an
infinite list right of random points and
I'll take 10 from that now I have 10
points I've just built points using the
generic functions that are available in
the standard library for me and again I
can I can go on for hours about the
thing here this is a just a so somewhat
contrived example I have a have a number
of number of points I want to calculate
the circumference circumference of the
polygon that's there so I have all of
those points and now I
of an infinite list of that I repeat
them infinitely over and over again
that's what this function does and then
I shift that one place to the to the
right and then I have these and then I
build points from that and then I met
the distance funks function across all
of those things one after the other and
then I finally sum that up again this is
something that I can do because this is
the way I think in this language I'm not
trying to sell you closer even though
it's the best language I know right now
not trying to do that what I'm trying to
point out is that as if I'm programming
in closure I approach problems in a
different way right it's a different way
of programming than what you use to
which supports my my theory that those
languages are not equal let's skip over
that let me highlight one other aspect
of this generic ass thing which is if I
have something like this here this is a
closure map again just using this as an
example I can access the elements in
that map very easily so this is the way
I would encapsulate a comp more complex
data structure and closure I would not
create a type for this I would not
create a class I'd simply use the
generic data structures to do that which
in the end means that I can let's just
go over that that I can access things in
those lists in a very generic fashion
it's kind of like only coupling myself
to a small part of the data structure
which again changes the semantics of my
program it's almost as if this data
structure resembles this stuff on the
right anyone know what that is on the
right it's JSON right so there are two
functions and closures that allow me to
go from a map to Jason from Jason to a
map and again that's an excellent
example of something that's really
different in different programming
languages if I if I have to write a
service that consumes or produces JSON a
language like this and there are many
others the chair this characteristic of
having easily accessible generic data
structures it's extremely easy to work
with
whereas I find in total pain in a
statically typed language to work with
something like JSON because the
idiomatic way of approaching it would be
to generate code that has classes that
map to the things that are in the jason
map right so every time i change the
structure of the jason that I'll have to
change the class structure that i've set
up now I know I don't have to again not
saying it's not possible
to do everything in every language I'm
saying it's not the default not the
standard way of doing things so that's a
major difference between one major
difference between prone languages that
I wanted to highlight and I think it's
it's it's just one one sign that it may
be more important than you think what
programming language you use can argue
that patterns that design patterns our
design smell right so many of you I
guess will see that book right it's a
it's a very it's a very very well-known
book I wish I had written that
bestseller because it's great to write a
best-seller in this industry almost
never happens but even though it's
severe it's been a very influential book
um you can argue that patterns are a
weakness and one guy from the Perl
community does that where he could've
been sitting in this post he argues that
if design patterns were had had been
invented in 1972 one of the design
patterns would have been subroutine
because in 1972 programming languages
didn't necessarily have I'm not sure
about my history here but didn't
necessarily have subroutines built in
maybe 1965 whatever so one way to do
that would be to describe this as a
pattern right you put some variables on
the stack or and some registers you put
a return address than you call a
function and it'll take the the
parameters and it'll do something and
it'll return to the return address I
mean that's a pattern right we we never
would accept the language that required
us to actually do that but we do accept
languages that require us to code lots
of other common patterns
what's the reason we're accepting that
there's an old paper by Peter Norvig
who's now I think the head of search
research or something at Google berry or
he took a look at the book and described
how the patterns in the book map to
features of dynamic and functional
programming languages again I am a big
fan of dynamic languages and functional
languages but it is this pattern again
this this idea translates to any two
languages right if there is something
that you can see yourself doing over and
over again maybe it's a good idea to
think about whether or not that might be
a part of your of your that should be
part of your programming language and
maybe there's a different one that does
this different
now I promise in the abstract of a talk
that I've give some examples so in
between all of my theoretical stuff have
some some examples thrown and this is
the first one so I think it's a good
case that shows who when and where you
might be able to profit from different
languages so this is one project we did
where he actually had modeling
information exported from a case tool
and wanted to import that into a
different case to leave first thing
produced xmi and the last one head of
java if you don't ask don't don't don't
do projects like this right but if you
have to this was an interesting thing
the guy who built that project took the
approach of doing the the interesting
stuff the transformation the model
transformation in Lisp because it's
perfect for that it's a perfect use case
but of course he could have built that
in Java as well he chose to do the XML
parsing the data structure to the basic
normalization of the data structure in
Java and then hand it over to a Java
based Lisp was not cultured so well that
was a while back and then produce
something that is that is then read by
Java program to use the Java API so you
have different languages with different
strengths and you should be able to pick
the one that makes sense for you having
said all of that make us I'm very
convinced that programming languages
make a difference yet it depends on what
level you're looking at so if somebody
has the argument that languages don't
matter I concede they have a point
depending on what it is we're talking
about so if you're looking at the at the
whole set of things that you have to
look at for example if you build a
modern web app then of course the
programming language is just one minor
thing all right and I agree that it
shouldn't be shouldn't be the most
important decision that you make it was
the only thing that you focus on right
so they from this perspective you look
at the whole of the whole sub the whole
system or subsystem or the whole
architecture maybe the language isn't
that important but they're still very
different and I think that matters a lot
now that's all pretty theoretical right
we have differences between languages
and that's interesting we could maybe
always pick the best language for a
particular case of course we can right
because the language has an ecosystem
surrounding it and the ecosystem is
almost as important as all the technical
features of that particular language
right and those ecosystems comprise a
lot of different things so we have a
development environment
if you're used to the development
environments available in one ecosystem
it's very very hard to go to a different
ecosystem that has a different idea of
what a development environment actually
is you may come as a surprise to you but
many people think Vi is the act as an
excellent development environment Emacs
is an excellent development environment
I know very few Java programmers who use
Emacs as their IDE think I know what and
he's weird but anyway the development is
just one part as our the libraries
you're using right you're using a lot of
libraries and they make your life easier
everybody would agree to that would it
would agree with that so having an
extensive set of libraries is a very
important thing and they're not easily
shared if you hop between ecosystems
right they have different API s and
different approaches and different
ecosystems have different strengths in
the kinds of libraries that they provide
some of them have almost no libraries
which is too bad you have different
runtime environments they may bring
their own VM they may work with a
different VM right we have a different
community community and culture I think
are underappreciated differences between
programming languages there is a huge
difference between the Perl community
and the Python community in the Ruby
community those are all dynamically
typed I guess still dynamically typed
wasn't sure after that last talk but
basically dynamically typed languages
that some people like to call scripting
languages they share a lot of
characteristics they all have support
for object orientation they're all very
fast they're all very usable very
pragmatic but the communities are very
very different so it's a really a strong
strong difference between the approach
you take there so you have to make sure
you take that into account when you
decide which programming language or
programming languages to use now right
here is a bad example that's also a
project example a large banking project
that we did and of course it was not one
of our employees who messed this up
somebody else
naturally who was a great programmer
accident an amazing programmer and a
half-scale fan and I like Haskell the
language I don't understand it but I
like it so I I'm not I don't object it
all to somebody using Haskell but this
guy used Haskell and only he used
Haskell and a team of 15 people and he
used Haskell to build external vs ELLs
that
he basically created new languages and
you could use that language to create
something that was saved in binary and
then read by Java library from the Java
program and he set up a pipeline where
stuff was from Excel piped from multiple
stages of best-of-breed tools to create
something that was an internal DSL that
wasn't parsed with Haskell and created
binary stuff that the Java program would
read that was an unmaintainable mess in
this particular context it might have
been grained if it had just been him
because he was absolutely able to work
in both the Haskell and the Java
ecosystem well I'm not entirely sure he
was able to work in the Java ecosystem
but definitely the Haskell but so that's
not a good idea you have to take that
into account and if nobody in the
project wants to use anything else but
this one particular programming language
convinced them first before you
introduce it don't do it on your own
because they will hate you I can I can
promise that
so no language is an island right a
language has a lot of things that come
with it and you need to take that into
account as well that said I think it's
changing a bit so we have those
multi-language virtual machines those
multi-language platforms write basic net
and the JVM which give us some some way
to reuse parts of our ecosystem
not all of it parts of it right we have
lots of different languages running on
dotnet on the.net runtime we now have
lots of languages running on the JVM
again it's getting better all the time
fortunately oracle has not stopped that
so we have a lot of support for
different kinds of languages this will
only get better in the future and if you
see what people like Charles Nutter can
do these days to a target that JVM from
JRuby this is really impressive they can
create really really efficient code
because the runtime has been extended to
support stuff that they can use to to do
that very efficiently right so if you
look at those things that I mentioned
you can see that at least some of them
are not as much of a problem as they
were before right so some of them are
addressed by this multi-language
kind of thing at least the libraries and
runtime environment maybe sometimes even
the development environment although I'm
not too sure I mean I way I'm aware that
on that at least under JVM for every
scripting library there is a sort of IDE
support in in Eclipse and an idea I'm
not sure that anybody who really
to use that program language we'll
actually use that so most of them stick
with their existing editors I kinda have
another project example I think that
should be number three not number two
which is a was a simple JRuby project
that ran on the JVM and was able to
simply reuse some of the Java libraries
right it was a nice runtime environment
it also had a nice effect for us that we
were able to use JRuby without really
telling the customer it's not entirely
true we told them we'll yeah we'll use
this fancy language but you won't you
won't notice because it'll run in the
exact same environment you have all of
your existing stuff running so the fact
that we can target a different runtime
environment enabled us to do this in a
programming language that we found was
more better suited for this particular
project and that was definitely a win
again I don't I don't think that
happened to much but we'll get to one of
my major reasons why I don't think
that's such a major point but at least
the runtime environment and of thing
gets you into more scenarios where you
can actually do that whereas I still
find it a problem to get something like
Erlang into companies because it
requires a different installation
different runtime so they have to
compile something this all feels weird
to people who are used to running JVM
based stuff right sometimes that matters
so these multi language environments
enable is her diversity that you
wouldn't be able to to to support or
that you wouldn't be able to sell
through customers or to or to decision
decision-makers if it were not for these
for these runtimes now let's get back to
let's get back to the title of the other
talk that had something to do with
polyglot ISM I guess I changed it so
polyglot programming I think one of the
things that people fail to do is make a
distinction between a polyglot polyglot
programmer and a polyglot and polyglot
programming I mean those are two
different things a polyglot
in general is somebody who is capable to
use multiple languages when it comes
from the language world so somebody who
speaks ten languages fluently as a
polyglot that's the cool thing I'd love
to be able to speak ten languages sadly
I don't I barely make make make it was
two so I think that's a that's a thing
we should aspire to I think it
it's a very very reasonable thing to do
this because when you do that you you
learn to approach things with
different views right once you've used a
lisp you will view the code you write in
Java differently you will think about
different abstractions if you're like me
once you've used Lisp you go back to
Java and say blah and try to find some
library that will enable you to do that
and then you'll decide that that's not a
good idea because it's not idea Matic so
you'll drop the library again whatever
it helps you to think about those things
it might help you make a decision on
when to go to the polyglot programming
model it might also help you to simply
see well this is this is something where
we should have a library that follows
the pattern that we have in this
particular language but it's also
interesting to ask which language do you
use right so how many of you use a
single programming language in their
daily work so I think you're you're
guessing what I'm getting at right the
question should rather be how many
languages do you use because nobody
nobody uses a single language at least
none any significant project that I'm
aware of you have a whole multitude of
different languages that you use right
some of them maybe shouldn't be called
languages I'm open to discussion there
but there are multiple ways to express
stuff and there are some of them
Arcturian complete some of them are not
but there are different languages right
at least in any every web project I know
you'll have some JavaScript somewhere in
basically every Java project we have
some something to add dynamics we will
get to that as well so we have a lot of
different things that that we already
use sequel is in basically every project
and is monitoring complete by the
program language some if you combine it
with a procedural logic would make it
pl/sql then of course you have something
that's complete so there are a lot of
different languages that you already use
and everybody thinks that's okay right
so it's tempting to say we'll just use
the best tool for the job let's just use
whatever makes the most sense and get
rid of this monoculture which is I think
a bad thing even if you look at the
original textbook dictionary definition
of what a monoculture is right a
monoculture means that your that
everything has to be the same that's
this that's the most important value
that you have everything else is
unimportant as long as
it's written in that one language
everything's fine think that's bad no
matter whether you're talking about
databases or runtime environments
operating systems programming languages
frameworks libraries whatever I think
monoculture is always a very risky thing
and the very the the very I don't know
exemplification of this is this logo
does anybody remember that anybody here
old enough to have programmed in 1996 so
that was the 100% Java logo that that
Sun back at the time used to to describe
a program that they set up where that
was a it was there for a reason because
they had this this lawsuit this fight
was Microsoft about whether or not it's
okay to extend java with proprietary
stuff but at some one in time this
became sort of the seal of approval if
my program is built in Java and in Java
only then it's great which is kind of
weird I don't see that as a value I
don't think it's great if something is
built in that particular way right
that's I don't find that particularly
convincing
especially since usually your database
isn't written in Java not even today and
even the JVM isn't written in Java
so I not really convinced that was such
a great idea but we still have something
like that in our minds specifically in
the Java world we tend to believe that
every cool idea is only cool if it's
done in Java if there's a great platform
that would solve all of my needs I can't
use it because it's not Java it's
because we value the programming
language too much I think we're making
an error here and I've tried to
illustrate that it's not a very great
illustration but hope I get my point
across if you look at this at the
technology stack that you are using when
you approach a project you have a number
of different aspects a number of
different things that you have to look
at right and if I change something if I
add features then that may mean that I
have to add something to biotechnology
stack right I have a different kind of
remoting technology different kind of UI
model different kind of database so I'll
add something I'll keep the language and
the runtime the same but I'll add
frameworks and libraries and maybe build
some code right that's okay we're fine
with that
we're all happy users Andry users of
libraries
but we don't do the same thing with the
languages now it might be that if I add
a language this will increase this will
is this will make this will create some
cognitive load people will have to learn
that people have to have to get acquire
the skills to work with that programming
language but doing that might actually
result in something that's that's less
complex than what you have to do if you
do it using just libraries and
frameworks right then I found that to be
true in a number of projects though it's
it's hard to get that point across but
the programming language is just one the
syntax of the program and it's just it's
just one small part of what you're
working with right you think that if I
use programming language acts and I hire
a new a new guy next week they cannot
work with my system it's it's it's just
wrong to assume that they will be able
to work with your system because they
have to learn all the other stuff anyway
right they may know the language that's
just one aspect but they still have to
learn everything else if there is so
much more to learn because you have to
build all of that yourself instead of
using it because it's built into the
language then it's going to hurt you in
the long run so I think languages have a
sweet spot somewhere so here are some
example criteria don't take them too
serious right it's just an example of
where different languages shine and I
think Java mainly shines because it has
this feature of being known by so many
people and if you'd pick Java you
usually don't have to justify that
decision which also means that you maybe
can focus on other decisions that you
also care about that require some
justification so sometimes Java is
perfect the same is true for a c-sharp
or other mainstream language or whatever
language it is that is your blob our
Erlang is an excellent superb language I
think Steve is going to do a lightning
talk Steve the Nazis are going to do a
lightning talk in the break on Erlang
curling is an amazing system if you have
to build a distributed system that's has
to be up and running all the time where
you want to replace things while it's
running right have different versions of
the same code the same running server
instance it's an awesome environment
it's not exactly the language that's so
awesome it's just a complete set of the
language and the libraries and they all
of them know how that went into that
thing
for for three decades culture as you can
guess is the language I like a lot I
think it's a general-purpose
you should use it for everything if you
don't do that at least consider it once
you have complex algorithmic problems
and maybe want to use a multi-core
environment because it's great because
it enables you to write multi-threaded
programs at work I don't think that's
that's a natural thing and Ruby just to
pick one could add groovy or Python or
Perl whatever you might pick that for
its productivity right so the fastest
language doesn't produce the fastest
running programs but it's it's a joy to
use it makes may make you very
productive at least for certain things
and we can argue about that for a long
time so in my view nobody uses a single
programming language anyway right that's
that's an illusion anyway so we have
people using multi multiple languages we
should be open of any more and I'm going
to get to that again in a few few
minutes I'm not suggesting everyone
picks their favorite language as they
please whenever just whatever just don't
care I'm not suggesting that because I'm
I'm too realistic to assume that could
ever work but it doesn't have to be one
it doesn't have to be a monoculture
because that's unhealthy
my next thesis is around stability
around layers in application this was
think it was also inspired by by an
olivine II post awhile ago although we
chose different layers but the the basic
idea is that if you if you look at your
application if it's a comp if it's a
complex application
it probably has different layers in some
way not talking about presentation logic
and business logic and persistence I'm
talking about what's fixed and what's
what's dynamic right the parts in your
application that you want to be able to
reconfigure even when it's deployed
those are different parts of your of
your application and the core engine the
core machinery that you have built 10
years ago and are still reusing product
people know what I'm talking about
because you usually have that stable
inner lower lowest layer here so if you
look at those things then you can say
that there are certain things that are
hard cold and some things are softer
right that's that's what I wanted to say
here and those can be very different
those can be very different things so
one way to approach this would be to
pick a pick a runtime maybe that's just
a JVM we're just using a generic run to
a specific runtime and stick with that
and then we'll build our core domain
using Java maybe that's some sort of
Divi approach we have this common
language that if that we've established
and everybody uses the same libraries
and that's sort of the core knowledge of
I don't know what a billing application
and a billing domain and then we have a
specific scenario where we may be wire
this together for a particular scenario
and you can see that there is something
software in the top layer which is this
XML kind of thing now I'm not using XML
as a programming language here I'm just
saying that you extract parts of your
program instead of putting them in Java
you put them into a software form into
XML because you can edit that at runtime
and you can actually do something that
might be you're a spring configuration
or it could be probably property files
or whatever and you can accept slide
variants now this is an interesting one
DSL I know a lot of projects we all do
them ourselves but I also know them from
other from other clients and other
companies where we used ESL's
domain-specific languages and there are
all the rage if you're if you're in the
Eclipse world right you're building a
DSL using a EMF the next text and all
those frameworks it's absolutely
fascinating to me that it's easier to
get a DSL into a project that's been
built using EMF than a different
programming language I never understood
why that is the case because actually
I'm using the language that I invented
and I'm telling you that's better than
using one that someone else invented
even though that other language has a
bunch of books and people and
conferences and lots of coal and all of
that now again I'm I'm a mix I'm being
I'm mixing things up here of course the
domain-specific language is hopefully
really domain-specific but often it's
not often we end up building the stuff
into those dsls
that we need to make things configurable
to make them software than if we built
them in our in our static languages
below and this could just as well be
something different right you could have
j ruby or any other dynamic JVM language
and the same is true for maybe as having
a mixture of c-sharp and vb.net or
whatever right you could have different
languages in your environment to
introduce that and that's I think a very
very interesting thing when you look at
at at complex projects you always find
this you always find those things
where were you add this dynamic these
dynamic aspects because you need them in
real life you need to have something
dynamic brings me to another quote you
can see I'm a big fan of quotes which is
from this guy called full of Greenspan
and there's even a verb of this green
spanning so amused he used common lisp
is the example but it's not necessarily
tied to that the idea is that if you
have a sufficiently complex system what
you're going to do is you're going to
build a programmability
into it you're going to build something
that that can actually act as a
programming language and I've seen
numerous occasions where somebody
started with a small language maybe just
something to set variables right this is
this this is six this is five this is
ten and they then they find out oh I
could use an if statement here right now
let's have a loop okay we're getting
very close now now we have modularity
and we have subroutines now we've
created our own programming language
simply because we need something that's
available to us at runtime and I'm
wondering what do we as developers know
that the developers of least these
languages don't and I want some quick
one criticism I hear a lot is that those
languages are are not performing well
enough right we need to write our code
in a in a language that works well I
cannot build a system that scales and
that performs and in a toy language but
what we end up doing is we have our
fancy static languages and then we
create our own little implementations
and we do that very badly in general
because we're not language designers
some people in this room accept it
accept it so soft and hard spots suggest
different languages right you have
different aspects in your system and
those might be better served with was
different with different languages
getting close to the answer let's go
with number six number six is the idea
that in a distributed system having a
single programming language becomes less
important I strongly believe that I
believe there was a point in time where
we had the idea that standardizing the
programming language was part of the
enterprise architecture strategy right
we use we'll just use EJB everywhere and
everyone's going to be happy and people
found out that even if you used EJB
everywhere
you couldn't get application server from
one vendor to work with the application
from another well you could actually not
even get two versions of the same app
server from the same vendor to talk to
each other so in the end we ended up
with something different I think if we
look in a distributed system something
that's somehow connected then we have to
focus on the on the connections between
those systems and what's inside is far
less important than we think but they
may be built using different languages
hopefully I don't care
hopefully that's true for other
technology decisions as well I'd like to
use one of those systems to maybe use a
no sequel datastore in another system to
use a relational database use what's
best there and I think that the idea
idea the core idea that I'm trying at
across is that if you have systems of
different size you use different
strategies of modeler ization right if
it's a very small thing you can get by
with maybe a single file if the system
grows becomes more complicated you use
different means of modularization
at some point in time whatever it is
those are maybe Ruby numbers at some
point in time you hit the boundary where
it makes more sense to have more than
one application the same is true in Java
as well I don't know how many of you
have a code base with more I have a
single system with a code base of more
than a million lines anybody here a few
people I really really am sorry for you
nobody chooses to do that nobody wants
to have a single system with a million
or five million or ten million lines
what you want to have something that's
modular that has different things
because those bastards that have five
million lines they're totally
unchangeable you cannot do well not
totally but really really hard to change
to modernize to to get into the next
century so again it seems as if I'm
suggesting that you don't have any rules
I think you should have a lot of rules
so I have rules on the left side here
which are maybe cross-system
architectural rules where you decide how
your systems speak with each other and
then you have rules on the right side
which are maybe which maybe limit the
number of programming languages that you
can use I understand that in a large
organization you want to limit the
number of languages to maybe two or
three or whatever right whenever the
right number is hopefully not just one
because I think that's not a good idea
I'm not suggesting that you don't
standardize that stuff again that's part
of the selling kind of thing I'm trying
to do right it's not a good idea to tell
people that they should not standardized
because they all know that it's going to
be hard to find people who want to work
in an environment but everybody uses
whatever they mmm actually that sounds
quite interesting but I don't think
anybody would want to do that so the
basic idea I want to get across here is
that you should have two lists right one
list should be what you set in stone for
the next ten years and one is a set of
guidelines that are valid right now and
that can change next year so that a
system from today can change and can
still talk to a system that's been using
the changed guidelines tomorrow and we
have an interesting example of that
where we have a bunch of very modular
architecture where we have both JRuby
and Java systems that communicate
through restful HTTP a lot of my
favorite technologies in this particular
example and this works really really
well it's a really nice environment
because we're able to use the people we
have the skills we have with different
technologies and we still have a common
architecture and a common approach I
think this idea that the the modern way
of doing distributed systems gives you
certain freedom is a very powerful one
right I care about providing that
interface and to get this sort of
disconnect from the language discussion
let me give another example why would
you not have a single system that has to
give you some XML based on the database
why shouldn't that be maybe using the
Oracle XML database facilities right as
long as nobody from the outside sees
that why not use the most efficient way
and the same is true for programming
language languages and lots of other
things as well there's one thing left
which is of course the most important
one has anybody always everybody always
says which is the people right so we
have lots of technical things we have
some architectural discussions we have
similarities the differences between
programming languages but of course the
people that actually have to work with
those things are the most important
aspect around here right and there are
there are interesting things like for
example the skills that you that you
have I mentioned that before the skills
that you that you need to learn a new
programming language all the skills in
that new programming language may not be
there already so you have to learn the
language but if you take airline OTP
an example than Erlang the language
itself is the easiest part I think it's
entirely possible to teach somebody
Erlang over a weekend it's not a hard
language at all it's a very simple small
language that doesn't have a lot of
features and an ugly syntax but it's
easy to learn and once you have mastered
that you don't know how to program in
Erlang because what you have to learn if
you want to build a distributed system
is the libraries all the stuff that's
there now those libraries you would have
to learn them in any environment right
if here if it were another environment
with another programming language the
same would be true even if it's your
standard environment but you have to
learn how to use that stuff that's true
for every environment it's not timed to
the language alone so I think that's an
interesting thing there's also another
aspect which is more again from from the
from the political side of things a
standard argument against against using
different programming languages that you
won't be able to find people in the
market who can help you write that
that's that's a valid concern I think
sometimes if you work the other way
around I know a lot of people who would
start working with you immediately if
you offered them a culture job because
some people like to work with different
languages and they're very attracted to
companies that try something there so it
might be your secret hiring strategy to
do exactly that the community is a very
important thing I think if you're
building certain kinds of systems then
the community can be a deciding factor
because you picked the community that
has the most experience in building this
kind of system and it just takes the
programming language and the libraries
with it right if you if this is the this
is the community that's really really
good and maybe automating operations
then then go with that maybe that's for
Python or Perl not entirely sure
maybe these days is even rubia I don't
know maybe if you're into web based
systems you read like the the rails
community and the indie and the
innovation there maybe you should go
with that just for that reason for the
framework as opposed to the language
maybe that's the batteries it depends so
the community at least is a deciding
factor I guess and you should take that
into account you need to assess the the
prejudices that people have right
sometimes they are justified sometimes
they're not sometimes it's a simple
matter of trying things out and seeing
is this really as slow as everybody
keeps telling me is it maybe just very
easy to do this
this type of stuff with a different
language and interesting experience last
week when I was added a customer and we
showed them if they're a very
conservative customer and we showed them
a prototype that we've built using
server-side Java and service on HTML
generation and and a bit of JavaScript
unobtrusively under kind and and one of
the guys said well we have this other
system that somebody else has built this
is this is much better it does
everything on the client and I'm not a
big fan of these single page apps so we
talked about this and found out that
what was great was not the fact that it
did everything of a client what was
great was the fact that it had way way
fewer lines of code and he didn't have
that because it did things on the client
it did that because it was written in
JavaScript so the same application in
JavaScript had about a third of the
lines of code than the same than a
system written in Java
once you noticed that you start asking
whether that's really a reasonable thing
to do right so trying things out and
having a look at them after you've
evaluated them it helps a lot to
overcome those prejudice sometimes you
have a lot of dependencies dependencies
can be can be really technical they can
also be in terms of people who are
attached to things right people depend
on on certain things somebody is a
master programmer in language blob and
are you suggesting they use language why
they're going to be a novice so who
wants to go from being an expert to
being a novice just because some random
dude suggests a different language is
better if you're depending on that
language to do that I think that's some
Java programmers will say yeah that's
he's talking about the COBOL guys maybe
I am sometimes it's a very frustrating
thing this can be involved both
directions again the scenario from from
a few minutes ago if you if you let
someone code in a language they hate
they're going to be very very frustrated
it's going to be really hard to make
them love the language just by letting
them play with it sometimes it works but
if they really have strong a strong
reaction some things are a matter of
opinion like if you're a fan of
statically typed languages some people
are very hard to convince of anything
else the same is true the other way
around as well right so maybe you can
try it once but if somebody has made up
their mind for good don't try to change
that and having someone use something
new might make them fresh
traded but the same is true in the
reverse as well right if somebody really
wants to do that fancy new stuff and you
don't give him the chance or the chance
to do that they will become frustrated
because they have to use the same stuff
over and over again so frustration and
motivation obviously are very closely
linked you might actually be able to
moderate motivate somebody because
they're finally allowed to use that
fancy new language to prove how great
that is whatever the language is doesn't
really matter the amount of energy
energy you can create using that is
amazing so as usual people matter most
it's known as no really surprised to see
that and with that I have a my all my
seven piece listed here and I conclude
and I would open up for questions any
comments are welcome as well and
disagreements to anybody yes
right so I think the question was what
about the long-term effect right isn't
too risky to pick a language where you
don't know whether it's going to be
there in three years
absolutely it may be too risky to do
that I don't know you're a scenario
right if you want to pick a language
that's going to be there 10 years from
now you have different rules then if you
if it doesn't matter right if you're if
you're able to say yeah we'll rewrite it
in a different language then it also
depends what the runtime environment is
with the libraries are what the
additional cost is would be what the
where exactly you use the tank for
everything or just for a small part of
the system um some languages have been
there for so long that I don't think
there's a risk that they'll go away
right for example um Ruby and Python and
Perl and then Java they're all languages
that I'm thinking are pretty pretty safe
bet I think even Scala and closure are
probably safe bets these days because
they have enough of a community to
support them and they have enough of
users to be interested in somebody doing
that but again your risk assessment may
be different from mine so maybe that
will narrow down the net number of
languages you can pick from but there
still is definitely more than one to do
that any other question yes
so that's a very good question sometimes
it's not the good parts that me that
that you should be concerned about
because they make it worth using the
language maybe it's the bad parts that
make it worth avoiding it I personally
think there are definitely certain areas
where you wouldn't use her at languages
so I don't have anything prepared for
that so for example I wouldn't use a
dynamically typed more of a scripting
language to write a high-performance
operating system I mean it's kind of
obvious right maybe it's maybe I have
sort of a narrow focus and does not a
really good answer to that because most
of the systems I'm involved with our
web-based systems and in web-based
systems performance of the programming
language is just one very very tiny
thing of the overall performance in the
architecture so you have to usually not
care too much about that it's risky what
I'm saying here but usually that's the
case I don't have any particular thing
but it's a great thing to follow up I
don't have an answer I have to admit
that anything else ok then thanks a lot
for your time have a good conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>