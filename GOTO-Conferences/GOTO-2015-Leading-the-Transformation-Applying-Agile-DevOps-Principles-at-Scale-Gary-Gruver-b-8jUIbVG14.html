<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Leading the Transformation &quot;Applying Agile &amp; DevOps Principles at Scale&quot; • Gary Gruver | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Leading the Transformation &quot;Applying Agile &amp; DevOps Principles at Scale&quot; • Gary Gruver - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Leading the Transformation &quot;Applying Agile &amp; DevOps Principles at Scale&quot; • Gary Gruver</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b-8jUIbVG14" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">if you can improve your
productivity by two to three X would it
matter if you could figure out how to
start saying yes to all the business
requests you're currently saying no to
would it make a difference what if you
decided all this stuff was too hard or
didn't make sense for your company when
you went back but your competitors
decided to go all-in and really start
transforming the way they did software
development can you see how that make a
difference to your company to your
co-workers and to yourself over time due
to 3x seems like a pretty ridiculous
statement in terms of being able to get
more productive but in large
organizations I think it's real
I think it's realistic at HP in 19 or in
2008 2007 I had an opportunity to take
over the LaserJet embedded firmware
organization that was about 800 people
worldwide the world wide span was about
a hundred million dollars a year and for
two decades since I'd been in the
business it had been the bottleneck for
the entire LaserJet printer business we
couldn't add a new product to our plans
we couldn't create the marketing
capability so we wanted to because we
always had to check with firmware and
too often the answer was no and in 2008
everybody remember 2008 it was a big
spending increase year now it wasn't so
much we had a new executive vice
president come in senior VP and the
costs were under constrained we had to
figure out how to reduce cost
dramatically across the business had 30
days to come up with a plan to reduce my
development cost from a hundred million
dollars a year to fifty to sixty at the
same time we're doing a complete
reaaahhr tech chure of the system and
throwing away the old codebase and
trying to figure out how to bring it up
I'd watched this business from the
outside for a couple of decades and
realized it was a constraint to the
business we couldn't move forward we can
move faster we needed to do something
fundamentally different up until this
time HP had been trying to spend their
way out of the problem with no success
we needed to engineer a solution we
needed to take a completely different
approach and we started applying what I
would call agile and DevOps principles
at scale we didn't necessarily spend a
lot of time on that
team level but we got my staff over 800
people thinking through how do we
constantly figure out how to improve
because there was a two billion dollar
business standing behind me
we'd thrown out the old architecture we
needed to get the new architecture out
and I was looking for anything I could
possibly do to improve the effectiveness
and productivity of the organization and
we went on a journey of continually
trying to improve that and after about
three years we look back and we
fundamentally changed the entire
productivity of the organization
we'd reduce the cost from one hundred
million dollars a year to fifty five
million dollars a year firmware was no
longer the bottleneck when we wanted to
add a new product to our plans and to
our future roadmaps
it was easy for us to look at it and say
it does not take a lot of resources so
we can add them we were starting to
release one hundred and forty percent
more products than we were previously
supporting at about half the cost and
the number of them the capacity that we
had for new features and new
capabilities had gone from about 5% of
everything we're doing to about 40% of
everything we were doing so we started
saying yes to the business in a lot of
fundamental ways and as I checked with
my co-author a couple of months ago when
I was back there talking about how
things were going
they'd actually drain the swamp a
marketing request and they're actually
working with the engineers to think of
new ideas that they could add while they
continue to reduce costs over time
pretty dramatic improvements in the
productivity of everything we're doing
now the interesting thing is is we look
back at it we had a lot of teams that
were implementing agile principles at
the team level they were doing burned
down charts they're doing stand-up so
doing scrum they were doing all those
things we had some other teams that
really weren't implementing or
practicing those team ovale rituals and
what we realized was there was not a
dramatic change in productivity between
the teams that were doing all the agile
things and the teams that weren't doing
all the agile things but 2 to 3x
improvement productivity at the overall
organization which led to our conclusion
that in a large enterprise how the teams
come together
deliver value is the first-order effect
how the individual teams work by
themselves as a second-order effect now
this is a case when you have more
tightly coupled architecture that
requires large parts of the organization
to develop qualify and release code as a
unit
it doesn't necessarily happen when you
have organizations that have
micro-services architectures that you
can have small independent teams develop
qualify and release code independently
so if you're thinking of a large
organization that's hightly coupled you
need to think about applying these
principles if you're more in a situation
where you've got a very clean
architecture with that's very loosely
coupled you can think about more how do
you empower the team and get people
supported and make those types of things
going so when I talk about the agile
principles I think it's pretty
straightforward and Dave can catch me if
I get this wrong because he was there
from the very beginning everybody
understands the basic waterfall
methodology and the realities of
waterfall that when you try to lock in
all three of those triangles and there's
uncertainty and discovery in the process
you either work the teams to death or
you slip the schedule or some
combination of both and the basic
principle of agile is to break that up
into smaller iterations where you're
releasing on a more frequent ongoing
basis well if you have a large tightly
coupled system that includes hundreds to
thousands of engineers the small agile
teams aren't necessarily going to think
about how they coordinate and integrate
and release their code on an ongoing
basis if you walk away from anything
with this one top walk away with this
that in a large complex organization
scrum does not equal agile and if you're
not really careful about how you do it
you're going to end up with a classic
mistake that's made in most enterprises
of creating a water scrum fall process
in this process you have the team stand
up doing really good iteration but
they're still committing to plans that
are 12 14 18 months into the future and
they're still having a hard time
integrating and releasing their code on
a more frequent basis a different
approach and the approach that I'm
presenting in my second book that's
coming out leading the transformation is
you really shouldn't do
you shouldn't do devops you shouldn't do
lean you shouldn't do any of those
things we're managing a business we're
part of a business you should understand
what you're trying to achieve for your
business and if you can't think about
why your current development processes
aren't meeting the needs of the business
and clearly identify that you shouldn't
go off on a journey just to adopt the
latest ideas or approaches you should
really start with why are your wire your
current development processes failing to
support the business needs that you have
and get that very clear because a
transformation like this is going to
take a while and you always need to look
at what's the long term vision what's
the long term direction what are the
things that in the way of getting this
done and what are we trying to achieve
and then once you have the business
objectives you can start to look at
there your toolbox and your toolbox has
combine ideas lean ideas I have two
ideas DevOps ideas and you should take
the tool other toolbox it's going to fix
the problem that's your biggest barrier
to making your business improve the next
thing I would say is you need an
enterprise level continuous improvement
process it's not enough for each of your
individual teams to be doing retro
spectryx and doing reviews and trying to
improve because if you're going to make
these changes in a large organizations
it's got to work across the organization
and you need your executives engaged in
part of the process of setting the
objectives and working with organization
to figure out what's getting in the way
of getting things done and what's not
and then if you have a good process for
changing your planning process to where
it's responsive and reactive to what's
going on a prioritized backlog and then
you have a good process for releasing
code on an ongoing basis in the
enterprise it does not need to be any
more complex or difficult than that but
you need to continually learn and adjust
you need to start where you're going to
have the biggest business impact and you
start need to work on your planning
process and your delivery process so
overall across the organization at HP we
very clearly started with our business
objectives and our business objectives
were we didn't want firmware to be the
bottleneck for the company anymore and
we wanted to free up capacity for
innovation
so when we looked at those things we
started looking at our value proposition
and we started looking at anything that
was a cycle time driver or cost driver
that wasn't key to the value that we
were trying to provide the company and
anything that wasn't we automated
eliminated or we engineered it out of
the system fundamentally changed
everything we're trying to do the next
thing is you need an executive lead
continuous improvement process and this
is more than just an aggregate of what
the teams are doing because if you've
got a thousand people and you've got you
know a hundred different teams your
strategy can't be an aggregate of all
those different teams if you're going to
try to coordinate work and coordinating
provement across the organization make
that piece over so you need to start
with setting objectives I know most
agile teams will work on a two week or a
month or a one week basis and sort of
iterate and respond but if you're in a
large organizations I found about a
month works well it gives you time to
set those objectives and it also gives
you time to get alignment across the
organization that those things are
important and achievable and possible to
do once you set those objectives you
don't change them during the iteration
you focus in on them and then as
executives what we would spend our time
doing is trying to figure out what was
getting in the ways organizations way of
getting these things done so you started
the month with her vein organization
bought into that these were important
they were a priority and they thought
they were possible to get done and if
they weren't get done during the month
as an executive I had metrics I could
review every morning and I'd spend all
my days out an organization as an
investigative reporter trying to figure
out what was getting in the
organization's way and it wasn't going
in to go and say Dave why didn't you get
this done it was Dave well what happened
what got in the way why didn't this get
done and wasn't why didn't Dave get it
done it was what got in the way of Dave
being able to accomplish this and doing
that and through that process you take
those learnings roll them into the next
iterations and start taking plans and
removing barriers that were getting in
the way of the organization being
effective and productive and it was an
interesting cultural change as a leader
over an 800
person organization when I started
showing up at the desktop of an engineer
that was struggling it was a bit
intimidating at first but when they got
used to me coming around and asking the
questions and trying to figure out how
to help and they realized I was really
there to help it started creating
transparency with trust constraints
parents even with transparency comes the
ability to fix things and it's a culture
that builds on itself over time the next
thing in the planning process it's
interesting and this is going to be the
hardest in any organizations to get the
business to understand because they
manage everything else in their business
with waterfall
I make commitments they make plans and
most of the people in the organization
don't understand software's different
needs to be managed differently probably
the biggest challenge with software is
we are so poor at predicting what
software capabilities will add any value
that literally 50% of everything we do
is in industry is ever neither is either
never used or does not beat its business
intent can you think of anything else in
your business that has a 50% hit rate in
terms of what's going to be useful in
there executives need to understand that
they also need to understand that
software is very different than
everything else that you do if you're
going to build a new manufacturing plant
it may be a little different size it may
be in a little different shape than
anything that you've done before but
it's going to be leveraged off of most
things that you've been doing for years
and years over different times and
there'll be some discovery in the
process when you go off to write new
software you're doing it for the very
first time the very first time ever and
it's really hard to think through all
the things and you can sit around and
plan and plan and plan and basically
work your way up this slide where over
time you can invest more and more in
planning but you meet diminishing
returns after a while the best way to
learn more about what your schedule is
going to be is start writing code and
start validating some of your
assumptions and figuring it out most
executives don't get that so hopefully
chapter 5 of my new book is something
that
you can share it and put on their death
work through that and help them
understand that if they are going to be
effective at managing software they need
to think about how to manage it
differently so 50% is never used it it's
it's hard to get it accurate but the
advantage of software is if you develop
it right it can be changed up to the
last minute
anything else an executive is doing in
their business if they get it wrong and
they they planned it wrong it's very
expensive to change if you poured all
the cement and the factory but you had
it planned wrong that's going to be very
expensive to change that's not the case
with software so if you look at applying
waterfall principles to software your
risk of making the classic mistake of
taking your most flexible asset turning
it into a fixed asset to deliver
features it'll never be used or won't
delivering business value you need to
get executives to figure that out and
figure out the managing software's
differently otherwise they'll waste a
lot of resources working all the way out
to this end of the curve because they
think if they just spend more time
planning software it will get better
over time probably a lot of people Moore
came to listen to the DevOps side of
this I've spent a lot of time
implementing a very large-scale
continuous integration thing at HP and
then at Macy's I'd let our transition to
continuous delivery for the website over
across the organization a lot of this
earnings will be shared based off of
that the first thing you need to start
with or what are the objectives that
you're trying to do if you're going to
try to apply DevOps principles if you're
going to try to release on a more
frequent basis one of my experiences we
went in we said well we're going to do
continuous delivery and we think it's
important to do continuous delivery and
I joined the company because they had an
effort to do continuous delivery and I'd
read justice book I liked it I wanted to
learn more about how to make that happen
and we'd taken one application and we
said okay we're going to script an
environment scripted deployment its
automated testing evolutionary database
on that one application what we quickly
found over not quickly about over nine
months is
we were struggling to deliver the value
that we expected to and help the company
because we couldn't independently
develop qualifying to play that code
because it was too tight tightly coupled
to the rest of system the organization
was able to look back at us and see the
fact that we'd invested a lot of money
and time and resources trying to do
continuous delivery but it wasn't
affecting their day-to-day work and I
went spent the afternoon with Jaz and
brainstormed and worked on it for quite
a while and I realized we'd made a
mistake that I didn't make it HP at HP
we didn't go off to do agile we went off
to improve our business and meet our
business objectives and so I stepped
back from what we were trying to
accomplish when we're doing continuous
delivery and said what are those
objectives it matters and the very first
thing is we wanted to provide good
real-time feedback to the developers
because we wanted to help them become
better developers we also want to make
sure that was in an operational like
environment as we possibly could because
we wanted to make sure the operations
team and the development team were
aligned on common objectives and said
developers trying to figure out how to
get a feature done and sign it off on
the desktop and then throw it over the
wall and ask operations to try figure
out how to get into production that
doesn't work very well the other thing
in a large organization is you tend to
take a lot of resources going from
release branch into production takes a
lot of time like takes a lot of effort
that's non-value-added in your system
and then the other thing we're focused
on is we were struggling with a reproof
reproducibility and repeatability of our
build deploy test process so we wanted
to clean that up and when we focus down
on these things that really helped guide
our guide our directions one of the
biggest things you're trying to do in a
large complex enterprise system is find
the offending code so you can get it
fixed so you can get the quality up to
the point where it is releasable I
imagine everybody knows their top triage
errs that go through the code in the
beginning and the end game and what
they're trying to do is who brought in
code that was offending now if I go to
Dave and I go to Dave 6-8 weeks after
he's written some code and says hey
David looks like you brought this in and
it broke all these tests what were you
thinking what you're doing to which
points Dave's going to go what test
when are you sure it was me you know
danke
in that code a lot I bet it was Dan and
it probably wasn't me and so what you're
trying to do with your process of DevOps
is really isolate who in the last six
eight weeks since your last release
brought in that offending code and then
give them that feedback if you can do
that within hours I'm no longer beating
up Dave for being a bad person
I'm helping Dave become a better
programmer because I'm giving them the
feedback in an operational like
environment to understand what it takes
to make it work all the way out to the
customer and you get the organization
focused on how do you transition this
all the way through the other big
cultural change is developing on trunk
if you look at a very large complex
enterprise system and you say we're
going to do development all on trunk at
HP we had 20 some-odd different products
we were supporting we're supporting MIPS
processors we're supporting arms
processors were supporting Lowe printers
and we were supporting big copiers we
had different scanners we had different
paper handling we had all those
different things
all that was done on one trunk with arms
nips XP and see that runtime compiled
for the specific product when I started
talking to organization about doing this
they thought I was crazy they would
avoid making eye contact when I walked
down the hall they're just ignore them
they'll come back to a census or I'll
fire mrs. HP it works that way and then
over time there was one day bra jerk we
came up to me goes you know I think we
can make this work we'll just feature
bind us we'll run time compile it we'll
make it all work we'll take all the
if-then statements out of the codebase
we'll put it into an XML file that
defines the product all the code will
reference that product and we'll quickly
be able to port it to all these
different products that's started to
make sense it was really hard for my
lead over release and test to figure out
and build to figure out how to buy into
this process he thought I was crazy for
longest time he actually would want to
come up to me and talk to me on a
regular basis okay branching we're going
to bring notroy we're not gonna branch
because previously we would have like 10
different branches were representing
product
and different windows of releases like
notroy we're not gonna branch he wore
out of the surahs trying to say branch
without same branching he'd say but when
we go to this different place at the end
then how are we going to manage the coat
and no we're not gonna branch troy
doesn't help to use different words and
after about two years three years i was
getting ready for our first release of
the new architecture for a scanner that
we're trying to get the door and say our
character i'm ready to bring it she's
like what you're crazy we can't branch
and lose all the efficiencies of working
on one trunk with all the automated
tests and all the quick feedback you're
crazy and then he went on a river trip
down the middle fork the salmon there's
a fly-in ranch that are halfway down
that's called the flying 'bee ranch and
he came up to him with his hat on it
goes we don't need no stinkin be ranch
i like that story for a few reasons one
is until you've worked in this type of
environment you can't imagine working in
this type of environment once you've
worked in this environment you can't
imagine work in any other way I've had
several people leave HB call me up go
Gary you can't believe this new company
I'm working as they've got no system
they've got no continuous integration
all the automated testings not work and
I don't have the coverage I don't have
the ability to program with trust and
reliability and go fast like I used to I
have to go slow slow and then I have to
always be fixing things later and then
the code base I'm in is not stable and I
can't understand the effects of my
changes the key in this is going on that
journey from nonbelievers they're not
amazing able to imagine work in any
other way but you should start with your
fundamentals I think the biggest thing
that people are starting to understand
as they do continuous delivery is you're
in one of these two camps almost
everybody you'll hear presenting at
conferences like velocity or a lot of
those has very clean architectures that
enable small agile teams to
independently develop deploy and qualify
code that's ideally where you should be
I'd love to be that way I tend to work
more on legacy large legacy organization
that have architectures that look a
little bit more like the architectural
diagram on the bottom of the screen over
there where it takes hundreds if not
thousands of people working together to
develop qualify and deploy code if you
try to implement the ideas that you're
hearing at the velocity conference when
you have an architecture that looks like
a ball of string it's not going to work
very well so before you start applying
DevOps principles figure out where you
are in terms of that independence of
teams and figuring out how to work
together I would encourage you were
possible to architects I think Rebecca
covered some good information on how to
reaaargh attack the micro services to
enable this to happen her comment was
you shouldn't do micro services until
you've done continuous delivery I guess
my pushback on that is you should really
think about going to micro services so
it's doable and easy to do continuous
delivery but you can do it with large
tightly coupled organizations it's just
more complex and you need to think about
it differently the first thing I'd start
with always is your build process this
may seem obvious but can you draw a
large architectural diagram of your main
artifact that you're thinking about in
the system get a green build with some
automated tests and then if you go to
version 2 of each one of those
components and version B causes it to go
red and you get a red build can you just
go back to version 1 of component B and
get a green build or do you have
libraries that are tightly coupled
across the system that have dependencies
across it so that you can't go back and
forth that way because if you're going
to build up a large complex system and
you're going to keep it always green and
releasable if you can't fundamentally
pull pieces out whenever you get a red
build up there you're gonna stop all the
code progressing through the system and
it's going to become very painful the
next thing is test automation
I think Trisha and joy presented some
really good information in the last
couple hours on how to do automated
testing more at the unit test level and
that works well if you have it and a lot
of legacy tightly coupled systems
frequently you can't depend on that
because one if you have legacy code when
are you going to get the time to go back
to
and a bunch of unit tests is probably
not realistic to make happen and if the
codes too tightly Epple coupled you're
gonna need test automation system
testing to enable you to find all the
issues and give the feedback to the
developers that you need this is too
important to be left to your QA
organization if you leave it to a QA
organization that's been doing manual
testing for years they will automate
what they've been manually doing and
you'll find that you end up with a
maintenance nightmare and you end up
with code that does not quickly localize
the problem and that's fine when you
have a 10 100 maybe 200 300 tests but
when you start getting thousands of
tests that won't work
Jeff Morgan's got a fairly good example
of how to do this with UI based system
tests where you've got business logic up
in the UI and what he does is basically
he uses a puppy adoption website and
teaches you how to do this what he does
is for each page he creates a page
object for each page in your website and
then when you hit that page he has a
data magic gym that automatically
populates that with the data that you
need and then when you write a test you
say go from here to there if you leave
it to your manual organization to do to
automate what they've been doing
manually for years what they're gonna go
through is we're gonna say okay if I
have a new credit card and I add new
functionality I want to make sure that
that works first thing I'm gonna do and
we get a home page we go to Mann's I'm
gonna go Blazers I'm gonna go to blue
and I'm gonna pick this I might add the
product to my cart and I'm gonna check
out does a credit card work well that
works fine when you have one or two of
those tests but when you have a thousand
of those tests that start on the home
page and the home page changes you're
dead in the water but if you've taken
the page object model approach then they
don't that and they all reference that
page object the only thing you have to
go update is that one page object that
enables you to keep UI testings
up-to-date with your website and evolve
with it and go with it as it comes along
this isn't the necessarily only way to
do it or the right way to do it but you
need to think about how your application
is going to be changing over time and
how do you design your system so
and it changes it only needs your tests
only need to change in one place and you
can reference that the other problem
with this test is this was a check-out
test to validate that the credit card
worked well if the checkout team's
responsible for keeping that test
passing on our ongoing basis and it's
written that way they're gonna run into
problems and you're gonna find that
they're not going to own the quality of
that test because if the home page broke
or the navigation broke or any of those
other things that broke that wasn't
associated with what they were doing was
not their responsibility and wasn't
their code then they're going to come in
and look at a bunch of check out tests
broken and they're gonna assume that
they have to fix something your
automated tests should realistically
start at the checkout page it should pre
populate it with everything you need to
do and validate that just that part of
the codes broken so getting the tests
where they're maintainable and quickly
localize the defects is important if
you're gonna be running thousands and
thousands of tests and getting the team
to own the quality of their code on an
ongoing basis automated testing is
probably your most valuable tool I'm
trying to figure out how to transform it
I don't know how you'd transform it
without it done well I think it's most
frequently thing that's done wrong in
organizations it gets maintainable it
gets where it's not maintainable from
keeping it up and it gets to where it's
not triage able in terms of automated it
being able to look at the test and
figure out what's going on it's too
important to be left to your QA
organizations you should get an
architect that really understands
object-oriented programming and tiin
them up with your test people and sort
of make sure you come up with the right
approach next when you're doing
continuous delivery you need to think
about you can do at a small scale a very
long complex algorithm and Jenkins it
sort of sets this all up and makes it
work I would encourage you to think
about more of the different principles
that you're trying to accomplish in here
you need a trigger that triggers off the
build that says I got a build I'm gonna
kick these things off you need to call
your scripted environments and set that
up separately you need to you need your
automated deployment your evolutionary
database and your testing if you try to
build that all into one script it gets
similar to what you're trying to do with
test automation is when your logic your
thinking about how are you
i'ma pipeline needs to work changes over
time you end up having to update all
these long monolithic scripts if you can
think about pulling that business logic
up into your Orchestrator enables you to
leverage more common scripts across the
system the other thing that's important
is if you're going to have a bunch of
different environments that you're
working across make sure that you have
common scripts you're probably not going
to have environments that are all
consistent but similar like we did in
the laser jib business where you an XML
that separately defined the different
products take that out of your common
scripts so that you have a common script
that you work you automate and you
reproduce it tens and hundreds of times
before you ever go into production to
make sure it's working and you just
referencing the environment differences
between the two places you need to do
the same thing with your automated
deployment to make sure they're common
and if you have your operations team and
your development team using different
tools for this process you're not going
to start to cultural alignment across
organizations that you need to have them
working on common objectives one of the
biggest values of continuous delivery is
when you go into production you've
already done it hundreds of times and
worked out all the bugs if you're using
different tools or different processes
in production than you are in
development you're not going to see the
benefits of those changes evolutionary
database one of the biggest bigger
challenges of keeping code always
releasable is when you bring in schema
changes a lot of people will come up and
say no I can't keep it always releasable
I got to make this schema change we have
to coordinate it if you have your DBA is
bringing that up buying this book have
them read it it's solved you do add and
deprecated you don't ever modify lazy
instantiation if you do alter or modify
it's like crossing the beams cats large
sleeping with dogs all sorts of bad
things happen and you can't have always
releasable code you need to do the same
thing with your services they need to be
versions and work through that process
when you're doing automated deployment
frequently what people do is they're
deploying across a large number of
servers you deploy the code or you
configure the environments you deploy
the code you're on your automated test
and then they fail and you start a big
long complex triage process and you've
got to figure out what routing or what
server is in a bad configuration or bad
state that can be as complex as finding
bad code that was brought in in the last
several months and trying to localize it
to the defending person and it can be
equally worse if you have the same
application running on several different
servers but the deployment only failed
on one of the servers because then it's
very intermittent somebody sees it when
they test somebody else doesn't see it
when they're testing the door through
that we ran into this and the last
implementation of continuous delivery I
did and what we what we found is we'd
spend two or three days with the team
trying to get the bill back to green and
there was a fail and there trying to
figure out what was going on they said
well it's pretty clear here that you
know don't bug us again because this
deployment wasn't successful and I said
well how can you tell that as well if
you go into log filing and look in these
areas you can see this oh great let's
start adding that as a test and so
similar to what we're trying to do with
billed frequency and some other things
to localize the offending code to the
fewest number of people as possible what
you're trying to do with your deployment
process is localize the offending
environment or deployment to the fewest
number of routing devices or servers as
you possibly can so start off with
configuring your routers and your
servers devices run a test to validate
that that's successful at the end of
each deployment run a test to make sure
that that deployment was successful and
then run your code validation when
you're on your system test this isolates
in a very large complex organization the
code issues from the deployment issues
and you don't want to waste your time on
these things and anytime you're finding
deployment or environment issues when
you run in your final system test it
tells you that you need another post
validation test that you need to add in
the process to find these things and
localized them earlier when you're
building up a large complex system say
you have a bunch of large agile
organizations but you're hooked to COBOL
mainframe type applications how do you
build up and integrate a very large
enterprise system like that the first
step is always start with your agile
components make sure that you've got
unit tests that are passing and you've
got you know
code analysis types of things going what
you're trying to do is keep really bad
code from getting in and damaging the
entire system and this is an ideal first
step I can't think of any reason why a
developer would be allowed to check in
unit code that's not working can't think
of any reason the developer would be
allowed to check in unit code that is
not working
J sort of said well there's bad unit
code and there's stuff that can be done
and people write it poorly when they
realize the pain of that they'll start
cleaning those things up and doing it
but if they can check in code and you've
got a bunch that are failing a bunch
that are passing how do you decide
whether you can want people check in or
not the next step is breaking up the
system
I found service virtualization you could
call a mock you could call it a stub but
how do you isolate certain parts of your
system so you can localize the code
there's there's three steps that you're
going to take to localize one is build
frequency the more frequently you can
build in the better feedback you can
give on that the more you're going to
localize it if you know fewer number of
developers the second is breaking up
components that get qualified and then
built up into the larger system so if
you have two different organizations one
on the East Coast and one on the west
coast you may want to think about a
continuous integration to build as much
of that system as frequently as you can
a system that builds as much of that as
frequently as you can and then put the
system together service virtualization
you should avoid wherever possible as
much as you can because it's something
you're going to have to maintain and
it's something that could be different
but when you have extremely large
organizations it does break down the
complexity and enable you to keep this
going and then once a day or so you
should always make sure you're pulling
the virtualization out and doing end and
testing the other important thing about
this is if you have very complex systems
hooking to things like COBOL and some of
those other things on mainframes if you
do Indian testing with everything it's
very expensive it's hard it's almost
more complex to set up those big large
environments and run all the testing in
my last job if we started with 1,300
tests that we ran about every 10 days to
release code on it to the website and
ongoing basis when I laughed we were
close to 20,000 a test
every day if I had been running all
those tests against the mainframe and
being charged for my processing on the
mainframe the CFO would have hunt me
down and shot me because I would have
driven costs out so the idea here was
test as much of the system back here and
then if I had a hundred tests that sort
of did end in testing and use the
service in a similar way run the
hundreds of tests when I was in this
phase of my deployment pipeline and then
when I got to this phase just picked the
one that I thought added the most value
and do the end and testing on it it's
different from how a lot of
organizations approach it where they
want to have the customer sign off on
Indian testing with everything and you
spend a bunch of your time and effort
trying to put the whole system together
and make it work the other thing that I
would say you heard of people talking
earlier about how do you get your
teammates bought in and courage to keep
a bill green and make it work on an
ongoing basis because what you'll get is
a train wreck on the system that
everybody has to stop developing code
deploying it get it into then on a
regular basis or else you know you're
just building up a tarball and you can
never get back to a green build at HP we
had a bunch of stuff we were trying to
get done I had an organization breathing
down my throat to look at the feature
throughput and what was getting done and
we ran into a day that either an
intermittent code or an intermittent
test made it into the system and we're
getting red bills and the build team was
getting frustrated everybody in the
organization was getting frustrated the
build teams added</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>