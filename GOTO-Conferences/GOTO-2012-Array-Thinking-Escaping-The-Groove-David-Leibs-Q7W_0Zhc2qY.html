<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Array Thinking Escaping The Groove • David Leibs | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Array Thinking Escaping The Groove • David Leibs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Array Thinking Escaping The Groove • David Leibs</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q7W_0Zhc2qY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning so I'm David
leaves from Oracle labs and I'll be
talking about some stuff that has
nothing to do with any Oracle product
present or future so we're going to
start off with some pseudo neuroscience
and metaphor and the underlying theme is
is really about our propensity to get
stuck in a groove or I'll even be less
polite gets stuck in a rut and that's
really about an idea called path
dependence which is a an idea from
economics about how you'll start off
with some piece of technology and the
early decisions you make will be with
you forever
hundreds and hundreds of years later
they will be influencing the decisions
that are made to go further we're gonna
then sort of look at how I as a human
being was wired as a child and then
we're gonna dive into one of my favorite
topics on earth array programming it's
beautiful and it's something I think
it's well worth your time to invest in
and then we're going to look at some
futuristic ideas for what kind of
interfaces we might put on array
programming in the future so I am NOT a
real neuroscientist but I did play one
once at NASA in the early 1970s and what
I'm going to talk about isn't real
it's not how we really work so it's
really going to be metaphor so let's
look at what happens when water falls
from the sky and hits a little piece of
ground it makes a dent and that little
dent now is a place the next time the
water hits it gets a little bit bigger
and water is very much an optimizer and
before long it you know turns into a
little bit of a groove and the you know
the groove but it becomes a rut and over
time water carves amazing deep canyons
so I maintain we're like that too
we're very influenced by what we first
learned and we practice things that that
were drawn to so we we lean towards that
what we like and our first experiences
have a huge impact on that
so as time goes on we just get into a
groove so let's play with this idea for
a second time this is one of my favorite
optical illusions of of all times it's
not really an optical illusion but what
do you see I'll give you a second all
right can you see the cow anybody there
you go
it's happening that little drops are
hitting maybe that little outline around
its face will help if you can't see it
that's okay
see me afterwards and I'll crank it up
and we'll give you the experience anyway
those of you who are able to see the cow
can you not see the cow and that's the
important part
once you have seen that cow you will
never be able to not see the cow an
ultimate we find ourselves at the bottom
of canyons loaded down with all of our
stuff slogging through the water with
our friends
we might well find ourselves at the
bottom of the for loop now to most
programmers this code for matrix
multiply it looks normal but to me it
you know I see a canyon being dyslexic
rotations don't matter so it's important
to remember to to climb out of these
canyons that were in from time to time
even though it's like difficult because
there's some things out there that are
of just absolutely great beauty you have
to go and and look into some of the
other canyons that are there so okay
truth in advertising let's look at how I
was wired as a child because this is
going to have something to do with where
the whole thing goes I had a very
strange toy I played with as a child I
played with clothes pins and I would
clip them together into structures and
then I would throw more clothes pins
into those structures and I'd try and
set off a chain reaction and it wouldn't
happen every time you sometimes the
magic would work sometimes it wouldn't
it was an obsession I did it like every
day and at the same time I was doing it
I was sitting on the floor in front of a
television set hooked into sort of the
information stream that was just coming
in I you know sometimes it was
interesting sometimes it wasn't but I
was still there trying to set off those
chain reactions I really really liked
some of the stuff I saw on television
and it it's just like wow I think I want
to be a scientist right
it's 1950s right well I well because
scientists are the ones that get to
fight monsters obviously you know I like
science fiction and
one day I had this amazing experience
where a real scientist came on TV and
started explaining how you know nuclear
chain reactions worked and explained how
like you know one slow-moving Neutron
would like go into a you know atom of
uranium what the isotope 235 and - it
would split and two more neutrons would
come out this is just what I'd been
doing with my clothes pins all along so
I really got it it was an amazing
experience to see that which I had been
doing sort of connected to something in
the real world
anyway you know years go by and finally
fortunately I got I got drawn to
mathematics anybody recognized that
person down in the bottom Oliver
Heaviside he's a person that was known
for coming up with a the notation that
we use for vector calculus and it's it's
pretty much if you do physics it's your
notation anyway so I was clearly
neglected they didn't give me you know
proper toys to play with and steer me
into you know more meaningful you know
directions as a child but so what
happened to me well strangely I find
myself doing today what I did then I sit
in front of a 30-inch monitor hooked
into a stream of information and you
know coming in from the internet all day
and I clicked together abstractions and
get to a point where I think it's ready
and I'll push the plunger or throw
something in and see if that chain
reaction sets in and I get the effect I
want lucky for me I got to have the good
fortune of being the person involved in
taking small talk ad out of Xerox PARC
and turning it into a real product so
just one more data point
here's my oldest child what he was doing
as a baby and what he's doing today you
know there's a pattern here all right so
let's let's get back to those greens now
that I've told you how I'm wired and
let's look at something really beautiful
get some water to prepare myself so back
in the 1950s at the time I was playing
with clothespins Ken Iverson was playing
with notation he was not satisfied with
mathematical notation he found it filled
with inconsistencies and he came up with
a much better notation and this was that
the really at the dawn of the computer
age he wrote a a wonderful book we just
celebrated the fiftieth anniversary of
that book and he was at Harvard at the
time he was doing this and what I think
sort of lucky for us he didn't get
tenure
you know and his person he was working
with there it was like well you haven't
really done that much you only wrote
that that one little book but it's quite
a quite a book and so anyway he went off
to IBM and with Aidan Falk cause he they
invented the computer language APL so a
sort of a quick overview it had
hieroglyphic symbols it had its own
Selectric golf ball where they they put
their own glyphs on it it had its own
keyboard he didn't like precedence rules
which are sort of forced on us by
algebra teachers so that you don't have
to write as much when you talk about
polynomials it appears as though the
evaluation is right-to-left there's a
notion of a workspace or like if if
you'd ever done small talk or something
like that
like you snapshot an environment that's
filled with your data and your variables
in your code and when you come back
later you just take up where you left
off and it operated on multi-dimensional
arrays as its main data type and so it's
it's functions are defined on scalars
you have operators that are defined on
on functions so operators take functions
as arguments and make new functions and
this all then extends to arrays in four
different ways the element by element
you can do reductions across arrays of
any dimension and you tend to use inner
and outer product as is building blocks
and the people that were really drawn to
this language were the applied math
crowd economists chemists physicists
people that had problems to solve so
they would write they would write code
they would write programs but it was
always in the process of solving a
problem they wanted an answer to a
question they were exploring a space or
maybe they were designing algorithms so
it's it's it's like not necessarily the
same kind of programming we normally do
but it's in sort of that area of
technical computing so APL has a really
really great idea in that your data is
multi-dimensional and you can take any
multi-dimensional you know be it like a
a number as zero dimensions you know a
list is one dimension a matrix or a you
know a plane it's to you extend it all
the way up and you can look at those in
multiple ways kind of like looking at a
cow you can think of it at at the bottom
you have zero cells which hold scalars
or an atom and then you can have rows of
atoms or you can you can look at the
frame of it and saying well I've got a
you know three three by four frame of
rows or a11 list of three dimensional
arrays so you can look at it anyway
and because functions themselves have
rank right the idea of rank permeates
APL you you have the ability then to
write a function and say I'm only
interested in numbers or I'm only
interested in rows and then APL will
automatically take something of a higher
dimension and figure out what to do call
each appropriately sized thing and
assemble the result into a proper frame
and this is what gives you the ability
to program without having to write loops
the roots the the loops are implicit in
how you set your your data up and the
way you write your functions so a little
bit of information from from the history
APL had reasonably good performance the
first implementation that they did at
IBM completely beat the 360 attempts
that like time sharing in that because
they paid attention to the movement of
the disk head in other words the other
the other groups doing things at the
time let the disk head jump all over the
the disk and the APL guys were careful
too
do their time-sharing by scheduling it
based on minimizing the movement of this
kids so they they outperformed it hugely
in it it went on to become very very
popular so here's some performance
numbers back from those you know days in
the point in time when I you know IBM
was selling APL to everybody all over
the world there'd be a little bit of
set-up time for an operation like a
couple of you know milliseconds and then
you were operating on big homogeneous
structures and once you you know gone
through that little bit of setup and it
would just cranks either through the
rest of it so if you had a thousand
elements the set-up time and the
interpretation was negligible and the
rest of the time was just executing
really really fast machine code and she
had like less than a thousand element
array well it didn't matter you know it
you know ten L woman ray yeah you won't
even notice what's interesting is how
well the modern implementations perform
on an iPhone it's just totally amazing
how fast it is today on on little I
devices so whatever happened to APL well
it grew rapidly in the 1970s and in the
1980s it started decaying off because
pcs were coming on workstations were
coming on and it sort of died out we've
got modern descendants it's still used
quite a lot in the financial community
it gives them a big edge and there's
people out there riding high-frequency
trading systems in APL descendants it
was very influential influence Fortran
90 MATLAB are it's the ideas in
Microsoft Excel array
Intel's array building blocks
Mathematica anything so let's look at
let's look in the little of it the the
version of APL that I liked it as my
favorite is a is a version called J
which is what Ken Iverson did after I
don't know when he when when he was
about 30 years then he decided to redo
the whole thing he said we made some
problems early on that I'm just gonna
start with it with a clean slate and he
made a version that's a ski based and
doesn't require a fancy strange keyboard
filled with wreath letters anyway here's
my ten by three working subset of our
which is mostly just some statistical
functions and the fact that I can put
them all on that one grid and get my
head around the whole thing at one
glance without having to scroll is
something I find very appealing to you
it it probably looks like line noise
certainly these are rate languages can
be very very fast there's lots of
experience going back to the 1970s on
how to do really really efficient
implementations of array processing by
holding off you know jumping in and
executing code too quickly in other
words rather than execute you build a
little bit of an abstract syntax tree
and look at it a little bit and say well
gee they really set up a pipeline here
we know how to do this much faster we're
not going to like make a whole bunch of
intermediate arrays there's no reason to
do that so there's there's a lot of
experience in optimizing these languages
in the 1990s when people started getting
more theory
about parallelism they they noticed that
most of the primitives were just
naturally parallel and because of the
way API works people would tend to write
40 to 50 percent of their code would
just be naturally parallel and this is
one of the things that I think is what's
interesting about why we would want to
look at an old language that isn't you
know isn't as mainstream as it as it
once was
it's a good way to train our thinking
for doing data parallel computation so
you tend to program by using big
building blocks and putting them
together with sort of let's say
higher-order functions and you don't
entangle a bunch of information in loops
it's like when we write when we write
loops we have the the best of intention
and we try and be efficient we try and
make them do more things at once and
what we're really doing is getting in
the way of the loop fusion machinery and
we're actually much better off not
thinking that we know how to optimize
code and letting the compiler do it in
other words much of our intuition is
wrong especially in light of memory
hierarchy issues so APL and it's
descendants encourage wonderful loop
las' you know thinking where you tend
not to you tend not to use accumulators
in loops and so here's a really really
beautiful piece of APL and i'm going to
now give you some animations to give you
a taste for how to do this sort of
thinking and then we're going to come
back to this function once once I've
entered
a little bit more so what's so okay
let's let's start off with just simple
arithmetic and adding three plus four so
it'll take the element to the right the
element to the left in computing and
this animation here is sort of now I'm
starting to show what goes on in my head
when I think in terms of array
programming or what I call array
thinking so the sequence of animations
is something that I'm kind of designing
in hopes of someday having it on some
little device like you know a sunspot
with a cheap e-ink LED and some simple
you know near-field you know maybe a
cheap Near Field Hall effect sensor so
you would know what was to the right and
what was to the left because my dream is
to actually pull it off the computer and
get back down on the floor like I did
with my clothes pins so watch it as it
executes this time and you'll sort of
see the the right-to-left evaluation
computed that so once you know once you
understand
adding scalars well there's nothing
there's nothing magic it'll extend in
the same way to erase
and you can mix scalars with arrays so
all of these functions work the same way
and these are these are typically the
the building blocks that that you
normally use and everything works the
same way so next stylistically you tend
to have interesting functions that take
can take scalars as arguments and make
arrays out of them so this is you know
function called integers it makes the
integers from like the you know the
first four integers zero through four
and it's often just called iota for the
for the character and you can of course
give iota an array and it'll generate
for you a multi-dimensional array so now
what do you do with the race well you
sculpt with them so here's let's just
let's just generate one and then reshape
it into something else
right so vector vector in and matrix out
now
the real power comes in when functions
themselves become data and you have
operators or in in like the the Jade
dialect we call functions verbs and we
call operators adverbs in anybody
continually guess what what we call the
numeric data nouns okay so that / is a
adverbs that is going to take take plus
and turn it into well watch it take that
you turn it into big Sigma and we'll sum
the whole thing up
now my favorite of the operators is
prefix can so here we here we've got a
chain of operators going so generate our
list make the big Sigma now we'll apply
that to every prefix of the array and so
what we get is a running sum now this
can be very useful so the way you can
use this now it's like we're going to
write a function called expand right so
what we want to do is have an array and
we want to put zeros in all the place
you know after all the places where
there's a 1 and where there's a 0 we're
not going to do anything different so to
do that we'll use that prefix sum
when you when you do that on something
boolean you get a nice walk of the
indices and then I'll multiply it by the
boolean again right so do that and what
that that does is you know it uses one
is the identity element and preserves
those indices and the zeros annihilate
just like you want so what I wind up
with in is this this nice thing with the
zeros where I want to do my expanding so
here's the same expression together this
is an indexing function and I'm going to
concatenate a zero onto my array and
when I index into it out pops my values
there with the zeros where I want them
and so that's that's how you use prefix
prefix can and prefix can is very nice
because that's something that we know
how to do in parallel and that's built
into GPUs and so if you start getting
into GPU programming you use prefix
skins all the time okay the other big
function that gets gets used a lot is
outer product and what that does is it
takes every zero cell on the right and
uses the operation that you pass in with
the row on the right so in other words
we'll take one well let's just let's
just let it run it's easier to watch it
there so we basic basically we start
with you know one-dimensional things and
we lift the dimensionality two to two
dimensions and then the other
interesting operation is compression so
on the on the left you have
boolean's and on the right you have some
data in a1 will select the element in a
0 suppresses it right so here's an
example you you know take the you know
take the modulus of each number pick the
ones that were equal to 0 resulting in a
boolean run that through compression and
out pops your data but compression is
really copying that's why in this and by
the way the the the symbols that I'm
using it's my own notation I make I'm
making it up so it we don't get bogged
down in a real language so compression
is really copy because the the number
that I give it is how many copies of it
we want so 0 is convenient way of saying
I want no copies all right now we're
ready to go back to that example and
understand what it it does it's it's one
of the things that I think is one of the
prettiest pieces of APL code and you're
prepared to understand that as I walk
you through it what we're going to do is
like figure figure out like the primes
in the numbers up to up through 15 yeah
it's just a nice small number so ok
we're used to this let's generate let's
generate the first 15 integers we'll add
one to each of them
we'll drop the first one because one
isn't interesting to us since we're
we're hunting prawns and I'm going to
assign that to a variable R now I
apologize for using a variable but I
could do this without the variable but
it would drag in so much more detail in
a first exposure it's unnecessary but
the good news is it's static single
assignment
I'm not going to reassign that variable
okay so now that we've got our that
shaded area is something that's like
something in parentheses we're going to
evaluate it before we go on but I sort
of like using a highlighter instead of
parentheses and it nests better and if
you have multiple colors it's easier to
see okay so let's evaluate this sub
expression first off the bat let's go
back to elementary school and build a
multiplication table of those first 15
numbers and multiply every one with
every other in so this is the example of
upping the dimensionality a classic
technique in array programming and once
we've we've done that we're gonna
flatten it you know
we'd much rather have it be
one-dimensional because we're going to
use the membership function and we're
actually going to take our first numbers
you know 2 through 14 and find the ones
that are that are in that table those
are the ones we don't want these are the
ones that weren't in there
hence primes so now all we have to do is
our cut go back to our copy machine and
select out of our integers the ones we
wanted and we've got our Prime's so
no loops in a faux variable and you can
see the notation down below that I
spared you from it's really not that bad
and if you if you don't like Greek
there's the ASCII J which one can learn
to read okay so remember those grooves
apo and it's it's families are in a
groove all of their own it i love it
it's beautiful you if you were to spend
the time to to to let it into your head
you would love it to and it would it
would show you a wonderful new way to
think but learning it it's it's a little
bit prickly and i promise though it will
expand your brain so I've really been
sitting up all along to talk more about
path dependence and the rate programming
community and us as well we're all stuck
in the mother of all ruts the idea that
started when they stuck a teletype
machine onto a computer and then later
on when they had displays they emulated
the teletype machine and we do
everything through this terrible little
one line at a time funnel likewise that
that little golf ball that was the head
that people hiked West that's a really
limited number of symbols and we've got
all of Unicode to work with and to be
honest we don't even have to be stuck
with Unicode we can you know we can use
candy colored tiles and and and you know
jump right to an iPad and have you ever
watched children have their first
experience with an iPad and how quickly
they take to it and start doing things
anyway we could we could retest array
programming to make it easier to learn
it's a puzzle game as a matter of fact
the APL and it's descendants J is really
very much a dataflow language once you
know what's really going on it's
strictly dataflow and so this is a
little puzzle game I I threw together
where rather than having it be implicit
you actually like see the the path of
the data as it goes through there and
anything you touch is the immediate
evaluation of it and shows you what was
to the right and what was to the left
and all the ranks and all of that so now
we're gonna make it okay
so here's I did a little interaction
design the other day so suspend
disbelief and pretend for a minute that
this is an iPad and we're just going to
have three blank boxes so we could grab
it with our finger and drag it out and
press on it and open up a nice little
wheel of our symbology in pick pick of
functions drag up a box for a noun and
then you know drag off of it and it'll
just let you scroll through numbers you
can use a keyboard but there's misses
the point you know I want to get away
from that that path dependence there
need another drag further up goes faster
and the idea is what is this read eval
print loop business in other words it's
like I want continuous evaluation in
other words we do continuous delivery we
do continuous you know
merging what's the continuous evaluation
while we're at it especially in a
language like this so it's always it's
just always evaluating if I'd drag the
other way I clearly want to be making a
list so change the function to something
else done did drop an adverb up there
make space big Sigma okay so that gives
you an idea of the your the kind of
things I you know these languages are 50
years old at this time we have lots of
experience and I'm really more
interested in the next 50 years it's not
going to go away in other words 50 years
from now we're still going to be using
computers we're not going to give them
up and what can we do to help relieve
some of the path dependence that were
that we're stuck in so here's a little
example of getting off of that
one-dimensional narrow little line that
little straw that we type into and do
things one line at a time every now and
then using up arrows and down arrows to
get the history it's like why are we
stuck on one line that that was
something that was forced on us by a
Selectric typewriter we can we can go to
two dimensions into something that's
more like a scrabble world so this piece
of code is interesting this is a this is
a chain of three verbs
well actually it's three verbs and an
adverb and so I'm going to this is like
arithmetic mean and we're going to work
our way up to some quickly through some
basic statistics and once
again this is going to focus on the data
flow and it's also going to let you
visualize the inherent parallelism let's
split do those two and combine and we're
done and so it's like we can we can give
things meaningful names using that
highlighting technique and so now we're
going to just you know use the regular
deviation that little hand points over
there it says give me the argument that
was on the right so I don't have to use
a variable and now we'll just just build
our way up and you know we'll do the sum
of the squares of deviations
yeah a little circle that was there was
composition of function you'll notice
that that's a sequencing operator and
it's also a bottleneck so okay let's
let's do some some futuristic ideas
here's my little friend Karras and she's
playing with my computational blocks
that I made out of acrylic
there's no electronics in the blocks
anyway she's playing with them and she's
you know there she goes he's just
carving a agree she's totally tactile
acquires most of the information that
she's going to get in the pattern of how
she's going to interact with the world
through these early experiences and I I
really like the idea of getting
computing off of the computers and where
we're going is really with more and more
use of vision it's like I can go out and
I can buy a depth camera from Microsoft
for about a hundred and twenty five US
dollars and I can pull a little eyes
reality I can recognize people by their
skeletons and that is just starting
we've been living with Moore's law for
how long now some of you out there your
entire life you don't know a time that
you weren't being subjected to Moore's
law and we do not have a good intuition
for Exponential's and we cannot
appreciate what's getting ready to come
down in the next 10 years it's going to
be totally amazing anyway with vision we
should just be able to take a picture
and just lift it up into the digital
domain in there it would go so you can
see I'm still doing it I want to play
with those clothes pins right I want to
play with those clothes pins and sit in
front of a big TV but I want to do my
programming with manipul bowls and just
lift it up so here's some resources I
guess this will be up on the the website
J is a really really really interesting
array programming language and it's a
good way to train how you think ken
Iverson's talk for his Turing Award is a
must-read it's notation as a tool of
thought in other words learn a little
bit of array programming first it's not
it's you don't want that paper to be
your first exposure but maybe your
second or third and it is it is amazing
paper
another interesting language out there
is K and Q which is created by K X it's
mostly used on on Wall Street the array
programming community is small but they
have very very very good customers and
there they're not a commodity item
they're very very sought-after and Wall
Street will gulp up any any confident K
programmer then of course there's the
classic itself my friends that dialogue
make a classic and they're adopting a
lot of the really really good ideas from
J slowly and then of course for the
people that didn't have time because we
went too fast here's the information for
the cow
well I would say yes and my favorite
array programming language is actually
Mathematica and that they they they
that's exactly what they do
it's it's like to me the the APL
languages or K or J has to be a complete
language so at some point they have to
adopt the sort of the normal things one
needs to do your work but for me the
real beauty is at the expression level
so I see it as a is a wonderful sort of
domain-specific language or or just ask
your language vendor to please please
give us give us array extensions and and
don't make Plus and time so limited in
other words naturally extend them I mean
can you imagine how cool a data parallel
JavaScript would be I mean why not
you know if the JavaScript is going to
rule 50 years from now let's hopefully
have a data parallel JavaScript yep
they are yeah in and one more truth in
advertising all of the animation and
that was done with Mathematica
yeah that's that's that's certainly a
another way to do it I like the the the
more compressed notation but length is
recognizable to me see it's the kind of
thing that once once you've learned to
think that way
in terms of writing your your code with
with powerful functions and using
powerful operators to combine them with
and I can't write loops anymore in other
words it seems like every time I try and
write a loop I just introduced more bugs
does anybody have that experience so
what you but once you've learned to
think that way
you can do it with any with anything
oh I don't know I don't really know sigh
hi but that they adopt they adopt the
ideas because you do want to do big
wholesale operations
Honore so at some level but I I find it
that when you when you put yourself into
the the real spirit by using one of
those languages you you take some amount
of time to sort of break through into
this sort of naturally composing that
way in other words it becomes a you
become fluent into the language and your
mind is forever changed</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>