<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Building Reactive Apps • James Ward | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Building Reactive Apps • James Ward - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Building Reactive Apps • James Ward</b></h2><h5 class="post__date">2015-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AFqFXlKrwRc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I think I remember coming i'm james ward
i wasn't i taken as a like six weeks ago
at salesforce stuff working on some
projects there most recently did some
everywhere whole application so this
this presentation is going to be about
building reactive jobs so first of all
let's just start a little bit of setup
so the reason why reactive people are
talking about people or building is
because what users want has changed but
we now kind of have some tools that help
us to address user needs that have been
around for a long time so some of these
user needs are in sync data real-time
collaboration instant feedback not to
wait these are things that we've always
wanted but to build these types of
applications in the past we didn't
really have the tools readily accessible
so the the thing about reactive is that
it's in some ways just taking a lot of
these ideas that have been around for a
long time and making them generally
accessible to us as developers so
there's something called the reactive
manifesto you can find out reactive
manifesto org and and the idea of the
reactor manifesto is to put together
these ideas into some high-level ways to
describe how we deliver these things
that users want and so I'll just go
through them real quick but you can
check out the reactor manifesto on your
own and you can sign it if you agree
with it so at first users want
applications that are responsive and
responsive encompasses a bunch of
different things latency and not going
down and all those sorts of things to do
that we need to build on a foundation
that's scalable and resilient so those
are the two kind of middle traits of
reactive and then in order to do all
this we need a foundation that's
event-driven that's really what enables
us to be scalable and resilient at the
same same time and deliver responsive
interfaces to our users so that's your
quick little synopsis on what reactive
is is about you can read a lot more
on react to manifest org the manifesto
is intentionally technology agnostic so
no matter what no matter what technology
you're using the idea should should
apply so you'll see these ideas kind of
weaved through out but I want to focus
more today on the actual how how do we
actually build reactive applications and
so I'm going to be going through kind of
three different ways that we do this so
first talking about reactive web and
talking about reactive actors and then
talking about reactive streams so those
are the three broad topic so we'll cover
and I'll probably spend most of the time
on the web stuff have a little bit of
time the end for actors and streams so
first let's let's talk about the
reactive web so reactive web is all
about a sink and non-blocking that's
probably the terminology that you've
heard most around reactive is a sink and
non-blocking it's a little bit on a sink
and non-blocking really to say a sink
and non-blocking is kind of weird
because we can't actually be
non-blocking without being a sink so we
could just say non-blocking but for some
reason we say a sink and non-blocking
but if you're just a sink there's really
it's really a negative you don't want to
just be a sink for the sake of being a
sink there's there's really no reason to
do that it complicates your programming
model make sure your code harder to
debug so really the reason why we are
going asing is because we want to be
non-blocking so i'm going to cover four
different ways that we can be a sink and
not blocking reactive requests reactive
composition reactive push and to a
reactive so in a nutshell a sink and
non-blocking in terms of the web is
first we have to contrast this with our
typical servlet model a typical servlet
model do get a new post and this is even
true for servlet 30 and 31 the
traditional pathway through a web
request is blocking and what that means
is that when that connection is just
sitting there kind of waiting for the
other side to respond waiting for the
other side to generate some some more
data we're actually going to keep that
thread around so we're going to keep the
thread active you
when the connection is not actively
being used that's the traditional model
that's how we've been building
applications for a long time so in the
async and non-blocking model what we
want to do is we want to be able to take
that thread and when win that connection
is idle we want to be able to take that
resource that thread and give it to
somebody else and this allows us to have
better scalability resiliency we'll talk
about a little bit later so this the
reason why this allows us to have better
scalability is a couple so first we can
do many more things in parallel when we
use this model where we're not blocking
all these threads ideally we want our
thread numbers to be down to about the
number of cores that we have on our
system that's really the optimal number
of threads within the JVM we usually
have a lot of overhead threads and that
sort of thing so it's hard to actually
get get exactly there but but that's the
ideal that's what we want to aim for
there's a few reasons why we want to aim
for that CPU caches stay better cached
when you are not you doing the context
switching of threads also there is a
pretty significant overhead to thread so
the default stack size on the GBM I
think is a megabyte and so this means
that every thread on your system takes a
megabyte just for the the stack and so
we can't just allocate thousands of
threads even if we have performant a
performant way to switch between those
threads we're still allocating a lot of
memory and we'd like to think that we
can and 64-bit jbm is just just have as
much memory as we want use as much
memory as we want a single JVM that's
really not true there is GC larger and
larger GC pauses at least in most JVMs
the larger your heap gets and so you
don't want to just allocate thousands of
threads because then you're going to
have a lot of memory that's that's
that's taking up more time in your GCS
so so it does that's one of the other
side effects and why would want to go
async a non-blocking is when you're not
using threads why have them allocated
we're not using an actual connection why
have it allocated so the other part of
this is that
we now have to be able to handle a lot
more connections to our servers because
we have real time because we have maybe
Internet of Things devices and millions
of devices all connecting to our service
so being able to handle that many
connections we start to would actually
hit limits physical limits on hardware
if we needed to be able to handle let's
say a million concurrent connections we
didn't have they sink and non-blocking
so then the the last reason that I'll
cover around async async and not
blocking is for parallel ism it's often
times now in our applications we have a
request it comes in and then we're going
to fan out to a bunch more requests and
we want to try to do as many of those in
parallel as possible and really one of
our gating factors for how much we can
do in parallel is how many threads we
can allocate and and then so if we're a
sink and not blocking then those fanned
out requests are going to be able to
operate much more efficiently in
parallel because we aren't going to have
the overhead of requests per connection
or a thread being held for all the idol
connections so that's our quick overview
on a sink and non-blocking I want to
dive into some code to actually show how
we would do this you can get some of
these ideas a bit better but I want to
take a poll of the audience you get to
select either Java 8 code or Scala code
so okay java 8 ok I think that's gonna
be one hour Scala code it was close but
I think Java 8 1 that one so ok so we're
gonna we're going to dive in and build a
little app to show how to do a sink and
unblocking with Java 8 so I'm going to
use something called typesafe activator
it's a way to build play and akka and
Scala applications and Java 8
applications so i'm going to call
activator and say not create new i'm
going to create a new application i just
downloaded activator it's a zip file and
extracted it and added it to my path so
then i'm going to select the play java
example and there we go so let me go
into that play Java this is now my new
project that I've just set up and I'm
going to run it so I'm going to
activator till they run and while that's
starting up let me go into IntelliJ here
and open up this project so I wanted to
start from scratch so you can get an
idea for for what it looks like for you
when you start from scratch so it'll
take a second to get everything up and
running in IntelliJ and get the the
project all set up so let's go take a
look first at the the layout of this
project so if I look in this project
whoa let's ignore the target directory
there so if I look in this project
there's a few different things i'm going
to be going through so first in a play
up this is a play application play
framework is a sink and non blocking out
of the box it doesn't use the servlet
api it uses Neddie for a sink and non
blocking so play the way that we're out
are the way that we handle requests is
through a controller will take a look at
that in a second and then I have views
which are my server side templates I can
of course use angular and client-side
technologies there's asset compilers
which we might see in a little bit if we
have time there's a routes file where I
declaratively define the routing of
requests for my application and then a
few other files for like build build
information and that sort of thing so
that's my basic project structure that
looks like it's up and running IntelliJ
before I go there let's go pull this
thing up in the browser so it should be
up and running on localhost 9000 there
we go there's our little play
application okay so let's go open up
that routes file and I'm going to go
create a new route so route is just a
mapping between an HTTP verb and a path
will put in / food for the path and then
a controller method to call and then I'm
going to go into my controller here and
you'll see there's already a controller
I'm going to add in a new one so you'll
see that i'm using static here with play
we can we can start with static methods
and then we can switch from static
methods to dependency injection if we
want to but static methods are simplest
way for demo so we'll use that one today
so a controller in play what it does is
it is it takes a request and it returns
a response so in this case the response
object is called the result so now I
just need to return a new result so I'm
going to return a status code 200 result
with a string body that just contains
asda so that's my very basic controller
and play let's go try it out and make
sure that works so there we go there's
my my controller okay so that's my basic
controller underneath the covers plays
doing this a synced not blocking but
what you've seen so far my code it
wasn't a sink explicitly so underneath
the covers this is a sink and non
blocking but from my perspective the
code I Britain is synchronous so let's
take a next step and let's make this now
asynchronous so instead of returning a
result I need to return something that
promises to return the result in the
future so I'm going to use the f'd up
promise this is really just a wrapper
around around the Scala future so play
is built internally with Scala so this
is an API that's a nice Java interface
on top of this this future API in Scala
so a little bit about futures and
promises that the terminology is kind of
used intermixed usually the the
terminology at least in the scholar
world I think in the JavaScript world as
well is that the future is the side that
I can read a future result out of and
then the promise is the right side that
i can write that into so it's the handle
both are handles the promise is the
handle that i can write the result into
the future is the side that i can read
the result out of so in the Java API I
think to be consistent with other Java
api's for some reason we collapsed down
the future and promised concepts into a
single object called promise not quite
sure why we did that but you'll see that
I now have a compile error because I'm
returning not a promise of a result but
I'm still just returning a result so
what I need to do is create something
that that will in the future produce the
result and
then we'll be a sink explicitly
asynchronous so I'm going to create a
new promise here and I'm going to use
the promise dot promise method and the
promised up promise method if we look at
it if we look at the signature will see
that it takes a function so because I I
don't want to actually call this code
when the request comes in right so if I
left it like this then it would be
trying to just call this ok and produce
the result immediately instead I need
something that I can call later to
produce that result to fulfill the
promise and be able to get the result
out of the future so so I can't return I
can't just call this this thing and
return the result I have to instead give
it a function that then play can
internally then call that function later
to get the result out of so now I'm
going to use the Java 8 nu lambda syntax
and I'm going to define a little
function in line here whole lot nicer
than the old Java syntax for doing that
but now that is a function that I've
just defined that takes no parameters so
that's the the lambda parameters there
are no parameters and then the function
body returns the result so now
internally play now has a handle so when
the request comes into this method play
now has a handle to something that will
in the future produce the result and so
then when play is ready to to be able to
get that result out it's going to invoke
this function and that function will
produce the result so let's try it out
and let's go change that string so we
can verify that it actually works so hit
refresh and compile and then we should
see ooh action not found that's a i'm
using play two three and that's a bug
gotta love brand new software all right
I definitely have a route
let's try this again ya got always clean
it oh man I'm in a bad state here there
we go there we go alright so don't use
dot zero software right this is play 2
30 wait until 231 okay but we'll see
that it worked wants to compiler figured
out what to do so there we go now I've
got my my controller that's that's now
explicitly asynchronous so that's good
I'm explicitly asynchronous but I'm
still not really non-blocking to be non
blocking you have to have something to
not block on and right now I don't
really have anything to not block on so
good examples of things to not block on
our network i/o is something we cannot
block on and then timeouts or something
we cannot block on messages from actors
there's a number of things out there
that are becoming more commonplace to
not block on but so we need one of those
things so just as an example a way to
not block is with a delayed timeout
basically something that says call this
function in some amount of time so
instead of the promise promise I'm going
to do a promise delay will see there's a
few other parameters here so the second
parameter is the amount of delay and
then i'm going to say do that for time
unit seconds so 45 seconds so it's going
to now wait for five seconds and it
waits probably the wrong way to use in
five seconds it will then invoke this
function that will fulfill that promise
and then return the result so let's
let's go try that out hopefully the
compiler cooperates this time I'm going
to open up the inspect window because we
should be able to once it gets compiled
we should be able to actually see this
five-second delay happen so there we go
looks like it worked you'll see that
there was second and a half of compile
time and then and then the five-second
delay so so let's go back to the code so
now I've got something that's a sink and
non-blocking so I'm explicitly async but
now I have something to not block on so
it's a little bit of trickery here
because
is there in order to have something that
is on a timer triggering at some point
in the future there does have to be a
thread there so there is one thread that
gets used for all of these types of
timeouts inside of the JVM so there is
one thread but I could have a million
requests come into this controller and
all of them for that five seconds are
just going to sit there not using any
threads I'll just have that one timer
thread that's managing all the time outs
so so this is now a sink and
non-blocking so let's go back here and
let's hit this again so there's a five
seconds where my browser is just
spinning so I have an open HTTP request
to my server this is just a standard
HTTP request there is nothing special
the browser has no special knowledge
about this what is actually being
happening on the server to make this a
sink and non-blocking so for that five
seconds the browser wheel is just
spinning it's like hey I haven't
received anything yet I haven't received
anything yet so but on the server side
the request came in that controller
method returned the promise of result
and then the thread for that connection
went away went to somebody else and so
then five seconds later then the delay
is going to kick in it's going to run
that function then we're going to get a
thread back and then we're going to be
able to send that data back so that for
that most of that five seconds there was
actually no thread allocated on the
server side to handle in this request
yeah on the client side I think that
chrome is probably also doing a sink and
non blocking but but that's up to the
actual client to decide how it handles
the actual networking so all of this is
based on Java niño Java niño provides
us an async way to do network I oh so
Nettie is the implementation that play
uses of Java niño and so this is really
what gives us the ability to be a synced
non-blocking so all controllers out of
the box or a synced non-blocking but we
can be explicitly a sink and non
blocking if we have something to not
block on ok I want to stop for a second
and see if there are any questions
before we get more
complicated and more useful yeah go
ahead it's totally up to you what you do
with your futures and promises this is
just a very trivial example but you can
create a promise and then you can have
whatever you want fulfill that promise
so let's say you talk to your dao layer
you pass that promise into your dao
layer and then your dao layer could then
fulfill that promise right so that's one
way you you could do that probably a
better way to do is you'd actually have
a method call to your dao their return a
promise of of some data and then you
would then you'd be able to listen
inside of the controller set up a handle
on that completion and then turn that
into the actual result back and that's
very similar to what we're going to see
in a second streaming yeah there is so
so streaming there's a lot of different
ways to do streaming if i'll try to show
one of them in a little bit which is
either web sockets or service and events
but you can also do comment or sorry not
comment you can also do chunked
responses and you can make those chunked
responses a sink and non blocking as
well so i'm not going to show a chunked
one but there is a good one in the play
documentation that does show how to do
chunked response a sink and unblocking
chunked responses okay so let's let's
make this more useful so so I've done
this delay not very useful let's do
something more useful which is a web
service call so I'm going to win the
request comes in to the server I'm going
to then make another request out from my
server to another server get some data
and then return that data back so let's
write the code for that first so what
I'm going to get back is going to be a F
dot promise of AWS response and we'll
call this jwf and then to do this I'm
going to use the play web service
library so should be to make sure I got
the right one imported yep okay then I'm
going to set the URL to James Ward calm
and then I'm going to make a get request
so if we look at what get that's
actually making a get request we look at
what that returns it's a promise of AWS
response so this is not the actual
response it's a promise to something
that will in the future would give me
the response and so I can't I can't use
this response yet what I really want to
do is just take the response that I get
from James Ward calm and send that back
to the person who's calling this
controller method so to do that we need
to get a little bit functional here so
which is going to impact everybody doing
java 8 programming we're going to have
to learn some functional concepts so so
here's your first one so what I have is
a promise of AWS response I need to
convert that I don't want to just block
on this response from James Ward calm
it's a sink and not blocking I want to
screw that up so instead what I want to
do is I want to transform the thing
inside of the response there's the thing
inside of the promise I want to
transform that thing inside in this case
is WS response into a result okay but I
want to do that without blocking so the
way that we do that is with the map so
what I'm going to do is I'm going to do
my jwf and then I'm going to do a map on
it map what map does is it transforms
things inside of boxes that's all that
map does and so in this case I'm going
to transform that ws response into a
result so the way that I do that is with
a function so map takes a function that
will do the transformation so in this
case that transformation will happen
when I get the response back from James
Ward calm then it's going to run this
map function on that thing and then do
the transformation so I'm actually going
to have two promises here right I have
the promise that I've given play for
this actual request the controller
request and then they have the promise
for James Ward calm and that outer
promise the one that's handling the user
connection that one's not going to be
fulfilled until I fulfill it based on
the request of James Ward calm promise
being fulfilled so in our map function
we're going to use a lambda again and
I'm going to say all right now I have my
and so this is my parameter and then my
body is going to be to return okay and
then I'm going to use that response and
I'm going to get the the body of James
Ward calm and then I just need to return
that so that out the type of this map
function what I actually get out of that
we'll see if IntelliJ tells me a little
bit weird in there but the output of
that map function is a promise of a
result so I've transformed from a
promise of response into a promise of a
result don't ask me why we have a
response and a result object why there
are different things actually I know
what a response is the read side result
is the right side so they're probably
could be a unified api for read and
write but but this is the side we read
the values out of and then the result
that I'm returning is the side we write
the values into okay so that's that's
why they're there okay so let's go try
this out here hopefully the compiler
cooperates and there we go so we just
saw James Ward calm in text form i
didn't set the content type so we see
james ward in text ok so now this was
what we call reactive composition so
I've got a request coming into my place
erver then a request from my place over
to James Ward com I have two requests
and there's some point in time where I'm
just waiting for james ward calm to
respond it's PHP wordpress so it could
be seconds and so i'm waiting for those
few seconds for PHP to respond and so
there's some amount of time where I've
got these two connections which normally
would take two threads and instead I
want to take both of those threads while
I'm just clearly waiting give them to
somebody else and then when the response
comes back from James Ward calm then I'm
going to get the threads back and send
the response back down to the browser so
that's exactly what's happening here
when we make that request ok so there's
there's the code again so questions
about that one speculative retry so
actors would be the right way to do that
to do a speculative retry so when we
talk about actors will get more to to
that sort of thing
so futures are one way to do this
concurrency async stuff actors are
another way that we'll talk about in a
few minutes so let's talk about the
composition though so so most these
requests and one of the big reasons for
reactive is that I want to be able to do
things in parallel so let's actually in
this request make a second request out
in this case to twitter com we'll call
this one twf and now what I need to do
is what I want to do is create a result
that takes both the Twitter response
body and the James Ward response body
and composes these together into a
single result and of course I want the
whole thing to be a sink and
non-blocking so to do this we're going
to have to get a little more functional
so what I'm going to do is I'm going to
take my Twitter future and I'm going to
do a map on that and then inside of that
we're going to do a function so this
will be my Twitter the parameter there
is my Twitter response and then inside
of that the response body then I want to
take my JW future and I want to do a map
on that one and then I'm going to be
able to at the end of it all inside of
these these nested functions I'm going
to be able to let's call this one JW I'm
going to be able to do my Twitter plus
my JW using strings is probably a
horrible example but as you probably
have realized in real-world use case
we'd be using JSON data or some other
structured data and lunging it all
together okay so let's let's so this is
not going to compile how it is and it's
going to take a little bit to explain
why so this is kind of the normal way
that we think about that is all right
I'm going to do a map on my Twitter 1
i'm going to do a map on my JW one and
then imma be able to get both of those
IntelliJ is kind of confused about the
air it says cyclic interferes
interference interesting maybe that's
accurate I don't know what that means
but the problem here is that the output
of JW f map the output of this this
function here
let's move that down these down so we
see things a little bit better I guess
the problem with this is that that jwf
map it outputs the output of that
function is a promise of a result yeah
so that's a promise of a result and so
then if I do this TW t WF map and I in
the body of that function I return
something that's returning a promise of
a result then ultimately I'm going to
return a promise of a promise of a
result okay and I don't want that so
what I want instead is I want to take
that promise of promise of result and
flatten those down into just a single
promise of a result and so then what we
have to do is not a map but a flat map
so so flat map is the way am I missing a
paren yep I am okay so flat map is the
way that we do a map and a flattened and
we do it in that order and I don't know
why we called it flat map I guess
because Matt flat just doesn't roll off
the tongue so we call it flat nap but
really it's a map and then a flattened
flatten is just flattening the those
things out so now what we're returning
is that promise of a result so now we
have these chained functions and it
doesn't matter what order these actually
are defined in in this case because when
the when I'm not actually doing the map
function when i'm not actually calling
the map function it's just memory on the
heap holding the result of that promise
so i'm not actually going to be using a
threads the ordering doesn't doesn't
matter so let's try it out and make sure
it works so what we should see is
twitter com there we go there's twitter
com and text form and then somewhere
down here is going to be James Ward calm
so now I've been able to do that but now
there's three requests and of course all
these are knit a sink and non-blocking
so at some point in time where the
request to twitter is idle the request
to James Ward calm is idle
then I'm going to not be using any
threads right for that so that's that's
where we can get some some high-value
with parallelization without having to
have these expensive threads being used
so you can imagine a more real use case
something that I've actually done is to
do like sediment analysis using some API
on a bunch of things at once and I want
to be able to do as many of those as i
can in parallel so the gating factor on
how many things I can do in parallel is
going to be how many threads I can
allocate but that is for active
connections so if I if I have ten
threads allocated that means I could
have 10 actual active connections open
to some some service that could mean
that i have actually a thousand
connections that are that are open but
most of them all but 10 of them are open
but just sitting idle waiting for a
response okay so that's reactive
composition questions about about that
so the ws API is the outgoing REST API
I'm just working with strings but you
can definitely work with Jason and then
the controller methods also support
Jason so so you'll see one of the things
that we can pass to okay which is the
status code 200 is adjacent node object
so I'm passing just a string but that
you could pass Jason content as well so
both the outgoing through the ws library
and then the controller response is both
support Jason as well there there's
currently a problem with observables and
I'm trying to think if I'm going to
remember correctly there was some
problem with how you use observables and
futures together I believe but when we
talk about reactive streams there's a
solution coming for that problem and
that would be a perfectly acceptable way
to do this with RX java or something
like that so so I know that it's
technically possible reactive streams
will be the right way to do this whole
thing with RX java but but i'll talk
about that in a few minutes good
question so I haven't talked about any
resiliency so there is a
resiliency model on promises and there's
different ways that you can deal with
that so a promise really has three
states it can be pending it can have a
value or it can have the air and then
you can set air handling through
functions like these on the promises so
one of the ways that you can deal with
airs on promises is you do a recover
recover we can actually try that real
quick so if i do a recover i give this
thing a function that's going to recover
from the failure with with a value
anyways and so i'd have to have
something that recovered with the right
value in this case a WS response i won't
actually fill out the code so that's
just one way that we could handle this
failure we could also there's like an on
air handler that we could use and we
could log the air so there's a number of
different ways that we would that we
would do resiliency on the the futures
depending on what you're looking for and
the errors in these futures are going to
propagate so so if i have by default if
i have an error state and one of my
child promises then that will propagate
all the way out so I could catch it on
the out all the way at the end or I
could catch it where it started so up to
you how you would handle that as well
okay so that's reactive composition with
multiple things in parallel let's go
back to a couple slides all these slides
are online freezes jet James Ward calm
and we've gone through that I'm not
going to do the actual the actual demo
but let me just show you what push looks
like and with server sent events in play
we this one doesn't really have anything
Java 8 I think there is employed 23 a
new Java 8 API for server sent events
but server sent events are one-way push
from the server to the client so what it
does with server-side events is it nails
open a connection which is a sink and
non-blocking and then whenever you want
you can call the send data method to
push data down to the browser so pretty
simple API both on the server side and
on the client side for doing that so and
then WebSockets as well
so with a WebSocket we have now two
channels both channels are reactive
reactive push channels so one is from
the client to the server and the other
one is from the server to the client so
i can read values off of on the server i
can read values off of the the channel
coming from the client to the server and
then i can write values into the channel
coming from the server to the client
both of those are a sink and
non-blocking so when i'm not actually
actually there over one connection but
when they're not when we're not actually
sending something over that connection
then it's not going to be using any
thread so pretty simple implementation
you'll see this is a method reference
that i'm using here in java 8 so that's
just calling this is like an echo
WebSocket so when i get a message coming
from the client i'm going to turn around
and write that back to the client and so
I just do a method handle Java a method
handle for that ok so let's spend a few
minutes talking about reactive actors so
actors come from the Erlang days and
there's a few ideas of actors that I
want to highlight and then I'll show
some code so the the actor
implementation that I'm going to be
using is called acha acha is a actor
implementation on the JVM and so there's
a few things that the actor model does
for us one is that it manages our
concurrency for us so you probably have
put synchronized calls in your Java code
before that's one way to manage your
concurrency it's kind of painful way to
do it actors do that for you what they
do the way that they do that is that you
create an actor and there's an actor in
your system but in order to talk that
actor you don't actually use it directly
instead what you do with an actor is you
send it a message and that message goes
into a mailbox and then when we can get
a thread we will then deliver the
message to the actor and then the actor
will process the message and once it's
done processing the message it goes to
sleep it's only using memory on the heat
then it'll be ready to receive another
message but in actors guaranteed to only
process one
sagitta time so now you have an
alternative to the synchronous
synchronized blocks now you have
something that you can guarantee is only
going to be you only going to happen one
at a time so it's helping you manage
your concurrency in a much higher level
construct so we always use that actor
ref for a few other reasons one of the
reasons is that then we have location
transparency so with acha when you send
a message to that actor ref the actual
the actual actor that's going to be
handling a message could actually be
somewhere else on the cluster and you
you can you decide how you want that to
happen or if you want that to happen but
it allows you to have the same construct
for in jbm as well as across jbm so you
can scale up and out and then the other
reason for the actor ref for using a
reference is that if for some reason
that actor dies or goes away it could be
an uncaught exception or the JVM went
down or whatever it may be by working
with that actor ref that actor ref is
always good it's always good to get
messages into the mailbox for that actor
so there will be a queue of messages
building up and it could be that while
working through the messages on that cue
that the extra actually restarts or
moves to a different server or whatever
it may be and the mailbox doesn't go
away and the messages are still going to
be delivered even across those restarts
of the actual actor so it gives us that
transparency or trans ability to not
have to worry about what's happening to
that actual actor implementation so the
last part about actors that you need to
know is that actors are built in trees
so we start with the actor system that's
really the root and then we build up a
tree of actors so what that means is
that actors have children and actors
parent is it supervisor it's the thing
that's responsible for for determining
what happens when the actor fails and
the default supervision strategy is just
to restart the actor but you can build
your own supervision in but this allows
you to contain failure into the the
the branches of your actor system so
that it doesn't propagate up your system
and take down everything so they impart
important parts of actors the only
construct for act for communicating with
actors is to send it a message but
actors can communicate out by sending
messages out to other things so this is
how actors communicate is always through
sending these messages actors can have a
lifetime of either either milliseconds
or of the entire duration that an
application is running or or a single
request by the user so you can have many
actors that have very very different
different lifespans and a typical actor
system may have tens hundreds thousands
even millions of actors in a single in a
single actor system so let's check out
some code and this stuff I'm just going
to copy and paste so I'm going to switch
my my little app here over to using
actors instead of using the the promises
that I've been using so I'm going to
first create here a new Java class and
we'll call this one foo actor put it in
the actors package now I'll just paste
in that and then spend a few minutes
importing things so it's import
hopefully I get all the right ones and
if you may be wondering why there is two
different two different api's if you've
noticed that in these imports see there
is played on a p.i and play dot not API
weirdest naming convention ever it's
French actually plays created by French
guys and so API actually is the Scala
API the non API one is the Java API one
right everyone should have known that
it's obvious so yeah so there we go so
you have to make sure you get the for
using Java make sure you get the right
nan api api in there ok all right so
then i'm going to change my
controller so we've got my actor I'll
show you the code for that in a second
let's go back here and change that
that's an actor ref few more import that
one and let's see props this could be
like a game we play and WS responsive
okay Oh foo actor one more okay so let's
first go look at our actor here so what
I've done is I've created a new untyped
actor an actor the main entry point into
this actor is the on receive method
there is a new Java 8 API and akka for
this and I'm not using the new Java 8
API but it's much more lambda e for
doing this kind of stuff so this one is
just the the standard Java API so I've
got this on receive and it takes an
untyped message so whenever you
communicate with actors it's always an
untyped message and then you can do
pattern matching or something on that
object to figure out what to do and so
in this case I'm just making that
request getting back my promise but then
I need to do something special so I now
I'm doing something a sink and not block
in and I need to win that thing
completes I want to route a message to
the person who sent me this on the other
side of that call right so so I'm going
to cross this async boundary and I want
to preserve the the sender the person
who sent me this and I wanted to not get
that mixed up in in a concurrent program
and so I use this pattern stop pipe in
order to handle that don't have a lot of
time to go into what that's actually
doing but trust me if you're doing
anything a sink and an actor use
patterns pipe ok so now over in our
controller here's where we're actually
creating the actor so I'm going to the
actor system and I'm saying create for
me an actor of the foo actor type and so
this goes off and tells the actor system
to create an instance of that actor but
you'll see what I get back is not the
actor instance but an actor breath the
reference to that thing and now i'm
going to use that actor
to communicate with it so what I'm doing
is here's my my foo actor I'm doing an
ask and the the default way I said that
the only way that you could communicate
with an actor is to send it a message
there's that is true but there's an API
kind of syntactic sugar on top of that
called and asked and it asks sends a
message but then gives me a promise of a
response back it it basically sets up
internally a promise that will be
fulfilled when that actor responds to me
with something else so actors they don't
have to be request response but for some
reason i love request-response stuff so
and then when you do an ask you always
have to specify a time out so i'm
specifying a five second time out okay
so what I get back is a promise of
object from that because these messages
between actors they are object and then
what I'm going to do is is do a map on
that promise and then I'm going to cast
this thing to a WS response and then
just return that so that's now my actor
based implementation let's go refresh it
and what we should see fit all compiles
there's James Ward calm so so there's
James Ward calm now going through the
actor so there's a few benefits to the
actor model we can we can use either
both models there's definitely use cases
for both one of the great use cases for
actors which i haven't mentioned is when
we have mutable state then actors are a
great place to put mutable States you're
going to be guaranteed that only one
threads going to be mutating that state
at a time so so actors are great for
handling mutable state they're also
great for handling things like retries
so what we can do is have a have an
actor that is acting as like this this
kind of manager for retries and for
making sure that we get a response a
very simple example of this is it's very
common that I'll have in my systems an
actor that is going to get some data but
I have both the database and I have a
cash system to get data from or I want
to get it from ideally want to get it
from the cash but if i get a cache miss
and
want to go to the database right and so
so if i have an actor i make a request
to the actor and say hey I need this
data I can actually use a router in acha
to say now send a request to both the
cash actor and the database actor and
there's a router called it's like
scatter gather first complete is the
router so it scatters the messages it
sends them to both of my child actors
and then the first one that gives me a
response back is the one that I actually
end up using the the value that I
actually use so you could use something
like that or there's other routers in
acha as well to create a retry type of
system retries probably have some state
involved like number of retries how many
times I've tried that sort of thing so
an actor becomes a good way to put that
state information and do the retries
yeah so you could definitely create a
acha router that would do have exactly
that behavior there's some
out-of-the-box routers and then you can
write your own custom routers as well so
maybe somebody who's already written one
that that specifically does that but
okay so that's a real quick intro to
actors I want to move on so that I can
talk about reactive streams real quick
and then we'll we'll have a few minutes
for questions so reactive streams what
it is is a new a new project across
collaboration between typesafe Netflix
Twitter and a bunch of other people to
create basically a JVM standard for
doing a sink and non-blocking reactive
streams with back pressure and so there
will be a number of what the what the
reactive steep streams project is is a
reference implementation a specification
a TCK so all the things that somebody
could create an implementation of
reactive streams on top of so the RX
java guys are working on a reactive
streams implementation on top of RX java
there's of course a naka implementation
and there's a finagle and film I think
it's finicky no sorry there's an eddy
vertex got a third time vertex
implementation of reactive streams as
well
so this is a really exciting new project
for being able to do a sink and
non-blocking streams of data with back
pressure so real quick example of back
pressure is if I have an upload coming
from a client to a server and then I'm
just taking those bites and pushing them
to like Amazon s3 or some other service
I really don't want the client to send
more bites than i can send to that next
service because then i'll be building up
giant buffers and and running out of
memory and so i want to be able to put
back pressure on the the producer to say
stop producing so much data or slow down
but i want to be able to do that in a
reactive way traditionally back pressure
has been done in most implementations in
a very synchronous way in a very
blocking way and so reactive streams is
about being able to do that in a non
blocking way so check it out reactive
desk streams org for more information
there is already implementations there's
in typesafe activator there's already
some sample applications to get you
started with reactive streams so check
that out that's that's pretty new and
exciting ok so the time for questions we
have a couple more minutes so in this
case I want to be able to call my
function when I've got the response back
and that's all a sink and non-blocking
for both of them so so when the win the
response comes back from the service it
just sits on the heap until I actually
until I actually need it and so so it's
not actually using a thread no no so
it's not you when it's when it's just
sitting idle it's when I'm not actively
transferring bites over the wire it's
not using network resources it's not
using a thread it's only using memory on
the heat so that was the that was the
whole goal was to get a synced
non-blocking all the way through that
whole chain and not be ever blocking
resources that aren't being used ever so
so that's why I had to nest those there
there is another way to do that that I
didn't show and if I have a bunch of
it's technically the same thing but if I
have a bunch of prom
this is that I want to kind of aggregate
together there's something called
promise sequence or future that sequence
and that takes a list of promises and
then allows me to to have a map function
on the on all of them that then I get
back a list of all of my responses or
all the objects that I get back so so
that would be another way to do it
there's also a zip and a number of other
ways but but anyway you look at as long
as you stick with the map functions and
and a sink and non-blocking constructs
then you will be a synced non-blocking
all the way throughout there will never
be a time when you're blocking resources
unnecessarily so by default promises
don't actually have a concept of a
timeout in them plays web service client
library does and then there's also you
can you can create our promise that does
have a timeout if you just found it on
stack overflow but but so you create a
promise that does have a timeout and
then that would fail and then you would
do a recover with on that to deal with
with the failure with the timeout
failure I can show you code examples of
that if you want afterwards okay all
right well thanks for coming I hope that
was useful I'll be around if you have
other questions thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>