<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • JavaScript at Uber • Dustin Whittle | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • JavaScript at Uber • Dustin Whittle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • JavaScript at Uber • Dustin Whittle</b></h2><h5 class="post__date">2017-08-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IG9gwgUiqZM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much
and so again hello everybody I'm Dustin
Whittle and I'm a developer advocate who
works on ubers developer platform where
I help third-party developers and our
partners build moving experiences and so
I wanted to talk a little bit about the
couple of ways we use JavaScript across
their engineering works I think in order
to properly tell the story you need to
understand a little bit about the scale
on the environment which we grew and
then I'll talk about how we build
back-end micro-services with JavaScript
how we build our front-end web
properties how we visualize data to
understand cities better and then how we
expose an external API for developer
platform and so again as a matter of
housekeeping please ask questions
through the app I'm saving some time at
the end to go through all of them so
please feel free and your feedback is
very much appreciated so please be
relentless and give as much feedback as
possible and so you probably know uber
by now push a button get a ride and so
burrs mission is really to make
transportations reliable as running
water everywhere and for everyone and in
just eight years we've done that we're
actually one of the fastest growing
companies that's ever existed and we're
on six continents in 73 countries and in
more than 470 cities and we've done that
by partnering with more than a million
and a half active driver partners who on
daily deliver more than five million
trips and we did this in under eight
years and last July we completed our two
billions trip and so if you'll indulge
me for just a second we can take a
little bit of a look at the evolution of
the uber app because really this has
been powered by JavaScript underneath so
if you travel back to 2009 this is
pretty much with the uber app look like
you had a map and you had a button that
said pick me up pretty straightforward
pretty bare-bones
and then in 2012 we released another
version of the app that added more
features like location search et A's
estimates and the ability to select
different products like uber pool
uberx uberx et cetera at the bottom and
then last year we released a new version
and it really we refreshed it to add
scheduled rides accelerators for known
location so you can have a one top rides
and then an interactive feed just to
name a few but as you can see the Ebor
app has evolved over time just as the
company in the engineering organization
has evolved as well and so today you can
actually take an uber ride experience
along the way you can play your music
with
and Dora you can see local
recommendations with Foursquare and you
can even order food with ubereats
and much more directly from the Google
app but it's not just rides in cars it's
been choppers and boats too from kitten
sites cream to even Christmas trees
we're not just moving people but we're
moving things as well and the uber
experiences iterated in many ways and
this is really a coming-of-age story
about JavaScript so I'll talk a little
bit about how we got there and so this
is a visualization of New Year's Eve
from 2013 to 2017 and so if you just
look at the this is Singapore and from
on New Year's Eve from 2013 to 2017
every year and so you can see the scale
the growth year over year and in June
2010 we launched our first ride in San
Francisco and by May 2012 we hit a
million rides worldwide and we hit a
billion rides by February 2015 and today
we exist in more than 73 countries and
so just if you look at the scale on the
timeline of this it's really quite fast
and to understand why we use JavaScript
in certain ways and how we've iterated
on it you need to understand the scale
the growth and so we hired a lot of
engineers they wrote a lot of software
and the reality is when you're working
at a hyper-growth engineering company
like uber pretty much looks like this
image you're moving super fast every
week we're launching new cities millions
of people are using our systems in real
time and we can't simply stop our
systems even for a minute to mean for
one minute of maintenance it's kinda
like changing the wheels on the car
driving 80 miles an hour
and so we are organized with programs
and platform teams and so under the
easiest way to think about this is
program teams are built on top of
technology platforms our platform teams
build the technology foundation on which
program teams can build customer-facing
products but we're all product teams
it's just whether the customer is
external or internal developers and so
we invest heavily in building these
platforms that enable developers to
iterate quickly and so building a
platform that interacts with the real
world as a whole nother level of
complexity and opportunity as well
because you can't really control what
happens in the real world the physical
worlds complexity is infinite but we
only have 64 bits and a 500 millisecond
SLA and so there's often things that we
can't really see and that go into the
technology underneath people use our
technology to make money to go where
they need to go and so there's no space
time to pause which is why we
sighs availability and scalability over
all else and so in order to do this we
actually have 15,000 repositories that
power more than the 3400 microservices
that we've released more than 260 of
them back to the open source community
and you probably just know the Hoover
rides after that we've read that but we
actually have more than 10 mobile
applications and more than 250 web
applications and a large piece of this
core technology behind this is
JavaScript and so ears ability to scale
has come from high velocity hard
engineering along with autonomous teams
and domains and so we designed
foundational services that are designed
for high scale and durability and we
focus on developer abstractions that
allow developers to be productive and so
we're a polyglot engineering
organization and we use a few languages
in production and so today we're moving
towards go and Java but again this is
we're coming age story about JavaScript
so I'll talk about sort of how we
evolved and got to the scale with
JavaScript and some of the reasons why
we're migrating in other directions and
so we use Go Java nodejs and Python in
production today and this is really an
order of preference but let's talk about
how it really started it started with
the freedom of choice when you're
growing super fast you're hiring many
engineers you want them to be as
productive as possible as fast as
possible they tend to hire their friends
once you get popular in the open source
world you start to build a community
around your projects and so it becomes
easier to hire people who are
like-minded who are come from your
culture and so originally when we
decided to use JavaScript we realized
that it was a single stack for the front
end of the backend and it made it very
easy to iterate and so again it has a
simple interface of thorough
documentation that makes it quick to
iterate and prototype it's asynchronous
nimble and flexible so it allowed us to
avoid concurrency challenges early on
and also had an increasingly mature
module ecosystem but today we only use
node.js for our web applications and so
why no js' early on if like most great
web companies uber started as a PHP in
my seagull shop it was actually
contracted out with a bunch of comments
in Spanish and then at the time no js'
came along we were very early adopters
and OJ
in fact we prototype the first version
on node 0.2 and we were running node in
production at 0.4 and so it's iterated
along it's come a long way since then at
one point more money move through the
ubers app and our new JSF and any other
new door JavaScript app in the world
until recently PayPal migrated to node
so they've sort of surpassed us but why
node node has a few core strengths that
lend itself well for our use case first
it handles asynchronous i/o with a
non-blocking single threaded event loop
that's particularly well-suited for
building distributed services that make
many Network calls underneath and nodejs
and more javascript in general is
excellent for quick iteration again easy
to prototype something and then to
iterate on it with a large team and then
three it has a great module ecosystem
you don't have to build all the
components yourself there's already a
large community there that you can build
on top of a talent pool to hire from as
well as existing modules for common use
cases and so throughout this talk we'll
talk about four ways in which we're
using JavaScript today on our
marketplace platform to provide the core
services underneath again we have an
architecture that consists of more than
3400 microservices a hundred of those
pertain to the core trip flow so just
pushing a button and getting a ride from
A to B is a hundred services topping
underneath and then we'll talk a little
bit about our web platform and how we
build front-end properties with react
and Express and then how we better
understand cities by visualizing data
and then finally talking about how
anyone can build applications through
our developer platform but we're invest
heavily in developer productivity and so
we've invested in a bunch of different
things and a bunch of different platform
teams that make it easy for developers
to be successful from their first day at
Hoover and so it really starts with the
core infrastructure this is our compute
network storage our cloud environments
or on-prem environments and it abstracts
this away so that developers can focus
on making magic and then we have our
developer experience team that this is
really focused on the developer tool
chain so how easy is it to build an app
and deploy production and then as you
need to as you add dependencies as you
need to understand interact with other
services we have our marketplace
platform this is the single gateway to
all the 3,400 micro services underneath
and then on top of that we have our
external components we have a web
platform team that maintains a
performant secure reliable web
foundation we have our mobile platform
team that's focused on enabling
thousands of mobile developers to build
world-class performant applications and
then we have our developer platform team
that focuses on exposing all this
functionality to the outside world and
so we have this cultural value to let
builders build and this really means to
not block people to give them the tools
they need to be successful and so when
you want to launch a new service in this
case a javascript micro service at uber
you send a proposal with a request for
comments the entire engineering work it
gives you a basic outline of what you
want to build the timeline associated
with it any security concerns and any
operational concerns and then you start
with scaffolding with this purpose built
around our staff so we solve a ton of
problems for you and if you use our art
we want to make our tools so good that
you'd be foolish to use any other tool
and so by building the best possible
tools you get the widest option because
it's the easiest that allows you to be
the most productive and then you deploy
with standardized infrastructure and so
we use playbooks to operate
operationalize our teams at scale and
I'll talk a little bit about this later
but if you think about what it takes to
build a web application that's user
facing today a lot of this is more than
just the JavaScript interface it's how
do you handle assets and an edge cash
how do you handle communications
internally whether that's through HTTP
or thrifty channel whatever how do you
manage translations internationalization
data network compute storage the list
goes on and on and so I'm not going to
talk about any of that today I'm going
to talk about how we build on top of it
and so our marketplace platform at its
core is pretty straightforward we have a
iOS and Android application that talks
to an HTTP endpoint or series of HTTP
endpoints that talk to underlying
services and at a really high level the
services look like this you have supply
you have demand you have authentication
the ability to match supply and demand
pricing etc but realistically it looks a
lot like this again we have more than
3,400 micro services that build the
ubers engineering
that's right and so this is one of the
things I'll talk about shortly which is
how do you figure out which service does
what when it's complicated how do you
get visibility into performance problems
and distributed applications and so
again our marketplace API is really the
single API that external applications
talk to and that's as the Gateway to the
more than 3400 underlying micro services
and so we expose over a thousand HD
endpoints that make it easy for third
parties sorry for our program teams to
build on top of but also it's a single
place to for monitoring and
documentation to make it easy to
discover services and understand how to
use them and so ultimately the
marketplace gateway is really just with
advanced traveling salesman problem with
logistics problem how do you map supply
and demand how do you make it an
efficient marketplace how do you
maximize the number of trips but also
minimize the wait times for riders and
for drivers and so if you think about
over pool running in a cities complex
traveling salesman problem and so look
at dive into some specifics about how we
scaled with node in just a second but to
understand this take a look at our
timeline in 2009 we started with PHP my
sequel around this time
2010 is when node came out and started
to get popular adoption we started to
move towards node J s mom's going to be
at the time is web scale and turns out
that's not really true
and so we migrated to it and away from
it we started to replace it with things
like Redis we started to migrate to my
sequel because we're originally on
Postgres and we sort of maxed out our
ability or right throughput on Postgres
at the time and then we started to write
our own data store which is schema list
built on top of my sequel and then as of
recently there's been a large push to
sort of standardize on go in Java but
let's talk about how we got here from
JavaScript so monoliths aren't
necessarily bad well they're not that at
first but they quickly turn into a ball
of mud and so monoliths really optimized
for developer velocity of early stage
projects when a single team owns it and
it consolidates all your operational
overhead into a single place there's
only one application to deploy one
codebase to maintain and the
microservices are a thing but
micro-services are really just the thing
that's focused on only one thing
one thing doesn't mean one API means one
business domain and so as we started to
break apart break apart our monolith and
create many micro-services we learned a
few things along the way
one it gives clear ownership boundaries
if there's a single team that owns a
single business domain you can map that
to individual services there's one team
determines authentication and identity
so they own the authentication identity
services most of the time it also gave
us product specific velocity again when
you're growing super fast you're hiring
all these new engineers where the
average engineers less than six months
at the company and you really want to
make it very easy for them to move at
their own pace
you don't want legacy foundational
services blocking the product
development of a new product and so it
allows the move allows us to move the
business faster and it gives teams
independent velocity those also solve
scaling issues not only internal systems
but also the company how do you group
people together and then it gives us the
ability to consolidate training
documentation and our tooling underneath
but ultimately gave the team's language
language and platform independence and
this is a large part about how we
started to adopt node it wasn't some
mandate that came down from some
executive team it was literally
engineers like JavaScript node signature
enough to solve the problem at the time
we had a bunch of talent that was
familiar with javascript in the node
ecosystem and so the team just sort of
organically grew from there
but as the team goes from hundreds to
thousands to multiple thousands you
really need to start to standardize and
so that's really what we started to do
is say okay we have a preferred set of
languages but you can use any tool you
want for the job but also gave us
reliability of the system as a whole
each service is independent each service
is scalable and each service is
independently testable so there's some
bad that comes with the good one it's
increased complexity to your point when
you're looking at a high level version
of it it looks like spaghetti so how do
you do discovery of when you have this
many services how do you name them early
on engineers are creative people they
tend to name things interesting we give
things interesting names and they don't
ever have anything to do with the
service so the authentication service
isn't called the authentication service
something very different and so how do
you map that to the stuff underneath you
need to be able to do discovery much
easy much
more consistently eventual consistently
becomes a problem eventual consistency
ultimately becomes a problem because
your data no longer lives in a single
place it's spread out across many
databases across many services and then
distributed tracing when you start to
run into performance problems how do you
figure out the root cause of the
performance problem and so we built some
tools to help alleviate some of these
issues and then obviously there's the
operational overhead for every service
you need to monitor you need to deploy
you need to instrument it and you need
to make sure it's secure and so every
time you add a new service if you're
doing this with independent tools and
you start to have to duplicate all this
operational overhead and the last thing
is it ends up being with repeated code
and repeated effort and so when you have
any teams honey make sure there's not
multiple teams and an engineering order
of thousands of people building the same
types of services and so Martin Fowler
has this great graph that shows for less
complex systems that extra effort
required to use a micro service
architecture outweighs its benefits but
once the problem becomes more complex
and the team size increases and the
benefits outweigh the risk
and so choosing a micro service
architecture largely depends on the
complexity of your application the
complexity of your team and there is no
golden rule and so one of the ways that
we ended up scaling our node
applications was by solving a few
different problems one how do you do
application level starting and we use
our at least we used to use Google's s2
library to shard the entire world so the
googles s2 library basically takes a
sphere and breaks it down into different
regions and so from those regions we can
start to shard our database or
applications based on geographies around
the world and so the problem with this
is when you're scaling applications that
do real-time requests that are specific
to a geolocation
you have surges in demand something like
in New York City the peak demand is not
going to be the same as an Amsterdam or
in Singapore or in San Francisco so how
do you shard that environment and so one
of the first tools that we wrote nodejs
to help us scale applications was Ring
Pop Ring Pop provides application level
charting and so allows you to bring
distribute cooperation coordination to
services but really it's a string on top
of a membership protocol that allows you
to choose either this instance of our
application can handle the request or I
need to forward it to the appropriate
instance they can and so it looks a lot
like this for every node instance you're
running you rung a Ring Pop client and
this ring pop plant can understand which
requests this instance can service so I
can handle requests for this particular
location or for this particular service
and so this allows us to easily decide
how we wanted to shard the backend but
manage it all at the application level
and so ring pops is written in nodejs
and we have clients for a variety of
languages one of the next things we
learned is that making requests an HTTP
was really built for a world and what
you're connecting from a browser a
client to a server but when you're
making server to server requests HTTP is
expensive and so there's a more
efficient way to communicate between
these back-end micro services and so at
the time thrift existed from Facebook
but it didn't have the language support
that we needed at the time and so we
wrote T channel and so T channel was a
RPC protocol that allows us to make a
very efficient request to the back-end
services and so T channels available
multiple languages but this is how we
actually communicate under in our
underlying micro service architecture
and then one of the lost tools that we
built for nodejs
was Jager and so Yeager's really build
was originally built on twitter Zipkin
and it provides distributed transaction
tracing for complex distribute apps and
so when you're looking at a complex
application you want to figure out where
the performance problem is you want to
have visibility into the underlying
calls so you can start to see where the
hotspots in the performance the root
cause of performance problems lie and so
a large part of what we did was figure
out how to make bring observability to
our distributed services and so we did
that through few different ways by
instrumenting t channel by using Jager
to visualize and Jager client to
instrument the underlying services and
we scaled out our node applications
using green pop and so there's great
engineering write-ups on our engineering
blog about each one of these services I
don't have too much time and there's a
lot of content but I'll follow up with
the slides at the end and so ultimately
note is just a thin wrapper around
C++ it's a thin scripting layer around
C++ and so all the Linux performance
tools you're used to just work and so it
was also built on top of those so
whether it's using node building node
flames of CPU flame graphs with P trace
you can still just use all the normal
performance tools you'd like to figure
out performance problems in your
applications and so the reason I like to
point the cell is that you should learn
how to profile applications on Linux and
then you should figure out how you get
visibility into those distributed
applications there is no silver bullet
and so we learned a couple of different
lessons and when we started with node
performance wasn't as big of a concern
as it is today but since we've migrated
to all the are we started migrating all
of our course services we realized that
the latency is too high for ultra
performant back-end systems again we
adopted earlier versions of nodes so a
lot of this has changed in time but when
you have dynamic typing dynamic garbage
collection all of a sudden the
performance isn't as predictable as it
is with other languages and so the p99
format latency started to become a
problem it wasn't about the average
latency for the request it was about
that one request that takes a lot of
time and so early on it made it very
quick to iterate but as the size of the
team scale the developer velocity
started to slow down and a team of five
people is very easy to develop but as
you add a hundred or even five hundred
committing to the same codebase
things start to break down again using
micro services gives us flexibility and
makes everything independent but it also
requires me to have a tight interface
between the different language but we
need services so if you rename a field
in one place now all the dependencies
need to adopt that and so again micro
services require a tight interface and
by using languages that support static
typing you're able to enforce that much
earlier in the process and so when you
have large development teams
contributing that starts to really have
an impact at over 100 developers and so
it allows us to catch issues at Build
time rather than at run time and again
hiring it was quick to learn but it was
easy to write poor quality code it
allows you to move fast but it also
allows you to be sloppy in the process
and so one of the nice things is the you
can write performant high-quality
JavaScript code but that takes
experience and when you're hiring people
there
very quickly even when they're amazing
sharp people they didn't learn node and
they don't know the pitfalls of common
design patterns with node they're
focused on getting stuff done and so you
want to make it safe for developers to
build things quickly and nodejs
sometimes a lot of people to be sloppy
how many people remember the library
that took down the internet because
somebody got annoyed that somebody
wanted to rename their package so
there's a great ecosystem of small
libraries in nodejs but there are some
issues that go with that a lot of them
were immature compared to their suits
Java or go counterparts a good example
this is the nude HTTP client and so the
go version is 10 times faster but it's
purely the implementation if it was
written in C++ it would be much much
better implemented and so while you have
this great ecosystem of small library
sometimes the libraries are too small
sometimes the dependency chain isn't
necessarily clear and so you have issues
where left pad can take down the
Internet
and then ultimately don't be afraid of
writing C++ so also again it's just a
small scripting layer so sometimes when
you need more performance the right
thing to do is just go a level down and
then write bindings that expose that
functionality to your language and I
think oftentimes people don't
necessarily think they should do that
but there's there's nothing wrong with
that and parts of our core services are
written that way and so again just to
recap some of the lessons that we learn
HTH a song was designed for browsers
using RPC with T channel and thrift is
much better form for a computer to
computer request when you're just
microservices communicating between each
other it's much more efficient to talk
via binary wire protocol this one comes
down to scaling with large teams after
certain age micro-services should become
immutable at some point it's easier to
ask people to move to a new service and
it is to ask them to change all the
interfaces that connect to that service
and so we have this idea that after a
period of time a service can't change
that we will release a new service that
replaces that functionality and having
multiple language allows 14 preferences
but it also serves as a great developers
based on their culture and it starts to
eliminate the ease of use of reusing
code
people on teams allowing teams to move
around the company and so this is some
issues we'll just adjust that for
everybody okay performance problems are
difficult to debug when you have these
complex distributed applications with
thousands of services so we had to
invest heavily in standardized
dashboards to give you meaningful
information and observability tools that
allow you to get to the root cause of
these performance problems like Lethe
ager and long and should never slow down
production if anything wrong should be
drop rather than delay the next request
but all of these decisions are
architecture decisions that are just
trade-offs it's easy when you're growing
very fast to go with the moment to let
the momentum carry you but oftentimes
you need to step back and be intentional
with these decisions and so a lot of
these lessons come because nobody's
stepped back and made intentional
decisions Engineers just build things to
survive to be able to scale so things
weren't falling over and so I think the
salient point and so the next way we use
JavaScript is really with our web
platform our web platform today is based
on react and express the much of open
source tools that you've probably seen
the various properties whether it's uber
calm and checking out for a ride if
you're interested in self-driving cars
or advanced technologies group uber
afraid to book a load and a button book
a load signing up to riding any
estimates ordering food movie packages
or things around town and managing your
business visualizing data for city
governments and my favorite website that
we personally maintain is developed over
comm where we empower third parties to
build moving experiences but the reason
I show all those we have more than 250
web applications that we have to
maintain and without a consistent
foundation all these applications would
have building built off entirely
different tools and different
architectures which creates a higher
likelihood that they're going to have
problems so that security vulnerability
and or just duplicated effort across
teams which you start to realize
investing in platform solves these
problems and so you'll notice the theme
is that we invest in these technology
platforms it allows developers to use a
standardized staff that's purpose-built
for our tools and so let's talk a little
bit about how we did that for our web
platform so to high-level our web
platforms
built on nodejs and npm like all the
JavaScript applications and we use
Express as it's a lightweight framework
that we've extend with a bunch of
middlewares
and on the client side we use reacting
read ups pretty straightforward now this
is particularly cutting-edge I think
this is a pretty standard open source
stack these days and so we use internet
sinha proxy for front-end web servers
and load balancers use NPM to manage our
packages Babel so we can use the latest
generation JavaScript Express so we have
a lightweight web framework react for UI
rendering Redux for state management and
then a bunch of tools that are built on
top of gulp that allow us to have a
consistent build and deploy pipeline and
standardize builds when across all these
applications and so for the most part
most of these applications are built
using the same stack and it comes with
some other special sauce that we need to
add on top that's a that makes it
purpose-built for our stack one we need
an internal NPM registries for private
package management and then hashing and
basically better resiliency so we don't
get blocked by deploy issues and when
you have a large team you want to make
it very easy to scaffold new projects so
we have our own equivalent to vo man
that allows us to bootstrap new
applications with these best practices
built-in I don't want to have to spend a
day configuring express to use all these
middlewares I just want to create a new
project that's ready to go and then we
customized our middle customized Express
with a bunch of middlewares that allow
us to handle standardized authentication
handle security issues like XSS cross
cross site request forgeries and content
security policy on the front end without
having to be a lot of work it should be
baked in by default and then handling
metrics logging internationalization
errors instrumentation analytics should
just be something you get by building on
top of our framework and so our
framework now only uses Express but we
extend Express to be built around all
our internal tools the libraries we use
for translations libraries we use for
our analytics pipeline etc and that's on
the server side but we have the same
thing on the client side so if you want
to quickly build applications you want a
UI component library that makes it easy
to try a build drag and drop components
and so we built the library on top of
jas and then again we don't use HTTP for
everything so we have our own I RPC
library on the client-side that allows
us to intelligently use HTTP or Qi
Channel or whatever way your service is
actually as communicating and then
finally shared build build tooling for
powered by gulp that allows us to have
hot reloading use the latest versions of
JavaScript and they make it easy to
deploy assets and deploy our
applications and do it in a consistent
way with standardized testing and
standardized code styles through lint
and yeah and then universal rendering
for the server and client I think this
is again one of the biggest reasons we
continue to use node.js today is it
allows us to write the same code on the
client side as the server side and
allows us to use isomorphic rendering to
provide the same views whether it's
front-end or back-end but we go a step
further than that and not just in
exposing a front-end client that's
wasn't written in react and a back-end
service and threatening new JFS we
actually separate our front-end services
those that serve the web pages or at
least the shells of the pages from our
back-end services those that interface
with the underlying microservices and
provide data to those who use and so
there's a couple of different reasons
for this one the services could take
advantage of the universal rendering and
tooling so everything just works out of
the box but you can also better utilize
languages for specific use case so if
you want to implement certain services
and go in the backend you can do that
and then you can just talk to them via
node and expose that in JavaScript on
the front-end it also allows you to
deploy and scale your services
separately and finally you can reuse
those back-end services for more things
like a mobile client or for our external
API and so if you take a look at what
our architecture looks like I have to
adjust this to make some people happy
but at a high level this is what the
architecture looks like in the client
side again it's a react application
inside of that we have a set of
standardized react components and then
we use redux for statements meant along
the way we have our own RPC library
underneath it handles talking to these
back-end services and then we have our
back our back-end application server
which is just the proxy from nginx and
ha proxy and then we have our
application server the application
server has a standing assets pipeline as
it's really just offloads things to a
CDN we have a way to route requests to
the underlying patent services and then
we have the actual pages that get served
to the browser and then along there we
also have ways to do isomorphic
rendering as well as a way to have a
shared routing mechanism between the
front end in the backend as well with
react router and then so one of the
things that we focus on is these react
components to make it easy to have
standardized UI's without having to
write all the code yourself so most
people are familiar with bootstrappers
herbs foundation this is our equivalent
built on top of react and so we liked it
because it allows us to if you saw all
those websites I personally think they
all look very good and that's not
because they had a dedicated designer on
each team who like made everything pixel
perfect it's because they had the
standardized tooling it made it look
good out of the box and so that's one of
the reasons that we have these react
components they're really optimized for
performance and they encapsulate the
style so that over the wire they're as
light as possible but they also have
analytics instrumentation bacon if I
click on a form element I don't want it
to track the redux the state and when
they type in some data and pass that
along I want to be able to intercept
those events and have them automatically
passed to our analytics pipeline and so
by having all the stuff built into the
front-end it just makes it easy to do
out-of-the-box and then as brands change
over time which they eventually do it
makes it easy to get seamless upgrades
to new versions and so we believe
heavily in writing CSS and JavaScript
and this is for a few reasons one is
because it's ultra performant you can
only ever serve the CSS that's actually
being used on the page and you don't
have to handle with that runtime and so
we try to enjoy we use one of the
engineers on our web platform team who
actually wrote style tron outside of
uber and then we adopted it on our team
as well and we started to use it
internally so all of our CSS is powered
by style Tron and the latest generation
of our web platform and this makes it
easy to manage all styles in one place
you have one file one react component
one thing to edit you don't have to
track libraries across libraries to
figure
how to make something - how to make
something look different and so one of
my favorite ways that we use javascript
is actually in data visualizations and
so this is one of the most powerful ways
that we use JavaScript today and so this
is a day in the life of San Francisco
and so if you take a look at this
visualization this is actually powered
by def GL which is a WebGL framework
we've released and allows us to
understand how cities work we one of the
our cultural values values is to
celebrate cities and what you start to
understand is that every city is very
unique but in order to understand how it
works you need to be able to visualize
it and so we've invested heavily these
digitalization frameworks to allow us to
do that and so you can check these out a
little bit later but I'll talk through
them quickly now we have reacted is this
is a charting library that basically
maps to react components and so if
you're used to building excellent charts
with d3 this is a react interface to do
that with standardized components for
various charts most of the maps that you
see on our website and in our
applications it is powered by react map
GL and so if you know map offices GL
library this is just a react interface
to that and then one of my favorite
libraries is deck GL which allows you to
use millions of data points and to
visualize them in the hyper formal way
and so really it's built on top of WebGL
- and it's a layered approach for
visualizing data and then we also
released luma GL and so luma GL simple
interface to WebGL actually standard
interface using X script 6 - WebGL -
that also deals with some 64-bit
precision ok so react vis again fancy
charts very easy through react interface
you can check out more at at JavaScript
our uber github bio slash node web and
so it gives you a composable
visualization system but really makes it
easy to render charts whether it's line
area bar charts heat maps scatter plots
sunburst and tree maps and so every
different chart and visualization you
can imagine it's supported by react is
and so some of the ways that we use this
today are to again understanding health
cities flow and so what you're looking
at is
an interactive map of New York as you
mouse over you can see the pickup and
drop off locations from a particular
point and so if you're a city manager
trying to understand where supply needs
to be in a city over time and where
people get dropped off this makes it
very easy to understand that information
this is another visualization that shows
density in New York and so this makes it
easy to understand
over time what it pickups and drop-offs
to look like in certain locations and so
again all of these visualizations are
powered by debt TL and debt feels really
designed to make visualization of large
datasets extremely simple and so when
you're it's easy to visualize a couple
thousand thousand pieces of information
it's much more complex to visualize in
real time millions of pieces of
information and so using layering and
instant thing we're able to provide high
performance like you've seen previously
and then luma GL luma GL just makes it
very easy to interact with WebGL so it's
a modern interface for dealing with
WebGL and the component base platform at
handles 64-bit precision which we need
for the degree of mapping that we do and
it also provides a better way to handle
errors in WebGL and so you can check out
more GL one of the best examples I think
they have is when mapping yellow cabs
for screen caps over the course of the
day and so sadly I don't think this
animation is playing but what you can
see is Manhattan rendered in 3d and then
the traffic flows across the real cities
all done in real time using millions of
data points and so this is actually
quite an impressive feat to be able to
do in JavaScript and have it be
high-performing and so all this is
available as open source and we're
completely open to pull requests in the
community so feel free to check it out
and follow up and again this is one more
visualization that shows over the period
of 24 hours what drop-offs look like in
San Francisco in the Bay Area and so one
of the biggest ways that we use Javas
for today is to get in visualize cities
so that we understand how to most
efficiently work in a city and most of
this is powered via JavaScript and all
the libraries that talk about today are
all open source and available on uber
by oh and so the last place that we use
javascript is through our developer
platform and so we want teams - we want
third parties to be able to build moving
experiences whether it's offering
on-demand rise or doing on-demand
delivery we expose all these 3400 micro
services as for the business domain
objects and we make it very easy to
interact with them via our node SDK so
if you want to be able to offer
on-demand rise inside of your
applications or to be able to plug
directly into the uber trip to create a
custom experience you can very easily do
that through our node SDK and so again
almost all this is powered by open
source tools and so we very heavily
contribute back to the community and not
only the tools that we use and there are
presence on github but also through our
engineering blog and so you're right
tons of tutorials that go very deep and
how to use some of these tools and sort
of why we built them and so if we're
talk like this I wanted to go very quick
at a high level through many of the
tools but the best way to follow up is
through the deep dives that live in our
engineering world and so if you're
interested in some of the nude back-end
pools you can go to github.com slash
uber nude and so this is really focused
on all the open source packing tools to
build node.js applications the things I
talked about earlier things like Ring
Pop and Jager and Qi Channel and then
you can go to github.com / uber web for
some of our web front-end properties web
tools and like our standardized Lent
rules for having consistent code and
then all the other sort of
visualizations that you have and then
again finally is our uber engineering
blog uber inch and super calm and we
dive into all of these tools and through
in-depth write-up so the best place I
think for every tool that I've mentioned
we have wall secure very deep into them
so I think that's a great place to dive
in and so we want to build an open
platform for building moving experiences
not only using our tools but also you
know by providing the data that we that
we use to build a great service and we
want to expose that for third parties
and so what future will you build all of
these tools all of this talk is built
from people way smarter than myself I
just get to be the person that
represents it
this comes from you know thousands of
engineers working on all these tools and
so a lot of the credit for this talk
goes to the many smart people at uber
and if you want to join the team we have
offices in Amsterdam and San Francisco
around the world so feel free to follow
up and there's some great talks that I
also recommend as well and with that I
would like to open it up for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>