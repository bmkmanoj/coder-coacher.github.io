<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Continuous Deployment for a Billion Dollar Order System • Steve Smith | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Continuous Deployment for a Billion Dollar Order System • Steve Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Continuous Deployment for a Billion Dollar Order System • Steve Smith</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U4vTuH9OQak" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name's Steve Smith from atlassian
that is not particularly important
although I will touch on some of our
stuff towards the end this is really
about our internal journey towards
continuous deployment and really about
you know this isn't a theory this is
this is practice this is how did we get
a billion-dollar order system into the
state where we continuous deployment
deployed and how do we actually do that
at the nuts and bolts low level so that
my background is I was less ian was over
over nine years now I was the original
sysadmin in the company I was then moved
into the internal systems team which
built the ordering system and I now work
with out of Europe working on developer
advocacy which is partly development
partly doing cool stuff like this say
eating big lunches and getting free beer
in the afternoons so the background to
this is I thought like this is a
billion-dollar ordering system now
that's largely just a hook to get you in
here and it seems to work pretty well we
will get to a billion dollars it's not
what you think it is well it's not it's
not as nice as having a billion dollars
anyway so this is the Lassen ordering
system this is how if you've ever bought
jira confluence any of our tools this is
what you probably interact with I am
genuinely sorry I built a lot of this at
a lot of it is a kind of clunky in a bit
slow is a reason it's slow which is that
it has a billion dollars password now
the background to this is we built our
own ordering system this is one of those
things they say for historical reasons
which is really a cold phrase for it
seemed like a good idea at a time and
now they're kind of stuck with it the
ordering system was built because
nothing really matched our business
model at the time atlassian at the time
was quite an in unique business model we
built her own ordering system didn't
take very long and it kind of snowballed
from there to now it's like one of the
most critical systems in the company and
it's got a little bit out of control but
it does actually work surprisingly well
this is what a billion dollars looks
like which is a surprisingly under well
whelming when you go and Google for this
on the Internet
I'd like to have it but it's not quite
the the bank vault I expect it was going
to be so a billion dollars when I talk
about this is not a billion dollars in
Alaskans bank account billing does pass
through it but some of that is text some
of its refunds some of it evaluations
get paid back all sorts of things go
back so forward but it doesn't matter
money coming in and money going out just
as important particular when you've got
regulatory requirements and expect you
to make all that add up at the end of
the day so the billion-dollar all the
system is how much pass through that
system and I was just discovered that by
accident because I'm triaging some
problem with the system and did a little
some on the table and realize we
basically just crossed a billion dollars
that's about a year and a half ago now
so it actually well we'll be on that now
doesn't mean it'll ask it has a billion
dollars in the bank account or anything
like that it's just a little indicator
of the Creator how critical this system
has become so because at this point a
failure of our system is a failure of
the business down time for this is now
critical down times this means scotton
Mike the founders come and breathe down
my neck personally or it did I got out I
team now and now I eat big big big
lunches which is quite nice so this is a
story of how we tried to make this a
little bit more robust but also to then
use continuous delivery to do that
continuous deployment because this isn't
like that becomes less than agile
becomes sort of fragile becomes somewhat
you know like that tree it's old its
cool it but it's also it works but it's
also you know an s of issues so in a
business is growing a lesson is growing
and want to continue to grow needs to be
agile and needed to be able to adapt to
changing market conditions new
competitors new products entering our
team's new product products entering
other companies teens we need to react
to and we need to be agile we need be
able to change pricing me to be able to
change products quite quickly and
release them very quickly but at this
point the system becomes somewhat
monolithic and was very very very very
hard to roots release when we start the
team it's two people developing this
it's now something like 40 or 60 people
on that team and so that the the rate of
development can increased but that was
causing more problems to be introduced
as we grew
so one thing to do is right break it
into smaller services we wanted to add
new pricing models etc etc but we were
doing at least once a week which means
that each release was getting more and
more changes into it which meant the
chances of any given release causing
breakages was quite high so the decision
was made that we would go towards a
continuous model now we say continuous
deployment and I'll cover what that
really means but really it's about
getting changes out there much faster
but more importantly in smaller chunks
the smaller chunks you get out there the
more control you have over a given
breakage the more easy it is to identify
and I'll talk about some of the benefits
of them this model in a bid when I
define it and talk about some the
stakeholders and you know what's going
on this is clearly going to be a hard
problem we're taking a monolithic or
near a monolithic system has been built
over about eight years and turning it
into something that's a be continuous
deployed and deployed multiple times a
day and it was going to be hard but just
because something's hard doesn't mean
you shouldn't do it in fact if it's hard
to do it more often which is one of the
ideas behind continuous deployment a
good to use integration and really
continues everything and agile itself so
we took it on I was given the job of
doing this because I the sysadmin and
developer so I was like Steve you must
know about this stuff there you go
and so we took that on me and pay with
one of the sysadmin team and we
basically decided that works out how to
patch this out and then as we ever came
on to putting more and more people to
get this done but that's the sort of the
meta picture will drill more down into
some of the ideas in there as I go along
but let's start at the beginning let's
start with an idea of what is continuous
anything was continuous deliveries
continuous deployment so my uncle works
is a consultant to the sort of top
London restaurants and I asked him how
often do you guys deliver I have
curiosity around this how many hell how
many meals do you do how many covers
they call it mute and someone someone
sit together at a place service and
getting fed food how many covers a
moderately busy restaurant will do 150
to 200 covers a day and we're pretty
smug that we r do
we're delivering like maybe twice a day
so this is actually how the world works
most places continuously deliver most
ladies working just in time did all of
these chefs are they are cooperating
shouting at each other the weights are
shouting at the maitre d maitre d
shouting the waiters the chefs are
shouting in the maitre d but they are
communicating that I getting the job
done and they are doing it doing it in a
way that is transparent to the people on
the floor who are just eating this food
so this is the normal we think we're
pretty clever so would not there's
nothing special about what we're doing
in many ways we just need to adjust our
expectations and the way that we work so
let's review a little bit about what we
were talking about when will my
continuous deployment or continuous
everything the quick recap because they
are important because when you should
look look at them together all the ideas
behind it together a pattern starts to
emerge so in the beginning there was
continuous integration well before that
where there was extreme programming a
stream provo programming did something
that the time was pretty radical which
was to say let's build a software every
day this was like this was 10 years 15
years ago this wasn't that far ago with
people literally worked for nine months
and then did a build at the end and
realized none of the compiler worked
together and spend the next three months
trying to get the thing into a state
where he eventually you know release it
the idea that would build a software
every day this is new days before we had
test-driven development or even the idea
of testing was a fairly radical idea
this is around the early j unit days but
the idea that you actually do this
continuously was a new idea of course
nowadays we're not talking about once a
day ideally we're talking about we will
do a build on a test on every commit and
we'll also do a build and test on every
commit on every branch that is active
currently and when I say test I'm
talking the full release sweet this
could take like up to an hour to run we
be paralyzed it quite a lot of Couture
Matt down quite a lot by chucking a lot
more hardware and actually AWS instances
at the the problem but we do every we
always build everything we always
test everything because if there's a
problem being introduced into the system
we want to find out about as soon as
possible before we actually turn it into
a release and I'll show you how when
always we do that in a little bit as
well so from there you got continuous
delivery continuous delivery is an
incremental change in front but beyond
that which is to say that if you're
running all these tests all the time and
you start to trust your test and you
have a commitment to never turn the
system into a state where it can't be
released then this is a goal in itself
it doesn't mean actually doing delivery
all the time what it means is we're
going to keep our tree in the state that
is not broken at any point and somebody
went released now you go okay we can do
do that it's passing the test if it's
passing the test then we have got a high
degree of confidence that is ready to go
out so say it doesn't mean actually
doing so but its commitment to never
breaking the systems again this is
actually fairly new idea it's been quite
hard to do up until recently when you
bring in DV CSS or you know modern
version control systems where you can
have much more isolation between streams
of work again I'll show you a bit about
how we how we do this and how we use the
development model but this is really
just about saying we're not gonna you
never been put your main release branch
into a state where it's broken you're
never going to have a half-built feature
you're going to only merge into that
main branch what is ready to go out so
from there obviously the next step is
well if we can do that we fear ethically
could do a lot of release at any point
why don't we now how often that release
occurs and how much have bigger changes
are in those releases entirely up to the
organization what your goals are but our
ultimate goal is I'm not so entirely
there yet is to be but every release
every unique feature that gets merged
with results in a release it's a very
powerful idea it sounds pretty extreme
but it's actually a massive improvement
over the normal way of doing things
because it gives you much more
fine-grained control over what is going
out it also gives you a lot much better
debugging capabilities bloodsucker on
that in a bit but the theme that runs
through all of these it is about what
quality it's a commitment
to having testing and in particular it's
a commitment to having automated testing
if you can basically press a button and
then go I have a high degree of
confidence that what is going to come
out of this process will be not broken
will be relatively feature complete be
something that I'm not going to be
ashamed to throw out there you're pretty
much ready to go say this is about
quality at at its core there's also the
question in a very reasonable question
of why bother at all I can only if it'll
every organization has their own goals
and requirements and business drivers
and all the rest so there's gonna be
different reasons I can just give you
ours and they were clear to us it's
important to have a clear idea why
you're doing this luckily that's not too
hard to do because you'll find people
push back and I'll talk about that as
well but the main reason for us we want
to release features not dumps what was
happening was once a week we were
dumping out whatever was ready to go at
that point now that meant you be a very
small bunch of changes a little schema
change a little optimization or it could
be a massive feature a whole bunch of
things went out hold streams of work
pricing models new products you know
neway emailing system we could all go
out and we had real control over that
because i only had a single window to do
it which was monday well is in australia
so that was actually our only time to
have real doubt downtime the other
reason was automation if something is
hard to do is you probably automated in
particularly anything is repetitive to
do should not be done by humans humans
get worse as things become more
repetitive they tend to make more
mistakes whereas machines tend to get
better at it the more information you
have the more you can feedback little
bugs and problems back into your scripts
scripts become more and more robust as
also another reason for automation which
is to remove bottlenecks we want to
release more often but we also had a
bottleneck in the form of humans by
removing humans from the equation we
would be able to release and we wanted
to rather than when we could get the SIS
admins time or the ups time or you know
cubase time whatever the more two more
things that are automated we can get
everything automated then
we don't need to rely on humans being
part of the loop most of the time we all
need to get people's time which brings
us to we're talking about Pete people
which is very important is the
stakeholders now you may know why you
want to do continue to deploy them but a
lot of people are going to want to push
back and they should do because this is
something you do true trivially changing
your entire way of developing software
and delivering it it's not something to
do just off not you know because you
felt like I like it so the very sleek I
push back on you and ask why and this is
good because they will force you to our
answer the questions yourself again I
can only really talk about our
constraints baths hopefully they'll fit
know most of these will match very well
we owe you well you did people who will
push back on you users are fairly
straightforward because they don't
really care too much about the
development model they care about is
getting what they wanted out of the
system now users here can be in our case
could be internal users who want the
admin interface updated order it could
be external users who we want to get
software to faster this is pretty
straightforward they they just get their
features of fixes faster and more
implicitly layer it just be less
breakages in the system and it's gonna
be less you know every Monday there's
this night nightmare of coming in and
finding out something's broke broken if
you're constantly upgrading it's much
more of a smoother cake cadence and
hopefully problems are the exception and
not the rule managers are interesting
some love this some hate it most will
love it when explain to them I this
theory about agile I think one of the
reasons why it was adopted so
universally so quickly with complete
buy-in from the whole organizations and
Papa Mia occasional you know complete
sticking mudhole hold out pretty much
most people like yeah this is great we
should do more of this is because
managers hate being kept in the dark
they hate this idea of the old waterfall
model of you know work for six months
and then you suddenly find out that the
tests have been passing for six months
or you know whatever and there you know
you've just blown your your delivery
schedule completely out of the wall or
water if you're doing agile you doing
weekly or bi-weekly spring
you see results come in quickly you get
feedback faster you can see on a nice
chart what is being done and what is not
you can see if your behavior behind
schedule and that gets people higher up
off their back and everyone's happy so
with this again I think matches are
fairly easy to sell on this idea as long
as you assure them you're going to be
careful about not breaking things which
of course we'll talk we'll talk about
but ultimately it's this is really an
extension of agile into the right up to
the end user developers again it's this
the reasons developers like a geology
removed a lot the death marches that
went with product development and again
we have this in particular is
interesting do you see this inside the
Linux kernel development they have this
this window comes out but look every
couple of months well it's 12 al says ok
merge windows open get your changes in
and a whole bunch of stuff is thrown at
it and toward you in the merge witness
is mad scramble and just as it closes
its all please can you get as one thing
in because they know it's gonna take
three months or something to get the
next the next window to open and they
get another chance to get that in the
same with develop developers if you have
a once a week or that's not too bad you
once a month or once every three months
release cycle you've got to get that
stuff in it you got to cut off on a fri
friday or thursday whenever it is you'll
be madly scrambling to get your changes
in there or you're someone's gonna be
breathing down your neck but that means
you're going to cut corners whereas if
you say well I'm I've decided this is
going to take an extra half a day
secretive polish this change get the
last few tests I wrote more robust
whatever then it takes half a day longer
well that means the change goes out half
a day later it doesn't really matter if
your give changes go out when they're
ready that's much easier and much less
stressful now the admins sis admins in
particular and ops are quite hard to
sell on this because they often don't
like the idea that developers are
driving changes into their
infrastructure they are justifiably
paranoid about that however there's one
really powerful feature that sis happens
love about continuous delivery
continuous deployment when it's done as
most extreme level which is this
so you got a weekly release schedule
going on Alice has decided to update the
Ajax interface on the front end on the
web in the web end bob has decided to
modify the schemer to the day database
slightly not very much just a bit just
to you know optimize it slightly and
Charles has introduced a new postgresql
driver to update after security it it's
so free changes go out and a database
load spikes who caused it yups people
the ones who've got to work out what
happened with what do we need to roll
back can we roll forward what's going on
do we need who's responsible for this
very very tricky you need to go pull it
apart put it to staging find out what
what happens maybe get a full dump as a
database into staging cetera et cetera
et cetera however if each one of those
changes rolled out one at a time and if
you're being smart and your deployment
system injects a notification into your
monitoring systems that says the line in
your monitoring systems it goes release
freee went out here and then after Ariz
freee the database spikes you know
exactly what just happened and you know
exactly what you got to do about about
it or Legion you know who to talk to and
you know what your options are this is a
very very powerful idea and one of the
most powerful ideas of this feature
based releasing of continuous deployment
of this very fine grained incremental
change changes to your systems that you
end with good monitoring and good
notification systems suddenly a lot of
things that were complicate before
become very easy so that's really the
wise let's talk a bit about the house
this is pretty much where most
continuous deployment tends to stop
people say oh yes great do it off you go
and that's fair enough to a degree
because every organization is different
every network is different but there
wasn't enough we needed to do this when
ease we didn't realize we were going to
have to answer a bunch of questions
about how to do this and actually do a
lot of research and find out what what's
the water trade-offs between different
ways of doing continuous deployment
and what i can do is now is tell you the
answers that we can't came up with and
hopefully there will be of use to you so
but first thing we'll do is we'll start
with the development workflow obviously
continuous employment implies a
different development workflow really
it's not that different because if
you're doing the what I've called modern
software methodology which to say agile
short release cycles feature-based
ticket based systems and a distributed
version control system or at least a
modern version control system but that
there's nothing made no major change
there but if you're not using that
methodology you probably gonna have
quite a hard time effects not going to
really be possible so the start is
really common sense this really this
idea really started with the Mozilla and
then develop further into I think a bun
two were quite big on this of everything
is a bug everything is a is a feature
request everything is a something in a
bug tracker if a bunt who famously had
bug number one was Microsoft is the
number one operating system in the world
they've actually close that one little
things important anymore whoa it's quite
true well as lessee have change as those
other tracks are getting interesting but
they but the idea is that everything
everything goes into the budget I got mo
Mozilla actually had a bug for an issue
raised for have a massive part party
when Firefox one is released things like
that so everything goes into bug tracker
and everything and in every individual
piece of work goes in there and make you
make its fine grained as possible you
briefings into epics into stories into
smaller smaller sub tasks until you got
something out as a piece of work that
can be done and then that has a unique
ID and that is used to track it into end
that brings some massive benefits that i
will show you towards the end of this
talk the way you use this is you work on
a branch this is where subversion is not
going to help you it is not your friend
subversion particular does not really do
branching and merging I used I did maybe
two major branches ever in subversion
and both ended up in disaster how many
people here are using a version
distributed version control system so
I'm guessing about two-thirds having
Brussels on subversion or CVS or sunk
all that oh yeah sorry yeah it is it is
a massive need it must be different way
of working but the fact you can do
branches and merges quickly and
painlessly and you'll a high degree of
confidence in that your merges will not
break something is very very powerful
idea but it's important you to isolate
your work you don't have ways of doing
subversion was you do all your work
upfront and then you kind of dump it
into the system and hope it doesn't
break anything then you do a code code
review whereas with a distributor
version control system or really a more
accurately any version control system
that does reliable branching and merging
then what you do is you break it off you
do multiple commit you can maybe clean
it up at the air afterwards if you so
wish depending on your policy regarding
changing history but you get into a
clean state where you've got a high
degree of confidence that when you do
the merge back to the your main branch
it's not going to break anything part of
that is because you will be running your
tests against your branch every test
that occurs on your main branch prior to
release is being run on every commit
that you make to your branch now you
need an automated system to do this
otherwise it's a pain in the ass but it
is pretty straightforward to do you all
see the fro a lot of hardware at this as
well but that is also cheaper than
developer time trust me so every commit
results in a you know build results in a
test full test suite and then you know
when you get to that final point where
you can't do a merge you're a high
degree of confidence that you are not
going to break anything you can even do
more complicate things whereas once
having the bamboo can do as you do you
do your build and off that build works
you didn't do a dummy merge or back onto
the tree and then you do the builds
again just a double check that actually
it's not just a question it works now
it'll work in the future as well when
you do when you have to come through the
merge but this is quite important now
once you've got that interstate where
you think the feature is complete and
all the tests of parsing everything then
you want to do a merge now we have a
rule and
is enforced at the server level that no
one can push the master master is
sacrosanct it can only be pushed via the
server via a pull request we use
bitbucket obviously but there are other
tools out there to do do that no
important but the pull request is
everyone hates code reviews but pull
request to call that no lots of
differences but pull requests a kind of
really code reviews a chance you to pull
in other pete people you can also set
other rules as well so we for instance
set a rule that you must have to
reviewers acknowledge this sometimes you
can set rule to say certain review
certain types of review must be there
certain release managers must review
everything or the architect must review
everything or whatever or you could have
much more ad hoc on we're a bit more
lenient than that and we found people
are generally pretty good when you trust
them but there's also rules like the bat
our bamboo system the the build systems
integration system actually talks back
to the server and says the Builder
passing to build a fake failing and will
actually block emerge if the bills are
actually failing on on the pull request
so this is about automation again it's
about you know putting as many guards in
place so we actually use pull requests
as an education system as well so if
you've got a new developer on the team
will generally pull them so I'll pull
them into lots and lots of different
pull request even though they don't have
much to add they'll still learn a lot as
they do that it's a way of sort of just
piecemeal learning where an assistant
lisi the discussions going on and what
constitutes code quality on the team etc
but once that's signed off you can
actually do do to merge wheels are some
rules around who can do the signing off
in extreme cases but I'll come back to
that so what happens is when you do to
merge you press that merge by a button
it gets merged back onto the main branch
now that every commit every merge onto
that main branch result in a full
release so basically for the entire
release process every time emerges back
onto the main branch this is this
feature based development every release
has one change in it that could be
tracked back to a branch you had this
real traceability idea of you've got a
release the release has a number that
number goes back to a merge that merger
goes back to a branch at branch because
to an original ticket and so you know
that particular reason contains the
contents or what supposed to be achieved
by this ticket over here and this this
this cracking idea goes all the way
through so this goes out in our case as
a staging server the staging server is
where we introduce humans into the
process also be doing pull requests
obviously developers are developing it
but at this point we probably go back to
the original customer the person who
raised a pull request maybe the bas get
involved maybe we get some QA people
it's a critical one will pull some more
people in some will do over blitz and
test it if it's a possibly a critical
one because this isn't iterated enough
in my opinion that software is the verse
by humans for humans the computers are
just a days to transferring data
backwards and falls between humans and
other humans humans need to be involved
in the process some point if you're not
even volva humans in the process you're
something going wrong humans have bear
better judgment of certain things but
the original is if you get most things
can be automated so you can also make as
much as possible do so but ultimately
humans do need to be involved in the
process at some point so we do this at a
staging or the system so if we do for
continuous deployment out onto the
staging system and then humans get
involved and go okay is that same only
at that point do we promote up to
production and what goes out the
production is exactly what was on
staging there's no a separate build and
a separate release what goes out is
exactly what was on the staging server
so we have a high degree of confidence
that it's going to work in production
never know weird changes are going to
occur in between these things can do
build can be environmental specific
sometimes it's not supposed to be but
they are everyone knows y'all it works
on my computer it doesn't work on the
production think story but that's pretty
much it so that's how this it's how up
to a point again this one of the areas
where people just the tensile the soy
sauce stop there but this is where it
gets really interesting for me this is
the way it actually got quite tricky
this is what I call the last mile how do
you get that stuff onto the staging
server and more importantly how you get
on to a production server how do you got
to production server
when you might have Sox compliance you
might have a dozen firewalls in between
here and there and all sorts of things
how do you make sure you're not going to
you know bring the system down this is
really where DevOps starts its truest
sense i mean DevOps is kind of lost its
way a little bit I think it's there some
people say DevOps is everything i'm not
doing particularly the developers
developers in all DevOps is a
certification it's a tool suite it's
it's continuous deployment or whatever
but that they're always supposed to be
about cooperation between developers and
operations and this is really where it
could this is absolutely true because to
get your software onto this machine's is
you're going to have to talk to sis
admins and you're going to have to
cooperate with them and come up with the
best solution and every organization is
going to be different I can tell you how
we had to do do this I can give it a
guidelines and give you the process that
we went through to discover the best
tools for us but ultimately you are
buying from the SIS admins it's all
going to go wrong you need they you need
to trust them and they need to trust you
so this is what DevOps are supposed to
be at its heart so you should go and
talk to your sis admins and get them
involved only two types of said means
the ones who are like yeah let's do it
is to be awesome okay I'll play with new
toys and then is the other ones were
like oh like the idea of that but you
need to win them over sometimes you to
make a Fink make them think it's their
idea that's what's quite a good lil
trick do but it is it's very much a
question of corporations good time go
ahead go go go off and buy them a beer
or something and you got to talk to this
is that means and eventually they're
gonna start discussing practical ways of
getting code onto a server possibly an
AWS possibly in your own secure bunker
in the Nevada mountains at mount members
in nevada but an epilogue owing to come
back in at you and say we should use
puppet always You chef probably because
they have puppet or chef in production
right now this is the wrong answer do
not do do this and this is very
important the wire is very simple indeed
pop and share for about managing if
structure in particularly about managing
infrastructure at the server level but
your concerns are not to the server
level yorkers observance urns are at the
application and almost the cloud level
forms of YouTube use the cloud term even
further but your core cross-cutting
concerns you know concern look at said
about the server level you're about the
application level at in terms of j2ee or
you know some you know blob of code
running somewhere you're concerned about
databases and load balancers and the
network in between them and see if
there's more than one server and one of
those servers on different data centers
because you've got last recovery working
you're a cross-cutting concern you tell
puppet or chef I want this machine to
look this way how it gets there is
entirely up to it telling puppet or chef
I need this amorphous mass of stuff to
happen in a specific order is to me not
really practical it's very possible to
do you know if you were real shyt a
puppet or chef masters to come up with
some hack to do it but it's not a good
idea so you're gonna start looking at
other tools tools are designed more for
orchestration and there's what we call
orchestration agents is there's three
two types of orchestration out there
one's a agent-based now it's possible
that your you already have that out
there there are bunch of them out there
saltstack is quite hip I haven't played
of it yet it's on my to-do list of toys
I'm collective we did actually use for
our full Claire offering for a while
apparently don't quote me on this
apparently from somebody who knows this
stuff it leads memory like you would not
believe a real problem there they
eventually solution was to just go
restart it every half hour so so agent
based systems by the way should probably
clarify when you've got a piece of
software it runs on each of your servers
and it will perform actions on your
behalf this is a way basically just
doing things across your your big cloud
of various machines bamboo itself is
actually a an agent based system you
could potentially use this funk there's
other ones I'm out there the the point
here is that if your sis happens already
have this in place if they already were
with this sort of methodology they're
using M collective or saltstack or
something to do all their changes to
manager infrastructure use that
absolutely perfect not prob with that
however if you're starting from scratch
if they or they don't have this kind of
capability out there from mass
modification of machines in a sequential
way then you're going to have problems
because they're going to have to roll
out all new infrastructure and that's
generally not something they're going to
want to do it is something you probably
don't want to do it takes time however
it's very likely they already have a
massive parallel distributed
modification architecture in place
that's called SSH it's almost certainly
already out there it's secure it has
very fine grain controls you can put all
sorts of interesting or authorization
systems on top of it you can limit what
a given user can do you can create dummy
users that only have very limited
control accessing your infrastructure
over ssh is probably the way you're
going to want to go if you don't already
have an infrastructure in place there
are a number of tools out there that
help you automate this so you use this
so they basically they walk workers
orchestration systems but they don't use
their own eight agents they just use SSH
as a transport you can just script this
up with bash if you really want to this
fabric as capistrano as ansible ansibles
quite hip one that we use now these are
the tools I looks at so what you need to
do you need to sit down with your sis
happens whoever ideally get someone
who's going to be seconded on to team
when you took on Don today their team
and you work together you both have the
job of getting this into place ideally
both teams together and you need to go
through what the current ecosystem is it
doesn't take very long this we chose
ansible and this is bad a year and a
half ago the word that echo system may
change is rapidly changing world right
now so just make a table up just have a
list of all the options available to you
just hunt around sorta ansible fabric
and whatever and have a list of their
properties and just waiting up against
each other take one or two try them out
and learn do it with this is admins
because the sysadmin is going to be
managing this system and they gonna be
writing some of these scripts but
there's developers you're also going to
be writing these scripts our all of our
deployment script actually written by
our developers but then signed off by
our operations team so you need to be
both working in is this is DevOps in its
purest sense this is silos breaking down
but I can tell you what we didn't yet so
this is what our solution for the last
mile looks like bamboo creates does
these releases they're pushed out on to
what's called a deployment environment
I'll talk about these briefly a bit
later but bamboo has this concept of the
it understands the idea there are
different environments you may be
interacting with in particularly my
development environment for a dislike
for rush boxes it may be in a per branch
one then you have a staging environment
and a production environment and it
understands that they exist and that you
wants different versions of software to
be our each one at different times it
also understands you have permissions
around who can deploy to these different
environments so there's an agent that
runs and it's all that age can do is
talk to one of the production
environments or the deployment
environments made staging or development
and neck Adobe's for building and they
were used for talking to more than one
environment this is for security reasons
you do not want somebody running a build
on an agent that has access to your
production systems so you need to
separate out your deployment
environments away from your build
environment that's the problem with
continues deployment it blurs the line
between production and development as it
will should but you don't want the
development the power of the developers
who should have as much power as
possible so we bled into the your
production of arms but it should be much
more lockdown and particularly if you
have see if you have Sox compliance or
PCI compliance issues you're going to
find that you want to have a very
specific rules say only certain people
can actually access these structured
environments now one as people can be
this agent and that that agent has a key
ssh key specific to it that is used to
access to production or the staging
environments so you need to isolate very
much say we use bamboo to do this you
can use other systems there are
dedicated deployment continuous
deployment systems ours is mitral hybrid
model in bamboo we'll find out what
works for you know who use Jing Jenkins
for this I will not badmouth one of our
competitors I don't mean I don't mean I
I want to go anything I it's just not
the not my way something lasting way a
lot of people are smart people using
these tools it doesn't one major issue
does not have strong commissions you if
you have a socks or regulatory
requirement about permissions you want
to be very careful about how can you can
you lock down and say only certain
people can perform releases into certain
environments in our case our developers
are never allowed to deploy into a
production environment this is a
separation of duties concept that's
required by summer at some regulators
the person developing can't be the
person who access to a production system
so the segue slightly here continues
continuous deployment does that mean
continuous down down down time the
answer is it depends listen be a bit of
a theme to know on this particular
conference so one of the reasons why
took so long for us to get this out
there was because we had to build a high
high availability system where to turn
our monolithic system into something
that could be rolled it could be
upgraded without doubt downtime I'll
giving is quite quickly ansible helps
you with this ansible has the concept of
rolling updates and it has a concept of
pre and post operations for each update
so what the ansible does for us it
contacts the load balancer takes a
server out of production it then
upgrades it and performs a bunch of
tests on
to ensure that it is actually up and
running correctly it then we'll put it
back into production and move on to the
next server it will stop if any server
fails you can see you can specify
certain clusters a service can be
upgraded if you've got massive cluster
you can upgrade them in in batches of a
small one you want to do in a series of
one at a time but you need high
availability for this if you're
releasing once a week that's fine if
you're releasing several times a day
you're going to be talking about a lot
of doubt downtime last section is
management this isn't again not touched
on very very often here in talking about
continuous deployment you need to be
able to trace this end to end I'll talk
briefly about the controller blinds
we've already covered them deployment
environments inside bamboo are you
consider us different environments that
have different roles out and your
organization as development staging
production but you want to move the
releases between them each release
really looks like a normal build plan
these are just a list of tasks that
occur on release a bill it would have
been built the the war in our case the
the java application we pass down as a
plot as a binary blob and then we just
check out our ansible scripts which are
in there git repository and we run our
deployments this is pretty
straightforward but it also manages
release numbers for us as well and what
happens is you can actually see here is
particular example held by the way is
one part of our a micro service that
deals with deploying to our cloud
environment you can actually see that
there are free different environments
they've sandbox staging and production
and each one of them has a different
release on it now this is good bamboo is
tracking what is released where now this
gives us another really powerful concept
which ticket based management this is
goes right back to the start member said
track everything in in a bug tracker and
that bug tracker will be you and their
track ID will be unique code for LT
that's how it communicates backwards and
forwards so what you have here this is
the original ticket as you can see it's
been what freaking
have occurred on this so the bug truck
is talking to the stash environment two
of two our get server and it knows how
many commits have occurred regarding
this because it knows that there's a
branch so it looks to branch names no
that's the branch related to this
particular piece of work and we know
there's a pull request one has been
merged as well so we know we know the
status of development we can actually
look at our original tickets becomes our
dashboard into this now obviously I'm
talking about jira and bamboo and the
rest here because this is particular
what I use but this there's no reason
why you can't do this in other systems
obviously goes without saying from my
point of view it's easy to just do this
well then this also gives you really
really powerful idea if you if bamboo
knows is the deployment environments and
it is a ticket number this pops up on
what on on each of our tickets you can
see that this particular piece of work
it's been merged and a deployment
occurred which we deploy down to the dev
environment is to be deployed out as the
staging environment is not yet been
deployed out in production environment
now this is really really powerful idea
as somebody who's got to get some work
done about people screaming in your ears
because if you give this to your
customers raise a ticket and then we'll
show you in that ticket each piece of
work being done well you can see the
works being done you can see that the
builds are failing you can see that
while we fix that you can see it's been
a pull request has been merged it's gone
out into staging wanted Oh staging well
I can actually go and have go and have a
look at it now oh it's gone our
production is all done people leave you
alone people don't mind bad news they
don't mind they understand it's you have
good days and bad days that's
development doesn't mean veterans
perfect all the time but they hate being
kept in the dark if you give them
information to leave you alone it's
really really powerful I idea so this is
where this ticket base management comes
in if you can you track your changes
enter in right out into the production
environment then the user can see this
day you can do this with JIRA you can do
build little dash balls dashing do
something like this be quite nice we
used to have a dashing ball that will
show you
you know dashing of building a little
wall boards will show you what's out on
each one prediction what version in
which branches are open currently and
which one's been deployed out into
different environments so this is really
powerful you can actually give the
information to your end users and carry
on the computer tracking this for you
just give just let them deal with the
user at the front end and you least and
point them at something and say there
you go work is occurring on this right
now so we're going to wrap wrap up here
I just like to reiterate the main points
here you have a clear motivation for why
you're doing this don't just do it
because it's cool it's fun and although
you know you can sneak that in there
somewhere that's always fun if a
branching workflow is absolutely key
must keep your changes separate until
they're ready to lay already and then
you must test those changes and be have
a high degree of confidence that when
you merge them they will be safe but
ultimately it's about cooperation is the
DevOps in its purest form it's about
cooperation between people and tools and
automating as much as possible and then
the bits that you can't also made its
cooperation it's about talking to the
people you need to talk to and about
getting everyone on the same page and
having the same goals and ultimately
having a lot more respect for each other
people if you get into work together
will generally have a lot most because
everyone understands each other's
constraints the things that drive them
on a day-to-day basis so that's the end
of my talk about a billion dollar order
system seemed to the billion dollar part
seemed to work quite well you just
remember rate this session I think we're
going for more verbal questions if you
are many questions I'm happy to take
them some nail and I'll be hanging
around the rest of the conference of
food please feel free to grab me
whenever you can
so the question is did we end up
splitting them into small systems
microservices is the hip new word at the
moment moment yeah no um it's my
struggling accent when I give bad news
so if you want to hack you hear about
this is less Ian's summit isn't a in
November and as I something to talk
about him about what happened since I've
left that team about this back breakout
monolithic systems or working more
monolithic systems my personal
experience is that it's harder than it
looks everyone goes in and goes I AAA so
we'll just break it into this and
there's the customers of a customer
service as a you know the days database
select databases in practice a lot
harder than looks because so many
cross-cutting implicit dependencies what
we started doing is ill new systems were
turned into new it's a new code it's in
it's a new micro services so if it is
more a question of it wasn't so much
that we split it up as we start adding
in more and more smaller services around
the outsides and let the inner the
inside atrophy to the point where became
less and less critical and its start
becoming more like the the logic engine
in the center of the system but things
like emailing or the web front end or
talking to our counting systems will
split off into smaller systems as much
as possible we were using rests where it
sits synchronous and we're using queuing
systems in particular horny queue for
our for where it's a asynchronous the
reason being horny queue has strong
transactional guarantees do not use
activemq it lies about about its XA
transactions or fall by the way hope
their answer question so the question is
could we use feature toggles instead of
feature branches yes but you have to
have a high degree of confidence that
the code you that you're putting in
there is not going to break something
your feature toggles are not broke
broken so you absolutely can do that
according to I think Gartner a few years
ago that's that's the the its way to do
it right now
feature branches are out feature toggles
are in I'm solid wary of feature toggles
because it implies a big architectural
change now if you're doing microservices
if you got very strong architecture
that's very interface driven and yes but
feature branches can generally work
right now Fuji toggles mean re
architects in your entire system
absolutely so it depends a lot on if you
want do things like a bee testing
feature toggles are absolutely the way
to go cuz you can build it in any way if
you know you absolutely have to make
this change then yes yeah it's a fair
question if you have the feature to your
system built in such a way the feature
toggles are possible that's definitely a
way to go it does incur some risk though
in my opinion but I know it's not very
so this is all very strong opinion at
this point it's not something I've done
a huge amount of it's definitely a
different approach a fee if you're
geared up that way yes oh that's an
awesome question we use a glass in JIRA
the best bug tracker in the world yeah
that's it basically now he is with our
own products we dog food them people we
generally we do dog food so we do
actually her own problem so we actually
do continuous delivery on our own
systems internally as well so often
sometimes we will actually hit about hit
up bugs and so on because we are
enormous running on the bleeding edge
but doesn't mean you get those quite
cool features we do the integration by
the way the big secret here do not tell
anyone my company I told you this it's
all just rest api is there's no reason
why if you are you're using JIRA but
you're stuck on Jenkins you can't make
the same API calls that bamboo would
make sets feet this information back but
I didn't tell you that okay thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>