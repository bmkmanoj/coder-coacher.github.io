<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Forget Velocity, Let's Talk Acceleration • Jessica Kerr | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Forget Velocity, Let's Talk Acceleration • Jessica Kerr - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Forget Velocity, Let's Talk Acceleration • Jessica Kerr</b></h2><h5 class="post__date">2017-10-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Lbcyyu8XB_Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Thank You yen good morning and thank you
for coming I'm very happy to be here my
name is Jessica care better known as
Jessa Tron and I'm excited to talk about
velocity and acceleration and how do we
get better at our job cuz that's why
we're here right it's at least our
excuse for coming to the conference
along the way I'll try to answer such
compelling and enduring questions about
software development like what is done
which programming language is the best
and the one that's really personal to me
why is this so hard because I have been
developing for eighteen years and it has
not gotten easier it gets harder all the
time and I'm like is it me am I getting
old I turned 40 this year but I don't
think it's me
I think there is something about our
work that is inherently hard that if
we're doing it well it's actually harder
than if we weren't so let's start by
defining velocity and acceleration I
only got my bachelor's in physics but I
remember this stuff really well so
here's a graph of happiness over time
that as we invest time into our software
we hope that it gets better and every
manager loves this graph because it's
nice and smooth and most importantly it
goes up and to the right
everyone loves graphs that go up and to
the right of course everything about
this graph is bullshit but we'll get to
that in a minute now the velocity is the
change the rate of change so it's the
slope of the line and here then whatever
it's a constant slope and it's about one
so here's our D happy DT
and that's supposed to be a flatline but
close enough our velocity is a constant
acceleration is change in velocity so
the acceleration here is zero
very unsatisfying for us but our
managers would love it if this was a
thing because then they could plan
unfortunately what software development
really looks like it's more like this it
starts off going okay and then it gets
slower and then oops Brooke production
and then it's just really rough it's an
unpredictable and then then sometime we
stop developing features and you would
think that the value would stay constant
but we know better than that
the world around the software changes
the meaning of value changes the
system's we interact with change and the
libraries that we we have installed get
security patches and eventually there's
other software out there that's much
better than this
but we can't use that oh no because this
was a capital investment and you will
darn well use the software that was
developed for your use if it's internal
and at some point because nobody can
change it it's not alive but it's still
running and it's making people's lives
worse it becomes zombie software more
and more on the zombies later but first
let's question more of this graph next
the x-axis why do we measure software
effort in terms of time because it's
easy that's why but it takes a lot more
than time to move software forward I
mean personally the time I sit at my
desk correlates very loosely with how
much better the software it gets because
I mean there's time in the shower that
I'm thinking about it or like when I'm
writing in my notebook over breakfast
that's moving it forward and there's
plenty of times at my desk where I'm
like whew and the supper is just sitting
there just fine so time isn't sufficient
we need something more so there's a word
CREP 'let's crip 'let's our units of
time and attention
the time is not enough we need focused
attention on the software in order to
change it in order to add value and
often of a day I run out of attention
before I run out of time especially if
I'm pairing and so I'm very focused for
a long time after about 6 hours I need
to go answer some email or something
because I'm done with this code thing my
brain is fried so we need more than time
we also need attention and its attention
with a brain with specific knowledge
which we'll get to later the other thing
about velocity to consider is that it's
not just one it's a vector and a vector
has magnitude and direction so this
picture is Professor B Nick from where I
went to college and used to dress up in
this vector man suit in order to get
through to the engineering physics
majors that vectors have magnitude and
direction they have to go somewhere so
in in our little chart here really at
each point the velocity is a vector it's
what magnitude is 1 and its direction is
up up increase in value but what does
that even mean velocity has to have a
direction and I'm sorry but better is
not a direction so where are we going
that's that is the crucial question
because software is like real estate you
can build a gorgeous mansion but if it
is in the middle of the desert wrong
tool you are not gonna get a good return
on it in real estate its location
location location in software it is is
it useful is it useful no no but really
is it useful that is the real eternal
question because the hard part is
building the right software that's what
is the right software and that is why
acceleration is particularly valuable
because we need to change more than the
magnitude of how fast we're going even
more crucial than that
you need to be able to change direction
and acceleration is required to change
the direction of the velocity I think of
it as we have a vision we have a quest
at atomist it is to change the way
software development is done by bringing
some automations that are currently too
difficult by bringing those in reach so
that we can work at a higher level and
write more code to make our own work
easier okay so to get there we need to
navigate through a sea of everything we
could possibly build and here's us we're
down here in come here give me the tool
we're down here in this little boat
here's a boat and we need to get to that
star so we like point in that direction
but we do not sail out into the open sea
with a Gantt chart that goes 150 years
into the future no we don't we we look
for safe harbors we look for places to
stop and land and take our bearings and
these are supposed to be a little
snow-capped mountain sea so with our
boats well navigate to the nearest one
what's the what's the smallest thing
that we could build and stop and get
feedback so we sail our boat to the safe
harbor which is deploy to production and
then we talk to the customers and we get
our bearings and we we like see if the
star is still in the same place and we
decide on the next safe harbor to get to
and in the meantime while we're trying
to get there we got like some sea
monsters that jump up and attack us and
we've got to fight them off and
sometimes we were delayed by a couple
days defeating them and other times for
like oh you know that however it doesn't
look so good after all how about that
one over there and this is fine too you
know we learned something and we shifted
direction that's that's essential but
these monsters they feel like sometimes
I feel offended by them Travis why is
your API documented so poorly and why
does some some rest calls require auth
and others won't work if you do send it
off
but I've come to realize that these
problems are in fact they're not in the
way of me doing my job they are my job
this is what I'm here to solve Jessie
Watson in a really good blog post about
the hard thing about software
development calls this the field of
micro problems it's all the problems
that are between us and the solution
we're trying to produce all the problems
that are like in that area between the
business and the technology as we try to
navigate this area and produce produce
the system that will solve our business
problems there's the system as we
navigate this field we find all these
micro problems and we need to be able to
solve them and to do that we have to be
pretty darn good at the business and the
technology and when we give an estimate
there's a dirty word we think we
understand the business and the
technology and we know some stuff about
it but we never understand it enough we
never know where all of the monsters are
because maybe you worked in Java for 10
years and you think you're good but have
you called exactly that method out in
this these libraries have you used this
particular API before and oh gosh did
you even know the garbage collector
could do that there's always something
new to discover in the technology but
even more in the business because the
business has probably been around for
longer and the business is made of
people and you can describe the happy
path easily enough and that happy path
maybe 99% of code executions but it is
1% of the code because every error path
is different and you'll find all kinds
of alternate ways to get to the top and
you'll learn about all the different
little dead ends that people could go
down and how can we redirect this and
there's always way more to it than you
think when you start entering these
instructions into the computer only when
we try to get to this level of detail do
we discover how detailed we real
have to be yesterday in the 360
developer track Martin Thompson brought
this up designed until you feel you
understand the problem code until you
realize you don't repeat that is totally
how it goes there is nothing and I
really seriously mean nothing in the
world that gets you to understand every
detail of the problem like instructing a
computer how to do it okay so yeah that
does sound hard how do we get better at
our job I'd like to zoom in on the we
who is it
or what is it that is producing value
for our customers our users it's not
just the software alone and it's not
just us
clearly we are involved clearly the
software is a part of it and so is all
of the little interstitial code around
the software the deployment the queues
between the services and maybe we've got
some some kubernetes going on here and
some surroundings all of this stuff
together with the people who are
maintaining it form a system I used to
call it the socio-technical system and
that's also true that is accurate
however there's there's a point to bring
out in here that this is a system of
mutual learning the code learns when we
change it we teach it new tricks and we
learn from the code from its output it
can tell us whether it was useful by
whether the customers are using it we
learn from the exceptions it throws to
us that the world is not as we would
prefer it and together together we each
get better over time and this is a
living system of mutual learning the
word for that by Norah Bateson is
samatha see sim for together Massa see
meaning learning and if you when you
look at it like this as a dynamic system
that is continually learning you start
to see why our job is so into
resting and you can kind of embrace
maintaining the relationships between us
and the code and and us in each other
and the code and the other code can we
all be nice to each other part of this
is our mental model of the software in
order to change the software we have to
have the mental model of how it works of
what the different parts do what the
different names mean that kind of thing
and only with that can we change the
software that mental model can be really
hard to build you would think you would
think that if someone has created a
system you could read it and figure it
out and understand how it works
more easily than you could write it
again from scratch but as far as mental
effort goes you would be wrong Valentino
Brighton Berg has a gorgeous little book
called vehicles it's about this big and
it's from the 60s and it's a thought
experiment about tiny little cars little
vehicles to start out with one motor and
a sensor so like the more light it sees
the faster it goes but and then we'll
add two motors and two sensors and and
so if it sees more light it goes faster
but then one wheel goes faster and it
runs away from the light
or you switch him and then it runs
toward the light and then you add
thresholds and it starts running toward
the light and then running away it's
really simple underneath and as you go
step by step and build it up there's
nothing caught it just doesn't seem
complicated to you but if you look at it
from the outside it looks like these
vehicles have behavior this book is so
fascinating I swear by page 25 I said I
understand religion now but the thesis
is this law of downhill invention uphill
analysis that creating a complex system
from scratch and understanding how it
works is easier than coming to a system
from the outside and figuring out how it
works and this is a big deal it means
that if in your team or your
organization you have some not invented
here syndrome those people are mentally
lazy because it may feel productive it
may be more work and it certainly takes
more time to rewrite something from
scratch for yourself than to understand
what other people have already written
and solved all those micro problems it
is mentally easier to create it I mean
yeah you put in more time but but it
really is harder to understand that
system I'm more productive so uh yeah
next time you tempted ah this this is
way too complicated I'm just gonna write
it myself
well maybe it's complicated for reasons
you don't know until you get in there
and yeah just accept that it's you're
not stupid it really is hard to figure
out someone else's system and that has
implications to understand that the
system and we talked about knowing the
tech and the business in order to create
the system but understanding the system
is crucial you have to have that mental
model in order to change it and that
mental model is really hard to get if
you don't have it so this means we have
a special relationship when we do have a
mental model of the code if you wrote
the system then you're in the privileged
position of having a mental model
without having to do that uphill
analysis and it's really hard to pass
that on to someone else because you
don't know what you know there's these
like unknown knowns in there because it
wasn't that hard for you it is simple
for you because you built it up from
scratch in small pieces and it is not
simple for other people and if you can't
explain it to them
and bring them up or if you more likely
you're changing it so fast that they
can't catch and they can't get there
then you look like the 10x developer but
really it's just that they haven't done
that uphill analysis yet it's really
hard so we have a relationship with our
code if you wrote it you're its parent
you brought it into the world you know
what all those scars are you know what
all those weird little mispronunciations
and those cute little interim award
you understand those you're good if you
adopt a piece of code and form that
mental model and build that relationship
awesome
that is extra challenging and it's what
most of us do and it's one of the things
that makes our job so hard but but
that's that's super powerful and you've
got a like figure out what it's doing
while interacting it while influencing
it without knowing all that history
super hard this means we have a
relationship with our code I think of
like the evolution of a system is kind
of like when we first write something
it's a baby maybe it's a script that
only runs on my computer maybe it's a
little website with no error handling
and that's fine because often the baby
it's easy to write and we can use it to
answer the question is it useful but
then whenever it fails whatever it craps
out we have to change this diaper by
hand but if it's useful if it looks
useful then we invest in potty training
and then it gets to be a kid and maybe
we deploy it as a service somewhere in
Cloud Foundry and that's cool
but then as soon as it hits the real
world we start hitting real error cases
and all those corners that we're like I
didn't know that could happen and it
starts to be a teenager I mean only real
world exposure can like grow from a
piece of software from kid to teenager
and on toward adulthood and now if we
need security we need authorization and
all that stuff and if we get it far
enough so that it can take care of its
own shit then it becomes an adult and
the adults has monitoring and alerting
and stuff but really it's got like it
restarts itself if it fails and it's
only the unexpected problems that it
needs to call you on now if at any point
you stop development and the team moves
on and no one has a mental model of that
software anymore it's expired or they've
left the company and no one can change
it
then it's the zombie so that can happen
at any stage it's a zombie and it will
eat your face
so let's not talk about zombies anymore
that's that's it for the zombies
yesterday Martin Thompson said that he
doesn't like the word software
maintenance because it doesn't really
describe what we do
I mean mate maintenance used to be like
you squirt some grease in the joints and
do other mechanical things that just
needed the same thing needed done year
after year and that is not what we do we
do something different every day so I
don't think maintenance is the right
word so I propose software parenting
because it's different every time and it
often surprises you and here's an
example last week a couple of weeks ago
at atomist we decided let's try putting
a graph QL endpoint in front of our
neo4j database will that be useful okay
so I wrote some scripts I downloaded the
graph QL extension for neo4j and I
loaded it up in our staging database
number some scripts to make the schemas
and update it and that kind of thing and
so sure we have a graphical extension on
our neo4j now but it's totally baby mode
because whenever we need to update the
schema I do that I mean yeah I made read
Me's but nobody else has their
environment set up for it and so they
just call me and this is proven useful
and it is way time to mature it past the
baby phase is well worth potty training
because if some if something happens
with that schema now they're they're
screwed for the rest of the day so yeah
right after this conference I intend to
raise this up to a baby and put some
more automation and clearer
documentation around how to do that the
extension itself come back please the
extension is written by neo4j people and
it's in the kid teenager phase they say
early teens because we're one of the
first people I guess use it in in
production
and we find things that aren't
implemented we found a few bugs but
mostly just stuff that they never
implemented because nobody had ever
needed it before because it hasn't had a
lot of contact with the real world
fortunately a neo for DES they're like
super happy to get our issues and bug
reports and I'm working from the tip of
Master here and that's fine and they
want to mature this and they know the
only way to mature it is to get those
bug reports from the real world so
they're all super happy and fix them
really quick and then we keep going and
this is how this is how we help each
other grow up if this is my credits for
the day these are all my credits in this
jar and I still have all this software
and baby stage I've got this graph QL
stuff in baby stage then that means
that's overhead because anything you
have to do to just keep things going in
the state that they are the classic
meaning of maintenance is overhead and
anything like outside the samatha situ
so it's fun like sending status reports
outward that feels like overhead and you
got to get that done before you can make
forward progress and add value to the
software and then hopefully you can take
a little bit of time to work on
acceleration which usually consists of
reducing the overhead because if there's
like a production incident or I got to
take my kid to the dentist the overhead
is still there and productivity our
value output can drop to pretty much
zero and then I don't have any time to
reduce the overhead so I can't get any
faster I can't get out of this hole and
that's really bad so that's what we want
to avoid and that's why we want to grow
our software up this gives us a way to
answer what is done because we're
parenting the software I mean when are
you done parenting only if your children
dies so I hope that doesn't happen to
any of us but in software I totally hope
it does Dunne is out of production if
you can determine that something is not
useful and take it out and remove the
feature then no one will ever call you
and ask you about it again
it would be great that is the definition
of done for software it's out of
production other than that it's it's
always there or the other thing you can
do is leave the company I get so much
done like the first six months in a job
but after that your context your
knowledge your mental model starts to
become the most valuable thing because
you have and and that makes you the
recipients of a lot of questions and
that's excellent but it does make you
busy another way the doing it well makes
it harder alright so if we do want to
raise our software all the way to
adulthood so that it doesn't bother us
so that we can continue to support more
software and we can add to our children
and have another one it takes a lot of
work so here are some of the things just
a few of the things that move us along
on the software maturity scale and and I
measure this scale from a shell script
that runs on my machine to Netflix and
Netflix has like some serious adulting
going on but adults are hugely more
expensive to build hugely more expensive
to build than teenagers and most
software is not sufficiently useful to
ever need that but that's okay the point
is that we can move it along according
to its usefulness and I want to
emphasize a few things on here versions
testing and deployment these are
particularly crucial and they're crucial
early as well because this is how we
enable change and our job is not to
write software our job is to change
software once you've written the line
especially once it's in production
you're not writing it you're changing it
and that's way harder so when we do get
software to adult that's awesome because
it calls us when it needs us and not
otherwise and if you'll notice some of
these these are a few characteristics of
adulthood a lot of these aren't in the
software itself backwards compatibility
might be or you might have a proxy
outside of it that's
that's faking it out-of-date libraries
might be inside but we could build
software from the outside to take care
of this it doesn't have to be in our
business software it's in all that code
around the code all this blue stuff here
and a bunch more that isn't pictured so
the code around the code by adding some
of that we can grow our software it
doesn't necessarily mean change in the
business services themselves it can be
infrastructure and it can be the little
pieces of code that that are between us
in the code the deployment scripts CI
and CD the automated tests and
continuous deployments and all of these
things make our make the whole samatha
see more adult and those are automations
so let's talk about automation and in
particular I want to talk about local
automation local to your team so stuff
that you run or ideally stuff that you
share with your team and your whole team
runs there's a special property here
that that software can be kids even
though it's advancing the business
software toward adulthood the local
automations that we write can be kids
which are orders of magnitude thousands
and hundreds of thousands times easier
to write and to change so for a local
automation I've got five why's a what
and how much first why saves time and
this is the absolute minimum obvious
reason to automate something how many
times do I do it times how long does it
take compare that to how long it would
take to automate it so if I spin up a
new project twice a year and it takes me
a week every time but it would take
three weeks to automate it it's gonna
take a long time to get my return on my
investment except it's not first of all
we saved more than time we save krupp
--let's oh i misspelled it there we save
CREP let's and so we save attention
maybe it's it's something smaller it's
not as big as for writing project maybe
it's every time I need to make a pull
request from a commit it's like four
commands and get and then I have to go
to github and click a thing I can I can
and have built a little script that does
those four commands and then opens the
web page on github
it's a tiny thing but I'm quicker to
make PRS because of it it changes my
behavior I don't wait as long to make a
pull request as I otherwise would
because it's two letters PR or blah-dee
blah-blah instead of requiring my more
attention than that now if you get
bigger say you have this project this C
write the new project automation and
then that year you create eight new
projects well why well because it's easy
now and so those other six projects are
ones that you would not otherwise have
created you would have just glommed him
onto some existing service because that
was easier that was safer and that was
the way to bring value to your customers
but it's a negative architectural II
it's better to have these things in
their own service where they can have
their own scalability considerations and
read/write trade-offs and where they can
more easily be deleted if they're not
useful architectural e it's better but
it would have cost more
now if spinning up a new project takes
half an hour because you automated it
suddenly the incentives are different
and so our behavior is different we've
eliminated a trade-off and so we're
gonna spin up a new project exactly when
it's appropriate to spin up a new
project and we've changed our world by
changing our behavior by changing our
incentives through automation my
favorite example personally is get get
totally changed how I work I mean you
can use it as a faster subversion but
but then it was like oh I can make a
commit before I go to lunch and I don't
have to share it with the rest of the
team even if the build is broken sweet
now I can save my work and I can come
back later and tell the story and I can
get access to that story instantaneously
cuz the log is right there totally
changes the way I develop and I never
want to develop without it I called the
these particular automations shaving the
Golden yak which is another talk and
those are quite rare but when you find
one it makes a big difference okay
next why safety and I don't mean like
human safety like I died or I stubbed my
toe safety from disasters of all sizes
including bugs including frustration
including embarrassment oh crap I broke
the build again automation provides this
because every time we do trip over
ourselves then we can go back into the
code because this is this is local to
our team so we have full ability to
change it and we add a little a little
check and then and then we're safe from
that it tells me I don't think you
really meant to do that to prod and I'm
like oh you're right I didn't think
reproducibility is another one now we
can how do you do a deployment like this
exactly like this every time because the
only real documentation is code peter
hilton has it has a name for this or or
one way to achieve this are DD readme
driven development it's called how do I
do this
oh I'll write the readme for it and you
start writing the readme and you're like
oh god I need to cover this case I'm
just gonna write the code because often
it's easier to express something in bash
then in markdown and then it's it's
documented it's automated it's useful
you don't have to explain it to anybody
you don't have to explain it to the new
team member they can dig in the code and
read it when they need it and before
that they can deploy here's here's a
different concept and this is a little
more abstract and it's not really about
us it's about the managers legibility is
a word from the book seeing like a state
by James C Scott and this is a book
about politics forestry city planning
but it totally applies to code the
concept of legibility is an
understanding that
is descriptive at a low level and also
at a high level so like in the Middle
Ages towns didn't have like street names
and people just had nicknames they
didn't have like family names or
anything they didn't need it because
everybody knew everybody everybody knew
where everything was and nobody else
cared and then you get alike governments
coming in and they want to tax all these
people so in order to tax them you've
got to count them and you've got to say
who owns what land and so they brought
people with big books and they made
everybody take two names and have an
address and I mean we find that useful
now but back then they didn't but it was
about the government because once you
can say I have once you can list the
people then you can count the people and
then you can add the counts from
different cities and this forms a monoid
and then the understanding can roll up
by region and country and you can see
things like oh is my country growing or
am i losing population is it shifting
from here to here are my tax revenues
commensurate with the prosperity of my
nation that kind of thing so we need
this in programming people
decision-makers above us really do need
to understand what's going on and
whether we've encountered more or fewer
monsters than expected that is essential
welcome to JIRA
lord knows JIRA is not for us because we
hate task managers because our tasks are
different every single time so they
never work but they are important it
really is important to get people the
information of what's going on and that
is it that's an important thing so if we
automate things if we automate what we
do like task switching or deployments
merging of PRS whoever writes those
automations has the power to introduce
reporting to whatever system management
wants whether it's JIRA or somebody's
spreadsheet that can all be automated so
automation has the power of giving
legibility in ways that don't burden the
people doing the work and in fact the
automations can make your life easier
and so you're happy to use them and the
legibility just happens and everyone's
happy
speaking of everyone's happy this one's
even better
this word out of the Journal of
organizational psychology generativity
is the difference between the team's
output with me versus without me as
opposed to personal productivity which
is the code I personally delivered so if
I'm coding along on something and you
come and ask me a question because I
have I wrote the system so I have a
better mental model of it than you and
you come and ask me the question and I
say I'm busy okay I'm being productive
but I am NOT generative whereas if if I
get an error message and I'm like god
that was really hard to figure out I'm
gonna go change the error so that the
next person who hits this does not have
the same problem that's generative it's
a distraction from what I'm supposed to
be doing but it smooths the team's work
forever and the whole team so if you're
the person who encourages people who
asks how they're doing who answers all
the questions you're gonna get less work
done personally but you are generative
and you are the most valuable so
generativity is about your contribution
to the team's output not just yours
an automation is extremely generative
because it takes your knowledge and
makes makes the road easier for everyone
so what are we going to automate this is
a decision to make and when I was
thinking about this I spent a couple
days on a task I was making automations
for cascading tests and I mapped out the
task in this particular case so that I
could study what is it that really holds
me back what is it that I'm doing so
each like line to the right here
represents a context switch of subtasks
or microbe problems and the the red ones
are really angry and then I can go back
and I can look at that and say well what
would automation really help with like
what do I do often it turns out that I
very often have to like upgrade this
library that I use and bring myself up
to the latest standards because it
changes really fast if I could automate
that that would be really helpful what
do we wait for if I'm waiting for builds
often can I make the thing that I need
to do after the build because that would
be great then it doesn't take my
attention or at least I could
synchronize this and have it ping me in
slack when the build is done so that I
can get to it then and not have to watch
it and what surprises us what do we trip
over this is an emoji that I use in
slack the wait emoji when I want to
complain about something that dragged me
down by tripping over it so like if if
I'm cutting along and I hit or I'm
testing say I hit a not implemented
exception I love those they tell me
exactly what isn't implemented and
exactly what I need to change but if I
get a nullpointerexception in a long
string of this Dada Dada Dada that it
could be any of those so when I'm in the
baby stage the the error handling that I
do introduce is the kind that's gonna
surprise me negatively at home if I walk
across the living room and there's a toy
in the middle of the floor and it's like
a teddy bear
and like maybe I'll pick it up later
somebody might play with it before then
but if it's a Lego car I'm like oh my
gosh I do not want to step on that so I
pick it up right away so the things that
are nasty surprises any sort of
automation or just coding practice that
can help us with that as important and
the last question is a tough one how
much how much time do we spend on
automating because while we're working
on acceleration acceleration is a
multiplier from moving forward but that
only helps if we're also moving forward
and for not spending time I'm moving
forward because we're doing all our own
automation what are we doing the answer
is time box it just like any other
software the question the burning
question is is it useful and so that
time box grows proportionally with how
you're useful it absolutely definitely
is so the first time I want my I wish I
had a PR script I don't do anything and
the second time I wish I had a PR script
I probably still don't do anything but
the third time I'll spend 15 minutes on
it and if that's not enough then the
fourth or fifth time I'll give it an
hour and then maybe I'll consult with my
teammates and they'll all be like oh my
gosh I wish I had that okay now maybe
it's worth spending a day automating TS
Lintz or whatever it is
okay so this is also really good
practice at making your effort
proportional to how useful you know it
is because you get to determine
usefulness here the goal being to spend
fewer credits overtime on overhead more
on actual work and whatever we can do
for a forum acceleration because this
takes our whole Samantha C into
adulthood alright so how do we get
better at our job our job is doing
things we've never done before
every day is different every day is
something new so how do we get better at
that transfer of learning is taking
something you've learned in one context
and using it in another context so this
is what we need we need to use our
learning in one place to learn faster
somewhere else and I do not recommend
this book I read it so you don't have to
it's expensive and it's not that good
but it does have some useful information
in it so here are some of the things
that help us do transfer to help us
transfer our learning we need at least
these five things so expertise and in
particular I want to zoom in on
expertise and get a little more detailed
with it
we need in-depth expertise in something
so go deep on Java or go or whatever it
is that you want to be really good at or
software in general because this we
transfer learning through metaphors and
this gives us something to relate
everything to personally I relate
everything to software software is a
complex system so it works for
everything
I think of biology in terms of software
analogies I think of human relationships
in terms of software analogies and this
is helpful that knowledge also needs to
be filled in you need to have edged
sedges and limits you need a lot of
success cases and a lot of failure cases
in your
and then you need some breath like the
more things you know well the my
grandmother used to say know a little
bit about everything just enough to have
a conversation about it because then you
get more conversations and also you get
kind of a framework to hang new
knowledge on if you just know a little
bit in breaths so that's useful too
the next thing is mood and in particular
the mood while you're learning something
to make that thing available for
transfer it helps to be happy it helps
to be interested to feel interest and it
helps to have a practical aim because
that also gives you a framework to hang
your knowledge on so you can retain it
better and use it more later as so the
next time you need to deal with nginx
configuration and you go and you google
it and you stack out and copy something
out of Stack Overflow yes do that but
also take a little extra time to fill in
some edges and learn some vocabulary of
nginx configuration and just just fill
it out a little bit oh the next time you
have a business question and you you
were like okay I think I need to ask
them about this particular error path go
a little deeper find out the history
that's where the real why is and that's
really where you'll get depth and
understanding of the business a
reflective practice yeah you've got to
do it and think about it how could I
have done better and like I really like
it when I have a pair and at the end of
the day or the pairing session we say
okay how did that go what would we do
better next time that's where you get
better at something theoretical
knowledge yes learn your data structures
and your algorithms and your design
principles because again that gives you
a framework to hang things off of and
culture of transfer I'll talk about in a
minute I want to get to levels of
transfer so new your transfer would be
like I learned something at school I
used it at work that's that's great and
this is this is totally useful far
transfer would is when you take an idea
from one context and use it in a very
different context so near transfer is
like getting worked
if you go a little farther and you're
like huh I haven't seen this before but
you know that other thing is a little
bit like it maybe maybe that has some
relevance then your problem solving and
if you go farther than that
it's called creativity this is where we
get new ideas from taking ideas from one
place and putting them in another the
the mind space for this is very
different so for work you want to be in
closed mode and closed mode means you
have a single mental model that you're
working with you have made a decision
about where you're going and you're
going there and this is about moving
forward which is great
whereas for problem solving and
creativity you want to be in an open
mode where you can shift between mental
models humor is really good for this
because that's the secret of a joke you
think you're in one reference frame and
you're in another I would tell a joke
but I'm terrible alright so the good
thing about closed mode is this is where
we move forward this is where we have
velocity and we're adding value and
that's where we want to spend most of
our time but then we often get surprises
now tests are really helpful here and
like the repple because you can do
constant experiments you can verify your
hypothesis very quickly I think this
will work yep I think this will work you
up and then when it doesn't you're still
in a closed context you don't have to
move very far you can adjust your model
and get back to it whereas when you have
no idea how that exception happened or
nothing changed why is this broken now
you need to ask open questions you can't
go in with a hypothesis you've got to be
open-ended and say wow what could have
happened here what don't I know about
the system ISO switching back and forth
between those is painful and costs us a
lot of time I talked about micro
problems every time we we write a line
of code we're making decisions usually
several decisions what do we name this
do we do an old check in that case what
do we do a lot of these decisions are
business-related a lot of them don't
feel business-related but are such as
the null checks and this is my attempt
to draw a fractal
of these these decisions of okay how do
I break down this problem and how do I
break down that now what do I do in this
case our job is not writing code that's
the easy part it is making decisions
lots and lots of decisions which require
expertise in the tech and the business
and this is what Jessie Watson argues in
his post this is why development is not
a commodity and you can't just outsource
it because you have to have that context
to make these constant decisions so in
order to get better at programming I do
not want to write fewer lines of code
our industry seems like it's obsessed
but can we express more in fewer lines
of code well you know what the
expression is the easy part that is the
down hill invention I do care about how
easy it is to read but as I'm going what
I really want to do is to make fewer and
easier decisions because my CREP let's
of attention are really I want to spend
them wisely so how can I make fewer and
easier decisions Automation is one that
pull request is not for things I have to
think about it's it's one now and an
automation takes a lot of decisions out
of it I particularly want to give a
shout out to code for matters and
linters with auto fix I freaking hate
lenders without auto fix but Artifex is
fine I do not care how many spaces or
tabs or whatever I don't care on the
formatting of my brackets or what lying
there on I just don't want to make that
decision so please those of you who care
about it
have fun write a program I will run it
or I will have my automation run it and
my code will look consistent there is
value in consistency I just don't want
to make those decisions that is not
where I want to put my crap let's pay
for software and if you ever get to the
point where you're like oh you know
WordPress and this plug-in it doesn't do
it quite the way I want I think I'll
write it for myself you know what maybe
the way you want causes problems down
the line and they're doing you a service
and there's a reason they did it the
other way and even even if they didn't
you know
spend the time to understand the
abstractions that people have created
this is so good it totally you're not
just getting code you're getting those
decisions made for you of what matters
what what is worth thinking about and
then expertise expertise makes for
easier and better decisions and in
particular expertise in the business and
in the system which means I don't want
to spend as much time on the technology
you know the technology is the part that
anybody can learn nobody else can learn
this business or this system without
being there and that brings us to what
is the best programming language so
these are a bunch of programming
languages that I've either used at work
or spoken about at conferences so I have
some some breadth here and I've decided
the best one is definitely whichever one
you already know because I can learn a
new programming language is in a few
weeks no big deal but I can learn the
build tools the ecosystem around it the
package management the versioning the
libraries the major frameworks the
memory management and performance
considerations the idioms and the
community in decades so yes
language matters and I used to be all
very polyglot whoo and now I'm like God
can I just use one language please can I
just get good at something again because
I want to have that depth in the
technology but I don't want to spend my
time on that because you're you're
serious value to a company as a
developer is in your knowledge of the
business and the system that's what
smooths us out and lets us make these
decisions
call out to tests makes decisions way
easier will this work or don't try it
that is hugely powerful because our job
is not just making it work that's the
easy part
I feel like it works I saw it work once
can you show that it works in all the
conditions that we need it to and can
you show that it still works after more
is added this is so much
harder and you should have more test
code than real code and it should take
longer and that's okay because yeah
showing that it works is way harder than
making it work but it's incredibly
valuable because it gives us freedom to
change all those other factors of
adulthood can come if you have the
freedom to change the software also
helps to have observability so you can
see what's going on in production and
roll back so that you can you can back
out your decision if you made a poor one
that lets us let's makes it easier to
experiment and the much neglected
outcome metrics which would tell you
isn't useful
can I kill it so we're not system
builders we are system movers and that
is much harder and it's much more
powerful because we can improve the
system as we're in it the whole samatha
see is our system and we are constantly
moving it through our interactions with
people our changes to the code and
everything we build around the code this
is the system that we are moving toward
greater usefulness which is constantly
in a different direction the people in
the system are important too and I
haven't talked about them much but I do
want to get back to culture of transfer
in order to transfer our learning we in
open mode being creative or
problem-solving we need to be around it
helps to be around other people but only
if none of them make us feel defensive
that asshole is holding everyone back
from learning and from using their
learning no when do they look productive
they're keeping everyone else down so we
want to say yes and we also want to
encourage impossible ideas john cleese
calls these the intermediate Impossibles
oh wouldn't it be awesome if this
library deployed itself to all the all
the production services oh yeah what if
we could like get clone every repository
and make a pull request and if the build
past just merge it oh hey I heard about
a tool that does that we're working on
that now
so you can get to the next idea you can
do a farther transfer than you would
individually with some impossible ideas
in the middle so yes our work is hard it
has all these contradictions we have to
be detailed and creative at the same
time low level and keep that broad
perspective a lot of people have said
that growth is a series of I'm not who I
thought I was so maybe our job isn't
what we think it was maybe we can get
better at it maybe I'm not being
productive maybe I'm not writing code
maybe that's not core to my job I'm
doing it but maybe it's not about making
it work or building systems maybe it's
about being generative it's about
decision making showing that it works
and moving systems Richard Campbell's
has a beautiful quote follow your dreams
huh fuck your dreams try stuff and see
what makes you happy
it's the same with software it is ok to
have a vision a quest that we won't
reach in my lifetime or in this project
or in this sprint
that's fine that's fine we're gonna move
forward one safe harbor at a time
automate your oars keep your heads up
for navigation I'm Jes etre and I'm a
system mover
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>