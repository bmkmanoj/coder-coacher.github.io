<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Interview with Dean Wampler &amp; Amanda Laucher | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Interview with Dean Wampler &amp; Amanda Laucher - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Interview with Dean Wampler &amp; Amanda Laucher</b></h2><h5 class="post__date">2013-06-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R_r7ef54AxY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">cheers I'm Amanda lager I'm a guest sort
of known for F sharp mostly functional
programming stab the deck functional
languages are kind of my thing I'm being
wampler done a lot of stuff but mainly
it's functional programming scallop big
data recently so we're going to talk
about functional programming today and
enjoy some drinks or reddit so when we
were asked to talk about functional
programming it said I don't really know
what I'm going to talk about because
functional programming is kind of dead
right like functional is just the way
you program that's just how you write
code now so I think it's an interesting
idea that maybe it's is it getting
boring I suppose if you talk to the mass
developer out there the average Joe
probably still isn't thinking that way
then maybe that's not true but yeah I
think maybe we're at the stage or we at
least need to make the case for why this
is better actually I just came out of
Brian gets this talk on Java 8 and
everyone's kind of focusing on the rebbe
and lambdas to the language which is
awesome but really what they're really
doing this enabling the kind of
functional code that we get used to an
f-sharp Scala and closure where if I
need to do a data transformation it's
just a sequence of very obvious and
intuitive calls and there's just a lot
of ceremony that you're now fades into
the background compared to the way it
used to be so yeah I just came from the
bar obviously too we were there's a
group of us talking about when Java
finally releases and all these
functional features are there are we
still are there so many people who
haven't jumped to another language
because at this point people who are
experimenting people who are
trying this sort of thing there they're
seeing how much better it it's not
convincing their companies they're
convincing their project teams that it's
time to make a switch so if by the time
java 8 releases there are still people
who are who haven't learned functional
programming they'll by default be doing
it so it's interesting to see that we
don't really have a choice anymore you
will go home town see chef developers
already doing it yeah I think that's
really true when you see what they're
doing with the job at eight if you've
only been using job until now you'd be
crazy not to migrate as best you can to
this new way of programming because it
drastically reduces your code raises the
abstraction level to the right
components it's composable much more so
than the old style object composition
was so yeah it's sort of a no-brainer at
this point I think I'll say the thing I
know that you don't like to hear other
functional programming everybody thinks
is really good for concurrency when you
need to distribute your processes across
multiple processors you can you can do
that very easily when it's small
composable functions is that the selling
point for functional programs well I
personally think that since most
developers don't worry about concurrency
that much usually it's like the
specialized guys on the team that the
fact that most people are still are now
doing data problems you know whether
it's you have to do official big data or
something else that's where it really
for me the the value of concurrence of
sorry functional programming is just
pervasive because it's all just data
transformations which is ultimately just
math in some sense or mass if you're
British so I actually personally think
that it'll be big data that sort of the
killer app for functional programming
concepts may be more than concurrency
just from the practical standpoint
mass adoption I mean it's like this now
completely agree up I actually I find it
interesting that i never found myself as
his data person I never thought of
myself as really interested in the data
the transformations of the data because
there was all this ceremony with
programming you had to think so much
about how you model your objects lovey
blah but now that I'm thinking
functionally is so easy to just see how
this is all about data every piece of
programming is about data and what
you're doing to that data yeah you know
I've gone to that same transformation to
the last few years just sort of tired of
ceremony and tired of building up object
models in memory that are just going to
be obsolete anyway the next time a
feature change comes in and just being
focused to the point that I've got to
get from point A to point B with this
data really is i think the right way to
think about a problem and get you know
what's the simplest like they could
possibly work is that old agile phrase
and I think that really applies here and
for me it's driven life thinking towards
functional programming it's interesting
when you when you mention agile as well
like a lot of the agile principles they
just come with functional programming
things like the FC practices TBD do you
have to do teen easy anymore when you're
doing functional programming you you can
you can't in whatever you prefer it's a
lot easier because your functional
programming you because you can just be
so succinct and really talk about what
you're doing to the data it's a lot
easier to test it's a lot easier to
reason about I used to say that it's
just a logical way to program and then
actually a friend to correct avisas it's
not logic it's just reasonable it's
reasonable thing to do but it's not
logical that's reasonable right exactly
I think that reminds me of another
that I see happening having been doing
big data consulting for a bit now is
most of the frameworks that we've been
using weather than their sequel
databases are gonna do for very generic
really and people don't quite know what
to do with them they sort of know they
need something is kind of what we found
but I see an emergence of more
specialized tooling that doesn't just
say you should be in analogy here is not
just doing functional programming but
what are the particular problems you're
solving and how do these sort of
fundamental tools like functional
programming or no sequel databases or
whatever how do they actually fit a
particular problem like salt making
search easier or you know doing
recommender systems if your Netflix and
Amazon those kind of things so that I
think it's another trend where we'll
start to stop talking so much about the
basics of functional programming and
talk more about specific ways of using
it to solve specific problems if you
want to be talking about Mona's and como
announces as I kind of where you're
going we're going to go up more this
mathematical language well I think no
actually that's not what I was thinking
you in a way I think it's sort of
unfortunate that we got hung up on that
because it really confuses people even
though it's legitimate terminology it's
I think rich shaky mentions this to me
once i think is very true that if you
use terms that don't have any immediate
relevance to people and this is one of
the things patterns taught us give it a
name that's meaningful and unfortunately
the mathematical got a category theory
terminology isn't very meaningful to the
average person and even i have to stop
and think what some of these things mean
what's a group versus the field and
stuff like that but but I think no I was
thinking more in terms of I don't just
need a generic data framework I need
something that lets me represent
probabilistic data more easily into it
at least so that i can make inferences
on you know sketchy observations or
things like that i think are really kind
of a direction that we can actually help
people be more effective rather than
just selling this general tool like
functional programming but sell them
specific salute
chance to what to their problems yeah
we're not solving trivial problems
anymore we're not trying to solve the
crud out we're not trying to create the
next basic crud website we're actually
doing things like you said the
recommendation system a lot of the stuff
that Facebook is doing a lot of the
stuff that all the companies that we
tend to take care about are doing their
they're solving more interesting
problems and being able to tell people
facts about their data I think is so
much more interesting than just hears
from the next website yeah I think
that's true although I would say is
maybe sort of a counterpoint to that
that even the trivial stuff for the
mundane stuff if you can make it easier
for the average guy to serve gals and be
sexy to the average person to solve that
problem then I think you've actually
pushed the world forward I've been on
engagements where there was just way too
much you know management or you know
architecture or other sort of high-level
worries and concerns when if they were
just using the right tools it would be
actually easy to solve a problem and
that would just get them past that very
quickly save us taxpayer dollars in one
pc case but in general i think it's you
know we shouldn't forget that yeah maybe
it sounds boring to create the new crud
application or the new website
technology but in some ways I suppose
probably staring yeah we want to do it
faster we want to deal with like you
said without this MIDI bugs without his
knees security breaches so you want to
scale faster so that if I'm startup you
know building like you're the next
Facebook or whatever I don't have to
fret too much about how to make this
thing scale and be secure and all that
so yeah I think resolving old problems
it's not necessarily a bad thing but
there's certainly new problems that are
kind of driving this towards functional
programming towards more data centric
programming so two years ago at every
conference I was at every other talk was
about functional programming this
functional concept that function concept
this new language that in language and
now it's more about we've got guys found
out security you've got guys talking
about no sequel databases about
mapreduce problems large amounts of data
we're talking about all kinds of really
cool problem solving techniques as
opposed to just another language and
it's not that i'm bored of it as much as
I just think it's become a part of our
everyday life and it should be and if it
has in and you're still solving problems
in this really convoluted way that
you're lots of ceremony it's time to
start looking at something else it's
time to start thinking about you know
the other languages this isn't something
that's going to pass it it's something
that will come have it stay and then
something better will come hopefully
right I think that's very true actually
Brian mentioned something that's very
true that it's easy to criticize Java
for the you know certain aspects of the
way it is but it does reflect the
thinking about what's that what's a
state-of-the-art language of its time
and what are the problems that we were
working at in the other night mid 90s
and the architectures we were working on
which were like single processor
machines that were loosely networked but
not you know multi-core and things like
that so it made perfect sense and
they've done I have to say I think
they've done a brilliant job balancing
the concerns of backwards compatibility
and leveraging was already there in the
sort of that what are the minimal
additions you can make to a language to
keep moving it forward in ways that
address current problems without
sacrificing backwards compatibility and
that's been kind of exciting to watch
them go through that process even if
it's frustrating and it's taking a long
time and he missed that your Java was
kind of languishing for a while but it's
kind of exciting to see it go I love
that you're talking about problems that
problems it used to exist versus
problems that exist now right functional
languages as you know they were here and
they didn't really make much progress
because we have a hardware issue so
we've solved our hardware issue with
software now we have software issues
that we can easily solve with hardware
and we can move our software industry
forward now you we don't have a lot of
memory we don't have a lack of you know
we can just throw more hardware on any
problem it's a commodity yeah so we can
solve more interesting solve our
problems yeah so I wonder if and
thinking about how Jonah started up
javis torino mid-90s round time of the
world and it was influenced a lot by C++
and when I think about your average web
app your average API that you're hitting
that seems actually much closer to a
functional approach than it seems to an
object-oriented approach because you're
reaching it to something you're saying
here's some inputs go do something and
give me a response so it's actually a
better model for the future based on how
things have developed Simpson I actually
think you're right if it was so easy for
us to think we should have this perfect
model of our domain in memory and then
the sort of ugly stuff that happened in
the database or the ugly stuff we have
to do in the web browser is something
that we you know as quickly as possible
we converted that you know ugly side
into our perfect in memory model but
really it was just data flowing through
a system going undergoing transformation
some filtering and so forth and if we
just kept that model i think we had much
lighter weight faster performant web
with servers and so forth and we do
today yeah i think it kind of bounces
back and forth right that you're always
going to have people who want to
developers inherently won a lot of
things in a way that they understand and
until they get to a place where they're
really able to simplify what they're
what they're trying to write in code i
think we're going to start I don't know
I kind of disagree it's going back and
forth there are people who are still
trying to model objects trying to pass
objects you know through different
processes and it's like okay well this
is a hard way of thinking of it I think
myself and most people / time with you
included definitely you're trying to
make things as simple as possible in
that that's just it you you have a
process to transform it you pass data in
you get something out yeah actually let
me give you an example if maybe it's a
little threadbare in a way because it's
been talked about a lot but I think it
illustrates kind of this
automated between odd sort of the class
is called classical object oriented
modeling and this sort that's just gate
and modeling that is like how would you
represent a person object well obviously
the attributes will depend on the
application but more and more these days
you're integrating lots of different
systems each of which is around
conception of what a person is and so
you know it used to be when it was all a
monolithic system it made more sense to
figure out what person was and just nail
that down and that you know it was in
the object model it was in the database
schema but now because i might have you
know maybe dozens of different person
concepts looking through my system maybe
it's better to put that in a map or it's
in the attributes are key value here so
i can be more you know flexible and
resilient to you know this guy has this
attribute its name this over here and i
don't have this sort of hard coded thing
and I'm force fitting everything you
know sort of a sieve I'm forcing
everything to go through I'm just be
more adaptive for me I think that's one
of the compelling arguments for why
functional programming kind of fits the
problems of today where I focus more on
these composable data structures rather
than with less emphasis on you know just
having a specific ad hoc tight for every
concept in my system yeah it's something
else that really stands out is the
immutability of functional programming I
mean it immutability and functional
programming tend to go in and can't even
though they're not directly really they
don't have to be but I was in Richie
Keys talk about day Tomic and he was
talking about the temporal reasoning you
get when you never update a record in
the database how great is it to just
always right always add new records
right you change one one field you just
add a new record right and always be
able to go back any going time I to me
that seems like such an obvious fit for
almost all the persistence problems that
you know your bank history your medical
records I mean there's so many ways in
which that's really just the right way
to think about the problem I think so
what you're saying about
going back to the object model like
knowing the archetypical person example
where you have all these fields it kind
of sounds like you're describing
projections so you have some core data
and then you have a projection in one
area with certain capabilities and
projection of another with certain
capabilities do you think that's
something which aligns well with the
functional model or is it related to it
or are they orthogonal ideas and I think
that's a good way to look at it in a way
that you are projecting whatever view
you need on data in a way sequel is
really kind of a dumb down functional
model and a lot of respects because of
it despite what Eric Meyer said this
morning it does try to be declarative
which is sort of a functional style and
just say like I want to represent
relationships between data and then I
want to get this outcome of a query you
figure out how to do it it's another
kind of homework of functional and the
reason I brought up sequels because it
does have this notion of views or you
project out you know a view onto the
data that may not be exactly what the
data really is but it's a view that's
convenient for the user to work with
every reduction shows a fact those views
are really important the projection is
different for every consumer no to
consumers looking at the same so trying
to force it into a model that that
doesn't fit everybody's mean it's
impossible to meet everybody's needs I
mean I but we know this from any kind of
you know work in enterprise it's you
know you're trying to come up with a
schema that doesn't really fit everybody
speed I think this projections in
functional programming are absolutely
parative this that's why you do it yeah
and even his performance benefits if
part of that projection is filtering out
data that I don't need to send down
pipeline I'm going to get better
performance out which has gotten another
amazing thing that no matter how high we
will raise these abstraction bars we
still really gained a lot of benefit by
understanding performance that you know
we had this whole performance track of
people talking about what what is the
JVM doing you Mark Martin the Thompson
talking about you how do you optimize
data structures to be cache aware and to
understand to be sympathetic with the
machine is the term he uses so it's just
kind of amazing how we never get away
from that but we figured out ways to
still have higher level abstractions
that let's be productive without that me
to write assembly code so to speak all
the time I think as I said earlier I was
just so busy when i was doing
object-oriented code figuring out how to
make it work for everybody trying to get
across the entire enterprise making the
same schema model work and now i don't
have to so it just takes me to a place
writing thing about the performance and
as I'm learning about performing
algorithms it's it's changing the way i
think about everything that it's always
functional like completely accredit that
to functional programming I think you
bring up a really good point about how
that impacts architecture because I
think we've all seen these huge
monolithic systems where there was a
sort of God in the middle mid-tier
object model that had all knowledge of
all things and everybody went through it
for every service even if you were just
sort of following a little thread
through that whole mess you had to meet
everybody's needs you had to know
everything there is to know about a
person whereas in a you know more
data-driven functional style you could
literally write a use case or whatever
term you want to use just in a little
thread of code that just it's completely
agnostic about almost everything about
the domain it just knows what it needs
to know to like figure out their payroll
or figure out what insurance charges to
apply to their introductions or whatever
your stuff like those and then that
means you can char your processing into
separate services each of which does
something well the whole single
responsibility principle kind of
rethought so I even get just it's hugely
compelling from an architecture
perspective as well as just little
design decisions should make and I need
something that that makes it possible as
the immutability legitimately if you're
if you have all these systems changing
data you're broken you can't do it but
now that you don't have to think that
way now I don't have to wonder what your
system is doing to my data really don't
have to wonder what I'm doing to your to
your data it just it takes us to a much
easier place to reason yeah I think it's
very true that probably most of the
nasty books in the world are just spooky
action at distance where you tweak
something on a collection that I sent
you you know many stat traces ago and
then I didn't know about it and then I'm
wrestling with what happened and then
you know bug pops up as a result it's
fun to talk to the traitors they're
quite a couple trading firms here
speaking and they're talking about some
of their issues it exactly like you said
it's somebody did something that
shouldn't they shouldn't have done to my
data oops we're about Lucy's my codes
not performance and you've changed my
data and you shouldn't have but all
kinds of things that are always you know
if you would've just use functional
programming it would have been fun yeah
although as I said when they started
writing these systems they didn't have
the hardware to keep up with it we
didn't have the ability to I mean all
the bad rap the functional programming
gets mostly comes from problems that
existed in the past these problems don't
exist anymore yeah it was crucial to
solve for both to scale perform a
hardware performance but to solve like
data structure problems like the
persistent data structures that rich
Hickey made popular enclosure where you
know if I need to insert an element in a
and a list i don't have to modify the
whole list or make a copy i can actually
share what did change and that largely
solves these performance issues that the
immutability naively applied would cause
it's interesting because i hear people
say all social programming comes from an
older space and we've outgrown that and
then you start to think about oh my gosh
our industry is so me on most of people
who pioneered are in our industry are so
alive so it's like wait a minute how
much have we really grown in the past 50
years we don't know what what we don't
know yet so it's I think it's a lot of
fun to to see us sort of go back in time
relearn the same thing oh we've solved
those problems so I think we're not in a
place yet where we can stop thinking
about Oh what problem did this solve and
why did we go about this right it's
funny you mention that because ola did a
great talk this morning about cancer and
the cancer startup that he worked with
and montano basically molecular biology
is about the same age as software and he
said it's it's now starting to go
through big revolution and it's thanking
in part driven by sequencing machines
where now we can sequence genomes for a
few thousand dollars versus the billions
of dollars it cost me 15 or so years ago
so is it interesting that's another
domain is completely separate from ours
that sort of going through a similar
just a rapid growth spurt and rapid
evolution and everyone's we sometimes
think we've got it figured out and then
we have to step back and like no wait a
minute you will have been doing this for
you know a few decades and we don't
really even have it figured out by any
stretch of the imagination fifty years
ago do you think anybody would have
thought that all would be using seven
different seven or eight different
languages to solve his problem yeah that
would have been at burruss unheard of I
don't even if there were that many
languages fifth year so there might have
been nobody knew them hey sir I didn't
know you knew one yeah right you do for
trainer COBOL maybe list if you're a
university student or something you have
being able to put the right language the
right paradigm with the problem
sometimes we've been the exact same
application is really interesting it is
and you know it's funny too that's
another sort of sea change I've seen is
the idea of just working and doing all
your work in one language spending your
entire day in one ide or something
that's that's just crazy I cannot see
doing that
more every night I routinely pull out a
bunch of different ones for different
stuff if Assad you like may is the
language or bash or Java or scholar or
Ruby or something you just have to be
polyglot these days you know I've spent
almost the entire conference so far and
no sequel I mean no Hadoop sessions and
wonder where they talked about in almost
every session somebody mentioned you
don't just use one day to store anymore
you're using different paradigms of data
stores with your different paradigms of
languages and run it's really it's cool
to see how we're progressing into this
place where you can't have to be able to
think in multiple ways to solve to solve
problems you know in the most efficient
way yeah one of the things you're asking
reminded me of a story with other ebay
or amazon with your doing their
architecture where every single feature
or group or sub portion of the site
created your own data their own silo and
everything the replicate stuff from
other users no matter what i first heard
this I thought that's insane that's
completely nuts but it seems like that
kind of approach actually isn't quite so
it's a particularly perfect me if it
protects you from mutation such you know
named John Boehner embed absolutely
everything that I've heard over my
entire career in software everything
I've heard that's horrible that has
suddenly become okay again and it really
is just okay so I don't want I don't
want you touching my data I want to be
able to have complete control over what
you're doing with my data to ok I will
do whatever you want just don't change
anything in a way that's going to be
going to affect me I even things like
unit testing Lee we went from a place
where one hundred percent test coverage
to eight percent test coverage to really
it's just a it's a insurance policy and
do what you need to do we're almost
getting to this place of a git er done
work mentality whatever it takes that
doesn't mess up what im trying to
the same data really is fine I think it
breaks up the point that you really
should always question your assumptions
because there's always benefits and
disadvantages and sometimes they're
actually really are benefits to
denormalize data or making copies of
data but you just need to know what
those are and then make that that
calculation that you know what's the
right thing to do but it's what you just
said to if you make the code small
enough all of our software development
problems basically go away if I turn a
neo a massive three-tiered java
application it's you know 20 lines here
20 lines there or whatever now it's a
script you know I don't care about all
the usual ceremony we used to go through
and if it sucks i'll just throw it away
right about the women you know tomorrow
or whatever so it's amazing how even
scale the scale of things changes
dramatically and changes how to eat your
whole approach to problems sometimes
yeah i think conventions are really
coming into play with us as well like
there are so many different places where
i used to have to think about what i was
doing as far as the api for something
now it's just its standard everything is
standard any collection you have I can
call us or any collection you have I can
call you know x y&amp;amp;z different functions
on them and I know what I can do just
based on the fact that everybody else is
it so I don't necessarily have to think
about these lower level things as long
as I know that all of my different data
structures have that ability I think
some of the things that we've been told
for a long time there they're coming
back but we're still going with this new
thought process of convention of
configuration and all of the insurance
policies that agile needs you is it's
really all starting to come together and
I'm excited to see where we are 10 years
from now yeah I think that a lot of
these ideas can come together things
like the new graph databases
the temporal reasoning and all of this
stuff do the our algorithms are going to
get more sophisticated and simpler at
the same time yes I think you're right
it's funny we have gone through this
process in the history of software
development of finding are trying out
ideas of abstraction or design patterns
for lack of a better word and some of
them eventually fall by the wayside and
others just turn out to be really good
ideas that will last forever like these
fundamental operations on collections
like sorting and grouping and filtering
I mean those are never going to go away
I'm going to go out on a leaf on a limb
here so those are never going to peers
from now we're going to be sitting here
again Oh nobody uses those anyway the
old school but milk but if that's that's
kind of an exciting aspect to watch this
how is forcing you to rethink what your
sacred cows as well as trying to ask why
is it that this seems so fundamentally
useful and probably will last verses and
why did this idea seemed so good at the
time that didn't actually hold up it's
always a really interesting process of
reflection I think to go through yeah
making complexity looks simple its
really you know where we are right now
what what's the theme of next year Yeah
right and a lot of it is of course
driven by what are the problems for
solving today that we never saw before
or which ones that we solving again that
we solve in ten years together or
whatever yeah what's broken what's
broken now an accident also asking
yourself dude that's good asker's up
what's broken like you get so used to
things that really are broken or it
could be a lot better and you just never
stop to think there's got to be a better
way than this Eric Blair pointed out di
pensee Direction fruit and it would have
first started everybody's ODI
yeah this is the greatest thing ever and
really for anybody who is thinking I
know not anybody was thinking but
anybody who is thinking kind of
critically about that situation they
were saying why do I have to go through
this extra process there's something
wrong here if I have to go through this
there's something wrong and then they're
all the the functional programmers came
out and said wait this is ridiculous you
don't have to do that here for it we
have better ways of doing this so it's
fun to hear all of the speakers talk
about all this is you know this was
great two years ago now horrible well
it's a horrible because our problems are
different yeah you're right it's always
horrible and context or right in the
context I guess when bug number one gets
eliminated but number two gets a
promotion ready and then sometimes we
come across plug number three and weary
implement bug number one yes then you
know all developers are architects they
have to be if you're writing code you
are architecting something and the
definition of architect is defining the
trade-offs understand the trade-offs and
making decisions about them right
certainly that's one of the things that
comes with experience is being able to
think a little globally even when you're
touching some something locally and what
are the global implications that's an
important skill right and it's stuff
that I don't know that they teaching
University but you know I'm not sure you
can either some things I really don't
care if they don't teach because you
just have to be in the real world and
find the right mentors to teach and what
it's really like it my personal view for
a little off track maybe is that
university should focus on these core
principles of data structures algorithms
you know it kind of stuff enough worry
too much about trying to teach them how
to do software development because but
their teachings going to be obsolete in
two years anyway so right i think it
goes back to another conversation I
hadn't bar earlier with Aaron bed right
he was talking about security and I my
feathers and I were
asking what are the right questions to
ask michael is saying that you should be
thinking about this when you're
designing your code you should be
thinking okay well what are the security
breasts and I said well we have to know
the right questions to ask before we can
start to sign that way I think it's the
same thing for this knowing the right
questions if University teaches you how
to ask the right questions you can find
the answers and we do legitimately if
you can't find the answer that means
you're inventing something new and
that's even better right but for the
most part I mean a lot of the things
that we're doing you can find the
answers you just have to know the right
question ass yeah so for me what I found
most valuable university was learning
how to learn it was treating your brain
like a muscle so you learn about
something you haven't learned before you
learn in three months such as you become
an expert you can pass the exam and then
you forget about it you completely
forget about you go on to the next thing
you learn that you're not getting
consultant you learn to become a
consultant and so it's that ongoing
process of learning and that's because
of what we do building software because
it's this cause of discovery process and
the technology is constantly changing I
feel like that learning really really
helps because that's what we're doing
our whole lives if we're not sitting in
a cube said we're trying to become an
expert on Siebel wrote it that's how you
become post technical right you stop
learning to learn new technologies such
a hard industry to a break into and be
stay in ever ignored want it was a
linkedin article the other day that said
something like as you get older as a
software engineer your pay should go
down because as you're young and you're
really interested in learning chances
are you're out there learning something
new like you said every night to study
for that test or to fix that problem at
work that you didn't quite understand
you what during the work hours and they
said well it's expected at this point as
you get older your salary will go
because they're not going to continue to
pay more and more and more to stop
learning right I do think that's really
good advice in general is if you feel
like you're not learning anything in a
job then you should really be paranoid
about your future yeah I remember when I
first moved to Chicago it was with the
telecom startup and it was a few years
after sort of the meltdown of the dot
bump sector or whatever and including
telecom and there were a bunch of guys
that came in were about my age who had
been writing you know like C++ modules
for telecom switches for decades and he
kind of felt sorry for these guys but
they were so stale that as a start-up we
just could not bet you take a risk on
these guys even though you knew they
really wanted a job again well there's a
standard right like there's the people
who are doing exactly you're talking
about they're just going to work every
day doing the exact same thing over and
over again essentially could be working
at a factory right doing the same thing
over and over again under tight
management and then there's people going
to conferences and learning and reading
books and writing books and you know
going back to school and taking new
Coursera courses I mean at this point
you don't even have to pay for classes
just do it go online and you can
register for your some kind of wicked
cool machine learning course that's
going to teach you new new ways of
thinking about your data if Bob Martin
had a really interesting comment once
about the whole issue like how many
hours you should work a week in his view
was that you really it's not fair for
your manager to expect more than 40
hours a week just on average but you
yourself should be allocating more hours
each week to you know learning on your
own
advanced in your knowledge and so forth
it's just you know you're investing in
your career in that way and I think he
was right about that that you know you
can't really expect your manager to be
looking out for the long term and the
forward-thinking ones will but it's
really up to you to take ownership of
your career in that way and to keep
learning point I think that there are
people who just think that way by
default like we are out with you know
when I'm around with my niece is in my
nephew my nephew's I'm thinking like
what what problems do they have how
should they be solving and what kind of
new innovative things could they be
doing and it's not about it's not about
necessarily reading a book it's about
just thinking outside of what you
normally think of throat and you know
you don't have to be going to class to
do that you don't have to be going to
conferences to do that you could just be
solving your problem at your desk and
think oh well what's a different way why
am I solving it this way to start with
and is this the most efficient most
effective way should I be doing
something else we have thinking outside
of the box yeah maybe that's it that's a
certain attitude that yeah and that's an
important skill to develop because our
natural tendency I think at least for
most people is to just fall into what we
know and what we're used to doing and to
actually force yourself to step out of
the zone and think of it in a different
way it's a really valuable life skill in
my view yeah it certainly shouldn't have
to be you know industry-specific you're
absolutely right it's a life skill
everybody should meet again another good
life skill is knowing a good man hat and
I must say we all go there so I've heard
that described as beginner's mind when I
look at something as if you're looking
at it for the first time yes it's easy
to get into the perspective that you
know what you're doing everybody knows
what they're doing because you do it all
the time and I think also with
functional programming it's easy to to
get into a place where you think oh you
know all about the different functional
concepts it's like okay I know what
monads are no
it's our I know map are doing all this
stuff and then forcing yourself to get
out and read papers and say okay well I
don't know everything the time you think
you know everything is it time when
you've bought stale yeah that that's a
really good point because the more I
learn the more I realize they don't know
and i know that's a good place to be
because that means that I'm actually
actively engaging to learn more yeah
that was my talking speaker compass yeah
I said well the more I learned the more
I understand that I don't get help and
that was part of the great part about
university is they taught me so much
that you know you come out and you think
well at first you think you know
everything but then you start working
and it's like oh my goodness I did just
cram for this test I didn't know what it
was talking about when I answer those
multiple choice questions so I have to
learn a ton more and it's having that
that well-rounded ability to tax all
right questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>