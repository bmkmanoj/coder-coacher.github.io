<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • When should you use a Serverless Approach? • Paul Johnston | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • When should you use a Serverless Approach? • Paul Johnston - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • When should you use a Serverless Approach? • Paul Johnston</b></h2><h5 class="post__date">2017-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1fBbSgJJV_g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well thank you very much I'm the kind of
person that likes to walk around a lot
so if you see me on various different
bits and don't be surprised I also get
quite excited by serverless
technologies which might be a little bit
strange within a tech company and tech
situation but that's okay a little bit
about me I am a CTO I've been a
consultant CTO for many years and I
chose to join a company called Mo vivo
which you will probably not have heard
of because we work primarily in the
developing world and in emerging
economies rather than in the Western
world so we don't really talk about what
we do but we have been using a service
approach for 21 months now so nearly two
years and we've been using AWS lambda
and doing a bunch of things around those
technologies to try and make them work
as a back-end mo vivo is is actually a
very small tech company so there's five
of us at present we're just about to
scale up to nine we're looking for
various different people at the moment
but it's quite difficult because you
can't really put on a job description
we're hiring for service people because
they don't really exist yet but we have
various different large deployments
mainly on AWS lambda which is we have
select quick quick aside we have one ec2
instance in our entire stack and we had
half a million monthly active users last
month so we kind of if you imagine that
we don't have the kind of normal world
that you live in then you're probably
right when we started I started it was
Greenfield there was wasn't anything
there in terms of service and the
project started with an Android app and
and lots of ideas but very little else
and I kind of came on board and said
well I know that there's this technology
called AWS lambda and I think it's
pretty cool
and the everyone else was kind of
looking at me going I don't know what
you're talking about
doesn't make any sense to anybody why
don't you just do the normal way you
know Django rails Heroku or something
like that
and we kind of just sald around that for
about a day before I went I want to do
it my way
now just to quick aside again now
serverless technologies is a kind of
catch-all term for various provided
function based services it's not the
only thing is it's not just lambda
there's lots of other ways of doing it
but my context is AWS lambda because
that's what I know it's not to say that
there aren't better ways or different
ways of doing these things and different
approaches that might work so all I can
do is give you my experience and talk
about that so if you want to leave now
that's my answer to the question which
is when you should use service
technologies and maybe there's a little
bit of a kind of you could but I think
that if you look at the idea of what a
cloud native is now and if you look at
the idea of how people are evolving
their use of technology within startups
and within larger organizations and
where things are going I think we're all
going to be looking at things like AWS
lambda function as a service over the
next few years as being where we're all
going to end up I think we are still in
a kind of pioneer phase at the moment it
seems like it's a long way away but it's
actually things can be done now but
there are some issues with it so what
I'm going to do with this talk is
explain what I see as a service approach
it may not be what you think it is it
may be exactly what you think it is I
don't know but we're going to talk about
what the service approach looks like and
then we're going to talk about the
scenarios where you could and couldn't
use it they kind of come at the end and
they're like the last five slides so you
know we'll get there but we kind of need
to talk a little bit about the
technology because it's a it's a term
that nobody really understands so when
you start looking at service one of the
things is kind of quite obvious
you don't have servers or you sort of do
it's just somebody else's but you
replace the idea of a server and of
something that runs some code with
function as a service which is what fast
means and you also instead of having
maybe containers or instances or or
using relational databases you actually
you intentionally use services instead
of running your own that's kind of the
the whole purpose of services to kind of
remove the the need to manage and
maintain anything and utilize the skills
that exist in the cloud providers and
everywhere else and there are there are
various other elements so often newer
you're looking at it being event-driven
lambda is run by events and its kind of
the key to running systems there in the
first place so it's a it's an
interesting different way of thinking
about it you automatically have to think
distributed it's a different approach to
let's run this code in this little box
and we'll call it two containers it's a
different way to think about it it's
inherently more scalable so well it's
inherently as scalable as your cloud
provider or your system can allow but it
it's because it's distributed and
because it's contained in different ways
you actually end up with a more scalable
system and the bottom ones actually
quite an interesting one um we actually
have come to the realization probably in
the last week or two that going down a
serverless route is more about ops than
it is about dev and actually you need
the devs to think much more as ops in
the DevOps world than you need them to
be developers so it actually changes the
kind of people that are approaching this
and the kind of people that you should
take on to do these kinds of projects
and it also changes your focus in the
way that you have to approach the
problem and I also would say it's as I
think I said before it's it's the
bleeding edge it's really right at the
edge of being what we would call cloud
native which is where I think it fits
for this for this talk and for this
track
I kind of would say that because you
know I like to think I'm always at the
cutting edge but I'm not always but it
is where we're going as a cloud native
group so one of the other ways I explain
to people what service is is it's kind
of super advanced cloud you're actually
basically diving all in and going we're
gonna use functions we're going to use
events and we're going to use every
single service we can to avoid having to
do some of the ops problems we have now
that's kind of how I try and explain it
to people who who are not so sure and
now you may have heard of something
called the service framework hands up if
you have this is interactive there's
eight of you really only eight how many
of you have heard of the service
framework ten okay so we kind of have
this problem within the service
community which is there is a thing
called a service framework which means
that everyone who's looks for serving us
thinks that it's the service framework
it's not it's not the only way of doing
it there are various different
approaches there things like apex
there's things various other bits I
actually wrote a blog post last week in
last week last year in which I said
service is just a name we could have
called it Jeff and to be honest that
normally gets a laugh but you're all
okay so the name is just a name is just
a look to hold on to we are not talking
about the service framework here we are
talking about the broader approach so I
I kind of want to be able to tell you
all of the times that you should be able
to use it so you don't have to think too
hard but actually I think that wouldn't
help you because service is going
service is a different way of thinking
so I kind of need to explain the
approach get into the detail and then
give you the the background and what you
can do with it so this is one of my
favorite slides simply because it says
that containers are the way we used to
do it the we have always kind of looked
at the way we develop systems as being
about a server at
an entity that is a Linux box usually in
some form either it's physical or it's
virtual or there's an instance within a
bunch of other within a physical server
or or there's something else there's a
thing and they're all servers in the
same way and and that kind of causes
some problems as you're going forwards
you kind of think a little bit about you
kind of approach a problem with the idea
that you have a server there every
single time now if you do that actually
the leap to service is quite difficult
because you end up not not having your
mind in the right place you end up
building a small server over here on top
of your function as a service and it
isn't quite how it's meant to work and
you kind of have to understand the
technologies to use them properly and
what we've had kind of over the last 15
years is a bunch of people explaining to
us that actually the best thing to do is
build a framework of some description so
for web it was something like Django or
Rails and we stick that on top of a
server solution so we had eventually ec2
instances and then Heroku came along and
just chuck your code onto here and we
all sort it out for you and we kind of
haven't really changed the way that we
approach except in high end startups and
enterprise level situations so there's
actually quite outlier cases the
majority of people who approach tech
approach it from the point of view of a
server it's quite important that
actually that is the key because it's
also a problem which is that you end up
having to maintain things you always end
up somewhere down the line having to
maintain a server and it's not so much
fun I've worked for a an ISP 20 years
ago and I was a sysadmin and I can tell
you that that what we used to do back
then in terms of patching servers and
sorting stuff out and having to fix
problems is exactly the same things we
have to do now we haven't actually
changed very much we've just
commoditized the process of doing it and
we know exactly so when you say we're
gonna have 20 containers or whatever you
know exactly what you're going to have
to do in
terms of operations to keep those
running to manage the maintain the
security um when you also build these
things you you you're also looking at a
server which isn't you know the system
is invariably a monolithic well it can
be small and monolithic but it's a
monolithic system because your testing
process goes we're gonna build so it
works in this way and then we're just
gonna drop it into this other
environment and it should just work
exactly the way we think and the problem
is that you end up with two things and
that's entrenched thinking you end up
thinking the same things and actually
you look at something new and go well
that can't work and that needs to be
kind of wrenched away to get people
anywhere near service but also the
long-term cost of operating and managing
servers is is actually quite a lot
higher than you think next time you go
back to work start doing a little log of
how many of the things that you do are
actually server maintenance things and
you will find that you're losing an
awful lot of time it's not necessarily
that they're bad things is just
identified that making the choice for a
server can actually be a negative one in
the long term so when you go towards
service you look at function as a
service you're looking at infrastructure
and infrastructure as code and things
like that and your cloud provider
providing systems and other services not
just your cloud provider services but
third-party services so logging maybe
there's some specialized services in
your industry like fraud prevention that
kind of thing and all of a sudden you
end up with having to manage this
greater complexity and you are actually
a lot more reliant on those third
parties for the delivery of the system
now when you basically put your system
onto a cloud one of the things if the
cloud goes down if s3 disappears because
it never does that
if s3 disappears then you end up with a
system where all of a sudden the
knock-on effect can mean that your
system goes down and that's that's not
what you want but actually I can tell
you that the majority of times when I've
run servers things go down and awful lot
more than when a cloud provider goes
down so do you kind of
worry about that but the thing is you
just got to worry about you know what
your users are going to think if
something goes down can you provide a
failover can you think about those kinds
of things but it's it's a it's a thing
to remember and I'm always I'm all about
the reduction in maintenance I'm all
around all about the long term total
cost of ownership of the system but
service is still a very new way of doing
it and and I know that there's a lot of
hesitancy I'm just trying to decide
whether I need to speed up or slow down
is this going too slowly or too quickly
okay yes good you're good good okay fine
mmm so service is still very new it's -
we are in the pioneer phase at the
moment there's a bunch of us who have
jumped on them on this service bandwagon
and are doing bits and pieces but there
are actually very few companies out
there doing any of this which is why
even a small company such as ours is an
interesting case study for other people
and because this the community is so
small that's why they're going out and
doing all of these talks even though
we're not trying to sell you anything
and the thing is that actually the
patterns are not emerging yet we still
don't know exactly how to do all of
these things we're still guessing we
still talking we're still playing the
community is ready to be shaped by
people who jump in and have a go
so I'm just kind of advising you to have
a look at it and I would say that scale
is easy and hard all at once you end up
with the ability to go like this very
very quickly without having to do
anything our systems basically went from
a few thousand users to five hundred
thousand users without really changing
anything core at all it just went and
that was because our service provide but
then we also then have to manage the
complexity of the systems and that is a
problem I've spoken to a lot of CEOs
about this I have had pretty much every
question you can imagine I don't know
all the answers quite happy to have a
dialogue with you but actually the best
questions often come from those pioneers
if you're not really playing with this
and asking and you're just asking
questions to find out if it's worth
playing with I'm going to say go away
have a play and then come back with the
questions there are lots of tutorials
out there to show you
and it's worth having a look but CTOs
are kind of the right place to play with
this it's an interesting technology so
what I'm going to do now is just jump
through the various different bits and
give you some pros and cons so the
function as a service is everyone who's
played with AWS lambda or one of the
other ones good a few of you it's it's
been around since 2014 but it's still a
very new idea in most people's minds
because it's so different there is no
straightforward analog to your systems
that you run now with servers which is
why it's a little bit different a thing
is a friend of mine told me it's a bit
like crack which is you try it once and
then you try it again and then you try
it again and all of a sudden you can't
go back to doing it the previous way so
I do kind of you know just tell you that
that happens but as I said we're still
in a pioneering phase there's some
really interesting things that you can
do look at apex specifically I think
there's some really interesting work
going on there but also the other
technologies around Apache open wisk is
very good for on-prem kind of stuff
around this so there there are services
out there that are worth exploring now
the advantages very much are things like
cost our costs for running large-scale
systems are tiny I can't tell you
exactly how much they are come and asked
me afterwards I will tell you off the
record but you would be amazed how
little we actually spend we also have to
think about decoupling logic it
encourages you to think about things
distributed Lee you end up having to
design systems in a different way and
one of the real advantages of using
function as a service is your errors are
actually contained within your system
you own if your errors it doesn't take a
whole server down so instead of having
something happen on one server that then
drops the whole thing it then goes on to
another and drops it then eventually
your system goes down lambda basically
takes an error it's the one tiny bit of
the hole and that one tiny bit stops
working and it's quite nice when that
happens because you can fix that bit
without having to affect anything else
you also get the scale all based upon
how your provider does the scaling and
it's really useful you can go from small
to very big from the very beginning
there aren't any really bulky frameworks
out there and what I mean by a bulky
framework is that if you actually have a
look at the majority of systems out
there things like web development based
in Java or in Python or in Ruby or
whatever you actually look at the amount
of code you've got there you're actually
taking an extreme amount of technical
debt into your system now it may not
feel like it because it's an open-source
system and it's fine but actually you
are you are literally porting technical
debt into your systems you may be able
to fix it they may be able to fix it but
actually you never never quite know so
once you take the idea of frameworks
being reduced and actually using
function as a services your core logic
and minimizing your library usage and
things like that you actually end up
without that bulk and without the the
loss of those the introduction of
technical debt so one of the things that
we do a lot with is events and queues
sometimes we can look at this as
messages and message queues and events
of what we call them within the AWS
world now interestingly when I started
talking about this and talking about
serverless and how it works one of the
first people that came up to me was a
this old guy in his 60s gray hair starts
talking to me about we've already fixed
all these problems and I said what do
you mean and he said well we already
fixed them in the 80s and he said
because we had small things that we had
to talk to each other and we had to
figure out how to make basically lots of
small bits into a distributed system but
that's a hardware problem and he said
that's where we have the point that's
where we've learned to do all of these
things so I would suggest if you if you
have any hardware people get them to
learn some of this stuff it's worth
doing it's now you might have heard that
doing AWS lamdaur similar is a
microservices approach I would actually
disagree I think it's different and
subtle but it's very different because
it'll come I'll come back to this later
but essentially the error bound the
error boundary is different within a
micro services system to within a lambda
system and there's probably more things
to talk about later but it's not the
same thing anyone that says it is I
think they're wrong
for a lot of people this feels like a
backward step but when you start using
the ideas of events and cues and dead
letter cues and queueing things you know
FIFO cues and all of that kind of stuff
you actually end up being more efficient
and you end up having a more resilient
system it's more complicated to do but
it is more resilient and actually you
can find that it's easier to switch out
parts of a system so if something isn't
quite doing the right thing it's
actually very easy to switch one bit out
without having to change the whole and I
think this is the key if you can
understand this and actually a lot of
people will understand this it's just
that they won't necessarily use these
words and naming conventions I think
this is the key to using serverless
really well function as a service is
nice it's just small bits of logic but
using events and cues going back to that
idea I think is key now when we talk
about data
most people will look at this and go
well you'll just we'll just use a
relational database and we won't worry
about that I think that's the wrong
approach when you start to do something
service you're thinking about scale from
the very beginning and when you think
about scale from the very beginning
relational database is actually cease to
be useful
they're good up to a certain point and
then you just have to chuck more and
more stuff at in there manage more and
more stuff and you start to have to
really think about things like read and
write what are you optimizing your data
for why are you doing it data-driven
design becomes really important at this
point and actually you can end up with a
scenario where you actually have
different databases to do different
things and they scale for you so we
actually have for example we have
DynamoDB as our right database and then
when we want to do a bunch of read stuff
we push it all into s3 and we do
reporting on it we push it all interests
3 and user Athena now they're things you
may or may not have ever heard of but
essentially they are recognizing that a
relational database is a
one-size-fits-all approach to data and
what we've done is go well these
different bits they need that kind of
data maybe it's a right system and these
kinds of bits
they need read and these kinds of bits
they're reporting bits and we've split
it up and it may sound like more of a
nightmare but actually it means that the
system works the system works much
better the other thing is that actually
it's very much more easy to understand
an identified data in rest and data in
motion data at rest and data in motion
purely because you are you actually
limits the amount of data you have and
you're not trying to do everything with
one system so I think the data actually
requires you and to think more
distributed and it's it's an interesting
problem to have but it's it's really a
fun one to to grasp actually so um as
you can probably understand one of the
big things is around this is these not
servers forget those until you need them
just understand that this is an
infrastructure as CROs code problem so
for example you can use nowadays you can
use cloud formation on AWS the cloud
formation wasn't very good when we
started doing it which was a long while
ago and so we picked up terraform
terraform has been brilliant for us and
terraform is how we run our systems and
how we deploy and how we do a whole
bunch of stuff around infrastructure and
I think if you actually looked at our
terraform you would actually cry and go
oh my goodness this is enormous because
it it just has to encompass the whole
thing but when you realize that it's a
distributed system you realize that
actually they're all uncoupled from each
other and it makes it quite a lot more
understandable it's just that we don't
really have the tooling to do this
client yet and DevOps is our kind of it
changes you you're developers have to
learn more ops and your DevOps people
kind of get subsumed so it becomes it's
more of an ops dev not a DevOps problem
over time because your ops becomes
bigger interestingly we found that
actually it's easier to train people
it's easier to hire a junior and then
explain to them about infrastructure and
then say now use the code that you've
learned you know your Java and your
JavaScript the code you've learned to
build little bits of logic but build me
a system and they kind of an it seems
that they
understand it's a little bit more if you
take out the idea of everything's got to
be a server and you start thinking
distributed Lee it actually becomes a
much much better problem for someone who
is new to try and understand it I can't
quite put my finger on why but it does
seem to work one of the things that is
difficult is that it is harder to test
we will come on to that in a minute but
essentially yes
testing is very very different because
of the moving parts because you can't
really test on a live system in the same
way and you can't do what you can do
with containers which is you know have
them running on your own systems it
doesn't quite work that way and kind of
talked a little bit about security one
of the big useful things is you're
actually you're you're handing over part
of your security problem to the provider
so we use API gateway for example for
all HTTP interaction to lambda so an api
gateway does it does a lot of jobs that
i don't need to know worry about such as
denial of service and managing those it
you know provides you with looking after
your various cookies and load-balancing
and all that kind of stuff it does a
useful job in that respect and it means
that you don't have to maintain and
manage and it's not a server approach
it's a different approach it's a service
approach I think when you look at
security as well one of the things we
use is AWS kognito does anyone used
Cognito anyone heard of Cognito two
people three four excellent
so a few people and Cognito is just
basically an authentication
authorization service that works with
AWS is authentication management
identity and authentication management I
am and what it really means for me is
that I can say right we're just going to
set up a kognito pool over here people
can log into their Cognito pool and
automatically they are a user and
identity within AWS that I can now limit
its interaction to just the API gateway
so instead of having to give it a server
with HTTP access and all of these other
things
all we do is go well that that person's
identity all they can do is this one
layer and that just touches on on small
bits of code small bits of logic in
lambda so it just makes the security
much much tighter and much less able
like you don't get think where you can
but it's very difficult you don't get
things like hacking attempts in the same
way there are different types of hacking
attempts they're probably better because
all of the containers that run the
lambda are short-lived
so you end up with a lot of security
built in which is really useful
deployment tools I've kind of talked a
little bit about this already there are
one of the things we found is that
deploying is pretty good it's alright
it's exactly the same you can use some
of the tools you can use terraform you
can do all of these various different
things and you can create the same kind
of CI CD pipelines that you can do
elsewhere but one of the problems we
found recently is that because we have a
large number of lambda functions if a
deployment for whatever reason goes
wrong partway through and it can just
because it's a distributed system you
can end up with half a system and half a
system that are out of sync and then how
do you then upgrade and deploy something
that's correct
and it's very difficult also things like
which staged deploys is basically what
I'm talking about it's actually very
hard there aren't the tools out there to
do it so we don't have the full set of
tools to be able to do all of this at
the moment also canarian blue/green
deployments you kind of have to roll
your own because the way that all of the
service providers have built lambdas is
so that you don't have this thing that
allows you to route temp center traffic
over there in 90% over there they don't
have that and also you have to do a lot
around service discovery so the first
conversation I had when I got here was
about service discovery as a problem and
I think you actually end up with a
bigger problem with service service
discovery here and the idea of service
meshes and I've kind of written a thing
about event routing so you can have an
AR n DNS like
scenario so that might be able to help
but we are in the middle of trying to
figure all of these things out but for
the majority of systems you'll be fine
with the deployment tools that you've
already got
but it's not a perfect system testing we
have within the server world testing is
some kind of a solved problem we know
what it is we know we do TDD we know it
all of these other things when you move
to a distributed system testing becomes
a slightly different problem simply
because your testing is different it is
very different now you can do amount an
amount of unit testing very easily
that's just small bits of logic in your
lambdas when you do integration testing
you've kind of got to do a lot of
mocking it's very frustrating because
you can't really run it unless you've
run a whole staging environment that
looks exactly as your production
environment but even then you can get
caught out and the really interesting
thing is I wrote I wrote another blog
post about this there is I think there
is a sense that testing becomes
different and possibly easier it's the
fact is that you can actually do unit
testing on a lambda function and then do
whole system end-to-end testing and
actually the bits in between because of
the test boundary around lambdas is
actually a lot different you don't have
multiple test boundaries it's it's a
it's something I can talk to a little
bit more about but actually it's a it's
an interesting point two testing is not
necessarily better or worse it's
different
I think it's possibly a little better
but we don't have the tools yet and
really you need infrastructure as code
to be able to build your production
system in a different count so that you
know that you can at least test to a
point with your production environment
so it's it's difficult but there's
coming um as I said earlier people I
think onboarding people into the system
I think it takes a takes a few weeks to
kind of get your head around this but if
you take someone who hasn't had 15 years
of working with servers and working with
large code bases and big monoliths even
if they're small monoliths in micro
services I think it's actually easier so
possibly junior and mid-range people may
actually end up being better at this
because they haven't got the baggage of
the large systems and also because
you're building small bits of logic you
end up being more productive more
quickly so while this is you know
not we're kind of going around the whole
thing of service at the moment and now
let's just kind of have a quick pause
big thing everyone talks about because
you are basically using services from
one provider in Europe you basically
jump all in and there is vendor lock-in
however I would argue that for the
majority of cases and for the majority
of systems vendor locking is not a big
problem the problem with vendor locking
is that if the vendor decides they don't
like you then you know you have to deal
with it but if the vendor doesn't like
you I think you're not doing a very good
job anyway the the problem with vendor
lock-in here is that you are building
lots and lots and lots of things on lots
of different services and actually you
can have third-party vendor lock-in you
can have you know your analytics maybe
somewhere else your fraud prevention may
be somewhere else your whatever you can
have different types of vendor lock-in
whatever you do you just have to work
out whether the trade off of having
someone build the systems that you want
is the right one for your company and
most of the time I would suggest
certainly within a startup environment
which is where we are I we wouldn't be
touching it with a bargepole
we're just going to get someone else to
take the load off and in the future if
we want to do something cool and clever
and new absolutely we'll build it
ourselves and we'll spin out off off the
vendor that we are locked into but I
think vendor locking is a little bit of
a a red herring is a thing that really
shouldn't be worrying about you should
just pick a vendor and get on with it
so the one big thing about serving us
for us is that you don't have to
maintain very much you have to maintain
the infrastructure as code obviously but
your code base is significantly smaller
it's also much less coupled your if you
don't do synchronous calls between
lambda functions between functions or
service systems then your your system is
actually a lot less coupled than a
normal system would be it might be
hundreds of functions but because
they're less coupled there's not going
to be follow-on errors and taking heart
big bits of systems down and also you
don't have to patch anything and you
don't have to I've already said this but
you don't have to patch anything you
don't have to worry about security
updates that provider does that for you
and trust me
that's a really nice thing especially if
you're a start-up because you can just
push it out and not worry about it
in 21 months I have had to deal with
technical problems of an evening or a
weekend I think about three times three
times in 21 months we don't have we
don't have the same kind of issues we
have different issues we have other
problems but actually I prefer having
those other problems to having to
maintain servers just not need it
anymore
so kind of this is my kind of overall
kind of pros and cons I'll let you
figure that one out I think there are
some really good big things but I think
we aren't there yet it's still
pioneering territory for service and
we're still not there here so where
should we kind of go from here so I've
kind of given you a broad overview of
what service is and and kind of the next
bit is well tell me how to use it tell
me what systems are going to be good for
this so most of the time I would suggest
it is an appropriate solution for
client-server environments I don't think
is difficult to take it on I don't think
it's difficult to even do a small thing
I actually think it's really good for
workflow management as well so when
you're trying to do so you if you've
ever seen anything to do with lambda or
or any of these functions or service
systems they have a a tutorial where you
chuck a file into something and then
they do the two changing it into various
different sizes and putting you
elsewhere and I don't think that's the
best use case but it's pretty good for
explaining how to do various simple
things I know a company that does virus
checking on every single one of the
emails that comes into its system so
they get their email into a system chuck
it into this and then they use lambda to
virus check whatever the attachments are
and then they say yes or no and then go
from there I think that's a useful what
you know that's a behind the scenes
workflow use case I think there are many
different ways of doing it I can't
really give you all of the systems but
as I say there I think that 99% of the
things we do as technologists so I think
I probably you can do them in service
however there are some problems with it
now when you have a
a solar system essentially what you're
doing is running very very small
containers that are very very quick to
load so recognize that they're still
going to possibly be if you're cold
starting there's going to be a short
time depending on the technology you
choose Java is quite slow to load up
node is remarkably quick to load up also
if you're using something like an API
gateway in the way then that will add
some latency into the system so if
you're looking at something for a real
time system probably not the best
approach
however I would again suggest that the
number of times you actually need true
real time systems is limited to a bunch
of very specific use cases in a bank or
somewhere like that
and so you can probably still get away
with it most of the time in any kind of
request response scenario in mobile
which is what we do the network is never
going to be very good and perfect so we
can always get away with a little bit of
latency anyway it's not a problem for
our systems now compute-intensive one of
the things that you can't really do is
is start up a function as a service
function and do a whole bunch of things
very compute-intensive
because you because they limit all of
the service providers limit the size of
the containers that you will load and
and I think that's a really good thing
because it makes you start to think
about running sequential and parallel
tasks in a different way so instead of
going I've got this big load of stuff
here and I'm just going to chuck it at a
server and it's gonna go I'm just gonna
do it and then chuck something out at
the other end what you can actually do
is go well this this process is 14
different tasks if I just pass it in at
the start and then just do those 14
tasks in sequence or or do some kind of
MapReduce then you can do some
interesting things just as a quick case
in point AWS has a little github repo
that has a AWS lambda MapReduce solution
it's worth looking at simply because you
don't need to know anything like Hadoop
you just need to know a little bit of
code and it works open quicker and it's
cheaper I kind of think it's worth
looking at if you're looking at big data
stuff
it's is definitely worth looking at but
in terms of compute-intensive stuff you
need to be looking at instances or even
on on you know on-prem computing you
know physical stuff you'd need to be
thinking about those in a different way
mission-critical stuff now this comes
back to being clouds and being super
advanced cloud very simple if you don't
want your systems going down because AWS
has had a has gone wrong for whatever
reason then you kind of have to have a
different solution but know that you're
going to have to manage that solution so
the trade-off is it's mission-critical
but I need to manage it if you don't
need if it's not mission-critical you
probably don't need to worry about it if
it goes down on the very occasional time
so your cloud provider goes down so
remember with all of these things it's
still your service you've still got to
care about your users who are using it
if you think your users aren't going to
like it if it goes down ever then you're
going to have to come up with a way of
managing that and that's not
straightforward failover is actually
really important but things like caching
and functionality at the edge become of
interest at this point and then another
scenario where you probably don't want
to be doing is where you need an amount
of control often for things like
regulatory reasons where you need to
know exactly where something is for the
government or whoever it is and you
actually need to be able to walk over
and point at a box there's probably not
the best scenario but you can get around
some of those things if you have the
right if the providers have the right
relationship with the government for
example and but also where you need a
specific and special configuration so
then you would be looking at containers
and you would be looking at other things
but the majority of those scenarios you
could probably take as small parts edge
cases within a whole you don't switch
out all of those bits for what you know
you could this is a part of the problem
rather than the only way but again when
should you use service or possibly it
should be when when could you use
service probably use it most of the time
it's not quite necessarily completely
ready for everybody who's who
looking for solidity and everything else
but I think it's probably pretty much
there for you know the late pioneers and
beyond to really start looking at all of
these things now just as a quick aside
as a we've a friend of mine and I I've
set up a community conference and it's
very very simple very very
straightforward we're very cheap and
we're not making any money out of it I
just say this because we've got some
very interesting speakers in and it's
been in less than a month and is good
fun and I will be there and trying to
tell everybody how amazing service is
again but otherwise when should you use
a service approach
I'd say about 99% of the time thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>