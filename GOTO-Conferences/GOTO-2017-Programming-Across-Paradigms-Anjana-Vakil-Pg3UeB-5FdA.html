<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Programming Across Paradigms • Anjana Vakil | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Programming Across Paradigms • Anjana Vakil - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Programming Across Paradigms • Anjana Vakil</b></h2><h5 class="post__date">2017-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pg3UeB-5FdA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I want to talk to you today about
programming paradigms so with everybody
here for David Nolan's Kino last night
very cool talk a little philosophical I
hope you like that because that's what
we're going to be doing today again a
little big picture so a little bit about
me I'm an Gina I am an engineer at uber
research no affiliation with taxis or
cars with any kind we do data about
scientific research funding and I work
on developing a custom query language
for that data I'm an alum of the recurse
Center which is an amazing programming
retreat and community in New York City
I'm also an alum of the Outreach II
program which is another amazing
initiative to get more women and
underrepresented folks involved in open
source at organizations like Mozilla so
Mozilla community member of a Moz Tech
speaker and I'm more than happy to talk
about any of those things in the hallway
come and grab me after if you're curious
about any of that but today I'm here to
talk about the paradigms of programming
the notion of a programming paradigm one
of the first times that this kind of
came to light in the the programming
community was in 1978 when this guy
Robert Floyd won the Turing Award and in
his Turing Award lecture and subsequent
paper he decided to focus on this notion
of paradigms in programming and I guess
when you win a Turing award you get to
start your paper with a with a quote
from the Oxford Dictionary which is
something I've never been allowed to do
but he did and he said ok a paradigm is
this notion of having an of a pattern or
an exemplar an example I think pattern
is the is the key word here and he then
to me he thinking about paradigms more
in
how they affect our programming so in
this paper he said I believe the best
chance we have to improve the general
record's programming is to attention to
our paradigm and that's really what I
like to run through today if you get
nothing else out of the talk I hope you
just get the idea that it's useful and
can help us all become better
programmers and individuals and
communities for us focus on paradigms
and how to Center that and put our
attention on that think about how they
affect our code so this of course brings
us to the question what are we talking
about so what is a paradigm this is
something that I probably a learned code
and the cable programmer something that
I kind of brought them within and more
superficial ways at first and then as I
learn more about a different paradigm I
got into kind of a deeper dialogue with
this question but actually the first
time that I came in contact with this
question was not through code at all it
was when I was studying philosophy as an
undergraduate I was a philosophy major
and in our philosophy of science class
we read this book called the structure
of scientific revolutions by a guy named
Thomas Kuhn and this book came out I
think the first edition was around 1960
and in this book he is a historian of
science and he wants to help us
understand kind of how science has made
progress over the years how we have been
able to advance the state of human
understanding so you know small
questions and he sort of centers the
whole dialogue around this notion of a
paradigm and so he frames a paradigm
kind of as a worldview a way of looking
at the universe a way of understanding
the universe for example we had as a
notion of a paradigm as an example of a
paradigm the idea of the the geocentric
model of the cosmos like the Ptolemaic
model where we have this model of the
universe where the earth we are like the
bright shining center of the universe
and all of the celestial bodies orbit us
in these celestial spheres and so this
is as I said kind of a model of the
universe that we're in a paradigm can be
looked at as kind of a way of
understanding of conceptualizing that
universe
and in that sense it's something that's
necessary for us to have scientific
progress says Kuhn that until we as a
community can rally around a model that
we can all agree upon it's not possible
for us to actually advance our
understanding of the universe he talks
about the pre paradigm phase of its kind
of like pre science where people are
just sort of stumbling around and when
one person is over here doing that and
other person is over here doing that but
as a community we're not able to move
forward until we all rally behind a
particular model a particular paradigm
but if a paradigm is a model then it
doesn't just contain the idea about
what's in the universe he says it tells
us also the series and methods and
standards together in an inextricable
mixture so what does he mean here the
theory is kind of this this view of the
universe what entities make up the
universe how do they behave and interact
but it also tells us not just about the
universe that we live in about but about
how we do the science that helps us
better understand that universe and so
that's where the methods and standards
come in a paradigm also tells us which
problems are we're solving which
questions it makes sense to ask which
questions are worth exploring and it
tells us which solutions are actually
legitimate
which answers are our good answers to
those questions so this is all wrapped
up in the notion of paradigm and Kuhn
talks about this in terms of mostly you
know the physical sciences things like
chemistry physics but these notions
apply to programs as well so if a
paradigm tells us in science what
entities make up the universe if we're
doing you know cosmology or astrophysics
in programming it tells us what makes up
a program what conceptual units is a
program made up of how do they interact
and it also tells us which problems we
need to address as programmers it sort
of defines the task of programming what
do we need to do as programmers given
this model of how programs are composed
what they're comprised of and which
solutions which parts of you know which
creations which programs that we write
are good ones so the theory methods and
standards are all wrapped up in this
worldview in this model but if it's a
model then we also have to remember this
this phrase from George box
he's a statistician and he's talking
about statistical models he says all
models are wrong kind of a famous phrase
none of them are an accurate picture of
reality they're all wrong and this is
where the the notion that Kuhn is
probably most famous for the notion of
paradigm shift comes in
so Kuhn says that you know finally the
scientific community has emerged from
the pre paradigm phase of darkness and
we found a paradigm it's a model like
the Ptolemaic model of the universe
let's say and we can do science this way
but eventually we'll start to notice
anomalies so let's say observations that
don't really fit the model that the
model has difficulty explaining things
that we have to kind of shoehorn into
the model using complex ideas like
epicycles and all kinds of strange
contraptions and this happens in
programming too right these are these
are the types of programs where it just
seems in elegant and clunky and awkward
and it's hard to maintain and hard to
read it's hard to think about these are
anomalies and once you know if you have
one anomaly here one anomaly there you
can even make an epicyclic trinomial
model and you can account for it once in
a while but enough of them accumulate or
perhaps some of them are so egregious
that eventually the scientific community
gets thrown into this kind of state of
crisis where the model has broken down
it no longer works it's no longer
helping us advance and then there's you
know arguments over which paradigm is
right there's the adherents of the old
model that refused to let it die there's
people coming out with competing new
models it's kind of this chaotic period
in which not much gets done until
finally the community decides to rally
around a new model and that's where the
notion of shift comes in and so then
that new model becomes the dominant
paradigm but of course they're all
models are wrong they're going to be
anomalies for that one and so we go
through the loop again and again and
again and it never really stops and so
the the example we had before of the
Ptolemy
model that eventually was superseded by
the Copernican model a heliocentric
world solar system in which the sun's at
the center you know the predicate is
like hey wouldn't it be so much easier
to explain all of these like anomalies
like the retrograde motion of Mars and
stuff like that if we didn't have to
posit all these crazy epicycles and we
just said well is the suns of the center
then it all kind of works out but these
shifts don't happen overnight Copernicus
came up with this idea but it was wasn't
for you know another couple hundred
years before the community had really
fully shifted they say that actually the
Copernican revolution didn't really
finish or didn't really conclude until
Newton came along with his sort of
unifying theories of how everything
works together what the universe is made
up of and how those things interact but
of course his model was also wrong you
know this guy came along Einstein came
along but actually you know Newton had
some good ideas but that was also an
incorrect model there are also anomalies
that a different model like relativity
can account for so ok this has all been
you know nice scientific history
exploration but y'all aren't here to
talk about Newton and Einstein you're
here to talk about programming paradigms
right so let's take a look then at the
field of programming at kind of our
scientific or pseudo scientific
evolution and see what kind of paradigm
shifts we went through there so in the
beginning there was imperative
programming something kind of miraculous
happened and we like as a as a species
figured out how to electrify rocks and
like make them do what we want pretty
amazing and in this kind of this first
sort of dominant paradigm we we conceive
those programs as made up of things like
statements and expressions and those
combined to create commands that we
human overlords for now give to the
computers and so this is a kind of the
to me the sort of the the crucial entity
that the imperative programming model
turns around is the notion of the
imperative statement which is a command
do this then do that then do that other
thing so
programming what we have to do as
programmers in the imperative paradigm
becomes saying things like hey you
computer follow my commands do what I
say follow them in the order that I give
them imperative programs read like top
to bottom mostly there's a little
jumping around but in general it's kind
of a linear way of thinking and so time
is important in the imperative paradigm
and so that's where state comes in state
being you know remembering values over
time how they change over time this is
all sort of central to the imperative
programming worldview so for me the the
mental kind of visual analogy that I
like to use for imperative programming
is kind of that of a complex clock or
sort of clockwork machinery it's very
intricate very precise very amazing sort
of when we think about how all of these
tiny pieces fit together but it means
that we have to be very very close
attention to every little tooth on every
little cog in that machine precision
becomes extremely important and of
course you know the clock is also kind
of a good metaphor because time state
that also matters in this paradigm so
here's some imperative code this is some
C code C is sort of one of the the
classic sort of archetypal imperative
languages that people still write lots
of useful code in this has just pulled
at random from the C Python interpreter
this is a little function it just rounds
up to the next highest power of two over
a number and it reads very much and it's
top to bottom you know do this do that
kind of fashion it's like you to
remember this number assert something
about it something about the input enter
a while loop in each iteration do this
in this check a condition if you
condition meet you know jump out of the
while loop and then return the result do
this do that
in that order so the metaphor of a clock
this this sort of intricate machinery
it's really great when it's working but
as soon as one little thing breaks down
in there the whole thing freezes up and
so some people found that this started
to be sort of an anomaly for the
paradigm of imperative programming that
as programs get more complex they become
much harder to manage and one little
thing can go wrong and bring down the
whole the whole system the whole
eight so new ideas for a new paradigm
starting to come about like for example
in the late 70s and early 80s the idea
of object-oriented programming with a
paradigm that started a rather seismic
shift towards that way of thinking so
object-oriented programming is still
sort of imperative we're still telling
the computer what to do but and we're
still paying attention to state but
we're breaking it up into little chunks
so that now programs the universe of
programs is no longer comprised of
commands it's comprised of these things
called objects whatever that means
objects are kind of like these little
units that keep a little portion of
state to themselves so we say hey you
object remember your little portion of
the world the state and the other thing
that that's important for a paradigm we
said is not just what entities are out
there but how they interact so these
little chunks these little objects they
interact according to people like Alan
Kay one of the founders of the paradigm
by sending messages to each other and
this is what happens when we call
methods on each object basically sending
a message like hey object you have some
state that you do here's a here's a
method that I want you to run on
whatever state you have and then give me
some response back do something in the
world maybe change something in the
state but but do something based on my
message respond as you see fit respond
as your internals are telling you to
respond we'll take a look at a little
bit later how that works because this
for me was kind of counterintuitive I
always thought object-oriented
programming with all about classes and
inheritance and whatnot but it's not
really the central notion which we'll
come back to a little bit later so the
the visual metaphor that I like for
object-oriented programming is the one
that Alan Kay talks about a lot when he
talks about the kind of history of how
we came up with these ideas and he and
other folks as well which is biological
really in its metaphor it's kind of the
notion of cells in a body if we think
about each object as kind of like a cell
in a larger tissue I so has its own
internal structure have its own state
has its own molecules inside has its own
little organelles and things going on
that that make it whatever type of cell
it is
and it has a membrane that sort of
protects whatever is inside it from the
rest of the world and it received it on
that membrane it has receptors for
molecules that are floating around in
the system and so all of the cells
together pass these molecules back and
forth and they do things with them with
their receptors and this makes a larger
system like a body or an organ function
so object-oriented code we're probably
all familiar with this is some Python
again pulled at random from C Python
from the from the Python interpreter and
we have these things like classes we
have inheritance as I said that's what's
there but it's not necessarily crucial
we also have we have methods we have
this notion of self we see this keyword
self a lot in object-oriented
programming we have this idea of
identity of each little cell being sort
of its own beautiful snowflake and
they're all kind of have an idea of who
am i and who is the rest of the world I
keep everything to myself so these are
some things typical of the
object-oriented programming paradigm
which we are likely familiar with
meanwhile the problem of the rigidity of
imperative programming and the problems
created by having to maintain complex
States also sparked working towards
another paradigm a different way of
solving basically that same problem
which is functional programming so the
origins of that go back like even
earlier to Alonzo Church and the lambda
calculus in the 30s but the as this
became kind of more a thing in everyday
programmers life which now in the last
you know 10 years or so we've seen like
a huge interest in this because we found
ways to make it efficient the idea that
comes let's like do things a completely
different way let's forget all about
these commands and saying do this do
that let's forget about time and state
and things like that let's beautiful
state is dangerous it causes us a lot of
problems we have so many so many bugs
and headaches and just like stress in
our lives because of mutable state let's
forget it instead let's conceive of the
universe of programs as made up of pure
functions where pure functions are
really safe because all they do is take
in some
inputs whatever arguments you give them
they do whatever complicated
computations or maybe not so complicated
computations they need to do and then
they spit out their output their return
values that's all they do all they look
at is the arguments that they get in
they don't look at anything else about
the rest of the world and all they do is
return a value they don't make any other
changes they're kind of like these these
little transformers of data data goes in
data comes out and we can hook them all
up together so that we sort of flow data
through our programs which are
themselves like giant pure functions
they just take input and give output and
so the visual metaphor that works for me
for this is kind of like a factory where
a factory gets in like the trucks come
in with the raw materials and then at
the end of the day the trucks go out
with the assembled whatever cars in this
case and inside the factory we have like
something like an assembly line where
lots of little stations kind of do one
specialized task and the data sort of
the raw materials flow through them and
get to transformed in little ways bit by
bit on that assembly line so functional
languages probably familiar with Lisp
this is some scheme the dialect of Lisp
they do a lot of things like this like
map function right it's very typical of
the functional paradigm where we are
taking in a list and we're kind of
processing it little by little by
applying a function this F that we've
gotten applying it to the first thing in
the list and then cleverly recursively
calling myself my I find the map
function on the rest of the list which
then means I apply F to the first thing
of the rest of the list and then I
recursively call myself on the rest of
the rest of the list and so on and so
forth until I process the whole list
like the whole assembly line you know
the list has passed by me on the
assembly line so functional programming
is actually a kind of sub paradigm or
one type of paradigm that falls under
the larger umbrella of declarative
programming and declarative programming
is usually put in contrast with
imperative programming
so if imperative programming concedes of
the universe of being made up of
commands that we give the computer
declarative programming says it's
made up of declarative statements it's
made up of instead of do this do that
it's made of statements like these are
the facts this is what I know this is
what I want from you computer and I
don't care how you go about giving it to
me I'm not going to give you in split
instructions do this than that so the
the metaphor that I like to use for
myself for this is kind of like a logic
puzzle like Sudoku and you Sudoku fans
anyway so it's the kind of thing where
you have you have constraints you have
like rules and facts about the world so
for example every 3x3 square has to have
the numbers 1 through 9 the digits 1
through 9 every row and every column has
to have those numbers these are like a
just general facts about the universe it
must be done this way and then you have
these sort of constraints about what
what you see like there's a 1 in the top
left corner and you have to work around
that to complete the puzzle in this
metaphor you are the computer as you
fill this out and so the point is that
it doesn't matter what order you enter
the numbers in all that matters is at
the end of the day you have a solved
pseudo ku grid and that's kind of what
we're telling the computer when we use a
declarative language like sequel for
example we just say ok I want some books
I want I care about their titles and
their prices and etc etc I only want
books where the price is above a certain
thing I want them ordered in a certain
way this is what I want go get it for me
we don't tell any we don't say anything
about how exactly it should retrieve
that information from the database we
don't say anything if we're asking for
you know joins and we don't say anything
about how it should integrate other
information or how it should perform the
ordering process none of that just
saying I want this please give it to me
and another sub paradigm of declarative
programming is like logic programming
which makes the pseudo Coos metaphor
even sort of more fitting so a language
like Prolog for example I think makes
this declarative style even more
explicit we're saying these are the
facts about the world you know wanted
Anna's parent Kim the Dennis parent Kim
is my parent these are some things I
know and then we're saying there are
also some facts about the world like you
can you can make deductions in a certain
way using certain rules of logic like
for example x and y are siblings if
there's something
@z who is both X's parent and Y's parent
and so then I can say Prolog I want to
know is Ana my sibling and Prolog will
tell me yes but I haven't said anything
about how I want it to make that
deduction all I've said is this is the
scenario tell me what I want okay so
there are a few more programming
paradigms than these these are just a
couple this guy Peter van Roy took it
upon himself to write down lots of them
not even all of them these are just the
principal ones and he categorizes them
in terms of the concepts that make them
up he gives some you know languages that
support them and interestingly you know
he points out in some of his work on
programming paradigms that sometimes
paradigms that we think are really
different I think things that we think
of as being totally diametrically
opposed paradigms really only differ in
maybe one or two concepts so this sort
of got me thinking and you don't have to
read all this as so there's links at the
end don't worry but this got me thinking
okay well you know a lot of the time
I've been told I feel like as especially
as kind of you know a junior ish coder
have been told a lot of things about
these program these paradigms are super
different but are they all really that
different
do they have things in common that we're
kind of not seeing if we're getting so
fixed in our ideas of one paradigm and I
start especially wondering about
object-oriented programming and
functional programming which seem to be
like placed in this epic rivalry in
programming culture that like the
die-hard functional programmers hate
object-oriented methods and
object-oriented programmers are like you
have schools grows everybody's fighting
each other and saying these are super
different but maybe they have more in
common than we thought so be again the
problem that they were both trying to
solve or one of the problems were they
were both trying to solve was kind of
the rigidity and the and the complexity
of the imperative paradigm I wasn't very
good at managing complexity and the
problem one of the problems on the main
issues that they both take with it is
shared mutable state
so both Hopi and functional programming
reject this notion that we should have
shared mutable state
they just do it in different ways so
functional programming says just forget
mutating anything just make everything
immutable just forget State forget time
and then you can share as much as you
want you can pass around data as much as
you want to as long as nobody's changing
anything and each function is just
churning out new data that sort of
replaces the old and olp also rejected
it it just said okay you know let's
divide up the state into little chunks
little cells that all keep to themselves
so that we're not sharing any of it and
in that way we'll kind of avoid those
problems so going back to this idea
about the central the core of the
object-oriented paradigm Alan Kay said
in around 1998 that he's sorry that he
coined the term objects for
object-oriented programming because it
gets people to focus on the lesser idea
the big idea he says is messaging right
so what we were saying before that these
kind of these cells that make up the
universe of a program send messages back
and forth and that's how we get a larger
system so to understand that a little
bit better let's take a look okay this
is some very very very complicated
object-oriented code right here but it
usually looks something like that right
we have like thing dot method and then
some arguments and in the way that I 1k
would like us to think about okie what
we're really saying when we say thing
dot do some stuff is we're sending a
message to the object in this case thing
and the content of that message is
usually the method name and then some
arguments that some data that we want it
to do something with so some languages
like for example in ruby apparently you
have the luxury of making that's
actually explicit you can either say you
know sing dot do some stuff or you can
explicitly use this dot send method
which shows us that we're really like
sending a message to the object where
the first thing in that message is a
symbol representing the name of the
method that we're trying to call and
then the rest is the arguments of the
data that were passing along so here's
some also extremely useful
object-oriented code
let's say we had a type of object called
a friend because we all like to be
friends we don't want to be arguing like
the Opie and the functional programming
people a friend all does is remember
that it has a certain list of friends
and then it can tell you whether
somebody is a friend of me so if I have
a buddy is an instance of friend who's
friends with Allen and Alonzo I can ask
you know buddy are you friends with guy
and of course the answer is false
because I'm not sure guys buddy but when
we think about that is South Park yes oh
when we think about that in the in the
message notation that we were just
looking at we could replace this call
buddy that is friend of guy with buddy
dot Send and then send the message where
the the first part of the content is the
name of the method that we're trying to
call and the rest is the data that we're
passing to it but we could just clean up
the syntax there a little bit right like
why do we really need that dot send for
if we're always sending messages
couldn't we just get rid of that and
then it starts to look a lot more like a
function and so we could actually write
our we could create our friend object a
functional way by representing it at the
closure because all a friend has to do
is it has to when we create it it has to
remember its list of friends Allen and
Alonzo and then it has to be able to
tell me for any given name whether it's
friends with that person whose name it
is so instead of having a class
definition with you know constructor
method and some some object methods on
there I could set this up as a closure
where I'm kind of remembering by
wrapping the context in which the object
itself dude the the instance is created
I'm wrapping that up into this
disclosure and then I can pass as an
argument just the name of a method in
this case it's only set up to support
one method I can pass that in with
whatever arguments and get basically the
same behavior that I was having before
so like this is functional this is
object oriented this is functional this
is object oriented like they're really
not that different
and so when we look at this code this is
this is functional right I mean it's not
in Haskell that's okay but it's all it's
all pure function that's using these
very very functional ideas of you know
higher order closures etc but in a sense
if I look at the bottom two lines I'm a
programmer I end up having to kind of
interact with this code in a similar way
to what I was using whatever used to
doing in object-oriented programming so
this is kind of one of those optical
illusion things note that the old lady
is that the young girl is at the dock is
it the rabbit it's like it's sort of
both depending on my frame of mind and
that's where we get back into the idea
of a paradigm being just a worldview a
mindset that you're using so this is we
could actually like write
object-oriented code in the lambda
calculus if we wanted to you wouldn't
probably do that but you could because
it's all about how we conceive of the
universe of our program and what what
makes it up and how those entities will
talk to each other okay so but then
everybody wants to know right especially
with this o P versus SP rivalry which
paradigm is the best well you probably
guess what answer is going to come up to
this and I think David Nolan also did a
bit of foreshadowing yesterday but let's
go back to this quote from George box
he said all models are wrong but that
wasn't the end of the quote these of all
models are wrong but some are useful and
this is really the main idea paradigms
are useful in different ways so going
back to our Newton versus Einstein thing
like there is a sense in which Newton
was wrong about the universe and his
model maybe doesn't match the universe
as closely as Einsteins model but that
doesn't mean that we need to throw out
Newton's mechanics entirely it's still
super useful for certain situations like
dealing with things on the surface of
the earth that aren't going very fast
building bridges you know sending
Rockets to places nearby we can do all
of that stuff using the Newtonian model
it's still very useful and in some sense
it's probably more useful to think about
cars and you know a Apple falling out of
trees in the Newtonian paradigm
I'm then thinking about them as being
able to be converted to energy and
whatever and thinking in a kind of
Einstein ian's way depending on the
problem you're trying to solve the old
model might still be very useful and so
peter van roy the guy who made the
paradigm diagram also comes back to this
idea he says each paradigm supports a
set of concepts that make it the best
for a certain kind of problem so these
little bundles of concepts which are our
paradigms they are all particularly well
matched or particularly poorly matched
to certain problems so it's really just
a matter of matching up your problem
that you have with the best paradigm for
solving it and George box says that you
know then the question to ask of a given
model isn't whether it's true because
you know it's not but you can ask is the
model illuminating does it tell us
something new does it give us some some
insight into the particular problem that
makes it easier to solve and sometimes
switching your paradigm makes a problem
that was impossible under your old
paradigm super trivial under the new one
so then this brings us to the question
of what can a paradigm teach us as
programmers what can you teach us as a
community of programmers and what kind
of teach us as individuals and each
paradigm kind of has something unique to
contribute to the dialogue so I think
that imperative programming is a really
great teacher of how to be explicit and
how to focus on and understand the
implementation as being crucial to the
particular program so that's why you
still see you know a lot of really
really important especially like
performance critical code written in
this imperative paradigm because it
forces you to think about those very
very precise small changes that need to
be made for the implementation to work
so for example this is something I ran
into Hawaii I gave a talk last year at
Europe I thought about a strange little
thing I found out in Python did you know
that in Python if you have a for loop
like on the left here for look that
doesn't do anything useful but it does
it a lot of times if you put that inside
a function and you call the function
that actually runs way faster than if
you just execute the for loop in the
global context so I thought this was
sort of weird
and as an object-oriented Python
programmer I was looking at these two
pieces of code and was like I don't see
the difference if anything there's like
more lines on the on the right side so
shouldn't it have more to do it has to
like create a function object and yadda
yadda but if you think really imperative
ly about this and you drill down and you
actually look at what the C Python
interpreter is seeing if we look at the
byte code that we disassembled for each
of these these code objects you can
actually see that there's a difference
so the the Python code on the left is
using some kind of action called store
name and load name and on the right it's
using something called store fast and
load fast which must be faster it's in
the name but it turns out that this is
because you know Python has this the
solution everything's an object and
whatever and the objects that it's using
to represent these these values are
different so on the left hand side just
as a factoid about Python in the global
context we don't know how many variables
are going to be declaring a program so
the global context has to be big it has
to be this big dictionary that it kind
of remembers anything we throw at it but
when we define a function on the right
hand side the function body already
contains all of the variables that it's
going to contain it's we know exactly
how many values are going to have to
remember there so we can pre allocate a
little array for all those values and
then when I need to go retrieve one of
them it's just a really quick you know
index lookup into there so the the
difference in these is not something
that the high-level Python sort of way
of thinking this object-oriented way of
thinking was able to help me understand
I had to go down into the details and if
you're interested in this kind of thing
and how like getting really nitty-gritty
into the details of the implementation
can help you become a better programmer
I highly recommend that you check out
Julia Evans works because she gives lots
of great talks and writes really cool
blog articles and Dean's about all the
amazing wizard magic you can learn by
doing this kind of imperative
exploration okay what about declarative
programming this is kind of the
counterpart the yin to imperative
programming the yang or vice versa if
imperative programming teaches us to be
explicit and get nitty-gritty into the
implementation declarative programming
teaches us to get really abstract and to
really think more about the domain
and the big picture ideas that we're
trying to represent in our program and
not how they're implemented so Martin
Fowler II spoke yesterday has a great
book called domain-specific languages
where he talks about this idea of having
kind of a better domain model of what it
is you're trying to do that that can
sometimes make your life as a programmer
and especially your your task of
communicating to let's say your clients
a lot easier when you have code that
looks like this so this is a Java code
in which we have an embedded or when he
calls an internal DSL domain-specific
language where we are focused on
representing calendars and the things
that they have like events which have
dates and times and location and
somewhere we also have a bunch of Java
code that's telling the telling us
exactly how we're remembering those
events and exactly how we're associating
various bits of data with them and how
it's all implemented but that's not
important when we're thinking
declaratively what we want to be
thinking about is like really the big
picture what am i trying to do here I'm
trying to represent a calendar I'm
trying to represent events and this can
be sometimes a much easier way of
thinking about certain problems when the
implementation is not what's at stake we
can change the implementation but the
the big picture stays the same so really
having both of those mentalities both of
those worldviews they complement each
other we can switch between them to do
whatever is necessary for the particular
problem at hand and the same is true of
object-oriented programming and
functional programming
so if object-oriented programming
teaches us you know this idea of objects
of kind of cells that I'll communicate
with one another sometimes this can be a
better fit for a particular problem then
even an amazing program like functional
programming so this is from a cool
article by Eric fellows whose name I
probably just very much mispronounced
sorry
it's called y oo P matters in F sharp so
he's an F sharp co-direct sharp is a
really interesting language it's like ml
inspired functional programming but it
also supports object-oriented
programming is kind of a generally
secondary paradigm and so he's saying
okay if we're trying to make an API
which has to be kind of aware of some
sort of context of diff
and dependencies that I have typically
as a functional f-sharp programmer my
first instinct would be to do what's on
the top here which is to have a module
where we have a bunch of different
function but each of those functions
have to know about the dependencies that
we pass them all Anna's arguments this
is sort of okay if you have just a
couple of things but as you get more and
more dependencies and more more
functions as things get more complex
this starts to get really ugly and
inelegant and kind of hard to to keep
track of and it stops being the best fit
for that particular case whereas since
object-oriented program is all about
interfaces it's all about kind of this
like molecule membranes that take inputs
and give outputs perhaps object-oriented
programming is a better fit for this
problem where we could just define an
API that you know when you construct it
you pass in the dependencies once and
then all of its methods kind of know
that from their internal encapsulated
context so this is just an example of
how you know sometimes bringing in a
little bit o P into your functional code
can also sometimes be a good idea and of
course it works the other way around as
well functional programming can teach us
the mindset of specializing of focusing
on doing one particular transformation
to the data like one little station on
our assembly line and Jessica Kerr
actually a couple years ago I think 2014
maybe I go to Chicago talked about this
she was talking about how she had this
she was white boarding a probably you
know a program on her that she needed to
make that that had to deal with deposits
and payments and kind of pair them up
and she found herself making this really
convoluted diagram where she to like go
back and forth and say okay if that
happens then we need to loop back over
here and it became really kind of hard
to to reason about and also hard to
understand how as a team they should go
though out like putting this together so
she said that one she started when she
switched into a functional mindset it
became it sort of fell into place so it
became a notion of an issue of
transforming data we have two kind of
data streams coming in they get filtered
in certain ways they they get merged
together and then they go to a store and
each of those things is like one little
transformation that we can make which we
can then break
up into chunks as the yellow boxes here
and then I can divvy it up she says you
know I can divvy it up to my team
members and everybody has you know just
their one little chunks to work on and
we put it all back together at the end
and it works great and the whiteboard is
way cleaner like the whiteboard makes
much more sense so sometimes the
functional approach can make a
convoluted what am I trying to do here
situation just almost trivial and so
this is this is kind of the take away
like none of these paradigms are best
all models are wrong but each is best
for something each is best at something
like all of them are special snowflakes
and they all have their unique moments
in the Sun sounds a little hippie dippie
but I think it's actually true and this
is you know what what peter van was
talking about they're kind of like a set
of concepts that's paired particularly
well with a set of problem and so that's
why fluid says in his Turing a word
paper he said that we actually need more
paradigms
he says the advancement of the general
art of programming requires the
continuing invention and elaboration of
paradigms I think this is also what
David Nolan was touching on last night
this idea that we we need to develop new
models new worldviews new ways of
thinking so that we can add those to our
kind of toolbox we already have a bunch
of you know pretty cool paradigms Peter
and Roy like diagram them all out for us
there we have a lot but we could always
use core and advancing the state of the
art of programming will involve
advancing our worldviews coming up with
different ways of conceiving of the
universe of programs and so if the
advancement of the general art means we
need new paradigms then the advancement
of the art of the individual programmer
requires that they expand their
repertory of paradigms so as individuals
we need to get comfortable with all of
the paradigms we can we need to add as
many of these tools to our personal tool
boxes as possible so the idea here is
that as individuals we should really not
get set in our ways just like as a the
community we should try to explore new
things like what David Nolan was talking
about last night
and one great way to do that is to work
in multi-paradigm languages so like we
mentioned F sharps before is a language
that lets you pull in a little bit of
olp sometimes even if most of the time
you're in a functional mindset and other
parrot other languages like Python for
example is very oriented but you can
also write it as just scripts and
imperative file or you can even do a
little bit of functional programming
it's maybe not the best fit and there
are other languages like like Erlang for
example where it's functional at core
but then the the notion of this kind of
actor model all that starts you start
thinking in a more kind of
object-oriented more like cells
communicating with each other sort of
way so working in languages that support
multiple paradigms is a great way to be
able to switch between those mindsets
and that way you don't have to learn a
whole new syntax when you want to learn
a paradigm you can just try something
new out and the language already
comfortable with okay so we're going to
last on time so what's the point then
for this whole thing basically I point
has been this paradigms enable
programming just like paradigms enable
scientific progress according to Kuhn we
need as a community to be able to agree
on a certain model of programs and a
model of programming and what it means
to write programs what it means to write
good programs in order for us to get
anything done and in that sense the
paradigm you use also sort of defines
the task of programming the the
worldview that you're in as we saw
earlier it tells you not only what
entities make up a program but also what
type of problems it makes sense to solve
and what type of solutions it makes
sense to bring to those problems so in
that way it defines like what it means
to do programming so this is why it's
really important that we not fight the
paradigms that we work in that we
understand them and we kind of embrace
them for like their beautiful snowflake
nests and we we use them to solve the
programs that they're best of the
problems that they're best at but we
remain open to shift to a new paradigm
as soon as those anomalies start
accumulating and we realize that we're
looking at a bunch of really combo
would code that's super hard to
understand super hard to refactor super
hard to teach the new dev on the team
like what's going on in this codebase
those are kind of moments where it's
great to be open to shift to a new way
of thinking about it and the main point
is just basically the point that had
that floyd made in 1979 which i think
it's kind of interesting cuz we don't
really have a whole ton of new paradigm
since then which is maybe a little bit
what david no one was getting at last
night so this is something that we all
together and individually should be
doing is kind of focusing on this this
meta level of like what am I even doing
here what am i conceiving of a program
is made up of and how am i approaching
the task of programming given that model
that worldview so if we can go out of
this attending a little bit more to the
paradigms we use I'll be happy that's
sort of what I want you all to take away
so that's all I had big thanks to the
recurse center community especially
these folks who helped me put together
the materials for this talk and big
things to go to Chicago for having me
thank you
here are some references to anybody
watch okay anybody has questions or you
know just wants to engage in some
philosophical dialogue ah technology now
we have about five minutes for questions
so if you can stick around you might
even have a chance to ask another one so
I have one here that says would you mix
paradigms in the same system or is it
more a question of picking the right
paradigm for this particular problem
well I think you know it depends on the
granularity that we're looking at I
personally think that there is
absolutely nothing wrong with mixing
paradigms at a system as long as you
know you're working in the same in a
language that supports them both it
becomes a little bit more complicated
when you have to start mixing and
matching different languages because
then you know maybe different people on
the team at different levels of comfort
with those languages but let's say
you're working in a language like Python
so and my company for example we have a
lot of Python and different parts of it
are structured in different ways and
sometimes you find that within a
generally object-oriented part of the
codebase there are some chunks that are
really like look functional that are
that are very pure and isolated and so
we can actually do that we can have an
object that does a lot of its
computation in a pure functional style
but is nevertheless kind of a wrapped in
this object interface so yeah you can
mix them click one here does assembly
slash machine language belong to any of
the paradigms well I would say that it's
imperative I suppose it's possible to
conceive of assembly foetid some other
paradigm but I've never really seen it
maybe somebody else has but generally
assembly code is extremely explicit and
has this very usually like when you read
the human readable forms of it like the
Python bytecode that I just thought that
I just showed it usually has these very
command oriented phrases right like load
this push this onto the stack do you
know pop these things etc so it has this
kind of do this then that and we have to
execute it in that particular order so
it's pretty I think it's a pretty good
actually a pretty good representation of
the imperative paradigm it's also
important to remember that our machines
are like
stuck in that paradise they don't have
the luxury that we have of being able to
sit comfortably between different
paradigms and different worldviews their
like yet tell me what to do and what
order I need to do it in because I am
stupid I don't know yeah so hope that
answered that question our micro service
is a paradigm
ah-so I personally think micro services
have kind of reinvented Allen Kay's
ideal vision of okey that's sort of the
personal conclusion that I've come due
that this idea of breaking things up
into little chunks but then all pass
messages back and forth together and
create a larger system that's sort of
more decentralized in a way I think that
actually kind of fits when you read when
you read what Alan Kay writes about
object-oriented programming I don't know
if I have the reference up there but he
talks it and there's a paper called the
history an early history of small talk
where he sort of explains his ideas
about this and it sounds a lot like what
we're doing with micro services to me so
but then again if you think about like I
said you know functional programming and
opie they're kind of a duck rabbit
situation if you ask me and so we can
also consider that if a micro service is
just responsible for getting its input
and getting its output you could also
conceive of it as pure functions and
we're all just you know passing things
from one into another it's all a matter
of perspective that's what we have so
far of anyone's has any any any
last-minute questions now's the time to
ask them no takers all right in that
case give it up for Angela please thanks
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>