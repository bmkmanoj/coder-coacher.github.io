<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Feature Branches and Toggles in a Post-GitHub World • Sam Newman | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Feature Branches and Toggles in a Post-GitHub World • Sam Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Feature Branches and Toggles in a Post-GitHub World • Sam Newman</b></h2><h5 class="post__date">2017-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lqRQYEHAtpk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank Ridgid obviously thank the
organizers for inviting me once again I
my second time for go to Chicago i bt
chicago's loans but normally and i get
to come in the winter and I actually
quite like the winters here because
they're like a proper winter you're not
messing about that's like a proper full
on winter experience you get last year
the weather was amazing so I was packing
to this trip and I asked Alexa what the
weather was like in Chicago the next
videos there will be a flood alert it
was a bit of a delay right because I
like to have to take all of my personal
information send it to the NSA but they
wanted to finish with that it was all
like there is a flood alert from Monday
to Thursday and I'm like oh that's good
the only four days I'm in Chicago flood
alert but the weather had cleared up
some I'm grateful for that yes it won't
be a talk about micro-services are we
selling the book so I'm not stupid we
are we talking about different subjects
instead I used to actually work for a
chic hago headquartered company thought
works for many many years and a bunch of
my own thoughts went knocking around I
then moved on to work for a company
called atomist and then I left them to
come independent when I left our
Australia last you are earlier this year
and so now I run my own company which is
really focused on what I think is the
most important and crucial aspect of IT
in a 21st century which is naming myself
so a little little tip I am the only
person in the company right now if my
accountant made me do this he said I
appear more formal so far it seems to be
working out I use the word we a lot when
we I you know these things are about
decade now interesting a lot not here to
talk about micro services I kind of did
want to reflect a little bit on why I
even got interested microservices in the
first place it was because I've from my
early days and thought works
my main focus area was actually on
helping people ship software more
quickly and so I spent lots of times
looking at continuous integration
continuous delivery cloud automation
infrastructure automation automated
testing and all of those sorts of things
and realize that actually a lot of time
of the architecture
systems themselves that made it hard to
shift software more quickly and too many
ways this talk it meters going back to
my roots and really re-examine our lot
of those original principles that we
were focusing on in the early days of of
content of the continuous delivery
movement and seeing if they still apply
in this sort of new post github but
hopefully not entirely post factual
world
I may even reference some data so let's
see how that gets on but I do not take
you back to the early days and I thought
Wesker in 2004 I joined thought works
and they immediately dispatched me off
to go and work for a client that client
was a company called Dixon's if you've
ever been to the UK and a UK Airport you
would have seen a Dixon's travel
Emporium where you can buy electrical
equipment for a mere five pounds less
than it'll pay you cos you in the high
street but then you've got to work out
how you're going to take a huge like
ghettoblaster on the plane with you and
the project we're working on was to
create an electronic point-of-sale
system actually custom and fit almost
full chain electronic point-of-sale is a
really really big big project and so I
was told to go to the platform at Euston
station and just they said you're
getting on a train and you're going to
hemel hempstead
and there will be other people on the
platform and I'm sure you can work out
who they are
and it's listed a lot for the diversity
of the company in the UK at that time
when I got on the platform I could set
exactly who my coworkers are and so we
had many happy hours travelling up and
down that train on up to hammer-headed
and back I shot our topic of
conversation most journeys was should we
actually get off at hemel hempstead stay
on the line for a bit longer because we
were going on at Euston and the line
went all the way up to Hamill hence tits
which was it's an okay place but if you
stay Don's a few more stops
you could go to Bletchley Park we did
that got off the train most of times but
every now and then it was a bit hard
going to work and that was because I
joined a rather interesting moment on
the project the project has been going
for a while but initially had been a a
project will be came on board they have
been quite behind schedule and I was a
real push to get things out a few years
ago all Don and the team were currently
working on
the third release of the software I say
release each sort of release went out so
multiple had multiple actual deployments
it was like a bucket of this is the are
three focus of work and each release are
taken in a larger section of the whole
Dixon's sort of organisation Emporium
they have like loads of different brands
on the high street and so you know and I
came in just after a moment when I think
kind of interesting it happened so the
bulk of you of the development
organization be working on the artery
band of branch of code checking in lots
and lots of changes but they've been
this awareness that there been a lot of
support now called technical debt
building up and there's a bunch of
people that wanted to make some fairly
substantial changes to the code base and
so the deal was made well at least
changes our guinea quite impactful it
can be quite hard for us to do that
while still delivering features and so
what we're going to do is we're gonna do
a not uncommon thing at that time but
effectively sort of cut off as a part of
our team and have them focused on making
these sort of larger scale architectural
changes so off we did we forked off the
r4 branch and that team while the r3
team are busy actually
you know delivering real value to
customers the rest of the ivory tower
architects decamped for different office
to work on their changes oh yeah we've
never actually to be fed a lot of really
good stuff is being done after projects
matured for a while you get it you get a
sense of a better way of doing things
and this is all about actually trying to
consolidate things down and after a
while the r4 team felt okay we've got a
pretty good grasp of what's going on now
and we think actually this is our
version of code one send live and so now
we need to make the our four branch our
live production release of software but
of course while we've been chipping our
stuff we've been what are we working on
refactoring our repository layers and
coming up with new web handlers or
whatever it is they were doing at a time
it's actually swing application so
actually even not quite web but we've
got to bring in all that change that's
been happening in the r3 branch since
you merged and so that'll be easy right
we'll just sort of merge in many many
months worth of development work being
done by half I you know tend if not
handled Avella pers and that's going to
be absolutely fine right it turns out
not so much and I arrived just as this
protis have happened
and I know some of the people are joined
within the same day were dispatched off
the res part the organization and then
they say came to me said so we've got a
very exciting proposition for you
how would you like to join the r3 r4
merge bug 16 - which of course the only
correct answer is yay
and so this or the T mails in for
several months and the only read and his
team existed was to fix the sort of bugs
and regressions that had occurred as a
result of this mammoth merging two
branches of code now this scarred myself
and many other people and actually led
to a lot of changes in how we think
about handling branches that led to
things like trunk based development and
continue to live which I'll come on to
shortly
many years later by the way I was woken
up in my bed the ground was shaking I
was living in London sizzle a normal
occurrence and found out that they've
been a huge explosion on oil refinery
the oil refining it was right next to
the headquarters the Dixons where I used
to work as far as I'm aware
it hasn't been conclusively proven that
this massive explosion was the cause of
this merge of code but it could have
been I'm not saying it's not happening
but anyway now of course the the
question I gave away I tell this story
the people ask me but the weren't you
doing continued integration you are
thought works you're the company that
popularized the whole concept of CI and
so why weren't you integrating your code
to avoid this sort of huge big giant
merge and the reality was we were I'm
just going to reprise continuous
integration very because I think it's a
very important concept but I'm not sure
that we always have the same definition
but CI works a very simple way you know
I work on mine on my laptop I create
some code I check that code into some
kind of source control repository now
back then we didn't have things like git
we had much more much worse things and
then some kind of CI tools there back
then we were making use of cruise
control nowadays you'd use Jenkins or go
CD or something like that or pick up
that change and we'll integrate it with
the last commit effectively what happens
is you integrate the code you then do a
compile step and a verification step and
you get a feedback on whether or not
your change works so you know Here I am
I'm checking in my
that's great next developer go to check
in their code and they're making sure
that their changes integrate with my
changes and it's not just enough to say
okay I don't get a merge conflict this
should be that semantically the software
still behaves how we expect it to behave
after you brought these two changes of
code together so that's the first thing
you need some sort of suite of a bill
that will validate the integration so
you know compilation static analysis
automated testing together these things
work together right now if I check in a
change and I break the build what that
means is the integration has failed
hopefully what I've actually done is run
the test locally before I checked in and
so I've actually probably got a
legitimate sort of you know miss
integration problem happening so the
next thing you've got to say there KP on
a breaking builds you've got to fix that
build it becomes the top job of the team
is to make sure that build is fixed and
normally what you would do is if you
checked in the breaking change you would
fix that break and change and no one
else would check in until that's done
this leads to some interesting behaviors
where people will not check in at four
o'clock on an afternoon on a Friday
because it's a bill breaks they are not
going to the pub so that's the real key
thing but also you have this idea that
you want to integrate often because if
you take a long time until you go and
finally check your change in you might
find that actually that you'd be working
for a while locally on your machine and
you finally check that code in many days
later you're much like that you're
likely times that big merge problem
again time to avoid that and fidella
rule the cardinal rule of CA is that you
integrate daily like you're doing
continuous integration you're
integrating daily that's that's the goal
that's what the original paper in 2000
said it's what Martin's updated articles
said that's what continuous integration
is the reality was though on Dixon's we
were doing continuous integration the
problem was how we were doing it she had
the R for the r3 team in the R 14
separate branches of code and so as the
r3 people were working on their changes
they had a CI build and the r4 people
also had a CI build but that integration
was a pure local integration we were
only actually looking at the changes
with an isolation of that team
and so when we pulled out all that
functionality we still had that same old
problem so clearly there's something a
bit different here but nonetheless our
idea of constant integration was
something we've always talked about the
more frequently you integrate your
changes the easiest going to be if you
do with merges because by definition you
should have a smaller scope of change
and therefore it's much easier to carry
out that merge activity but this goal of
integrating once-a-day butts up against
other problem namely not all of your
work can be done in a single day's worth
of work even if you thought think it
could be something it's going to happen
right you're going to call into a
meeting or a volleyball game or
something like that you're sick right
and so you can't integrate every you
can't let's say finish a feature every
single day because some features also
more complex and others so if you want
to integrate often to make it easy for
us to handle merges how do we do that
one we've got work that's half finished
there's a bunch of different ways that
we can handle this problem option one is
actually just don't check in now we
don't really like this anymore
but we used to do this a lot like I mean
we would check it in for several days
and then if your machine broke and your
hard drive got trashed you lost several
days worth of work and so we don't like
doing that anymore because it's kind of
sucky so we want to put our coats on
we're safe in case something bad happens
so that's option number one was put that
to one side option number two let's make
a branch so here what we're going to do
just like we did for our for we took a
branch of that code to allow us to work
effectively on features that weren't
quite ready to go into production being
finished off and then sort of that
promotion activity of now saying right
now that's the relief branch allows us
to release those features you know so
here I am are working a new feature that
feeds it could take me several days so I
create a branch of code and I make my
changes locally on that branch and like
my colleague does likewise they take a
branch as well they work on their
features it allows us to although our
because our features not quite
implemented yet it's not quite fully
there I can safely check in and commit
to that branch and then when I'm ready
I'll merge that back into trunk which is
where I'm going to release from this
might be called master depending on your
version control system and so I've
checked a big change in and I've made
that work and that's
great that's fantastic now my colleague
does the same and find that I played
loads of changes earlier and I get
really annoyed so I've got a whole big
merge activity but this is sort of how
feature branches work right you you have
those changes you make those changes
faithfully on a separate branch allowing
you to make lots of commits until your
feature is ready and then you merge that
back in and we can use CI tools to
actually run builds on those branches as
well so you still get that feedback
about things working and we can
integrate continuously if we want to our
branch so it's very easy things that
goes my favorite CD tool up on these
sorts of things the issue though is we
have the same problem that we did with
the r3 r4 merge here right we are
integrating continuously with our branch
we're not integrating continuously with
everybody else's changes we are still
deferring integration into that
deployable unit it's uh believe me into
my most of my general problem with all
this approach like I mean I the pain of
a merge it was like there's going to be
a function here somewhere I'm hoping
someone to do research in it's but it's
like the pain of a merge is almost like
a function of how big that merge is what
that Delta is and how long it's been
since you last try to integrate with
that code it's like that it's not just
the side the duration because the
duration also matters because you've
lost track of what the hell's going on
on trunk you don't know it's hard to
understand what changes have been made
well Bob while you've been off in your
own little bubble working away after one
side so you know that's not great and
and we know that like big mergers also
lead to the funfun act of commit races
you've seen this happen I have a new
right you'll be working for a few days
on the feature and you know it's going
to be a bitter pain to merge in but you
think you're just about got it right but
your colleague has also got a big commit
they want to make so what you do you
distract them you send them pictures you
send them pictures of of kittens you go
out for lunch and suggest I just want
more beer for you and then you run back
to the office and you check your coding
before they can check their coding
because then they have to deal with the
merge so that it's funny but it's also
annoying there's another issue that
comes up those is another reason why I'm
really
hesitant about having branches for for
feature delivery and that's because
merging refactorings is very difficult
when you just add a new code integrating
that sort of fairly straight foot is
very easy but if you're actually
refactoring your code for example a God
trying to create brand-new abstractions
through move code duplication source
control tools are aware of textual
differences they're not aware of
semantic changes they can't read into
your intent behind a change you made
four weeks ago and reapply that intent
on the new code you're merging in we
don't have operational transforms inside
our source control tools and so what you
start seeing is that when people are
working on branches are around for
several days if they are discouraged
effectively from performing refactoring
because if they refactor on their
branches they actually make that merge
activity quite difficult and so like
you're trying to do something nice or
trying to make the code a nicer place
and all you've done have made your own
job more difficult we try and note that
feature in and so when you see these
very very long live branches you see
that people don't tend to refactor much
and code base is where you have lots of
long live branches again you don't see a
lot of refactoring going on it's too
dangerous and activity okay so I'm not a
big fan clearly a feature branches so
what was the other option we talked
about at the time ok well ok so I want
to integrate often I don't want branches
but if I just checked in anyway ok well
how does that work because if the
feature isn't finished how can I just
check my code in any way so we seem to
make sense but this is the idea behind
we're now called trunk base development
which is everybody integrates into trunk
so everybody there I've been all working
away on the same branch this will be
master in git or whatever it is we're
all integrating it together the idea is
we're integrating really often right
we're getting our changes in we're
making lots and lots of small
integration steps we're getting fast
feedback as when those integrations work
and we're also getting breaking up that
merge plane I'm not having one giant
merge activity to the end I've got lots
of incremental merges going along the
way but again we still need to deal with
the fact that we don't actually haven't
answer here - how about half-finished
features so - mink trunk based
development work where you integrate
once a day - main line into trunk we
have to have some of the technique and
that technique normally comes down to
using something like feature toggles so
feature toggles are a way of you hiding
partially implemented features or
functionality in there in the Guinea
existing system so the really simple
example of how feature toggles might
work let's consider a website okay so
I'm working on the brand new super
awesome amazing super widget which will
display low cats in a nice carousel on
the bottom of my e-commerce website and
it's not quite finished yet because I
haven't quite got the text formatting
correctly and I keep bringing in like
dogs instead of cats so I'm working it
through right but it's cutting edge and
it's any day now it could be great so
what I do is I just actually hide that
widget so we're just not available on
the website I'm not available on the
production site but it's a configuration
file that as a developer you can go and
change the value of that configuration
file saying super widget is on and now
that appears on my web page so the code
is checked in it's all integrated it's
not actually visible in the production
environment it's not visible to my
customers but I have the ability to turn
it on to test it in Scituate be now
configuration files are one way of doing
it obviously that had to get mapped into
a boolean condition somewhere your code
but other common ways of using this is
something like a flag of command line
flag so Google who famously do trunk
based development who don't use feature
branches they make use of flags to turn
features off and on and if you get
really fancy you can even allow you can
even use your flag system to allow you
to turn things off and on at runtime
maybe using some kind of centralized
configuration management system so a lot
of times people will use things like
zookeeper or console to provide
configuration to running instances and
so I think people use these systems to
allow you to turn features off and on
now that's quite easy actually when you
think about something as simple as I am
working on a brand new widget where you
know that widget is a thing that wasn't
there before and I'm just put turning it
on it's quite easy to see how you'd
implement something like that it's quite
straightforward to make that work but a
lot of time of course we're changing
functionality what happens if what I'm
actually changing is I'm changing the
another widget and actually it's going
to behave differently in the future how
would I have implement that well we'll
get onto that so let's talk about how
that might work that's giving a good
Kraig great cater an example of this
actually this is actually an example
from go early days of gogo used to call
crews and when God first started off it
was sort of a single server base node
with you have a manager build farm but
as it grew there was a realization that
we wanted more than one machine running
the server process we didn't have a
single point of failure and item each
larger scale so you've got this existing
system in saigo that was you making use
of hypersonic so hypersonic is perfectly
okay what you want is like an in-memory
database and at this point you know
cruise was just really go with loose
filling small amounts of metadata but it
was actually quite deeply integrated
into the product and so what will it be
able to do is instead say okay we want
to be able to send go live and that
haven't run off your offer proper
database one that would actually allow
you to achieve larger scale ah you know
make it easier in terms of failure modes
but actually implementing you know the
support for say using post grades on my
sequel but the team record had actually
taken a like a few quite a few
concentrated weeks of just a focused
effort to make that change but they
still wanted to be able to ship new
features but the problem was it was
quite it was was using a lot in parts of
the code bases there's this hard
constraint the new versions of cruise
and as they do now is go or available
every two weeks so you can go through
the website and download a brand new
version every two weeks out of the goal
so actually practicing continuous
delivery with a downloaded products is
quite difficult challenge okay so this
change is going to take us many weeks
but we also want to keep the shipping
features and we want to make our
software available for download and we
were check into mainline and this thing
is quite integrated so how do we go
about doing this so the answer is you
create effectively a brand new
implementation of the changed
functionality
so this existing example we're coming up
with a work-in-progress genetics
all participants implementation and so
you can check in an early version of
this it can be integrated you can be
running tests against it but you need
the ability to sort of turn it on to see
how it's working in terms of the whole
system so the next thing you need to do
is need to create an abstraction point
in your code so in this particular
example you come up with say a sort of a
higher-order persistent interface and
then happy ability to turn it off and on
again implement a toggle around this so
by default my hypersonic persistence
implementation is widen and I can change
that configuration value and have it
instead use the sequel consistent
incidents so for many weeks when you
were downloading crews internally
although the average person using crews
wouldn't notice there was a flag deeply
inside the sort of that you should not
touch configuration file that would
allow you to turn on this
work-in-progress sequel implementation
now if you did it wouldn't work it
wasn't finished but the team itself were
able to actually play with that make
sure it was working and configure it and
when they were happy roll that change
out if actually also gave them the
mechanisms to allow people to
incremental move over to this new way of
handing their participant system once
that feature was bedded in and they are
happy with it you remove the old
implementation you could potentially
even if you wanted to remove the
abstraction point so rather than sort of
using feature branching where you have a
branch of code where your other
implementation is or your change in
behavior is instead you are coexisting
both implementations in the same code
base at the same time via an abstraction
point and it's pattern is called branch
by abstraction
so rather than branch and source code
I'm branching in the same version of the
code now this causes people the people
don't like this all the time because
this actually requires that you have to
refactor your code to create an
abstraction point my view all is that is
if you don't feel confident in INRI
fracturing your code to create an
abstraction point you've got different
problems but nonetheless this use of a
bronze by abstraction model allows you
to be checking in a change in existing
behavior without having branching and
then you can turn which abstraction on
your using using a feature toggling
mechanism now there are some things to
be aware of with feature toggles and
there are a few pitfalls and people get
themselves tied up in knots iffy now and
then I'll set
seen some bad uses of these techniques
there are some rules I'm going to bet
the bear in mind would feature toggles
and things the first thing is the flag
however that's using your system your
code base have it using as few places
possible so for example if I'm going to
tell a widget off and on
I only maybe want a say boolean in my
templating language somewhere my
templating code may be one place maybe
two places in code is okay I worked with
one team and they use every flag words
was used in about you know 50 or 60
places across their code bases became a
real nightmare no it got really
confusing so you like one place one
place in your codebase and then you know
when you don't need them anymore remove
them that same team had over 200 flags
that were different in QA versus
production and you had no understanding
as well not the software you were
actually testing in QA was the same that
was actually employed in production
environment so be very very careful
about how you use these flags you don't
want loads you remove them once you're
done using a small number of places and
you'll be okay there are some nice side
benefits when you create these
abstraction points that allow for
toggling of behavior you actually open
up the possibility of implementing other
deployment related activities that can
be really useful when deploying in a
safe manner it can use it for things
like a be testing for example I've got
the ability in the same code base to
Courage's two different implementations
of the same abstraction the same piece
of functionality I've got an abstraction
point where I can toggle between the two
it's not a stretch to think oh I could
now use that to implement something like
an a/b test base you know maybe randomly
I give you a different implementation of
that abstraction point or based on some
characteristic of your customer bases
maybe I even mark this a certain
customer group as being the beta test
customers and they get siva new
implementation you've created that
abstraction point you can now use if
other things can also be used with a bit
more work for something like canary
releasing where we release a brand new
version of our functionality to a small
subset of our users if it behaves
correctly we can ramp up the number of
people that see it so this is these are
different ways of taking advantage of
that extraction point you've got now I'm
actually working on a book at the moment
to talk about this whole thing
everything happens from finishing a line
of code in your laptop to shipping in
production it's not going to be ready
till the end of the year but if you
don't know a lot more about trunk base
development now a colleague of mine Paul
Hammond that's got a great great website
called trunk based development comm
where he'd captured a whole lot of stuff
and the patterns and they use cases of
that so do give that website a read if
you want to know a bit more now coming
out of the wreckage I say wreckage
Dixon's is really interesting was you
know from a development point of view
was often quite tough but it was a
really successful project for the
company both the thought was I'm the
client right it was quite happy with it
but nonetheless we came out of that
experiencing experience realizing long
live branch is really problematic you
know realizing that actually finding
alternative ways of working with
software in terms of how we handle
source control work really important so
that led to extending the idea behind C
I became trunk based development and
then led to you know continuous delivery
so it's no surprise
Dave Farley who's one of the long
hwijae's humble wrote that continuous
delivery was the main text from the
Vixens project and he learned so much my
experiences of that he they they kind of
pulled together these new ways of
working in that CD book the kazoo books
actually I was a lot old my thoughts at
you 2011 and an awful lot has actually
changed since then but so much of what
was in the book still really does apply
now to this day and age you know there's
lots of ideas in the continues to be
books I think a really important one of
the main shifts was beyond talking about
CII and using trunk based development as
opposed to feature branches or this idea
of moving towards treating every
check-in as a release candidate but you
should be happy with every check-in
going into production the reason it
became really important was that shift
in thinking about release cadence and
release frequency I think a lot of the
work that have been done up to this
point especially the work I was doing
with enterprise organizations was about
making releases themselves more reliable
improving code quality but we weren't
necessarily improving the cadence of of
software deployments but when you
started seeing what was happening in the
dot-com startup they was realizing the
value of much more fast and frequent
releases I think it is still being
articulated best in in general sports
talk ox meta metrics in this case and
it's an old talk now but
like still gold so John's now CTO
actually he was previously head of upset
she and before that released manager for
Flickr as he made its observation that
when we release software infrequently we
have sort of a two-fold problem on the
one hand when we take a long time
between releases each release has a
larger change it's a larger Delta
there's more changes more lines of code
that have changed between this release
and a previous release that means that
risk is inherently that release is
inherently more risky as more chance of
something going wrong it also follows
that any release or remediation is
probably gonna be more complicated
because there's much more stuff has
changed
normally with you know large changes in
release between one releases another
it's not some just safest to roll back
rather than trying to fix that thing in
suits you the other thing of course is
that if you're only releasing
infrequently your release process
doesn't use that often therefore it's
more likely it's going to have problems
in it and also you're not learning you
know if the cutter likes these features
are not right and then you get into
these weird nasty anti patterns you
don't release that often when you do
release you have a problem you have a
problem because the size the release is
so large you increase the risk of that
release and she had issues and people
get crossed and say well how how do we
make sure that we don't have a problem
on our next deployment I know we'll be
extra specially care for the next one so
let's take more time and we'll apply
more rigor and we'll put more processes
in place and so the next release will be
even longer from now and let me do that
we've got a problem what should we do
let's pay the even more careful about
the next release and she release
Cadence's increase
it's amazing that how much of the work
I've done around continuous delivery
with clients has actually just been
looking at release processes and
realizing that a large amount of the
procedures that are in place inside that
organization kind of amount to
organizational scar tissue like
something really bad happened to us ten
years ago and we put something in place
to stop that problem from happening
again but no one actually remembers what
that problem was we just know we've got
this nasty sort of scar on our body
somewhere right that's all what of it
what it is
so John made the observations actually
if you shrink your back size down if you
shrink down the sides of each
Lys you have a smaller Delta between
each release that means the risk of each
release is much smaller you're much less
likely going to have a problem with that
and if you do it's gonna be easier to
diagnose and fix it
you also release software more often
therefore your release process is more
likely to work because you do it a lot
and you also get to learn from that and
so one of these ideas came together and
so the continues live ebook was saying
well how can we take that rigor of
ensuring quality of our software
integrating our software more frequently
but also actually ship software to our
customers more frequently it actually
comes back 10 these poor ideas integrate
often so you make sure all your code
works together when you defer
integration integration more expensive
less late to work keep the size of your
changes small and again if you're
integrating often each integration is
going to be small and relate and ship
your software frequently while looking
well Jeff and David work on the
continuous delivery book there was the
little source control engine that could
get was was was buzzing about now git
was covered in detail in the book but
really wasn't making much impact in the
world of software development as a whole
even in 2011 that a number of people
that were using it in corporate sectors
was was quite small it was very big in
the open source sector we should
actually remember where it came from
get with design as a replacement for
bitkeeper which is being used at that
point to manage the Linux kernel there
was a falling-out around licensing I
won't go into it you can read it on
Wikipedia so Linus was stuck for the
problem that he needed a sort of an
alternative source control system and
it's probably important to reflect on
why get works the way it does and it
does to enable people to maintain the
Linux kernel this kind of quite
different to most of software that we
work on most of our software we
integrate down to single deployment that
isn't you know and we deploy into one
location for most of us motors work on
some kind of potential the essentially
deployed system is used by multiple
customers but its kernel is not one
thing there's not one version of even
the 3:6 kernel right it's made up of a
whole number of different patches
different operating systems will apply
different OS patters
patch it into their kernel you know the
the Red Hat comb is different from the
Ubuntu kernel and everything else is
that this it's a different it's kind of
mix-and-match metaphor well nonetheless
though Linus had this I this is this
driver to make it very fast to integrate
patches that were being sent to him most
converging control systems at the time
he reckoned were taking around 30
seconds to integrate a patch his goal
was being able to apply a patch in three
seconds or less now that doesn't mean
understanding the patch and reading it
and reasoning about it but just the
actual process of integrating that in
I'm so going to borrowing from previous
attributed version control systems like
bit keeper and arch and the others we
have gift and get now has a few
characteristics that kind of maybe shift
the game a little bit when we start
thinking about feature branching one of
the very first things I realized is that
the branches inside Gear are
significantly more lightweight than the
traditional version control tools that
came before in subversion for example
branching was a major activity because
creating a branch normally involved in a
whole copy of that source actually on
the server that could be a significant
impact and therefore you wouldn't just
create branches really nearly you'd have
to have a conversation about it what
that meant was that when you did
branches but we want to leave a branch
is lying around for a while and not
often you'd be encouraged to use that
branch for multiple purposes so that
there are three are for example Dixon's
was due in part to the cost of branching
so it was easy to have one branch and
lots and lots of lots of branches those
are the nice things likely had a full
copy the source code here running on
laptop and that's kind of nice and cool
so you can kind of commit locally and
then push from your local source code as
well and also the merging of the text in
github the gate was significantly better
than subversion it seems the better job
of identifying changes in in text and
working picking up things like renames
and stuff like that I mean to be fair
subversion of things have got better as
well
the key thing to understand though is
that branches are more lightweight and
git and that the textual merging has
been better than some of the sisters
before but it's still not actually a
semantic merge people are believed are
not working on this there are people out
there now that are trying to look at
language aware merge tools and source
control systems alright and and I think
I'm hoping at some point in the future
we will have
version control tools
that actually operate you know the
equivalent of operational transforms in
the code you know rather than when I do
a rename of something just storing the
after-effects in a text file
it actually version controlled the
rename operation then that's the only
real answer I think to actually probably
doing merges but most of us don't have
access to those tools I think a lot on
the pipe dreams at the moment so git was
rumbling around at this time but hadn't
really kicked into high gear primarily
because people weren't using it that
much so other than on things like the
kernel but then there was github and
github is probably one say
single-handedly but certainly is a major
part of why gate became popular 2008 I
think it was long github was launched
and it took them a while but they you
know their third blog post talked about
rolling out the support for things
called feature requests their pull
requests so poor requests are actually
in the burliest version of get their the
request that the git pull request is
actually request pull operation I can't
quite remember the the get module was
there for the very early days but the
github developers thought they could do
better and implement the web front-end
and the idea is that if you wanted to
make a change to a piece of code what
you would do is you would fork the code
you want to make a change to you would
make that change within that branch that
fork of the code and then you would tell
the maintainer so look I've got a new
version I've made some change the
functionality if you take a look at it
and merge that change in and this be
proved to fundamentally shift the way
the open-source software is developed so
there's a number of people that have
done some nice work visualizing source
control changes big projects over time
it's quite a nice thing you go back
looking at big projects look at the
source control history you can see all
kinds of amazing things happening one of
the visualizations I found recently
which actually an old colleague of mine
Joe always pointed me to this actually
shows the the sort of development being
done on Ruby on Rails and a really
interesting thing happens when you watch
that video at the point where the Ruby
on Rails codebase moved over to github
you see something quite interesting so
like many other open source tools sort
of Ruby on Rails worked about you know
have a core
of committees that have rights to push
into mainline but they also take commits
and changes from around the wider
community now that process was sort of
slightly always slightly torturous when
we had things like you know none in the
world before change requests as they
pull requests what the river rail people
found out about here is when they moved
over to github the pull request
mechanism drastically lowered the
barrier to entry for sort of untrusted
committers as in people who weren't part
the core team to get involved and you
see this explosion in growth in the
number of committees involved actively
on the Ruby on Rails project and that
that sort of that little twist of making
it very easy for you to work on your
changes safely and then tell people
about them and have those maintained is
look at and apply those changes in a
fairly safe manner really shifted things
along so no surprise in a way that is
only it was very shortly after a long
time you imagine the meteoric growth of
github that for three years after
launching they were already more
successful more popular handing more
commits than both Google Code which now
been closed down and source for together
source forward of course being the big
Daddy at the time and now it's a great
place if you want to go and download
more where apparently that's been fixed
but of course firm you were talking
about feature branching how bad feature
branching was earlier and basically pull
requests are a feel form of feature
branching right you are creating a fork
of the code you're working on that
change and then you are asking it to be
pulled back in the difference is you I
think pull requests work very well when
you've got people outside of a core team
who are committing less piratical II who
are maybe not part of that core trusted
team you have the ability to make it
easy for them to commit but you have the
ability also to vet that change and
integrate that change I think it is a
subtly different thing I don't really
like I don't see people working inside
small co-located team making use of pull
requests in turn in also ask the
question what's the point what's of lots
of value in that ceremony but for
untrusted committers which is ultimately
what the vast majority of open source
contributions represent that the pull
requests neck isn't works very well and
although yes there are some potential
downside side branches you can't have
those on trusted committers committing
really really frequently because they
are
some value of untrusted committees so
that got really successful and github
was really being an incredibly
empowering our representation of how
open-source code could work and actually
how sort of untrusted committees can
work and that's led to similar changes
being provided lots of source control
systems and liners are still angry about
how the implemented pull requests start
you know they want to say she shut up ah
and then of course there was get flow
because if there's something worth doing
that something was doing really
complicated lis so this is an overview
of how git flow works now git really
lowered the cost of creating branches
and it made it much cheaper and quicker
and faster and more efficient to create
branches and so people started using it
to implement different variations on the
feature branching mechanism this is just
one overview of how feature branching
can work so you have master and enemy at
the hotfix branches and we have the
release branches and then we have the
development branches and yet the feature
branches are I don't understand all this
because I'm all of them quite stupid and
actually there are some people that
really like this model and then they've
created tools on top of the git flow
mechanism of how you work but this is a
formalized mechanism for doing feature
branches and so the git flow high level
scripts on top can really help you try
and sort of make sense of all this but I
really have trouble conceptualizing this
workflow in my head and actually when I
sort of managed to peer through the fog
it seems to me that things like git flow
are actually optimizing for a model
where a developer is sitting by
themselves working on feature for a long
period of time and fundamentally don't
sit right with me
this idea that you have a developer who
works on a feature by themselves a long
period of time the creation of software
is a social activity it's a it's a
collective activity I like the idea that
you've got an important feature that
lots of people have worked on that
understand how it works again an open
source world where by definition because
of geography because of availability of
people this is always going to happen
put on the team structure using
something like git flow feels weird to
me because it's just promoting and
enabling working off by yourself and a
branch for a long period of time how
doesn't help me ship software frequently
and integrate often and I get some
people saying ah no but we'll use get
flow but we
you always merge back in really fast and
until you integrate really frequently to
get flows fine they go okay so if you're
integrating back into mainline like
everyday why the hell do you need get
flow it doesn't seem to make sense to me
I'm still not entirely sure of of the
sweet spots or get flow it seems overly
complicated and most people together
head around when contributing to open
source projects and for co-located teams
there seem to be better ways of working
I'm happy to be proven wrong but every
single picture I should explain to me
how git flow works just maybe you want
to kill myself
other things have moved on though as
well we now have organizations that are
actively providing solutions to make
feature toggling more easy so split the
i/o and launch darkly are two of the
best examples of that now poke down a
bit with weird split my own they've got
some really interesting features way it
works is you can actually go and
configure your flags your application
can reach out and grab the values of
these flags from essential system is
you've got a place where you can store
different configuration steps and even
update those things at runtime and so
both of these tools come with an SDK
view integrate into your application now
I have some real reservations about
offloading my feature flagging to sort
of affected a staff based product like
this because ultimately this thing has
to be out for my system to work and
that's that coupling really does worry
me I mean a split i/o team certainly
I've done some stuff around mitigating
those features but I'm still you know
I'm not sure but on the other hand they
make it very very easy for you to
integrate toggles and actually build
really interesting things on top of it
they make it very easy for example to
segment flags by customer so if you want
to enable a beta set of customers you
can very easily say okay that cost was
the beta customer therefore they see the
beta set of features and providing those
high level management they even do geo
locate location aware features so you
can roll out certain features to certain
parts of the world based on IP address
which is kind of cool I'm hoping also
some of you have read this this is a
DevOps handbook written by sort of for
the DevOps II pioneers people there
Jinky and J's humble John Willis and
Patchett apply of course came up with
the term DevOps in the first place and
in this book they do revisit the topic
of trunk based development in the you
know in 2012 16
the book so 2017 looking again at the
concept of trunk based development and
unsurprisingly they have opinions
because jazz wrote continuously wrote
this book as well they thought they say
about trunk based development the first
statement I think most of us can agree
is quite true trunk based development is
like the most controversial practice
discussed in this book I have had more
religious debates about trunk based
development and feature development than
anything else in my career they go on to
say however the data from the puppet
labs 2015 state of devil supports clear
trunk based development but it's higher
throughput and better stability and even
higher job satisfaction and lower rates
of burnout now there was a didn't he
come to Nicole's talk earlier today
hands up anyway if you did so some of
you may know what I'm going to say so
the dick out data the puppet labs state
of DevOps I don't use pocket you chef
what's this got to do with me in a way
this this sort of this ongoing survey
that they've been doing now for several
years it is always maybe miss named
because I think it's now covering topics
so broad that just calling it DevOps in
a way might might under play its
significance but this study has been
looking at the efficacy of certain
practices and culture and behavior so
what they've been doing is identifying
the practices and behaviors of
high-performing IT teams and trying to
work out what practices are sort of
statistically significant in terms of
working out correlation and things like
that so they look at do these behaviors
are these so are these ways of
developing software things that lead to
good higher high performing IT teams or
or not high performing IT teams the
latest version of the reports available
as a 2016 report is definitely worth a
read it's quite terse and the new
version will be available in six weeks
the 2016 version looking at their
analysis says this we have found that
having branches or Forks with very short
lifetimes less than a day before being
merged into trunk and less than three
active branches in total are important
aspects of continuous delivery and all
contribute to higher performance
so does merging code into trunk or
master on a daily basis
so this means that they found a
statistically significant correlation
between practicing trunk based
development and high-performing IT teams
that's not to say that you can't be a
high-performing IT team and you see two
branching just that that's not what they
found in general to be the case and so
it's now starting to get some sort of
fairly rigorous research that's implying
what some of us have believes based on
our own experiences and started to see
that these things might apply now I
don't need to validate your own
experiences you may well have an
organization's using these feature
branches and it's working extremely well
in which case that's great but we are
starting to see now is the research in
general shows that you may well be
better off practicing a different form
of development so summarizing yourself
I'm not necessarily here to say that
branches are inherently evil now
probably less evil than they were in the
past Ferranti has tried doing branch
management in CVS or PVCs or MKS source
integrity or star team's versions or
star team's dimensions or SC TSS CCS so
that was a good one I've used all of
those systems I've used about three the
different Microsoft version control
tools as well and a lot of those
experiences were generally quite
miserable and some of them are regarding
branch branches were absolutely awful
the only one I never got to work with
was clearcase because I made sure that I
was whenever there was a project coming
up where I'd be using clearcase I would
be sick that day
so branches have got a lot easier to
work with and get as shown as how
lightweight they can be just by doing
some smart engineering and so some of
the traditional challenges around them
have been reduced but ultimately it also
combats that same problem is that if
you're using branches to avoid
integration you're probably not actually
going to be optimizing for frequent
delivery of software you're not
optimizing for integration early making
sure your software actually works so by
all means use feature branches or things
like experimental code use feature
branches for use branches for things
like release branching you know we have
a unidirectional merge but using them
for feature branching and still remain
unconvinced fourteen years on is a good
idea I keep coming back to the same sort
of Penance that repeated again and again
the continuous delivery book and earlier
in the work around
continuous integration integrate often
keep your batch sizes small and ship
your software frequently right if you
want to ship software quickly find out
if your software works and according to
setup did not support potentially even
reduce team burnout practicing something
with shrunk based development probably
still the right answer even after all
the changes and shifts that we've had in
technology now I am sure there are
questions and abuse that's fine I'm a
grown-up so are there any questions out
there we have a question in the middle
there we've got time for questions begin
and I'm positive that you have questions
and people have questions that are going
to want to ask them and unfortunately we
are completely out of time but that
means you can do the traditional refresh
the stage and come and chat yes let
impac is last half of first yes so I'll
come in to answer questions down here if
not you can hurl abuse at Sam human on
the Twitter's but thank you very much
for time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>