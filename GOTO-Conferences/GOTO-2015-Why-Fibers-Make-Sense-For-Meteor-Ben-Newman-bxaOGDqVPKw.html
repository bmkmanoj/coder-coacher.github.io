<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Why Fibers Make Sense For Meteor • Ben Newman | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Why Fibers Make Sense For Meteor • Ben Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Why Fibers Make Sense For Meteor • Ben Newman</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bxaOGDqVPKw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay
long coffee break we're gonna get
started with that Newman is gonna be
talking about fibers which is a way of
dealing with asynchronous code in
JavaScript Ben works at meteor which is
based in San Francisco but he lives in
New York so he's all good
all right you hear me
great thanks for coming I'm Ben I work
at meteor development group and I'm
representing them here today as you
might imagine just in case you've never
heard of it
meteor is a JavaScript application
platform that makes it easy to write
live updating highly interactive rich
client web and mobile applications and
it's also entirely open-source so I'm
not here to sell you anything you can
use it if after this talk you think it
might be a good idea or not and I'd be
happy to talk to you about its merits
I've only been at meteor for the last
seven or so months since last summer
before that I was at Facebook on their
JavaScript infrastructure team where I
worked on some things like react and
regenerator but one of my favorite parts
about working at Facebook was that I got
to be one of their delegates to the tc39
JavaScript Standards Committee meetings
which is the body that is formalizing
the next version of JavaScript and so
one of my conditions for accepting the
job at meteor was that they also become
a member of that organization so that I
could keep going and keep being involved
in that although with a very slightly
different agenda so that's my background
I've been doing this web development
thing and especially JavaScript stuff
for a while and throughout that time
I've struggled in a way that maybe some
of you have struggled to explain what is
exciting about my line of work in
particular to non-technical people of
which there are quite a few in my life
so I'm going to share one version of
that story in case it helps you tell the
same story
I'm Benjamin without the ion most forms
of social media and there are slides for
this talk I'm lyin at that URL at the
bottom benjamin decada hub that io
slash go to 2015 - talk so the way I
come at what is interesting about
JavaScript and programming in general is
by saying that I'm interested in the
ways languages change over time and in
particular how programming languages
change although of course
sociolinguistics and etymology of
natural languages are also fascinating
I'm just not really qualified to talk
about that and this talk is going to be
about how JavaScript might be able to
change and javascript suffers from the
the reasons that it is difficult to
change programming languages almost more
so than any other language there has
ever been I think the the great value of
a programming language is that everyone
agrees the people who write code in that
programming language agree people who
run code written in that programming
language sort of implicitly participate
in a consensus about exactly precisely
what that programming language means and
in particular what a computer should do
if you run a program written in that
language on the computer and that
precision is of course why computers are
able to do their work so quickly and
reliably it's why if you figure out how
to tell the computer how to do something
new you can give your code to somebody
else and without even understanding how
it works they can see that it does work
by running it because to a close
approximation it runs exactly the same
on their computer and of course then if
they want to understand how it works
they can dig into it and at every level
it sort of makes sense and that's a cool
property that natural languages
certainly do not have you know we all
have our different understandings of
meanings of words and syntactic
structures and if you hear somebody say
something and you don't understand what
it means you have to fall back on
context clues and asking questions and
that ambiguity is why most of our
efforts at natural language processing
still fall squarely in the realm of
artificial intelligence rather than
simple algorithms like
used for pricing and evaluating
programming languages but the downside
the downside to having convinced so many
people to agree on how a programming
language works is that if you ever want
it to change you've got to convince all
those people all over again and it would
be one thing if they all cared right but
especially in JavaScript case everyone
with a web browser has a particular
version of JavaScript installed and they
may not even realize that they're making
an implicit choice about what version of
the language they're using may not even
recognize JavaScript as a pair of words
stuck together and so convincing them
that it's a good idea to upgrade has to
either be a really good argument or
really easy and the like insurmountable
'ti of this task used to be the most
depressing thing about javascript people
thought that it would never change that
it was stuck in its 1995 ways because it
was just too much effort to get it to
change and while it is still definitely
true as Brendan Eich has said that the
web is a brutal shortest path versus
better evolving system I think we can
finally say that that evolution is
proceeding more quickly than it used to
javascript is finally becoming the
language that we want and many new
features that are proposed in Ethne
script 6 or even ACMA Script 7 can be
simulated without any changes to the
language which is cool this is what
babel Jas and Tracy are are all about
and they account for most of the new
features in the language which is
awesome so we get to have the future now
here's a simple example of an es6 arrow
function that is being passed as a
callback to this sort method and it can
be pretty trivially transformed into an
es5 function expression and this just
runs in all browsers today so this is
sort of like if you went to the effort
of like rewording your you know fancy
new lingo in something that people who
understood an older version of english
understood and it's great that it
requires not as much effort so that's a
great story and it's really exciting to
have things like generators and modules
and classes today rather than five years
from now but not everything
unfortunately that has been proposed
or es6 like proxies and symbols can be
translated or it can be simulated with
any fidelity and today I want to talk
about a powerful feature that could be
part of Java scripts that isn't now that
cannot be simulated in any reasonable
way this is not a riddle I'm going to
tell you in a second what it is but I
want to be perfectly clear what I mean
by reasonable here so a reasonable
translation needs to take futuristic
code and turn it into you know maybe
more convoluted harder to read current
day code but that current day code still
needs to be readable and debuggable and
recognizable as JavaScript rather than
say if you just like generated bytecode
from LLVM and ran that on a virtual
machine that was implemented in
JavaScript like that's always a backup
option but we'd have to throw out a lot
of our relatively mature tools like the
the Chrome and Firefox and Safari dev
tools and web inspectors and all of that
tooling so we'd be sort of throwing the
baby out with the bathwater I don't know
if that's the right metaphor but the
other problem with it is that we'd sort
of be abandoning the progress of
javascript giving up on letting our
experimentation with these new features
actually inform the progress of the
language because you know we just be
sort of doing our own thing so that's
less good in my mind but if it comes to
that you know we'll do what we have to
so this feature that I'm about to tell
you about is actually available in
meteor today so without further ado it
goes by a couple of different names one
of them is co-routines the other is
fibers co-routines is the sort of
computer science erosion that Don Knuth
originally used when he first talked
about them so what is a fiber or a
co-routine well JavaScript as you know
it has a strict run to completion
execution model which means you know if
if you're executing some code you can
rely on it finishing either like
throwing an exception and bailing out or
all of your functions returning and
unwinding the stack and once the stack
is empty again after all your functions
have returned or been aborted then other
events can be run in the event loop
so in other words the current the call
stack must unwind completely before any
other events can can take place so if
you've ever wished that you could simply
pause what you're doing right now in
handling a request or an event and then
let some other events run in the
meantime and then later resume where you
left off that's exactly what Co routines
are for sort of a cooperative task
switching paradigm and it's important to
note that it's not multi-threading you
know things aren't happening at the same
time they're just taking turns more
rapidly than they normally do alright so
here's a simple example of the way the
fibers API works in order to be able to
suspend the call stack you need to
establish a fiber and then the function
that you pass through that fiber can
call other functions like this sleep
function and those functions no matter
how deeply nested they are can call
fiber yield to suspend the whole fiber
so this will console that log before and
then wait a second and console dot log
after and if you think about how you
might implement that sleep function
without fibers it'd be very difficult
you're just sitting a while true loop
and like check you know new date give
time periodically but that wouldn't let
anything else happen so the fact that we
can make this sleep function look
synchronous in the way that we call it
is pretty magical and the way we do that
is that we grab the current fiber this
won't work if we're not in a fiber then
we set a timeout for the specified
number of milliseconds and we yield so
when fiber run finally gets called that
fiber dot yield from the perspective of
this fiber that statement will return a
sleep statement will return the stack
will unwind so this is the simplest
example I can find but it's still I
don't know if you've never seen fibers
before and you come across some code
like not only is this doing something
surprising it's like not the world's
best API so one of the things I want to
talk about in this talk is how we can
make that API look a little more
familiar now although I'm coming from
the perspective of sort of the the
minority opinion that this is a good
feature at least for JavaScript it's
worth noting that this is not like I
don't know continuations which are only
really supported in scheme and some
lisps many other languages support
co-routines
in fact bolding the ones that like I've
written where then I'll line up here so
these are you know real languages for
sure and so this is something that works
some of these are maybe a little
disingenuous like it's not built into
Python in fact Python uses a very
similar native module to the one that we
use at meteor to have this feature to
JavaScript so but these are all
languages in which you can and people do
successfully use co-routines so why not
javascript well Dave Herman who is one
of the people I respect most in the
world who works at Mozilla and is
another member of the tc39 committee a
few years ago wrote this blog post why
co-routines won't work on the web and
it's a great blog post I'm not going to
try to go through and refute each of the
arguments he makes in fact I'm going to
bring them up as problems that you
should know about but I have some ideas
about how we can mitigate them and I
guess the the point I'm making here is
that someone well regarded on the
committee that controls the future of
JavaScript is very much against them and
against co-routines that is and so it's
going to be an uphill battle though this
is among the things that would be in my
current company's interest to push for
in the future it's definitely the case
this is almost a cliche that programming
language design is as much about saying
no to tempting features as it is about
saying yes you just can't you can't have
everything not everything works together
and it is absolutely the job of a
standards committee to put together a
coherent language you know even if it
doesn't have some nice to have features
but gonna make an argument that we could
have a coherent JavaScript that
supported co-routines
so if we can agree that making
asynchronous programming easier is
important for the future of JavaScript
and it sure is and tc39 is not
interested in co-routines
and what are the remedy do they have in
mind hope they've got something planned
you may have heard of async and a wait
now this is a future that has been
proposed for atmosphere of 7/4
background echo syrup 6 is the version
of the language that has just been
finalized and so these aren't making it
into that but the next version there's a
lot of momentum behind them it's a it's
a feature that was borrowed from c-sharp
and the c-sharp people love it so I
think it's safe to say this will
definitely become part of the language
so how does this work well you can take
a function and add the async keyword in
front of the function keyword and that
means a couple of things the function
will now always return a promise which
is like a deferred value encapsulating
its eventual result but also if there
are other things you need to wait on in
the course of evaluating that function
you can pass them as arguments to the
awake keyword which is syntactically
sort of like throw or return or yield
takes an argument if that argument is a
promise then it suspends the the current
function and when the promise is finally
fulfilled it evaluates to the result of
the promise and if the promise is
rejected then the await expression
throws an exception so you could
actually use a try-catch block here you
know like one thing that we've sort of
been getting away from with callbacks
and promises is that you know you you
don't get to use these things that are
built into JavaScript like return
statements and try catch blocks but this
is sort of bringing that back so we're
doing two awaits in that function this
composes really nicely so you can have
other async functions that also await
the result of in this case create user
so we've got like you know the the
version of the function that always
creates the user and the one that checks
see if that's already a user with that
name
and then only creates it if they don't
exist yet now at some point you're going
to need to call an async function that
is from from a call site that's not also
in an async function and remember that
it returns the promise so now you're
back to just attaching callbacks to the
promise to get at the value that's
pretty familiar in today's JavaScript
and this feature is planned for es 7 as
I mentioned but it's actually available
today with a pretty good simulation via
regenerator which also transpires
generator functions and if you happen to
be in an environment where you already
have generator functions implemented
Navin natively or maybe you're handling
them some other way you can transpile
async functions to generators using
another module
I wrote both of these modules so I mean
I I stand behind them but there could be
other possibilities like tracer so let's
try that with pure promises actually I'm
gonna skip over this cuz this isn't all
that interesting it gets like a little
worse the lines are a little longer but
if you understand promises it's like not
that huge of a savings of boilerplate to
use async functions though I will say if
you had a weight inside of a loop that
would look pretty nice in the async
function context but with promises you'd
have to like chain them together
iteration to iteration and that gets
messy but what about callbacks well
let's try that so this is our promise
version and the real rub here is that
you've got to handle all the error cases
so you know in case the first
asynchronous operation comes back with
an error you have to handle that if the
second one comes back with an error I
have to handle that and you can't just
like pass callback as a callback to the
venn function because it has this kind
of funky nodi API where you pass the
error or null first and then the result
second and likewise with get or create
user it just becomes like not as
terribly nested as pure callbacks
because we're using promises here but
the like number of lines of code
increases dramatically
so unless you're familiar with this
style of programming this is is pretty
obscure it's hard to see what's going on
until you've like really parsed it and
run it in your head so I think it's fair
to say we've come a long way but we're
in the business of perfecting this
language and there's no reason we
shouldn't be asking if we can do even
better than async functions I will be
excited to have a version of JavaScript
that supports a saint can await but I
would be even more excited if it worked
in the way that I'm about to describe so
I claim if JavaScript had co-routines
then we could implement these async and
await keywords without any new syntax
because there are keywords that in
itself is new syntax but what do I mean
here well we could turn async into a
wrapper function sort of like a
decorator in Python where we pass the
the original function to async and it
returns a wrapper which we bind to the
create user variable this is since these
are function declarations you know they
should be hoisted so this isn't a
perfect translation if you really like
into the details of that but you can see
that this would be a pretty easy
compilation target if you were trying to
go from es7 a single way to yes five and
similarly with a wait I'm just gonna
turn it into a function by having some
parentheses here is it really easy and
now if you didn't know that these
functions were doing anything magical
this would look just like JavaScript of
today you know I'm accepted Alette
I guess because that's es6 these are
just function calls so how might these
magical functions be implemented well
here's a wait and this is a fully
functional implementation a wait is
going to take an argument which might be
a promise it's okay if it's not
it'll just evaluate to that argument
itself if it's not a promise grab the
current fiber because it's a important
that we are in a fiber so that we have
something to suspend and resume later
I'm going to go ahead and take up four
lines with this assertion that just
guarantees that later we're going to
yield
return something whatever is returned by
fiber yield and since argument might not
be a promise we call promised at resolve
to course it to a promise if it is a
promise a promise don't resolve just
returns the argument itself so this is
lightweight and attach some callbacks to
it in a success case they call fiber dot
run if you're familiar with generators
this is kind of like calling generator
that next and in the error case we call
fiber dot throw into and that's actually
all we have to do so the argument that
you pass to fiber dot run becomes the
result of the fiber yield call when it
finally returns and if you throw an
error into it then that fiber dot you'll
call throws an exception so if you like
wrap that in a try-catch block you could
catch the error later although you want
to do that here all right so not so
magical after all here's async which is
coincidentally the same number of lines
it's going to return a wrapper function
and that wrapper function needs to
always return a promise because that's
the contract with async functions and
inside the promise we establish a new
fiber a new call stack that we can
suspend and resume so you could have
like two async functions running sort of
in parallel because they both have their
own fibers and somewhere in there we
want to call the original function with
the same value of this and arguments and
if that is successful of course you can
imagine we want to pass it to the
promise resolve function my apologies if
the promise API is not familiar it is a
little weird that like there's this
function you pass to the constructor and
then it takes arguments that are
callback functions you're supposed to
call but the slides are online and it it
does actually work okay so f in dot
apply will throw an exception if there's
any problem even if it happens like in a
later stage of the fibers execution the
fiber itself can like yield multiple
times so in case there was an error
thrown and we want to use that as the
rejection reason for the promise and the
only thing that's left to do is to kick
off this fiber by calling its run method
all right so those are a sink and a
weight
and if you've got something like fibers
or some other implementation of
co-routines then you can like speed
ahead to the distant future of
JavaScript and have your s7 a sink and a
weight already so once we have these two
functions in our tool chain this is sort
of an aspirational statement for meteor
this is a direction I would like to see
us go in but I have to be honest that we
are not fully there yet we can actually
just forget that these two functions
were implemented using fibers it becomes
an implementation detail that we don't
have to worry about anymore
just as I typically don't remember that
node fibers is implemented on top of Lib
Kuro which is this C library that swaps
out stacked pointers and thread data
pointers to make co-routines work with
literally no changes to v8 which is
insane
but these two functions I hope I've just
convinced you that they're at least as
powerful as async and await they're
actually more powerful than that which
is both good and bad so here they are
the natural question to ask since it was
definitely the case that we needed all
the await and async keywords in the
original example do we need all of these
async and a weight function calls here
well sort of a leading question the
answer is no let's try removing some so
the first one we're going to remove is
the call to async around create user
because if we're willing to say that
create user is only called from other
functions that are async or you know
with some async function somewhere above
it on the call stack then those weight
instructions expressions inside of
create user will be legal there's
nothing wrong with them they don't have
to be directly inside the body of an
async function and because create user
is now just returning a simple value
it's no longer an async function it
doesn't return a promise we actually
don't have to await its result in get or
create user so that can go away we could
it would be harmless but we don't have
to and in fact if we're willing to adopt
the practice of running most all of our
code in a fiber then we can get
the async wrapper for good or create
user - so all we're left with our weight
expressions and so in this coding style
the weight function sort of becomes a
tool for evaluating promises
synchronously if you happen to think
that that is more convenient in certain
cases and I don't want to make this seem
like like broad recommendation because
it can actually still be valuable to
mark functions as a sink so that they
can run in parallel it's good for the
like learnability of meteor for new
developers new meteor developers you may
just be like new web developers full
stop to not have to think about async
and weight and promises on there like
first day of learning meteor so that's
one reason that hiding this from users
can be a good idea
but even for sophisticated users who
want to paralyze these operations so
that they're not blocking on each other
it's important to give them the ability
to say that get or create user is in
fact a sink so that it can return
immediately and start creating both of
these users simultaneously and then you
know if you know what you're doing if
you've heard of promise dot all before
you can sort of join on all their
results and it won't be the sum of the
times they took but some like
combination of of the times so it might
still be a good idea to leave get or
create user async so that it returns a
promise so that Marley doesn't have to
wait on bin so if you if you know meteor
you may be wondering how if this is only
available in the server how meteor
allows database access on the client
because that's one of the niceties of
meteor that you get to sort of write the
same database access code on both client
and server and that currently is sort of
a bit of trickery I mean that in the
best way
mini Mongo is our client-side
implementation of the Mongo API and it's
essentially a sophisticated cache that
we pre-populate be based on publication
data on the server it supports a subset
of the Mongo Collection API like you
know fine find one insert update remove
and those methods have to return
immediately like they
they don't get to return promises you
don't like pass a callback and wait for
the result and that certainly doesn't go
to the server and ask for the new data
so if they have to return immediately
you might get into situations where you
you call a function like fine then you
don't get any results back even though
there actually are results that are
pending from the server and the way we
get around this is through leveraging
other strengths of meteor this is
acceptable because meteor automatically
rear Enders the UI whenever different
data become available so if you render
your UI in a way that is that works both
when there's no data and when there is
data then on the initial page load
you'll get the version with no data and
as soon as the data is available you'll
your UI will just automatically update
right so it's sort of like waiting on a
promise except that you have the
opportunity to see something before the
data is actually available which is kind
of cool but it's just very different
from what happens on the server and I
want to make that clear so how should
meteor allow database access on the
client this is an open question but if
we wanted the database access API on the
client to look exactly like the one on
the server and have the same semantics
we could rewrite both of them to return
promise objects that's like a pretty
standard JavaScript thing to do these
days now that promises are baked into
es6 I think most asynchronous API is are
going to be written in that style going
forward so you could think if we did
this of a weight as just a convenience
that happens to be available on the
server and it would be a pretty sweet
sugar to have in that context but you
know depending on your your feelings
about running exactly the same code on
client and server you might be
interested in that or you might be
interested in just using promises in
both places okay so this isn't the end
of the talk but if you understand these
next couple of slides then you're in
great shape you can think of co-routines
as sort of a relaxation of es7 async and
await syntax in which the await keyword
is allowed to appear in the body of any
function that happens to be called
within a fiber and if it's not a fiber
it'll just throw instead of the as in
es7 being restricted to the bodies of
functions that are explicitly marked as
async right so you know and in the way
that you can throw an exception from a
deeply nested function and it bubbles up
the the call stack the the version of a
sink and a weight that I'm proposing
allows you to bury a weight in some
deeply nested function call and have
that suspend a fiber that may have
started many function frames up the call
stack okay so here's our original async
and a weight what we're doing here is
saying that some of those awaits are
actually not necessary and depending on
you know what kind of API are trying to
expose some of those a sinks are not
actually necessary you know so is this
better code well this is sort of a
contrived example and so it's not you
know it's it's clearly shorter there are
a few fewer letters in it and this
future this future is possible although
it is not currently on the roadmap for
yes seven or beyond but this is
particularly great news for a framework
like meteor because what we can do if we
don't have to make every function that
contains a weight be an async function
is wrap our top-level request and event
handlers in fibers which is code that
you know we control you know it's it's
open source you can definitely see it
see how it works but you don't have to
think about it that just means that most
of the code that you encounter when
you're using meteor will be in a fiber
at some level and you can you know
create your own fibers if you want to
like control the parallelism but for the
most part you don't have to worry about
that and then where do we put the awaits
well we can use those to implement some
asynchronous library operations down in
our core packages and all the code in
between doesn't have to know about
co-routines at all you know this isn't
like a magic trick it's not like we're
trying to hide it but
you know if you're if you're not at the
point where you need to think about
those semantics then this is not
something that's forced on you when you
first start using meteor best of all and
this is sort of something I came to
realize while I was preparing this talk
last week so I hope it seems novel and
interesting to other people too if es7
adopts async and a way as they've
currently been proposed that's actually
great news it's not a parallel history
like an offshoot that you know meteor is
going to be diverging from if we keep
using fibers it actually means that
we've got all the syntax we need and
tc39 is not going to have to invent any
new syntax if we ever decide to adopt
co-routines it'll literally just be a
matter of relaxing the syntax because
anything you might want to do with
co-routines can be expressed in terms of
a sink and a weight just with that
slightly relaxed set of rules about
where a weight can legally appear so I'm
really excited about a sink and a weight
and about having this conversation with
tc39 about whether we might consider
relaxing the syntax because the the
benefits would be pretty sweet
especially for meteor so there has to be
a catch I've you know portrayed this
idea that Dave Herman is arguing in that
blog post is not so great as a really
good idea so far in this talk and I
would be irresponsible not to mention
that there are in my mind three big
problems we have fibers the first
simulating fibers in the browser is
difficult difficult to impossible I'm
not actually going to say impossible but
let me show you what that would involve
and meteor is a framework that tries to
let you write the same code on client
and server so this is kind of an
unfortunate inconsistency you might
though think we could implement fibers
using the s7 a sink and a weight because
they're sort of you know similar
features just like maybe you'd have to
insert some extra a sinks and weights
well yeah to say the least technically
it is possible though it would require
waiting any expression in your code any
expression at all every last identifier
that might possibly evaluate to
promised objects and then of course
you'd be adding a bunch of awaits
throughout your code any function
containing one of those awaits would
have to become an async function because
of the syntactic restriction and then
all of those new async functions would
return promises so there call sites
would have to await the promises and so
on and so forth so you can see that
unless you had like a strong type
inference system that allowed you and
c-sharp has a type system so it benefits
from this kind of thing it knows what
expressions or promises and what
expressions are not unless you had that
kind of type system then I think nearly
every function in your code base would
become async which you know if you're
just playing around with your code that
might be a nice academic exercise but it
gets pretty hairy so these are our es7
async and weight functions the current I
think best way of transpiling them into
es5 is to run them through a generator
or babel j/s which uses for january
there and they they just get a little
bit longer and harder to read and debug
especially if you've never encountered
this kind of soup before and these are
bear in mind the the versions of those
functions that you would actually write
by hand in yes seven and what would
actually happen in practice is that in
order to reliably transpile this into es
seven you'd have to take every single
expression and await it so now we're
awaiting the users object before calling
the insert method where a waiting name
because who knows what that is you know
we're a waiting response ID in case that
property happens to be a promise you
know we just don't know any better and
so this turns out to be even longer I
mean maybe I'm over selling this because
this is not like pages and pages of code
you know this is a this is an okay like
nuclear backup option but I don't
particularly want to stop start the meme
that meteor just like eviscerates your
client-side code you know you open up
the debugger and you're like what is
this I didn't write this so this is just
a bit too much to swallow if we can
avoid it
the second catch
is that mutating shared global state is
tricky with fibers just as it is tricky
with multi-threading the section in Dave
Herman's blog posts titled
fibers are almost as or co-routines are
almost as pre-emptive as threads is
basically about this topic of course you
know we all know that minimizing the use
of mutable shared global state is a good
idea if you can but one place you're
probably not going to be able to get
away from that is the omnipresent file
system it's this you know global system
resource that is definitely mutable and
if you have two fibers that are like
interleaving operations and one is
trying to list the contents of a
directory and the other is removing or
adding files to the directory you know
you very well might get back a list of
directory contents that never actually
correspond it to the file system and
that's that could to say the least so
it's unfortunate that you can't just
like live in the dream world of having
no shared global state if you could this
would not be such a catch so how do we
write say file system code with fibers
at meteor I want to preface this by
saying I don't think this solution is
perfect
but we have this helper called no yields
allowed and you pass a callback function
to it and then in the context of that
function fiber dot yield becomes illegal
it throws an exception and you know you
find out about that at development time
so you can fix it
you know you have a bug it's kind of
heavy-handed I think this could be
recruit improved if if you restricted
what kind of events what other kind of
events can run while your fiber is
yielding like if you're both accessing
the file system if you could say you
know don't schedule any other events
that are planning on accessing the file
system then that would be a lot more
precise than just preventing the current
fiber from yielding at all because
yielding can still be useful and safe so
if you have any ideas about how to
implement that how to like exercise
control over what gets executed in the
event loop in JavaScript then I'd like
to talk about it
we also do this thing where we wrap the
functions in nodes filesystem module so
that they can behave asynchronously when
fiber current is defined when we run a
fiber and we just use the synchronous
versions of your outside of a fiber so
that's kind of a unique benefit of the
filesystem module that it has both
synchronous and asynchronous versions of
all those methods it allows us to
provide the same API no matter where you
are which is cool but not the most
generalizable thing okay so the third
catch the last one is that it's kind of
a pain to ensure compatibility with
fibers other native modules that we're
using might not work well with fibers if
they're doing crazy things the node
fibers module is mature enough that
normal old JavaScript code is probably
not going to interfere with fibers that
much but you know who knows what a
native module is doing using its own
threads manipulating the call stack on
its own all those things are potential
compatibility hazards for for fibers so
we just have to be really careful when
we're releasing a new version of meteor
and our long term ability to keep up to
date with the latest node is definitely
impacted by you know the fact that it
might change its native module API and
we'd have to adapt the node fibers
native module to go along with that and
who knows one day that might be just too
difficult and we'd have to come up with
something completely different
but fortunately we have plenty of
winning we're still shipping node 0.10
and people are ok with that although I'd
love to upgrade and we also have the
luxury since it's sort of like a
all-in-one package of shipping a
specific version of node and specific
versions of all of our packages so it's
not just like you install whatever the
latest minor version of your NPM
packages are available in the day you
decide to start using meteor it's a
little more conservative than that and
that's how we can sleep at night
so for meteor the benefits still
outweigh those three negatives the first
of three main benefits is learnability
for new users of meteor maintainability
you know the less code that you leaked
your abstractions into the less you have
to update when you decide to refactor
things all the code in between request
handlers and library functions that
yield need not change or you know you
not changed much when you change the way
that you are doing asynchronous stuff
and flexibility so not only is this good
for first-time developers it's also good
for sophisticated developers who know
about promises and want to unwrap that
abstraction and write code that is
faster because it is more parallelizable
so those three things are why we're
going to keep shipping fibers with
meteor and in our sort of you know
easygoing way suggesting to the
community that this feature deserves
another look so thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>