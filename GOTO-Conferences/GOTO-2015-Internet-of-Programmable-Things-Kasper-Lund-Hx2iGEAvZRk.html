<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Internet of Programmable Things • Kasper Lund | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Internet of Programmable Things • Kasper Lund - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Internet of Programmable Things • Kasper Lund</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Hx2iGEAvZRk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Casper em and i work on
internet of things but mostly
programmable things at at Google and my
background is it's very much in the
language of space so I'm I worked on
embedded Smalltalk systems JavaScript
engines and recently I worked on dot a
structured programming language for for
the web but clearly this doesn't really
match anything sort of in the title so
we're going to change a little bit now
and focus on something not on this slide
not in my sort of usual background here
let's see this thing going so the reason
why I'm here is that over the last few
years we've seen an explosion of devices
for what we all refer to as IOT it's a
big word actually three words so it's
like three big words and it means a lot
of different things to lot of different
people and but I got to try to focus on
one part of it here the most interesting
thing here is really like here is an
explosion of devices we're seeing a
tremendous growth and it doesn't seem to
be slowing down anytime soon and if you
put it in perspective and think about
how many smartphones or cell phones you
have today we're around like at one
estimate is around like 7.5 billion
smartphones but that's very much limited
by the amount of people we have like
some people may have two phones or three
phones but it's kind of hard to have a
hundred probably doesn't make sense
whereas in your home in in some cities
smart cities and enterprise settings you
can have lots and lots of devices and we
all want to sort of hook them up
together and make them hackable
programmable so this term intent of
things it really means almost too much I
think and it's about gathering data and
then sensing it surroundings processing
these data and transmitting them it's
about transporting this stuff across
networks so this is I involve switches
and sort of network hardware it's about
storing this information possibly in the
cloud it's also about analyzing and
extracting insights from this and this
process then gathered data
and it's certainly about controlling
devices and the environment based on
alerts or in science gathered and so
there's a lot of stuff going on here and
and maybe even more importantly there is
also sharing of this data to other
systems so it's almost like this means
too much so I'm going to try to cut it
down here and focus on a couple of these
things and turn my attention to to the
spaces where the devices are really
present and where you can really start
to talk about programming these devices
so certainly in the in the sense space
where you have lots of small devices
that are doing monitoring and sensing it
makes sense to talk about in
programmable devices but are certainly
also in the in the control space you can
talk about having devices that are
controlled from other systems or even
control other systems so we focus on
those things we can set up narrowed live
it down I this are not the only two
device that fit this but there's like
two two different kinds here there are
like smartwatches on the on the Left I
guess on the right for you guys and that
are fairly fairly big I mean it's it's
it's not small systems we're talking
about they're running like micro
processors they probably have a hundreds
of megabytes of RAM there I fairly big
things but they still fit in here and
and usually in the control way that they
are used to control other devices just
like a smartphone would fit in here as
well I don't know if you know what this
this thing is it's an Amazon dash button
it's a new thing you can buy these for
like five dollars in the US and what it
does it allow should have a small button
you can put somewhere in your kitchen
and when you press this you order more
macaroni and cheese it's it's pretty
clever and they're all sort of branded
you can get them for like diapers and
whatever you want to write you can put
them or you want to really cheap and
they cannot run a big microprocessor
they run something much smaller
microcontrollers so we think about this
split into two segments and if we look
at the hardware involved like the
microprocessor space is way too much to
just order macaroni and cheese like one
sort of setting here is there or one
kind of device here is like the
raspberry pi like it's really again a
full-blown and system that has like a
quad-core processor that runs fairly
quickly
as a gigabyte of ram and it's extensible
through a external micro card microsd
cards it's not that expensive and it can
run sort of all almost all systems and
runs windows today and runs linux it's
probably the most commonly used OS on
them it can run more or less everything
this is like a small server it's fairly
small it's fairly cheap but it's still
sort of a server I find the other kind
little bit more interesting this is a
very high-end microcontroller a fairly
new one and it has an arm cortex-m seven
core and and like this a high sort of
high-end specs for that space 32-bit
CPUs and like a reasonable amount of RAM
like 320 kilobytes of RAM quite a lot
and maybe up to a megabyte of flesh and
but it they still actually cut some
corners in producing this they decided
not to have a double-precision
floating-point unit and there's no sort
of fancy memory management unit put in
there as well so it really put some
burden on the people developing software
for these things to be able to live with
those restrictions it's not a full-blown
thing so in this presentation I'm going
to focus mostly on these kind of chips
because I think that's really where the
explosive growth is going to happen
because a like even though this is
really really high in my controller it's
still a lot cheaper than the other one
and we're seeing chips that are way way
below a dollar in there in production
and cost so it's it's it's happening so
people really want to run something like
embedded linux on they're really small
devices so a good question to ask is
like is that even possible right and
people talk about this you see Linux
which is a Linux that runs on very small
devices without memory management units
but it really requires something like
four megabytes of RAM and maybe two
three megabytes of flesh so it's really
really hard to run something like Linux
and in that space and that makes a lot
of people sad they're really used to
they were used to having this like I
just put linux there then I have my all
my tools that I'm used to and it just
kind of works doesn't really work that
well in this setting so we need to
figure out what we have instead so we
will left for something like this like a
GCC is an important one or llvm and
maybe you have the some debugging
support as well but it's fairly fairly
primitive maybe this is a little bit too
much you
probably have a bit more than this but I
think the best case scenario is
something like this or you have some way
of writing C code and like this is a
fairly well structured nice example from
from embed produced by armed and in if
you're lucky enough you also have a GDP
that runs across some sort of remote
device connection here that allows you
to work with the system often gb is a
little bit unaware of like the threads
that running on top of the OS so it's
like it's like doing kernel level
debugging it's pretty hard but it's
still way better than not having it I
think this is sort of the best case
scenario for development for these very
small devices and to me I kind of like
this thing but I know a lot of
developers are not comfortable really
writing a lot of code this way and if
you work in big teams it's really hard
to do anything with technology site like
this so what we see today is that there
are not that many developers that are
really productive with a setup like this
so I think we need to change that
somehow so now is the part where I tell
you well what I really want but also I
think what you need really need and
let's hope there's some overlap between
the two things I guess I think there
isn't that's the reason why I'm here so
I think it's really important that we
get a platform that's much more
accessible to a much broader range of
developers and we need something that
seems familiar to a lot of people not
just again so yeah a few few thousand
people around the globe but in something
that can reach like a million f
developers not let that nephew and I
think we needed to be based on some sort
of high-level managed language that
makes more people more productive in
this space there are a few choices we
can make there and I have a good idea
about what we should choose but they
will get back to that of course but I
think this isn't really important to
make devices a sort of programmable by
well I say everyone but at least like
making them much more accessible and
much easier to to hack on I think we
need to change it a little bit you also
need a much more productive environment
right now I mean you can build really
cool things really cool I te o io io t
gadgets but it's more instead of in
spite of the tooling then it is because
of it so I think you need a productive
environment with like static analysis
code completion things you're used to
from higher level stacks
need that in this space as well and you
need a sort of an ecosystem of
functionality they can pull in and reuse
across these devices and at something
that's really hard to write with C code
it's not necessarily the most portable
code in the world and so you can write
it in a really nice way which it's it's
pretty portable but you still have to
care a lot so we don't see a lot of
sharing going on and at least I think we
could do way better and I think this all
is needed to make people built these
things a lot not quicker than we've seen
in the past and so I think about how
much faster people are developing web
apps than they are like building
embedded apps if we'd somehow bridge the
gap a little bit and make embedded
developers more or less as productive as
people developing for the web today it
would be a lot better at least maybe the
most important thing that I think we
don't have today is is an open sort of
serviceable platform a platform where
you can where you can upgrade software
components in there and a platform where
you can have in the independent develop
code coexist in the same space with some
guarantees and and something that can
really like propel the devices from
being fairly static with a set of
firmware with I guess known security box
and everything to something that's
really extensible and configurable
something that you can in your home
install a bit of software on that will
enable some functionality to come to
life I think this is this is really core
and right now that there are a few
players that are trying to build this
thing but they're mostly focusing on
micro process and upwards and we see
very few that are trying like really
hard in the lower in space there are few
but but it's hard so I guess we have a
few requests here we would like a lot of
things like it has to be managed
language and it has to be everything
it's it's like libraries and modulus
serviceability changing code and has to
run on really small microcontrollers and
it's it seems hard to to get everything
you want I know people that really want
a pony and they're not having it people
that want like golden toilet seats it's
not necessarily in the cops either but I
think we can actually have a lot of this
maybe not everything but i'll tell you
what where we can start and then we can
figure out how we can move towards
having everything so one possibility is
to start with a high-level language like
dart and this is where Sarah I come in
that is the language I helped design a
few years ago and we started out
designing it for a for a web setting but
it's a fairly general purpose in
familiar language to most it is a
high-level managed language object
oriented and it has a syntax that looks
a lot like see which is I think is a
benefit in this in this context there
are newer and cooler languages around I
think too that look way less than C and
are way less like see them and artists
but in this context I think it's really
a strength that you have something where
like the usual things you do in a small
embedded setting the kind of code
snippets you see there will sort of
translate fairly easily to this this
thing and if you want to play around
with dart you can go to our dart pad
that dart line the dork side where you
can just try it out in the in a browser
context just to get a feel for what the
language is but this is not a
presentation about dart so it's just
like enabling technology for doing what
I'm going to show you so the one problem
we do have though is that does start
actually run on these micro controls at
all and and up until now it's been a not
really I've we've been running on
microprocessors and in different
contexts on smart phones and smart
watches and things like that but on the
sort of the lower end of what we usually
think of as device that you can program
we haven't been doing very well so i'm
going to i'm here to tell you that's
that's changed so i'm going to give you
as like a sneak peek of a project we've
been running it for a little while I'm
call it Fletch Fletch is a small part of
a dot so that's the reason why we chose
that name and Fletch is a system that is
small and light productive and and
serviceable and and fairly simple and
accessible that allows you to write high
level in this case dart code for small
microcontrollers so to actually make a
small runtime or small virtual machine
for a managed language fit in a
microcontroller setting and we have to
think about what what is usually put in
these in these systems and what we can
remove so this is not necessarily the
the common definition of a virtual
machine but we see the trend right now
where people think of a virtual machine
is something that executes source code
directly so it just takes care of
compiling the source code to whatever
native code needs to compile it to and
to run it and it needs to have an
execution in that I can run that code it
has to have a garbage collector and some
way of defining classes and objects
and it has to have pretty good debugging
support that's at all sort of adds up
and makes virtual machines today like
fairly big if you look at a v8 from
JavaScript that I helped build it's it's
not a small system anymore I probably
was the first three months but you get
more demand for new features in new
performance and you said it piles up so
things we can certainly think of
removing is the source code compiler
that will get us back to more common
systems where the compiler and the
runtime were more separated like like
back in the day and also what you have
with GCC and llvm and we can think about
whether or not the debugging support can
be made simpler smaller and have I get
like a really good protocols that allow
to like really fancy debugging and and
working with the system without these
things execution engine optic model and
garbage like they're they're really hard
to live without in a managed high level
language so what we try to do is to
build a system that has basically only
those parts on running on the
microcontroller so the way we've split
it up is that we have a compiler usually
running on a developer machine doesn't
really have to run anywhere particular
it can run anywhere you want to that
talks to a runtime potentially on
another system and the the interface
between these two things is kind of
interesting so the runtime needs to be
very simple so the interface also has to
be simple so what we've built is
actually a go runtime that has a sort of
a command driven API that allows the
system over here the compiler to ask it
to do certain things for it underneath
its a.m. it's a stack machine so you can
you can push new state onto the stack of
this runtimes thing and you can
manipulate a build new class structures
define new objects define new methods
through this this API and to let the
compiler keep track of which classes end
up where in the system and give them the
symbolic names we allow the compiler to
associate arbitrary IDs which sort of
any entity that's running on the run
time over there the runtime doesn't
really care about this mapping so i put
it up off the side here but the compiler
may need to know later on when it gets
say an object back that's an instance of
a certain class so the system needs to
be able to communicate that this
instance is of class seven thousand four
hundred and nine and then the
Pilar will know what that means so it's
basically like taking the symbolic
debugging information and putting that
off the side it's not unheard of in
other systems as well so it's not super
novel but we don't see people building
these systems anymore the way they they
used to so we've taken a step back you
could say and separate run time
debugging info and the compiler so the
kind of things we do and we do all this
over a wire protocol so we can run this
remotely and we don't really care too
much what it is right now it's mostly
based on tcp/ip but you can go way lower
and do something over you are it's and
whatnot and but the things you can do
with this kind of wire protocol is you
can set up the program structure you can
define new methods and new classes but
you can also change the program
structure and you can change the method
table of a class and say from this point
forward I really want this class to also
have a method called bar instead of just
having a method called foo that means
you can change the behavior of the code
running on your microcontroller while
you're developing on it which is
something known from other like more
like bigger systems this like live or
interactive way of working with the
system but it's something we rarely see
in this space you can also change
schemas this is a is the sort of
terminology used for describing the the
thing that happens when you change the
layout of a class by adding new fields
for instance and the difficult part here
is that if you have say a hundred
objects of a certain class in your
system and you then go ahead and add
another field or remove a field from
that class you need to do something to
all these objects as well the system
supports this it just runs through the
optics and manipulates them they
upgrades them in place to make them sort
of have the new kind of format
definition that the class implies we
also have a fairly simple protocol for
debugging the running program you can
start it up you can set break points
against restart the activation but it
all happens over this wire protocol and
there's a lot of things this debugger
cannot do it doesn't know about source
code it doesn't know about locations in
in your text files it doesn't know about
anything those things it all has to be
mapped out from the outside and I'm
going to give you a small demo of what
how this actually works out in practice
in a little while so what you need to
remember is just like the runtime is
super small it's focused on doing one
thing well and that is being again a
runtime for running programs but
does have a an API that allows you to
make it from the outside in this sort of
stack based machine and if that's driven
from the compiler there's a sort of a an
interesting side effect of this design
is that we've found instead of
historically that people working on
virtual machines they really hate adding
new functionalities to make developers
life easier for some reason we just want
to focus on performance performance
performance maybe maybe size as well but
those are the things we care about and
whereas people that work on the compiler
side they may care about good error
messages and like and those things so
having the split where a you don't have
to convince the team delivering the
small run time to add more functionality
to improve the command line debug
interface it's actually kind of nice
just there's resistance even in me when
I work on the run time to somehow just
keep making it hard for developers to
use the system because I want to keep it
small so the split makes it makes it
much cleaner and you can add more weight
to the compiler that is that is better
for developers so I don't know if that
applies to everyone working on VMS but
it certainly applies to me one other guy
wants to join too so one thing having
said all that about performance I do
actually want to spend a few minutes
about talking about performance of these
systems and how do you make them fast
one thing that a system like dart does
is that every method call is very
dynamic you have very little static
information to go by so you need to make
that fast it's very nice to work in a
system like this but the runtime has to
be fast too so this like a super short
interlude just to explain you a few
technical details about how we're doing
this system so here is a class hierarchy
we're classy extends be that extends a
and the Class D extends as a Class A so
but it's not related to B or C there is
a bar method in a that is over written
in C there's a foo mate method in B and
there's a separate bass method in D and
so usually if you wanted to implement
dispatching that is calling a method on
one of these objects or an object to
derive from all these classes you you go
and look at the class structure and then
you traverse the hierarchy and figure
out for instance if you're calling say
bar on FB instance then you say well bar
doesn't isn't design and be so let's
look in the superclass you go there and
you find them
and you're happy and often people end up
adding a level of caching on top of that
to make it faster but that's sort of the
sort of the gist of it we've found that
these caches on really small devices are
hard to control especially in the size
of them they have to be fairly big to to
be hit quite frequently and if you don't
make them big enough then you end up
having to reverse the hierarchy too
often that makes them slow you really
want something more predictable so
luckily there is a way of making it more
predictable so you can make a big table
here with all the classes out here ABC
and D and the method names down here foo
bar and bass and then you can say like
food the food method is not implemented
in a but it's implemented on B and the B
version of this is also inherited to to
see a class so if you want to call foo
on a B or C OD just look up with the
class and you find the right thing right
away the same for bar which is inherited
to all of them there's a separate
version for sea but other than that we
have a bar and all of them and bass is
only on d does that make sense we can
build a table like this the problem is
that gets really big really quickly like
if you have n classes &amp;amp; M method names
you get a table of size n times m
certainly doesn't fit on small
microcontrollers it actually doesn't fit
anywhere so we have to do something
about that research to the rescue like a
long time ago people really worried
about these things so we sort of we're
returning to that and we're looking at
what has what's been tried out in this
space before and one thing that's really
promising is what's called selective
based row displacement it sounds very
fancy and it sort of is kind of clever
there's a core notion is that there are
holes in here maybe some of the other
roads like this row could fit in some of
these holes maybe we can overlay them
somehow and adjust them and make them
also to fit in one one row instead of in
three rows in this case so how would
that look well one way of doing it would
be to say we take the bar things there's
a very long row you could say and put it
first then we add the foo methods here
and then we add bass down there and I'll
explain why there is a hole here in a
little while but it's important to
notice that there can be holes in a
representation like this so the way we
actually go about constructing this one
big table is that we want
we want to associate a an offset with
all these method names so that the the
offset + the class number you could say
gives you the right index into this
table so for bar I've chosen offset 0 so
ace index is 0 plus offices plus off at
0 and thus ends up here and you hit a
bar you at a Bar C bar and a bar that
sort of works like before you could say
so for foo it's a little bit more
complex we want this be foo implement it
on the on the first class with index one
to be hit and and hits entry for here so
we need the off the bees bee three so
that the bees 1 plus these three hits
this one and then works out well for the
CD case as well so we end up here with
the 5 3 plus 2 so if we were to just add
the the bass case right here we would
end up having a small issue and that is
that the best thing would actually end
up having offset 3 as well like six plus
these three here or six minus that's
their the three here gives us an offset
of three but it's really convenient that
they have unique offsets so we just push
it further out get a hole and give it
off set for instead the reason why we
need these options to be unique is that
when you look up here you take the
method name in this case let's say bass
you take the the class ID you have right
now when you call something it could be
one or two or three or even zero you add
them together and you look up in the
table you want to make sure you're not
hitting an entry from one of the other
rows so what we star in the in these
entries is not yet just a method to call
it's also something to verify we're
hitting the right thing and that's the
offset as well so we're storing offset
three in here and here and for all fit
for in here so if we do hit something
here based on a selector of bass we will
know that it's not applicable although I
swoops we might end up in trouble so
this means that if you do this do it
this way you get guaranteed constant
time dynamic dispatching you look up in
the table and you say it's this entry
correct for me if it is you call it if
it isn't then you say to the system
this offic doesn't implement this method
so it's very very simple at runtime we
can compute this table before we even
start the application and just ship it
as part of the application and so it
doesn't have any runtime cost to build
it and and it only takes up like 10 to
seventy percent more space than and v
tables known from other class based
systems it's kind of cool like the
reason why we cannot use V tables is
because we don't have static type
annotations everywhere it's a really
doesn't work out but we can get the
benefits of V tables and in this in this
different way that was the very short
interlude on how we speed things up
let's return to something that's a
little bit more tangible the programming
model so if we have this nice high level
language and we want people to develop
for small devices based on it and what
do we offer them like what do they
actually have to write so what we build
this is something that fits on top of a
small embedded real-time OS and so
that's the fletch runtime and on top of
that we have support for running
multiple independent programs and and
these programs really don't have to me
tonight they don't need to know about
each other they can be upgraded
independently and you can self install
them in the system and replace the mesh
as you go these programs can actually be
running in multiple instances at the
same time so their processes running on
top of this and it's very much like a
unix system you could say just built by
us in a much smaller space some programs
may actually not be running right now
others might be executing in with to
process and others might be running even
more I'll tell you why it's it actually
makes sense to consider having a setup
where you have in this case what seven
process running on top is because we
made the process and very lightweight so
a price on this in this space has a
small memory footprint right now it's
around 4k and that needs to go further
down to be really applicable to the
smallest devices and but it does mean
that you can get a completely separate
instance of a program running in around
4k we share all the byte codes and all
the things that make the system work all
the class structures everything is
shared so you only pay for the data / or
process it's not a new thing in an OS
setting this is how most operating
systems work and but it's it's kind of
new in a in a very small always space
where people don't
have the luxury of mm use where they can
share and have a read of right only well
read only segments that are than shared
that's harder to get by in those cases
one other thing that's kind of neat here
is that we can actually allow these
system process to be blocked and just
waiting for something to happen without
taking up system resources on these
small devices often you only have a
number of threats that are available to
you maybe maybe only one maybe a fixed
number and you really don't want that
like to hold up a native OS level threat
to block a process so we made it so that
if a process blocks we return that
native threat to the system we can do
something interesting and something else
in it that's basic if you do have more
cores which may not actually apply to my
controls at this point they actually do
run in parallel these things which is
kind of neat so here's a piece of code
that sort of shows you how you can use
process to to deal with incoming
connections as separate entities that
interact very very little so if you
create a server socket somewhere in a
sort of unique see way you can then you
can accept incoming connections by
spawning a new process and then you
actually just have the code in here in
ass instead of an inline closure that
actually runs in a separate process that
can then go ahead and sent back
something to the to the socket and close
it off when it's done with that in this
case it probably doesn't make a whole
lot of sense to run that's a separate
process but if there was some compute in
here or things we're having its sandbox
and off to the side not being able to
interact with the system not being able
to mess with the server for instance
it's kind of need to be able to do the
separation even in small smallest of
devices this this spawn except method is
actually a blocking thing it doesn't
actually return until it's accepted a
connection so that that also shows that
it's kind of nice you can just reason
about the code you just block here and
some until something happens like the
latest craze is to do everything async
and which is really nice on her in many
ways it's really a nice model it's just
really hard to program and in such large
scale scale things so the messages are
actually always blocking in there in
this version of start here and we do
have a way of communicating
between the process that you can set up
so you can spawn a process that has
access to a port that is actually a
representative ability to sense a
certain channel if you know go and go
routines like the way they use channel
to communicate between them it's very
similar to what we have here there are
differences but this very similar so
here you have one process sending
messages and one process consistently
sort of blocked on receiving the next
message and they're just printing them
in loop not the most interesting thing
to run on a small device but it just
shows you that you can communicate
between these things and and then build
up and sort of a set of communicating
process that that the fulfill or deliver
some may result for you so make this
code makes sense this is that code it
the only scary thing here is probably
the closure but that's I think that's
that's getting sort of it that's being
put in most languages these days so
hopefully you probably have to get used
to these kind of things in the future
anyway let's see maybe this was a little
bit too easy right in this case what you
saw here was said that the only things
sent between these these process was
were integers that's fairly easy to do
and we found that it's also too limiting
and being able to only send say
primitive values like strings integers
it's not really enough to build up
something interesting so like we could
have something like shared state
concurrency so you have multiple
processes like using the same state and
just operating on it and and the way to
do that is just allow any object to be
sent as a message to someone else
without copying it you just get a
reference to the object and that means
that any at any given time that there
can be multiple process that actually
have a reference to the same objects and
they can just operate on that same off
you can parallel sounds good and you
probably have to have lots of sort of
synchronization primitives in the
language to make this work like locks
and all the flags semaphores and latches
and whatnot it's a fairly common model
that's what we've seen sort of built in
Java in many ways and other systems too
I don't like it I think it's too
complicated and like so it's kind of
nice to be able to send any object
between these independent parts of your
app and but it's just I think it's too
much to say that then suddenly every
single office
also might be like access in parallel by
multiple independent threats I think
it's too much so what we put in instead
is actually shared immutable state
consider concurrency so you can do all
of what I just said as long as you
promise and actually show us that the
only things you send across are deeply
mutable objects you can build up
arbitrarily large graphs of these well
acyclic graphs of these deeply immutable
structures and pass them as message
between these things so and suddenly
it's safe for multiple process to
operate on the same thing they can only
read write their army immutable and you
still have no need for explicit
synchronization primitives that means
that it's it's possible for say a
hundred process to orchestrate something
by building up state sharing it and
working with it so there is one more
thing like we've seen so far that a
process can block and wait for something
to happen but what if you have a process
needs to wait for multiple so
independent things to happen how do you
deal with that in the async model you
just sort of register multiple
independent callbacks and say if this
thing happens I'm going to do this if
that's thing happens I'm going to do
that it would be nice to be able to
support something like that so I'm put
in here is is something not completely
unheard of another language of either
fibers so a lightweight threading model
on top of the system that allows you to
 off new fibers they then end up
doing blocking operations like in here
so they're the case here is that you
want to wait until some temperature
sensor sensor actually produces a new
value for you so you block on the input
in here say what's the current value if
it's different from the last one we send
some message to someone and we just keep
on going in a loop just like waiting for
the next event to happen but if you do
have two sensors like a humidity and
temperature sensor sensor you need to
somehow like be blocked on two different
things at the same time and this is
where our fiber model comes in and you
can just have a an arbitrary amount of
fibers in cute and waiting for something
this is very close to what you have with
an async programming model except that
it's very clear what's going to happen
when the received call up here on blocks
when that value is produce you can you
can read it right here if you work in a
debugger it's much easier to reason
about what the next thing is
going to happen often in an async bottle
you you lose touch with what sort of
include in your in your event queue and
also like like who are going to process
these things in how's that going to fit
together it's much harder to reason
about in practice at least so this is a
different model for it where we allow
multiple fibers within one process to to
run these fibers are cooperatively
scheduled we only change between them
and whenever one of them blocks we
change the next ready one and so there
is no parallelism in here there's no
support for that it's it is just a way
of like logically having independent
threats of control a sort of
participating in fulfilling some sort of
task so all that and then on embedded
device so how do we go about taking a
program model of feels like fairly high
level to most people and just making it
fit in in a small space well and today
we actually just announced a very early
version of a and sdk for doing these
things in the first version we support
device that are way too big like a
raspberry pi because they're very
available we've seen a lot of people at
having fun with that kind of hardware
I'd want to try out the workflows and
try out working with a with a high-level
language in context of that so that the
setup we use actually we have a
developer pc i get your mac or the next
box that is connected to a an embedded
device in this case a Raspberry Pi and
in the in the future this is going to be
available on on micro controls as well
if we wanted to get started well
basically today so I had something cool
to show you guys so the way you run code
here is basically you can say I want to
run either on my developments pc or I
want to run it on the embedded device
and then you get all the feedback back
from the system and you can debug and
work with it so just I wanted to make
sure this was actually in the slide so
if people saw this afterwards that they
would not be surprised it is very early
access is just to give you a feel for
what it is but it's usable and the way
it works is that you can run code
through a the fletch command and say I
want to run this start program and to
change between running it locally and
running it remotely on the on the pie
all you need to do is to add the small
sort of incantation at the end probably
going to make that little bit shorter
long-term but right now I felt like it
was good to be explicit so if you say
run it runs locally on my macbook pro if
you say run in session remote it means
run it on the Raspberry Pi and let's see
and I think probably have a little bit
of time here to actually go ahead and
show you guys how this works out so I
here I have the Flash command I can just
double check the lecture works and i
have the sdk downloaded and i can run
these commands i just told you about and
locally on this device sorry and it runs
on my mac with the darwin tag up there
but i can also run it on this raspberry
pi that i've got hidden down here
somewhere and it doesn't really matter
that much it's connected with it was an
Ethernet cable so it should just work
when I say run it remotely and so this
compiles the code and two byte codes it
moves it over it starts it up there it
starts a vm instance that it's not
communicating with it so in itself this
is not super impressive but the nice
thing is you can actually start doing
more you could say I actually don't want
to just run it I want to debug it
instead and and that will move you into
the debugger or you can say i want to
say put a breakpoint in maine and then
run to that and then you're in maine you
can say i want to see where i'm stuck in
this case i'm actually stuck getting the
info from the system before printing it
out of course that's fine just continue
and then it prints some things like you
so you connected to the device and you
can work with it and next step for us is
to make the the operating the code very
simple to do so that if you change your
files on disk and say i actually want to
apply those changes over the wire and
say let me change the string here and
start over and that's method that just
works it's not part of what we were
sending out today but it's something
we're building so you get to work with
the with the code more or less as if
it's running on your device and and the
promise is to be able to do exactly the
same thing for a microcontroller one
thing we have told you about but didn't
really show you is that being able to
run lots of process at the same time
it's kind of neat in and then we can
actually do that over today so i have a
small program here
processus galore and try that again and
it just shows that it can you can run
like a hundred thousand process start
them up get them to send some messages
and and and stop it all down again and I
have fairly quickly and this is going to
show you like we can create these a
hundred thousand processes and send
message between them and stuff them down
in 750 milliseconds we could try that on
the Raspberry Pi clearly if you run this
on a very small microcontroller the
numbers would be very different probably
would run out of memory but it still
it's kind of nice to see that even if
you do spawn a lot of independent things
like these have their own heat their
garbage like that independent they're
very very separate so it works let me
return today so hopefully this gives you
an idea of what you kind of what kind of
things you can do right it's it's an
attempt to build a high level accessible
language where the toolchain is also
higher level on what you're used to but
you still get some load of debugging
support from the system if we were to
actually go ahead and blink some lights
on that thing clearly you also need
access to like the GPIO and all that
stuff and so we built that into the
system as a set of packages that you can
just install and have fun with and we
believe we can make grow a small
ecosystem of support functionalities
that can do fun stuff for you and one
interesting thing here is again the
model is very simple you just have a
loop some point you say I want to sleep
here for 500 milliseconds it means that
and then you sort of flipped it flipped
a bit on the on the GPIO pin and it's
very simple model and this doesn't
necessarily mean that you're blocking a
native threat from the OS underneath
you're just saying right now this thing
running doesn't have anything else to do
so give back the threat and come back
later when I have something to do it's
just a very simple model if you look at
what people write today for small OSS
they right kind of this code right but
it doesn't really scale well up which
when you start to building big things
our system will hopefully this code is
also like relatively readable and easy
to get through so like the the short
version of this is something like this
like I think the world really needs more
productive embedded developers like the
growth in devices is is really
impressive
and but they're way too few people out
there that can really develop something
amazing in that space I think we have to
change that otherwise it's going to be
the same hundred people in the world
that needs to produce all the code it
doesn't really scale and it's certainly
a problem that too many developers they
lack the skills to try an embedded
device this is not because of developers
are like it's not because we have bad
developers it's really because of the
constraint that targeting embedded
devices leave to it I mean it's really
hard I'm not saying that having a high
level language and having a managed
systems and all that stuff is going to
solve all problems because you still
have constraints here that you're not
used to but it makes it a lot easier to
get started a lot of you to start
reasoning about the half problems not
setting up the tool chain and working
with gdb so again we need more
developers and right now the it's hard
to teach them to use the current
offerings for these low-end devices we
need to make that easier I think this
goes without saying that productivity is
higher with with better tools and a
managed language and it's really hard to
measure this thing it's something that
you usually sexy in when you see teams
working with better tools they just get
sort of enabled by that but it's
something that we haven't been able to
play a lot with in the embedded space
before and it's something we'd like to
to try to wear to change and maybe the
conclusion is really that that man is
languages that fit on on
microcontrollers will soon include dot
and that is a high level but fairly
simple language in many ways it's
designed originally for a web context
but it's designed by a couple of people
that really care about performance and
footprint and we've decided the system
so it it actually fits in a space like
this so it's not a stretch to put it in
a microcontroller and it's something
that we're actually developing and maybe
your question from all this is like why
do you got a hack on next I think all of
you and here should like over the next
few years find something to work on that
space I think it's going to be massive
like we're going to it's going to take
off and way right now we're seeing
people targeting mobile phones which is
great it's a huge market but if you want
to hit a really big market in like two
or three years this is where to go like
this is really what you need to be doing
so with I think we have a little bit of
time for questions which I really like
so where I hope you have some questions
for me and then then otherwise you can
drop by later we can I can show you more
about what what's running on these
devices and then how we are going to
move it forward but if you do have
questions let me know so the street
options to the application so start
there we'll use for smaller devices like
gardenia or esp8266 yes when and so
right now our target is really like the
32 bit cpu so there are arduino it cpus
out there or you know systems that that
sort of fit that bill and but we right
now we've not wanted to venture into the
eight or 16 bit bit space and we are
trying to focus on on i get a few and
sort of devices at a time raspberry pi
is like a bit of a cheat in the sense
that it's way too big so that's not a
real target for us the first thing is
probably gonna be at court x m7 the
thing that we believe we can roll out
fairly soon and next in line will
probably be something like the the big
arduino are going to do and and a few
others and so i think i think the answer
is yes we will get those thurs done and
i think sometime next year probably
early next year is a good good bet on
that can you say something about ID or
ID support and yeah what i showed you
here is like the really bare metal
version of this like running everything
from the command line and that is well
supported by a few a few IDEs today and
we're seeing most interest in the
IntelliJ sublime and Adam space and so
there is a way of plucking the dart
analyzer doing static analysis and code
completion in that space that you can
use a with fletch almost today it's not
trivial to set up which is why I what
didn't want to brag about it so we will
try to make a trivial to set up so that
if you're using a demo sublime and/or
IntelliJ you will be able to work with
that the Fletcher offering from within
that
lastly we showed interactions through
gpio what can also interact with pines
and libraries and execute kind of thin
strips and so luckily on something like
the the microprocessor based Raspberry
Pi there is almost nothing we cannot do
we can call out to the system and start
new process so we could we could run
Python there as well and talk to that I
think that would be fairly easy to get
going and when we hit the smaller
targets the most likely thing you will
be able to throw in there with the with
your dart code is probably like low
levels see libraries that you have from
from other settings are things that is
just like really hot hand-tuned coated
you just want to make use of and so I
think under my control is having
something like Python it's going to be a
stretch there is micro pison but it's a
little bit bigger than than what we're
targeting so in the everything here is
not really like what you've seen with
the GPIO it's not built into the system
it's built on top of the system so it's
all user level code so you can write the
same things yourself if you want it to
you have a question and when you select
the mic controller for a certain
application that you're going to make
usually what you care about is the idol
structure of the device and knowledge
was the turns the fruit springs or what
you're going to make and if you look at
let's say like Southwest company like at
home they have seven different
architectures maybe but they are
approximately 600 different models and
what differentiates all these models are
basically the fire of the device how
would you hope you handle that plethora
of different configurations within that
in the system that you're describing we
will let that be with the artist level
underneath or who you address that
somewhere it's a very good question did
everyone hear what the question was it's
fairly lengthy questions I'm not going
to repeat all of it but it is true that
once you get out there and target real
devices there is a lot of variety and a
lot of different device you can tack it
and like the question was really are we
going to sort of try to address that at
the at the real time I West level or
trying to sort of paper or the
difference at a higher level I don't
think we've decided that yet it's a very
good question because it's really hard
to come up with a sort of a abstractions
that that hide the details or the
implementations of these things and to a
certain extent I don't think we should
be doing that I think we need to have a
way of exposing the low level stuff as
well and but at the same time sometimes
you just want to be able to write code
that runs across these six hundred
different devices and make that work so
our solution to that is make sure that
everything we do is a user level code in
a sense so that people can can share
these things and they can develop a
certain kind of veneers that they can
add on top if they want to sort of non
enforced abstractions that you can use
if they make sense to you I think that's
the best bet we have right now it's
really hard to come up with any kind of
abstraction that covers that that much
variety any other questions
if there are no other questions I really
just want to like recommend all of you
to a get hold of some like
microcontrollers or are these micro
process and then play with them it's a
lot of fun we have so much so many
devices floating around the office the
Google office where I am and people are
having a lot of fun working on these
things and it's having them and working
with them really changes your perception
on them i think it's a it's a very good
interesting space to be in cool thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>