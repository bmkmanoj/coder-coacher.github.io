<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Writing highly Concurrent Polyglot Applications with Vert.x • Tim Fox | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Writing highly Concurrent Polyglot Applications with Vert.x • Tim Fox - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Writing highly Concurrent Polyglot Applications with Vert.x • Tim Fox</b></h2><h5 class="post__date">2015-03-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EMtoN9wFEOU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay
hello everybody yeah as Oliver just said
my name is Tim Fox just say a few brief
words about myself I'm pulled by red hat
being there for quite a while although I
kind of took a bit of time and went to
spring thaws for a while and back at red
hat again like Martin I've been involved
in messaging systems for quite a long
time
although the kind of messages I'm
evolved are less the kind of low latency
financial service messaging systems
which a lot arguably is a more niche
market and more the kind of mass-market
open-source messaging systems so I've
worked in I work exclusively in open
source software I don't do anything else
there's no proprietary stuff at all and
for the last four life ten years of my
career has been open source exclusively
other than vertex other projects I've
been involved with I work with the
rabbitmq team I'm the creator of the
Hornet queue messaging system which is
the one inside tables application server
that's about to be merged who's heard of
activemq it's another one not many
people okay surprising all right so
basically Hornick yous going to be
merged back to him Hugh and that's going
to become another so anyway I've been
involved with the three biggest
open-source messaging systems
rabbitmq Hornet Q net thank you and
various other projects anyway we're not
talking about messaging systems here
though today so unlike Marta's talk
before we REM this is a more of a
general-purpose stuff so I've kind of
moved away from the messaging system
stuff more to kind of like how do you
build application then what kind of API
design kind of stuff and how do you
scale applications so who's actually
heard of vertex okay and how many field
actually used it so far right okay
yeah how many would have heard of
reactive application development okay so
the kind of like buzz were the moment a
lot of people are claiming to be
reactive which means a lot of different
things but we would definitely fit into
that kind of mold who said of nodejs
okay so you in the right kind of area
although we're not no I gotta get into
that a minute yeah so vertex right now
kind of production release which is
vertex two but right now most of the
developments going on in vertex three
and we do loads and loads of new staff
for making that it's much more
embeddable we're getting away from this
kind of like making everything like a
container and making it much more
embeddable like a library allows new
features and really cool stuff and I'll
talk more about that in this talk so a
lot of this talks really about you know
a lot of the features are in only
available in vertex three or some of the
features of any available vertex three
other ones they're not necessarily
available in the current production
version so what is vertex um it's quite
hard to describe because it's a very
general purpose kind of thing say
advancing the JVM it's a framework frame
it's kind of a dirty word to some people
I think when people kind of say
frameworks daddy well they're kind of
thinking more of a container right so
when I say framework I'm not so really
talking about container some you know
some libraries can be frameworks - all
right so and certainly vertex three it's
a hundred percent embeddable you can use
it with with whatever you want we're not
saying you know you have to run it
inside a vertex container okay
yeah very general purpose we take a lot
of inspiration from so when I was at
Springs also work the rabbitmq team for
a world rub MQ is written in Erlang
Erlang it's probably the most one of the
most famous implementations of the actor
model and it's a functional language as
well so that's definitely a source of
inspiration another source of
inspiration was and I kind of that's an
inspiration doesn't mean I think it's
done everything right and actually one
of the reasons for vertes existing is
because we didn't want to do stuff in
exactly that way and we thought we could
do it better and that's no js'
in some ways you can think of vertex or
they kind of let polyglot bastard love
child of kind of lang OTP and nodejs on
the JVM okay we are polyglot right so
you can develop your vertex applications
in in multiple languages and JVM I'll
get to that in a bit as well
very high performance everybody says
high performance right so but for that
vertex is you know objectively we've
been measured
there's been a set of frameworks of it
who's had a tech and power our
frameworks sorry second power benchmarks
okay so there's a set of benchmarks done
by campaign nothing to do with us and
they did am Italy quite trivial
benchmarks and they pretty much measured
every single and it for everything on
the market just about in some very
simple HTTP style benchmarks and we're
right at the top not just JVM staff like
nodejs staff and Ruby staff and sieve
staff and whatever so very high
performance but I'm what I would say
about performance people can get a bit
obsessed about performance right and the
reality is everyone everyone says I want
the framework I use to be the fastest
one but actually most people do actually
need that most people aren't writing
height low latency financial systems
that have needs sub you know microsecond
response times most people writing
websites and stuff like that we don't
need it right so actually you can go a
bit up your own ass when it comes to
performance so I'm kind of stepping away
from that and all that's good enough
that's what you know that's good enough
for most people and we won the Jack's
Innovation Award this year for the most
innovative Java technology right so
that's kind of introduction of what
vertex is I mentioned polyglot so we
yeah we support Java JavaScript we
enjoyed verse at three we use Ian at the
Naza one JavaScript engine has anyone
actually played with that and it's
available in Java 8 right now okay now
and play with that okay a couple of
people so this is kind of really cool
it's very fast JavaScript engine much
faster than the old Rhino engine so we
use that we get really groovy Python is
using jython Jason's kind of been a bit
kind of stalled for a long time but it's
probably not the best
language to use but closure Scala
actually peak actually you use PHP with
vet sites as well and salon which the
new language from JBoss so we support a
lot of different languages at the core
of vertex our set of asynchronous API s
so biting you know what I mean by
asynchronous so kind of vent vent style
API so instead of saying do this now and
then blocking waiting for response you
say go and do this here's a handler call
me back in some way when when when the
response is ready so the cool API is in
vertex are pretty much all asynchronous
and we've got stuff and if you use no
Jes before it's kind of similar idea so
we have kind of a very small set of cool
API 3 very you know quite low-level
stuff you know like HTTP and TCP and we
have like 8 SSL support we actually have
WebSocket support in there as well with
asynchronous file system support and
we've had dnas UDP we have a thing
called the event bus which is a very
cool feature in vertex and probably the
most important feature and this is
actually a distributed messaging system
built into vertex and I'll get to I'll
show you some demonstrations of that a
bit later on we also have support for
distributed data we have distributed map
support so you can kind of on your
network you can have different nodes
putting stuff into Maps distributed maps
and getting the data out anyway we'll
get to that so why is synchronous way I
just said the core API is in vertex our
asynchrony have synchronous API so
you're probably familiar with most API
is in the JDK tend to be 8 synchronous
and most other languages arguably
dealing with asynchronous API is hard to
reason about
harder to debug harder to test and
there's a certain amount of truth in
that it's not actually there's a quite a
lot of myths actually in there as well
so why are we going down this route ok
and it's all about scaling with a lot of
concurrency not all applications
actually need a lot of concurrent
but a lot of modern applications do so
where do those where does that
concurrency comes come from it may be
that you have a lot of messages flying
around from do you know different
publishers different subscribers it
might just be maybe you have a lot of
connections maybe you have kind of but
maybe you're writing a web server and
you have a keepalive even with them you
know most web servers either keep a
lifetime of like 5 10 seconds so any one
time you know without a traffic you can
have a lot of connections you need to
support WebSocket server lots of
connections again you know
long live connections internet things
MQTT again long live connections so a
lot of modern applications characterize
having to support a lot of connections
and you know connections can introduce a
little concurrency and if you're using a
kind of a blocking i/o the connection
level then you're not going to scale
because you know if you have a million
connections in a million threads and
even though threads are a lot cheaper
than they used to be on what an opera
systems are still a lot of overhead
there okay so it's all about scalability
and dealing with a lot of concurrency so
how do you actually write a vertex
application well you can't just embed it
you just embed you use those core api's
directly in your application if you like
and use you what your own threading
model and do what you want but we also
provide this thing called a vertical
which basically gives you a concurrency
model okay and we kind of recommend you
users concurrent we don't say you have
to use it but you really recommend users
concurrency model with the very actor
like and currency model so the code you
write in vertex is written in the form
of these things called verticals and
verticals just lumps of code they're
kind of the the basic execution unit of
vertex and they can be written in any
language you like so Java JavaScript
Ruby whatever yeah so and you can mix
and match them in an application you can
have different verticals written
different languages an important thing
about a vertical and it particular
vertical instance is always single
threaded well there is actually an edge
case I won't go in advanced case I won't
into that right now but you can see him
for now they're all single threaded and
what this gives you is a developer you
have to worry about you know
synchronized and volatile and locking
lots of look you know lots of race
conditions that just don't occur it's a
much nicer way to write replication so
but we're moving away from this kind of
like multi-threaded concurrency model to
more of an actor model yeah so these
effect you cannot kind of fit they're
not we're not strictly an accent model
but you can kind of think of the
verticals as a bit like actors and they
communicate with each other by sending
messages over the event bus and you
scale by having more instances but a
particular instance of the vertical it's
always single threaded yeah so it's kind
of like the actor model who's heard of
the actor model by the way okay it's
kind of popular you've got like Roland
Kuhn was here just now and he's
obviously at the Acker lead there
obviously another actor model
implementation so I'll show you a
vertical in just a minute you can run
these verticals at the command line or
you can like package them up into your
maybe you have a Grail or maven build
system you know you can just you can use
all these tools directly with vertex
we're not trying to reinvent the wheel
okay so let me show you a very simple
vertical so what's the font size like
that it's pretty bit big actually well
you can see it so that's all right so
let's have a look at a hello world
vertical so I have a directory here and
I have two files in it a Java file and a
JavaScript file let's have a look at the
Java one now I've got a feeling this
font size might be a bit too big wrong
on my shift key doesn't work some reason
there we go yeah let me just adjust that
font size edit it just depends from now
projected to projector really so let's
go down a bit to 20
okay still overlapping a bit anyway this
is a kind of the simp one of the
simplest possible verticals you can
write this time in Java this particular
this particular vertical we use Java 8
in vertex very exclusively and all
you're doing here you're basically ever
think verticals got to start method and
then inside that we're going to create
an HTTP server and I'll just scroll
across a bit it can't quite see it all
in there but but basically just creating
an HP server and we're setting a
response handler on the server and we're
using lambdas for that scroll across and
lo just change the EF font-size again so
you can actually see it hopefully it's
right
yeah so we studying with creating a tree
server setting or a handle on the server
and that hand is going to be called when
a request arrives it's just a lambda
Java rate lambda and then I'm just going
to put out some static HTML so it's a
very trivial example right so let's run
that tab actually run that and have you
seen this if you've used no Jess before
you've seen a similar kind of thing
right so to run it you can run it on the
command line if you like and you can do
that so I think vertex run oh hang on a
second
it's a Java source file so we have to
compile it first right you can't run
Java source files directly actually no
you cannot you can run Java source files
directly with vertex so we just run it
directly and let's go to our browser f5
okay hello well from Java is writing
okay it's got a nice feature of Java you
can run you have to go through this
whole kind of like build compile know
cycle for prototyping so if you're kind
of knocking stuff together really you
know creating a demo or doing a bit
quick prototyping you just run Java
stuff directly we obviously support
running class files too so in a in a
bigger application you would typically
compile as well have it as part of a
bill but it's good for prototyping stuff
like that it's kind of nice feature so
it's all about kind of one of the main
things about getting away from this kind
of complexity of like you know we want
you to have real power to do stuff
directly run stuff where you want
directly without having to go through
with some complex packaging okay let's
take a look the JavaScript one actually
learn to type and it's the same thing
written in JavaScript a bit less verbose
again you've used no Jess before it kind
of its kind of similar right
so you're creating it further and you're
setting a request Handler we can run
that too so so when we run verticals
directly on the command line that's
called raw verticals we call them rule
verticals okay five there you go right
so it's kind of a hello world thing I
mentioned before if this thing called
the event bus in vertex and the event
bus so a little vertical like that by
itself is not much use
and real applications going to be
composed of many many different
verticals doing different things usually
doing one thing and doing one thing well
it's kind of the microservices model
really ok so you can kind of think
verticals typically implement your micro
services for your application yeah and
they're then talked to each other either
on an event path or maybe via HTTP
depending what style of Micra services
you like maybe prefer kind of HTTP map
services that's fine but um we all sort
of write something called an event bus
so the event bus is the nervous system a
vertex there's really a basically a
transient publish/subscribe messaging
system it's built into vertex and you
can send message a consent pretty much
very very simple the messages we
actually send is no complicated kind of
message format you can send it to the
primitive type or a string or you know
more complex objects if you want one
thing we kind of recommend for most
interactions is to send Jason and the
reason for that is Jason's really well
understood by all the different
languages it's really easy to create
Jason it's really easy to understand it
to parse it understand it you know if we
were sending some sort of serialize Java
object to a ruby vertical this is going
to go what the fuck what do I do with
this all right
be very hard for it to understand so
that's why we kind of say Jason although
it's um it's not a strict rule you can
use whatever you want maybe in an
application you don't have any really
verticals maybe it's all Java in which
case you can send whatever you want so
the event bars inside a particular JVM
instance you have many different
vertexes running I use event you use the
event bus to communicate but actually
because I mentioned before it's actually
distributing messaging system so
actually joins together multiple vertex
instances running on the same network
and they'll discover each other and form
this kind of like big distributed
peer-to-peer events the event bus
there's no there's no master server it's
not like kind of your typical JMS server
or something where you've got kind of
like a master server you start up and
everybody connects through it and send
stuff so where are we going here we're
basically going towards a more
micro-services model for application
development we're moving away from it's
kind of like a placate you know
application
service style says no kind of like
monolithic application server where you
deploy verticals into you just run them
wherever you want yeah and actually you
can run them without even having vertex
installed and I'll get to that in a
minute
and you have these different parts of
the application communicating over the
eventbus to form your application so if
you had a large application you can
compact decompose that into different
languages maybe have different teams you
wanted a different parts of the
application maybe you like a web team he
wants to use Java Script and because
their skill set maybe have like a
back-end team wants to use Java or skål
or something they can do that yeah and
they can be loosely coupled living on
different parts of your network talking
to each other so no application server
and we take the event massive step
further still not only can you use the
event bus to come to join together these
services on your your own on your own
network we can extend that into the
browser too so you can have use the same
API or very similar API inside your
browser in client-side JavaScript to
interact on the event bus as it would do
on the server side so now you have it's
kind of like big you know address space
which well especially a completely flat
address space which encompasses you know
your stuff in your server stuff in your
client and it can all talk to each other
than exactly the same way so this makes
it really easy to do this whole kind of
like you've the whole generation of
so-called real-time web applications so
kind of pushing stuff to browsers you
know and we find a lot of people using
vertex in the gaming industry for
example a lot kind of like mobile games
that kind of stuff is fit proven very
popular for that kind of thing we don't
force you to use the event bus I know
right now for instance HTTP rest rest
micro service is a very popular of stuff
like drop wizard and and you can also
use vertex in that way so especially in
vertex through bringing a lot of really
cool rest support in we can already do
rest web services in vertex bit vertex
free it's going to be a lot easier so
they're going to so it's the kind of
interesting thing about Vytas we're very
unappealing ated we don't say this is
how are you write web application
it's a toolkit you can use it in a
thousand different ways yeah and it
supports it's kind of like no Jess in
that respect no Jess itself doesn't say
this how you're out web application
that's kind of done by the modules that
the NPM witch that sit on top of no Jess
all right and it's similar vertex the
core of vertex is pretty is very uh
opinionated so let me show you the event
bus okay so let me shut down that one so
we're in let's move to a different
directory called event bus I have a very
simple example here I have let's take a
look at receiver J s again another rule
vertical so let me use less there might
be a bit easier to view okay so this
vertical is very trivial it's basically
doing the SUBSCRIBE part of
publish/subscribe messaging okay
it's are registering a handler on the
event bass against the an address called
newsfeed just a string it could be
anything whenever it receives data on
that address is just going to log it out
to the console so whenever it receives a
message it's going to log it out okay
so let's run that vertex run received
yes now this time we're going to add a
switch called cluster and this tells
vertex when it step starts up because
obsolete when I run in the command line
they're all running in their own with
JVM yeah it tells vertex the clusters
which tells vertex look when you start
up look out for any other vertexes and
light appear on the network and if they
do then form a cluster with them okay so
it takes a few seconds to you know still
agates TIF starting it's running now so
let's go to another console where are we
Peter eight and we have a vertical
sender dot Java this time written Java
obviously and this is this is going to
do the published part of published
SUBSCRIBE messaging what it's going to
do we're setting a timer it's going to
fire every thousand milliseconds every
second and when it does it's just going
to send that message to that same
address okay
let's run that - cluster alright so it
and going back to the other console you
can see the other ones picked it up and
that would work wherever it is on the
network okay so let's make a bit more
interesting let's go to another console
and OH
PWD okay let's push that into the
browser - so in order to push into the
browser we need to serve a page the
browser so we need a web server so we've
got a web server written also in vertex
call British server je s and actually
only the top part of it is the web
server it's very simple to write web
server in vertex I can if it's not
obvious to you what's going on there
I'll just step through it very quickly
we're creating an HTTP server and then
we're setting this request handler on it
again when we get a request in we're
just going to look at the path of that
request if it's for the route we're
going to serve index.html otherwise
we're just going to serve whatever has
been asked for don't run that in
production there's an obvious obvious
security problem there okay I think some
of you will have not the Spotted lot
already but it's just kind of demo for
demo purposes right now the bit at the
bottom says create a sock yes but this
is kind of the magic I'm not going to go
into that and the moment I'm gone off
time it's a lot of features to get
through in this presentation this kind
of does the bridging between the event
bus the client-side event bus in the
server-side event bus so let's run that
so we go vertex run o before we run
actually let me show you the index.html
page we're going to serve very trivial
example it's just a basically a blank
page that's got a bit of JavaScript in
it the JavaScript opens a connection to
the event bus and then when it's open we
are registering a hand or on the event
bus and we're just kind of you know
doing the same as we did in the server
basically
and then we've got a little bit of
jQuery we're just going to output what
we get to the actual page if as you can
see I'm a server-side developer another
clients my developer so it's very
unpretty okay so let's run that bridge
oh I forgot the cluster switch though I
run it again with the cluster switch
because all these three parts they can
be running anywhere in a network they
don't be in the same same place okay
right let's go back to our browser 5 as
you can see the browser picked up that
same sender so it's all working on the
same event bus right so it's kind of a
nice feature of vertex ok so yeah I
mentioned how to time you've seen
already how to run verticals what I call
Rover tools it can be running the
command line but for many applications
you don't want to do it that way you
maybe you kind of more use to the Java
you know maven build process or you have
a Gradle build and you want to package
stuff up the jars do the kind of like
standard maven kind of thing and push
stuff to maven repository you can do all
that vertex - you don't have to do
everything like I just said it works
very well with a standard maven build
and standard Gradle build ok and vs. is
completely embeddable as well you can
embed it in your own applications say
you've got an existing application you
can just embed it and use the parts you
want ok so we're not kind of preaching
we don't want to I'm not saying this
look this is like the container you have
to run everything inside ok ok oh yeah
let me just show you an example of a
maven project that's using vertex vertex
3 just so you can see how simple it is
Oh member refresh has gone a bit weird
there let me just okay IntelliJ why you
doing that some reason the Refresh is
going to wait on that
what is it doing let me just open that
project again that's very weird tell you
what limit let me restart IntelliJ yes
so you can basically have what I'm going
to show you two minutes let's just at
whose use maven here before who uses
regularly uses maven a part of your
standard build process yeah but pretty
most people alright so what I show you
here is the standard maven project
nothing very vanilla project and show
you how easy it is use vertex in that
way as well that's a complete different
projects it's just opens we just sit
this one yeah yeah so I've got a it's
actually the same you know that same
vertical lighter shade in the command
line but this time it's in you know part
of our maven build in a saying hello
world and the prompt XML is you know
very very vanilla basically that's
including the vertex dependency just
setting the compiler to 1.8 and a little
bit at the end here I'm going to show
you in a minute what I'm going to do
we're going to we're going to build it
into a fact jar who's used to the idea
of having a fact executable jar kind of
fashionable at the moment so the idea
here is you're going to compile
everything into one jar and just deploy
it you know with all the dependencies
including the vertex dependency inside
the jar so you can copy that jar to any
server with a JDK in it and just run it
yeah so you can have your micro service
all packaged up into one little unit and
then just copy it wherever you want and
we use the maven Shea jar for doing that
that's kind of a common common thing
right so let me show you that let's shut
down these service here
yeah so I'm in the right directory so
let me just run it so it's the same
right maven install create the pack
showed up actually install it into the
local repository now if we actually look
in the target directory you'll see we've
got a example project fat jobs this is
the fattest executable jar and we just
run it with Java
- jar
so I'm in the wrong direction
okay go back to our browser five so it's
working same example from before but
that's all packaged up so what I'm
demonstrating there is he we're not
trying to reinvent the wheel when you've
already got your own build process at
your company and you can put vertex
components can be pushed into any maven
repository and resolved like that invert
its through the also the very cool thing
you catch you resolve maven dependencies
at runtime if you want as well but
haven't got time to go into that alright
so how about how am i doing for time
actually halfway through vertex also has
some high availability built in a chaise
support so you can run your services so
you've got um you want you want
redundant services on the server side so
you can run your micro services on the
server side and if one of them fails
another vertex node can take over
responsibility for that for that so I
failed service and that's built into
vertex we support quote V's we we
basically detect network partitions
using a quorum approach I'm sure most of
you are familiar with that who's heard
his head of the quorum approach for okay
so you basically just start up a number
of nodes you say I want I don't want
them the network to continue functioning
unless there's a certain number of nodes
still alive and if they can't see that
number of nodes and it automatically
shut down okay I don't think I've got I
have actually have an H a demo I could
show you but I don't think I'm gonna
have time if I do that I probably have
time to show you the rest of the
presentation so I'm going to miss that
today but but like most things in vertex
the H shades are really simple to use
we're not you know editing complex XML
files literally the way you enable a
chain vertex use just put H a switch on
the command line that's it all right so
when you that vertex around below minus
H a I mean there are some more advanced
settings you can provide but again we're
not doing that via XML config
all right so one um interesting feature
in in vertex three is basically solving
a problem we had in vertex two about
keeping all our API up-to-date
so in vertex two we you know we support
all these like I mentioned before we
support all these different languages
and we have like a core Java API and
then we have kind like a version of the
API for each of these languages as you
can imagine keeping that all up-to-date
is quite a painter every time we add
something or change something the Java
we need to update the equivalent to add
the equivalent in the Java Script the
Ruby and the groovy in the closure and
the Python blah blah blah and add all
the tests and everything right so it's
very proved to be quite hard to manage
and it's been very time consuming it's
may meant that it's really slowed us
down in innovating those api's and also
we have a very small team all that we
have we have a good community as well
even so there's a lot of work to do that
so we thought if it's three we need to
solve that problem and the way we're
doing events vertex free instead of
manually maintaining those other
language api's we're generating them now
from the java api so all we have to
maintain now is the java api and
everything else gets generated including
the documentation yeah and it's pretty
quite difficult job people when we went
into a lot people say that what you're
not that's not going to work how are you
going to create idiomatic
other language api so that the key isn't
being idiomatic anyone can do coaching
right but making that actually look like
an api that somebody would actually want
to use in Ruby or JavaScript is much
more difficult and the way we attacked
that was by putting constraints on the
Java API just generating you know
generating idiomatic Java scripts
fraught for example from any Java API
would be too hard of tasks to do so we
said our Java API has there's a subset
of things you can do in in those api's
so you made the problem more tractable
by doing that so if I set of constraints
and our Java API is which makes it a lot
easier to do and we have kind of liked
it so when we as part of our build we
kind of check that you have a look at we
have effectively an annotation process
so it checks all the Java API s and it
basically won't compile it if you're
doing something you're not allowed to do
in the core anyway so you've yet to
actually generate we generate it using
ml templates it's kind of implementation
detail but it works pretty well and so
far we've done vertex three is kind of
like we're not there yet but we've
already done Java Script groovy salon
and we'll start with basicly starting
scarlet one at the moment as well
another thing we learnt in vertex two is
all about who's had a callback hell okay
the Pyramid of doom all right who's
actually who kind of works day-to-day
with asynchronous API s okay and how do
you compose those api's sorry okay so it
depends which language you're using
different approaches people use and
there are various different proaches in
the scarlet world and you have
definitely known so so you get one big
criticism of using rule callback based
API this is quite hard too but for
simple things it's simple but as soon as
you say have multiple different streams
of data and you want to compose them in
more complicated ways and it starts to
become a difficult problem solving it
comes very error-prone
how do you deal with errors and all that
kind of stuff as well there are
different ways of mitigating that some
people their various promises libraries
that relate to compose promises in
different ways there's another library
called rx Java who's head of rx Java
okay so iris Java is based on original
rx technology from Microsoft and it's
kind of a sort of a port that to the
Java world
okay and what the idea is it's kind of
like promises this promises to similarly
have one value one you know they are
either the result happens and they're
finished right but with our X it's
streams of values okay that's kind of
the fund them at the main limitation of
the promise based approach it's it's
okay with single value event single
single shot events but it's not much
good for streams so with vertex three we
have a set of libraries you can sale a
an API that allows you to
automatically convert the callback based
API into an R exif ID API so anything in
vertex 3 if you wish you can use rx with
it so you can say compose everything so
our X provides also provides a set of
kinda like functional like operations
that you can apply to the data like map
and flatmap and all those kind of things
that you probably familiar with if
you've done any functional stuff so it's
a very nice way of mitigating against
that call but he'll again vertices and
opinionated this is just one thing you
could use not everybody uses this will
use this other people use different
techniques is up to you we're not
preaching about it but we do provide it
and we think it's gonna be very useful
for more complex applications another
feature new feature in vertex 3 is
distributed what I call distributed data
support so what would provide inverted 3
is ability who's used like distributed
Maps before ok hoops hurt your things
like oracle coherence in Finney's
infinity span blah blah various
different projects out there did that
kind of thing so the idea is you can
kind of put stuff you have a different
part different nodes in that we can put
stuff into like distributed map and then
you can get it out again in different
nodes so we have this support vertex
free ok it's kind of useful for you know
maybe have some sort of session state in
your application you want to survive
survive failure so you have you'll set
your service for example could put some
state into a distribute mat when it
fails the other one comes up over the H
a and get that stayed out again we also
provide as well as mat we have this an
asynchronous lock so it's quite common
in distributed systems to want to do
something but only do it in one place or
only do it once and that's kind of
fairly hard problem to solve in
distributed system how do you actually
guarantee that only one things doing
that so to solve that we provide a very
simple API so you can basically get out
an asynchronous lock so by asynchronous
means it doesn't block you're not sort
of saying
block until get your name you're not
blocking a thread until you get a lot
and you're not holding that thread until
you finish the lock
you're just saying get me a lock and
then you go for this thing else sometime
later it comes back with a lock for you
when it's ready when it's available you
then do your stuff
and while you're doing your stuff nobody
else can get that lock and then when you
finish you just release it okay so a
synchro's lock non 100 cent non-blocking
like like everything in that takes and
we have another thing that's also very
useful and many many distributed
applications the counter to through
difficult of functionality again it's
kind of tricky fiddly problem to solve
usually if you're doing it from first
principles how do you you know have a
counter that you can atomically
increment across a cluster we provide
that stuff again asynchronous as well
I'm non blocking or non blocking another
thing in vertex 3 we have management
supports it's all we have we use the
coda Hale metrics is now part of drop
wizard metrics basically it's what kind
of renamed but um so we use that
internally again it's an optional add-on
to vertex you don't have to use it don't
want to but if you do then but then the
then basically the vertex core objects
produce various different event slightly
HTTP server will produce events how many
requests per second all this kind of
stuff and you can expose that vibe JMX
I'm also going to lie to expose it via
the event bus so you can have some a
listener on the event bus anyone the
network so the tuning insert events
management events and getting data
so where are we actually where we going
with this so I with vertex fear it's all
about we're trying to build is like
official stack with punch back trying to
build a end-to-end asynchronous stack of
staff that you can use you kind of want
most it's very commonly wanted a lot of
different applications so like I said
well the vertex core it's serve with a
bit low level and you know you can't
just use the core in most applications
you probably want database access email
you want very integration with a
messaging system you know distribute
data I've already mentioned
maybe you're doing IOT staff you want
mqtt co-op whatever you want author
another classic thing you want is off
right
pretty much every app needs off so as
well as the core vertex we have
basically producing the set of component
to sit on top of vertex that you know
kind of LEGO bricks that allow you to
plug these things together and make real
hundred-percent asynchronous
applications we also have a very active
community in vertex so a lot of stuff is
kind of we have a lot of components work
by the community - exactly in vertex
turn we hope the same continues of
vertex 3 but the idea of the official
stack is were kind of given the stamp of
QA approval make because certainly the
node s world you have a thousands of
components in NPM but how many of those
do you really trust to use in production
it's a big problem there in the know
chess world actually if you know being
getting making sure the quality's up to
scratch yeah and also yes stuff about
where the loads more staff to do have
rest microservices inverse X 3 so we're
basically you know going very strongly
in that direction as well but again non
opinionated save your knees the eventbus
that's fine too okay
so what's all about so it's all about
we're moving away from this kind of
application server model of development
to more to a micro-services style model
microservices is kind of like means so
many different things different people
to a lot of people it means HTTP micro
services but that's not the only kind of
micro service you can have event bus
style micro services so instead of
interacting HTTP they interact in the
event bus
we don't preach about that you can do
all those different styles if you want
you can have an a mqtt micro service if
you wanted or any other or maybe just a
TCP one okay the ID but the
architectural style is you do each you
split your application into bits
components that do one thing in one
thing only
those are the Micra servers I don't care
if they interact on HTTP or eventbus
MPPT whatever that's up to you yeah and
your own preferences but we're moving
away from this application server more
that's that's the key thing to take home
yeah polyglot we're not preaching about
the language not saying oh I like one
language is better than any other
language
it depends everyone has different
opinion so he's trying to support a lot
of different languages so you can use
depending on your personal preferences
depending on the job at hand you know
what are you actually building what's
the appropriate tool and also depending
on the skill set of your team's you know
you're not having to tell everybody
retrain everybody to JavaScript's or
scholar or whatever and I mention before
yeah so we want to produce this library
of LEGO bricks or this official stack so
you can put everything together and
vertex right now we're getting a lot I'm
my employer Red Hat it's been a lot of
estimate into vertex it's kind of
strategic project for Red Hat so we kind
of see this the future in some ways the
future of the app server what I would
say it's not a Red Hat projects versus
is actually an eclipse project in terms
of IP they clips control the trademark
all that stuff and that's because of the
history of versus I started it when I
was at VMware and there's a lot there's
kind of like a legal battle and stuff
and ended up in anyway so but the key
point there I was trying to make was
it's not owned by Red Hat's not
completely commits not read out doesn't
say you hate do it this way okay read up
don't control the direction of project
yeah although they do invest in it and
yeah so you know we're 100 so
everything's open source everything's in
the open we're not developing anything
behind closed doors everything's in the
open so we interested in getting
involved please get involved we're on
github
I haven't actually looked at the SIS
it's for a lot for a while that we were
it's at one point we were one of the
most popular Java projects on github
open the whole of github but you know if
you what we're doing we're doing a lot
of cool stuff and actually with vertex 3
we're puli doing you know I'm actually
more excited now than at any time during
the velopment of vertex with the cool
stuff we're doing we think it's gonna be
really big and take vertex to the next
level so if you want to get involved
with that there's loads of stuff to do
and just you know come to our Google
group or send me an email or or whatever
or IRC we have a channel on freenode net
and but you know basically the whole
team hangs out there and that's
basically what I said isn't it yeah so
free noted that vertex Ric channel so if
you're interested in getting Veliz do
and that's it thanks thank you
yeah good question so the question is so
in the actor model you have you
basically have this like the concept of
supervision you delegate the restarting
and staff to to something other than the
actual actor so in vertex 3 we are
interesting a similar idea we don't have
it right now and vertex 2 but we are
we're going to introduce a similar idea
to a supervision tree in vertex 3 we
don't have that right now so the
question is how do you is it possible to
have interrupts between vertex and go I
have no idea sorry but what you pretty
what you could do I mean obviously goes
not JVM but what you could do is what
you can do a vertex with any non JVM
stuff you can pretty much bridge into it
just by opening a web so if you have a
WebSocket support imagine go probably
has a WebSocket client support most
things do so you could create a
WebSocket into vertex and then basically
interact on the event bus from that and
that would be possible I imagine
assuming go has clients like WebSockets
port I'd say a few more words on that in
vertex 3 we're going to try and this
idea of interoperability with non JVM
staff is quite important so I'm gonna
have interrupts a of nodejs and and you
know MRI Ruby environments and other non
JVM stuff so we're thinking of exposing
some sort of wire protocol of a kind of
simple socket based protocol you can
actually connect up into 30x words so
that's come something we're thinking
about at the moment I'm not quite sure
how it's going to go
so the question is how do you handle
synchronous staff like JDBC so JDBC is
inherently synchronous and obviously we
can't change the JDBC API so how do we
do that it's actually a general problem
a lot of api's traditional api's and
java world of synchronous so we have a
concept for worker to deal with that so
if you're on a standard vertical you're
on the event loop
you must not block that event loop
because if you do that then your system
becomes on responses because you can't
do anything else well it's blocked so if
you want to call a blocking API what we
do is we have a thing called a worker
vertical you see put that blocking code
in the work of article and then you run
it as a work of art what that means is
it runs instead of running on the event
loop it runs on a thread from a thread
pool yeah so you can block for that and
then it communicates back to the other
vertical again via both fight by
messaging but 8-bit story async JDBC
verb I would love to have a sync JDBC
and I've been asking for it for ages but
I'm not I'm not holding my breath
yep question is on what parts you know
all these different features do we know
well what do we use stuff internally to
actually implement that yeah so we use
some for a lot of the i/o the such as
the socket IO Usenet II the filesystem
stuff we use do directly with the jdk
api the event bus we well the discovery
part of the event bus so the kind of the
you know how to know see each other that
we delegate to something called the
cluster manager which like an SPI yeah
I'm have a default implementation of
that SPI which uses hazel casts by
default but you can use you could
basically create your own implementation
that uses something different and we
already have people they've we've got a
zookeeper implementation as well I think
somebody's it's like two or three
different limitations but the default
one within the distribution is hazel
caste what else yes and distributed maps
again that delegate to the cluster
manager so in the default case that uses
hazel class but you could say plug-in in
Finnish town or something for that if
you wanted or actually there's going to
be another implementation about you that
uses J groups there's give you another
information so you ought to choose
basically which one you want yeah
yes we're not we're not we're not
reimplemented every single thing from
scratch because i've been that be a lot
of work yeah
when will version three be available a
good question there's a lot to do I'm
hoping it's not a promise I'm hoping
like the beginning of next year at some
point maybe the first quarter of next
year realistically we have a lot to do I
mean the main thing is really just
building out those components that you
know database support and all that kind
of stuff a lot of stuff for it exists we
have to kind of port it to vertex three
and do all the documentation all that
stuff kind of takes time
ah yeah good question the reactive
streams API so the rata streams API
there's a cross company effort that's
been led by typesafe it also includes
Red Hat various other groups pivotal and
various other companies the idea is to
provide an ape basically a way to
interoperate between different reactive
systems and provide be able to you know
push back a back pressure between the
systems which is very important when
you're dealing with async resistors
now we've already signed up to that to
that step you know we're one of the
people involved that we already have a
reactive streams implementation vertex
right you can already use that yeah
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>