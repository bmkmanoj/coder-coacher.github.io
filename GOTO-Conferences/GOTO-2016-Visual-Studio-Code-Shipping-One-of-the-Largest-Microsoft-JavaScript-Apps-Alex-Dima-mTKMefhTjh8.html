<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Visual Studio Code: Shipping One of the Largest Microsoft JavaScript Apps • Alex Dima | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Visual Studio Code: Shipping One of the Largest Microsoft JavaScript Apps • Alex Dima - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Visual Studio Code: Shipping One of the Largest Microsoft JavaScript Apps • Alex Dima</b></h2><h5 class="post__date">2016-12-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mTKMefhTjh8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody thank you for joining me
today my name is Alex Dima I'm a senior
software engineer on the Visual Studio
code team at Microsoft we are working
out of Surak and today I would like to
tell you a little bit about some of the
lessons we've learned while developing
and shipping Visual Studio code and I
will try to give some insight into what
we've been doing into what we've learned
and hopefully this would also help you
in what you're doing as well yeah first
a reminder to rate the talk so this is
basically just your code I'm sorry if
you can already see it that well this is
what we ship every month and I hope you
know actually quite a lot about it from
Eric's talk earlier in reality we
actually ship to different things so we
ship business with your code which is
more or less a web app so it's an it's
an app built using Java Script built
using node.js API and built on top of a
browser API and they all come in the
shape of electron-electron basically
consisting of a merger between chromium
and node.js but at the same time we ship
a library which we call the Monaco
editor which more or less contains the
thing in red over there we take that
thing out of our product and we ship it
separately as a JavaScript library that
can run in any modern web browser so if
you have an app where you're showing
code you can actually even today go on
NPM and fetch the Monaco editor node
module I'm still working on the
documentation so it's still a work in
progress but yeah so that's what we do
today but we didn't start doing that and
we actually started since quite a number
of years actually sends the autumn of
2000
and back at the time as Eric mentioned
we were given the mission to redefine
and create developer experience or
development tools that work in the
browser so at the time we actually
started in JavaScript our patterns were
consisting more or less of trying to
create classes where in JavaScript you
would use prototypical inheritance and
so on so we would literally say function
my class my class dot prototype dot foo
equals something so we would all right
idiomatic JavaScript to try to create
some sort of classes and patterns and
types in our source code one thing we
got right from the beginning is that we
jumped straight on promises as a way to
abstract away a synchronicity right so
whenever we build something in the UI
whenever we had to compute something so
for example you move your mouse over a
piece of text and we have to show you a
hover so whenever we do that we build
the UI code in such a way that in the
end the UI code makes a call and that
call returns a promise with the actual
thing to show so this was actually a big
win for us because whenever we changed
architectures whenever we moved away
from running only in the browser to
running in this electron environment we
could just substitute the implementation
of the hover providers and instead of
executing them in a web worker all of a
sudden we could just spawn a process and
do it in a separate process and we had
literally zero changes to our UI code so
I was actually from the beginning I'm a
I'm a hardcore JavaScript programmer so
I actually love JavaScript and any
project I start I immediately start in
JavaScript but at the same time we were
starting at Microsoft but what became to
be the typescript compiler this little
team they also started something they
call it at the time they called it
Strada and it was still an experiment as
far
they were concerned and they were also
looking for early adopters of their
compiler I was a big skeptic so actually
I try to stay away from it for as long
as I could but then at one point I
actually understood their promise which
is that of basically giving you the
necessary tooling to be able to write
and maintain a large application that at
the end of the day executes in
JavaScript JavaScript as far as I'm
concerned and you guys know as well
actually fulfills the promise made by
Java if you would like you really write
your code once and it really execute
every where however if you keep on
adding people to a team or if your code
is is growing and growing and you have
multiple pieces that you need to stitch
together at one point you're gonna be a
little bit scared to make changes so I
personally wrote a lots and lots of
tests to cover my code but then every
every now and then I would need to
change something in someone else's like
I just need own they are they're calling
me in a weird way let me fix it up a
little bit and every time I would do
this I would get a little bit nervous
because I was never really confident
that the changes I do are really gonna
work in the end so that's actually one
of the things that typescript tries to
help with which is it's actually trying
to give you an extra layer of security
more specifically it protects you
against your own stupid so how should I
say this
it's it's more like a safety net I see
it as a safety net and as a set of tools
that allow me to be more productive
typescript unlike many other languages
is not does eventually compile down to
JavaScript but it is a superset of
JavaScript so what does that mean that
means that any JavaScript you can write
is actually typescript as well so
typescript just adds some optional
syntactical constructs such as type
annotations and interfaces and generally
makes author
javascript code more pleasant all of
these things they mostly come only with
benefits as they allow you to have rich
tooling at compile time
and all the typescript at the end of the
day compiles down to JavaScript so at
runtime there's zero cost associated
with with working with writing your code
in typescript okay so I would introduce
a little bit how typescript works and I
hope you get to see my screen so here I
will just launch this to your code over
a simple folder which contains just a
single file I hope you can read it and
this one simply contains a method that
sorts an array and for each member of
the array it does a compare on that
array name now as I said any JavaScript
is a typescript so if I just go ahead
and rename this Dodgers 2 dot es besides
the thing in the corner here that tells
me that this is now typescript nothing
really has changed right because this is
all valid typescript however you see at
this point that if you just keep only
the Java scripts subset of the
typescript language you don't really get
a lot out of it right so typescript is
good and they know that there's a method
sort by name and they know that it takes
an argument but they have no clue what
this method is supposed to take and what
this method is supposed to return so I
can just pass in five and there will be
happy with it now the true value of
typescript comes in once you type two
once you begin a little bit too to
decorate your code with a little bit of
explanations which would also help you
in the future so for example I have here
snippet that actually this sort by name
function is supposed to take an array of
person right so I will just add it over
here and all of a sudden not only did I
communicate this to myself in the future
or my teammates that this function
should be called with an array of
persons but all of a sudden you see
typescript lighting up
and it's already beginning to show us
some problems with our code right which
otherwise as far as we were concerned
looked perfectly reasonable and it would
just fail at runtime now what's
interesting about this is that you don't
have to pollute your code and right at
each and every location the type of your
of your of your variables so for example
result is in feared to be a person array
you don't need to say it again our
result is a person array or basically
here x and y when you call sort they
already know that x and y should be a
person so you don't need to do anything
there either
so all of a sudden you get all these
rich typing only by just more or less
explaining what the arguments passed in
even better they already know what your
function returns which is given a person
array it returns a person array now this
is basically the keeping safe from
stupid like you would just run the
compiler and it has errors so you would
not ship your code but the true power of
typescript comes in when you want to
work right so when you when you would
just type now they already know that X
has a member called name and name is a
string so I can do locale compare and I
can compare it with Y dot name so if you
do this from the beginning
this mistake wouldn't even have happen
because you would just autocomplete
locale compare and it's not look I'll
compare right it's just a type of so I
can fix this and now it's happy of
course it's not entirely happy as I give
it a five so I can for example give it
an empty array and yeah basically this
looks a lot better now what what we can
do is we can try to generate I mean so
far all you've seen all these squiggles
they were just inside the editor right
nothing was really happening you still
cannot see the result of your work but
if you just for example run the types to
compiler and I will just launch it to
watch this file it will automatically
generate next to this ts file the
JavaScript file right and as I said
before this is 100% your code or the
only thing that happens is that these
are no type annotations are dropped so
there's no
more first : person array also the
interface we use to describe this this
just disappears as JavaScript does not
have such a concern now the nice thing
about this is that you can use for
example construct which maybe not all
JavaScript runtimes have so if I now use
a lambda function here
typescript will down level compile it to
a normal function so you can make your
code nice and beautiful and use new ACMA
script six or maybe ik master seven
already features and still downlevel
compile it to to run in any environment
the JavaScript runs in another
interesting thing which I said about it
so let me for example in here create
something now as you see when I do
control space they know I'm supposed to
give in an age because a person has to
have an age according to my definition
of it let me make this even more
complicated so this is just for example
how a class gets downlevel compiled
right so since Eggman script five it
only came out in ACMA script six that
you can actually use the class syntax in
JavaScript they downlevel compile it to
the idiomatic JavaScript you would have
written by making function greeter
greeter dot prototype dot greet and so
on something which is very important to
recognize and here let me just stage
these files that you get to see the div
is that right now I can just for example
go on this name and I can just say
right-click rename I can call it full
name and all of a sudden typescript
knows to change exactly the locations it
must so if you look at the diff it
basically left alone this name over here
because it knew that this name is not
having anything to do with the interface
person or with the rest of the code
right so it's pretty cool that you can
now make a refactoring in your code and
have the confidence that your code is
still executing the correct way
one last thing I wanted to show you on
this on this sample is so if I now run
TSC - in it
this basically creates a TS config dot
JSON file and more or less this contains
instructions for the compiler right it
tells it your module the module system
I'm using for my code is common yes and
it says exclude some folders from it
which in this case they don't really
matter but now if I run the watch I can
for example say oh look I know for a
fact that I'm not targeting any echo
script 5 right I know for a fact I'm not
just targeting any browser I know I'm
targeting node version 6 and up so I can
just say node version 6 supports a comma
script 6 I can just change this to a 6
and what will happen is that oh sorry I
missed I'm into it again is that now
they generate the code by keeping the
native syntax that a comma script 6
brings in so now they do use a class
when when you write it because node
actually supports it starting version 6
they do use lambda functions and so on
so although most all the time your code
can be nice and can be already up to the
latest ACMA script spec and you can
still have it run in any environment you
have now let me close this for a second
and maybe show you something a little
bit more interesting
here I also have the same sort of idea I
mean the idea behind it is the same
yeah okay that looks more happy so for
example here this code is using this
structuring right so there's a function
called point that it gets passed in two
numbers this is the new this is a new
eggman script six syntax that you can
just create a literal so that actually
means what you see here on the right and
you can also use the structuring to
extract the individual properties of an
object and type script also downlevel
compiles that for you
how to actually run it I have to do the
same should result in the same yeah now
what's interesting and what type script
already supports is basically a sink and
a weight so if you do use promises you
can now write your code a lot nicer so
the idea behind this example is that
there's a function called delay and that
returns a new promise I'll get in a
second - why the squiggles are there
this one returns a new promise and this
promise would just resolve itself after
a number of milliseconds now what's nice
about this is that for example the
function ping inside a loop calls ten
times the delay and waits each time for
this delay to occur and after each of
those it basically loves the thing and
then the function main is just awaiting
the whole thing to happen now the
squiggles you get here are because of a
missing feature that typescript has on
the roadmap so right now they cannot
downlevel compile a sink and a wait to
ECMO script 5 because if you look at the
generated code so let me fix it and let
it know that I am in fact targeting like
my script 6 so now the errors should go
away eventually okay there they go
so the read the the reason they cannot
download or compile get to a comma
script 5 is because they actually use
generator functions behind the scenes
together with the new yield
key word to implement this behavior and
leave your code more or less top-down
right you you write a top-down they they
have to mangle it a little bit so they
wrap it inside a helper called the
waiter but at the end of the day your
code stays the same way you wrote it
okay so that's that I hope that was a
really brief introduction to typescript
okay now one of the things which we did
not get right from the beginning
we're basically dependencies so we
failed we utterly failed to keep track
of what each javascript file needs and
what it provides right so that's the
basic rule if you want to have a good
system you should have a way to know
what each of your file needs to run
correctly and what it can offer to
anyone else built on top of it and we
totally sucked and we totally failed at
this at the beginning and one of the
reasons for that is because we were
using namespaces right so you were using
well namespaces being a very fancy word
for Global's so for example in a certain
file we would just reach on to this we
call it namespace dot util dot strings
and define a new method on this
namespace
however the problem here is that there
is no correlation between the file that
actually does this and the namespace
that's actually being defined right so
here I could call the file strings dot
J's I could call the file utils Dodgers
but the problem is that nobody in my
team would know where to actually find
the implementation of the trim function
right they might be using it everywhere
but they wouldn't necessarily know
unless you're really careful about it
they will necessarily know which file on
disk they should go open and change such
that can they can change this method so
renaming files was a huge pain renaming
namespaces was something we never did
because we wouldn't know where where
they are all used and of course if you
just try to do a string search as you
saw before with the name case right you
you would just hit so many different
occasions you wouldn't know which one is
a false positive or not so yeah I guess
this is a fun way to depict depict what
I think was our dependency graph at the
time but regardless so back then we had
our source split up into client and
server so we would have this tiny little
node.js server that would serve up all
the contents and it would know how to
read files from disk write files to disk
and so on but most of the code was
client-side so most of the code was
running inside the browser now for no
J's it is a given right everybody that
does know just uses common J's as a
module system and this is great I mean
it's great that note came out with
something like this from the beginning
however there is a little subtle catch
which many people are not aware of so
for example how do you think Note
evaluates this code that you've written
right so what they do is when you when
they load up my module dot yes is they
will more or less read this file from
disk yeah they do a little bit of
wrapping where they added their name and
so on but then they will go on and
evaluate and as part of evaluation you
see the problematic line over here is
that they basically have to make an
implementation of this require function
and if you step in and step in and keep
on stepping like until you really reach
the meat of this require you will see at
the end of the day it does an F s read
file sing or equivalent right so it will
literally block the VM execution the
JavaScript VM will be blocked until it
goes to death and tries to read this
file out and why does it do that because
that's how the code is written right so
the code at this point when this require
function returns it should very well
return whatever is exported from that
other file so common J's is great
because you get to tell exactly in a
file this is what I need and this is
what I give to you into the form of the
exports but basically the problem with
it is that it's very suitable for
running on a server maybe where you have
local disk access right you cannot do
this in a browser you cannot expect you
ship this code up and then in here do
basically a synchronous xhr request to
try to fetch your dependency so that's
basically at the time when we looked
into it that's also when AMD came out so
AMD stands for a synchronous module
definition and the only real difference
in the code is that it's it's all the
dependencies of the actual code are in a
way extracted outside in an array so
what this means is when you actually
look at and run this code you can
capture yeah this is the the code I need
to execute inside this function and
these are the dependencies I need to
fulfill before executing that code so
basically if you write a loader like
that you can then a synchronously fetch
this dependency ID and once you have
that and once you have resolved that
that's when you can actually run the
actual code so we actually stuck up with
AMD and I will give some more examples
why we find that useful so this is from
a time when there was no other module
system right there was common J's and
basically and okay so yeah before that
the good thing about typescript is that
it actually supports that you can come
down you can compile your JavaScript to
either one of the two or even something
they call um V Universal module
definitions so in typescript you just
used a new format for dependency that
will come up in ACMA script seven I
think so you just write your code
normally there's no spaghetti there's no
defined function there's no nastiness
and then you just by the flick of an
option as I showed you there in the TS
config dot JSON you make it compile and
it generates common just looking code or
AMD looking code one of the advantages
of AMD which we began to to benefit from
early on is the lazy code loading so one
of the things we do is for example if
you open us up and you know we ship with
like 30 languages right we have PHP
c-sharp I don't even know them Ruby and
so on like there's just so many of them
you know what would be really really
stupid is that if you would open a txt
file all of a sudden you will load those
30 languages just because they're there
and try to start them up just in case
they are needed so what we're actually
doing is we split our code up or we have
a sort of like a contribution system
where on the one hand something which is
mostly like I don't know 30 bytes or
whatever when you minify it and so on
this just describes to the system that
there is a language called PHP which
should kick in once you open a PHP file
or a PHP 4 file or a PHP 5 file and once
that once you do that once you actually
do open it then you should load the
module at blah blah blah and instantiate
the class called blah blah so basically
when you open a text file the only thing
that loaded that is loaded is this piece
over here and then only later when you
open a PHP file that's the entire PHP
thing get loaded and this yeah okay
sorry so it might look that it's smaller
but in fact this is lots of code over
there to actually implement PHP and all
the semantics and all the coloring and
so on yeah so yeah we like to think of
it like an iceberg right like we have a
little part which gets synchronously
loaded that describes that the other
part should kick in at one point or
another and then hopefully the large
piece of code that actually knows how to
do PHP is only lazily load another thing
which we do is we take advantage of AMD
loader plugins so whenever we write our
code by now it's all done in typescript
we can just have like oh sorry besides
the regular dependencies we can just
write a dependency to the CSS that this
file needs so for example this is just
like the I just took some lines from the
code that renders the current line
highlight so when you move around in the
editor we render a little highlight of
the current line now how this highlight
works is that in the end of the day
it creates abdominal and it sets a
certain class name on this domnode and
then it maintains it right if you move
your cursor up and down it moves up and
down but essentially it's just a Dom
node with a class name and of course to
make things nice you want to put the
styling of your app outside of the
JavaScript or typescript code so you put
it in a CSS file so now whenever we end
up loading this file called current line
highlight dot yes the this dependency
will show up we will actually invoke the
AMD CSS plugin and which is indicated by
this bag over here so we will load first
a plug-in called vs CSS and then pass to
it as an argument the rest of the thing
and the rest of the thing is more or
less the path to how to find the CSS
file so we actually make use of this
both at development time when we when
you want to run something and we also
make use of it when we bundle so that's
one thing we do and we are actually keep
on doing since a very long time and if
you want to take away something with you
today is maybe you should really look
into bundling and minification is true
so for example this is the startup time
of Visual Studio code this is split up
into three so the first piece is
basically just a given
that's just electron it takes a little
while to start up it needs to load 40
megabytes of goodness we love that we
want to have all the api's of html5 we
want to have all the api's of note it's
what it is right that's a given cost
start it's basically the same cost that
you would when you open Chrome for
example there is a certain cost until
JavaScript finally kicks in the the one
at the end is just logic it's just some
code which renders the first time things
start up and the thing in the middle is
the actual time spent in loading and
evaluating the code the first one is
when we run with maybe thousand
different files
so this is all locally right everybody
says you should bundle and minify
because each byte you sent over the wire
costs each request you make to the
server has a certain latency and you
should try to minimize those but this is
all running locally it's all running off
of my SSD so what I found very
interesting is that simply by bundling
all the files into one you actually get
quite quite a benefit so this is all the
same code you end up shipping the same
thing you don't even change anything in
your code it's just a matter of how you
how you package it and then even and
then we thought oh yeah let's just put
it all in one bundle and not minify it
why many files right maybe people wanted
to edit it and look and debug it and so
on but then even minifying helps and I
left it here as a link at the end as a
hint I don't know if you knew this but
for example v8 if you have a function
you know like at one point you can go on
a function and say function dot - string
right and this shows you more less the
body of the function now if the body of
the function is over 600 characters that
function will never get in line anywhere
regardless how many times you call it
and like maybe you have a big fat loop
of going to 10 million and you call a
single function that adds two numbers
that function will never get in line if
it's over 600 characters in size it's
just a number the v8 guys came up with
it and they ship with it and they don't
care but basically a few minute I heard
and it sounds so stupid right just
minify your code it will more or less
extract the comments it will make all
the identifiers smaller and you might
have a very good chance that all of a
sudden a function which was not in line
before is now in line so yeah yeah after
we finished and after we actually moved
all our code to AMD we were very happy
about it okay so this is more or less
the basics right like we finally after a
while we figured out the basics which is
like yeah manager dependency though of
course I don't know
use good abstractions like promises and
classes and so on of course and at one
point our code just kept on growing and
growing I mean you'll notice in the end
I don't even know because at this point
we were split into so many repositories
but I don't even know I just gave up I
didn't have the the I didn't feel like
writing a script that goes and pull
sources from different repos and tries
to eliminate tests and so on to figure
that out
so as we kept on growing I actually gave
up my huge anti typescript opinion and
the reason for that so this is actually
a funny story so I don't know if you
were paying attention in Eric's talk
this morning but we basically now ship
with Internet Explorer starting with I
11 and what they now call edge so when
you do f12 if you've ever have two done
that you can debug your JavaScript in
there right so that's actually our
component and one of the things they
asked for is that people when they do
that sometimes people they end up maybe
stepping by accident inside jQuery dot
min right now jQuery dot min is not the
worst file but it is it's a file that
contains everything on the first line
right so we were like yeah yeah just
take our code our code is awesome the
first thing they tried it failed
miserably and then I was going home
crying
no but basically what I realized is I
had all of a sudden between my view code
and between my model code so the editor
is split up into sort of like a view
model controller sort of thing where in
the model which keeps the buffer you
just have like an array of lines and in
this case for jQuery men I had an array
of one nine it was just like a very long
string and I realized actually all of a
sudden needed to plug in something in
between the view and the model right I
needed to plug in what is now in the
source and it's called the view model
and now what this view model does is it
basically transforms the model and
splits this huge one line into multiple
lines which
so and plain people talk is called word
wrapping so I was just building it up
right but it's more or less when you
when you have a long line right and
you've seen this in all the editors you
use at one point the code will wrap if
you wanted to write or it could wrap at
the at the level of the viewport or it
basically maybe wraps after a certain
number and so on but basically I had to
introduce all of a sudden in all this
view code which was already like
tinkered and optimized I had to
completely replace the data structures
that it no longer goes to the model but
it goes through a view model which has
the chance to do something with with the
actual text to make things better so
instead of spending three weeks doing
that I spent three weeks going to
typescript and more or less two or three
days doing that because it was a lot
easier once I was converting my code to
typescript it was a lot easier to see
what sort of data structures my view
needs and then I would just implement
them and provide them through this view
model yeah I think this is my speed I
don't know if this is really important
like yeah and okay we also have some
team specific rules so for example we
try to put return types like as I showed
earlier that typescript can guess it but
at one point you're actually going to
burn a little bit of CPU like if you
have a large large project and you let
it in fear everything it's gonna like
take a while to interfere everything so
we try to help it out by actually
putting the return types on public
methods and so on and yeah just dock the
stuff and PS lent it yeah this is an
example also that basically this is from
from my code so this is supposed to say
start marker ID but in JavaScript it's
perfectly fine to say delete the key
undefined right so I had a range and
then that that marker ID did not exist
on this range so this would evaluate to
undefined and then the code would just
say delete object of undefined and
that's perfectly fine as far as
JavaScript is concerned that's perfectly
fine and this was causing like quite a
memory leak because every time you would
type I would like me
a little marker to remember something I
don't exactly know what but every time
you type I would have one of these guys
leaking right and I had no clue about it
until I converted my code
another thing which I found interesting
is that what you can do with typescript
is you can basically compile so imagine
now you're two teams or maybe you're two
different projects so for example we
consume from the typescript guys we
consume this typescript services dot J's
that they produce
that's just like a big fat javascript
file and you can throw to it
typescript you can throw to a JavaScript
and it will just tell you all sorts of
goodness about it that's basically how
the demos I showed before in the editor
work we more or less take the buffer
that you're typing throw it inside the
smartness they're really smart guys they
know what they're doing and they just
come back and offer suggestions they
offer hovers and so on based on it and
we do that by them basically shipping to
us a bundle minified javascript file
accompanied by a DTS which more or less
describes what is inside that JavaScript
and conceptionally this DTS that's the
API that we between our projects have so
if they make up a new version we will
get both new files and we will just
compile against the new DTS and we'll
just get errors wherever they have
decided to drop a certain method or to
rename it or so on we do the same when
we ship the Monaco editor this thing
that is a library and runs in the
browser and we also do the same when
whenever you're an extension you get a
vs code or the dot yes that describes to
you the API of vs code on top of which
you could build there's something also
cool that typescript supports they're
called decorators in this case they're
constructor decorators and we use them
to actually get really nice service
injection so what they do in this case
this is basically an action in the
editor it's the action that if you press
f12 at one point it asks someone smarter
than it and after the promised returns
it can actually
to the definition of a certain symbol so
you would do this on a function it would
it would jump you to the place where the
function is implemented and then we
actually use these decorators to
signalize that we should inject some
services to this action in this case I
will just focus on the message service
so later in this code I did not all fit
in here this action if something bad
happens like a boo-boo like a error it
actually calls inside this message
service and says show error now what
this means is when you run vs code we
have an implementation of the message
service that shows a little drop-down at
the top right so here imagine I was
writing my cool Fibonacci code and then
I was saying go to definition it didn't
work it always works by this was just
fake and then it would just show a
message at the top now the same code
that I've shown which is this go to
definition action it's also shipping
with the moniker editor which is a
library that runs in a browser right all
of a sudden here we do not own the UI we
do not own the exterior of the editor so
we don't know how this message should be
shown in the app so the default
implementation we ship with of the
message service is just a stupid
console.log but of course we have ways
for people that integrate us to
substitute that implementation with
their own and finally inside the test
here I had to do a little bit of paint
art to cut them out too that they fit we
basically say if the message service
inside the tests ever gets to show an
error message let the tests fail so yeah
okay
to more recent times so we are actually
built on top of electron and I would
like to show you a little bit have any
of you heard before of electron okay
cool
nice so I hope you will not find it too
boring then but it's easy okay let me
stop the other things
okay so here I have a minimal electron
app so what is electron electron is
basically a very nice marriage of
chromium and node.js and how they work
is that you give them a script in this
case it's this main dot yes I will show
you in a second
oh okay sorry about that
hey cool okay sorry about that so this
is main.js
this is basically where the I define the
entry point to this example this is a
minimal electron example so what it does
is it uses their API which comes in form
of this module called electron and then
once the app is ready so usually you
would say document already but in this
case it's more complicated right it
basically creates a new browser window
it says that's your width that's your
height and in this browser window it
will load the file index.html and then
once it's closed it's closed and once
it's closed it quits or something like
that so that's how you should read that
inside the index dot HTML that's where
you actually have that's where you you
finally get both the browser API and the
node API this main dot J's is basically
a driver of these windows so you know
how Chrome if you launch Chrome and you
open a new tab they make a new process
and you open a new tab they make a new
process so how this all works is that
they have a main process which is
basically an electron driven by this
main dot yes and that process is always
there and that's the process that
communicates to the OS and that's the
process that owns like the buttons the
menus and so on and then you have each
render process which is more or less
what it gets rendered inside a document
so let me just try to run it I would
even show you here hopefully that works
so this is a really simple example it
just says hello world but I wanted to
show that already when I launched it
right there's a main process and then
unless you can recognize like it has
okay it's hard to read sorry about that
it basically says main jet and then this
one is a renderer process which is the
marriage of the HTML and no now to
better prove that this is really a
marriage made in heaven
inside this render yes I have led some
coding and I hope your eyes are not
bleeding right now because yeah on this
line we're actually making a Dom element
and on the next line we're using node
API to fill that element in all right so
you should never do this at home but
that's actually one of the cool stuff
all right did I kill it of electron so
now this thing runs and it just prints
its own source code but this just shows
how you can how they allow you to work
together and have something which is
both HTML and node.js so this is great
if you're like if you know JavaScript
you know html5 you know note all of a
sudden you can build the rich app and
ship it very easily one thing I wanted
to point out is that this main dot J's
is a very important process so inside
this main dot J's you should not do what
I'm about to do now which is more or
less it's a set interval and what it's
doing is it's computing Fibonacci which
is always good to compute everybody
loves that and the number it's computing
on grows right so this is more or less
exponential in Oh Big O notation and so
on so if you now run this what will
happen is you see as I'm moving the
mouse at one point you see how the thing
okay it's hard to say maybe we already
lost it but at this point the whole
thing goes down because how electron
inherits the process architecture of
chromium so this main process
if it's now super busy it will basically
bring down everything with it because
even a mouse move actually goes to the
main process and then the mouse move is
sent over to the renderer process where
you actually get a chance to do
something and if your main process is
busy your app is sort of dead so this is
just a little bit to motivate okay thank
you
I know I did this I deserve this is just
a little bit to motivate what we do
individuals to your code so as I said
before this is basically what we get
from electron-electron gets this from
chromium and once you run it you get a
main process over here and for each
window you open similar how in chrome
you open a new tab you get a new render
process now what we've done is that as
I've shown you before it's very
dangerous to do actually anything in
that one because if you by accident have
something which is a little bit complex
or a little bit maybe takes two seconds
all of a sudden you're all your windows
might not get the UI events and so on so
we actually create a new process that
where we do things such as checking for
updates like because this is something
that impacts the entire product or we do
things such as managing extensions and
so on we have other processes so for
each render process we create an
extension house and we also launched
on-demand processes like if you do a
search we will launch a process it will
quickly search on the folder you have
opened and give back the results and so
on we also have web workers so this is
all making this thing very complicated
because each one of these processes they
have a different execution environment
so the blue ones are node the dark blue
one is node and a little bit of electron
the purple one is node and electron and
html5 the green one is just JavaScript
and web worker API so today we don't
have a great solution for this so it's
still something we are trying to figure
out but we do use a folder path name
based convention sort of things so we
have code under coma
under node and a browser and so another
quick demo I will try to hurt you
this is basically how do we actually
develop the rest your code so okay I
hope you get to see at this time
so basically to develop adjust your code
you more or less clone the vs code repo
you do npm install conceptionally and
then just run gulp watch which is just
something i've already done before
because i don't want you to be bored
today and one of the things we've
invested in is that once you launch this
gulp watch it takes a little bit to warm
up so it's like takes maybe 3040 seconds
but then every little change you do
becomes incremental so if I if I do
changes inside the vs code type script
code this guy to the bottom kicks in and
just like that like an under a second or
so it basically has compiled and
generated the JavaScript this is
something which we found very valuable
like this cycle of typing something and
then being able to run it the next
second it's very important for us so to
actually run it we just have in here at
scripts slash code and then and then
this runs there's just your code in
development mode right it runs out of
the sources it's not packaged as what
bundled it allows us to do nice
debugging and so one of the things I
wanted to to do here is and it's of
course motivated by an interesting thing
so I don't know if you if you've seen
this page so at one point when I
registered for the go-to thing they
asked me to give a fun tagline about
myself
so I thought okay what's cooler than
drinking beer which I love to drink
right and apparently in the meantime
they renamed the field to say what
company you work for so that's why I'm
the guy that says I am my job is to
drink beer which is a great job so I
thought then I just do a demo which
actually shows I am a beer drinker
professionally so here I will just make
a little change to some CSS of course
and I will just do the right thing such
that when you refresh now all of a
sudden you get beer in your editor
background everywhere right so this is
just the best who needs to read code you
can just say oh I could not read it
because of the beer so yeah that's a
tiny change
something else which I wanted to show
and that's something we care and we do
so let me just bind these keys again so
this just add some commands which I have
locally i we don't ship this because
it's just some performance test and now
it's just bounce them to f2 f f2 f3 f4
so what they do is they do lots of stuff
like the f3 whoa okay I have to refresh
to get it sorry so if I now press f3
it's just a performance test that I run
every now and then which is just acting
as if you would just hold down the
cursor down and just like scroll down
right and this is one of the things that
we use to profile and we try to really
put an emphasis on making our edit or
performing so let me remove a little bit
the background but basically what we do
and this is the one I actually like the
most is the a4 one and I hope you see
that so this is me usually working right
so you see my productivity going up like
crazy but this is just a test which is
more or less typing out an entire file
and usually how I run this of course is
I open up developer tools and I profile
it and then I try to dig into what's
happening so that being said this is
actually something which I wanted to
share it might it might or might not
help you in your day-to-day life but I
wanted to share this technique that we
end up doing in the editor so this is
actually called virtual scrolling and
what I what I captured here is on the
one side I'm scrolling inside the editor
and on the other side I have shown the
developer tools the Dom nodes right and
you see I try to do it very slowly that
as you scroll the lines down the old
lines go up they get pushed and then
eventually removed so you get to see
that they get removed at the top and new
ones come in and you see they have this
knife animation which shows you which
ones are fresh and so on so this is all
very good this is of course
something which we had of course this
done doesn't really help you if you have
a really really long line like the F
tall guys asked us to fix but it does
have some interesting problems of its
own so maybe the guys in the in the
first row can read that do you actually
know what this is this is jQuery but
it's not here because it's jQuery this
is jQuery minified right so as I was
saying this is actually if you if you
show this to any guy who's written an
editor will tell you to go out please
because this is just the worst you could
do right because at one point if you
think about it when we have to render
this and we render it as each text each
little different color text we make a
span out of it so we do create a Dom
node and it's a spawn and for example
jQuery men in the first 42 line it
generates we need to render like 3,500
tokens meanwhile a normal file like this
is jQuery non minified is yeah only 280
tokens because mostly they have a lot of
comments which I love because they're
all green it means performance is great
so right comments in your code but
basically the problem we were having and
something which I was doing is I was
profiling this and trying to see how it
goes so even though the frame rate was
up the probe the CPU time was was quite
high as well and one thing I would
recommend is to get to know the tools
you have so I don't know if you ever use
this one it does enabled paint slashing
this one gets to show to you what
actually chrome paints on each on each
frame and after enabling this I could
see that on each time you were scrolling
the chrome would paint the whole thing
and one of the reason it was doing that
it's because as part of scrolling I was
just moving the position of the Dom
nodes right I was just saying position
is now -5 okay we have to cut it short
anyhow we Lew used in the end
translate3d yeah these are some links
and yeah thank you for listening to me
today yeah
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>