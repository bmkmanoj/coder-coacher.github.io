<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Javalution - How I Learned to Stop Worrying &amp; Play Jenga • G. Saab &amp; A. García-Ribeyro | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Javalution - How I Learned to Stop Worrying &amp; Play Jenga • G. Saab &amp; A. García-Ribeyro - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Javalution - How I Learned to Stop Worrying &amp; Play Jenga • G. Saab &amp; A. García-Ribeyro</b></h2><h5 class="post__date">2017-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VJQzckSz_N8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so for this next session I'm going to
speak a little bit and then I'm going to
hand over to
Aurelio's so I will introduce them first
and then myself Aurelio I guess we could
wait for the slides where you want to
wait but yeah sure that's fine we can do
that I'll do in a minute I'll I'll start
in and introduce myself in fact oh by
the way we both work at Oracle so you
get the pleasure of seeing this slide in
right yeah anything about the future
it's just a plan from Bank on it
yeah it's the future and and this is
sort of the another version of our title
which is you can't make an omelet
without breaking some eggs
so we're going to talk about omelet
making so I am the vice president
development for the Java SE group at
Oracle I'm also the chairperson for the
open JDK governing board and Aurelio is
director of product management at the
also at the the Java SE group at Oracle
and was previously at Sun and around
working on Java for many years almost a
decade right yeah that makes me one of
the nah I think I'm just shy of being
the junior person in the team because we
got people that been there for 15 20
years so I'm still following you and
before going over to the dark side of
management I worked as an engineer on
Java um back I think I started it son in
1996 and so I have there's a lot to
blame before let's put it that way and
then the third presenter is Charlie Hunt
who actually is chicago-based and so we
were hoping to heaven come by and talk
to you he is on the performance team
he's a performance architect for Java in
the JVM unfortunately he was not able to
make it today
all right so some headlines as you guys
can see everyone is predicting the death
of Java horrible horrible it's really
sad of course if you take a look at some
of the dates you can see that these were
headlines at various releases of Java
over the last twenty years so basically
we have a trend here write a bunch of
stuff comes along there's new stuff it's
a little bit scary everyone's afraid
that the world is is going to end and of
course as we've seen it hasn't ended on
there have been you know different
releases some bringing more
functionality some some less but by and
large as a development community we
embrace these we found ways to both take
advantage of the positive aspects we
bring and also deal with with negative
aspects to the extent that there have
been those and the reason that I bring
this up is that we now find ourselves on
the cusp of a new major release of Java
coming scheduled for July of this year
and this is one of these releases and
releases which is not so much
evolutionary as revolutionary this
brings the module system for Java
it also module arises the JDK and so
we're going to talk a little bit today
about both that and other things that
are in nine that you may be interested
in as well as possibly a little bit of
you know what we think the future is
going to look like I think one thing
that we can definitely predict is that
it will take longer for people to adopt
jigsaw because of the fact that the
module system brings along with it
strongly capsulation and and I think
that is something that will be a little
bit of a challenge for people to get
their heads around initially we're also
trying to do a lot to make that
transition easy I think above all one of
the things that we tried to do is do all
of the development of nine in the open
in open JDK so you've been able to look
at everything that's happening
look at the code download weekly bills
and we've had a lot of people doing that
and not just people who are you know
interested in JDK implementation or JVM
implementation but also a lot of makers
of frameworks and libraries as well as
application developers so let's let's go
ahead and look at this what what kinds
of things is is for well you know
clearly a modern programming language
and platform needs a module system right
I mean you know you'd hardly build one
today without finding some way of doing
that but of course a challenge for Java
is it didn't have one originally right
it had a fairly simple way of organizing
your code a pretty simple way of
indicating to use the developer what
code is actually public API that I
should be using or what is something
that's meant to be an internal
implementation detail which may be
available to other classes in my package
but it's not really something that
someone from outside is intended to
reach in and use however Java didn't
provide for a way to prevent your doing
that and of course at some levels that
can be a feature right it makes it very
very flexible it's really convenient to
me that I can go and look at a bunch of
code that is this somewhere and I can
call it on the other hand you know if
you are trying to maintain this as a
system over time and evolve it and make
it better
it's very very hard to do that if
absolutely anything could be called and
changing it would be considered
something or could be considered
something that breaks users and so you
know this is this is where this desire
to evolve and improve sort of comes up
against another principle which you know
we like to think we hold very strongly
in developing Java which is not to break
users right we want our releases to be
compatible we want your existing code to
continue to work so you know the
challenge in this case is how do you
evolve something when nothing can change
well clearly that's not something that
is tenable forever and in fact you know
you can go back and look at the
tation from Java all along from you know
mid-90s and see all of the places where
it says you know this is public API that
you can change that you can use these
other things that are here you really
are just strongly discouraged from using
so we'll have a little bit more about
that in in a few minutes but you know
some I've heard some people sort of say
well you know okay look I can kind of
understand the idea of modules for the
JDK right for actually modularizing the
JDK libraries but you know do we really
need to go and extend that to frameworks
into applications well you know
interestingly a lot of the people that
we speak with and many people on the
team have you know not always just been
working on Java but have actually used
it in other programming systems over the
years to you know to make end-user
applications and you know one of the
things that we use universally find is
that this challenge that we that I just
described for implementing the JDK
exists for those frameworks as well
right so if I'm writing a framework
their library I want to be able to
evolve it but I'm similarly you know in
a bad state if I can't change anything
because everyone is sort of reaching in
and dealing stuff that's internal
implementation detail so it is something
that libraries need and want even at
sort of a higher level writing an
application you know how many of you
have been in a you know a larger project
in your company where all of a sudden
you found that something you wrote that
you didn't even think about you know how
to do it because this is all internal
you know somebody else ended up using
and depending on and you changed
something without realizing that and
everything broke right happens happens a
lot so I think that need is there but
it's sort of greater than this as well
because in addition to this sort of
encapsulation challenge a number of the
other things that we hear from users is
well look a lot performance to be better
we want footprint to be smaller and when
we say performance we also mean startup
time right so that has been one of the
things that people have felt over the
years which other that we kind of carry
around too much stuff like
do I really need to have Corbeau when
I'm not using it exactly and in addition
the startup time which you know again
it's wonderful with Java that you have
the flexibility of things actually being
loaded at runtime right and then things
starting to compile over time so which
other you have both the initial startup
which is the JVM runtime coming up as
well as your file being you know being
read in and initially interpreted and
then over time compiled as well as all
the things that it's depending on and
importing having the same thing happen
there and we have had you know over the
years a few productive experiments with
things like pasta data sharing and other
things that allow some of the stuff to
be done ahead of time but what we really
want to get to is something where you
know when you start your application it
comes up super quickly because all of
the work of validating classes of even
compiling resolving dependencies
everything that's done by the class
loader magically for you at runtime can
actually be done in advance okay so so
that's a big that's a big piece as well
so as you can see I think there are you
know a bunch of benefits that the module
system brings with it however even some
of those advantages are also things that
could be regarded as as disadvantages
right so you know a lot of the the sort
of resolution of dependencies and and
avoiding ambiguity of which actual
version of this class that was on my
gigantic crap path did the runtime
choose for me right now it's pointed out
you know you're going to resolve that
dependency you're going to have to and
before you might have thought a system
was doing it for you but you're actually
just deceiving yourself
you were lucky if if your code got the
right one so you know there are a bunch
of things like that that are going to be
interesting to to look at all right so
I'm going to actually hand off now to my
colleague array Leo who's going to go
through a bunch more detail in injects
on another
thank George I think yeah by the way who
noticed that the last tool in the good
section is actually the first two in the
bad section right yeah that's not a typo
that's because for some people people
that is named dick so you don't want any
ambiguity you want to know which class
you're loading they're frameworks that
you know exploit that option and
consider anything that fixes that about
likewise we now have a clear separation
of what it's going to intended for you
to use and what is intended to be used
by the platform which we think is a good
thing will allows the world a platform
that's probably going to be the hardest
pill to swallow for people moving to JDK
9 which is things that they expected to
use and we're always used to having
access to are disappearing so why is
that it's a bit of background there's
always been a bunch of different
categories of API in the JDK there's a
couple of them that were supported and
intended for use for external use so
there's some Java API s
that are part of the Java specification
you cannot have something and call it a
Java implementation if you don't provide
those API so of course developers you
know that's the contract that's what we
say Java provides if you stick to that
you can write Java that will run on the
Oracle JDK or an IBM or in any other
vendors because they all have to provide
those API then we have other api's that
were jdk specific that's you know son
now oracle to serve api's that are only
in that product but that were meant to
be used by developers an example of that
is when we introduce Java FX
it's not part of the Java specification
but the dev FX ap is you know it's meant
to be used if you look at the
documentation it says go ahead and use
it and then there's another set those
are the unsupported JDK internal don't
touch this API those are mostly under
standard star okay there's a couple of
Sun dot star
guys that we think are good to use but
last majority of the Santos star are
don't touch that and I mean you're not
supposed to be able to read that but
that's just a screenshot you can find it
with a Internet Archive over 1996 that's
what this little warning from Sun
telling you not to use this API as of
JDK 6 you get warnings if you try to
compile using this API now just out of
curiosity how many people here ignore
the compiler warnings a regular part of
their day come on fess up right a lot of
people they're just like oh yeah I
compiled to give me one is who cares
about the warning recompile it's running
you should there's a reason we put those
warnings in there so when we were
considering well we have jigsaw the
truth is we could have just done jigsaw
and not turn on this feature and just
leave it so that those internal api's
would remain open and I would have made
the adoption of JDK 9 simpler and we
will just be having this conversation
with dedicate hanoar JDK 11 so we will
just be kicking the bucket for a little
later and we would still be in the same
problem so we've decided now we should
do the right thing right now that we
have a mechanism let's go ahead and use
it
so we went to look at a bunch of
different products we have the same
access that you do to libraries that are
open source and we look at their code to
see whether there was indeed some
internal API that was required and you
know maybe we should just make that into
a Java SE API and this is what we found
out you can see that there's couple of
api's that are widely used but then what
we have is a very long tail of you know
one of two use cases of products trivia
question which one do you think it's the
most use internal API anybody wild guess
and say this is by the way this is I
love this question because everybody
says and says it's not basic ste for
encoder okay about twice as much
well not twice as much but that's that
number one lead basics before there's
API is that I've been doing this for a
long time there's a lot of external
libraries we introduced a base64 encoded
in JDK 8 and still the most commonly
used API is a 64 as a just a bit of
trivia when we introduced the beige 64
encoder the official one that's JDK 8 we
have a customer call us and tell us
there's a bug in the new class its
encoding incorrectly so what is it
encoding correctly it gave us the value
of the like Nana the original one the
internal one that's not following the
exact certification we use it to encode
a certain set of characters that
character was not in our test case so
the new one does it correctly the other
one has an error and what was the
company customers answer could you put a
flag so that the new one gives you the
same error so that's how entrenched
people are to using these things right
well when we saw this we realized
there's a bunch of internal API that are
used for convenience but like the base64
encoded one there's a quite an easy
migration path right use the official
one there are other cases on which yeah
there may not be a clear migration path
but really you know what you're trying
to do it's just such an stream edge case
that we can live without that thing
existing you know if your code doesn't
do that that's fine there were however a
handful of api's that we found like some
miss can save where there's a valid use
case for it and there is no officially
supported API that will support it so if
you look at the jet where we introduced
this we called out I think it's about
five classes that we say those are
internal API that we do intend to remove
at some point but there's no good answer
for in jdk 9 so we're going to leave
those exposed those remain publicly
available visible
you don't have to pass any parameter
they're still there go ahead and use
them with the warning that we're
actively working on providing you with
officially supported versions for those
api's when we do we will remove them so
this is not a you know new contract
we've introduced them to the standard
that's not what we're doing here we're
just saying yeah we need more time for
those everybody else is going to be
hidden by default and notice I carefully
chose the word it's hidden by default
meaning you can unhide them right so but
don't okay it's just a bad idea but this
is going to be the thing that's going to
keep most people just going to give a
lot of grief sorry about that but we
think it's the right thing to do
then we have other changes and in some
cases you know anything that we change
trips somebody up one of my favorite
examples was I don't know if you guys
heard that Sun was acquired by Oracle
yeah no news we of course went and
changed some of the properties so if you
look at the bender properties of the JRE
it used to say son right after the
acquisition what would you expect it
would say Oracle right
it's the vendor property on the file
who's that going to affect yeah I think
was Eclipse that was going to break it
with it that because they were using the
vendor property to decide which starter
parameters to use and they said if it's
Sun you know it's hot pot and if it's
not Sun not be again and it's j9 and it
uses different startup parameters and
you know Oracle is not Sun no pun
intended
so therefore when we give them the early
access build of this it broke and we had
to provide them if you look at the J
arena if you download it you will see
this a little text file which has a lot
of information including you know it's
whether it's Oracle or not and that's
the kind of stuff that will trip us up
right we think nobody's going to rely on
that and sure enough somebody does
similar the version string anybody
download the latest version well it's
now 31 rather than 20
that's the verb if you do a Java -
version on the twenty one version this
is what you get right now anybody knows
what all of those pieces would mean you
know the one dot it's a historical
leftover every version of Java all the
version strings have always started with
one dot what does he mean by now nothing
it's just yeah well you don't want to
change it because you know it's always
be there the eight is the major version
that makes sense the zero we had
something called revisions last time we
use it was four version four remember
1.4.2 there hasn't been a revision since
and we don't expect it'll ever be
actually that's not true there has been
a revision of eight we just didn't read
the number because it's not such a big
deal anymore right so we don't try to
keep it in sync so even though the
version the speck of eight has changed
we didn't change that number it's filled
zero then there's a non-standard
diameter there's a number over there
that's the update number and the rule is
pretty straightforward
all for security even for features right
this is a leftover from when Sun
alternated and it was every three months
it was like C synchronize security
release that's what they call it and
then a feature read then a secret
security release so it wasn't planned
but it turned out that it was out for
security except that and then the bill
number except that you know it didn't
stay there we decided to do more
frequent security updates so that sort
of broke that even odd but we liked it
so we change the rule and we said it
will make it end in five or in one for
scheduled critical patch update right
and we will keep other odd numbers for
unplanned security updates and multiples
of 24 features and I can see the
laughter going I mean all of these each
one of these decisions make sense at the
time but once you string them all
together you end up with something
ridiculous by the way we realize here we
introduced bpop oh it's not in five it's
going to be in groups of ten it went
completely bonkers
right so JDK nine were ditching this and
we're going for something that is closer
to semantics
versioning we provide you an API so that
you give you a version screening and
parsing validation so the DA version of
nine if you look at version screen
you'll be nine not one but 9.0 double
security updates we include you know we
have another digit this is for when we
add new features if at security it's all
you're doing you're not adding your
feature so that one remains unchanged
zero and we just keep incrementing this
one we also leave some gaps because you
know they may be a security alert that
we didn't plan for and we don't want to
have to renumber everything further out
so up to nine will release 9:03 the next
plan security update will be nine zero
six if we were to do a feature update
after nine zero six it would be nine dot
one dot six notice that the six didn't
move because we do pick security
vulnerabilities we just add any features
now does that is that a little bit more
readable okay we hope so we also found
what we're looking at code code that
would just go and say well let me figure
out the version number delete the first
two right because it's one dot you don't
have to yeah that's going to break sorry
also this means that all of the file
names for the JRE and the JDK change so
if you have some sort of automated build
system that grab the file for you and
concatenated things and downloaded the
correct one is what sorry
and you know in order to add a little
insult to it this is not retroactive and
we expect JDK 8 to be around for a long
long time so I envisioned a long future
where we have a version less than you
know nine D geologic if Larssen and
above this is your logic but we think
again the only way that you you know
stop progressing is if you die so this
is the cost of progress this is you know
we have to break some eggs there's some
other several changes in JDK nine that
matrix um people up there's a bunch of
tools that we ship with the JDK that are
not really to the same level of standard
as the JDK itself in some cases we don't
develop them so for example Java DV it's
just a
packaging up Apache Derby and it's in
the in JDK 8 it started ship with Jetta
k6s egg or 7 in any case whenever I ship
anymore we figure you know now it's not
a big deal back when we did this it was
a big issue to go and try to download
some separate software and this creates
a lot of problems right what happens if
they rev at a different speed than we do
are we going to rev just to keep it not
so a bunch of tools are not no longer
than a ship in some cases when we shall
VM we really like it but we don't
maintain it you know our team doesn't so
it just remains in github go grab from
there there's some other experimental
tools that we thought oh these are cool
but you know it's kind of hard to keep
up with those experimental tools and now
they have better alternatives so those
are going away and we're also changing a
few default anybody is familiar with
what's the default garbage collection
algorithm for the JDK right now and the
trivia question is how many people do
you think really care yet don't specify
it and just rely on the default yeah for
those guys they're going to have a
problem because we're switching the
default right and that's going to be g1
simple fix don't rely on the default you
know pass a parameter and tell it which
one you want but again some unified
login we don't expect this be a big
issue but if you were parsing the output
of the log again you may need to just go
on rework it we think it makes more
sense now and we also have something
called a jnlp parsing that was very
permissive if you didn't quite match the
spec we would try our best to guess what
you intended and we've discovered that
that's not a good thing to do because we
you know not always get it right and you
never correct a mistake if you you know
have this thing fixed for you so JLP
parsing now if you got something wrong
I'll just error out and tell you what do
you want me to do please provide the
right values and I'll work again
then there's how many deprecated API s
have been removed
we started deprecated which have a
one or two right about I don't know 17
18 years ago how many have we removed
none right so I apologize but that means
we've trained developers to think that
deprecated is just a warning generator
what more we we've abused deprecated
there were some swing classes that have
a show and hide option right to show up
format something and in Java we don't
like show unhide so we introduced a set
visible to visible falls and show on
hide where marked as deprecated not
because we ever plan to remove them or
because they were wrong but it's just
not as pretty as fiscal trample JDK nine
unduplicated that deprecation you know
so we pre kate's them okay so we've
deprecated a couple of applications
there's also some cases there's nothing
wrong with the API that's there you
shouldn't worry about it
but there's a better alternative so if
you're writing a new program you should
use the new one but if you've got some
old library that works fine it's okay to
continue using the deprecated one right
and there's a handful of other
deprecated stuff which is we're just
trying to get rid of it and we plan to
drop it in the next version so even if
it's in all stuff if you wanted to run
with the next version it'd be great if
you go ahead and remove it and before
gdk9 there was you could read in the
documentation
one by one but there was no programmatic
way of figuring out which one was which
we've added something called enhanced
deprecation which is an annotation where
we say yeah this one we plan to remove
in the next version there's a for
removal tool and since we all like to
there's a new tool called JD per scan
that you can run against your code and
they'll find all of the instance of
deprecated and if you pass it the right
flag they'll find the ones that are
deprecated with for removal equals true
so we were you know you guys are not
like the first people to complain about
some of these changes we also have to
deal with a lot of people within Oracle
that use the JDK and
unlike most of you they are forced to
test it and they're very vocal about
these things so they tell us things like
you know just having the compiler tell
you that's not enough I need to have a
tool that will work when I don't have
that source code when I'm not going to
compile what happens if I use a
third-party library right I don't have
the source code I don't know what
they're doing you guys do tell me so
there's a bunch of new tools that will
help you with this a bunch of things as
I said they're gone both of them we
don't think you know unsupported Apple
API you know they were Apple specific
how there's an equivalent version that's
platform-independent some GC
combinations that we're deprecated in
JDK 8 remember those warnings I was
mentioning yeah those are warnings on 8
they're going to be errors in 9 so if
you see those warnings do something
about them please and you know perm gen
and things like that
now I know nobody here ever would choose
to use an internal API and you are very
careful you know if you don't let anyone
in path however when we went a look at
all of those open source libraries we
discover anybody care to guess about
what percentage of them use internal API
is talking about non trivial code
anybody thinks
more than half more than half more than
80% how about a hundred percent we
couldn't find a single non-trivial
library that didn't use internal API as
I said in some cases it was for some
convenient thing it's not a big deal but
what we expect is unless you're writing
something really small and you're not
using log4j or spring or anything at
least you'll have to read to the next
version of those libraries so we've been
contacting them we've been telling them
hey please upgrade these with senior
source code and we expect that some of
them if not all will have a version
ready by the time JDK releases gdk9 and
we hope the others will catch up soon
after but in the meantime I keep
I mean people you are responsible for
choosing your libraries you inherit
whatever vices and virtues they have so
it's now on you to rest the library
likewise there's a few things that we
have deprecated in nine some of them we
may want to remove later there is a
screenshot of an early access
documentation page there has a whole
brocaded section you cannot really see
in here but there's a long list of
things that will remain during nine you
can use them but you should plan in
removing them for a later version okay
another thing that's important this is
not well there's a long laundry list of
things there applets anybody needs to
know why that is being deprecated yeah
some codex
Jar Jar that's grabbing the same jar and
running it through Jar twice which for
some bizarre reason what support it
won't be anymore
and other important changes and this is
not just nine by the way this happens
right now with six seven and eight
anybody heard about what happened with
md5 hashing function what's a great idea
it's no longer considered secure what's
the next one that's going that way shall
one thank you so what happens your
version you know you grab a version of
the JDK when you downloaded this thing
in 2011 sha-1 was you know consider safe
that was a default you went and you
signed a bunch of jars which I want this
is what's going to happen soon you're
going to have to resign that jar right
so this is one of the few cases in which
we go out of our way to tell you with as
much warning as possible of a change in
security you don't know what you know
creating these the internal brouhaha
that was to be able to publish this so
there is a page java.com slash crypto
roadmap where we tell you which
algorithms are going to be disabled in
what version in some cases we cannot say
anything because you know there's a
security vulnerability we'll just do it
and we'll
after the fact but for the ones that we
can we'll set it as far away into the
future as possible we'll give you
instructions if possible so that you can
configure your JRE to behave as it will
in the future that way you can test it
and see whether you're impacted and when
we do disable the algorithm or something
there are instructions in there for how
to turn it back on that is a really bad
idea it's no no good no good bad idea so
the only excuse on why you should do
that it's because you were you know you
were sleeping you didn't see any of this
you updated and now your choices are
downgrade the GRE even worse idea or
temporarily configure the JRE - for
example except mv5 while you go and
resign I've gotten a few questions from
groups about well we didn't sign in time
what should we do resign and I mean
either leave the company or sign your
jar either of those works for me
okay so prepare for the future now all
of these sounds a little scary
plenty of warning plenty of time we
currently have early access builds of
JDK 9 where all of these things that
we're telling you are already in place
so if you go to JDK 9 EA now here's the
trick by the way if you search for JDK 9
early access we've recently changed the
servers and as far as I can tell no
search engine has yet found the correct
one so as a stopgap you can go to the
main JDK download page there's a button
that says early access click on that one
that one has the updated links I'm sure
you know all the Google being they will
touch up eventually
you don't unpack all of those guys but
you can download JDK 9 now try all of
these we introduced knowing that one was
going to trip everybody up was the
hiding of the internal API there's a new
tool that's available in JDK 8 and of
course early access of 9 called jaidev's
Java dependencies you run it against
bytecode so I don't care
you don't have the source code you're
meant to run this against your whole
project even the libraries that you
download it from Vita and will tell you
which modules that particular class uses
there's an option that says I don't care
about the full verbose thing just tell
me about internal ones and they'll tell
you in advance yeah here are the ones
that are going to blow up if you try to
run this on jdk 9 so you can use it to
find the new ones or at least you'll
know which ones to re-enable using that
command that we mentioned about how to
turn it back on okay you know where my
preference lies find the correct one so
update your own code as I said stopgap
use the command line options to turn
these back on and in some cases you will
discover that your favorite library that
you download it back in you know 2001
it's no longer being maintained and it's
now a good time to go and find an
alternative library that that's
something better okay this is the
current page we have early access builds
that we update I think it's weekly if
not sent it's not every other week so
the build number is probably off by now
but you know when I took this screenshot
last week it was 167 we are done feature
wise so what we're doing now is bug
fixes so if you're the kind of person
that wait until it's stable enough
because you don't want things to break
you're good go get it now it's got a
little label say in Developer Preview
that means when bug fixing mode you're
in the sweet spot where it's not
changing so it's good to change to check
it but you still have a little bit of a
window so if you find a bug that's
important we might be able to fix it
please don't be the guy that files a
critical bug two days before the release
we've been there we don't like them you
know you create a lot of problem for us
give us a couple of months we'll be very
thankful for that
okay this is the output of jaidev's
the Java dependencies analysis tool
right as I said it's in the since GA
version 4 JDK 8 so you already have it I
forgot to us anybody here using anything
older than JDK 8
right I'm hoping your have plans to fix
that soon um yeah some people have good
reason but even if you're not using JDK
a you can still use de that's against
your code you know it's an external tool
it doesn't you don't have to recompile
anything so that's good run it I run it
here against our own PC updater the tool
that we give you to update the time
zones and you can see that yeah we use
some internal API and yeah this is the
JDK we have to use it online guys in
some cases we will tell you you're using
this API here is the recommended
alternative so if you're using base64
here's the official one in some cases
we'll say we have no idea what you
should use instead but just get out of
that ok if you look at the JDK 9 early
access 1 we have slightly better
recommendations but they will either the
JDK 8 or 9 will still find all of the
internal API and this is my screenshot
of that secret command well not secret
but here's what you do it you do ad
exports you say the module and which
package and who you want to expose that
to all unnamed is the automatic name
that all code that it's not module gets
so more likely not that's the one you're
going to get and you have to do these
not at the API level but at the package
level so you may have to have ass in
this case several instances and no we're
not going to make it any easier and yes
we could but that would be missing the
point
ok as I said we have a new development
paradigm we're going to switch to try to
get to a faster release model
I'll let George cover that in a minute
we're trying to adapt a lot of new
changes that we've been holding back on
so here's some additional pools to adopt
to the new paradigm right ahead of time
compilation I think I have a different
slide on this one because yeah I forgot
about the party on this one
as you know Java interpreter interprets
your code and it compiles it while it's
running optimized for that particular
machine so we figure we do that for you
and give you an optional step
so we now with JDK 9 offer the
alternative of instead of you having to
compile every single time you can
compile ahead of time pretty sure had a
little pro tip here at the bottom which
is there's a reason why we don't
pre-compile something for example the
JDK and put it out there the reason is
because you should really use these on a
system that's as close as possible to
the one that matches your production
environment because this thing optimizes
for your environment right the JDK will
produce different bytecode if you're
running on a crappy machine with one
core and a lot you know very little
memory then if you have a monster
machine with multicores and another
memory so do not be as foolish as to
think that you can ahead of time compile
it in one machine and then give it to
everybody that's why this is a tool that
comes with the JDK you're supposed to
run it on your production machine or as
close as possible ok for now we support
ahead of time compile a database module
and experimentally everything else ok so
another point that we've heard is yeah
that's a cool new API but I want my jar
file to work as well with older versions
so that means that I cannot use this new
API so I can use lambda because somebody
may be running it on seven and you know
I don't want to have a JDK for seven and
a JDK for eight so since we want to
avoid that we've created the option of a
multi-week jar file in this example over
here if you run this jar against JDK 8
or lower these are the classes ABCD
however if you run it on jdk 9 instead
of these a class use this a class which
will use some api that's only available
in nine and instead of this B class here
is a more efficient way using api that
are only available in nine you still
have to maintain the code for nine and
eight but now you can just package it in
a single thing and give it to somebody
and it will do the right thing the ten
which environment it's running on I told
you I had CI copied the slide and that
was a pro team so I've already covered
this and the property use it on your
production machine not on the
development one okay another thing that
has changed we went from one Giri to
rule them all to a customized runtime we
did this forum bit not we so tell the
planet the point is we started these
with the use case which was embedded
devices right where you have a machine
that's not as capable and we figured
well do you really need a full JRE if
you're only trying to run a very small
application right the JRE has a bunch of
libraries to your point it has corba it
has login it has you know a large number
of you know desktop modules what if I
don't need any of that why do I have to
ship with it and the paradigm has shift
right back when this was decided the
idea was you're going to have one Giri
in your system and it's going to run
every java application so therefore you
needed that Giri to be complete to have
everything because even though you may
want to run just a HelloWorld somebody
else is going to try to run some very
different java application and the Giri
must be able to take it right and this
was to minimize download size remember
when you have to dial up and think took
forever for download you don't want to
have multiple GRE for that 300 megabytes
that was gigantic right you don't want
to have multiple instances of that on
your system and serious applications
require one large app container and you
know you set that up and everything runs
against that now we're better off
minimizing into dependencies each
application can have its own custom done
time and I have in my phone 600
megabytes of games and to hunt 20
gigabytes of media right so 200 that's
nothing and you require hundreds of
thousands of instances so these are the
JDK modules
blue ones at the Java specification
green ones are some JDK black ones are
I'm sorry
JavaFX black ones are JDK there's one
incubator module which is a special
module which means this one is not part
of the specification we're still working
on it go ahead and try it but don't
build production systems on it because
it's not going to be there in the next
version it's going to change right we
want feedback my example I just reset
the Java C modules and their own
dependencies imagine that I write an
application and I decide of these I need
API let's say I want sequel rosette and
Java activation right since those
modules depend on all the modules I
could create my little graph and see
that's what my application needs so
rather than having a full JRE which is I
don't know couple hundred megabyte how
about I create a custom runtime and by
the way let's include my application in
that runtime no need to put it as a
separate jar it's just another module
the whole thing now it's at 40 megabytes
so I can since I'm not sharing the GRE
this is notice that the title has
changed I'm going to rollback Java C
modules this is no longer a Java is here
under this is a custom random for your
application it can only run applications
that rely on that so this is what you
can do now with j-link and jdk 9 we
think this will make a lot of sense when
you are trying to create an application
in a container that it's self-contained
and I'm going to give it back leave the
mic back to George see we can come back
for questions thanks
okay so Aurelio's already started sort
of hinting towards a direction that
we're going I think it is important to
remember that even with the benefits
that the module system brings you in
nine we look at that it's not you know
just the end of a mini many year process
I think we started gosh to a totally
2008 earlier yeah so so that's that's
been running for quite a long time
but we also think that this is really
the start of something new because I
think what's going to happen here is the
facilities that the module system
provides are going to make it you know
even easier for people in the ecosystem
to create and maintain libraries over
time and and so I think that's clearly
something that's you know being a
strength for Java over the years and and
this will just make that even even
easier for people that along with things
like multi release jars and that sort of
thing and in terms of you know what you
see when you download the version now
and you try out these tools you try out
the module system you try out J link is
really sort of the starting point the
things aralia was talking about with
experiments in äôt and and footprint
reduction and that sort of thing we're
going to be able to do a lot of things
over the coming versions that continue
down the path of making improvements to
that what we've really done a nine is
sort of shown that that sort of thing is
possible and tried to make it good it's
sort of like with with lambdas when we
introduced them in eight our goal was
really to try to make sure that the
performance solves lambdas and streams
were basically as good as or slightly
better than the equivalent if you you
know use the old way of doing things you
know with another center of classes and
fun stuff like that but basically you
know we knew that there's sort of a
continuing roadmap of things that we can
do to make the performance there even
better over time and we certainly intend
to do that in terms of other things that
are coming you know I get a lot of
people starting to ask me now well you
know what's what's going to happen after
nine
and you know you can kind of look at
this you'll notice there are no dates on
this but this is just to give you an
idea of sort of what the release model
looked like right which is a period
where we're doing development and early
access builds a period where there's
sort of free publicly available bills
and then sort of a long tail of support
that exists
you know usually commercial support from
us and from other vendors and and so you
know that's quite a long period of time
and as you can see there's a lot of
stuff that's being maintained at the
same time now on one hand that's very
good it means that there's sort of
stability and predictability well except
there isn't always predictability and
one of the reasons is that in the past
for Java Fe there's always been this
mode of tying a big driving major
feature to a release even before you
started the release and so we all know
now in 2017 as software developers that
that's really not such a great idea
that's kind of a recipe for you know
things being delayed or other things
happening and indeed we've seen that
with with major releases over the year
over the years and so you know what we
are hoping to do is get to a point where
instead of releasing major functionality
on a very very long schedule we actually
have regular releases that come out far
more often and then we work on features
in projects in open JDK until we're done
and when they're done they go in right
but none actually means not we're going
to put it in and then it's going to have
two years about fixing right it's like
it's already fixed we know that the
quality is good etcetera etc and so you
know that's sort of a different mode of
working now to be fair we have actually
had that mode of working for the update
releases right so basically when you saw
an gray leo showed the version string
before 8:28 you 40 80 60 you know these
are releases that were essentially minor
update releases but had functionality
improvements in them right and what
we're talking about doing now is the
same thing except not only having minor
minor release changes that is to say
implementation improvements but also
introducing
new things in the language new api's and
more substantial changes in the vm and
so basically what that will allow us to
do I think is go to a model that is far
tighter and then ultimately I think what
we've seen in in a lot of programming
communities that have gone to this model
is that you know rather than doing
support for every every one of these
there's typically some kind of long-term
support type of model right where every
few releases there's something that's
designated is a long-term support branch
so anyway I do want to kind of get clear
that you know this is something that
we're considering right now there's a
bunch of discussion in OpenJDK amongst
people who are collaborating there about
that we're very committed to the
stability and quality of Java and
keeping that high and you're not
something that all of our all of our
users value tremendously so you know
what we want to do is make sure that if
we're going to a more rapid delivery
model we're you know doing it in a way
that's going to be able to help let us
keep those core principles strong and we
really think that this shift with nine
and with modules is a very key part of
being able to get there right because
basically by reducing the security
attack area by you know reducing the
compatibility surface area and making it
possible to evolve the internal
implementation because you know it's far
less likely that code out there is going
to be depending on it that will let us
get to a point where we can actually
validate the changes that we're making
are not going to break you and your
applications and libraries that you're
using okay so you know basically I hope
that you you know this is giving you a
little bit of insight into how we think
about this some of the kind of balancing
that we do all the time with all the
decisions that we make you know trying
to continue to revolve Java and you know
bring you new functionality and bring it
to you in a timely fashion not make you
have to wait you know another two years
for the next major release including
major functionality but also smaller
things you know we'd like to get as in
your hands
and we hope to have a great experience
with nine as aralia said eight is going
to be around for a long time so if you
find when you start easy things with
nine that it's a bit challenging don't
stress out about it you can continue
using eight but look at nine as you know
what's coming
how can I take advantage of what's there
so that is it for talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>