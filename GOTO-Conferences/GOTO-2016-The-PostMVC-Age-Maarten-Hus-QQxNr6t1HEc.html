<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • The Post-MVC Age • Maarten Hus | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • The Post-MVC Age • Maarten Hus - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • The Post-MVC Age • Maarten Hus</b></h2><h5 class="post__date">2016-09-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QQxNr6t1HEc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">event listeners that's the polymer way
to do it so that was a google max
component but let's look at the
copolymers a little bit more abstractly
to see what the characteristics behind
those components are and the first
characteristic is that a component is
isolated this means that you can put
multiple components multiple instances
of the same component on the same screen
without them interfering with each other
so indicate in the example we saw before
we had for Google Maps components and
they could be controlled separately
without them interfering with each other
another characteristic is that a
component has very clear input and
output semantics and that means that the
only way to manipulate a component is
via the inputs that it that it provided
for you and the only way a component can
manipulate the outside world is through
very clearly defined output semantics so
in this case the inputs are the
longitude latitude and the output was
the event listener that we added another
characteristic is that a component is
declarative so we just all saw this
Google Map component in action and it
was very declarative it was very easy to
but just by looking at the code to
figure out what the component was
actually doing and the final
characteristic is that a component is
composable and what I mean by that is
that you could take multiple smaller
components for example a button
component and an input component
combine them to create a search
component so we can use components as
Lego blocks to define components in
terms of other components and it's a
very powerful mechanism and all of these
characteristics they make components
very easy to reason about because a
component is isolated when you see it on
a page somewhere you know what that
component is going to do ever you see it
in the code somewhere you're pretty sure
what the component is going to do and
because a component has very clear input
and output semantics like ei it doesn't
have to manipulate the outside world
it's very easy to understand its place
in your application so to conclude
components are pretty awesome but what
we just saw was a component in isolation
so now the question is how do we build
apps using only components so to
demonstrate that I've created a very
simple to do application in angular 2.0
and everyone probably knows how this how
this works you can order to do that
cross them off and at the bottom there's
a footer and there you can toggle
between the components State to do state
that you want to see for example if you
press active you only see the components
you need to do and where you click
completed you only see the to do so
you've already done so like I said this
application was built in angular 2.0 and
it was built from the following
components and I've represented this as
a tree that's that's the funny thing
about a component based application that
it is actually a tree just like normal
Dom elements would be on a page they are
also trees so what we see here at the
very top is the to-do application and
that's the so-called root component it's
either directly or indirectly the
grandparent of all other components and
this is an example of the composability
so this entire application is basically
one single app component and on the
right here we see this to-do list
component which has an N number of
deduce which are
on the screen and we also have an ad to
do component which is basically an input
element where you click enter on it it
will add a new to do and we also have a
toggle all component and when you click
that you instantly check off all your to
Deus and on the Left we have the filters
component which represents the footer
which has three filter components all
active and completed but if you take a
look at this tree or any tree which
represents a component based application
you might have the following questions
or at least I did and the first question
you might have is where does the state
live in this application and by state I
mean where are all the to-do stores
where is stored which filter is
currently active and the second question
you might have is how do these
components communicate with each other
how do they do that and to make that a
little bit more concrete for this to do
up in the example we could ask the first
question this way instead of saying
where does the state live where do we
put the current active filter so if we
take a look at our tree we could say
let's put the current active filter in
the filters component because that's the
place they all have in common that's is
they have the same parent in common but
then you realize that the active filter
is used inside to do lists and in that
component it is determined which filter
to apply but then you might argue to put
the thing in the to do application root
component because that's the common
parent over of these two components so
what I did I put it in the to do
application all the way at the top but
the answer is not very clear so you can
make the case for each of those three
components and it would probably be a
valid case so this is not a very
satisfying answer I know that but later
on in my presentation I'll show you a
way to make this question a little bit
easier to answer but for now it's not
always very clear where the state should
live inside of the application tree
so that brings us to the second question
how do components communicate and we can
ask that by asking ourselves how do
filters change and like I said I chose
to put the filter all the way at the top
in a to-do application so when you click
on complete a tall or active in some way
I need to communicate that all the way
to the top because that's where the data
is stored so what I need to do is I need
to link the completely this click send
it to its parent and when Filters has it
it needs to send it up one level to do
application so the thing is is that a
component cannot communicate to another
component which is not directly related
to it so you can only go from the child
to the parent from the parent to the
child so that means that communication
is a little bit of a hassle because the
more distance there is between the
component in which you want to
communicate with for example here we
want to communicate from the blue
component all the way to the red
component you can see that we first need
to go all the way to the top and then
all the way to the right so basically
these two questions highlights two
weaknesses of this architecture so it's
not always clear where the state goes
and communication between components
that are not directly related to each
other that's a little bit of asshole so
now we have seen components and we have
seen two weaknesses so now it's time to
look at a way to mitigate those
weaknesses and in this case that means
taking a look at Redux so what is Redux
well Redux is a library created by a guy
called M Abramoff and it's the most
popular implementation of the
architecture called flux so what is this
flux thing well flux was invented at
Facebook and it's a way to do
unidirectional data
and Fluxus is more of an idea and Redux
is an implementation of that idea and
since it's the most popular one I've
chosen to focus more on Redux instead so
what is the idea behind flux and redux
well the idea is that we still have our
componentry but we are going to put
another concept next to the tree and
that concept is called
the store and what the store does is it
provides all the state to the
componentry so we no longer store our
state in components we store every bit
of state of this application in one
single variable in the store and
whenever an action occurs for example we
oughta need to do we check it to do or
we do go all to deuce or check on a
filter an action is sent to the store
and that manipulates the store and then
we send the state to the componentry
again so if we look at it slightly
differently like this you can see where
the unit directionality comes from so
the store provides the state to the
componentry
the componentry fires actions the
actions manipulate the soar and this
will go around and route in a single
loop but always in one direction that's
why it's unidirectional so Redux and
flux they give us two very nice answers
to our two questions so the two answers
are that all state simply lives in the
store so we no longer have to worry
about where in our component we restore
state and the second is that all events
route or are events route to the store
so we no longer need to communicate
between two components directly we
simply send all events to the store
where the state is manipulated so this
was highly theoretical so what I want to
do is make it a little bit more
practical by looking at some actual
Reducto so I want to do another case
study this sum of a very simple
application that the counter application
there's two buttons minus and plus and
the number in between them when you
click plus the number increases when you
click minus the number decreases there
simple so in redux it's a it's common to
define all of your actions as schools
definitions so what we see here we have
two actions increment counter and
decrement counter and then we have these
two functions increment counter and
decrement counter and these are what
reduct calls action creator functions
they create actions that we can send to
the store and an action is always an
object which has a type property and the
type property identifies the action so
in this case whenever we call the
increment counter function we get a
simple object back saying which type of
action it is so now that we have defined
our actions we can take the next step
and we can see how we can create a store
so what we do first is we set the
initial count to zero the counter starts
counting at zero and then we do a little
bit of reduction magic we say Redux
create store and there's a second
argument it takes our initial count and
as the first argument it takes this
counter app function so what is this
counter function well that's called a
reducer and the reducer is a function
which takes the old state and an action
to apply to that state and there are a
couple of rules with the reducer the
first rule is that a reducer must be
pure so that means that we can never
manipulate the old state directly we
always need to create a new copy and the
second rule is that whenever you account
to an action that you don't know you
simply return the state so an in the
reducer we handle our two action types
increment counter and decrement counter
so whenever we encounter increment we
simply add one when we encounter
decrement we decrease it by one so for
example if our counter app has a state
of five and we send the increment action
it will be 5 plus 1 so 6 will be the new
state and this is a very simple
reduction occation reduction so
framework agnostic so you can use redux
both reacts or angular or any other type
of framework but it's more geared toward
react to be honest so this was a very
very simple application where the state
was a integer that's not very fun so I
want to make it a little bit more
complex this time by adding the
possibility of dynamically adding
counters and dynamically removing them
so the code doesn't say it all in one
slide so what I did is for each action
that there is I created the separate
slide so I want to do the remove counter
first but let's take a look at the
initial State so this time it's not a
number it's an object and this object
has two properties an X counter ID which
you can kind of think of as an auto
increment ID on an SQL table it's meant
to increase each time a new counter is
added so we have unique E and the second
property is called counters which is a
key tell you pair in which the key is
the ID of the counter which points to
the counter object and in this case we
have a single counter object which
starts at 42 so then we see the remove
counter action creator but this one is a
little different this one takes an
argument the counter and that's the
counter that we want to remove so
basically when you have these actions
you always have a tie property but you
can add as many other properties as you
need for your action and in this case
it's just the counter and then somewhere
inside the reducer we have to remove
counter and there I do this little trick
with object assign to create a copy of
the current state because remember we
cannot manipulate the existing state and
then we simply take the counter from the
action and we delete the key in the key
value pair map and then we return the
state and then we have removed the
counter so in this case if we call
remove counter with 1 then the count 42
will be removed then then we have to
a counter and it does not have a
parameter because we don't know which
counter we are going to create
beforehand and in the reducer again we
create a copy and then we increment that
next counter ID manually so that the
next time we also have unique ID and
then we simply take that previous ID and
assign it to a new counter object which
starts counting at zero and it also
knows which counter it is because it has
the counter keep stored in it then we
have increment counter which you also
need to give a counter ID in the action
creator so we can identify which counter
we need to increase again we copy the
state and we pluck the counter from the
from the initial state and we increment
it by one decrement is much the same
except it decrements the count by one so
what we see here is an example of a more
complex products application and as you
can see it's customary to put your
state's in these objects in this case
initial state and for those of you who
think well that if we have many actions
this switch statement will get really
really huge and that's true but
fortunately we can create multiple
reducers for the same application so we
can split it up based on the domain
entity that we are going to manipulate
so don't worry about that
so the benefits of Redux is having a
very clear answer where to put the
states and how to communicate with
components but there are also a couple
of other benefits and the first benefit
is that Redux makes
universal JavaScript easier Universal
JavaScript is is the art of rendering
your application on an ODS server and
sending that back to the browser which
has CEO benefits and makes it makes your
application render faster and the reason
why it's easier in redux is because all
of your states is located inside of a
single variable so you only need to set
that variable once and then give that to
your component tree
and then you get your UI and you could
send it back to the browser so if we
couldn't trust that with having States
located in multiple separate components
we will have to do a lot of work just to
get those components and assigned the
state correctly so you have to write a
lot more boilerplate code so that's the
first benefit the second benefit is that
Redux has a surprisingly good developer
experience sorry
so gifts say more than a thousand words
so what we see here is a another counter
example but this time with the
development tools displayed on the right
so what we see here is that each time
that we perform an action we see on the
right and the black bar we see that
action occur that we can even click on
those actions to pretend that they never
happened so that's really cool but you
could also do is you can commit States
and you can also load external States
from JSON so if your customer says hey I
found a bug in your application you
could ask them to send the current state
and you can load it in your local
development environment and see exactly
what they saw so that's pretty neat
nothing is perfect however and Redux is
no different so there are a couple of
downsides to Redux and the first one is
that it has a slight learning curve you
have to learn about reducers pure
functions immutability thunks ah gasp
it's a very it's not that difficult to
learn but there is a slight learning
curve the second cone is a little bit
more insidious and that has to do that
javascript is not immutable by nature so
javascript allows you to change
variables so if you by accident do
something in your reducer that
accidentally changes the state then your
whole application will fall down like a
house of cards because redux does not
accept you mutating the state so you
have to be really disciplined when
writing your reducers to make sure that
you don't accidentally manipulate state
luckily there are libraries this one is
immutable yes also by facebook which
gives you an immutable collections
library so in this case we have this map
and list
they represent objects and erase and
whenever you perform an action on map
oral or on list you always get a new
copy and you never modify the existing
object so you can use immutable yes to
mitigate this weakness a little bit but
again using this library you create a
little over at and if you have to
communicate with some third-party
library which expects normal objects
then you will have to do some plumbing
to give those third-party libraries
normal objects instead of immutable Maps
or beautiful lists so that was redux
which gave us two nice ways to mitigate
the two weaknesses of the component
library and now it's time to take a look
at reactive programming and reactive
programming you can use to supercharge
your components asynchronous event
handling it's really powerful for that
so what is this reactive programming
thing defining reactive programming it's
often easiest to look at what we call
normal programming first and in the
reactive community they call it passive
programming and what passive programming
is is that when you have two components
one component is in charge of another
component so in this case we have a car
and we have an engine and the engine
starts whenever the car key is turned so
in a sense the engine component is not
in control of its own destiny it always
gets stalled when to start and in code
you can see it like this so the car
object has an engine property and it
fires up the engine whenever the key is
turned so reactive programming in vs.
this relationship so in reactive program
the engine knows when it fires up and
the car does not know that it
manipulates the engine and in this case
it does Sophia callback mechanism so
whenever the car only turned event is
triggered the engine fires itself up and
this maps really nicely to our component
to the benefits of components because if
you write your component reactively your
component is in control of its own
destiny and you can really easily
understand how you component reacts just
by looking at the component source
because it will tell you in its source
when it gets triggered manipulated or
does some action so callbacks are a very
poor mechanism they are relatively
low-level so there are libraries out
there such as rxjs which soup up this
disk all that mechanism to make it more
powerful
so rxjs comes from a library of families
called reactive X and what reactive X is
is kind of like a protocol description
so it's a big it's a big description of
all of these kinds of operations and
functions and methods and then what they
did is they created multiple
implementations in multiple different
languages so there's a c-sharp Rx is
there's a for m1 for JavaScript one for
Scala one for Java etc etc so just by
learning one set of operations and rules
you can port that knowledge to various
other languages so what are the the the
main concepts behind our SAS the first
concept isn't observable and that is
something you can listen to that could
be anything
keyboard clicks Mouse events Ajax
requests coming in WebSockets sending
data over the line anything you can
listen to you can turn into an
observable in rx a yes at the second
concept is that of operations and up
raishin allows you to manipulate your
observables so you can basically perform
an operation unobservable
and get a new observable out so to
demonstrate how operate operations and
observables work I've created this
pseudocode example and what you see here
on this slide is an observable called a
which is an array of strings numbers so
the numbers 1 to 10 in string form so we
can do operations on that stream on that
observable for example to number and
what to number thus it simply takes the
string number and turns it into an
integer number
but the reactive part is is that
whenever observable a changes so for
example if we add the string number two
at the end observed will be will also
get updated and we'll get the number two
appended at the end so it reacts to
changes on observable a so we can do
more operations we can for example do an
even operation which filters that the
set to only include
the even numbers and again it's reactive
so if a changes B will get updated if B
gets updated C will get updated and we
can do one final operation called
aggregate which counts up the even
numbers in this case so what I think is
the beauty of reactive programming is
that you can define D you know that it
will get updated whenever its inputs
change you don't have to do that
manually yourself anymore
so that's pretty powerful so to run on
down through completely if we are the
string number two at the a observable B
we'll get the number to append at the
end then C will also get the number two
because it's an even number and then the
aggregate will be 32 so it's very
powerful stuff so now I want to move
from the pseudo code into the real real
rx
and what I want to do is I want to take
another do another case study and this
time look at an autocomplete example so
everyone knows without the complete does
you type in a query in a search box it
sends it to the back end and the back
end will provide you with suggestions so
in this case we search for American and
it will give you some shows that start
with American the autocomplete is a
surprisingly difficult thing to get
completely right so what I want to do
first is I want to show you guys an
imperfect example of a autocomplete and
then I want to improve it bit by bit
using rxjs so here's the code the first
thing we need to do is we need to get a
reference to an input element in this
case the element of which you can do
your query in and then we do some RSA
yes magic we create an observable for
each time the input element as a key up
event so whenever the user starts typing
in something the observable will fire
and we get events but the events that we
get are JavaScript events which will
tell you which key is active if the
shift key was pressed and which key code
was entered but we're not really
interested in that so we perform a map
operation to get the value of the target
which is the actual contents of the
input element that we currently have
when the event was fired and then we do
another map operation and map is that is
exactly the same as the es5 map
operation we have on erase it performs a
function on on an input so in this case
what we're going to do is we're going to
take that query and we're going to give
it to this search function which does an
ajax request to the back end and the
back end will gives us hopefully some
other completion results and then at the
bottom we see this SUBSCRIBE function
and subscribe you can kind of view as
the endpoint of an observable so
whenever something changes we are we are
we are subscribed
we get we go into the that subscribe
operator and the subscribe operator has
to function functions as arguments the
first function is for whenever something
went well for when a successful thing
happened in this case when the backend
provided us with other completed results
and we also have as a second fire
function the error which gets called
whenever an error occurred so for
example if the backend was unavailable
or could not provide us with results and
whenever we get a successful out to
completion we update the UI and whenever
it goes wrong we just ignore it because
that was what we do with errors and
subscribe' should remind you of promises
so a promise in JavaScript can only be
resolved once but an observable can be
resolved many times so sometimes in on
the web you will see that they call
observables promises plus plus because
they have a little bit of extra
functionality on top of promises and
it's also very easy in rxjs
to create an observable from a promise
there are functions for that but like I
said this example is imperfect there are
a couple of things that go wrong if you
put this code in production and the
first thing is this guy so very slow
yeah so what you see here is there is
the time and and some queries that we
send to the backend but what I want to
illustrate is that each time you type in
a query in this case I love go to we
send all permutations of that query to
the backend so what we basically created
is a very convenient way to spam your
own server so basically what we want to
do is we want to say only send the query
to the back end if the user has stopped
typing for a little while that's what we
want to do so there's an operator for
that that operator is called debounce
and what you see here on this screen is
what Rx is and the reactive fix family
of frameworks call a marble diagram so
what a marvel diagram shows you is a is
an input stream the operation in the
middle this case debounce
and what the resulting stream would be
if that operation was applied so in this
case the top stream has one two three
four five and six s events but two three
four and five are really close together
so what the resulting stream will do is
it will filter out two three and four
and it will only keep five so we can use
this operator for our example to limit
amount of queries that we sent by simply
adding this debounce operator and then
we say 500 that means if the user stops
idle for half a second then we send it
to the back end and this way we prevent
us from spamming our server but we're
not there yet there's still another
thing is that if your query has very few
characters you often get a lot of
results which are not really relevant
for that user so in this case we only
get good results if our query is bigger
than three characters long so what we
want to do is if the query is less than
that we just want to ignore those
queries and there's an operator for that
as well this one is called filter and
what filter does is it takes a predicate
function and the predicate function is a
function which must return to a false
based on an input and in this case it
will if the X is bigger than 10 it will
allow them in so that's why you can see
that the numbers that are lower than 10
are simply ignored so we can use that in
our example by simply calling filter
before we do the debounce
and we take the query that we just say
only allow them in if the query length
is bigger than 3 so now we've solved
that problem but of course we're not out
of the woods yet there's another problem
still and that is that sometimes we send
the same query twice in a row and this
can happen if the user presses the enter
key so what we see now is that there was
a five-second window between the first
go to and the second go to query and we
all know that we probably don't have new
results within a five-second window so
what we want to do is we only want the
query
if the query is actually changed from
before and there's an operator for that
as well this one is called distinct
until changed and what it does is it it
will only allow an event through if it's
different from the one before and this
is something we haven't seen before is
what we see here is an operator which
has an internal state this operator
keeps track of the previous entry that
was made to it so you can have operators
that have state so that's pretty
powerful and as you can see in the
resulting stream we only have
alternating values so we apply this
operator this thing don't they'll
changed and now we only send query if
the query has actually changed so now we
have we were almost finished we have one
big problem still left to resolve and
that problem is is rather devious and
that's this one so here we see a time
line and we see two queries so the user
search for go to rotterdam quickly
realised that the go-to is not in
rotterdam but in amsterdam so we changed
this query to go to amsterdam but now we
have two asynchronous requests in the
air at the same time and if your server
is having an off-day
the result for go to amsterdam might be
might get resolved first before the
results of go to rotterdam so what you
see is something very strange is you and
your in your query box you see go to
Amsterdam what you see the results for
go to Rotterdam and your autocomplete
which is very weird and not something
that we want to have so what we want to
do is we want to express the idea of
only using the results of the last Ajax
request that was sent to the backend so
as you probably guessed by now there's
an operator for that as a very strange
name it's called flat map latest don't
ask me why but it does exactly what I
just described so if you have multiple
asynchronous requests it will only use
the results of the last request that was
made so that bug that we just saw is no
longer an issue
so this is the completed example and as
you might notice it's relatively small
it has a few lines of codes but it does
a lot of work and that's the power of
rxjs by using these standard operations
and combining them in clever ways you
get a really powerful mechanism and if
I'm absolutely honest if I had to write
this without rxjs in pure JavaScript my
code would probably 500 lines Wow and
there will be probably a lot of bugs in
in that code as well so by standing on
the shoulders of giants in this case Raj
yes you can leverage them to accomplish
great things in relatively few lines of
code but there also there are some other
benefits of rxjs and the first benefit
is that the producer and the consumer
are decoupled so what I mean by that is
that the producer in this case was the
key up event that fired the initial
event and the consumer was to subscribe
and as long as the subscribe got its
array of auto completions it was happy
so it didn't care how many operations we
put in between there we did not have to
change the consumer or the producer we
didn't have to change that code so
that's very powerful and of course the
other benefit that I already explained
it a little is that operations are a
very very powerful building block so you
can combine them in multiple interesting
ways
again like Lego blocks and you can get
really powerful results but there is
really big drawback to rzs and that is
that it has a very very steep learning
curve and I don't like to call it a
learning curve I like to call it a
learning cliff because this black one
that's kind of my experience with rzs
and that's because you really have to
let go of your imperative model because
you were so used to always manipulating
variables and not thinking in streams
that it takes a little while before that
that clicks in your head but once it
does it's very rewarding because you see
a lot of problems that you would
previews the solve it with imperative
programming that you can now
with observables in a cleaner cleaner
way so it's definitely worth looking at
it and as you saw from the autocomplete
example it's it's really really powerful
the second comb is that the
documentation is very highly conceptual
and what I mean by that is that
sometimes the documentation reads like
someone's thesis project it's it's
really very yeah I an abstract so in
this case returns an observable sequence
that contains only distinct continuous
elements according to the key selector
and comparer so what's the key selector
what's the compare continuous elements
so does anyone have a clue what this
operator is the description for this
operate yeah exactly
this is the single till changed so
sometimes when I when I'm trying to
program in rx a yes and I encountered
this documentation I'm like oh this is
not the one I need and then later on I
find something on Stack Overflow then it
turns out I have the right one all along
but this documentation doesn't help the
documentation is also very it shows you
very non practical examples so we will
always be like an array of 1 to 10 and
then applies the operation on that so
it's not always practical so what I wish
that they would do is that they would
use more practical examples in in the
documentation so that was reactive
programming a nice tool to supercharge
your asynchronous events and that brings
me now we're almost at the end of the
presentation but it's customary for a
presenter to give you guys some
recommendations on how to use these
technologies and my first recommendation
might be a little counterintuitive but I
don't recommend using Redux or rsjs
if your app is really really small
because you add a lot of overheads and
that might not be worth it so for the
to-do application for the counter
application using our SaaS or redux it's
really really an overkill but if your
application starts to feel too big and I
know this is a little wishy-washy
feeling thing but you know when you get
there so suddenly you will have this
application and all of the sudden it
won't fit in your head you
don't know where the state should be a
new team members don't understand where
our thing goes then it might be a good
time to start using Redux like I said it
has a small learning curve but it's
small enough so you can on board new
team members
relatively quickly so that's my second
recommendation if it starts feeling too
big just use Redux it's a nice way to
store your state my third recommendation
is that when you have events that
require a lot of coordination like we
saw on the outer complete example you
want to do some higher-level things with
asynchronous events you want to
supercharge a component then it might be
time to swallow the red pill and start
using rxjs but like I said it has a very
steep learning curve so do expect some
onboarding problems with newer
developers because you have to take some
time to explain how it works and how to
use rx a yes so I just gave you like a
50-minute each presentation on reduction
reactive programming and I barely
scratched the surface so it's it's not
enough to know redux or RCS so what I
want to do is I want to write a series
of blog post to fleshing out these
topics a little more provide you guys
with some videos with blog posts to show
you guys how to learn with ducts and
react to fix the funny thing about both
Redux and reactive fix they're all our
videos available the maker of Redux has
its own course on a kadai oh it's free
you can follow that and you will explain
how to build Redux and how to use redux
so it's it's very cool so people I on
don't panic that 42,000 elf or for that
series and I will start sending them out
weekly starting this Thursday so that's
almost it we also have a stand
downstairs where you can play fallout
base terminal hacking minigame you can
win a grand prize a big rubber duck and
I'm also there at the stand so if you
want to talk to me about redux or rxjs
or reactive programming come find me
so that's it don't forget to vote for
the session and any other session that
you attend thank you
yeah so so there's a question if the
state gets really really really big what
does the performance do with Redux well
it will degrade of course because you
cannot keep infinitely a number of
things in memory but if you use
pagination or you only put in the store
what you currently need then you can
mitigate that it's it's regular
JavaScript so you can't keep putting in
memory and of course it will lose a
little bit of performance okay memory
leaks in redux I don't think it's that's
something you can easily do it because
the reduc says there's one reduc store
per application so it doesn't it's not
prone to leaking because there's only
one store and that store will just need
to be removed when the user closes its
tab so in that way memory leaks are not
that much of a problem in in redux
because there's just one store and it
will get cleaned up when you close the
tab so yeah so so to give you guys a
little bit background so
model-view-controller versus the
component architecture so I did not even
T the component architecture
I was really hit in the face with it so
we are angry we are an angular shop at
42 angular 1.0 and in angular 2.0 they
went to this new architecture so but the
thing is that the trend has been going
for a little while so react was the
first one to embrace the component
architecture an angular followed suit
and polymer came along so a lot of
frameworks are moving towards components
so I think that if you upgrade to
angular 2 you almost you don't have a
choice you will go to the component
architecture but the difference between
a component and mobile view controller
it's just that the inner component it's
basically the combination of a view and
a controller in one single thing but
that the difference is it that it it
does not try to take them separately so
a mobile view controller there's often a
lot of talk about
having multiple controllers for the same
view and having multiple views for the
same controller and we all know that
that's secretly not true I've never
written a controller for multiple views
or add the view for one single
controller so really the components are
basically a way of saying we acknowledge
the fact that they are married to each
other so let's not pretend anymore that
there are two separate entities so it's
not too much of a stretch to migrate and
in angular 2 there are upgrade guides on
how to do</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>