<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • From Macro To Micro • Sam Newman | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • From Macro To Micro • Sam Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • From Macro To Micro • Sam Newman</b></h2><h5 class="post__date">2015-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2ofzdPXeQ6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is sam newman I hope
hopefully share with you today are some
lessons that I've sort of extrapolated
from work I've been doing with thought
works over the last 10 years and my
colleagues have done really in the art
of taking the big and making it smaller
and here specifically we're talking
about how do I take a big service and
make it a smaller service a set of
smaller services talking about why we
might do that some of the benefits
hopefully you're going to come out of
this with some real practical
understanding about why we gained why
you'd want to do this we'll also talk
about a topic called micro services that
many of you may have heard about some of
you may be coming to my tutorial that
I'm doing with James Lewis on Thursday
all about this subject are just in case
you're worried only some of this content
will be on the Thursday night whole lot
of other stuff coming up as I said I
work for thought works I'm actually also
on the technology advisory board for
thought works which we and we put out
this thing called the technology radar
it's freely available comes out every
six months we mostly write it to share
our own experiences of different
technology in different techniques and
we typically completely miss the point
of what's going to be controversial so
ah you know saying that maven is
horrible system I she was common sense
but apparently a lot of people got angry
about it if you want to debate the
relative merits of things on the tech
radar come find me afterwards but as i
said i am here today to talk about big
things and basically how do you go from
the very big too well the smaller there
are lots of reasons actually why you
might choose to break apart systems a
lot of them come down to the inner T's
durability often you can achieve
different types of durability for your
system by breaking it up into smaller
parts maybe only some parts of your
system need highly durable services it's
more feasible to make that service more
durable if you only isolate those
features sets you care about you can
split it apart and treat those concerned
separately technology is a good one if
you were here earlier you saw her Neil
Ford wasn't really paying attention but
I think he was saying something along
the lines
you should sneak in new languages
wherever you can this is a very good way
to do that if you break apart your your
big monolithic service or system into
smaller parts you actually create space
where you can experiment with new
technology you can actually take a
component that might represent a smaller
risk to your business and say well
that's where we're going to try the new
language or the new framework
geographies a good one I'm here my
customers are over there maybe I should
distribute my system such that some of
my services are closer to my clients
team structure and organization is a
really important one here how many of
you here have heard of Conway's law ah
ok so probably only about fifteen
percent of the room it's probably one of
the most important laws you'll see in
computing it's worth reading up about
that basic says the design of our
systems will follow the communication
pathways in our organization and vice
versa so often where you find things
like I've got two teams in two different
geographical locations that's often a
really good reason to have them work on
two separate services that are
collaborating I can't go into that in
too much detail today there's also speed
of change when you break up a big system
into smaller components you have the
ability to deploy changes to independent
components without affecting the whole
overall system might orkut go to last
year our was actually the subjects
called dem designing for rapid release
there's a lot more detail about
characteristics of services that make
them easy to release frequently before
we talk about breaking as so as a part
though we should maybe step back up in
think what is a good service and I'm
going to keep it fairly high level when
we think about a service I think no two
characteristics are very important to
consider the first is sort of high
occasion if I've got a set of
functionality around a given area I
would like it to be sort of in the same
place because it gives me opportunity to
create abstractions around that piece of
code if I fix a defect I can fix it in
one place on one place only at least
closely together it also makes it easier
for me to understand comprehend how my
system works I've got lots of
like-minded star
in one place and is also loose coupling
I would don't want my systems to be
composed of services that are so tightly
bound together that I can't change one
service without changing the entire
system big monolithic systems are quite
hard to change it's even harder to
change distributed systems are very
highly tightly coupled together an
example what i mean by loose coupling to
imagine i've got a service and inside my
service I have my internal
representations of the work I'm doing
this is effectively my objects I've got
in memory and it's how I'm doing my work
and let's imagine that I am providing a
service to other things around me and so
here they are and they're wanting things
from me now if I allow these services to
reach right inside me and grab my
internal representations then
effectively I have an unfortunate side
of coupling it's now hard for me to
change the internals of my system
internals of my service here because the
things on the outsider sort of grabbing
hold of it is like when you're having a
conversation with somebody we're trying
to speak verbally and then suddenly he
starts reaching into your brain and
grabbing all the sign apses it makes it
very hard for for me to do my job when
something's reach deep inside and
grabbed hold of me and this is actually
how you can very quickly create these
sort of intricate maps of distributed
systems where things are very very
tightly coupled together and a very
common example of this is where people
take internal representations serialize
that and then share that over the wire
they become inadvertent coupling points
russ talked earlier today in this track
about things like Conway's law I talked
about more than that my previous talk
longing for rapid release about
techniques how you can avoid that so we
really want to have this concept of high
cohesion and loose coupling we make good
services because this sort of coupling
process but can become a bit of a mess
you end up with a big old well basically
a bit of a nightmare try and pick apart
now this is a fairly modern conference
your phony modern people and I was
trying to think of an example a good
example to help illustrate some of the
the lessons i'm going to talk about
today and so i was thinking what one of
all the kids doing nowadays I think
cutting edge so I think the future of
the music industry is basically about
the physical delivery of media so here
we are so our example for today is going
to all be about how CDs come from a
website and get arrived at your door now
think about what's going to happen in
that operation we're dealing with
physical things I like physical things
you can point to them and say that thing
is there it's not over there cuz I can
see it physics aside and say imagine
with a a music shop here I am I have my
warehouse so my warehouse contains many
many things it contains CDs it contains
breakout areas it contains calendars of
questionable content are boxes and
people and obviously people have to get
paid and lots of numbers need to be
written down for financial reports oh my
my organization is where we gonna have a
finance guy somewhere you can tell he's
in finance he has the blue tie he's
thinking very thoughtfully about I
wonder if I shovel all my tax who
Luxembourg if I can avoid and he's
writing things down with a pen so he the
finance guys thinking deeply now things
happen in the warehouse that the finance
guy doesn't really care about he's not
really that bothered about the fact that
the warehouse has inside it a forklift
truck equi doesn't know for reasons
known only to the people who work in the
warehouse that the forklift truck is
called barrel he doesn't even know where
right he just knows about some aspects
of the warehouse he probably needs to
know about the inventory for purposes of
financial reporting but I need to know
about detail so it doesn't you demand
the forklift truck doesn't even know
about the types of boxes that are
involved that used to store the items
but he very much cares about the kind of
products that we are selling and
shipping because he has to write out
reports this is interesting here right
we've got within an organization within
the context of our music shop we have
people and responsibilities we have the
finance guy who does finance things I
don't understand finance there's finance
things being done by him all I know is
that payslips come out at the end and
report and he talks to the warehouse and
he might ask for specific piece of
information and even though everything
though so effectively you know heat all
the finance stuff is in the fine
guy in the warehouse does in the
warehouse going out or talking over that
line um how many people here have read
this book the main given design it gets
lower every year which does worry me a
little bit actually it's a really
interesting book by Erich Evans arm when
I first read this book pretty about 10
years ago now as when it first came out
I found the first half of that book to
be the really interesting insightful um
if any of you have a repository layer
our posit Ori interface in your code you
know a user repository or the apt
repository more than likely that the
person you put that it we read this book
and thought we need repositories in our
system it turned out actually the
interesting stuffs at the back half of
the book but I didn't read that till
much later as a concept to Eric talks
about a book which is one of a bounded
context so banner context this is our
Eric describes the barrack context the
delimited applicability of a particular
model bounded contexts give team members
a clear and shared understanding of what
has to be consistent and what can
develop independently now I think Eric's
great with ideas and concepts I have
found is quite hard to understand I find
a more pity our explanation of what a
 context wasn't a blog post which is
a specific responsibilities enforced by
explicit boundaries so let's think about
the warehouse the finance team the
finance team have their job that they do
and they have a responsibility and
operation to carry out they have all
tana me the warehouse likewise they have
an explicit interaction point I need
inventory report so I can do my which I
can do my details racket in my reports
or you can summarize this all as sort of
respect my authoritah these are bounded
contact design I'm doing this you stand
on my way I know what I'm doing let me
do what I want to do and when it comes
to services we're thinking about these
concepts of high cohesion and loose
coupling these explicit boundaries
between the Bannock contexts are a great
place to actually achieve that loose
coupling we talk and communicate
across a fairly narrow well understood
set of interactions high cohesion or the
finance stuff done by the finance team
this ends up being a really useful model
of me thinking about designing our own
systems let's think about some of the
capabilities that we might have within
say our music website things I might
want to achieve with my system I might
want to add something to my shopping
cart I want to check something out I'm
thinking about viewing the latest
releases searching the catalog listening
to previews it's also about activities
responsibilities that are part of my
online music shop but you can already
when you look at things like this start
to group them together and create sort
of like minded things things that sort
of sit well that have high cohesion need
to be calm effectively banning contexts
so some of the banner context that might
exist within our music shop are things
like well shopping cart a catalog a
music library and you will probably find
that within your own organizations
people already know what the Ballad
contexts are and in terms of already get
used you have teams you have all
organizations within your own company
already question is how much of that is
actually represented in the flows of
your own architecture and your own
systems you're in design so one of the
key things that we found is that when we
find and take a big service and spit up
in smaller chunks if we can do it around
these banner context we end up with
services that have those two
characteristics we like to look for that
high cohesion and that low coupling so
how do we how do we achieve that how
long we start with the big box where do
we go well easy things at the beginning
is to start simple you get around a
whiteboard you start sketching out very
high level well the banner context that
we think exists and start coarse-grained
so maybe this is high enough level for
the music shop we think we've got like
these these four five things in our
system really high level things the
interesting thing with music with the
better context is actually kind of nest
if we think about that the context of
you know this this conference we have
the whole conference we have to set up
nations around the canteen instead of
operations around the coffee shop there
there's the crew who run all the
feedback sessions and make sure we get
in and get out all those sorts of things
start course and start slicing apart
when the easy way to do this is actually
just to look for things your language
provides you in terms of grouping code
together I spent most of my professional
life working in Java Java has the
concept of the package the package is
actually from a program point of view a
very weak construct many other languages
do much more interesting things with
packages but they're actually quite use
useful as just grouping things together
at all like structure 101 can do a very
good job but actually showing you your
packages and how they interrelate we're
looking member for that loose coupling
so we're looking at our Bannock context
we're looking for opportunity to see our
things to couple together so structure
101 gives you useful are pictures like
this so here I'm already seeing some
things that seem like that might be
about my business I've got to thank for
a booking criteria a commission plan
report system and you can start seeing
some interesting things like it's kind
of weird you know I can understand so
for example why the business criteria
kinda needs the Commission plan but I
understand why that links going back
that's not how our organization works
why is my code looking like that and i
think is moving code is fairly easy
they're simple refactorings you can make
so if you have a tool that lets you
visualize the groupings within your
existing system your existing monolithic
codebase you can just over time chip
away shift stuff around look at the
flows and get to a happy place doesn't
have to be all or nothing very very
low-impact work and so over time you can
go from a place for your big monolithic
service actually gets broken down inside
itself into sort of packages to look
like this the reason i expend much time
talking about how you achieve that part
of it is because actually that's the
easy part and i think most of you can
understand your domain better there's a
good book called implementing domain
driven design that goes into more detail
about how you actually get into the the
detail of actually separating out these
concepts but often just by pete speaking
to your business stakeholders will get a
lot of that information
the hard bit as always is databases
because basically data is called the
databases suck and there are often the
biggest impediment to how you break
apart systems and services some stuff
I'm going to talk about our patterns
actually in the refracting databases
book which you may well want to read
especially if you're dealing with an RC
legacy databases lots of coping patterns
in their house separate and pull apart
these systems so here's an example that
the cute the core problem here is this
is the most additional way of people
breaking apart systems is to basically
say right I've got my mana thick music
shop I'm going to pull out my service
and they're all going to integrate back
to the database and that's kind of a bad
thing to do because if I change
something in the music shop I might want
to change the schema underlying my
service can I do that I don't know
because my recommendation service are
talking to the same database we have a
source of coupling we need to break that
apart so you really do need to separate
those things out and use separate scheme
as wherever possible so you probably end
up with something like this I've got my
packages first thing you want to try and
do is where we go from a single
repository layer within your big
monolithic service to actually
separating out those repositories for
being on a per banded context basis if
you do end up having different
connection pools and things like that
but it's do it's worthwhile doing
because then all of the work related to
the catalog is there and visible and
your repository layers a great way of
visualizing the interactions with the
data schema as well you can see which
parts the schema the catalog uses and
which part the skin with the warehouse
uses it's not the end of the story of
course because obviously you have
referential integrity between database
tables it's not visible within the
application tier there if you're using
relational database tools like schema
spy are very good at helping you here so
you can actually see the relationships
because we need if I want to spin off
the catalog as a separate service I've
got a chip all the way down and move
that schema out look at some examples of
that so here we have a catalog and a
line items table and I've got finance
and I've got a ledger not sure the
ledger is but they're very important
things our ledger and I've got to
generate a report as part of the finance
system now my existing system
report gets run I'm putting together
information from the ledger with
additional metadata from the line items
table to enrich that report so I know
how many of its not just I know that
I've sold 50 items of skew 123 I know
thats q 1 2 3 is the greatest hits of
Justin Bieber it's very short album so
here i am and i'm putting this across
now here though I've got the bounded
context of Finance reaching in to data
that's kind of much more closely
associated with catalog now if I want to
separate those as services that lines
can become a problem so I need to kill
that line I may also have referential
integrity from the ledger into line
items table what I need to do is split
break both of those lines and what I
want instead is when the finance report
runs it should go to the catalog banner
context and interface and say please
give me it's not require and that's a
change you can make within the single
service before then separating those out
as two separate services that then get
to maintain their own schemas
independently and then that relationship
that within a relational database may be
a foreign key relationship or something
like that ends up being maybe something
as simple as a link to another resource
look another example arm country codes
tables country code tables are like the
string utils of the database world every
project I've been on seems to think that
countries get created much more
frequently than we release our software
and so that we put these country code
tables in there so that why she was some
software that's probably true but anyway
you know you put it in here so we can
magically go in and add in a new line
when a new guide and appears or whatever
else how am I going to split this up
well there's some odd things I could do
so the first step I could take is to
give each valid context its own country
codes thing seems a bit all twos a bit
excessive um I could equally just say
well there's just static code it's just
static stuff you know I'm just going to
put those country short codes in an enum
and stick that in code and have some
Reaper and have some actual duplication
between my arm bandit context rust talk
quite well at the beginning of the day
about how actually duplication between
services not necessarily a problem if it
avoids coupling
in one environment we actually took that
customer that's why those country codes
and made it a separate service because
it was a large amount of sort of
metadata associated general reference
data names of companies things like that
and those enough that it became a
service in its own right to break that
connection here's another example a
finance my warehouse system both talking
to a customer record table at this point
I'm going to use a fancy word because I
think both Neal and rats introduced
fancy words so out the word i'm going to
identify here is ray at five and i have
a diff edition not from webster but from
google which actually from victory com
see if we are ray of phi r AFI means to
make something abstract make it more
concrete make it more real so if you
look at this situation I've got the
finance system and the warehouse system
both talking to a customer record table
the finance system is updating things
like this customer paid are refunded
customer are item of turns I've we find
the amount the warehouse system is
saying things like I received the
redfoot return if I've sent the order
out and they're updating this same
concept the issue here is that we have
an implicit domain concept that hasn't
been realized we've discovered it while
going through our data schema the in
what's the implicit domain concept here
customer so there was something we
didn't know was then we found it it's
fun to like archaeology this stuff so
there we are now we create a new ballad
context and it might be a very very
small one it might actually be nothing
more than a nice interface on top of
some some very simple hibernate mappings
but now the finances from the warehouse
system can talk to the customer context
which in turn talks to that table and if
I roll it all the way through I could
end up with three separate services that
are then collaborating one last example
here we have the catalog on the
warehouse and we have a nicely generic
table called item because items are for
storing items and in the item table we
have information like this that we have
the bee gees 4929 we have 40
so bee gees 499 information about the
record and 45 is how many items we have
in stock and so both banner context to
care about that information when you're
browsing the cataloger you want to know
how much it costs and anything else in
the warehouse need to be able to update
the inventory and all those sorts of
things but we effectively have two
separate concepts here and so sometimes
when you find these you actually need to
take those schemas and actually separate
those apart the refactoring database
book talks a lot about how you can do
those things piecemeal so here rather
than having a very generic concept I now
need to be much more specific and
explicit in what I'm doing here by
pulling these two concepts apart um the
key thing I want when I get across here
is that this will be a journey of
discovery um it can be a bit concerning
because there is no necessary necessary
grand plan other than the understanding
that we want to model our services
around his banner context what you're
trying to do is high-level when you
start chipping away the key thing to
understand here is actually the cost of
change the cost of change around a
whiteboard is very low if a line in the
wrong place I rub it out I draw a new
line it's kind of a straightforward if
I'm working within surcoat base of say
one within a process boundary and I want
to move some code between a package
between packages it's a shift f6
IntelliJ it's not an operation that
should cause any errors it's a very
quick and easy thing to do and if I make
a mistake i can write it back quite
quickly changing how services talk
together is much more tricky because if
I get it wrong the cost of that is much
worse sometimes those team those
services we split between separate teams
for example if I need to make a change
and I have to orchestrate deployment two
components and changing the database is
also likely more like quite expensive
and this is all basically an argument
for a little bit of upfront thinking not
a lot just a little bit I think getting
around a whiteboard and actually
thinking about how these better context
interact and what would they look like a
service is a very sensible exercise as
how many of you when your university did
object-oriented theory and talked about
class responsibility collaborator things
few time and I suspect like all of you
like myself anyway I did that at uni and
thought that's a really interesting
exercise and then probably never used it
ever again and I think it's a huge
amount of overkill for objects I
actually think though it's very sensible
for services just get around a
whiteboard what's the responsibility of
this service how's it talk over here
let's try a use case I'll this services
talking sister is like five times during
this use case maybe that's a sign
they're too closely couples and should
be one thing this thing's got circular
de pitches we should tease those apart
two very simple easy conversations you
can have around a whiteboard and
actually some of the exercise around crc
cards work quite well there so then the
next question of course is well if I'm
breaking these things apart and I know
that Vanek context nest within each
other I have the music shop I have the
warehouse do I start splitting out
within the warehouse or concepts inside
the warehouse I go how small is too
small now for a service there's good
things about being small a piece of code
which is small is fairly easy to
understand the house for do I go before
it causes me problems somewhere else and
this really is where a lot of the
interest and microservices has come
about and the movement towards more
fine-grained architectures has come
about in large part because we've had a
whole lot of enabling technologies that
have reduced the cost of having more
types of services lying around we've got
cloud infrastructure automation and
we've also understanding about
architectural patterns and distributed
systems is much more mature and so we
now have the ability to go much more
fine-grained than ever before but how
fine grain should I go and and and what
are the benefits of doing that so I'm
going to talk about that by talking
about unix so I'm a big unix fan my
first proper professional platform was
looking off about six different unix
variants a lot of fun although see
macros are evil I should know I wrote a
lot and really to understand why I unix
has been so successful and why linux of
the back that's been so successful is
because there is actually an ethos
behind
it that drove at the successful
deployment of so many different variants
their system with these same underlying
principles and I'm a great believer like
many of my colleagues when designing a
system that having principles that help
guide your way are very important and
here's his Doug a Douglas McCrory from a
lot of work Bell and the early days of
UNIX talking about what the UNIX
philosophy is this is the UNIX
philosophy right programs that do one
thing and do it well write programs to
work together write programs to handle
tech streams because that is a universal
interface arm has a smart guy who's back
in this I think is a 67 just a ram home
this point a bit more as a book called
the art of unix programming that i'm
sure the ripsnorter but i haven't read
it what i have done is found out about
it on wikipedia and copy bits of
wikipedia into my slides there are
basically in this book are I think about
17 rules of UNIX let eric raymond talks
about i think he's very seriously talks
about rules and I've picked out a few
rules that give you well I quite like as
for general rules for all systems is the
rule of modularity developers should
build a program out of simple parts
connected by well-defined interfaces so
problems are local and parts of the
program can be replaced in future
versions to support new features this
rule aims to save time on debugging
debugging complex code this complex long
unreadable good the rule of simplicity
developers should design for simplicity
by looking for ways to break up program
systems into small straightforward
cooperating pieces he kind of likes the
small thing here doesn't he this rule
aims to discourage developers affection
for writing intricate and beautiful
complexities that are in reality bug
prone programs I feel quite offended
about this because I've been doing that
for quite a long time I like my big
complex systems and Neil talked earlier
before lunch about this this challenge
that we often don't have constraints
place upon us and therefore we allow our
systems become big and complex is my
favorite one the rule of power
simoni so word I don't use enough pulse
many developers should avoid writing big
programs again he's really driving the
point home to the point of being boring
now this rule aims to prevent over
investment of development time in failed
or sub optimal approaches caused by the
owners of the program's reluctant to
throw away visibly large pieces of work
smaller programs are not only easier to
optimize and maintain they are easier to
delete when deprecated this is really
really important stuff I think it's okay
if the board of your company knows about
the name of a system as a whole if the
board of your company knows the name of
a service in that system it's already
too big for you to kill easily this is
the problem they're big they're visible
lots of risks associated but if you need
to change the axis of pain in the arse
as too much attention I can't do it
these are the big complex legacy systems
with it if my service is nice and small
i can rewrite it who cares dan north
almost caused this designing for rewrite
rather than reuse making things small
enough that you can rewrite them in a
new language in a different way just to
make it easier to understand more
perform on whatever it is but we need to
think about what unix thinks of as a
program a lot of you here probably use
linux and if you've got max you've been
maybe the command line this is what a
unix program looks like alice that lists
a directory structure i pass in text
with command line arguments if i want to
gain exit to another program i have a
uniform text interface called pipe so
this will take LS and send the output of
that to another program called grip
that's going to look for the word Sam
this is small stuff now i've been using
LS for about 15 years i know i've used
completely different versions of LS and
even on the platform as i've been using
for a long period of time NS has been
completely rewritten the features I
always used to use still work and new
features have been added but that code
has been rewritten fundamentally
multiple different times so think about
a services then we like to go small but
how small
should I go is my colleague James Lewis
ah who's committing the mac sorta tutor
of me on Thursday James used to say when
he was asked how small she to service be
he said you said no bigger than my head
arm the first time I gave this talk I
was in Poland in a multiplex cinema and
James his head was four times bigger
than it is here which was an awkward
conversation to have initially it was
about saying well if I can fit all the
code for service in one screen and my
head's about the same size of the screen
it's kind of a Plymouth same about font
size and um James really means is that
the service should be no more complex
and I can understand I should be able to
look at and understand what that service
is doing at that level of that service
it should conceptually fit inside my
head inside my brain I've heard other
people that say certain organizations
that practice a lot of fine-grained
architectures they have like rules of
thumb like 200 lines of codes about
right Tony lines are codon seemed like a
lot let's think about our shop let's
think about our webshop think about the
basket service what am I going to do
with a basket i'm going to add to basket
i'm going to remove from basket i'm
going to look at the basket even if this
was backed into a database for
persistence between sessions i would
actually be a bit embarrassed if I
couldn't write that service and listen
to you on the lines of code are even in
Java login let's login logout am I
logged in that's three things I'm doing
again to an advisor code seems
reasonable registration register okay
next I you know recommendation what's in
my basket what should I recommend I'm
being slightly glib but when you
actually take these contexts and break
them apart you son you start
understanding your system doesn't seem
that complex after all this actually
allows you to focus on the essential
complexity rather than the accidental
complexity that gets pushed to your
interaction points it's very hard to
understand how these would be more than
a couple hundred lines of code and if
I'm gonna blow one away and replace it
with something else well I can
is better so why wouldn't I that can
lead to these sort of big systems of
very very fine-grained have lots of
interactions with each other typically
at this point if I'm allowing questions
which I'm not to because I'm worried
about being behind time you can ask
questions later via the app press the
green button arm is is one of things
like performance only the first things I
did there was I actually took a service
I broke up the banner context within the
same service had different resource
pools talking to the same database
that's obviously going to be slower
isn't it what are you talking about Sam
this is nuts I'm now going to make
multiple service calls to assemble my
application that's going to be slow and
then we have a big fight about things so
at this point I would just say a few
things firstly performance is not the
most important thing I don't care what
application you're building performance
is not the most important thing to you
what is features you need some features
otherwise a very fast app that does
nothing is useless so there's always
trade-offs performance is often vying
against other things that are important
to you it's vying against the speed of
delivery is dying against data
durability service availability
consistency of information as a whole of
trade-offs you have what does good look
like for your system what is performant
for your system now tell me how fast
your system currently is and then we'll
talk about how fast it's going to be can
we make the change so as always with
these things test quite often when you
break these systems apart you discover
other opportunities to make your system
faster you actually start to break away
some of the parts and some search
features actually become faster because
they no longer shackled with the compute
paths or the i/o intensity of another
type of operation so often people say
and then how small should I go well you
know you want to go small the constraint
actually not the lines of code you get
more benefit the small your services
because it's easier to comprehend the
code but too many services and too many
types of discrete services can be
problematic and the other constraint
that comes into here is your operational
and architectural maturity so we think
of by your operational maturity in the
old world we had one big service and we
won't have multiple instances of that
made of load balancing them and they sat
on the big box ah this is a very easy
model to understand to comprehend
in a new world we go to smaller service
isn't the first thing a lot of people do
is say right I'm now going to have lots
of things on a box keep my boxes this
becomes problematic firstly you've got
some port ops guy sitting there are who
has to go and deploy these things and if
people have picked different technology
stacks that's quite painful most shops I
know this that do very fine-grained
architectures standardize on one or two
technology platforms so they might be a
JVM and an Ogier shop that's partly
because you want commonality you want to
probably some ploy mcmechen is an easily
pretty similar but secondly you get
problems in the old world if I got an
alert on a box and only had one service
on that box I knew that well either that
service well that's so it is impacted by
that alert or it calls the number the
reasoning activities you go through when
dealing with that condition were much
simpler now when I have multiple
services in that box which ones calls
the problem what's the impact of that
problem happening now so this becomes a
bit more challenging so if you can when
you're moving to finer grain services
still try and keep that one to one
mapping between the service and the host
it is running on so rather than having
big boxes with lots of small services
try and have smaller box of a smaller
services this actually excrete Lee
simplifies the operational overhead in
terms of understanding our system is
working it also makes your life simpler
in terms of provisioning if you've got
an example an environment where you can
provision these hosts on demand maybe
you're using anything from lxc all the
way up to say ur VMS or Amazon or as
your for bring up your compute you can
then bring up boxes i tripping up
services and destroy them the same time
this allows you to actually have to
still keep the lives of your operational
team better it's not a problem to think
about if I had one big box it's kind of
typically has a binary state in terms of
being happy it's either up or it's bound
it's kind of straightforward ah no it's
off what about one of the big system
like this is all intricate now what if
this guy in the middle is down is my
system up or is my assistant down arm
don't know a bit more fuzzy it's becomes
a bit more confusing to understand you
have to get better for example at
knowing that the guy up here in the top
might have a problem because something
downstream has a problem you have to get
very smart for all of your endpoints
need to map and understand the health
their downstream resources need to get
good at monitoring response times of all
of these individual components to
understand where the bottlenecks might
be these are not problems you had in the
past with the one big box if something
or slow is the one big box there's
nothing else in the world now in this
world is something slow what is its
causing the problem and so from an
operational point of view the amount of
pain you're going to suffer is not down
to how big or small a service is it's
going to be about the number of them the
number of those things you're managing
so you need to understand how mature
your organization is in terms of
handling not only the implications are
safe downstream outage and the
architectural patent required to ensure
distributed systems themselves can be
stable and then I'll start with magna
guards release it book but also your
operational maturity how easy is it for
you to provision hosts for your services
how easy to deploy services understand
what's happening to them in production
and depending on where you are maybe in
your the old school I've got to Rack a
box up everything or maybe I'm in a new
school I can I've can provision
everything automatic and the cloud world
is going to tell you where your appetite
is for how small and how many of these
things you can afford to have and
probably is a rule of thumb i would
start coarse-grained and get finer
grained because you will learn things at
you know one of the time people say how
many serves is a good number i say how
many of you got now and they say five i
say six go to six and see what happens
and then go to seven and then go to
eight and as you go you will learn
things and discover things do not go
from one to 20 if you do don't blame me
because your life will become a living
hell because what will happen is you'll
discover all the stuff you didn't know
about downstream cascading failures and
the pain of the operations team and then
the cloud hates you ultimately this is
all about other traders
but the key thing here is to start as
you mean to go on is to slowly chip away
and emerge and pull out these designs
where each banner context in particular
you want to spin off and take out of
your your main service it's going to
depend a lot of factors I talked about
the beginning maybe this area of codes
actually are we need to scale up this
feature set maybe it's that we've got a
lot of changes that are happening in
this one area of the code and if you
make it a separate service that we can
actually do release those change without
affecting the overall system it may be
geography maybe all those sorts of
things but at least when you start
getting these tensions now you can think
okay so what I need to do whether seems
in my system there's a lot of ideas that
sort of are not really around
distributed systems that have sort of
helped interpret is thinking you've got
things like object oriented systems and
CRC cards you've got things from the
UNIX processing UNIX operating system
when I also think about finish this
presentation the first time I suddenly
realized this reminds me so much of all
the stuff that Mike feathers talks about
is book working with legacy code you
take a big thing you look for seams and
all I'm suggesting here is that those
seams should follow the business domain
or the domain in which you are operating
because by nature they tend to have like
you might be a fairly chaotic
organization like white knight I
actually working but typically most
organizations you have these explicit
bound use explicit responsibilities
those interaction points and they're
great ways to actually model services on
so in summary understand your bounded
context where are they how they exist
this is actually a great opportunity for
your technologies to reach out to those
people in your business domain one of
the things that we care about us is that
how those guys talk together or why
aren't we doing that in the code
understand where the cost of changes if
we don't have a big conversation about
where you're going to move code to
initially when you start getting into
when teammate database changes or
changes with house services talk to each
other do a little bit more upfront
thinking at that point please it's
important tool you can have as a
delivery team as a whiteboard and some
pens and a ball rubber I do get
surprised by the organization's I've
been in where it's easier to get a new
machine racked up the
is to find some ball rubbers and things
like that it's insane this is very much
an incremental journey you can chip away
at this gradually over time it's
actually is a very good way of getting
confidence to your system can be a bit
more supple in a bit more adaptive find
these seams chip away gradually pull
things apart the key thing for me is
this has been fantastic in allowing
organizations to experiment more when
you have a big service all of my
features are in there now for all my
risk is in there and if I want to try a
new language try any framework the risk
of that's huge if I can break that apart
and target changes to a small component
over here though i'll try an idea around
does it work if it doesn't work it's
actually create a fairly low risk it's a
bit of code we won't change i doffed
earnest it's not the end of the world
forget a couple of issues here it
actually allows you to be a bit braver
it's not only in terms of addressing
things like technical debt and be more
adaptive in your thinking but also in
terms of bringing new technology and
techniques into your organization and so
one last point is that why size is often
important and in general small is often
better you have to go slowly to
understand what your own level of
maturity is around the architectural
patterns and around your operational
maturity I think with that I'm I'm done
so I was going to say yeah thank very
much
so hopefully some of you have asked
questions on the special app all we've
got questions okay okay thank you okay
okay so a recommendation engine is not
200 lines of code perhaps a network
request to a cache response somewhere
but not actual algorithms for
determining user recommendations so we
are you causing service based on that
example I think we could argue about
this I mean simple genre matching would
be would be perfectly acceptable I think
as a recommendation system for many
people so I would say that is an example
of a service I was being slightly glib
with the 200 lines of code I think
within an organized i mean the key thing
for me is when you get into this
microservice world if you it starts to
allow you to concentrate on the the sort
of the real complexity rather than the
incidental complexity I could imagine a
recommendation service that is just
something as simple as saying the cds in
my basket are mostly in the rock genre
i'm going to take the top 10 rock genre
records and put those out as
recommendations may not be very
sophisticated but it'd be a start that's
a very obvious bounded context I might
then get a lot more sophisticated I
might start looking at the country you
live in the air you live in the interest
you and your friends have get more
sophisticated the key thing is from the
outside world point of view no one
notices just semantically the responses
get better I hope that's answered the
question if not feel free to glass me
outside another question when moving
from big to smaller composed services
some things become simpler but in
introduces complexity between the
services where is the root cause of a
problem do you need to protect against
that there is more opportunity to
failure any thoughts on that absolutely
hopefully I started touching on that at
the end are you have to get a lot very
smart about the protocols you use to
talk to each other that's where up front
design is very important colleague of
mine Eric denenberg users analogy where
he talks about the concept of town
planning versus architecture with town
planning it's like SimCity why you have
a certain you have my light industrial
area here I commercial area here I don't
really care what buildings appear in
that space I care
about the roads between them you
actually spend a lot of your time as an
architect not worrying about what I team
does inside the box and caring a lot
more about what goes on between the box
the key thing is you start getting a
separation responsibility the people
inside the service just care about what
they're so doing the architects thinking
about the more complex things so yet you
need to monitor response time to every
service you need to look at downstream
reporting of your dependencies you're
going to be doing trending decent log
aggregation stuff they say there's a lot
when you list out all the things the
people who do fine grain architectures
do it's a daunting list it's a scary
list which is why start small and you'll
see when you need to introduce those
concepts I think about time for one more
okay okay so Mike services make clear
sense for back-end system but how do you
recommend exposing the set all good
question the services to fronting
clients such as web desktop and mobile
one approach is to let the clients
interact with individual services via
discovery process and others the thin
service level facade giving client to
sing representation the resources each
has pros and cons I'd appreciate your
perspective um I think in the old days
where we only ever built websites you'd
have like a big UI web shop and that
would be all your stuff there and you
talked to all the backend services
behind the scenes I think increasingly
that doesn't hold water anymore I think
the key thing we can say is not the web
and mobile it's just we now have a lot
of clients and we don't know who they
are or where they're going to be I
actually tend to in general have the
clients talk directly to the services as
opposed to trying to create thin veneer
services what we're trying to do is
really think about this idea of
hexagonal architecture you we want to
avoid this layered problem a lot of time
when we have clients talking through a
thin service layer where we're trying to
push shared code into the server we
actually end up doing things like
creating aggregation services and all
that sort of stuff and over time that
can be really hard to deal with and you
end up actually you know I've got a load
of now stuff his specific about a domain
content as actually really do subjects
you down here I think common services
for clients that make sense of things
like looking
handshaking for API keys looking for
accidental denial of service attacks
logging you might have all farriers if
you're doing security to make sure
people have got the rights to in general
I favor clients going to the services
and the with the intermediate services
being nothing being fairly agnostic and
certainly have no understanding of the
domain there are times we need to go a
bit in the middle but in general stay
over here wherever this here is I hope
I've answered that question how we doing
for time you've got time for any other
questions though okay well thank your
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>