<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Building Evolutionary Architectures • Patrick Kua | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Building Evolutionary Architectures • Patrick Kua - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Building Evolutionary Architectures • Patrick Kua</b></h2><h5 class="post__date">2018-01-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8bEsNT7jdC4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi good afternoon so I work for m26
which is a mobile bank that the world
loves to use and we're building a
digital solution that challenges the way
that Europeans do banking we have more
than 500 thousand users across Europe
already and we get strong consistent
recognition from both Apple and Google
through the app stores from a sort of
focus on user experience and we're
really happy about the product they were
actually building and I'm building the
engineering organization here in Berlin
if anyone is interested in helping us
actually build a bank the world would
actually like to use but in terms of my
journey I'm going to be focusing on the
latest of these books about building
evolutionary architectures and one of
the reasons that this is a really
important topic is that we often talk
about the things around continuous
delivery agile but one of the words has
sort of disappeared amongst our radar is
actually architecture and what does that
actually mean how do we approach this in
this new world and this is a book that
my co-authors Neil Ford and Rebecca
Parsons from thought works we work
together on a sort of book of three
years sort of journey trying to distill
down our experiences of talking to a lot
of different organizations about why
they should approach architecture in
this fashion now the question is why did
we pick the metaphor of evolution so if
anyone has studied biology and evolution
we don't claim to be experts but one of
the interesting things about evolution
is this idea about change and we know
that change is inevitable so whether or
not we want to have change we have to
accept that change will be thrust upon
us and we have to be able to adapt to
our environment as that environment
around changes with us and we talk about
change in sort of two aspects in our
sort of world we talk about the
technical and we talk about domain
changes so if you've been an industry
for a while you can probably start to
understand what are the changes that
we've had in our technical space so if
you think about programming languages
the things that have started emerging
over the last sort of five years around
sort of go rust Swift now Kotlin there's
lots of new programming languages and
they won't be the last ones we also have
a whole proliferation of different
libraries so if any of you have been
working on the JVM you know about the
proliferation of Java logging libraries
so much so that we
have a framework that covers up all the
libraries for logging so that we can
actually abstract that away we also have
numbers of frameworks as we discover new
types of problems they help us solve
some of these problems quite rapidly so
if you think about web development one
of the most popular frameworks was sort
of Ruby on Rails and those patterns of
how you solve those sort of domain
problems has helped us solve those sort
of domain problems a lot easier and then
we export those patterns into other
types of sort of frameworks like spring
MVC and of course with every sort of
platform we have an ecosystem of tools
that help us evolve and that we have to
constantly keep up-to-date with
understanding what are the latest tools
that were using even if you think about
our sort of base operating environments
we actually start to think about the
differences of the way that we actually
work so in terms of the flavors of Linux
or the flavors of cloud sort of
computing that we actually have to think
about and we also change the way or our
world changes about how technical
constraints happen so fast forward or
rewind ten years ago most of us probably
would be working on sort of very slow
internet of some sort
now broadband is pretty much ubiquitous
so much so that on our sort of mobile
phones we have really fast networks this
isn't true across the world but we do
see these rapid changes in our sort of
technical evolution that we have to kind
of keep up to pace with so technical is
kind of the world that we live in but we
also have to think about the domain of
how we actually build products and how
do we keep up to date with the changes
that we want to have from our sort of
businesses or ecosystems or products and
even in the domain space we can actually
see a whole bunch of changes about the
way that we buy or build sort of
products so if we think about revenue
models most of you here might be some
sort of subscriber to Spotify so instead
of buying physical albums we now rent
music and then we have access to a whole
collection of sort of music that we
didn't have access to before and that
changes the way that we have to
architect our applications to think
about how do we monitor usage and how do
we price that and how do we make sure
that we evenly distribute that across
our sort of product set with base
technology adoption in our sort of
Western civilization's smartphones are
pretty ubiquitous but when I was sort of
working for thought works if you go to
the sort of African subcontinent
smartphones aren't so you
so the constraint there is actually
access to energy so you can recharge
smartphones where we have rich energy
sort of sources where we can recharge
our phones at the end of the day when
we're when we've done surfing Facebook
or Twitter we also have a whole bunch of
competitors right so startup world's
really big here in Berlin and that means
we always have to evolve our product set
to make sure that we're competitive and
stay competitive and at the edge of our
particular market and our customer needs
have changed along with that as well so
if you think about the very early days
of the web you were probably used to
having blink tags or maybe scrolling
text on Geocities now we expect rich
user experiences in our sort of web
applications our standards for customer
needs are a lot higher and that means we
actually have to think about how we
support those needs when we're building
our products as well unlike every
industry we have new markets emerging
all the time we have things around 3d
printing we have crypto currencies which
means we actually have to think about
the the domains that we have to support
and this means new products that we get
to unleash across each of these markets
as well so there's lots of elements of
change but I think we can pretty much
take it or granted that change is
inevitable so the question is if change
is inevitable then what do we do about
that and that's kind of the question
that we're trying to answer with
evolutionary architecture now I'm going
to take a step back and talk about a
case study and this is sort of borne out
through 15 years of sort of working in
technology in 13 years doing consulting
and this is often a case study that
would have with a lot of our clients
when I was working with thought works so
often businesses would have some sort of
idea they want to go to market with this
wonderful idea and they start to think
about how could they actually build a
system around this now a solution
architect gets involved probably early
on and they start to explore what it is
that they actually need to build what
are the capabilities that you might need
to actually design an account for and
what's the quickest way we can actually
build or collect the capabilities so
that we can actually give this to our
customers as early as possible so we
start going on a bit of a sort of
shopping lists of capabilities products
and the things that we can do to unleash
that but like all good
we're all thinking we need to support
some sort of change of some sort so we
don't want to just build one single
product or buy a single product because
we'll be coupled to them we want to have
a collection of these things so that we
can change our minds as our business
changes their minds about what they'd
like to do so we started to collect a
list of products that we want to have
but we don't necessarily want to build
it in a single product we want to have
loose integration and this is where the
thoughts of some sort of enterprise
service message bus might come in of
making sure that we can change our
products as we'd like to have now some
time has passed we get a team together
starting to work on all these different
types of products and time starts to
pass now if you've ever been on any one
of these journeys you know that setting
up large sort of products and vendor
driven sort of customization can take
some time to just specify what you'd
actually like to have to start planning
what you need to have and actually
getting these features customized in the
platforms that you have and of course we
know what happens as time passes people
want change and so when you go back to
your original plan with your vendors
around what things you've agreed upon in
your contracts of course vendors are
very happy to actually accommodate
changes but of course that will cost you
money and more than that it's not just
the money which is a key idea is that
actually vendors have a big roadmap of
other customers they actually have to
sort of keep happy as well and so
they'll be happy to do your changes but
they have other changes they have to
make and you end up sort of being driven
by their roadmap of the things that they
can actually support now typically these
might be cycles of three to six months
and at some point you might get your
whole set of products all that I could
sort of customize talking to each other
and then you discover to find these
funny integration bugs across all of
these this isn't the flow of what we
expected from this product to this
product
these things aren't sending the right
information between these systems and
you find out and you realize that you
have one precious environment or
production where everything magically
kind of works and of course as a
developer you're really scared to make
changes because a single change in that
environment means that you might break a
lot of things for our sort of users and
so change just becomes harder and harder
over time and the business starts to say
what have we been doing and maybe we
need to put a stop to this
so this is a typical scenario of which
we get called in in terms of thought
works and and one of the questions is
what happens if we actually design a
system for change rather than thinking
about buying things off the shelf and
trying to sort of customize these things
and so when we were exploring this idea
we came up with the definition of what
we talked about in evolutionary
architecture as an architecture that
supports incremental guided change as a
first principle among multiple
dimensions and so we'll explore each of
these different elements of this
definition to understand why these are
essential parts of evolutionary
architecture the first key word here is
about incremental and so architectures
are evolved through incremental releases
we bring it back to the evolutionary
metaphor the way that we evolve is sort
of genetic beings is actually through
the idea of generations so incremental
releases for us in a software world
represent the generations of software
that we can actually release so when we
actually think about our sort of budding
sort of system we start off with some
sort of idea behind that some sort of
concept and over time depending on how
the environment works for a business
change or a technical change we want to
evolve our system to actually
accommodate that particular scenario we
may not be able to predict what those
scenarios are but hopefully we can
actually adjust to adapt our systems
according to that and over time we might
end up with very different systems
depending on how we're evolving in
response to technical changes and domain
changes and we might end up with a very
different sort of system now one of the
key ideas about evolve ability and
survivability in biology is really about
this idea about how fast is your
generation so in software the question
is how fast is your generation does it
take you six months for you to be other
actually release software into
production and actually understand what
that is or are you actually a lot faster
in how you can involve your generations
to a daily or even a minute basis of
software change and so for our
perspective generations in a biology
sense is really this idea about cycle
time and so this is really the time
taken to get a simple change from
development all the way into production
but it's not really just throwing code
into production and hoping that
everything works it's really about this
idea about repeatably
and reliably so we really want to make
sure that as we evolve our system our
system is secure and safe as how would
like it to evolve in the sort of domain
area that we have and this isn't really
a new concept this is really the idea of
continuous delivery and so a lot of the
practices that we sort of talked about
in continuous delivery actually helped
us build available architectures because
it gives us that increment basis of
being able to create new generations of
software now continuous delivery isn't
just the only sort of side of building
software you also have to think about
the social sides and the process and
structures of your organization's about
how that helps you build software and
release that into production as well and
that's where movements like DevOps
have really come into play so the
Phoenix projects a really great business
tale that talks about how you can
overcome your organizational barriers to
make sure you can repeatedly and
reliably release software and another
book that's useful is also the DevOps
handbook so all the practices that
really come from these kind of worlds
are things that help us build in
incremental sort of software
architecture that allows us to test out
how good our architecture is and this is
maybe coming back to the idea of well
what is architecture and how does this
kind of work so in a lot of teams today
I find that a lot of people don't think
about architecture
you know we design stuff we build it and
we throw it into production and out
kotecha is actually something that maybe
is coming back can I hope that you kind
of challenge yourself and educate
yourself and why it's important so maybe
if we explore what architecture is it'll
help you understand a bit where we're
coming from unfortunately there is no
industry standard definition of what
architecture is instead there are maybe
some interesting quotes from people that
we can refer to to understand the
characteristics of architecture and the
process of architecting so Martin Fowler
talks about software architecture is the
decisions which are both important and
hard to change
Simon Brown talks about architecture is
about understanding what you need to
build creating a vision for building it
and making the appropriate design
decisions and I like Ralph Johnson's one
which was about architecture the
decisions that you wish you could get
right
early on in a project so there's
something about decisions making choices
the importance of them that makes a big
difference but if we go back to a
typical sort of designing process we
often think of architectures are sort of
linear thing right so we often think
about we architects and we decide we
make the important decisions here and we
kind of pretend to ourselves that the
easy stuff is in the development and
releasing oh yeah that's somebody else's
problem right but actually if anyone has
been building software you realize
actually you know what appears to be
important during the architecture phase
may not actually be so important and
it's actually in the process of
developing that we start to realize
maybe there are some other things that
we should have paid attention to and
we've made the false assumptions which
means the decisions we've made aren't
necessarily the important ones that we
thought they were and in reality we know
that releasing software is a lot harder
than what it appears to be from the
beginning and we need to really design
for that from the beginning so the
challenge from our perspective is
turning this linear thinking away from
this process to something that turns
into a loop of some sort and actually
when we release our software's we should
actually be reconsidering the decisions
we make to understand if we're actually
helping us build software that's easier
to change or if we can actually reverse
decisions now a key process in this loop
is really the question of how long this
cycle takes and if we can actually
condense this cycle release software a
lot faster we can actually test our
assumptions about whether or not the
decisions we make are the right ones and
if they're the wrong ones we can
actually even reverse them so we can
take the decisions out and once again
this comes down to the idea of cycle
time being our constraint of how well we
can evaluate our architectural decisions
when we make them so continuous delivery
forms the basis of giving us our
incremental set of evolutionary
architecture the second characteristic
we talk about is about guided so unlike
nature where evolution happens by random
chance in software we don't really have
the time to wait for software's that
kind of randomly reproduce and then sort
of hope that we end up with the right
system we want to have our sort of
guiding hand in how the system actually
evolves and we talk about guiding
evolutionary architectures through the
use of fitness functions so the question
what is a fitness function a fitness
function is this idea that comes out of
sort of machine learning it's an
objective function that measures how
close a given solution is to a
particular goal so typically in machine
learning you don't really think about
how something happens you really care
about the results and the quality of
that results and this is very similar to
what we should be thinking about in our
sort of architecture and when we think
about what are the characteristics of
sort of a sort of system that we care
about there are things that we really
want to care about that are important
and those that are not important and
typically these might be called the
non-functional requirements or the cross
functional requirements because they cut
across the system or the quality
attributes of the system that you care
about now a lot of people that I know
don't even lie dentists I what is
actually important for their system or
unimportant but we have to actually
think about once we've identified what
is important how do we go about turning
that back into an objective function of
some sort to make sure that we
continually monitor if our architecture
is heading in the right direction and
there are typically three ways that you
can kind of think about implementing
this so one is around metrics one is
around tests and one is really around
the process of making sure that you
think about testing your architecture
for the fit of the characteristics that
you're actually trying to optimize for
when we talk about fitness functions we
talked about in the book three types of
fitness functions and I'll explore each
one very briefly we talked about those
fitness functions that are atomic around
a single element we talked about a
fitness function that talks about the
holistic characteristics of the system
and then we talked about fitness
functions that are sort of continuous
and ongoing and I'll talk about examples
about how they are kind of work so an
example of an atomic fitness function
might be thinking about if you have too
much coupling in your particular sort of
system so in this code sample here we
have J depend testing to see if we have
cyclic dependencies within our code base
so we know at some point we don't want
to have cyclic dependencies we want nice
modular systems and this might be a way
of actually testing a single attribute
about how well modularized is your
system and so this is an example of an
atomic one we can even get more specific
which is rather than thinking about
cyclic we can actually think about the
layering and
in enforcing those types of layers as
well so in this example we have the web
depending on you till we have a
repository depending on you till and we
have a web depending on repository but
not the other way around so if we have
this running in our sort of continuous
delivery pipelines as people add code to
their sort of system we can enforce this
layering in terms of the architectural
layers of modules that we actually want
to have and guarantee some level of
consistency or fit for function but that
takes some effort to actually think
about what you want now an example of a
holistic fitness function is thinking
about what things can you run that test
the entire characteristics of the system
so I want to talk about an example that
I worked with a client a while ago we
were building a highly performant sort
of storage mechanism so the system would
be storing high volumes of small files
and it was really important that we
could sort of these things in a very
short time frame but we weren't reading
them out as as frequently so right was a
really important characteristic and the
reason this system existed was that
performance is really critical and so
what we did to actually guarantee this
is that we ended up building a whole CD
pipeline and performance tests we'd
start off with a sanity performance test
so as we would make a code change a
small test would run to make sure that
holistically everything worked how
performance test harnesses was still
sort of working and then if that pass
would actually run a much larger test so
we'd actually run a memory soak test to
actually test the system under high load
for a long period to see if would
actually introduce any memory sort of
problems now we also had overnight runs
that would test things like an
escalating load and one day we actually
found there were some interesting
behaviors and we detected this in a
particular test run so when we actually
visualize the results from this test we
expected sort of a linear performance as
we as an increasing sort of load but
what would actually find is that every
hour there would be a sort of spike in
the performance charts that we have in
terms of latency and we asked ourselves
why was that why was this actually the
case we hadn't done anything that we
theorized actually caused a problem now
we rolled back heard we ran the scenario
again we found the same pattern of
behavior so the question for us is what
had actually changed after
while we talk to the sort of operations
people who manage the data center in
which these tests were running and that
we actually found that there was a
misconfigured disk controller and every
hour it would actually flip over data
center from one data center to the other
that would improve that would actually
change a sort of performance
characteristics and we violated our
fitness function now what's interesting
about this holistic fitness function is
that you wouldn't be able to detect this
in your software alone because this is
really a whole systemic behavior of how
your software works with the environment
and through this process we could
actually guarantee to make sure that in
these data centers we had those
performance characteristics that we had
rather than actually anything that might
actually violate the things that we were
caring about so think about not just
your atomic fitness functions but think
about your holistic fitness functions as
well now in terms of continuous we have
some really good examples today about
what you can do to continually test your
systems for the behaviors you want and
probably the most famous example is
really Netflix with their simian army so
they're probably the best well known for
actually running these simians sort of
processes in production breaking things
tweaking configuration and then testing
for resilience because it's such a key
characteristic of their system that they
care about and if you think about the
recent sort of s3 outage they were a
really good example of being one of the
best sort of demonstrations of how you
can be resilient and they have the
confidence because they're continually
running this fitness function in
production and if you look at sort of
chaos engineering that's a no other
movement that's kind of encouraging this
so this really comes back to the idea of
continuous delivery of if it hurts do it
more often and it's not because we're
sadistic people that we really like pain
the idea is really that we actually want
to get better so if we heard a little
bit we start to realize we need to
improve our systems and our systems
improve to the characteristics we
actually care about
so we've explored the idea of
incremental we've explored the idea
about guided let's have a look at the
idea of dimensions of change and what we
talked about so when we think about
evolving our sort of systems we have
both are sort of technical changes we
have libraries we have tools frameworks
and platforms upon which we
so the domain logic to give our users
their value so you have to think about
when we introduce new tools how do we
actually introduce new tools that are
easy to sort of chain how do we
configure the tools of frameworks that
we have so as an example when we look at
tools you should be thinking about how
easy is it to actually manage that
configuration I can talk about one of
the reasons why you want to move away
from tools that have only graphical
configuration is that they'll that will
be really hard to be able to reproduce
in different environments and also
source control and test you end up with
sort of manual errors and differences
between different environments which
means that you'll have a lot more
difficulty making changes repeatedly and
reliably what happens when we upgrade a
particular sort of framework or version
how often do we test our code against
latest versions of frameworks to detect
if there's any API breakages so that we
can respond really rapidly or do we
defer the choice of actually upgrading
and we build that up until the point
where you need a whole program of work
in order to upgrade a significant
framework the other question is really
about a level of appropriate coupling
about if we were to replace a particular
framework or tool how much of our
codebase would actually need to change
how many parts of our code base do we
need to go to to understand what we need
to do to remove it or have we actually
done something in a way that isolates it
to a single part of our codebase such
that we can immediately replace it with
a type of other equivalent library and
then the same thing if we actually want
to remove it the other question that we
want to sort of look at changes about
it's not just technical space but also
the domain changes that we want to
support and this is the one that we
probably focus on a lot more around the
types of features applications new
interfaces new business rules that we
want to have and let's take a look at
some architectures and understand how
that might be easier or harder to
actually do so we'll look at for
classical architectures to understand
perhaps the styles or how they support
change we'll start with a big ball of
mud
so hopefully you don't end up with one
of these this is actually an analysis
from a code base of a former client what
you have around the edge of the circle
is actually a dot that represents a
single class and each line is a method
between those classes and the thick of
those lines are the
all calls there are in that particular
sort of call graph so as you can see
it's not the most appealing modularized
codebase that we'd like to have in a
better modulized codebase you'd have
maybe more clusters of lines and clear
separation of different parts but if you
start to look at where you want to
upgrade perhaps a logging framework or
you have to make a change to a pricing
rule you probably have to start
analyzing quite a large part of the code
base to understand the impact you pull
one thread and a whole bunch of other
threads follow with it that you have to
understand the impact and so this
doesn't really support change from
either a domain or a technical
perspective as easy now hopefully most
of us have avoided this and we ended up
with some sort of tiered or layered
architecture so we have nice tiers of
separation of presentation business
service persistence and you know if
we're sort of good citizens we might
think about how consistent we are so we
made sure that each sort of sort of new
feel goes through each layer so that
developers know what things that might
need to change you might actually choose
to sort of bypass a layer because it
maybe isn't really adding a lot of value
now if we actually think about technical
changes if we think about we want to
swap out a data base we know that
actually we can go to our persistence
layer and this is the area of concern
that would actually need to work on and
it's kind of isolated in a single place
but if we actually think about where we
want to change pricing rules if we look
at this architecture diagram where do
you go in the codebase that talks about
pricing there's no single place around
that you probably have some places in
configuration or a screen where pricing
gets defined you have business rules in
a sort of business layer that talks
about the impact of maybe discounts once
the price is applied to a particular
volume and at some point it gets saved
away in a database as well and so just a
layered approach may not actually help
you support business changes as much and
so frameworks that you probably know are
things like spring or Ruby on Rails that
like lead to this kind of layered
architecture
another common architectural approach is
this thing about a microkernel so in a
microkernel system you have this core
system that is built around pluggable
endpoints and once you have that core
system they define what are the things
that you might be able to do to extend
that system based on different types at
the head
yes so some examples are really things
like maven Eclipse or Firefox now if any
of you had to live with maven for a long
time I'm really sorry but one of the
interesting things about maven is that
it does a really good job as long as it
matches your business problem so as long
as you're building something that looks
like an Apaches open-source kind of
common library then maven does the job
really well and it defines extension
points around places where you can give
in sort of extra plugins based on their
sort of maven lifecycle but if you've
worked in a more complex business
application using maven you start to
realize you start to work around the
edges of mavens sort of phase lifecycle
because it doesn't support the things
that you want in your business
application you know there isn't a phase
in your maven lifecycle that talks about
here's where you run performance tests
here is where we run the infrastructure
as codes spin up new environments you do
funny things like creating new profiles
that piggyback on an existing sort of
maven lifecycle in order to get the
behavior that you want and so these are
microkernel architectures can really
help you deliver sort of business change
and technical change as long as it
matches your domain really closely but
you have to have a really good guess at
making sure that you have that alignment
once you step out of that two main
you'll actually find these micro kernels
prevent you from actually making changes
both technically and business level as
well now the most popular probably
architecture of today is really around
micro services and I want to talk about
micro services done right so in this
kind of example we have micro services
that are focused around different domain
areas so we have a place which is
focused around sort of the customers
customer management of that we are
things that are focused around to the
inventory and things focus around
fulfilment now one of the reasons that
this architecture is really popular is
because we start to look at how do we
support both technical and domain
changes so let's say we want to change
the way that we persist our users and we
want to understand the relationships
between users so we want to start using
a graph database rather than a normal
database where do we go for that well we
go to a sort of customer sort of service
and then we could actually swap out the
database in that area without having
impact on the other sorts of services
that we want
what happens if we want to change the
fulfillment workflow for the way that we
actually provision and sort of fill our
orders well we have a sort of set of
services here that actually allows us to
narrow down that domain sort of sentence
and so these sorts of services allow us
to flex the types of changes that we
want at a sort of incremental technical
level as we want to change libraries
appropriate to a particular problem or
if we want to respond to business
changes incrementally across without
changing the entire code base and so one
of the reasons looking at why micro
service is really popular is because it
helps us evolve parts of our
architecture in ways that respond to our
environments as we change and we can
support that as well so we've looked at
the definition of evolutionary
architecture of being incremental guided
in multiple dimensions and I want to
sort of highlight some of the different
types of practices that make sense now
interestingly evolutionary architecture
isn't just about the technical practices
it just has so much to do as well with
the organization process that it's just
as important to look at those elements
as well so from a technical perspective
the practices around continuous delivery
will help you build evolutionary
architectures one of the reasons they do
this is because they help you support
fast feedback so if you're thinking
about that incremental approach about
decisions you can reverse things out if
you start to realize that this wasn't
the right decision and you can actually
test that one of the other benefits of
really a fuss sort of cycle time is that
you get to test how well you can upgrade
how well you can reconfigure things
across different environments and what
things are making it easier or harder
that you can maybe choose tools test
them out throw them away if they prove
to be wrong and then find a replacement
that helps you with your particular
changes thinking about coupling and
teaching people about coupling is really
key aspect of helping people understand
if we're coupling ourselves to our tools
and frameworks too much or if actually
we have an appropriate level of coupling
now we don't say no coupling because you
wouldn't have a very useful system if it
wasn't connected together but there's an
appropriate level of coupling and it's
our duty is to make sure that everyone
understands the types of coupling we
want to have in our sort of domains and
services that we have now one of the
example architectural patterns
is ports and adapters so this used to be
called hexagonal architecture and this
is if you're partnering with external
vendors or AP is don't make them the
heart of your system but keep them at
the edges of your system and have
adapters that represent the
functionality that are important to the
domain that you have and so when a
service provider stops being useful you
only have to change your adapter you
don't have to change the entire code
base so you can upgrade parts of your
system incrementally and really think
about the things that you can do around
automating your fitness functions at
both anatomic holistic or continuous
level around the things that you have as
important elements for your systems that
you're building now from a domain
perspective one of the key things is
really thinking about how you align your
product development with your business
capabilities now it's an interesting
kind of exercise because most of us in
terms of being technical people probably
never really think about the business in
terms of business capabilities what does
that mean well it really means what are
the sort of departments of business
units that you have in your organization
and how well do you respond and how well
can you actually increment your software
in line with the changes that they need
in terms of their department so we're
often thinking about technology and
business it a little bit separate and
actually we're really trying to align
our sort of technology product teams to
the business capabilities so they can
evolve the services they need in line
with the domain changes they care about
and this is kind of a big shift away
thinking from project project-based
thinking to product based thinking so
this is really thinking about how you
have people that sit with products a lot
longer because you have domain knowledge
that people can actually build up and
they can be a lot more effective at
actually making change when you have
project based teams you gain a whole
bunch of domain experience at the end of
the project you just remember that sort
of team and then that domain is
knowledge is kind of lost and the next
group has to come along and sort of
learn about that domain again and a key
part of this is really thinking in terms
of cross-functional teams so I'll
explain that in a little bit as well now
when you actually go down this path of
fast increments and testing on your
architecture it actually unlocks an
interesting capability of enabling
experimentation so evolutionary
architectures also affect the way that
you do product planning
and that instead of actually thinking
about the products that you actually
want to build you can hopefully get to a
point we are actually hypothesizing
about the features that will have impact
to business metrics and testing out
different types of features or changes
that will improve engagement and this
really requires a different way of
actually thinking about governance so in
a typical sort of organization you don't
really want to think about centralized
governance of one person making all the
decisions but really thinking about how
you push that decision making Authority
and understanding down into the teams
where they're actually facing the
problems at the heart and can respond to
make the right decisions as much as
possible
so or explore a couple of these
practices in a bit more detail to help
you understand why this is important
there are still organizations today that
are still grouped in terms of functional
sort of grouping so we have a whole
bunch of user interface people may be
based around Android or iOS these days
we have a whole bunch of sort of
back-end engineers working on
server-side and you might even have a
group of DBAs and they all work together
and they all work together because we
want people with the same skills to
really spread knowledge and sort of the
Altis or to keep up with their sort of
changes but if we structure our product
development flow in this you actually
end up with architectures that reinforce
these hierarchies and so one of the
interesting things about this sort of
movement towards cross-functional teams
aligned with business capabilities is
that you end up changing your
organizational structure if you want to
have evolutionary architectures and you
can increment things a lot faster so
instead of having individual sort of
functional silos you really want to be
making sure that you have people with
the right skills that you need around
the product areas so you can actually
increment that as fast as possible we
talked about the ideas of fast feedback
and one of the ideas of fast feedback is
you need all the skills you have that
are necessary to release the software
that you have so you can get really fast
feedback so if you need changes to your
database you really need to have that
optimized according to that business
service that you have on top of that as
well as the interface on top of that and
you need that as close together as
possible and this idea of architecting
your organization in the way that you
want your architecture reflect it's
called the inverse Conway maneuver so
there's a lot of talk in marketing
services land around Conway's law
and one of the things that I challenge
you all this sort of architects or
developers to think about is how does
your organizational structure support or
not support the architecture that you're
aiming for when you end up with
knowledge silos be it data scientists or
database people you will end up with
sticking points that make it harder to
change and one of the ideas is really
trying to bring them all together in a
way that you can really rapidly iterate
with all the skills that you kind of
need now I talked about sort of
architecture before in governance and
one of the ways that you can achieve
this is really thinking about the types
of principles you're actually trying to
have from the system that you're trying
to build so don't think about the rules
and say here are the things that you
must or must not do it's really thinking
about how do you empower developers to
make the better decisions and so I
challenge all of you to really start
thinking like a town planner and town
planners are kind of interesting because
they're not really dictating exactly
what gets built on this plot of land
they're thinking about the
infrastructure and the
interconnectedness and the guidance
around what zone of types of things
should be built in this area and they
put sort of constraints of how people
should build and so if you are in a sort
of architecture role it's really
thinking about how you help people make
better decisions so if a lot about
architecture is about making decisions
your goal is really about education so
you help people make better decisions at
a time where it really matters and this
really means that you have to avoid
making decisions for them so change away
from centralized governance of having an
architecture sort of person that
approves or disapproves of the decisions
that you have instead see that role as
an enabling function of helping people
really understand why we're building the
things that we do in order to reduce
coupling in order to improve fast
feedback and to help us evolve our
architectures over time now there's a
lot of reasons why evolutionary
architecture doesn't really work out now
I'll talk about some traps that you can
actually fall into the first one is the
last 10% trap so if you were sort of
around in sort of the late 80s Early 90s
working in software you probably were
working a lot with sort of four GL's
right or model driven development or
graphic driven development the idea that
you can have a tool that allows business
people to drag and drop blocks and then
you generate the systems that you want
now if you ever worked in one of the
systems like this like you've got 80% of
the way with these tools it's an amazing
productivity boost right you can
actually say hey look at what I've done
in like a couple of weeks and and you
can actually start to understand the
flows of screens or sort of data that
you're actually capturing but over time
what you'll actually find is actually
that extra 10% more over that 80% this
extra feature that this business really
really wants that's critical you have to
start doing workarounds around the tool
and you start doing funny things that
are not really possible or was designed
for in that particular tool and actually
you find in that last 10% you just find
it's impossible to actually be able to
do that in that tool because it was
never really designed for it and it's
one of the reasons why we've dropped
back into sort of through third
generation languages or being able to
actually do the things that we can
rather than being stuck in these tools
or abstractions that prevent us from
actually solving business problems one
of the other traps is really this idea
about coding via configuration so I hear
this a lot with say messaging buses is
that well we can just throw a
configuration into the bus and it'll
take care of our transformations and
it'll be really easy for us to respond
to business needs and one of the
interesting things about configuration
is that it gets really complex over time
so the point where it just gets like
treated like code and if you're actually
doing this in some proprietary tool
through some sort of user interface or
through some sort of configuration
scripts you actually starts would need
to work out how you get files feedback
and confidence about your changes and
then you start to realize we need to
actually treat our configuration like
code we need to actually source control
configuration we need to be able to test
this thing release it into different
environments so we get confidence that
actually is configuration is like code
and we get to the realization that we
need to actually treat configuration
like code and not just have these things
that we can sort of change really
rapidly the other trap that we often see
is this thing around product
customization so you know it's all well
buying products and there's nothing
wrong with that I think the question is
about how much you're customizing
products according to your business
process of what you need and one of the
traps around this is that you get
trapped into whatever your vendor
lifecycle is about the changes that you
want to have and so your business will
often be constrained as to
what things can be done when by these
sort of products products and how well
they can be customized but also
hamstrung through the versioning around
it as well
so if you install some sort of products
on site and you've got some level of
customization and that vendor is
releasing new versions for that product
they also have to think about how do
they support your features and make sure
that they can sort of reliably upgrade
it on your sort of premises and it gets
to a point where the types of
customizations that you have just
unsustainable and so our recommendation
around this is if you adopt products as
a service you really want to minimize
the amount of customization you have and
change your business process to be in
line with what the tool has rather than
really trying to change the product and
at its core you use the product for what
it brings take advantage of it but don't
try to make a unique sort of competitive
advantage from your side now the final
sort of trap is really the idea about
exuberant coupling and it's one of those
unfortunate things where we talk a lot
as developers about cohesion and
coupling but often I see a lot of teams
not getting to the point where actually
measuring coupling and cohesion so one
of the ideas behind this is really
thinking about how cohesive are parts of
your domain in your sort of code base
analyzing that through static analysis
and trying to also analyze how much
coupling there is between services and
sort of modules in your sort of code
base to see if you can actually separate
the types of coupling now I don't have
enough time to talk about the different
types occasioning coupling but there's
actually probably about seven of each
cohesion and coupling and there's a
different order as to which one you
actually want to have which will
actually enable you to have a better
ease of change over time so evolutionary
architecture is not for everyone and
it's a question about where you use it
and so like a good consultant it really
depends all right so when we're actually
thinking about building systems or
building something new for organizations
we often end up in this dilemma of build
versus buy so it's an either/or choice
in reality it's a bit more of a blur so
nothing is ever really that binary in
that sort of sentence and when we're
actually starting to think about new
projects one of the pressures that we
have is how quickly can we go to market
and think about the things that we want
to have so when we actually are
evaluating everything from custom code
where we get to build ever
all the way up to sort of pre-built
products we actually think about well
one of the features that we get and how
quickly can we go to market so with
custom code we have to write a lot of
code in order to get the features that
we care about but this product does
exactly what we need rather than just
looking at this choice through this lens
we need to apply a different lens as
well and sort of think about what's the
ability for us to change that over time
as well so with custom code we can make
it do anything we want because we have
the ability to design that but our
product that we have from a vendor it'll
essentially be that product at the end
may be slightly customized but not be
significantly different and so we need
to actually make choices when we're
actually architecting and building
systems about which way we go in terms
of the build or buy and the style of a
development that we care about and so we
have a Magic Quadrant here we have
things around value generating and the
need for change and so I'm not saying
that you really need to think about
evolutionary architecture for all IT
systems there are commodity systems that
we really shouldn't be building so if
any of you out there are probably
building your own operating system your
own email server unless that's your
business it's probably the wrong choice
so these are the things that we don't
need a lot of change for we upgrade when
it's available but they're also not
value generating to our business we also
have support systems so things that
don't really help us earn money but
things that we need for us to work
together so ticketing system is a really
good example of that
so JIRA or helpdesk schools then these
sorts of things we need some level of
customization to be able to respond but
it's not our key sort of sort of systems
that we really want to be evolving
rapidly for sort of change there are
also sort of systems that we want to
sort of potentially of high value but we
really don't know if there's appetite
for it and these are what I would call
experimental things right so we don't
know if this is the the bet that we're
going to go into market with but if it's
not we're not really going to invest
anymore in it we don't really care about
the build pipelines we don't care about
the change if our bet actually fails
instead we really should be thinking
about what are those strategic systems
those things that add value and those
things where we're going to need to
support change as our business evolves
things that we'll need to worry about in
terms of technical upgrades as our
ecosystem evolved as we have new
programming languages new frameworks but
also supporting new change that the
business want to have and this is the
argument around where I recommend you
think about evolutionary architecture
and the practices so if you have a
strategic system then you're not
thinking about the practices that help
you evolve that architecture then
perhaps you might end up having
difficulty changing that architecture
over time so hopefully at the end of
this talk I am sorry to my animations
hopefully at the end of this talk you
now understand what evolution really
tetras are their architectures that
support incremental guided change as a
first principle among multiple
dimensions now when you go down this
path it's easy in a software development
context to think about just architecture
and software but I challenge you really
to think about your architectural
choices and also the decision-making
processes and thinking that go on in
your organization as well as the
organizational cultural aspects that are
fetched the way that you build and
evolve your systems thank you
yeah thanks a lot for the great talk so
we still have some time for some
questions how do you find the balance
between developing a good architecture
which takes time and a quick start with
simple application that just works so
how do you find the balance around that
I think part of it is knowing about what
type of quadrant they're actually
building so if you're an experimental it
might make sense to actually just throw
something up there but if it's a
strategic system then you need to
recognize that it's now become a street
part of your business that's where you
actually want to sort of evolve so I
think what happens is often if something
is a successful experimental thing you
end up with sort of throwaway
architecture that you might want to
start again and you need to sort of
capture that really early so once you
actually realize that your experimental
system is now a strategic competitive
advantage that you want to sort of
support lots of change that's probably
where you need some time to make sure
that you used to reinvest in thinking
about the architecture that you're
building and also the processes around
that okay in projects designed upfront
they're usually design documents that
give context for why certain decisions
were made how can this context be given
in an evolutionary architecture yes sir
it's a good question I think one of the
interesting things that Michael Nygaard
so author release has written about is
this idea about architecture decision
records and the idea is that there's
sort of lightweight documentation that
sits within your code base or near your
code base that talks about why you
picked a particular boy why you made a
particular decision and the constraints
around that so I think what's
interesting about that is that it's very
lightweight so that price I think wrote
a ADR tool that you can just run in the
command line and it just produces some
sort of file that you can check in and
then you can have a sequence of that and
so what you really want to have is
something lightweight that people can
sort of refer to that's close to the
code base I think also there's a bit of
a cultural side of making sure that you
spend some time to review these at
certain points so I think the hard bit
about working in very iterative
incremental is that you need to
sometimes take a step back and actually
think about all these small decisions
that we've made
if we look back at that have they been
the right choices as well and by having
them sort of documented in a lightweight
fashion hopefully you can review them
and work out if they're the right
decision okay so this one is probably a
good one who keeps the overview of the
architecture if the I attack I hit X are
restricted to teaching roads it's a good
question I think this is where your
automated functions really come into
play as well right so whatever system
you end up with you really shouldn't
care about the shape of it as long as
you're getting the characteristics of
the system you care about and so as long
as you can actually start to think about
defining automated versions of the
traits that you care about
you really shouldn't care too much about
the overview because that will
constantly change you might be able to
do things depending on the size of your
organization around scaling that and
having sort of an overview of people who
come together and sort of reflect on
what the diagram is but I know that in
sort of larger organizations it'll be
impossible one person can't really keep
in their head the interactions of all
different types of services about what
people are working out but as long as
each unit and capability is being able
to deliver the changes they need in the
pace that they care about it shouldn't
matter about the sort of overview and
one person having that okay I understand
that you are not on an twenty six
payroll for too long but still so that's
that's a bank or no and obviously there
are security issue challenges around
that and you don't want to have any
vulnerabilities so how does that
influence what what you just talked
about and how does that influence I
textured work in general yeah so
obviously for us this banking security
is very important and I think one
exciting thing about what the team has
actually built I've been there now for
about two months so I can't really take
credit for that team has done is that
they've spent a lot of time sort of in
sort of automation right so for us to be
able to invest in that is that security
won't really scale if you have people
handcrafting things so you have to rely
on a lot of automation and I think in
our sort of spaces infrastructure is
code there's also a whole bunch of work
around sort of automated security so
there's something kind of dev set which
is sort of coming up which is like
instead of DevOps it's Devon Security
about how do we actually bring that into
the sort of the teams there's also a
sort of cultural side to it again this
which is
working with the teams very early on to
understand sort of threat modeling very
early on when you're actually building
features to understand what are the
things that you want to avoid and making
sure you you sort of catch those errors
before it becomes a problem very early
on okay final question what does n 26
stand for so there's um if you have a
Rubik's Cube there's 26 moves to sort of
solve a Rubik's Cube and the idea is is
about solving something that's complex
in the most simplest way and so that's
where the number comes from which is
we're trying to solve banking that is
typically seen as a very complex thing
in the most simple way that you can use
an access based on your mobile phone
okay thanks a lot thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>