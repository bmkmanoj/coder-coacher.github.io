<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Conquering Time with Functional Reactive Programming • Sergi Mansilla | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Conquering Time with Functional Reactive Programming • Sergi Mansilla - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Conquering Time with Functional Reactive Programming • Sergi Mansilla</b></h2><h5 class="post__date">2015-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gT6il5fJyAs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it is a short talk made to get you a bit
excited at FRP reaction reactive
programming or reactive programming
these are two different things with
today we're going to talk about mainly
reactive programming how many of you
have some experience with it alright so
some people already had some exposure so
reactive programming is a hot topic as
of late especially with just such things
as the reactive manifesto and I think it
was Coursera made a massive course in
Scala by one of the authors of Scott was
the author of Scala marked another
scheme so it's kind of it's it's it's
getting traction I'm going to talk about
functional reactive programming applied
in JavaScript and it's going to be very
practical I'm gonna gonna go through a
theory which there's a lot so I am yeah
I'm sorry Monsignor that's my Twitter
that's my github I have a lot of
projects I collaborate on many
open-source projects before I used to
work at TomTom making the web key dua of
the devices there's three devices of
confirm that use javascript to control
the UI now they use their back to using
Android and then I worked at cloud9 IDE
which is an IDE online the runs in your
browser currently I'm working at Eleanor
that's a Scandinavian telco but I don't
do anything related to
telecommunications I work on Firefox OS
with Mozilla and first of all let me
apologize but apologize about the
shameless link baiting that I done with
the title
I mean conquering time with FRP is
pretty grandiose and ambitious but my
first title was something like that so
we should be grateful at tame your
racing code which is one weird trick so
we're gonna talk about time anyway
human beings half-time hardware in their
brains we know about our appointments we
know what happened yesterday we know
about our birthday everything is about
time we have to meet a friend at a
particular time a specialization of
human beings which is which are
JavaScript developers have heard we're
hardwired async in their brain that's
for many reasons JavaScript has only one
thread most of the interactions you do
in JavaScript has to be have to be
asynchronous if you don't want to blog
UI you probably are familiar with the
with the reasons the thing is JavaScript
deals with a lot of a synchronicity but
it didn't come with any way to make it
easy so we came up with all kinds of
constructs to deal with that time
annoying time concept we came back with
callbacks which is the rawest most basic
no GS chosen way of dealing with
asynchronous stuff you just pass
functions and call them when the
function that executed before is
finished promises are an improvement I
mean that's an opinion but that are an
improvement over callbacks because you
at least have a handler on the on the
time-related task and now generators are
coming generators are cool they are
going to change everything about
JavaScript because they are extremely
powerful and they allow you to go back
to a synchronous way of programming kind
of then we have events but in reality
everything you do is synchronously could
be call events because whenever a
function comes back is an event whenever
I promise
executed then cause it's an event so
it's all events it's all things that
happen on you want to do something when
they happen we use events to deal with
all the synchronous tasks so I will I
will start with my first example being a
JavaScript event
for those of you that program JavaScript
usually there's a very familiar code
that's an event listener for a click
event what it does is count it loads the
coordinates of clicks that happen on the
right side of the screen but only the
first 10 clicks then it stops like
that's all we want to do but we don't
think about it anymore because we do it
all the time but look at this code I
just want to lock clicks on the right
10 times there's a lot of code why are
still micromanaging code this kind of
code especially it's not that I want
some precision because it's a very
performance sensitive task
I don't there's absolutely no reason why
I have to write so much so let's go back
to the code what I really want this code
to do the really meaningful lines are if
clicks is less than 10 that means like
only log 10 clicks or only do it for 10
clicks if the coordinates are the right
ones which is right side of the screen
then just I put do some side effect and
output the x and y coordinates that's
all I want from that code now you might
be thinking well that's not that bad
it's not isn't horrible code but now I
want to add another condition to that
code and I want that all this only
happens that the only locks the clicks
when the a key is pressed another simple
condition that's what happens to the
code and if you have a better way to
tell me but what I have to do is that
two more event listeners one four key
down here 140 up next row variable is a
pressed which is initialized to false
whenever a is pressed whenever I do key
down is press it's true and then if then
I click I check for that condition
everything works but is a lot of code
and very complicated and the thing
I've heard that probably I'm familiar
with it but if I suddenly I take this
computer you've never seen that code and
I give it to you you will need some
minutes to know what this is doing or
why am i doing it and that is because
nowadays al is in JavaScript and in for
the web we still code the how instead of
the what the what is what I want to do
the how is how the computer should do it
so this code I'm telling the computer
exactly how to do that I'm telling you
okay now register this event listener
then remove it if the clicks are less
than 10 this is it has nothing to do
with the task at hand which is like log
the first 10 clicks programming should
be more about the what programming for
these kind of tasks I'm not talking
about programming micro processors we do
have to be very precise very fast for
these kind of tasks we should be able to
just say like log this lot the first 10
clicks as succinctly as possible without
living memory leaks because when you
don't remove an event listener it's a
memory leak and stuff like this so
programming should be more about the
what that woman knows well the other
thing is state is dangerous how many of
you are familiar with functional
programming
alright state is dangerous the more
staid you keep in an object or whatever
or whatever started from in more state
you keep the more risks of somebody else
some in your program modifying the death
state and ending up with with
unpredictable consequences it's
dangerous
we're talking about a very small program
here we really have all this state
everything that circle does its state so
we need a variable to register the
clicks outside my event listener if
somebody else in other part of program
modifies this variable
the program doesn't work as I expected
more then I have to take care to update
this clicks I need another variable to
register whether a is pressed and then I
have to modify to true or false all the
time depending on whether a spread this
is not good we have the smallest program
and we really have all this state
risking you know for example here I
don't reset clicks - I don't reset kill
exhibit I there's already about you
could count it as a bug but you know
it's not really but it is depends on
that how this program evolves these are
potential bugs that will happen at some
point then the reason are seen which I
call event limbo it's not that kind of
limbo but if you have to take something
away from this talk it should be the
following these record exists david
hasselhoff do the limbo dance that
really is out there event limbo what is
it
our poor events are one of the most
important parts in JavaScript whether
you didn't know it is whether your front
end back end it's all about events but
they are not really first-class citizens
an event first of all it's stateful by
default an event you cannot you cannot
do any side effects for an event it
doesn't make sense whatever value you
return from an event doesn't matter you
can return whatever nobody will pick out
this value ever an event just is there
to make to do side effects also you
cannot pass an event an event stream I
should say you can pass the event object
but you know what do you do with this
not much what you want is to isolate you
know first of all to have a handler to
the event because in this example when I
click click is very synchronous code
that's for sure
but imagine that was an ajax request
from the moment I send the event for so
let's do it with click from them when I
click to the moment my
function gets executed doesn't have a
handler to the event so I just hope for
the best
they just say like listen to click
whenever you click just execute this in
case of Ajax I would do like do this
request when it's back to this in the
meantime I don't I don't know where this
function is I don't know where the
callback is the developer is kind of
helpless until the callback is executed
no feedback nothing but isn't that the
problem the promises try to solve kind
of so promises are good for solving
asynchronous operation such as querying
a service with an XML HTTP request where
the expected behavior is one value and
then completion or go to the next
promise so something like that here on
the upper side of the of the diagram
have the synchronous person which is
just assigning functions to variables on
the right of that right we have the
promised way we do FA Singh or G icing
and then we execute when this is
completed so what I'm going to introduce
today which is Rx is it's a it's a
reactive framework that allows us to do
what promises do but with streams of
events the equivalent will be imagine
that you have an array of stocks that's
the lower the lower part of the picture
you have an array of stocks you just
filter by symbol the Facebook symbol and
then you map it to whatever quote that
that stock has whatever value has and
then when you have that you can iterate
right how many of you are familiar with
filter and map operations most of you so
what's happening here is that on an
array we filter whatever has the symbol
Facebook returns true so only the values
that have
we'll go to the next stage which is the
map and the map replaces the symbol the
string FB and that case by the court
that's pretty awesome of a race but the
weather Erikson's allows us to do is the
same exact that's real code with
asynchronous retrieval so in that case
stocks is not an array let me see this
stocks that's not an array that is what
we call an observable this is an
asynchronous operation that might have
that that has not happened yet this is
an eight-six request or user input
whatever whenever it happens we'll get
the results so to understand that better
what I'm trying to say is that reactive
programming energy is in particular is
all about stream of events so how is how
does an event work this is you know my
way of drawing what happened when a user
clicks the screen so whenever I keep
clicking the security the screen the
computer gets this it gets one click
then another one then maybe one hour
later another one what does this look
like what if we put some brackets around
it put some commas between the clicks
that looks like an array what is in a
raid our raisins is a sequence so what
we want to do is to see our events and
by event I on I know that I mean
JavaScript events but anything is
synchronous as a sequence not as a
single event we don't want to deal with
this click and this click we want to
take the whole sequence of clicks and
operate on it and be able to take this
sequence and pass it around capture it
and clone it under stuff with the
sequence that cannot be done in in plain
JavaScript
the best programming style to deal with
sequences is functional functional the
functional programming is very good at
dealing with lists of items transforming
them passing them around so we have in
JavaScript we have stuff like this we
have an array of numbers we filter it by
the ones that are divisible by two we
add a string and we log it this function
I'm passing at no point there's state in
this whole operation there's no external
state I don't keep anything I just keep
passing and transforming the initial
sequence into a final output
I'm using es6 by the way that's why you
don't see function names or anything
like I'm using arrows it's much better
for presentations code it's everywhere
very nice if there's any doubt about the
code just let me know so we haven't
solve anything yet this is very obvious
this synchronous code and very easy to
to grasp in the way what is good a
discreet asing event stream processing
is FRP if you look for FRP online you
will might not find the right reference
at that for at first you will find final
resting place that's that's true in
google
fantasy role-playing does not what I'm
talking about I'm talking about
functional reactive programming and
there is a very cool concept that or
image visual image that shows reactive
programming in a second how many of you
have ever used a spreadsheet most of you
obviously we all have
in Excel you making whatever you think
in Excel or whatever spreadsheet is you
might think anything about that program
but Excel got one thing amazingly right
first of all is the most people say like
JavaScript is the most extended
programming platform in the world
because other browsers run it no js'
everything starting to move to jobs you
know the most exciting programming
platform in the world is Excel everyone
programs in Excel
my dad programs in Excel just puts
formulas and formulas and things work
and as a developer you might make fun of
it but Excel has one amazing feature
which is this in Excel you change values
and a value that has a formula referring
to these values changes automatically
the C cell has just the I think the
addition or the multiplication of AMD
whenever I change a or whenever I change
we see changes I don't have to tell
Excel when arian be changes agents orbit
changes in any case update yourself by
adding these three so nobody has to do
that you just know that you just put a
plus B whenever you change it it works
nobody instructed Excel nobody
registered an event nobody told the
program step by step what to do when
cells change and that's very easy to
cross imagine that Excel didn't work
that way nobody will use it if you have
to do any programming that's why it's so
popular
doesn't really want it to do yeah so why
don't we why don't we program like this
why don't we at least have the
possibility to program like this why do
we have to painstakingly tell everything
that's gonna happen deal with every race
condition every edge case that exists
and only then our program kind of works
and whenever I want to add a feature
it's more painstakingly adding stuff to
the code so what do we want to do on one
of the hardest things in computer
science right now is deal with values
that change over time properly without
complications Erick's this is a symbol
this is the logo for RX RX is a platform
that was made by Microsoft amazingly now
sometimes it's easy to forget them some
good stuff comes out from Microsoft
still Eric's was made by Microsoft open
technologies and open source and the
cool thing is that here I'm talking
about our XD yes JavaScript but almost
for every language there is an ax Rex
there's an Rx for Java for dotnet for
Ruby for Lua for all kinds of all kinds
of languages an Rx helps us compose the
synchronous and event based programs
let's take our previous example there's
three things I wanted to do with my
clicks I wanted to limit them to 10
clicks limit the whole thing to thank
legs I don't want anything else I just
want the first thing I want to filter
them by coordinate and I want to
eventually print the coordinates these
are previous code this how you do it
with our eggs in our eggs we say from
the event click in the document filter
by these coordinates take 10 of these
results once
his son subscribe what is happening is
the first line creates unobservable
which I will get back to it in a moment
about what it is from that observable we
filter so we create another observable
that contains the filtering from the
first one create a final observable
taking only the first ten results and
actually kick off the computation so
until I subscribe nothing happens I'm
just declaring what I want to happen
when there is a subscription now our X
has two main types there's other types
but they rely on those or I or our
specializations of these two there's an
observable and unobserved you can think
of the observable class as a push
equivalent to a terrible so an iterator
in other languages in JavaScript we
still don't have them but in our
language is just an object which to
which us
next item next item next item and I
think this this I traitor contains a
collection you asked for the next item
until its it says like there's no more
items and then it's completed or throws
an error and in the meantime the
observable is like this but instead of
pulling from the from the collection it
gets the items push so the observable
would push to the observer whenever it
has items whenever it receives a request
whenever the user clicks it will push to
the observer the observer doesn't have
to do anything just has to wait there's
only three methods on an observer which
is unnecessary
same kind of methods as Anya as in and I
terrible but with the particularity that
they get caught so the observer type
adds the ability for the producer to
signal to the consumer that there is no
more data available in that in that
regard you can think of the observable
is a very simple concept you can think
of
as a fusion between iterators and the
observer pattern the good old observer
pattern right observer pattern you just
have one object that has all these
listeners whenever something happens
call the listeners but the observer
pattern doesn't have the concept of own
complete and on error
it just keeps passing stuff the idolater
has this but what it doesn't have is the
ability to push values to the customers
the customer has to have to add have to
ask for them so this a little bit more
code I try to keep the code simple RNGs
has a lot of operators or methods here I
show range you have all kinds of tools
to manipulate create and transform
sequences in that case is very simple I
make a range from 1 to 5 and I subscribe
to this if you see in the SUBSCRIBE
method I pass your next function which
is the first one on error second one and
the third one is completed of course no
errors will happen so the output I get
is all the values of the range and then
uncompleted
so this is exactly what we expect the
important part here is I am assigning
this to a variable from this variable I
can pass it I can clone it I can create
extra observables that don't modify the
parent this variable is final but at the
same time is a stream that changes
whenever new values come let's see
something more interesting this one is
in our example I create unobservable
from a mouse movie then I create another
observable from this mode movie event
but this one Maps the event to an object
with the coordinates
I create yet another observable called
Mouse ID which maps the first Mouse move
- it takes a coordinate and outputs
either right or left and then I
subscribe to only the coordinates this
will output objects with coordinates
this will subscribe to the mouth side
this will output right or left depending
on wherever I move the mouse and this
will be updated real time these two
observables the three of them will be
completing dependent they will update I
don't have to do anything else to lock
all these coordinates and to do all this
stuff of the mouse now real world
example or can this this might look like
a lot of code but is very simple the
first function just retrieves creates an
observable that retrieves the term from
the Wikipedia you see I have the URL so
you pass it a term like whatever I'm
sure damn it and I create an observable
that has instead of the methods we've
seen it has guide JSONP request this is
some normal query selector step now this
is pretty cool key app will contain the
stream of events of Kea but not only
that I will get the target value so the
value of the input field where the text
is longer than - I don't want to
retrieve one character I will throttle
200 milliseconds so that the user if a
user types very fast I don't send a
million requests to Wikipedia and what I
will only accept distinct values so if I
move the cursor the cursor keys which
don't change the value of the input box
I don't want to send new requests so in
three lines we are filtering we're
throttling threading is hard in in real
JavaScript and I will only accept
distinct values and now on the earth on
their hand so here I have I get the
input of the user
on the other hand I get Anki up so I
subscribe to this key event that we call
it searcher which isn't will be another
observable we map it we map its value to
the actual Wikipedia retriever so all
these looks synchronous but is highly
highly highly synchronous these
registering the key is the key ops from
the user searching in Wikipedia then we
have another method called sweets latest
which only will accept the latest result
that arise what I don't want to is too
you know some of the terms it happens
with the synchronous and that's one of
the hard things I can keep typing on a
search box on the latest result is not
the one that I was asking anymore so
it's not the one that that it
corresponds to the Texan I'm putting it
synchronous is chaos so anything can
arrive right sweets late this ensures
that I only get the result that is the
last result that I want so whatever the
text corresponds to all the others are
discarded and I also just filter by data
lengths to which means where we have
data because that's it returns an array
we subscribe and which we just do
whatever we want with the code and
that's the other webpage around but I
don't like demo effects so that's what
happens this is and there's no more code
like there's only the HTML code to make
the input that's all to make real
requests to Wikipedia real-time throttle
distinct making sure that no mix results
come another cool side effect comes from
the fact that I can abstract stream of
events into variables and is that this
code usually or what this code does will
be held to test
asynchronous code is very hard to test
people started making mock-ups with set
timeouts and stuff like this it gets
hairy very very very quickly and almost
always there's bugs in the test as well
so the cool thing is that you see the
first term search Wikipedia which does a
real JSON request I can just do that
just make up an array but because it's
an observable everything will just work
and still keep a synchronous there's
even another thing that I didn't I
didn't put on the slides which are I'm
not talking about it and talk because
it's it's more an advanced topic but
there are schedulers so what I can do is
any observable I can attach any
scheduler to it tell it how to behave in
time so even if I have a for example if
I do an observable in an array the
default scheduler is the current thread
so it will go instantly like we expect
synchronously but maybe I don't want
this a rate to behave synchronously and
I can attach the scheduler that
separates the results by 200
milliseconds I just attached an
scheduler 200 milliseconds and
everything will be a synchronized then
we have a test scheduler that simulates
a synchronicity so in that case in this
from array
the second parameter I could just attach
scheduler that delays that or that
intercession or random a synchronicity
and we could test for a synchronicity as
well so testing becomes very easy no
mocking know anything just changing to a
different scheduler and you can test
anything we saw from array from event
there's more some that I miss you can
create observers from callbacks from
node callbacks because of course you
know all this is very nice but you will
have to deal with third-party libraries
you might want to test it in a project
you have but you don't want to convert
anything to the
our exes religion so you can convert to
and from observables from not callbacks
from event patterns you can define your
own observables all kinds of stuff I
want to show another example that a
thing is pretty cool because until now
we haven't seen much UI the input one
was a bit of UI but this one is really
nice
so to program in reactive programming
you have to change a little bit the way
you think you have to think in sequences
so a mouse drag and drop is a sequence
there's different sequences
there's the sequence of mouse down
there's a sequence of mouse up and
there's the sequence of mouse move these
are three different sequences that
happened in time like events happen so a
comedic I can make a code that says you
see here I subscribe to the events he's
not very interesting mouse drag is a
mouse down select many is basically a
concat all in an array so imagine you
have an array Narae an array of arrays
and it just normalizes it so it makes it
to an array with values it takes out all
the inner arrays select these are
coordinated calculations and then I can
do like we turn the mouse move but take
only the mouse move until there's a
mouse so what is happening here I'm
telling I'm composing stream of events
I'm saying like subscribe to Mouse down
whenever a mouse an happens inside the
Muslim event check the mouse moves only
do all this until there's a mouse up so
take until now that remember that before
we use take to take values to take
amount of clicks we can also use it to
take Mouse appearance because
both are observables so when you think
of in sequences code becomes that is in
that code but that code does is oops
the following now let me see yeah I have
it here doesn't fit very well the code
you've seen is where's my mouse here
it's this it's a bit strange but I we
have the master arc we find here mouse
move taken to Mouse app what happens is
it I just have I just have normal track
cool thing is have normal drag without
there is no state there is no state that
said Mouse right I'm not keeping my
variables around outside the closures to
control what when is the user clicking
when is the user unclicking and this
kind of stuff there's no safe it's all
functions and functions and observables
being passed I don't have to unsubscribe
I didn't have to do anything like that I
just deal with sequences rxjs does
everything in the background one thing I
get I always get us is about performance
as a JavaScript developer you probably
know this is the normal array example
now observos here normal JavaScript
whenever you do that this is very easy
or very nice with ten items but what's
happening here really is that so
the first filter function loops through
the whole array the map function loops
again and the final for each to print
the item loops again so if instead of
ten items I have a hundred millions
items that is a performance bottleneck
so whenever people see these observable
stuff at everything everything
everything is a sequence that we I trade
on
that's the first question like how
performin is that that can be that can
be good whenever this happens I take my
slide my cat slide out this cat is
pushing a watermelon out of a lake and
your argument is invalid what happens
here this is the observable example and
as I said before if you didn't catch it
we do we convert it from the array we
attach the filter function we had a map
that multiplies we attach another map
that composes a string but all these
have has not executed anything yet it's
all the clarity the only thing that
executes is subscribe but what you have
done in this until the up up until the
subscriber are exist has done in the
background is composed internally so
that there's only one loop and this one
loop executes all the instructions so
it's very very very very very fast as
fast as looping one time with the
overhead of calling functions but that
doesn't really count so it doesn't yeah
it doesn't process the items for it's a
terrific method the things to take away
are that reactive programming allow you
to make the events into first class give
events that the power that they require
events are nice but they get messy what
we want is to be able to pass stream of
events around easily I to rate over them
transform them we want to compose them
as well want to just filter map do this
kind of stuff over all kinds of of of
event streams and encapsulate we don't
have state we want things to be on their
own and not manipulate state events
inherently whenever you use events
you're using state there's no way around
it either that or you're doing very
little with the event like console
logging something you're always side
effecting that's bad especially in large
application
now who is using that there's there's a
lot of buzz with reactive programming
but most of the frameworks that are
there are pretty new not that much used
in production I'm kind of experimental
there's good stuff there's Facebook
react is kind of reactive but not really
the same concept there's bacon Gia's
there's an hour FRP framework same as
there are X is some differences in the
philosophy it's pretty new the cool
thing about Eric Z is is that is based
on our X Netflix the whole Netflix stock
now the server is running Eric's Java on
the client is running rx is if you use
Netflix that's our X or happening
Microsoft obviously they created it they
use it on all kinds of projects
SoundCloud is using it github uses rx
cocoa for their mock up an erector net
for their Windows app so it's very solid
it's very stable real companies are
using it and they are benefiting from it
well everybody's dealing with crazy
asynchronous models I'm trying to tame
the asynchronicity of it all are exists
makes it much much easier and I think
that's all I've got for today so thank
you very much
I don't know I don't know if there's any
questions yes the question is how would
you ice or MVC for example work with our
eggs is the way the way to think about
stuff is what is reacting in the
model-view-controller the view is
reacting probably the control is more
producing values so basically the view
subscribes to controller in that case
controllers are observables whatever I
know the user makes makes it with the
model yeah
the controller was the model will be an
observable the controller will be
aníbal observe the model and the view
will observe the controller that's how
we could should work then what I didn't
talk about in the talk there's another
kind of entities called subjects which
inherit from both observable and observe
of an observers so they can do both at
the same time then the model in that
case would be one of those because it
will the view can change the model so it
could be will be kind of a circle of
listening and reacting to each other I
think that's from the top of my head
right now all right
then I think that's it thank you very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>