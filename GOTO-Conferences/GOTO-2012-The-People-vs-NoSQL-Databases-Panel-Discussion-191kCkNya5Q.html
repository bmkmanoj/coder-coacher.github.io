<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • The People vs. NoSQL Databases • Panel Discussion | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • The People vs. NoSQL Databases • Panel Discussion - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • The People vs. NoSQL Databases • Panel Discussion</b></h2><h5 class="post__date">2012-12-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/191kCkNya5Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and the general manager for via in I was
enjoying yelling the general manager for
a me and bash out of technologies for
the makers react where bassist our
European headquarters in London that's
where you'll find me I'm Jim I worked at
near technology and in London office
just we like great with Chris Anderson
I'm a co-founder of Couchbase I've been
doing core engineering on the project
since 2008 and it's a pleasure being
here I'm Alan Richardson syndicate our
extra attention and make us a MongoDB I
spend a lot of time in California and
I've been in Europe to six months and I
can't remember what sunniest acts but I
represent the right solution for the
right bubble okay I'm Martin Fowler I'm
allowed manner for thought works I am
not associated with any particular
technology although we have used several
of these at the table and I'm here
violating an important rule of
performance because it's a well-known
fact that you should never perform with
children or animals and I'm on a panel
with Jim Weber
that makes me a coffee okay so thank you
everybody so I prepared two questions
before we kind of open up to audience
questions and the first one is is based
on you know you know at this conference
we've been talking for the last 15 years
about different software methodologies
you know then it was clear case and this
and that and that gel and one thing in
another and you know in many cases you
got the impression that there was a
publish single projects where they
actually had some good people and they
were successful and so one of the guys
in that project went and wrote a book
about how they develop software and try
to impose that on everybody else as the
method of developing software of course
trouble was you know wasn't the same
people in the same customer and the same
organization in many ways so so often
these at these early attempts of doing
software Methodist's in many ways fail
because it just was put in puts used out
of context so I'm thinking the question
here is actually say the same question
but we phrased for these technologies
the doober the centre-right goes like
this they can so maybe you can kind of
describe the first use case or driving
idea or the customer both of what was
the thing that ignited this thing what
was tough and I know now we're probably
three or four five years down the line
in your in your product development and
you have a nice shiny marketing story on
how this can solve all the world's
problems but I'd like to hear dig in a
bit and say what was the what was the
original use case over the driving
motivator for doing this what was
keeping you up at night hacking away
when you did the first or this first
person was being built maybe your
network of sensitive for actually
implementing the first
but at least to know the story most
likely so I don't know who want to start
if you want to go down the line the same
where anyone so our first customer and
this was really shaped the technology a
lot even before we had any money in the
bank we had a contract with Zynga to
build a scalable data layer for them and
the constraint that matters when your
Zynga is it's a portfolio business you
have hundreds of games and they're not
all going to be hit but the ones that
are hits have to scale smoothly and it's
gonna be a surprise you're not gonna
know that's gonna be a hit until it
happens so being able to turn the scale
knob and have things be super fast super
snappy good user experience and good
uptime and reliability and operability
that and they came to us because we have
a background in the memcache D core code
and project so they don't move cash D is
fast but they wanted it to be persistent
and scalable and so we've taken it from
there the other kind of use cases that
fall out of their ad targeting where you
have to turn around your response at a
certain time based service level
agreements if you have to be fast
that's what tough space is for me so I
Cassandra actually started at Facebook
for their inbox messaging system
basically all of the emails that you're
sending on Facebook we're needing to be
indexed and searched and so Facebook
actually wrote Cassandra to solve that
problem
basically writing essentially inverted
indexes running the system to store and
search those from scratch after that
point they open sourced it after they
were using it for that and was still
very beta quality but working for their
problems Jonathan
our only the founders of data stacks was
working in Rackspace at the time and
Rackspace needed to build a big scalable
internal database for a lot of the
internal infrastructure they had and
Jonathan Ellis basically said you can
either do this from scratch where you
can build on top of this let's build on
top of this and so started a land that
became active in the community and then
ended up with a lot of emails and
messages from other people saying you
know Jesus system looks like it's gonna
solve our problems - can you help us
with that and he said actually I can't
you're a competitor of us anyways go
away and got enough of these emails and
finally he said well let's make a
company out of this and then data stacks
was born for MongoDB is pretty simple
I found that Merriman was the founder
and CTO double-click and so when
double-click is founded in 1996 they
built everything on Java and relational
stack and life was good until they ran
out of capacity on their first Oracle
instance and so in order to actually
scale their business to 20 billion a
observes a day you know essentially they
had to spend only 5% of their budget
building sharding and replication and
all the other technology on top of an
Oracle database in order to scale it and
so when they sold double-click to Google
do I figured that if he had to spend 85%
of his R&amp;amp;D doing that sort of thing then
there was a whole bunch of other people
who were gonna run into the same
scalability issues with the way that
people now want you to consume complete
via you know Amazon's ec2 or other cloud
cloud stories and so 10 Jen's original
idea was to build essential platform as
a service that you go and there you
design your application you have a
persistent store and you know our pivot
point was our first couple of beta
customers said you know we're not sure
about this bit and this bit but yeah
this database thing at the bottom is
really quite awesome and so we then did
the peer
and actually refocus the company on
purely on solving a database book and
MongoDB was born from there so fashion
Basho had a permanent pivot story as
well in 2008 it was a completely
different company it was actually a CRM
company at the time selling some kind of
plugin prospecting tool for Salesforce
and there's 2007 to 2008 the company was
doing this for they're doing this around
the time and they had been inspired to
or been inspired by the dynamic paper
that which was released in 2007 and so
Andy Gross is not here today should be
but I think built the first prototype of
react based on that paper on a flight
from San Francisco to Boston and they
built this dynamo system written in
early and it served them well but in
2008 the market crashed and they were
kind of scraping by and eventually they
just had the pivot it was kind of the
same aha moment like hey we've kind of
built this awesome database we have
nothing left our business is gone let's
pivot and open source this and that's
exactly what happened and the rest is
history
does this mean that you got the last
word then okay so I thought Martin was
the old man of no sequel it turns out
that's not true it's neo4j we first
version was in 2000 predating all of
these whippersnappers
you guys if we're in California right
now angry like near technologies the hot
young startup it's a really kind of
duplicitous message so near 4j is it's
quite surprising backstory so these guys
were building a CMS my god connection ah
and they really found that the API is
they were using was sucky so they built
a network like API on top of the CMS and
bound that to a to a relational store
this CMS ultimately again surprisingly
was I was for the Swedish military
because who the thought Sweden had
a military
all they do is like molest polar bears
for six months of the year or something
oh sorry I just forgot the lots of
Swedes in the audience
Jena Swedes but anyway that's kind of
door because that's what the Swedes did
back in the old days and eventually they
said are this relational database stuff
is killing us for joins but we like the
API we like thinking in terms of grass
it's useful particularly for like
connected data like a CMS and so they
took the decision to to replace the
relational store they were using and
they built a graph native store
underneath it fast forward a few years
it got me fired from a gig when I worked
with Martin for using it for solving in
about six hours what we were planning to
do in an enterprise scale deployment in
three to five years I took it to the
project manager and said hey I've just
saw our product catalog problem we could
now do telecoms product catalog he took
me into the office and he swore at me
vehemently and profoundly and while one
half of me was like wow good words the
other half me was like wow I didn't
expect this so I learned from that I
learned that graphs are super cool and
expressive and they really annoy idiots
i from then on I I'm hooked
and also it got it got me out of living
in Calgary where it was minus 40 Celsius
for some of the time I don't have a
product to talk about
okay well thanks for sharing your
stories so obviously the follow-up
question would be I mean how does that
impact where you can use your product
today and is that maybe I should ask
that question before I mean do you think
having a particular use case for first I
mean being a CMS foundation or being
clickstream foundation of what is that a
limiting factor going forward you guys
are gonna have to try harder to stop me
grabbing that mic
we can never backslide we have users
with time bests or sign based service
level agreements and they expect version
two to be you know just a little bit
faster than version 1.8 and we have to
deliver and so that means that every
time we release it our test cycle gets
that much bigger and it gets more and
more challenging you want to add
features but you can't slow down I like
a challenge but that's that's what means
well well I certainly hope it means is
that we are moving past the days of
one-size-fits-all data stores and that
we begin to see well we have to think
about what is the right kind of data
store for a job for the job and the term
you often hear floating around is
polyglot persistence we have multiple
data stores perhaps even within the
context of the single application now
that's bad in that you know we have to
think about this stuff we cannot just
say oh what's a corporate standard
relational database and warm up to that
but on the other hand it's good because
it allows us to tackle problems more
easily than and and that are even
possible that we couldn't tackle with
other things and we certainly seeing
that on our projects because we're
seeing a lot of cases where we're able
to use a specific data store that
matches well to the kind of problem that
we're working with and we're able to
move much more quickly as a result
if anyone want to come follow up yeah
I'm gonna be I'm gonna break out world
peace so I think all of the models that
are represented here modulo Martyn are
actually you know general-purpose data
storage models and they certainly
certainly you know some models have
strengths in operation availability some
models have strengths in terms of data
experts ippity but I think every
database here you know we're not talking
about MarkLogic are we we're talking
about general-purpose databases that can
be broadly applied now yeah I'm not
saying that again one size fits all I
concur wholeheartedly but anything here
should be a reasonable approximation at
least at your first your first whittling
down for what you want to do and indeed
if someone from Oracle was here do I
point out that they are a
general-purpose database so logic
salesmen would definitely tell you that
there's logic salesmen can go
themselves
okay I'm not so much world peace now so
I think that's a genuine problem that
you know we have these general-purpose
databases and you all represent these
right to some degree right somewhere a
better fit than others for particular
problems but it's really because you
still kind of generally categorize these
as general-purpose then you also attempt
to think you typically do with just
picking one database or any one of them
could probably be used so you kind of
easily fall into this trap of thinking
of these as a database you have this
picture in your mind of what is the
database and this is probably something
very close to that and when you talk to
managers or decision-makers you know
they're asking which database to use for
this and it's really difficult to tell
that story so we really I think we need
some better classification from from you
guys I mean saying we built a
general-purpose database isn't good
enough Jim well I mean I think what
we've all done is that we've all made in
order to get the scalability a whole
bunch of design choices and that means
that those design choices are more
optimum for some use cases than others I
don't think we would say that we're
general-purpose
I won't say MongoDB is general-purpose I
think it's got a a wide range of use
case
but you know if you need a veil ability
over consistency then there are better
options around this table if you need
consistency over availability then I
think MongoDB is a viable alternative is
it general-purpose and I don't think
that's the interesting way of thinking
about the problem I think the
interesting thing about the problem is
what is the use case what is the problem
you're trying to solve and then figuring
out the best technology to fit that
problem rather than say Oh
one size fits all work before I'm gonna
pick one no sequel datastore and just
use that well you're gonna have a very
bad time at some point because it you're
gonna have a technology mismatch between
what you need to do in your expectations
agreeing with that and also saying I
think there are two kind of directions
to look at when you're examining it one
is the data model some data models vary
in terms of what you get from the
different things so you've got to look
at does the data model fit how I want to
interact with the data and the second
has to do with the distribution and
consistency story because again so look
the trade-off that Alvin said there some
of them lean more towards consistency
others lean more towards availability
and and lower latency for the accesses
and you've got to make your decision
amongst that set of trade-offs so I want
I want to put the next slide up because
are you actually kind of diving into
that right now because actually when I
when I talk to people that don't know
anything about Noah school I like to
make this matrix right kind of often two
primary dimensions that you see in these
products one is is this product really
built for online processing all TP live
data is it really built for dead data
for analysis right that's one dimension
the other dimension is is it really
built for single big fat machine that
allows you to do complex queries or is
it a multi machine system that gives you
probably simple queries but also
availability and scalability maybe so I
mean this is just one kind of simple
matrix that you can start off with and
say
probably many of these databases you
could categorize into one of these boxes
I think I think this is our you can
disagree figure so you were leading the
the jury milord this kind of single
machine complex queries multi machine
simple queries well there's another
dimension there that you know obviously
factorial that you missed okay so for
example Neos it's in multi machine
complex query in the general case but if
you want to you know do something
sensible you know lap you just hang some
OLAP read slaves off it and job done so
it's kind of another farming obviously
graphs are very multi-dimensional so we
could graph this comfortably
is that the part where it's actually a
general database in the sense that you
can do both of these and it depends on
the use case yes I just fed that to you
didn't I
yes you owe me a drink when we get back
to London Cassandra I think also fits in
a couple of those places
Cassandra itself is really definitely
multiple machine and at its base more
simple queries data stacks has been
integrating other products with that
which is now an enterprise solution but
definitely fits OLTP and no lab so it's
kind of across the board there
yeah Rioch definitely fits in the multi
machine simple query in the like online
processing not people laptop it's not
good for that it's good for like web web
request latencies and whatnot but
doesn't react support not produce viola
no it does not no we do have a MapReduce
framework but it does all of it doesn't
necessarily serialize anything to the
disk and so persistence doesn't take
place and everything is done in memory
and so there's constraint by memory and
it's not something you want to leave a
long-running request most of the time
what we recommend is that with Rioch
that you really depending on the size of
the cluster in the data set that you
keep a bounded set of keys but to do
like a full data set or to do even a
bucket which still has to go around the
entire dynamo ring we really recommend
against it not to be nice to you again
that backfired spectacularly I mean sort
of MongoDB fits in the kind of multi
machine you know we've got an inbuilt
query processing language it's simple I
would say it's complex like Cinco we
have MapReduce we have an aggregation
framework and so I think it's one of
those places you can do a whole bunch of
computation and store the results for
that but there are some problems that
are great to solve with Hadoop so we
have a connector we can exchange to and
from data from Hadoop if you need that
kind of large scale of aggregation
across those data sets
and so it's blue in the middle some we
were playin buzzword bingo everybody
would have a full plate now you know we
really need I mean us looking at all
this cool technology that you build for
these cloud scale things etc we really
need some you know simple words for
describing what these things do so so
Couchbase answers are your answers are
just well we do it all basically you
also Couchbase is very live if you don't
need your data right now then don't keep
three copies of it in RAM so you know we
have users this was common pattern to
have a Hadoop cluster and we've also got
a MapReduce framework it's an
incremental real-time MapReduce it's
disk based but you're not gonna run it
across your entire history so do that
hindu pan then let couchbase tell you
what's happened since the last time
Hadoop finished the job
I think the origins are pretty small
how in its a sensor that stated the
world that were in I mean if these are
not simple choices I mean there's a lot
of complexity it's not clear what the
trade-offs are because it's still very
new and I tend to listen primarily to
feedback from project people I've talked
to that aren't necessarily connected
with the particular organizations were
selling the slope now you know I'm still
I'm whisked we've got you know two or
three years of using various different
bits and pieces it's still very early on
to be able to tell them to go with and
that's a stated of maturity to market as
the market matures all of these people
will tell you that they can all do
everything because I guess that's the
way which the marketing people will take
over their base we'll see some
consolidation some of these
organizations won't be around in a few
years time and will be kind of beers
commiserating with that that's the
nature of how things go the hard part
that comes from this is the fad we now
have to really think about how are we
going to be able to access the data in
order to help us make a choice it's no
longer the cases say you can model your
data any way you like the database will
just take care of it it'll just do the
right indexes and you don't have to
worry about the physical access paths
we've realized that that's just not
going to be the case for the situations
where you want to use these kinds of
databases and don't forget the majority
of systems are still going to be built
for with relational databases for the
next few years I think one of the
biggest problems that this points out is
that we're referred collectively as the
no sequel group right and I bash oh
there's just this mantra internally that
we hate being called no sequel because
it's a it's a name of where we're you
know a name by the lack of something and
it's like therefore this beer is no
sequel and this water is no sequel and
it's it's really it doesn't distinguish
like it when I have prospects come and
say we're looking at Mongo and react I'm
like because I know it's a huge
education from there and it's not as I
might very well say use Mongo because
what you're trying to do the analytics
the analytics that you're trying to do
and look like a click stream or whatever
should not be done in react and and so
we're I'd like to think that we're
pretty good at saying
yeah we fit in that bottom left quadrant
and that's where we belong and that's
the problem that we solve and then the
rest of time we try to just point people
like I've certainly pointed customers
towards Cassandra which i think is the
most technically competitive product
sitting next to it you know at this at
this table so because we share the same
architecture right so as well right
right I did a store on a single node on
the disk structures or a BigTable
inherited I guess influenced as the word
I was looking for but the replication
model is dynamo based and I think you're
right it's it's not just that we're the
most technically similar one but I mean
I think that's actually a clear win for
the architecture I don't think there are
their choices you you were saying
earlier that there are lots of other
choices for things and I generally agree
with that but like the talk I gave today
said that you have requirements you have
necessary requirements they're not
sufficient but you have to have
performance and scalability and
availability if you're liking any of
those things your system fails and so
that's the things you should start with
evaluate your systems on your
performance does it meet your needs on
the scalability does it meet your needs
and on the availability the availability
being the hard one the complicated one
because if you assume failures don't
happen then performance and scalability
is easy I'm sorry but you know to half
the people in this room could could
solve that problem if you just assume
that nothing fails which is why I like
the dynamo model so I like the term no
sequel because it's a good way to get us
all in a room together and talk and I
like hanging out with database geeks
and I like cider but the you know no
forward-looking statements here but if
you see Couchbase have a sequel
compatible query engine in the future
are we still no sequel and that's sure
would happen and then the other thing
I'll say up shoot me at that point
please I'm gonna I'm gonna I'm gonna lay
down like a little bit of controversy
and you have to understand my background
I'm a web a web programmer you know I
used to just make websites before I got
hooked on this couch stuff and so at
least for that part of the you know the
what programmers do I think the 80%
solution is a JSON document database I
think that we're gonna be standing here
in ten years and someone's can be like
oh a JSON document database that's what
we use by default now and a relational
database you only use that when you're
in some crazy edge case that's where I
think the world's going one of my
favorite quotes was from other chief
architects at Guardian media in London
who said quote relational databases are
dead to me I haven't written a sequel
query in a long time I start nightmares
about him to say they're so up
nightmares about the sequel queries
haven't written one but how many people
do it it's like you have to tell the
database how to do its job you have to
like put little affordance in it like oh
so did you leave clues for each other
you oh yeah
product underscore FK okay I get that
that's like some like identifier for
like some foreign keys for pride okay
and customer underscore FK that must be
the same for customers know that's
customers who have we just list
them into database you're just telling
the database how to do this King job all
the time stop working for the database
people I mean really infuriating it was
a week where I mean I know I'm quite a
kind of sweary kind of guy but I was at
sweary level 11 for a week while I was
working with the sequel stuff how do you
guys just get through your day I mean
you have like 10 more you probably have
state-sponsored like psychiatrists on
top like state-sponsored back rubs every
time like you have to do an inner outer
upper downy join or something
freaks you out how do you get through
the week I mean the weather's miserable
and you're working with tables
sorry have this outburst brought you by
new technology it's funny you say that
actually because I think most of the
databases I want to tell the database
how to do its job that's one of the
reasons I like Cassandra the problem
with relational databases is there's
stuff in between that's preventing me
from doing that when I write a query I
want to give it the physical plan and I
can't do that I have to wait for the
query planner to go optimize optimize it
I want to forget there's a freaking
database like databases should be
transparent and gone and not a problem
that that's where I'm coming from well
again it depends on the nature the
problem you're working with I mean I I
have I do come across situations where
it naturally met the natural fit of
tables works really well and then sequel
is an excellent language for
manipulating those tables I mean it the
problem of course is a lot of people
don't ever bother to really learn sequel
very much well I think this is the
reality though which is most of the
people here they're using some ORM like
hibernate or spring data people don't
write sequel statements anymore there's
some object mapping that hides all the
database complexity and generates ass
bad queries that some DBA has a heart
attack about and then has to reality the
developers never see this stuff anymore
it's it's a myth that's that's the
audience I mean how many here use a norm
and don't write sequel directly that's
the different room so how many people
here write SQL actually write this code
there's more people yeah that's
surprising
oh yeah and how many like it I think you
guys are giving a sequel bad rap it's a
pretty damn useful language to be able
to access data in any configuration any
tabular format that you need and so I
think what's that language wolves can't
live without him I guess I I still
recommend customers to sequel if if it's
their problem with it's the right thing
it's sending to post press or Oracle or
my sequel whatever Postgres I love post
press if it's a relational database it's
all Postgres for me all the time if
everything else but I do have a question
for you actually how do you determine
that that's the right fit for them
because I share that I share the the
feelings in the methodology I do push
people off to other systems Mongo in the
past and right occasionally in quadrant
one usually it's you know analytics
processing that's gonna happen offline
doesn't have a high availability story
tied to it just needs to be able to do
some background work and it's a complex
query that maybe some business analysts
want to be able to do and it might be
what happens is we get back to polygon
persistence right where we say okay you
probably want react or some you know XYZ
datastore up here up front taking care
of this and throw you know these
requests onto a queue post process and
then stick them into your relational
database in the background so that you
can go back and do some bi work on it
later I mean say going back to the
regional premise I think it was the
people versus no sequel right so you
know what I'd like to see is you know
the relational vendors here so that they
can actually see this vast crowd of
people they have corrupted with their
one-size-fits-all story where are those
guys
so we had in still going on like it's
sort of an open community project called
on Q L uncle and its sequel for
unstructured data sequels great it just
assumes things are in tables so if you
figure out sort of a way to drill into
nested data structures and still offer a
similar query language or perhaps even
sequel is a subset of Uncle I don't see
anything wrong with having you know a
text-based keyword based declarative
query language I think there's all sorts
of good things that come of that that's
that's true there are good things that
come with that but there's a lot of bad
things too that's that's my main
complaint about relational systems is
when you have this declarative language
you're not specifying how you want
things stored on disk you're not
specifying how you want to access them
you're not specifying the algorithms and
because of that the query planner or
whatever you want to call it in any
system that is declarative makes crap up
half the time and that kills your
performance and there's no way to fix it
in sequel for example there are some
databases that allow you to provide
index hints and some of those are just
hints and then others you can actually
force them to do it but in others
there's no way to do that once you've
lost the control to do that there
there's no way to solve it I mean I
think to solve this problem you need
strong AI and not there you hadn't but I
would argue that 80% of software
projects that being done
the programmers involved shouldn't be
telling the database how to go and query
the data and that's where sequel is very
strong I mean we're in a kind of weird
audience here the fact that people are
coming to this conference makes them
actually kind of unusual out there
because a lot of organizations would not
pay to send people to a conference like
this they would most people occur
immense and ridiculous figure said
something like and I'm making this up
but it's roughly this kind of feel you
know 70% of programmers you know read
one book or less a year the degree to
which the the average project is out
there they shouldn't be messing around
with going after it's talking about how
to query to date or on the disk leaving
it to the relational database that's
just about right but there are
but the even though it's a minority it's
still a very large number of people who
do care about this stuff and need to
have more sharper tools that are
appropriate for the problem and that's
you know the space I'm interested in the
space we're interested it I actually
agree with that 80 80 percent maybe even
higher than that should not be having to
do this my problem is for that 10
percent of that 20 percent that you have
to do it that there's no option that
that's what I care about I want
something that the JVM does great with
that you know 99% of the time the
garbage collection is perfect you it
never gets any way you don't to worry
about it that's awesome that that 1%
that you have to fight it
is a pain in the butt automatic
transmissions are the same thing query
planners on relational databases it's
it's I want the automation for the 80 or
90 percent of the projects it's that
last 10% that I want the option for it I
want to have some sort of answer that I
can do it so that's possible make easy
things easy and hard things possible so
both you Matt and Martin you kind of
hints it that there's lots of good use
cases for as for SQL source of course
but maybe maybe you could do you think
you can describe generally what what
kind of defines that boundary or some
examples I the dominant one I can if
your project is not particularly vital
and your and/or your team is not
particularly good use relational
databases right which is a vast majority
of projects out there technologies
maturer you've got plenty of support
from lots of people it doesn't really
matter that much yeah people can come
say oh you've got a super high
availability actually websites go down
all the time and you know if a
particularly if it's an internal system
who's gonna care all right I mean it's
gonna be down for me out some minutes
maybe even some hours people survive
that Amazon went down it made a lot of
noise but you know I don't see that was
a large amount of deaths reported I mean
I mean the reality is for a lot of
systems you go with that flow and that's
gonna be the case for quite a while I
think we're talking about the wrong
thing the query language is a red
herring the thing that really puts the
nose sequel databases in a singular
category is the lack of complex
transactions with rollback and whether
you query it with a declarative you know
thing with capital select or whatever
doesn't really matter what matters is
your unit of isolation you know your
what what what can be acid what can be
rolled back and if you're querying that
through data log you know I'll still
that I you know it's it's not sequel
that's setting us apart from the
traditional databases it's this notion
of isolated transactions I think that
might be a good description for the
majority of no sequel databases I
represent one that embraces acid
transactions as a fundamental unit of
work so I don't it's it's a good
approximation
but it doesn't hold true for all of us I
think the difference is so you know in
MongoDB writes our asset right what we
don't do any guarantees is to sequential
writes after each other I there's no
dependency between those and so really
what you're talking about is the ability
if you've got to spread data across
multiple nodes and you want to have
writes that a guarantee to either all
complete or all rollback across those
nodes you're talking about two-phase
commit and 20 plus years we still
haven't optimized two-phase commit
because you get latency and so you know
that that's the fundamental problem if
you can reformulate the shape of your
data so you don't need multiple writes
then that is an alternative to in order
to get that scalability
never thought I'd agree with tension but
yeah yeah that's the thing most of the
transactions you don't actually need and
you're giving them up and you get a lot
of other things instead asset
transactions you embrace those as a
fundamental thing I mean that's how's
that work for the availability that's
the problem I have because if you ignore
that problem then there are lots of good
solutions there's lots of easy solutions
if you're not worried about availability
well of course I do worry about
availability being a database being a CA
database availability is one of the two
things I find particularly important so
of course you know in any system where
you impose a level of locking and
isolation there may be contention but
for practical purposes in a graph
structure that contention tends to be
very widely spread out so acid
transactions of a of the variety that we
use and we tend not to use distributive
two-phase commit because that is a
scalability and availability inhibitor
but for neo we don't need to do that so
we commit acid transactions to a single
database which is then replicated out
after the fact so you mean a single node
a master node we have that we have a
master yes effectively at some point all
rights go through nearest master right
how many masters are in the system they
mean do you chardon across those ah
sharding are blessed so in the database
that you can download today neo runs as
a master slave cluster where you can
write through slaves and if you choose
to shard
that's a politician that's an
application level concern okay so what
happens when that master goes down or if
you're running across multiple data
centers and it's partitioned so that I
have some set of my application that
needs to store data and I can't reach
the master and then then of course your
data is only accessible for reason you
can't deliver that right so I mean you
know plastic example of this is Adobe
who run their Creative Cloud on top of
neo and if you can't reach us east by
hook or by crook then your rights are
going to struggle to get to the database
because that's when they choose to run
their their masters okay I think that's
a fundamental problem in archit
sure that's that's not what I would
consider a viable solution to most
systems to that last 20% yeah no it's
not yeah it's not it's not a trade off
it's not a trade off you're making
because you're preventing a solution to
it it's okay to say that when things are
working I would like to have this
consistency or I can use these automatic
query planners or transactions or
anything else for this 80% but what's
happened is that other 20% there is no
solution now it's now an impossible
thing to do yes and of course nobody at
neo is at all sitting around thinking
about partitioning of graphs that would
be completely a no of course everyone is
so yes you're right and as I said I was
very careful when I picked my words that
the version of neo you can download
today will be a master slave cluster and
it does suit you know even for global
scale deployments for the likes of Adobe
so maybe they're not one of the 20% of
like particularly tough problems but it
works for them and at some point we will
roll out something which actually very
much inspired by by your staff and
you're stuck at the plumbing level but
which will be partition graphs at the
application level actually that that's
what I wanted to hear that was the
important part yeah but we're working on
now because the problem I have with
spitting those words out is the you
should say J'Accuse because effectively
that's vaporware is that we published
our source I mean if you have plans you
could at least we were vapor aware for
like 16 months after we announced our
2.0 and we finally just shipped it last
week the beta the the GA will be soon
but yeah it feels good not to be
vaporware anymore
what's interesting is that this
conversation seems to be naturally led
to being framed around the cap theorem
in terms of choices between each vendor
here and and so that's part of what I
mean at least how basho defines itself
is that when we go to explain ourselves
in compares to other vendors what we're
doing is we the first step is okay let's
tell them about cap let's explain to
them what it means and then what choices
we made what the trade-offs are in
engineering and then what we optimize
for and and and then if that if that
lines up with whatever your use case is
then it sounds like we're a good fit for
you otherwise we tend to try to push
people to the right you know the right
tool for the right you know the right
solution so I guess I think getting back
to my point earlier about I hate the
term no sequel it would be nice to to
begin to I think collectively like
organize ourselves better so that people
understood what really set us apart and
they didn't have to necessarily they
intrinsically knew the cap theorem or
whatever and they understood what
vendors made what choices and also how
do you make a see a choice I don't
understand that exactly did it doesn't
exist
did anyone understand that comment did
how many people have no idea of what
what I was talking about when I said
that okay a few people all right so
there's this cap theorem consistency
availability partition there that
theorem basically says you have to
choose two out of the three you can have
consistency and partition tolerance but
then you would lose availability or you
can have consistency and availability
but you lose partition tolerance you can
have partition tolerance and consistency
but anyway you can choose the theorem
says you can take any two of those and
what I was saying and what he was saying
is that consistency and availability is
not a valid choice that doesn't make
sense
because if you lose a partition you're
not available anymore therefore wait
wait there's nuance to this which I
think you're missing and I'll let you
jump in because maybe you'll correct me
but I hope not
the yeah so I'm the the partition so the
captain was really about consistency
availability and partition tolerance of
your data in a distributed system and
what you're looking for is a guarantee
of all three and because it's a
distributed system and you're looking
for the partition tolerance of your data
you you can't sacrifice partition
tolerance and still have a distributed
system basically if you can't move your
data into different partitions you can't
have a distributed system it's just that
way so it's ultimately a choice between
consistency or availability and that's
the part where I didn't understand the
consistency and availability part and
also this is the the choice you have to
make you know I'm sorry but the choice
when you have to make this consistency
or availability isn't all the time but
it's in an instance of failure or like
concurrent operations or something like
that of multiple actors in the single
system but I would argue lots and lots
of systems out there don't have any
partition tolerance and they work just
fine yes that does mean that if either
they're all running on one machine so
yes I guess he could partition if it you
know the motherboard starts clogging up
but the risk of the things going wrong
is sufficiently rare that people don't
worry about it and if something does
happen then they have to then deal with
it and that has actually worked fine for
a large amount of non distributed
software systems for a long time and
then if you will live in that world then
a whole bunch of complexity goes away
and then when you had many situations
you do have to worry about there are
needs a media to push towards
distribution and as you go to that push
towards distribution then complexity
goes up and you have to start making the
decisions between on that sliding scale
between consistency and availability but
there's lots and lots of cases where
that doesn't apply and and I think it's
very disingenuous to say oh they can't
work because it clearly has worked for
quite a good bit of time and will
continue for quite a good bit of time we
have to make the trade-off of whether we
care about partition tolerance so you
actually just said that it doesn't work
right you just said that you said that
this works and a lot of systems that are
out there that only have one
and so that's not available by
definition right I mean it's absolutely
there hi Bree without a hundred percent
for instance we are not all sitting in
the same place on this imaginary cap
triangle I'll try to do some
characterization I'd say that react and
Cassandra are you know gonna place
availability at the top of their
priority list and and Couchbase and
Mongo are going to be more consistent
but that doesn't mean that we're
completely unavailable in the event of a
partition what it means like for
instance in Couchbase you lose a node
and then you fail over the replicas you
know you'd auto detect the failover
fifteen seconds later so yes there was a
lack of availability but 15 seconds
later you're back in business
it's still about it but it's also so he
says it's still a lack of availability
but also I'll say it's also still a
distributed system and that's the kind
of choice that we're offering up in
terms of the different products for
people to figure out for their
particular use case so they need
constant availability is it stock ticks
where absolutely you have to be
guaranteed - right or are you a system
where for all your developer community
is it more important to get a consistent
view of that data and deal with some
lack of availability in an event where
you may not be able to write data for 10
15 seconds and that's the kind of choice
you're making
No now we've done we've done a ton of
talking did you want to let the audience
have some questions I believe the
audience was promised beer for questions
we have three beers so we can have three
audience questions who wants the first
one awesome you win so would you say
that you're you if if I if I knew enough
about the cap theorem I could actually
use that as a starting point for
figuring out which product of yours or
maybe old-fashioned or in a relational
databases I should choose with the cap
theorem
give me a good starting point there good
good just a little bit more on that I
yes what what he said but I would start
from the availability availability
perspective and he's right that's on the
top of my priority list but that's
because it's the hard problem because if
you ignore that everything else is easy
so either you need availability or not
and then from there continue on right so
I'm a bit confused as I think the last
15 minutes have proven yeah
the problem I have is mainly I'm
thinking back to 2001 2002 when we
introduced this wonderful new thing
called agile methodologies and you know
a whole bunch of very very intelligent
people were talking about similar things
but sufficiently different and they all
went away and wrote different books and
came up with slightly different slants
that really confused the whole the whole
industry for for more than a decade and
I think we are still cleaning up after
the the mess that the scrum alliances as
is brought into
so um I guess my question is how do we
make sure that this does not happen and
I mean the previous question was really
good in that
I don't expect many people to really
read the cap theorem before they sit
down to think about Oh which database
should be used for our fraud or a
project well the hope is that the market
will decide and if you just you know
wait it out long enough you can pick the
winner by default caveat the markets did
a really good job since 2008 so so were
you saying is whoever has the best
marketing department in the bed the
biggest budget I think the developers
are smart and good technology will win
and it might not because of the cap
theorem it might be because it's easy to
install actually it brings out a very
interesting point here which is one
thing that's very different in this
world to what happened inside a shake-up
of the various relational vendors that
occurred 10 20 years ago is that we're
in a situation where all of the no
sequel community people that people
that's the stuff that people are talking
about these are all open-source systems
and this is a very interesting
development that we're actually talking
about competition between open-source
based systems now there are some
commercial systems that ever liked to
call themselves no sequel jim has
already expressed his appreciation for
one of them but I think that's going to
make an interesting change for the
dynamics I don't know what it's going to
do to the dynamics but I'm fascinating
then I'm gonna really enjoy finding out
ok I think we probably need to end here
we've already a couple of minutes
overtime so please give a hand to
everybody
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>