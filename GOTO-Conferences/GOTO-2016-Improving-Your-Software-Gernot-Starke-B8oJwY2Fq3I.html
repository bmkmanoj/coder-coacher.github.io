<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Improving Your Software • Gernot Starke | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Improving Your Software • Gernot Starke - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Improving Your Software • Gernot Starke</b></h2><h5 class="post__date">2017-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B8oJwY2Fq3I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Garrett um I'm very proud and happy
to be an interview fellow my one of my
business hobbies is writing books and I
won't talk about me any longer but I
want to I want to complain about the
fact that nearly nobody who works in IT
has systematically learned about
improvement modernization or maintenance
of systems we all learn from the very
beginning how to build systems from
scratch and we can do that quite well
but we are not very good or actually we
are extremely bad in keeping systems up
and running and improving them or adding
functionality over time so it's a there
is some room to get better in this in
this aspect I brought you a diagram
please have a look at the green line I
hope you can see it from the back it's
pretty much original I left out the name
of the client or the company but it's as
I said it's pretty much original it's
from an insurance background the company
has about five six hundred software
developers working on a variety of
systems and the Green Line depict some
performance indicators of a specific
relatively new system I patch or
modified the exact numbers they are not
very interesting in the beginning of the
system when the system was initially
built the team consisting of about 30-40
people so not a very small and not a
very huge system could deliver a
relatively high number of features per
release this company releases four times
a year that's not modern it's not hip
but they do it it's it's quite okay for
them over time the performance of the
team the team remained constant over
time so there was no big change in
people
there was no headcount reduction on the
team or any of these management
techniques so the team remained constant
and the team is not overall stupid now
this work quite usual people their
ability to deliver a new business
functionality declined over time so you
see here a very steep decline at a
certain certain point in time I don't
know the exact reason why that happens
I'm interested in the curve in this
diagram the overall tendency over time
shows that the ability of a team to
deliver system decreases probably you
don't have this exact diagram for your
system I have created a number of these
diagrams for companies for enterprises
to show them what happens to their
systems and I call this the very normal
case if you have a different opinion
different experience be very happy
because this is industry standard in
software in software systems when
systems are maintained when systems are
worked on over time they really rot and
Robert Martin and other and other very
clever people have written about these
symptoms since ages people invented
refactoring because of this phenomenon
in my probably very special case another
thing happened in parallel to the same
system the stability so the number of
production bugs you always have some
production bugs that will most most
always happen but the number of
production bugs went up over time
showing that the team lost control of
the system they were not very clear what
they were doing they were modifying some
sources modifying some data structures
whatever and they had no clear idea of
the connect
in production yes they test it and yes
they had some unit tests integration
tests and so on but give me your hands
up has anybody of you seen a phenomenon
like this before oh I see a few hands
rising now that's that was my reason for
for many years to try to improve that
situation to identify patterns and
practices to get better in that case you
know this city anybody here from
Switzerland this is basil um you know
basil
you know what basil has to do with
software it's a great software industry
in basil I know but so basil is known in
the financial industry because there are
some regulations called the basil
regulations that very strictly regulate
how financial depth financial loans can
be given by banks so if anybody of you
wants to buy a house or a home or any
other huge thing go to your bank ask for
money the basic criteria limit the
amount of money you can get they define
how much risk a bank is allowed to take
what has that to do with software in
software we take arbitrary risks we take
technical depth or social depth and
together with a technical depth in an
arbitrary and unlimited amount and we
don't care about repayment so if you if
you're hacking on your system without
thinking of the future you take up some
technique you won't do that any rogue
programmer would probably do that take
some technical depth implements like
hell and doesn't think about repaying
this debt and that's why probably a good
idea to sometimes think of basil it's a
nice city to visit by the way
so if different people think of software
probably in that degrading situation I
wanted to tell you about technical about
depth in the financial world you have to
sign a contract so the bank is sure you
you will repay that have you ever signed
a contract in software you will repay
your technical debt no you have um there
is an upper limit on technical depth on
financial debt I have seen systems with
no upper limit on technical depth
probably you have seen that too now in
the annual balance in German it's called
be lanced in the annual balance you have
to show the amount of depth you have you
have to make it explicit how bad your
financial situation is you can cover up
in software you just built another layer
of complexity migrated to micro services
and probably for some years you can hide
that but it will hit you I'm sure in
software we take up depth accidentally
with an arbitrary amount with no clear
criteria
what's a risk and what's a problem and
so on and as you know everything that's
implicit implicit knowledge is bad it's
a nice you photograph the slides you get
it for download probably the quality is
better and I won't be on the image so
downloaded slides are more beautiful I
promise a few things I know I fight
against lunch I would just turn over
take an hour so now um I talk about
systemic improvement of software um at
first I show you a bit how to identify
or find your problems problems in
software you then solve I will talk
about how do you
Vince your management that you want to
improve really improve the internals and
internal structure of your system I show
you a bit how you can actually do that
in practice and I talked a little about
how you can align improvement with your
day to day activities because your
business wants features not some
internal improvements in software we
usually have two types of people talking
about those software I am very very
stereotypic here so I generalize too
much probably you have management that
is much more knowledgeable software but
I met a lot of managers that complained
you guys are always too expensive it's
the the software we have here the
software systems are too expensive to
maintain it contains too many bugs and
the time to market is way too long
we need the features faster you ever
heard that anybody here who has never
heard that that would be the guys not
from the software industry now we have
just a few managers I'm I'm afraid I am
male manager here it's the same for male
and female managers and it's the same
for male and female techies techies have
a completely different opinion on the
systems they maintain all right they say
oh we have too much technical debt we
improve too little our technology really
I don't say that word is bad we have
little in innovation and we have never
enough time to do it right anybody heard
that before now if you compare these
statements one could think they are
talking about two different things but
actually these persons are talking about
the same thing just from different
viewpoints oh that's interesting
if you are very important managers these
are the guys with the money if they
think it's too expensive
it's very unlikely they will give you
more money for improvement if you're
already too expensive and by telling
them about some abstract technical depth
using software engineering terminology
probably talking about microservice and
server less and whatever you will never
convince the guy who thinks you are too
expensive you simply fail in
communication it's not that you're a bad
software developer I'm quite sure you
all know how to technically fix things
but we have a huge problem in convincing
the guys on the left now let's talk a
bit about value because value might be
an idea how you can convince your
management if you stop talking about
engineering terminology but tell your
management hey I got an idea how you can
save thousand euro per week that's a
statement that's interesting for the
guys on the left so if you make
technical improvements if you give it a
unit like money or time you might be
able to convince people that have no
idea of software at all and I have met
enough managers who are not programmers
who know how to use Excel and very
excellent in numbers and project
planning and so on
but are not software guys they don't
understand coupling cohesion scholar
traits and whatever all the things you
understand so I'd like to talk about
value now we have value or the opposite
of value I call cost we have value in
two different aspects when we talk about
improvements the first thing I want to I
want to briefly talk about is a thing I
call issue and actually it's a problem
some bad thing in your software you have
to tight coupling between two packages
you might have a bear technology at
part in your system whatever we call
this problem problem is an unfriendly
word what tools you have available a
problem tracker or an issue tracker an
issue tracker it's a more friendly word
so in this open source project I did not
yet talk about we use the term issue to
denote problems risk all the bad things
you have in your systems and these
things are somehow disturbing these are
negative in a sense they make it more
difficult to maintain the system so
somehow you want to overcome this very
tight coupling or bad technology
whatever so you think of some
improvement whenever you read some
source code you identify a problem there
is a badly written code and the typical
developer immediately starts thinking in
the solution space how can I improve
that how can I write the code in a
better way and we often just start doing
it I think this is a bad idea
because when we just immediately start
solving these problems we probably
forget other options we have and I have
a small example of such an issue it was
a quite small ecommerce shop I worked
with the with the guys in a small
project and they had the problem that
their system got unstable
every day in production there's a very
small company so the their shop broke
down once a day they had no real
operations department so the developer
had to get up from the desk walk to the
server room lock in the console do some
magic restart the system and walk back
this is an issue now what did the
developers propose they said oh we need
a new shop we had this old PHP based
system we modified it and we patched it
again and we lost some some framework
updates and now it's completely
unmaintained
so we have to buy it have to buy right
or whatever a new one
and they they ask me first because they
before they went to their management
they said we need a new shop do you
agree do they need a new shops a new
shop the one solution to this problem I
asked them for an estimate how bad is
the situation how often do you need to
restart they told me once a day I asked
him how long does it take you they said
oh um the server room is next door so I
get up walk there about 20 minutes half
an hour I said one developer half an
hour per day that makes around three
hours per week that makes hundred fifty
hours per year that's bad I asked them
another question how much do you think
would a new shop cost you they thought
about and they said off for the last one
we needed about a person year 200 person
days now compare the numbers 200 person
days to build a new one and hundred
fifty person hours and it's the cost of
the problem I asked them do you lose any
business in the afternoon and they said
no we have a robust shopping cart so
things in the shopping cart or get never
never get lost the client keeps up some
kind of session so the the end customer
doesn't even know that the back end
breaks down so why the hell do you want
to build a new system it's extremely
expensive 200 person days to build a new
system and that's the developer estimate
the real cost would probably be a bit
higher
the cost of the problem is way lower I
asked them is there a second option how
you could solve the problem that's it no
no way I said I have an idea can you
teach me how to restart the system and
said yes of course if you can teach it
to me can you can teach it to any other
guy yeah probably I said Oh have a look
over there you have a marketing
department you have students that you
practice work in your company for they
are here for about half a year they're
computer science students and you make
them draw a Photoshop images they are
probably very happy if they can work on
the console for half an hour every day
and it doesn't cost you any developer
time it doesn't cost you anything extra
they didn't believe me
so we tried that so we we picked one of
these students and we wrote a little
script what they should do and to
restart the my sequel database whatever
and it worked and we immediately got rid
of the problem oh it's not the actual
problem but we found a solution that's
cheaper and that's why I have a big
problem in only letting source code
influence our and our improvements
sometimes we have several options how we
can overcome a problem and it's a very
good idea in general to calculate or
estimate the cost of the problem first
before you think of a solution if the
solution is extremely cheap the the
effort of estimation is might be too big
but very often the cost of the
improvement is too high it doesn't value
it doesn't and it's no business used to
to work that way so you we have to think
of different options now um the things
you see here that improvements and
issues and the associated costs is
something like a domain model of
software improvement um
I found it together with chef until
cough and others I found it an open
source project architecture improvement
method and we had a we have a simple
domain modeled so we we use these terms
to explain how things should work out
and one more interesting thing about
these two terms issues and improvement
they have an M to end relationship to
each other so for one problem you
probably need two or three measures
improvements so one single improvement
won't solve the overall problem it might
be that one improvement solves one
and-a-half problems so maintaining some
relationship some idea if I do this I
get the following effect is a difficult
thing so it's not always a one-to-one
relationship it's not always that you
have one one improvement to solve a
single problem it might be that if you
solve one problem you create a new one
it's called negative consequences I'm
sure you you all had this this effect
you do something and it has a negative
consequence you create a new everyday
not not he but but the guy on his right
now if you start talking about the cost
of issues your management would start to
listen if you if you only talk about we
need a new programming language a micro
service a trade or or some fancy
coupling things these management guys
won't understand you if you tell them I
have an improvement that would save you
150 hours per year they can understand
that so that's one strategy how to
tackle overall software improvement only
start doing things if the improvement
cost of the cost of doing something is
lower than the cost of the problem so if
the problem is not big probably ignore
it although it's disturbing you ignore
it now you have to align this kind of
improvement with your daily business and
we have learned the hard way by the way
in software that iteration is a great
idea so software improvement as we
propose in this in this systematic
approach is a strictly iterative
approach we divided this into three some
three phases we call analyze evaluate
and improve this improve is a fun part
this is where your refactor we architect
improve your domain and whatever but
before you actually do things you should
think a bit and I call this analyze
evaluate and and and collect what's the
result of this of this analyze and
collect is that you have an explicit
overview what are the problems in my
system so it's not just this single
classes are are badly implemented but a
broad overview what kind of problems you
have
and what candidates we have what could
we do to overcome this problems when you
have this kind of lists
I very much like to start with stickers
on a wall so I have red stickers for the
problems I have green or blue stickers
for the improvements and then we can
discuss in the team what can we do I
proposed and that's this evaluate you
think about the cost of these problems
and the cost of these improvements so
you can better compare those let's start
with the problems because it's such a
complicated topic to analyze problems
I'd like to take a an example from real
life so if we if we take a complicated
system and I you have here some kind of
tomato soup it's a complicated system
because you have many ingredients and
it's a it's no algorithm to produce but
there is some some art in cooking and so
I'd like to take this as an example if
you think about some dish or some food
and you try to identify problem so some
things that come to your mind as a user
of the food so I'm fighting against the
lunchbox of your users of food and you
probably think about taste I taste good
or bad and the price and what does it
look like and where do I get it so this
might be sources for for you will you
look after problems now let's switch the
perspective a bit and let's think about
the cook the cook will obviously think
about taste but a cook is quite strict
in in other things he will he will
probably measure the temperature or feel
the temperature he will look for
consistence he will look for popularity
because these guys don't want to cook
things that nobody's going to buy
you are not thinking about popularity
it's not your criteria the cook will
probably think about purchase price so
if you order some strange sea mussels
and you are willing to pay 20 euros for
it but these guys need to pay 30 euro
and for four for the market price it's
of no use
they have a different view on problems
now there's another guy involved here in
a laboratory they're analyzing the
tomato soup for radioactivity it's
probably a spy story some Russian
dissident and it has allegedly been
killed in London by an overdose of some
very difficult to trace radio
radioactive substance now that's not the
thing you identify as a user while
eating the soup is completely tasteless
you need some other stakeholders in that
food aspects to look for those and um
many of these these guys are looking for
the contents of a food from a completely
different perspective now there are even
more stakeholders you want to get the
food to the people um if you want to do
it in an industrial if you want to
produce food in a more large scale set
up you're not thinking about taste that
much you think about how can I pack that
wrap it so it gets to the user how can I
say let market and so on and so on
what you see in this example you have
many many different criteria what's a
problem from different standpoints from
different stakeholder viewpoints and in
in every complicated systems you have a
variety of sources for problems I won't
read all those and you have to adjust
some and of course us developer you have
always a brilliant view of the kinds of
problems in the components you are
King on very often your view is limited
to the things you you already know we
have often problems in software with the
so called cross-cutting aspects
cross-cutting is often technology or
some rules and principles that are
should be valid all over the system when
I do architecture or system assessment
evaluation I very often found problems
in the development process
in the requirements process and the test
process I found problems that the
organization is not fit to maintain the
software it's a completely different
source of problems then if you look at
the source code of a single component
let me give you a very small example
from the source code space let's assume
you have four components and you have
some tool like solar cube in place that
measures a bit about these components
and you found that in these components
you have a certain complexity and a
certain amount of coupling now the
higher the complexity the more difficult
it is to understand and maintain this a
piece of code and high coupling as you
know looks like a bad idea so just from
these numbers I hope you can can read it
in the back just from these numbers
there is one component that's red one
that cries out loud fix me I'm so
complex and I am so tightly coupled I
need to be fixed and in many many
development teams I have experienced the
whole team gathered and started working
on this red component it gives you a
great feeling but it probably doesn't
add any value because
have some other metrics we could measure
the DTF be metric the days to fix a buck
how long does it take the team on
average to fix a buck in a certain
component and we see here that the days
to fix the back in our red complicated
component it's astonishing but it's low
and we don't have many bugs the
component that didn't look that bad
initially fixing bugs here takes ages
four times as long as this one oh wow if
you invested days and days in improving
that one that would that whole thing
would still be a failure so you would
have invested on the wrong in the wrong
area of your system
what you probably learn from that is
don't jump to conclusions too early
don't look just on your sonar cube
numbers these standard set of metrics
and start fixing that I think that
sometimes it works but use more
indicators use more problem sources
broaden your search scope and days to
fix it back or hours to fix the back is
a very good additional metric because
days to fix a bug is directly associated
to cost complexity isn't you will never
convince your manager or we have high
complexity here I don't care your
problem if you tell your manager all we
need 8 days to fix a bug here um so if
we can reduce this by 20% you gain a lot
and you can immediately transfer this
and to value into money so people will
listen to you now
I brought you another example from real
life again I left out the name of the of
the company doing that they had nearly
clean code I have rarely seen such
awesomely written source code small
methods great identifiers
um a layer structure that was really
clean and the most fucked up data model
I've seen all my life no that's not
funny now today it's funny when I was in
that situation um it was not funny at
all
because it's kind of standard software
the the this company was selling the
software to other enterprises and the
the customers were complaining about low
performance and a very long time to
market data um clean code is not enough
to fix these issues they had old all
data we are talking about billions of
records in four tables which itself is
not that bad having only four tables but
you know something about relational
databases how many columns do you expect
in a typical industrial or business
application in a table ten twenty
hundred maybe the Oracle query optimizer
stops optimizing at about 150 as far as
I know and they had 500 to 700 and
that's completely obvious if such a
thing is broken
you will not ever say oh I need some new
kind of data which of these 700 shall I
use I just make a new one and and that's
why these delivery rate goes down the
drain
if something is so the developers didn't
question the data model it was holy
territory and Pepperdine one of these
great database experts has written some
had written an internal review about
this data structure and even he said
that's the worst I've ever seen and
that's the most interesting rate of I go
back of clean code to data structure
he's ever seen so if you continue
refactoring your source code you spent a
lot of time with no effect
on the overall quality of the system now
I advertised a bit that you broaden your
search scope for problems and I brought
this example from some Indian from
Indian spice market where you have a lot
REE a lot of different spices to try
from and I think looking for problems of
our issues in software is a bit similar
because she has such a broad variety of
systems of aspects where you might look
for problems due to my my available time
here I won't go into details of all
those aspects that were take me about
today so in a day I can teach you or
show you it's all written up in that
same 42 method so you are not stuck to
listening to me yes everybody in the
software developer space is looking for
problems in code structure that's what
we are working with every day I talked
about that problems and data and data
structures we have quite often problems
we have no documentation so new people
don't understand the system we have very
often problems in security that are not
directly related to source code we have
often problems that the development
process is not suited to maintain this
and so on and so on my proposal here
it's a breadth-first search in german
its Bryton zu and probably and so i'd
like to do it in iterations and in my
first or we always start at zero but in
my first iteration i'd like to have a
look at source code obviously it's very
important but I like to question other
right people working on the system or do
we probably need some different know-how
it's our context are our external
interfaces okay or do we have any
problems in there do we have problems
with data and so on and so on
if we
defy that oh we have severe problems in
data yeah you can do a second iteration
and investigate a bit more in here
iterative approaches have the advantages
that you can work in time boxes and you
can make this search for problem
activity I call that analyze you can
make this a very small time box and with
clients I we experimented how much time
do we need to identify issues and people
said oh we need weeks and I said no no
we need to integrate it in our usual
scrum process so make it a few hours per
iteration that's quite easy to to manage
a good starting point I brought them
some snippet I found have a look at your
source code they snippet assumes you are
using git and this snippet finds the
files that have been modified the most
often there are the files that might be
critical and you might want to optimize
those that many people handle every day
that's just a very small example now
let's assume after some some work on
identifying problems you get a number
let's say 20 30 40 of those red cards
attached to the wall every card contains
a single problem now you want to
convince your management that some of
these problems need to be fixed and as I
said um I think you need to evaluate the
cost of the problem most software
developers or software people in general
and I have talked to and I have asked
about this subject about estimation or
evaluating always evaluate effort how
much time does it take to do something
and nobody ever estimated how bad is the
problem I heard a podcast with a very
famous software guy Steve McConnell he
has written this this
demystifying the black art is a very
good estimation book and he limits
estimation just to effort estimation how
long does it take to do something but I
come I don't care how long does it take
if the problem is not bad now if the
problem cost is just a few hours per
year I don't care I just leave it as it
is and do something else fix some other
problem that's why I'm pretty strict
here I want to attach estimates um some
cost with the problems we find and the
problem with this sorry
fucked up data structure there was
extremely high cost in that and yes they
had some classes they had ideas how they
could even refactor those with no effect
this is this is doable so there are some
mechanics how one can estimate the
effort of the the F the the the
intensity of the pain we have with a
certain problem the cost of issues is
the thing you should definitely consider
again in this m42 method we had some we
have some kind of domain model for
estimation it's no tutorial how to do
that but it at least we show some steps
probably the most important thing you
have to do is you have to identify what
are the factors and I like to call them
cost factors what are the cost factors
influencing the cost of my problem in
that example I had before the developer
walking to the server and restarting
something the factors is obvious how
often does it happen and how long does
it take the the person and the third
factor is how much business do you lose
so these are the factors and now for
every factor I make an assumption how
bad is that
how much does it cost how much and
negative value does it produce so you
have asked
made about your factors so definitely
you're breaking down your estimation
problem into smaller estimation or
guessing problems I propose you always
do these estimations in an interval from
a might be the developer uses only five
minutes to boot to boot up the shop or
in the worst case um they need one hour
so you have the interval from five
minutes to one hour what is the interval
good for any idea if the interval is
quite broad you explicitly show oh I'm
not sure if the interval is smaller oh
it might take five minutes or seven and
the interval is quite small you are very
sure about yourself so if you are unsure
how bad a problem is make the interval a
bit broader the basic idea in this
estimation you want to convince your
management that this problem is either
bad or not that bad and you compare the
cost of the problem to the cost of the
improvement measures now that's the
that's the thing you you have to do it
will take some time I did these problem
estimations with teams in time boxes so
we pre estimated we had this 30 to 50
cards attached to the wall with it some
rough pre estimation is this a very bad
bad or a low kind of problem and we gave
every of these index cards about half a
minute to a minute you can do that quite
quickly in your usual scrum or whatever
planning sessions for the top two or
three for problems you do a detailed
in-depth estimation you probably invest
in our people didn't believe me I
convinced it works in an hour you can
estimate nearly
every problem on the planet last week I
evaluated with them with a Swiss
government agency the problem cost of
their mainframe still in production and
iBM is some is raising the prices and
whatever so people told me or not we
cannot estimate that I convinced them
yes that's possible
I just want to advertise systematic
approaches here let's assume for now you
have some numbers for your problems you
will have you easily find numbers for
your improvements because this is your
daily daily business and estimating how
long will it take now we need some in
the third phase of the improvement we
need to fix the fences I took this small
example because this is any craft
everybody of you knows how to reflect
your classes and so on all these
low-level stuff you know that but in
systematic improvement we need to do a
little more yeah what was my um my joke
to keep you here apart from the fact
that lunches is coming um obviously you
should work in software as if your
successor is dangerous probably we will
understand the joke over over lunch in
in this improvement method and we we try
to categorize possible improvements and
we didn't want to limit the range of the
the area where you look for improvements
to just low level code improvements all
of you know how to low level improve
code but there are there are options in
changing the process if the way we work
is not good enough and we might change
this way we work before we reflect
resource code we might have measures
improving the technical infrastructure
all that DevOps container or whatever
type technology and
that's targeted at improving the
infrastructure DevOps is not fixing your
code it's a completely different kind of
improvement measure and I want to just
briefly give some more details to some
of these to some of these improvement
categories just to show you that we have
in that m42 project collected very broad
variety of ideas so if you are looking
for ideas how can we overcome a specific
problem this this open source is
designed to just give you some ideas it
won't tell you the exact way how you
should behave one thing that my clients
or our clients found particularly
interesting are the long run
improvements how do we organize
improvements to come from a really bad
system over two or three years to
something which is much more
maintainable and I call this this
strategic approaches Ava had no worry
I don't read all these there are um this
is these have been successfully
performed in reality so this is not
theoretical invention of some strange
scientist but this is really pragmatic
approaches how to do that now in the
beginning I promised some things I
promised systemic improvement I showed
you there is some kind of systematic
iterative approaches I divided that into
phases and I promised I show you how to
find problems yes I did
I just touched the surface but I made
you look breadth-first not depth-first
like sonar cube for example proposes
depth-first no no good idea read first I
try to show you how to convince
management you talk about money not
about coupling cohesion engineering
principles CQRS pattern
they don't understand talk about money
talk about saving a big a big amount of
money and then they will listen to your
proposals that's a good way to align
that with your development work if you
if you can't convince your management
that you are really saving money they
will give you some time to do that
facilitating alignment with development
work now I promise some mid and long
term improvement approaches I've shown
yet I've shown you at least some
diagrams we have no time to dive into
them in detail if you like ask me after
the session we could do that one last
advertisement about us getting um are
you hungry yes he he's not saying yes
but he's nodding yes and every - is an
open source project we're actively
looking for a country country butor as'
our newest contributor is sitting in the
front when um he is doing great work on
social depth um in that area and I
really thank a lot for you folks being
here I will be here in the afternoon so
if you got any additional questions do
it via the app or just attack me
personally thank you very much have a
nice close
thanks doc Donald do you still want to
to take a question if you got any
questions I one last thing I know
could you please vote for the session
yeah in the last session not enough
people voted so Ava had got a bit angry
or nervous so do him a favor and vote
for this session
thank you I'm actually never angry okay
so I think we can we can take just one
questions so do you also recommend to
measure costs of not evolving the system
for example a cost of not of not
evolving the system for example
increased support cost over time due to
using an outdated technology increasing
support cost is a problem so if that
problem cost is not high enough I
wouldn't change it but increasing cost
is usually a very strong indicator for
management to do at least something so
definitely I would handle that ok thanks
a lot enjoy lunch thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>