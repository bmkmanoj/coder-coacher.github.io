<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Raising Abstractions for the Software Defined Business • Dave Duggal | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Raising Abstractions for the Software Defined Business • Dave Duggal - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Raising Abstractions for the Software Defined Business • Dave Duggal</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zzrIkVmpP-U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">fantastic so i'm going to i'm going to
start and uh you guys have been having
in innumerable sessions here i know
things like microservices are obviously
a hot topic but you've been covering on
things as well analytics i assume are
also being spoken about here andrew
being real time and data-driven is
actually something that's increasingly a
demand of the business right so how it's
being implemented of course is probably
varying lee it's probably by app and
what we're providing is an opportunity
to create an entire layer where
everything can be fully dynamic data
driven policy controlled with full trace
acid transactions rollback everything
and do that in a in a really elegant way
and i hope that you know you guys can
ask me ton of questions a small group
here we can make it interactive but the
ideas it's that you know moving away you
know so we would share a lot of the same
argument the micro services people do
with ESB and so the centralized command
and control the pile of architects
dictates to everybody else in these and
we'd say well okay that models not a
great model but I look at I look at
service or mean like microservices and
say well no you know first we started
with opie and we wrapped data with
methods okay great we broke down the
monolith a little bit then we want to
distribute that right and we rewrapped
him with interfaces and now we
distribute those objects right and
though now microservice isn't really
changing the architecture of service
orientation right it's just a nice
doubling down on isolation we're gonna
run them all on separate servers a whole
bunch of consequences architectural II I
think it's fair you could call it an
anti-pattern because you're isolating
everything so architecture is almost
being swept aside a little bit you so
you have to conceive your architecture
over those micro services um and what
we're saying is oh yeah we do good some
of the argument about the ESB but I
think we're having we're living a time
this false binary where you're actually
saying well I don't want to be central
with I'm mildly capable with the ESB
provides to me it's too much too much
work I have to conform and uh but I
don't know if lightweight and stupid is
great way to go either I think actually
the ideal Siddle where condition is
actually be lightweight and smart right
to be scale-out lightweight and smart
and I look at middle with a role of
middleware should
be the thin layer between my objects and
the behavior I want from my objects and
nothing more right and we've had this
history of building these massive
component-based architectures right and
they have all sorts of accidental
architecture consequences of them at the
implementation layer arm but I you know
that that's run into whole bunch of
problems it's the walls we've been
hitting most in the 21st century is the
consequence of that stack approach the
modular made it work it's a middleware
vendors dream of course because
everything every solution to every
problem in Middle where is more
middleware right and every piece of
middleware looks awesome in isolation
you look and say hey this this
middleware component delivers a new
capability my capabilities come in
components and you go great another one
but it only makes sense when I look at
it in isolation when I look at the IMP
the compounded impact of all of these
components and then writing my apps over
the top of them and the consequence that
my apps are only going to be as
resilient uh you know there'd only be
the sort of a you know resilient durable
you know performance scalable as the
least one of those components right cuz
my apps run across all of them right so
for somebody from some ESP vendor to say
well my ESP is you know as a scale-out
horizontal architecture okay or needs be
I'd sort of expect you to be that way
but it's almost not even a point right
this is like well my applications don't
just consume ESB they consume all this
other components I gotta be concerned
about and so what we're talking about is
raising abstractions and why I chose
raising the abstractions is a it's
actually in a lot of domains this is the
way people are thinking about it I'd go
from here to own ugh right and we're
winning awards in the telecom space
because in those places they're
absolutely I was at the o net conference
last fall and they were saying the
multi-billion dollar question to solve
is how we do this declarative you
declaratively layer 7 above all of our
endpoints I need to manage things right
because our Allen points are completely
diverse and these were like the leaders
of networking science right from the
Purdue University you got comer and you
got all these other people right and
they were talking about this is the big
problem to solve and then there was a
vendor panel and Cisco and everybody
else was up there and they're saying yes
this is the big this is the Graham we
got to go to layer 7 right okay we got
to take it all the way up and so when
we're
course as we raise abstractions up to
that layer things become increasingly
complex right it's harder to make
abstractions that don't leak right so
that's what we're gonna talk about so
I'll start off and I'm gonna walk them
through some stuff and you excuse if it
starts off simplistic but I just want to
build a case that hopefully is logical
and then when and then end in some place
so hopefully you'll walk away with some
you'll feel like maybe this was
insightful that's my goal for you today
so the real world is dynamic distributed
diverse right it's obvious but you know
it didn't wasn't always that way right
it used to be not very dynamic it needs
to be slow to change it used to be
incredibly centralized and you should be
pretty homogeneous right and it's
evolved now everybody wants everything
distributed is reverse and dynamic and
you can almost look at it to say Humpty
Dumpty's broken right that's not
changing anytime soon you can diversity
is going to explode right we'd have well
four or five years ago you know we're
talking about vmware and VMS now we talk
about docker now we're talking about
core OS and next year will be something
else right technology innovation is
happening all over the place the genie
is not going back in the bottle you know
that's going to keep on getting
incredibly more diverse things will keep
on getting more distributed but if you
look at that fragmentation that means
right or that what does that mean to be
an organization that's so fragmented
right it's exploding it's like you're
like a balloon blowing up a balloon and
your points are spreading right on that
balloon as you blow it up that that's a
real world challenge because as a
business a couple things a it'd be nice
to have oversight over everything right
that doesn't mean I have to control
everything all right doesn't mean
everybody has to do everything a
standard way should be nice from a
business legal compliance perspective to
have some visibility into what's going
on in my operation right should be nice
to have some process interoperability
right and so you look this you know
while I hear a lot of IT talk especially
some of the more marketing oriented
bloggers that are just doing the thin
where let's say you're um is that it's
almost like IT Liberation Theology right
it's like oh yeah we just we just want
to do what we want to do and we don't
want to be like why don't these are
organizations right these are big
corporations with real legal concerns
real legitimate compliance requirements
right needs for efficiency want to avoid
redundancy all over the place so I never
really bought into that line of thinking
furthermore managing this world is just
not well supported by our old world I'd
actually submit to you that the
technologies the automation technology
we used today is 20th century technology
and I don't carefully we're still
talking about you know the you know the
latest scripting technology you name
your favorite um you know scripting is
an old idea right having libraries and
exploding libraries of static scripts is
not necessarily a great idea it's like a
whole bunch of guys fell out in
networking cabinets and discovered
software and also in their writing
scripts and think that hey look
everything's automated and so you know
we're working on 20th century automation
ideas and it's really frustrating the
business because i think the business
you know we've been promised agility
from IT for a long time and the business
if you ask the business they don't you
know certainly I T is getting some
efficiencies in the last decade right
may cloud is certainly bringing some
efficiencies they're absolutely new new
capabilities are being brought to bear
but if you actually ask the business
that they feel really agile I don't meet
many CIOs that's would say that they
feel that way or more heads and lines of
business um so recreating you know so
you know if you can think about what
what the problem is you know we've
created these abstract service
abstraction layers and we have our API
abstractions and we look and say oh this
is so marvelous they're all loosely
coupled right and they are all loosely
coupled that layer right we did create
something there we abstracted some
functions out of their systems and we
created some loose coupling there but at
the application layer right and remember
all business value happens from the
application layer down right the
business only cares about the
application layer that's business right
and so they just look at the business
and say well gosh it they'll at the
application layer I pick up an API I
read the API and I wire it into my
process in my application where's the
loose coupling right all that effort to
make it loosely coupled here and it
terminates at the application of course
you know 100 hundred application as you
know the story 100 applications or
processes call that API but the API
changes they won't know to the runtime
that they're broken you can certainly
manage and monitor some things but again
you're almost doing things as they serve
a reaction to the environments that
we're creating we're sort of going
headlong down a path and it doesn't seem
like we're necessarily innovating so
we're still doing three-tier vertically
integrated integration and cloud we're
rebuilding our silos in this in the
cloud
of course things that were hard in the
data center don't become easier in the
cloud right under distributed
geographies undistributed as a diverse
SLA s you know managing all these
different integrations that you have to
do can come becoming increasingly
complicated of course if you have very
simple apps and you only care about a
very small domain or if you have a
business like some of these digital
businesses out there we obviously hear
about Netflix that does you know all of
its call it moves content right it's
digital content and moves them down very
specific pipes it does it in ungodly
volumes so you know I'm not knocking
what they do at all but I'm saying not
every American corps international
corporation is netflix they have
incredibly diverse domains many lines of
business right they have an incredible
amount complexity and compliance that
they have to deal with in regulation and
that is not going to be dealt with in
these in these simple scripted worlds so
you know operations its operations
fragment management is lost right and
this is a I can go in any CIOs office
and they'll agree right immediately come
into here and I say do have problems
with sensitive you know organization
wide version control governance security
would you like to have virtually
centralized policy management that's
like yes yes yes yes yes right and they
would never say they have any of these
things I've never met a CIO that said
they have control of these things across
a scope you know they have maybe in a
very very narrow way only so you know
I'd argue that the application model is
broken and what we won the 21st century
and actually a lot of people have been
presenting to this and Rebecca in the
back here and other people in many the
presentations I hear evolutionary
architektur a core architecture here
agility right building things so that
they last adapt and evolve right so so
what we really need in the change in in
the face of distributed dynamic
diversity we need flexibility right to
cope with the accelerating change
because you never you know I think one
of the funny things is here is you
actually another thing another term
you'll hear you're here at go to Cana
logged app dev conferences is a
continuous integration but there's like
a silent word in between continuous and
integration manual right it's not
automated right it's continuous manual
integration how manual integration keep
up
the 21st century right with the rate of
new things that you have to connect with
the rate of demand of change of the
application layer from your from the
business these are becoming these
accounting problems and it's almost
actually a bit antiquated that we
manually integrate things isn't it you
know is an IT s role to automate things
right the only thing we haven't I think
about that what's the least efficient
aspect of all of the enterprise least
automated change management right and
you think about your change management
pipelines etc like that and obviously
varied perspectives so you know changes
or changes you know the coping with the
accelerating change dealing with varied
perspectives you know having flexibility
so you not everybody's viewing the same
rigid canonical master data management
perspective kind of thing which hasn't
really succeeded particularly well it's
incredible my discipline to try to
impose master data management and of
course anytime you impose something in
an organization it's always going to be
reacted to so you know you want
flexibility for perspectives and in
flexibility to deal with the
interoperability problems right things
that you're going to be interoperating
with that we can't conceive today right
i mean we just don't know we we don't
even know what's gonna be coming out six
months from now if you think about how
fast these trends are coming so we net
we need I for IT itself to be resilient
we need to get up on top right we IT has
to raise itself over this like you know
bubbling ocean here so yea big marketing
claim we've reinvented middleware and
well now say how so a light a light
weight scale out architecture for
responsive and highly connected
processes and I would actually say that
that's probably a lot of the problems
that you're working with have to deal
with now processes that have to connect
right between maybe systems machines
devices across silos across
organizational boundaries right so being
connected is really important being
responsive data-driven and scale out i
think is of course obviously
increasingly important so you know the
kinds of behaviors you want to be able
to do is personalized user experiences
you know mais every customer experience
dynamically enforce compliance right GRC
kind of apps are very difficult to do
right governance risk and compliance or
you have a whole bunch of hard-coded
apps and then you want to do GRC over
the top so you create cargo de gr
the apps over the top of those
hard-coded apps any party to that
changes and you've broken the GRC
compliance right and so you know we've
you know it's got some you know a lot of
things to reconsider here automate IT
governance right i mean they we should
be enforcing you know software too far
sdlc kind of policies we should be on
automating IT in general
interoperability itself and then
optimizing these pipelines as well to
write so getting away from static
pipelines to your meta data driven
dynamic pipelines right over anything so
actually having systems that could do
all of these and of course this is
pretty a pretty big gamut from user
experiences and building you know human
processes and workflows to your
pipelines and again normally this would
be done by a wide range of systems and
what we're going to be talking about as
a system that does this in a 32 megabyte
footprint and you create value change so
how do we radically simplified
distributed processes right that was the
subtitle of the talk was distributed
processes it was we have you start with
a unified object model right if
everything's diverse and it's
potentially distributed then it would be
really an advantage if I could create a
consistency layer over the top of these
things if I could go to a space a
logical space right because some of
these things are be federated but a
logical space but it's not just a
logical data warehouse because its data
and code right so now it's your github
it's your it's your logical data
warehouse it's one place where I can
look at all of these things and now I
can navigate them I can i can start
navigating them as if they were resident
in my laptop or right in my local system
right I could start like walking all the
relationships because everything's been
described in metadata right so now I can
navigate all these relationships between
these diverse objects with a unified
object model gives me shared methods
right so this is a you know precepts
that come from the mainframe the
mainframe everything was just zeros ones
addresses with you know over stuff that
encode live together right and it gives
you incredible compressive power because
i can i can do common methods over these
things in common management right i
don't actually have to segregate
everything right middleware was about
getting things into boxes right and what
is them what is the middleware component
right its patterns trapped in a box
under a syntax that's what middleware is
right so you know I deal with patterns
right we can we can interpret patterns
patterns don't have to be under separate
syntaxes we can have common common sin
taxes for dealing with patterns right we
don't actually have to do everything as
a building compile we can actually
interpret patterns right this is soft
this is software not hardware right we
shouldn't be fixing our constraints we
shouldn't be locking things down the
whole idea is it should be mutable so
when we have shared methods in common
management that's where things like you
know common policy management imagine
how powerful you'd be if you could
actually write policy from one place and
have it run across a micro service and
API and a web service as well as in
process objects and it would apply
security or any other policy and the
system would handle the implementation
detail over those diverse and
distributed objects right that's the
that's you know I'm not hearing that
people have this capability so I think
that this is you know hopefully some
things they'll be compelling to you and
we're also talking about moving
middleware functions as is moving them
away from components but actually taking
those middleware functions essentially
liberating them as patterns and
interpreting them in real time so the
system that delivers middleware
functions as services that can run
across data centers so you're not
building stacks all over the place right
we're dentally having all these room so
I can only imagine you the stacks that
some of your organization's have and the
amount of hardware and infrastructure
that you have for what we're talking
about is not your solutions we're
talking about your non differentiating
middleware I remember let's make sure we
we separate the fact that your seat
nobody in the business ever asks for who
your complex event processing vendor is
right they don't really care right they
don't care who your ESB vendor is they
never asked for a BRMS business rule
system they don't ask who your BP then
they don't order they care about
behavior they care about the application
those things are just lower level
technologies implementation details so
that's non differentiated middleware to
deliver some capability but we can
deliver that capability different play
its software ah and do this over a
mutable shared memory of course you know
mutability we're actually made separate
assess information from the state
processes from their stadium for
that's going to support you know
scalability is going to separate
concerns shared memories and allow us to
facilitate inter-process communications
but torrent between running processes
now you can actually have processes
monitoring the events that are being
thrown by other processes and now they
can be triggered as triggers and when
we're going to I'm hoping we can do the
demo you saw that I couldn't get online
and I couldn't even get to go to meeting
but we'll try because it's actually of
course I want to explain it to you then
I wanted to show it you will see if that
works out that way and to be horizontal
scale out plug in fabric and i want to
point that out because we by no means
are trying to say where every endpoint
right it wouldn't be we're never to be
every algorithm we're not gonna be a
function or a platform we're delivering
platform services data services
integration services workflow services
right that you can then combine in a
declarative way with your objects to get
behaviors that you want and do that very
flexibly with rollback trace everything
being parallel by design everything
being built over a single actually
another aspect of it is you're talking
about a single middleware layer with one
scaling characteristic right when you
build component architectures you have X
component scaling are you know
characteristics oh so a plug-in fabric
where you can plug in all these things
so you know what does this look I mean
you guys are familiar with this with the
stack the sack adds that complexity
right and obviously doing it simple
simply you know we talked about being as
strong as the weakest link and what
we're talking about is saying well all
the fundamental capabilities of this can
be can be stored in a single system
right and if you think what the system
becomes it becomes a library right
that's a natural trajectory if I think
the future of IT all right libraries are
for what sharing right not isolation
right I mean so this whole thing about
like you know you know microservices
isolate microservices will absolutely
have use cases and they'll have some use
cases for some you know big web scale
companies more so than other
corporations but and they'll have use
case in general use cases as well so
it's not it this is not
not picking Dogma right a dogmatic fight
whatsoever you know you pick the right
tools for the job and what I'm saying is
all of this is schmatta right none of it
matters right nobody ever asks for this
nobody really cares what your schedule
there is right and think of the stacks
we're asking people to build now right
think of the things we're asking people
that developers to take responsibility
for and a lot of these things especially
when they're open source or really
half-baked projects right they're
evolving very rapidly and you're trying
two coats and you're trying to integrate
stacks with all these different open
source projects let's be honest a lot of
them are actually half baked right I
might I don't know if you guys work with
OpenStack or as any my work here with
OpenStack of course of course you have
so I mean OpenStack is 10 12 projects
each project representing a dozen
microservices maybe they're not even
economically they're not really treated
in a disciplined way as microservices
there's they're not architected together
there's overlap between the sets of
micro services delivered by the
different projects they're supposed to
work together but they don't O's work
together there's a thin python api over
the top of them and he changed to any
one of the projects breaks the ipi
you're out of luck right and so you look
at that and say well it's called
OpenStack that's the tail right
OpenStack it's a stack right and so we
get em you look at big data and the
stacks were being asked to do and the
kind of schedules and other things that
people are being asked to put together
and you know they're at Yeti they all
add capability they're all being done by
thoughtful smart good people but I think
we have to step back and look at the
bigger problem the bigger problem is all
of that cumulative complexity and it's
accidental complexity one is just
hurtling into your enterprise right what
is just hurtling into your organization
so you know less cruft more stuff right
if I can get rid of that think about the
how chatty that network is right think
about think about you know when and when
you guys design applications you you
have a sense of what you can add you can
expect I oh wise right and you'll
throttle your design sometimes right
based on somebody's asking you a big ask
that'd be really I Oh intensive then you
have to make considerations about
whether that I Oh can be sustained
delivered in a reasonable time frame
that's going to have customer
satisfaction right or end user
satisfaction right and what were I'm
saying is well if we strip this out
where benchmarking against all the major
open-source tax now and we're showing 50
to 100 x improvement 50 50 to 100 x I
ops and compute cycles being liberated
and what we do is we take that because
we work over this one thin layer it's
horizontally scalable it's all done in
graphs so if i don't know if you know
there's an advanced and one advantage in
graphs is adjacency right and in a graph
everything is essentially one hop away
from everything else right we don't have
to deal with foreign keys we don't have
to do complex joins it's just a graph
it's just an unstructured graph
everything's tagged and linked and if I
need something I can get to it I get to
it directly i don't have the in
direction um that i would have in
working in a conventional system so you
know i think i have actually start
covered quite a few of these but in
general at least this deck is going to
be made available through the good folks
here go to UM so you sigma chi mikhay
read this to you but actually it's a so
there's a whole bunch of problems and we
discuss most of them but actually one of
them i want to point out right away is
you the stack architecture doesn't
actually allow for complex computation
right i mean essentially the output a is
the input at be right and that's a
really limited computation right when
you're pushing these messages and if you
have a complex problem the question is
do want to take one problem that's
complex and distribute it through ten
components which is effectively the
equivalent of me whispering in your ear
my solution you were spraying your
combined solution into his ear and
passing it out is that the best way to
reason over a problem or would it be the
best for us all to talk put the problem
in the center of the room talk about
that problem reason over it really
quickly because because what's hi what's
not happening is as you move down the
line they're not having the benefit of
the cumulative state right you know
you're instead of working like a if you
were a detective on a crime scene you'd
be picking up pieces of evidence you
wouldn't be making your determination in
a linear static linear fashion right
you'd be making observations you'd be
collecting pieces of facts you'll be
making connections between those
different pieces of information
and then you would you would actually
make a determination at the end it's the
same way a doctor makes a decision right
doctor doesn't make a decision just on
one obvious factor but they're going to
look at many things so that's in so you
know this is an example of a small
middleware stack and again I think the
representation hopefully is is clear but
that's a relatively simplistic stack and
you know obviously it's a fragmented and
complex application architecture and
this is simple that's what it simple
transaction looks like all right just
going in and out of all those different
components and right away you could say
that's not super pretty you know and the
problem here is as your problem as your
solution space increases in complexity
and scale and and if complexity means
adding more capability means adding more
components right and scale might be some
of these might have to scale up this
problems going to become increasingly
complex right so it doesn't scale out
then late interprocess communications of
us of this type will have these
challenges you know across the board and
you know you're having a lot of
inefficient processing over we're done
in non differentiated middleware and
this is how what we look like right we
run as we run as we can run as a virtual
machine distribute ourselves dynamically
scale that up ourselves we can manage
our manage our own distribution over the
over the network its runs as one system
runs as a web style key value dip let's
only like I said 32 megabytes footprint
with with our base system libraries and
it's just one thing it's just it would
look to you like it's a web server right
it would look to you like how could it
actually do anything we don't need an
app server we don't we run inside any DB
whether it's Cassandra or sequel or my
sequel or postgres our Microsoft Oracle
sequel we run as a long skinny table
right and that long sitting tabulates
web style so key equals URI so we have a
namespace value equals resource resource
going to be anything so it's a file
store so now it's a web style key value
that's a file store could essentially
you are I could be over anything
right structured unstructured
semi-structured right we're going to put
a piece of going to put an xml file on
top of each one of them so going to be a
document store we're going to put
properties on the on the on the piece of
xml that's going to make make make it a
graph and then we're going to use those
graphs to represent objects and now we
have a website evaluate graph object
store right and a multi what they are
now calling do any of you work in no
sequel space or in the DB space a little
bit so i'm officer crossing categories
and I'm but you know keep in mind if you
work in the micro services they're
expecting you guys we all full stack
developers right everybody can have to
manage the db2 what we're doing is we're
extracting the DB itself we're saying
you don't shouldn't have to worry about
what the DB is you shouldn't have a
worry about your data structures the
fact that we have you know 15 different
kinds of databases nowadays is not a
really an advantage to you it's
recreating the middleware problem in the
database space right it's over
specialization every solution is a
specialized solution every specialized
solution now compound's your
interoperability challenge so you add
capability you pay for an
interoperability right it's an inverse
relationship between the capabilities
you want to add and the interoperability
you also want to have and we're saying
is that's a you know again a false
binary it's a it's a bad trade-off it's
it's a smell right if I'm always adding
capabilities and capabilities come at a
cost you know this is a mistake sorry so
now we're talking about an architecture
that just essentially drops into a box
it run it deploys running we deployed
inside sprint in 15 minutes right oh and
we're doing really crazy stuff over our
OpenStack for them right OpenStack
docker Andy at VMware ESXi their
engineers were able to start building
network we're called network services
that morning out of the system because
this isn't construction zone you eyes
they didn't do any system integration
they didn't do any database tuning
configuration of tuning we just Louie
said you know through a database of your
choice in there right we need Java sir
it's a we work on the JVM so give us a
Java servlet container with tomcat
whatever right jboss a glassfish
and boom we just deploy and it's running
that's it the no system integration
they're going straight to adding value
right straight to building stuff right
and this is sort of my give the point
I'm the recurring point is like that's
what you want to focus on the business
value you know making new connections to
disparate stuff and adding business
value that's all that ever matters so
now you're talking about a unified and
horizontal application architecture and
that's what a transaction looks like in
our system a transaction is just you
know because we're extracting you know
all the underlying infrastructure below
right it's just just making just making
calls over over this and it scales out
and actually um so it's scales naturally
with activity in complexity right you
add things to library you want more
complexity you add more end points to
the library all right and those
endpoints could be local right they
could be in process object so can be
remote objects and even if their remote
objects I think there's something
interesting to consider is obviously if
we're going outside the system and we're
grabbing capability data or state or
going to configure something outside the
system the laws of physics apply to us
too we haven't overcome those but the
really cool part of this is well in a
way we do actually make the problem
better because because we have a meta
data representation of all those
federated components we could do our
reasoning in telecom you say east to
west i could reason across those
distributed and diverse objects without
actually touching them right i
understand i have descriptions of them
right i can i can reason over those
objects make my decisions and then
implement when I want to implement I
don't have to call call call call call
call figure out what I'm gonna do right
I can actually just go you know reason
in this thin single layer right really
quickly right use that I the advantage
we have in the I ops and the compute
cycles to do you know all these resource
fetches and transformations and then
implement vertically as we need to so
some big advantages over here so this is
now getting into the abstraction so this
the whole system is based on an
abstraction that everything can be
represented as a graph object which is
really modeling a set of loosely coupled
relationships we just wanted a deal with
consulting a large consulting firm that
is going to build a global practice with
us here in Chicago we actually have one
largest SI p integrators utopia is right
out of Chicago there are large
independent SI p integrator they're
building a fabric over SI p because SI p
doesn't have common objects across its
components i mean even over its own
stack so they're going to be putting us
as a thin lightweight layer for doing
managing data migrations data governance
over over that stack so but my point
here is we've taught them how to build
and develop solutions on their own in
like a day right because once they
understand this concept almost cycle
started liberate themselves and say
everything can be in a library and I can
declaratively come right logic over
these libraries and then they see the
behavior at first they certainly don't
believe it I've had people here he'll
tell me that like I'd I have to see that
to believe it but like I'm just writing
logic / libraries right and now guess
what the logic lives in the library too
right so you get this tremendous amount
of reuse because that's one of the value
propositions of libraries right
everything is very abstract because it's
all being done declaratively and then
the system handles all the
implementation detail so when we talk
about modeling the application graph and
when I talk about dependencies I'm
really talking about dependencies writ
large anybody guys familiar with 12 f
you familiar with 12 oh so 12 12 f is
you can google it i think it's 12 f dot
org and i'm trying to think which
company actually came i want to say it
was base camp I want to say they it was
some of the people from there I can't
really remember i think it was and they
came up with and said came up with the
characteristics of what you'd want to do
to build web scale apps and they call it
the 12 factors 12 f and it's as she
interesting so when i read it you know
years ago and actually sort of hinted at
microservices even back it goes back
like four or five maybe six years for 45
years it sort of hinted at micro
services in isolation but it's
interesting it really if you were to
look at the 12 items really almost all
I'd say three cortisone really talk
about relationships of an object right
they say you really want to you know
have loosely loosely coupled isolated
dependencies of your application
resources you want your config your
configs all available
right you wait for your application you
want to have your your pointers to your
code base but they treated those all
different things as most people do in
the application development world right
they they think of these things as being
completely discreet my logs are discreet
my code bases is greed my application
resources environmental with my config
files my backing services you do them
all separately the divorce behaviors my
connection details and we're saying well
gosh because they're just pointers to
stuff right there just my pointers to
information about this thing right I've
got an end point and it has connection
details great cool just can you describe
that and the details cool well now we
have a meta data description of that
right backing services right we can we
can put pointers to backing services we
can have files representing the
environmental variables application
resources and we could do that so that
any time I pick up an object I pick up
that object and I can see all of that
hanging off that object right and if i'm
a developer i can reason over that
individual object and all objects the
same exact way and see all of these
relationships in one place and if i can
see them all in one but not have to
worry about how they implement right
because not only can a human look at
them and understand them as well
understood isolated objects system
agents can understand them as well and
they if i compose with a bunch of these
and i literally just use links and
metadata and say I want to take these
end points I'm going to bind these link
I'm going to actually just declaratively
connect these links and end points with
metadata and links meta data link
submitted our references um then you
that makes complete sense I could look
at it it's completely illogical
description of an application right
it'll be they'll actually tell me well
on these conditions call these things
and it'll keep on everything will be
just a reference to an end point and I
just follow those that we can have
complete referential integrity right
I'll be able to be able to trace every
dependency to data code config files all
the way down right in one system and
then getting surface or surface that
visibility and then the system will
execute all the the integrations for me
and the value proposition of that is I'm
no longer pre optimizing by tightly
coupling my applications to my services
right I've actually just I declare my AP
is my third my remote objects to the
system they're all loosely coupled to
the system they're all being essentially
connected to an information model my
applications and processes point with
metadata and links to the information
mountain to model and now I've created a
separation of concerns between my
service abstraction layers and my remote
object abstractions and the application
behavior I want well there's a lot of
butyl out of Ben Offit's of that right
because now I can separate model from
implementation if I actually tightly
couple everything in advance so I can
tell you what the behaviors of every
application is going to be it's going to
do specifically that but it's not going
to do anything dynamic all right because
every kind of every condition is going
to be predefined here in our system is
it can follow any algorithms to say okay
this time you know grab this end point
because of these sets of conditions use
the in-band metadata from the
transaction from the interaction with a
human or system client to bootstrap the
interpretation of this object follow all
of the relationships and deliver an
optimized solution for every interaction
if you know gets away from the brittle
nature of applications because if their
underlying resources are changing and
it's a non material change it doesn't
break it doesn't break the semantics of
the service it won't break the
application now right whereas today does
break the application now because we're
loosely coupled to it I can just be
grabbing those latest updates of all
those endpoints and the system will chew
through them so it's going to evolve
forward and if we were able to do the
demo you'd actually see that it's just
pretty neat actually and we usually even
do part of our demo we purposely break
something we we put in something that
would be overtly you would know to be
bad right and then we say oh go look
look how does the system behave right
because we can do a real-time trace of
what the system did we literally the
event we've now we've been in production
for four years we've never had a crash
for years all right we got some big
customers right and no crashes so I can
look at the transaction I could see the
if I'm a developer I can actually look
at the failure mode it's like literally
a link to the failure mode it gives me a
trace of every single thing that the
agent did to execute that well first of
all this the system doesn't fail the
application doesn't crash the page
doesn't break right the only thing the
system couldn't deliver whatever there
might be an endpoint or something that
was missing or unavailable whatever it
was and literally it will highlight what
wasn't available right give me the link
to that object I link right to that
object I can see the
object right and I could follow if it's
out of the system I could actually
follow it all the way back out and
actually debug right on the fly since
its dynamic system there's no building
and pile I could just update it fix a
change as fast as I broke it right just
fix a change and save it boom and the
page is running again right so because
what I'm doing is the system seeming
those changes remember I said it's an
immutable store so anytime you change a
resource or amended resource or it's
been updated the system doesn't append
to the DB right so all i did was am i
fixed it when I broke it they were there
was an append right I could either
rolled the resource back or I could you
know do a new save over the top the next
time that I refresh that other page
where the person was trying to do
something that broke it will now just
run right through and be not completely
non interrupted and the complete history
of what the developer did will be
traceable what the business user did
will be traceable the life cycle of the
resource will be available everything is
preserved and it actually scales
beautifully you think about wasn't how
do you save all that history and it
makes it like the ultimates the
ultimately audible system right because
we're storing common thing common
methods right we have lifecycle
management over everything right so
whether it's static code you know
service API microservers doesn't matter
it's all going to be version control the
same way all be traceable inaudible the
same way but we're just managing the
deltas right since these little deltas
and then we construct views from the
sums of changes right we are all well
ordered temporarily ordered a series and
so then you can compose these objects
into higher order things and they could
be you know you know complex functions
entities data models how much time that
I've left actually by the way it's
almost over 23 minutes okay so but i'll
get i'll give you a you know one good
use case and try to describe a three-way
scattered in a couple of customer
references just to give you some ideas
of how people are using it but i'll give
you another one is lots of times when we
go and i'll make it really something
that everybody can bite on right so a
lots of times i go into organizations
and they never have a single decent
single source of truth right i mean
that's a real struggle for a lot of
organizations even if they tell me
pre-sale they do even if they think they
do they do
right and so even something as mundane
as a people table right is I don't have
a single people table where all that
people reside right there's some people
are now the absolutely blow over here so
people over here somebody all right so
no problem ok we'll declaratively model
all the sources right so now we've got a
model representing all the sources will
create a composite entity that maps all
of the sources will put config files
between the sources and the targets
because I now we can have one
representation of all of them all of
those sources get to continue speaking
the same way so we didn't impose one way
of speaking right they all interoperate
the way they interoperate the config
files are just other files in our in
that library right there almost nothing
for the system to blow through right and
the system so the I got config files
between my sources and targets now that
composite entity can be extended by more
with more metadata that might be richer
inside the system right I could use that
composite entity to drive now really
cool data you know data-driven apps
inside our system but I can also point
it back out as an API to the legacy
right to the Central Europe II and now
they have a single source of truth we do
that in like a week for major
organizations and most of that time is
just for them to figure out what the
sources are give us some basic
descriptions of that information we
point them in the right direction get
things going ask them to do make sure
you know preface that it should be clean
right and in all this kind of common
things but that's done in a week and
also now we might have come in to solve
a real specific wicked business problem
that will need to be data-driven and
scalable and now we just solve the
really wicked IT problem of how do i
make master data management flexible
right and then the power all of this is
that we're doing it through flexible
graphs right the way we do everything in
IT is do hierarchy right and the way
we're doing everything a hierarchy is a
form of static graph right with fixed
structures fixed structures are the
enemy of agility right the more fixed
structures I have the more static
structures I have the less agile I am
and this is just just laws of nature
right so what but a graph can project a
hierarchy right I could say present
these as parent-child relationships boom
and now I can actually have something
that looks concrete but it's abstract so
going over another age-old problem
actually we just dropped off our
packages to fedex right and i was joking
because they you can't have one fed
account for the copy shop and the
shipping I know if you know that they
bought kinkos what six seven years ago
they still don't have one sense system
you have to have two separate accounts I
said that's so be my partner we were
last or her choking I wish I got that
job um and they have two separate
systems well this is a pretty common
problem company made doesn't merger they
want to move a division under an
unmoving unit or SETI units under
another division so high that take some
18 months 24 months got some 5 10 15
million dollars right this is real world
stuff happening all the time for us
you'd grab that you what would be in or
an organization chart in our world would
be a set of loosely coupled units with
parent-child relationships right right
the describe their connections right
it'll be logically bound not statically
bound if I want to move a unit to
another division I literally drag it to
that other division and it reek licks
and it now has all any kind of trickle
down rules will now come from its new
parent but it's complete history will be
preserved because it's all immutable
right we know that it once lived under
this parent and in all its history was
from here and now it lives under this
parent if there's other lower level
details that didn't even modify that's
fine but the structures weren't static
right so that's probably my cue ahaha so
I'm sorry didn't get to the demo III
know this was a lot of a lot and I just
dumped it on you but i do want someone
to allow for questions I'm happy to stay
longer i don't know if anybody else
comes into this room next you yeah I'll
linger outside the door for a little bit
cuz we actually just shipped our booth
home so I'm happy to answer questions
but that makes sense there you go
alright hope that there was some value
in there I'm really asking you to think
differently I think that there's maybe
you know it's 2015 and maybe there's
other ways we should be looking about
software maybe we really should be
thinking about automating things making
things much more declarative over the
top at a higher level of attraction that
was a point today thank you
sure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>