<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Pragmatic Microservices • Randy Shoup | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Pragmatic Microservices • Randy Shoup - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Pragmatic Microservices • Randy Shoup</b></h2><h5 class="post__date">2016-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9vS7TbgirgY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi I'm Randy shell and I wanted to
talk about pragmatics microservices and
this talk sort of came out of I've spent
the last couple of years evangelizing
micro-services I've worked at Google and
eBay so a bunch of environments where we
did micro-services a lot and then it
became clear that everybody was talking
about how great micro services are but
nobody was talking about how to make the
decision to go to micro services and to
give people a sort of principled way of
deciding whether to go in that direction
or stay with what they have so how many
people are already on a micro services
architecture in the room surprising
amount so maybe a quarter of the people
so this talk is more for the three
quarters than for the one quarter cool
so this like I said I used to work for
Google and for eBay and a lot of things
that I want to talk about here came out
of conversations that went something
like this
so I live in Silicon Valley and I advise
a bunch of startups and conversations
would go hey Randy tell us how you did
stuff at Google and eBay and I'd say
sure I'll be very happy to tell you but
you have to promise me not to do it at
least not yet so large scale
architectures that that are the sort of
poster children of micro services
evolved they didn't appear as micro
services in the beginning so to take an
example from eBay depending on how you
count
eBay is on about its fifth generation of
its architecture so it famously started
as a monolithic pearl application that
the founder wrote in a three-day weekend
in 1995 it then moved to a monolithic
C++ application that at its worst was
3.4 million lines of code in a single
DLL so please don't do that
it then migrated to a java-based a Java
based infrastructure which was
partitioned but not really micro
services a bunch of parallel
applications and finally I think it's
fair to characterize the current eBay as
a micro services architecture so Twitter
went through a similar evolution so
depending on how you count Twitter's on
about its third generation of its
infrastructure
so it started famously as a monolithic
rails application which my Twitter
friends tell me was nicknamed the
monorail which I thought was quite
clever then moved to pulling out a bunch
of the front end into JavaScript a bunch
of the back end into services mostly
written in Scala and now Twitter is
mostly is Apollo is a polyglot set of
micro services and Amazon has gone
through a similar evolution they're not
so clear there aren't so many so clear a
distinction between the architecture
sort of boundaries but it started out as
a monolithic C++ application a bunch of
services written mostly in Java and
Scala and now Amazon can be
characterized as again a set of polyglot
micro services so there are two things
to notice here one is that companies at
large scale ultimately end up evolving
to micro services absolutely true and
it's absolutely the right choice for
them a large scale but none of them
started that way right so that I think
the key thing to take away and what I
want to leave you with is thinking about
the is the steps along the way in the
evolution and making the right choice
for where you are now or another way to
ask the problem ask the question is our
micro services really the right solution
for every problem and I think the answer
is no so to break it down I wanted to
talk first about some model monolithic
architectures then I wanted to talk
about some of the characteristics of
micro service architectures then I want
to talk about the Ryoka textured
decision how is it and when when are we
going to make the decision to react
attack potentially and finally I want to
give you some suggestions from
successful reactor textures and I've
been involved with about some tactics
and strategies you can use to make that
ryoga texture successful so first I want
to talk about monoliths so we like to we
like to feel sometimes that monoliths
are bad and we should feel ashamed of
them but as as as you heard a moment ago
all those companies that we've heard of
and maybe use every day all started as a
monolith and there are actually real
advantages to having a monolithic
approach right it's certainly simple at
first it's a very simple approach at
small scale all the latencies within a
monolithic application are in process so
it's it's quite fast typically it's a
single codebase and a single deployment
unit so that has some nice operational
simplicity's and it's very resource
efficient at small scale
there are lots of cons that come along
with monoliths too mostly that occur at
larger scale so the coordination
overhead grows substantially as your
team size grows and Rodriguez excellent
presentation about zalando earlier today
gave some really crisp examples of that
there's poor enforcement of modularity
with which Adrienne pointed out in the
keynote this morning so there's nothing
that's going to help that's going to
force you to be properly module between
individual components and a monolith it
also you also get poor scaling so
typically in a monolithic application
you only get the vertical scaling option
you don't have the opportunity to break
it up into smaller horizontal pieces and
finally the monolith tends to be a
single point of failure both in terms of
bugs and in terms of sort of operational
availability but when when you have a
monolithic architecture or maybe the
most sort of monolithic aspect of it
tends to be the database and this is
actually something that my current
company stitch fix in the US is
wrestling with right now so the pros of
having a monolithic database are again
that it's very it's very simple it's
simple to have everything all in one
place join queries where we want to join
multiple entities together and get and
do queries across multiple tables are
very easy in in a monolithic database
you get the benefit of transactions so
that actually has some really nice
really nice properties makes it makes
life a lot easier certainly and then
again it's very resource efficient at
small scale but but the and the problems
that that a that happened with a
monolithic database tend to again happen
at larger scale so the database tends to
be a coupling point for your team over
time it tends to be a tensed it at
larger scale it becomes a performance
and a scalability bottleneck it can be
difficult to tune a monolithic database
properly right if a database is doing
lots of different things as Adrienne
pointed out in the keynote if it's
really your kitchen sink then it's hard
to get hard to tune it for any one
particular use case when you're using it
for bulk reads large scale queries fast
reading reads and writes of individual
records all those things are you know
different tuning would would leverage
different tuning approaches
and are difficult and if you have one
that's one database that's doing it all
it's difficult to tune it in a global
way and then finally the monolithic
database becomes a single point of
failure but if you're in a monolithic
situation you can set yourself up for
success even without moving to micro
services so one of the things that I
strongly recommend is exploiting the
natural partitions in your problem right
so lots of different problems problem
areas that we face every day and are
naturally partition into into separate
areas so if you're writing an e-commerce
site like eBay that naturally partitions
into the buyer side and the seller side
if you're writing a ride-sharing
application like uber or lyft that
naturally partitions into the writer
side and the driver side and similarly
search engines naturally partition into
the crawler the indexer in the query
engine so and then the next thing that
you can do is force yourself and force
your team to have the discipline around
keeping modular boundaries within
components so you know I'm old enough to
have no hair anymore and 25 years ago we
didn't have micro services but we did
have modularity right so it's definitely
possible even in a system where there's
one application or one binary to have
modular divisions between individual
components and that internal component
is a ssin gives you a lot of the the
cognitive benefits of dividing of
distributing into micro services and
also as you want as you decide to move
to something more like micro services it
makes those individual components easy
to modify or replace with a remote
service and then the final thing that
that is critical I think to sort of a
healthy monolith is the ability to do
continuous delivery in other words the
ability to do rapid improvements rapid
releases to to the code and that allows
you to rapidly evolve the monolith and
it also as we'll see in a moment allows
you to rapidly evolved from a monolithic
proach into micro services if that's the
way that you end up wanting to go okay
so that was a little that was a brief
tour of monoliths and now I want to talk
about micro service architectures so
it's a bit funny that we haven't we've
gone a ways talking about micro services
today but but I guess we haven't really
defined them
so to me the important characteristics
of a micro service are that it be single
purpose that I have a simple
well-defined interface and that that the
individual services in a micro service
architecture be modular and independent
of each other and something that we'll
talk about a little bit later is in
order to be really successful by
contrast to the monolithic database
that's maybe shared with lots of
different parts of the system in order
for microcircuits to really be
successful we need the individual
services to own their own isolated
persistence so now you might look at you
might look at something like this and
say this is a new idea well you know the
idea the word microcell so if we knew
it's only a couple of years old but the
concept of dividing a system into these
individual independently cooperating
components is is quite old and to my
mind micro services despite the
fanciness of the word are nothing more
than a service-oriented architecture
done properly so I want to talk now a
little bit about the sort of pros and
cons to micro services so each so one of
the nice nice advantages of a micro
services approach is that each
individual unit is simple so that's the
idea of the micro service it's a very
simple individual component you can now
independently scale you can
independently scale them and they can
have independent performance
characteristics you can also I think
this is less well appreciated you
because the micro services are small and
independent it's a lot easier to
independently test and independently
deploy them I mean that can be a real
advantage in a large-scale system and
then finally because micro services are
single purpose it allows us to
potentially optimally tune the
performance of that particular part of
the system so we can introduce caching
for example behind the behind the
service interface or introduced a more
appropriate data structure or game
storage mechanism which allows us to
tune the performance of that particular
part of the system optimally some of the
cons of micro services are that ok each
individual unit is simple but now you
have lots of different cooperating units
and the complexity of the system has
changed so it's now now we have
individual simple simple
but some of the complexity of that
system has moved toward the interactions
between the units and and if we don't
have really good monitoring as I'll talk
about in a moment that's going to be a
place where operationally and sort of
development wise we're going to be blind
to those complexities so we've also in
micro services now replace those in
process Layton sees now with Network
latency so now we need to be a lot more
careful with making calls in parallel
making calls asynchronously dealing with
all the issues of long of relatively
longer latency between for the calls
than we might be used to if everything
was all in process we've lost the
ability to do transactions there are
lots of things we can talk about
separately if you like about ways we can
get some of the some of the nice
benefits of transactions back but you
don't get them in a nice easy freeway
and microservices also are a situation
where we require a lot more
sophisticated tooling and a lot more
dependency management than where them
were used to with a monolith so one of
the things I want to talk about now are
some of the prerequisites for being
successful with micro services and
you'll see some some major parallels
with what Rodrigue talked about earlier
this afternoon because he's actually
he's actually really lived it so I first
want to talk about process maturity then
I want to talk about organizational
maturity and finally operational
maturity and I think if you don't have
all these these pieces in place that you
should work on dealing with these pieces
before moving to something more before
moving to micro services so the first
area I wanted to talk about is in
process maturity and here I want to
highlight the idea of continuous
delivery so it's a nice to have in the
monolithic world it's an absolute
requirement when we're in a micro
services world so what we need to have
happen before we can successfully deploy
a micro services approach is to have a
really repeatable deployment pipeline
where we have low risk push-button
deployment it's really easy maybe one
line in a command line or a button in a
UI that allows us to do a really rapid
release cadence so we're able to release
potentially mobile multiple times a day
and also critically allow allow us both
to to rollback and to recover when those
two
clemont's don't work I don't work well
the other aspect of continuous delivery
that's important here is is to have a
strong emphasis around automated testing
and all of the all the places that I
know that have really done well with
micro services have adopted automated
testing straight away so it's important
here that the developers are writing the
tests and encode at the same time so as
I'm not done with my feature or my
change to the system until I've both
written the code that implements the
feature and also written the code that
tests the feature it's less important to
me whether it's test driven or test
first but I'm not done with that with
that piece of work until it's both
written works and ends tested and this
allows this gives us the confidence to
make risky changes to the software and
to release it many potentially multiple
times a day
and then the last element here of
continuous delivery is continuous
integration so by definition a micro
services architecture is a system where
there are lots of cooperating components
lots of lots of individual micro
services flying around so it's important
that we be able to test the interaction
of those system components before we do
deployments so we can do we can
understand that those interactions are
going to work correctly in a safe way
before we before we deploy it
so after process maturity I want to talk
about organizational maturity and I want
to mention again the same thing that
quadric mentioned earlier about Conway's
law so as you heard earlier the organ is
a con way said in 1968 that essentially
the organisation of software of a
software organization constrains the
architecture that we're gonna that we're
going to produce and in particular the
design of a system is going to be a
reflection of the communication paths
within the organization so he meant this
as a descriptive situation he was
describing the scene that he saw in a
bunch of organizations that he worked
with and but what he noted is that the a
modular system a system that had
something like microservices actually
requires a modular organization and so
when we have small independent
teams that are able to operate
autonomously that get that ends up
leading more directly to more flexible
and composable systems whereas when we
have monolithic teams that are quite
that are large and interdependent that
ends up leading to more monolithic more
interdependent systems so it's it's a
direct there's a direct relationship
between the organizational structure or
the organizational architecture you have
and the software architecture that
you're going to be able to produce and
so we can use this not just in a
descriptive way but also in a normative
way meaning we can in order to get the
system that we want we can we need to
engineer the organization so one of the
things that I strongly recommend is if
you're considering moving to micro
services one of the first things did you
consider doing is breaking up your
organization into smaller pieces that
parallel the services that you want to
build so a little more detail on that I
like to talk about this I like to talk
about the micro services organization in
the form of service teams and this is a
this is a term that we used at Google
Amazon and Netflix also also talk about
these things similarly so individual to
individual service teams are aligned
with particular domains of the business
so each team has a clear well-defined
set of responsibilities and an
individual team is typically responsible
for one service or a small set of
related services those teams intend to
be cross-functional so and what we're
trying to get here is that is that the
team is self sufficient the team is
basically able to get its job done
without needing to involve lots of other
teams in a in lots of having to talk
with lots of other teams in a very high
bandwidth way now obviously every team
no team is able to do everything on its
own it should rely on other teams to
provide you know supporting services
supporting libraries and supporting
tools but that's more of a hands-off
relationship but then and and most of
the work that an individual team would
need to do is isolated within within the
boundary of the team and then the other
important discipline here is that team
should have end-to-end ownership of the
software that they build right so the
team owns the service all the way from
design through to development through to
deployment
all the way to retirement so when I
started in software you
to be that our team was done when we
threw the code over the wall to the
operations team now that was a terrible
situation for both the development side
and the operations side now a team is
only done when the service that they're
providing is no longer being used any by
anybody right a team is only done when a
service is retired and this very much
parallels the DevOps philosophy of you
build it you run it so the last
prerequisite that I want to talk about
is an operational maturity around
monitoring so in order to be successful
with micro-services we really need to
have a strong practice within our
organization of deep very highly
detailed end to end monitoring of
production systems and what we need it
here is the ability to detect and alert
on issues that occur anywhere in the
system and the way - the way to
understand whether we've got that or not
to sort of a metric that you can use is
we need to be able to have sufficient
monitoring in order to be able to
remotely diagnose issues that occur in
production without having to log into
the individual machine so the thing that
I like to say here is if you ever have
to ssh into a machine to debug a problem
it's because your monitoring has failed
you so that's a bit about Microsoft the
micro service architecture and and some
of the ways that we can be successful
with micro services now I want to talk
about the decision process that we would
go through to move potentially from a
monolithic system into micro services so
I want to ask the question why are we
going to RER Kotak and they're typically
tend to be tend to be one of three one
or several of three three answers so the
first reason that weari architect tends
to be around velocity or or in Claude
Reid's example from solando we talked
about this in terms of an innovation so
here the reason why we would we would
change is because our time to market is
being constrained by the lack of
isolation or the coupling that we find
from in the monolith also another
example is that teams could be stepping
on each other's toes while trying to get
their work done right so teams are no
longer really able to develop
independently because the because the
interactions with
the monolith are are too difficult to
deal with and then also the other the
other metric is how long does it take
for new engineers joining your team to
be productive or more precisely how long
does it take new engineers to be able to
feel safe that they can check something
in without breaking something right so
in addition to velocity oftentimes other
organizations will think about it from a
scaling perspective right so there will
there may come a time when vertical
scaling of the monolith no longer works
so that's it's no longer enough to scale
to the load that we that we're
experiencing and that parts of the
system might need to scale at different
rates from others this was certainly
something that we experienced at eBay
where pieces lots of different pieces of
the system would scale at wildly
different rates than than other parts
and so well when it was in a monolithic
situation we were kind of constrained
and when we had a architecture where
things were more divided it was a lot
easier to be able to do those to scale
those different parts of the system
independently and then the last reason
to think about rear connecting is is
deployment so parts of the system might
need to be deployed independently of
other of others because maybe they're on
a different life cycle so some parts of
the system tend to evolve really quickly
other parts of the system are more
stable and evolve more slowly and it may
be that the monolithic release cadence
is it's too slow or it's too complicated
or it's too risky so that can be other
other decision criteria that you would
use to think about whether to move from
a more monolithic approach into into
micro services so as an engineer I look
at this and I go well if I'm already
going to be end up in micro services why
don't I just start there right what a
and isn't the fact that I have to re are
Kotak talung the way doesn't that mean
that I didn't do my job I actually like
to think of it a different way where I
like to think of getting to re-architect
a system is more a sign of success than
it is a sign of failure and why do I say
that there are there are lots of system
there are lots of startups in the world
90% of them fail there are lots of
systems in the world
90% of them aren't appropriate for
microservices because they're too small
or they're too simple when we get to the
point that we want to reject a system or
that we feel the need to re architect a
system from an older and older
architecture into a newer architecture
that often that's a sign that the
business model that we're pursuing is
really successful right it means that
we're doing something that people
actually care about and typically we
have the resources in order to apply -
to doing the Rea architecture so this I
you know I can't say often enough to the
startups that I that I that I advise the
this point of really texture is really
as a sign of of a successful trajectory
more than more than a problem and if you
don't believe me again we can think
about the examples that I showed earlier
the eBay's the Amazons the Twitter's of
the world every single one of those you
know well-known applications that we use
all the time has gone through one of
these architectural evolutions and no
system that I can think of any company
I've ever heard of has the same
architecture today as they did when they
started so the other way I like to think
about this is if you don't end up
regretting your early technology
decisions you probably and over
engineered and there may well have been
another Twitter competitor that rather
than doing something really simple with
rails started out building a great
distributed system that was going to
scale them for the next five or ten
years you know there's a reason why
we've never heard of that how to heard
of that company there's a reason why
we've never heard of the eBay competitor
or Amazon competitor that started out
building a distributed system rather
than a monolith it's because the
companies that were successful focused
on meeting the needs of their customers
finding a finding a business model
making sure they had product market fit
and and moving forward in a in a sort of
evolutionary way rather than over
engineering from the beginning so the
last section that I want to talk about
here is ok Randy I do feel like I'm in
the situation where I want to react
attack to micro services so now I want
to offer you some suggestions that of
tactics and strategies that have worked
reasonably well in the past so the one
thing I would absolutely recommend to
start with is do not do it as a
bang and Martin Fowler has a wonderful
quote here which I love which is the
only thing a Big Bang migration
guarantees is a Big Bang so much rather
I much would much more strongly
recommend think thinking about a Ryoka
texture as an incremental step so how
can we keep the current system system
running and at the same time move
incrementally over from from one thing
from an old architecture to a new
architecture and the analogy to
distributed systems is a reactor re
architecture is more a rolling update
than it is a Bluegreen deployment
doesn't make sense what I'm saying okay
great so how would we approach
incremental migration so the step zero
that I often recommend to people that I
work with is do a pilot implementation
first to convince yourself that the new
architecture whether it's micro services
or whatever is going to work for your
for your problem domain and within your
organization and what I recommend is
that we is that you choose an initial
end-to-end vertical experience and
migrate that thing rather than taking an
individual piece to start with the
reason that we want to do this sort of
pilot is we want we want to take the
opportunity to learn and to adjust as we
as we are doing this new architecture we
also want to demonstrate the feasibility
and within our organization and gain the
confidence that we can we can have this
work with our technology team with our
technology stack and with our business
problem we also at the same time we want
to bound our investment and our risk so
we don't want to do a big bang a real
architecture straightaway and at the
same time if we if we choose a real
customer problem we're actually
providing real customer value while
we're doing this we architecture so
that's us that's the step zero and
actually this initial step tends to
often be the hardest because this is the
time when we're actually learning how to
do the things in a new way and we're
actually building out the basic sort of
building blocks the basic capabilities
in order to in order to move to micro
services so once we've done that now we
should take an incremental approach to
migrating the rest of the system and my
strong suggestion is that we actually
think about it from
what's the most important business value
and sort of what's the most important
part of the system and try to do that
first and that seems counterintuitive it
might it seems like maybe that's a maybe
that's a risky approach but this is
actually what this is exactly what we
did at eBay where we sort of looked at
all the pages on the site and reversed
sort of them by contribution to revenue
and we re architected that the highest
revenue-generating pages first and then
went down from there and the the reason
to do this this despite being
counterintuitive is that this allows us
to focus on the areas that typically
have the greatest change so it's the
stuff that we're actually working on
we'd be working on anyway it also
maximizes the near-term benefit and then
sort of the near-term payoff that we get
from the investment in the reaaahhr
texture and it also forces us to
confront and solve a bunch of the hard
problems that we would face earlier on
in the cycle rather than waiting till
the end to face the real difficult
challenges and the other interesting
thing which also came out of the eBay
experience is that it may be that as you
keep going down from sort of highest
business value to lowest business value
you may end up having our monolith that
stays around forever so when I left
eBay eBay had been doing the it's Ryoga
tech chure for six or seven years when I
left in 2011 at that time there were
still pages that were on that previous
version two of the architecture but
those pages were the were the pages that
really nobody cared about they never
changed they weren't getting much
traffic and so we we could we had by
doing this sort of biggest fault solved
the biggest problem first and then leave
the rest later it allowed us to kind of
migrate those those other pages or those
other pieces of the site very
opportunistically
and allow and forced us to think
carefully about where was the most
business value we could get from this
really textured investment rather than
doing the easy stuff first so now a bit
a bit of tactics about carving up the
monolith itself so the first thing I
like to suggest is that we look for or
potentially potentially
factor in order to create a seam within
the monolith so we found this area that
can be sort of separated from the rest
of the monolith and again often there's
a lot of work associated with
refactoring to make this be the case so
then the next thing we want to do is
wall that off behind an interface and
all that all the interactions to that
that component are going are going
through that interface but it's still in
process with the monolith so the next
thing we want to do if we don't already
have strong automated tests around this
area we want to write a bunch of
automated tests around that particular
component and only after that do we want
to we want to move the implementation of
that component out into its own remote
service and and replace it with with a
sort of micro service and then we want
to rinse and repeat
every time I give this talk this seemed
i-i've had the feeling that this seems
too overly simplistic but every other
architect every other we architecture
approach that's sort of more complicated
or as more steps than this I found not
not to work as well as this approach
it's it's very simple but it's very
step-by-step and it's very sort of
procedural and allows us to make make
lots of forward progress so the final
thing that I want to mention here are
some Annie patterns that as we're moving
to services that we might that we might
run into and so the first one I want to
talk about is by contrast to the micro
service that the auntie pattern here is
I like to call the mega service and this
is a service where it has a really over
a broad area of responsibility so it's
not single purpose it's not it's not a
well-defined small interface with a with
a small surface area and those those
types of mega services tend to be really
difficult to change really difficult to
evolve and it also makes it leads to
very unsustainable amounts of dependency
so you know that service that does quite
a lot is has lots of upstream
dependencies on other services or
applications and lots of downstream
dependencies as well so don't do that
and by the way as a side as a side note
I think lots of the failures that our
industry had in front first trying to
move to a service-oriented architecture
came because we built services that were
too over-broad right that was that
certainly was my experience and so one
of the reasons why I think the the
industry has correctly shifted toward
thinking about services as micro
services is is trying trying to avoid
that problem trying not to build
services that have over broad areas of
responsibility that are essentially
other a little mini mini monoliths in
our system so the next any pattern that
I that I want to talk about is something
that I call the leaky abstraction
service so the idea here is that when
when producing the interface the service
provider didn't think about it from the
perspective of the customer but only
thought about it from the perspective of
what was it going to take the provider
to produce like essentially it is
essentially leaking implementation
details of the service into the
interface and there are lots of reasons
not to do this
most most powerfully it's because this
consumers model of the service often
tends to be a lot simpler so that
consumers the consumers approach tends
to be more abstract and tends to be a
lot simpler than the implementation and
also as a service provider if we leak
our implementation model into the
interface that makes it really difficult
for us to change it
which constrains the ability our ability
to evolve that service over time so the
last thing I want to talk about a last
anti-pattern that I want to talk about
here is shared persistence so when we
have a situation where we have a nice
interface at the micro service level but
we share a database or some other
persistence mechanism with other
services or other applications that
actually breaks completely breaks the
encapsulation of the interface that we
exposed to our clients and it actually
encourages or at least allows other
parts of the system to kind of make
backdoor violations of the interface
behind our back sort of directly in the
database or directly in the persistent
store and what that ends up leading to
is is of is a very unhealthy coupling
but that you that's near invisible very
unhealthy coupling between those two
services that are kind of also that are
sharing that same back-end and this was
it this was one of the main reasons why
a base for a into service-oriented
architecture around 2008 was a was a big
failure in the end it has worked out
fine because they've approached it in a
different way but in but in 2008 the EBA
the approach at eBay was to partition
the application tier so there were lots
of applications that were you know
here's your selling and here's buying
and here's search and oh nice nice
partitioning of of the application tier
and they did a decent job also of
partitioning the service tier so here
were services around authentication here
were services around check out or
billing but the underlying databases
underneath those services were still
shared so what happened was in practice
nobody used the services or the service
interfaces they just continued to go
directly to the databases where they
always had been and the services attend
all the effort that we put into building
really nice clean services ended up
being being wasted effort okay so in
conclusion I think it's I think it's
fair to say as wonderful as micro
services are particularly at large scale
I want to leave you with the idea that
micro services may not be for you if you
have a simple system right if you have a
small team of developers if you're not
able to invest in a bunch of those
prerequisites that I mentioned before in
can't invest in continuous delivery
can't invest in monitoring are unable to
change the organization around small
service teams and most importantly micro
services aren't for you if they don't
solve the problems that you actually
have so thank you very much
so I think we have a few prop you well
yeah we actually had a lot of questions
right all right far away and I'll be
here the rest of the conference - so
yeah so yeah go up and talk to him
afterwards if you don't get your
question in here so there seems to be
some confusion about why you would say
don't do micro services from the get-go
because why would you suggest that you
should make a monolith from the start
and let me just deter Prasanna list here
because that indicates something large
and usually applications are not from
the start right yeah right now that's an
that's an excellent point
yeah the why would I not just move to
micro-services because when you have 10
users or 100 users or a thousand users
you shouldn't be spending your time
building a distributed system you should
be spending time building the
application that your that your users
actually need to use so it's a matter of
opportunity cost it's a matter of what
should what's the most important thing I
can spend my development resources and
my machine resources on right now and in
the early stages of a company or an
application it's right it's completely
wrong to think about building something
that's going to be five years down the
road or 10 years down the road though if
you know startups that work that way
don't tend to don't tend to work out
another question is so you just
mentioned that you shouldn't do
integration through the database right
but in the beginning of your talk you
said that you guys had that problem
right now oh yeah so once you're in that
so one of the one of the challenges of
moving from the monolithic approach into
micro services is that you have to start
to sever those integration points within
the database again the the idea in the
early when you think about it as
different life cycles different life
cycles have a person or different life
cycles of a company in the early stages
you don't you shouldn't try to solve the
problems that are only going to come
later on so in the early stage when
again you're trying to figure out
whether you have a business model
whether you have prod
market fit or whether your application
is actually going to be used by by your
users you should focus on you should
make it as easy as possible to move
forward and often with small at small
scale that's a monolithic application
with monolithic databases and then if
you should be so lucky as to have to end
up having a much larger scale situation
that's the appropriate time to invest in
in that longer term approach and the
investment that you would make earlier
on in my personal opinion is is is not
the best use of your time and resources
okay we also had quite a lot of
questions about testing and how to
actually do it in practice because you
mentioned that you should build a test
harness around a component in your
application that you would rip out and
make into a micro service but at that
point the tests that you do could be
unit tests and all of a sudden they
might be interface tests instead right I
think I see what you're asking so I mean
you're asking generally about testing
and so as we as we put that as we
introduce that interface around the
component that we're about to pull out
what we wanted what we're trying to
achieve with testing here is to make
sure that in pulling it out we haven't
broken anything right and the best way
to do that honestly the only way to do
that is to write tests that exercise
that component upfront ahead of time
before moving it if we wait till move if
we make wait to write tests but after
we've already sort of extracted it
that's too late because we don't know we
we can't know whether we've changed
behavior or not so you have to you have
to do that earlier on so while we're on
the topic of changing behavior so say
that you have a couple of Micra services
how do you test that if you change one
of them that they are still compatible
how do you how do you test several micro
services at the time yeah right it's
like Adrian was saying a moment ago it's
sort of defense-in-depth but testing in
depth so the first thing that we can do
to test a micro service is to test to
test that component in isolation right
so to write write tests against the
interface
correctly and to the extent that we have
other services that that micro service
interacts with we should mock them out
and this is something that we did super
heavily at Google where we every time we
would build a service we would spend
most of our effort our testing effort
around testing that service and
isolation and then mocking out the
interactions that that that that system
had with that that service had with
other parts of the system and that and
that has that all that's is easy because
you're doing it in isolation but it also
allows you to simulate lots of failure
modes that would never occur or would
only rarely occur in real life right
something that happens you know I'm one
in a million or one in a billion times
in production that's really hard to
simulate by running it a billion times
but it's super easy to simulate it with
by mocking out that that interacting
service there so then the next so that's
at the at the service level then the
next the next level up is sort of an
integration test where we could test the
test the system test a running system
all together and that allows you to do
more and end-to-end related stuff one
more thing I'll say about here you
didn't it's not really about testing but
the the critical discipline that you
need to have in terms of making sure
service interactions continue to work is
backward compatibility and forward
compatibility of the interfaces right so
the critical discipline is that if my
service a is talking to service B
service B should be able to work to be
able to modify itself and deploy
independently but that only works if the
sir if the deployments that service B
does don't break the interface that I'm
expecting so that's all you know that's
that's almost the step zero that's
before testing does it make sense what
I'm talking about
okay there's been a lot of talk about
domain driven design in relation with
micro services is that something you've
used yourself or is that something you
consider when you design micro services
yeah I think domain driven design is
super powerful in micro services I don't
think you I don't think it's a
requirement but but Eric Evans approach
particularly to bounded context is a
really wonderful way of thinking about
it's a wonderful kind of architectural
discipline and architectural philosophy
to to apply to services so I think
domain driven design works very well
with micro services is it
a requirement I don't think so but it's
super powerful and if you're already a
fan of it you should microservices will
be a lot easier for it so final question
it's in relation to distributed
transactions so you rip out a couple of
components from your application and
then you realize oh we actually need a
transaction across this is that already
too late or can you use something like
distributed transactions and are there
any good tools for that
yeah sure this is a this is a talk in
itself well obviously if you've ripped
something out and then decide you to
transaction well that is too late but
but you're thinking about it
whoever's a questioner like you're
thinking about it ahead of time so I'm
sure you won't wait till that time to
figure it out yeah that's that that's a
challenge because as soon as as soon as
you have as soon as you have split the
persistence of a thing between two two
databases for example the transactions
become challenge a challenge distributed
transactions I really I really don't
like for reasons I'm happy to talk about
offline there are serious availability
and scalability bottleneck but but you
can do techniques around reconciliation
of changes that happen
you basically have to asynchronously
introduce the consistency sort of after
the fact and I'm happy to talk with
people afterward because there's sort of
a lot more complexity than I'm able to
do in one sentence but I'll give the
quick example of when when banks are
doing transactions between banks like
they don't do distributed transactions
right when Deutsche Bank and Bank of
America are doing a currency trade
that's not a distributed transaction
that's something where they they do the
transactions during the trading day and
then they reconcile at night does it
make sense they sort they they send each
other files I saw these 999,999
transactions oh I see I saw these 100
million transactions and they and they
reconcile so that's one of many
approaches that one can take to getting
the getting the same consistency effects
of transactions while at the same time
having two independent components that
that aren't transactionally bound it oh
dude that was helpful
Thank You Randy thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>