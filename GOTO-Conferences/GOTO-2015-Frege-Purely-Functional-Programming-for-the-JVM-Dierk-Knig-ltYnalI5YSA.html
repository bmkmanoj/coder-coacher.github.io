<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Frege: Purely Functional Programming for the JVM • Dierk König | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Frege: Purely Functional Programming for the JVM • Dierk König - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Frege: Purely Functional Programming for the JVM • Dierk König</b></h2><h5 class="post__date">2016-07-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ltYnalI5YSA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so who in the room is a Java developer
okay this is one hundred percent in this
group okay it's calibrating myself so
who that was not everybody else
interesting so um who has ever done any
kind of haskell me Rhonda o camel mlss
00 pail something so this like okay half
of the audience which is interesting
because I assume if you dislike this
kind of language language with the
passion you would not be here so I
assume that you like it which is good
and you I assume you want to see output
work on the JVM it can possibly work on
the JVM maybe and when i started my
endeavor when I when I looked into
Haskell my impression was that I'm the
only one of the plant on the planet that
does java and Haskell at the same time
and I'm really can i'm surprised and I'm
pleasantly surprised to see that there's
an overlap that of course we are
addressing with Vega we are but also be
addressing the second group so people
that have not yet seen these languages
and we'll tak have curious on what is
different we will focus also on the
first half of the talk on what is
different that's meter chronic I've
worked for canoe in Basel Switzerland to
begin with and particularly for the
second group that has mainly done
imperative programming in the past i'd
like to read you a program and i'll ask
you what that program does okay let's
kind of a challenge in the afternoon a
little bit five lines of code contains
three variables a B and C
and when I say a equals one that has
value semantics meaning that the value
one gets assigned to the variable ay ay
equals one like like written you know
okay is that okay for everybody so
here's a challenge five lines of code a
equals 1 got it B equals to C equals b b
equals a a equals see what is that code
doing some how some adjustment my way
it's getting worse you know when you try
to optimize guess what gets worse does
anybody have a shaver with them so
anyway so ideas what what the program
was doing flipping two values very good
there was somebody in the audience so I
now give you a mind read of what your
mind was doing when trying to follow
this program so now comes the
engineering part I going to need this
for the left coding anyway so you have
to cope with it I fear good so a equals
1 so there's memory location for the
variable a which now contains 1 B equals
2 here you go
c equals B okay a and B stay the same
but then the value from B gets copied
over to the location C mm-hmm p equals a
so a and C stay the same but then the
value in the location of a gets copied
over hmm i equals C so B and Steve sale
stayed the same but what was once copied
over which boss additionally the value
of B now gets copied over to a so this
is the steps that we have to follow the
we follow in our head we follow these
operations and as engineers on the Java
platform mainly using imperative code
this is the kind of reasoning that we
apply every day we are also a
self-selected group you know people that
have immense difficulties doing this
kind of mental juggling they don't stay
in programming very long it's too
frustrating for them but I guess you
also agree that for this rather
primitive operation of flipping or
swapping two values the the number of
steps and the amount of considerations
that we have to do is rather high the
price is rather high for a little out
cap and this is because not only do we
have to care about three different
places that our brain is rather good and
caring about places but the brain is not
very good in caring about these places
at various points in time and why do we
have time at all in this thing this is
because of assignments assignments
introduce the notion of time in code
everything that happened before the
assignment and everything that happened
behind after the assignment this is
where you get the time into the equation
here and that means that even for this
primitive operation
we have to care about nine different
states as you see here the initial ones
over here is just the definition but
then we have nine different states the
short-term memory of the average human
and I'm pretty sure you're above that
number is nine you can manage nine
places the average is 7 plus minus 2
minus 5 and if you try to remember what
happened to you when following my lines
of code I assume that some somewhere
here or here your mind gave up now this
is how you can judge you you can
estimate how big your there's a lot of
memory is because it's rather difficult
for the brain and only a few brave ones
have followed through so stumped up to
you you Jesus guess there's also fine
good guess so this is and because we
have to follow these operations to
reason about the code this is called
operational reasoning hmm now if this
small thing is already rather difficult
so difficult that most of us cannot do
it in the head we need some tooling
support for this you know we need
tooling support that gives us
information at what point in time our
memory locations had what value and this
is called the debugger the main reason
by far margin the most important reason
for a debugger is this the notion of
time location based programming and the
notion of time combined if you don't
have that there's dramatically less to
do for a debugger and I guess you
already been there so you you make a
watch variable on one of those and then
you single step through it to see what
unfolds in the operation good I have
recently explained this to my parents
my mum is 75 years old my father's 80
years old and they have no technical
training whatsoever and they ask me boy
what are you doing and I said well you
know what this coffee cup over here is
an a and this glass of water is a B and
then we want to swap that over the I
cannot just put that in that know that
also doesn't work so my father you have
to have temporary storage over the acid
like a programmer yeah and move that
over and this over here and then check
out that around and and we do this in
our head I said and my parents have this
phase of poor poor boy this explains
something and but we figured something
out I am currently with this new thing
we have a new idea we call it functions
and it works like so we put this
Catholic up over here and we have this
glass of water over here and then we
leave it like so and never change it
again and whoever looks at this thing
always sees a consistent state done case
closed you know by definition and then
my father said yeah big boy you said you
wanted to see it swapped over right so
said yes seeing it swapped over is easy
it took its classes and said just
imagine you these have these present
classes where I and every see the left
to the right and so right there are
those classes on the internet if you
want you and then you see it like so but
this interferes with nobody you can have
thousand people looking at this
information and everybody has different
glasses one is only looking at the first
versions and was a second value and what
has only plus one filter on and nobody
interferes with anything else with
anybody else and there's always a
consistent state that's much easier if I
would have told you in the beginning a
comma P equals B comma a you would have
guessed quicker what the guy is doing
pretty sure about that
so we have a new idea the new idea is we
just get rid of these assignments they
seem to be dangerous and assignments are
just a special incarnation of statements
so we just in one goal statement also
ruled out now if you don't have
statements in programming language you
also don't need control structures
anymore because control structure
control the flow of operations and you
don't have operations anymore no
statements so you don't need control
structures so from tomorrow morning on
we do programming differently no
assignments no statements no control
structures how would that be this would
kind of it would be different you know
question is is that practical can we
really do it and there's actually two
ways of doing it the blue pill and the
ram pill the blue pill is everything
that I like this check very much in the
conference was a very good track
interesting content lots of insight
about programming most of it functional
programming these days but the blue pill
it was the blue pill that we have seen
so far imposing develop a discipline
we've been in the first talked this
morning in in distract some yeah okay
challenge I'll the the ongoing the
repeating statement was and then we
settled on a convention of only doing
this you know and then we settled on the
convention of never doing that so and
this kept us on track for functional
programming you know you have to impose
discipline one way or the other maybes
tool support it or to some extent
language supported in other languages
but the only language that gives you the
red pill where you get rid of the old
metrics thing and you enter the new word
of reality is using a purely functional
language that doesn't even have a
notation for a sign
there is nothing there is no syntax for
assignment you cannot do assignment
because there is no syntax for it there
is no syntax for statements there are no
control structures in the language so
this kind of forces you into a new way
of thinking and using a new programming
language on the alternative programming
language only makes sense if it forces
you to think differently about your
solutions it's not about superficial
syntactical differences the superficial
syntactical differences that we will see
today are only there to remind you of
the fundamental underlying differences
and here is the our idea for purely
functional language I'm going to show
you some code if you want you can follow
the code samples in online there's an
online ripple read eval print loop where
you can try that code I'll show a little
bit of code here not late i'll just live
with live coding to give you the joy of
seeing me failing it so um and by the
way for the non german native speakers
the word fig is a bit different
difficult to pronounce so you're
entitled to call that freaky if you want
you so here comes um we are working with
functions all our code is built from
Frank shins the whole language is built
from functions no surprise there's lots
of language support for functions
because it's all it does and here's how
you define one so and will in the Revel
let's say we define a function called
times it takes two parameters a and B
and returns a times B this is how we
define a function it looks somewhat
unfamiliar first from from Java
perspective first we don't see any types
it's kind of untyped or dynamically
typed what is it kind of just JavaScript
II thing no as we will see how do we
apply a function well we can just give
the parameters like so in the most
silent fashion that you can think of the
operator for function application is
space and this is actually the theme of
this conference is going to new spaces
or something okay so that is we are
using space here go go into space I like
the keynote so much the best ki know
that I've ever seen so we are using
space here so this space over here is
actually an operator that takes this
function and applies it to this argument
and then to the next argument we'll see
how that looks like in the same so I no
surprise it returns 6m and we can ask
the rebel for the type of times as I
said there is some type it's not untimed
and the type looks somewhat crazy we'll
see what that means in a second let's
get some help so we had no times
declared the times the types are in
third we did not even declare the types
of the parameters Vega and he'll still
have global type inference meaning if
you don't want to you almost never have
to write any type and it but no matter
how small or big the expression your
language is it will always be fully
typing for it so I said that this space
over here of a blank character is
denoting the function application
operator well it would be a little bit
more correct saying that it is the
juxtaposition of these two you put them
beside each on each other then would
more correct to say so but you can also
you can already infer everything else
that I'm going to tell them tell in the
next five minutes from that information
and that means if that is true this
means that this expression here and by
the way the function application is left
associative as an operator so there is
implicitly like parentheses here so that
means that x is a function it is which
is applied to the number two what is
this expression evaluating too well
since it is juxtaposed to the three it
must evaluate to a function okay so this
must be a function that we later apply
to three hey your high schoolers all
cool fricassee so if we ask the times it
actually tells us this it says these
arrow means we have a function from here
to here and functions always have only
one argument and exactly one argument it
says well x two x sorry x here is a
function that takes an argument this one
and returns as we have seen it returns a
function which takes in another a which
is number three and returns six so this
is how you read it and on the left hand
side this is called a constraint you can
read this as a Java interface then since
we use x over here that only works for
numerical values so called type class
over here but it skip a little bit over
that one so if we look into these times
2 since we already know that this
expression denotes a function thank you
we can reference it we can use x 2 and
give it a name now what can I do with
that name well we can apply it to some
number giving us 6 hmm if we ask for the
type of two times what will that be
mm-hmm there's a number of options what
could happen it takes into int it's a
function from integer to integer why why
not numb to numb or something because we
have already specialized it to an
integer right no longer can three be a
double or a float or anything because we
have already specialized it and these
types must be the exact same types they
were bought both of type alpha right
there for now you may notice this space
over here in this space is there for a
reason if you think in java terms from
Java perspective if when you compare
this to a way that you do methods in
Java you would expect there to be a
formal parameter that you call right for
this argument you would like to see a
formal parameter in the in your arm in
your type right hmm you can actually
think of such a parameter you can
imagine such a parameter if you want you
let's say there would be an X then for
calling x 2 we would also need to supply
the X right is that okay this is
actually like in mathematics you can
this is like an equation in mathematics
you can extend an equation but your
autumn can cancel out terms of an
equation so if you're like in Germany
you say curtain right you can cancel out
the X of you this is valid hesco
including the gray ones but you can
cancel out the X you can divide through
X if you that that is the analogy by
actually multiplication is applying a
linear function in mathematics so that's
that is the analogy where that comes
from you can cancel out the X that's the
kind of operations that you can do on
equations in all your historical Joe
Haskell current becomes hasta la Vega
code becomes a series of equations that
you solve and you can work with it like
an algebra which is of course not
possible in any language that has
statements or assignments all time so
these these canceling out of these terms
I'd say is sometimes called currying for
good reasons sometimes soon wrinkling
from Moses to and wrinkle who did the
theoretical work on this but actually
this kind of concept of having functions
that are used as arguments to other
functions or being functions that are
returned from functions is first
described by God la Vega afternoon that
1891 in what was that on on he did so
many publications can outside the bread
pan correctly on on concept of numbers
or something m was not on the concept
notation I have to look that up I forgot
that anyway maybe not simple so in four
times the more specific and then we can
also do function composition so we have
defining a function using a function
applying a function using parts of a
function and now combining functions so
let's say we do something like two times
of three times two well as a Java
programmer I would assume that this now
does the following it would apply three
would evaluate three times to giving six
and then applying to x 26 let's like the
Java way of doing things that is called
strict evaluation you always first
evaluate your parameters in a certain
order mostly left to right in most
languages
and then you apply it this is not the
case in flag and Haskell because at
reagan high school they were too lazy
lee they only evaluate this if needed
and there's a good reason for that as
well so that anyway this region's 12 as
we expect but we can write this in a
different way as well so the two times
and three times our functions and we can
compose these functions into it six
times hmm with these dot in the middle
and this dot is let's get let's get some
help for this and six times to we can
apply this and get the type of six times
which is in to end of course let's get
some hard for this now this over here is
like a function f applied to the result
of a function G applied to some X right
the mathematical location you may
remember this from high school and your
high school teacher may have mentioned
that you can write this as the F
composed G is that correct yes correct
and apply to X so this is this term here
is a new functional this is our six
times right you can actually do the same
trick that we did before you can put the
eggs in again you can put the eggs over
here six times x two x + 3 x put in
parenthesis in the six over here still
the same code would still work but we
already canceled it out so you can
compose functions because the first
class citizens in your language clear so
far questions so far good so
all this works only because we have pure
functions and since we have a lot of
high schoolers in the room you know we
like two months ago we had the flag day
at canoe in Basel and we did a lot of
interviews in every interview at some
point expect me to ask why are you here
what is special and they said at some
points I said you know what it's it's
pure and you could feel the shot of
endorphin going through the body when
they say pure and as a high schooler I
would say it's not endorphins it's have
a shot of endomorphisms so good so the
why do we care about purity well if we
have a java method under any name and we
see the type signature in no
implementation and we don't trust the
comments what could we tell about any
method from its type signature well
let's say technical just says I take a
pair of tea and you when I return
something of type T what is they're
doing well most likely it returns the
first element of the pair put a return
null yes of course could it thrown upon
the exception yes of course coded print
to standard out yes of course put a lock
yes of course got it go to the database
yes of course go to read from the
database yes maybe couldn't stop the
missiles and stop third world war of
course right who cares hmm inflating one
high school if you have this kind of
type signature saying I take a pair of
alpha beta I return alpha for every
computation that finally holds that
final returns the only possible
implementation of that is returning the
Alpha nothing else can possibly happen
first there is no null which means
there's also no night when the
exceptions
if there would be any kind of side
effect like reading writing stuff and so
it would be visible in the time so long
story short everything can happen here
you know exactly what happens here this
is a kind of type signature where
actually the tool can infer the one
possible implementation of the method
there's actually tools that do it if you
want you it doesn't it's not possible
for every function to do that okay with
a pure function once once we have
convinced ourselves that we have a pure
shop function and it is of course
possible to write pure functions in
every language you can do it in
assembler if you want right it's your
developer discipline of doing it in play
go I Haskell we have the type system of
telling us whether it's pure or not and
because the type system reveals that
information any tool especially the
compiler can use that information if we
call the cosine function with one dot o
it returns a zero I don't know something
okay if we call it again with the same
value it will return the same value you
know you can memorize this you can cash
it you can since there is no notion of
time anyway in a pure function you can
evaluate that at any time before it's
used you can do it lazily you can do it
in advance speculatively when the
computers idle anyway well let let's
evaluate some expressions you can do it
concurrently which is the big thing
about concurrent programming and
parallel programming without any fear of
dead logs and race conditions and
whatever if you have code like x 2 3
times 2 3 times 2 3 times 2 3 the
compiler or maybe your ID can say well
let's let remove it and refactor it in
one term that we have in the beginning
this is what you can only do with pure
functions if you had an impure function
with a side-effect let's say
system.currenttimemillis here here here
here here you wouldn't want to refactor
that out right certainly for a reason
that you get the time it's at a certain
evaluation point so you can eliminate
common sub-expressions and all this is
an optimization issue hmm and actually
this opens in a huge range of possible
refactorings that the ides could now
apply safely most refactorings from the
idea is that you get from your IDE at
the moment as a developer are not really
safe that's more like proposal is if
we'd suggest you could refactor this out
into an extract method or something you
know it's not really safe as long as you
cannot ensure purity but now it could be
safe it could be marked as human here's
a safe one for you please ask your IDE
vendor for supporting this this is
optimization that the the tools can do
but also that the developer can do now
you may have found yourself in this
position where you were you have some
method it may contain a back in UNIX
read sure where the back comes from from
some state change that shouldn't be
there or you consider where's that stage
actually changed or it can I refactor it
or can I call it this is the thread safe
can i call it in kerala and you don't
you just don't know so what do you do
you look into the implementation and the
implementation says well involve a and B
and C and then you go into the
implementation of a and then inspect
this and then into B &amp;amp; B calls ABC BD
diesel and finally you end up like so
this is from an actual project so you
have to inspect a route and this is only
one branch of the tree it's actually
waste in reality so and after a week of
inspecting the code you have convinced
yourself you know that's safe I can call
it
and you do it and then the next day some
program of your team comes and changes
let's say here and the system out print
line because it needs it which by the
way totally undermines all your parallel
ISM because that synchronizes on the
other extreme and so on right so
whatever the effect of that maybe maybe
only performance drop or whatever he has
no chance of knowing that you made this
silent assumption you have no chance of
knowing that he has broken your silent
assumption its all full of silent
assumptions and this is the cause of
bags how do you get around this manual
inspection doesn't work so the only
thing is we can ask the type system if
the type system tells us and keeps it in
place that all this is pure then we
don't have to inspect it anymore we can
ask the type system well I have to go
one back into existing now pretty much
every language on the jet here comes now
in the next five minutes comes the big
difference of Vega between all other jvn
languages and unique point of Vega that
I've not seen in any other language so
far and it comes from this point here
let's say I have a super duper language
it ensures purity through the type
system here in this in this code well
with the type system but down here or
some way I mean some more up the the
coil chain is a call into Java I call
into Java Oh system.out.println current
I'm Millie's whatever some java method
pretty much every JVM language goes to
the root of saying well as soon as you
call into Java all bets are off right
your fault it doesn't have so much right
click it goes a different route Vega
says well
we do not combine on that level we make
a very clear distinction between our
purely functional world and the object
oriented well is tablished imperative
java volt we make an extremely clear
distinction we can call both ways that
we do not mix we do not mix the two
paradigms we keep our side clean if you
want to call from figure into a sorry
from Java into Frager that's the easy
part because Vega compiles to java
source code it generates java source
code and then uses Java Sea to compile
it to bytecode so you have java source
code laying around well this you can
call from any java module anyway so it's
java to java actually fine if you want
to see what kind of java code generates
you can even ask the repple forgive me
the java version of this figure code
from Vega to java is the interesting
part well now we have to distinguish we
have to declare and we have to it's not
optional we have to declare our silent
assumptions about what the java code is
doing that may be hidden in the
implementation or maybe in the API drug
or whatever our assumptions become
explicit we have to declare explicitly
what we think the type of the java
method would be in three terms so for
example Java net your L encoder encode
is a static function you might know that
and it is string to string you give it a
string and returns the string string is
immutable it does no side effects only
works on the parameters it is pure I can
call it now from Vega as encode this is
the method that I assign to it say dear
chronic and then it replaces blank with
I don't know to send 20 or something
fine all nice and tidy right everything
is still pure
when I use this method when I use this
function my code is still pure we have
other methods and actually most methods
are impure let's say poster child is
current time Millie's it takes just like
a damn a parameter if you want and
returns well this is a long in Java but
we say well it's not only a lot it's an
i/o long and this because now the the
long is somehow tainted you know it's
dirty you know if you the type system
now knows that this is dirty one and I
along is actually more like in inaction
it's not the long itself it's the action
that you would give you the long and I
can call the Middle East but just giving
it the unit but if I would like to if I
want to call it I must be it makes
myself dirty but especially if I want to
kind of do arithmetic with it this does
not compile it says when my lease is not
a long you cannot calculate with an IO
long first you yourself have to become
dirty you have to change yourself with
IO and then I would give you the long
and then it can do whatever you want to
do but it will make you dirty so the
caller gets dirty and everybody who
calls me but also get dirty and him and
him and him until main main is of course
dirty it does something no not heating
up the CPU it's it's doing something so
that is the key distinction between fall
through to all other languages on the
JVM actually the that was the point that
sold me on the project when I saw this I
felt like you know there's somebody who
knows what he's doing so long story
short you can pump faked a call into
Java bid it's kind of an intimate thing
don't do it unprotected so a second
second thing that you now guess is that
you have a global type inference since
you have no statements in know
silence ain't no control structures from
this and this is difficult to reveal in
these 50 minutes from this you get an
amount of structural safety about your
code the code is actually like it was
knowing what you're doing in don't let
you break out and reuse things in
uncertain context and so on so it knows
structurally very well what you're doing
and guides you to a correct solutions so
if much more safety and for very little
try for very small price so if you don't
want to pay any price at all you just
don't do anything in the type system
right you still get the type safety and
here is how are you going to use it it
is all your pure computations are like
islands in a sea of imperative code in
the sea of dirty code you have things
that are mutable in your maybe job even
java based application and that does I
oh and mutable I oh and databases and
whatnot but inside you have islands of
pure computations that way can reason
about equation alee that's the idea and
the type system ensures that once that
somebody is dirty he cannot escape
anymore it is like a context that you
cannot escape and in the first part
those are thread safe by construction
and if you have any error in your in
your multi threading on parallel
whatever solution you can exclude a huge
number of possible errors you don't have
to look inside those because they cannot
fail and then like technically these
things over here are called monads
however get over it's just a name and
I'm going to show you some live coding I
guess we will maybe do a little bit I
may need a few minutes more than
50 and this is the fizzbuzz problem who
has ever heard about fizzbuzz almost
everybody so you can't numbers in for
every third number you say fees and for
every fifth number you say it buzz and
then you counting from one to 100 like
this it's a it's very often an interview
question and job interviews some people
say it's children's games some people
use it as a drinking game anyway anyway
if you ask on the on the internet for
possible implementations of that here is
hit number one this happens to be an
imperative code and it's actually it's
Java but it's the point is not that this
is Java there's much better solutions in
Java as well but this is kind of the
conventional way of writing it in Java
and the point is that this is typical
imperative you can write this in C is
healed solution would also be like so
you have a for loop and lots of changing
state and then you have to think about
you know the point where three and five
comes together this is s at 15 and we
have to cover this case first and then
comes the other two other cases special
cases and then comes with general Kaiser
yeah okay let's kind of typical code who
would have written this kind of code to
solve the problem Oh at least two or
three very good last time I asked that
their folks nobody was and that was a
lie of course okay so that is kind of
the conventional way and as a thought
the idea about a new language is it
should make you think differently about
the problem in a possible solution so
let's say if we call the frigate Apple
that's this is javafx oh my Chris little
bit bigger command P this is written in
figure it is using javafx three
components anyway so the first thing is
we have no for loop yeah
okay we cannot do this go home okay we
can what we can do is we can use leg leg
of an extreme an infinite sequence of
numbers this is something that we have
available and it is denoted likes so one
dot and if we evaluate this it gives us
all natural numbers whereas the rattle
is intelligent enough of not giving us
all natural numbers but because of lazy
evaluation we can actually limit this
okay anyway this automatic while we need
those since we want to print it not as
the number but as the string so we are
in taking this and we are mapping every
single element in its to string
representation you're mapping this and
then on Vega and haskell it's called
show instead of two string and we're
taking this one dip dip we see this air
strings so visible from the back set
yeah okay so and we give it a name this
is the numbers okay let's let's again
check numbers is a list of strings good
numbers is this now we need some kind of
notion where we say every third is a
fizz okay how can we do this well we
have a list it is an empty string in an
empty string interferes okay and then if
we want to have an endless repetition in
infinite repetition of that we can say
well please cycle over it gives us the
definitive history visited endless
rhythm cool let's give it a name the
fizzes
there hmm how about buzzes well you
already know the trick make the same for
buzzes this ism I could use a repeat
here but anyway make this very easier
buzzes so what are the buzzes
deliverables better the best belittle
best bill and buzzing well but the
requirements say we have to kind of
combine fizzes and puzzles it's this is
business rules right and if they come
together the fizzes must come first and
then buzzes like if there's some kind of
overlap so we make ourselves a pattern
from this from we have to infinite
productions of strings and we combine
them element vice the pops up in squad
zip like a zipper on your pants right so
this is our theta equals it's called zip
and we are dipping it with a function
their fault slip with and the function
that we use is string concatenation
which looks like which is denoted by
plus plus and we're using the phases and
the buzzes to do that so what is the
pattern there fizzes buzz visible buzz
and number 50 15 is fizzbuzz so far so
good but not now about the numbers we
have to bring the numbers in and okay we
can also zip the numbers but what is the
function that we can zip the numbers
with well here comes a little trick that
I did not do in the initial version of
this but which was contributed by Kevlin
hen a and it has a nice observation and
it is strings have an ordering and the
empty string is always considered the
smallest and then come strings that only
are composed of digits and if you have
any
thing that starts with a non digit
alphanumeric character this is
considered higher than those right so
you can use the maximum functions it's
kind of interesting so the actual fizz
buzz is the zip with the maximum
function of the numbers and the pattern
got it that looks like you know business
process something this is processed
modeling or so okay so what is fizzbuzz
here we have the first so many right but
since the the original statement was we
have to print the numbers so but what we
have here it looks like an infinite list
but of course there is no infinite list
there's nothing that occupies all or a
memory or so that's not the case it is
actually more like an iterator like a
lazy sequence like a stream all those
things are the same in lazy languages so
what we can do we can actually iterate
over that long stream and now what is
the function name that takes an infinite
production of things in iteration over
things and apply some logic to it how's
that function name map would apply each
element wise and I want to produce an
effect right out print line I want I
want to print something out the ply
could be 14 because it's actually the
same thing as a for loop for fizzbuzz
print line
okay you see ya I get goose bumps when i
write this how nice is that so actually
so fizzbuzz would be nice but this would
be an endless production of print Lance
we have to limit this right so we have
to limit it with say we only take the
first story take 100 of those fizzbuzz
and entries keep calm Keep Calm we
actually be running out of time so I'm I
take some Liberty and since the
organizer granted me in additional 10
minutes I'll do that okay as long as
nobody's leaving early so I'll I'd like
to interpret this result a little so if
you'll find that in the in the download
as well it's in this light day so but if
we look into this yeah two operations
you will see that the imperative
solutions has four conditionals dddddd
for conditionals that we have to think
through whereas the logical one has 0
conditionals we had two packs creep in
in conditionals particularly in nested
conditionals and the nesting level is
due to the if-else and four in the
cyclomatic complexity is three and here
it is zero the number of apparatus is
seven and most implementations actually
have a little bit more because they do
Anna deuce the 15 but they do 3 and 5
and so on so it's actually more and here
we have the plus + on strings which we
actually use as a function and not as an
operator but I give you that one okay as
in 11 to argue over there this the
sequencing here it is extremely
sensitive to reordering
almost any reordering of these lines
will make a wrong solution right you can
change the three for the five over here
but this is the only change that you can
do every other reordering is wrong here
you can every permutation of these lines
is correct and by the way have you seen
the following and when we when we worked
in the repple at no point in time did I
go back and change anything that I had
written before at no point in time do I
even have to recompile what i have
written before that is incremental
programming right if you're not changing
what you have written before and you
don't even recompile what you have
written before what can't you break in
the old code nothing that is big how do
we write code one line at a time
incrementally and we only have to check
that this line is correct how cool is
that in the other case every single
change every single increment that we
want to do we cannot do this non
intrusively we have to do it intrusively
we have to change the old code we may
possibly break something and this is not
a thing that I kind of made up because I
can choose exactly this example it was
like it came by total accident but what
I've shown you interactively was exactly
the steps that I went through when I did
it the first time it's just the natural
thing to do and it turns out to be have
all these nice characteristics and now
comes maintainability so customer comes
as she Stefan walk over there so he is
the expert on that one so customer comes
and says well you know what every
seventh number should be go to
conference oh god
now I have to care for the multiples of
three and multiples of five and the
multiples of 7 and the multiples of
three and five and seven and the
multiples of three and five in the
correct order oh no i forgot the
multiples of five and seven because it
was too complicated try to get this
right and it's extremely difficult and
you have to touch everything that you
did before what do I do here there is go
to conference business rule that are
also zip-in done right that's it so
maintainability is really bad in the
imperative code and gets natural easy in
the logical country so the campus to
something to sum up the long talk what
we get when we don't have assignments no
statements no control structures only
expressions we get and this is only
possible in purely functional language
or what makes a purely functional
language then we get global type
inference we can detect purity and use
it to our advantage we can use laziness
which is not possibly before and all the
kind of separation of generating the
inference stream and using the internet
stream is only possible because of
laziness otherwise this kind of solution
approach wouldn't work and we are the
guarantees that we have even extend into
java course right we are not giving up
our language guarantees that makes us
robust and the parallel execution robust
under composition drove us and the
increments robust and the refactoring
and it is the best way of learning
functional programming you know if you
want to learn English go to England
speak English from
that's dusk-to-dawn the whole day long
and don't go to the native language
anymore you know for some time at least
that's the best way of learning it it
forces you into a new way of thinking
you will learn much more and then it's
just a pleasure to work with I know
everybody says this about his language
you know but he is true if you want to
learn it you can just pick up any
haskell resource there are thousands of
tutorials and what have you videos in
all possible forms you can pick those up
or and then there's also any books or
whatever there's also special free ebook
for the specifics of Vega that you can
check out there's currently and massive
online course running by Eric Maya for
functional programming 101 I guess it's
a little bit too late to to jump on the
train but maybe then next year it's a
very good of online course it's not easy
but it teaches your functional
programming that it is from my side I'm
very happy to take additional questions
and we have some as I see what happens
when we strong when we wrongly annotate
the java method as pure okay who decides
who decides whether it's pure pure
native you as a developer decide but the
vega type checker will do some
plausibility checks on what you say so
if you annotate something as pure but it
doesn't take any arguments no matter
what it really does in the end whether
it hasn't returned value or not if it
doesn't take any arguments it's very
unlikely to be pure well
if it doesn't return anything it is
obviously not pure it will not allow
that one it will give you warnings and
errors in these cases if you say I'm
using Java util time and I'm not
annotating this is so crazy as it is
type wise you know it you can change the
time and so on you can say first of
October is no second of October whatever
in Java util time if you do not annotate
this correctly that wrongly and it
happens that somebody actually changes
the value you may see an outdated value
then you know somebody changes the value
but reg has cashed it so you not see the
updated value that will be the the
effect</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>