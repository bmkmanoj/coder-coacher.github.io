<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Designing For Rapid Release • Sam Newman | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Designing For Rapid Release • Sam Newman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Designing For Rapid Release • Sam Newman</b></h2><h5 class="post__date">2013-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yMXox5DjQAU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is sam newman i work at
thoughtworks i probably should get some
things out of the way first I'm not
Brett from flight of the conchords it's
definitely not me I do know all the
lyrics to sugar lumps and a lot of the
lyrics to business time as well but I do
we borrow a lot of free beer before I'll
share either those things with you I
work for thought works as Mike mentioned
we're a custom software delivery company
we've got a booth you can come and hang
out and win a backpack that will charge
up your iPhone although in Northern
European whether it might take a little
bit longer than the five hours it claims
we also do a few products we've got a
tool that does a sort of user case
management systems agile tracking stuff
called mingle an acceptance test
scripting tool called twist and a tool
called go for continuous integration and
continuous delivery I will not mention
these tools ever again if you want to
find out about them you can come far me
afters they're all awesome but that's as
much as I'm going to say and we're also
hiring we kind of also always hiring but
I'm really here to talk to you today
about why ah well firstly why rapid
release is important why do we want to
be able to release our applications
faster than we did in the past and none
of this is sort of coming out of the
Lean Startup movement and everything
else but it's it's as much as anything
else it's about we are writing software
we're writing software for somebody to
go and use and the idea is is that they
is hopefully going to be something they
want to use and use well and they're
going to give us feedback about it so
we're constantly wanting to get our
software in the hands of our users
faster because then we know does it
really work can we get real-world data
about how effective it is about how many
machines we need most of you I suspect
working something that's web facing I
mean I know some people here do work in
embedded systems a couple of people here
that working guidance for Rockets fall I
know but for most of you you have the
ability to release to your client base
Mart much more often you already are
dwell too much on the
point but if you're interested in some
of the business drivers behind this
there's lots of other sessions of
continuous delivery on at the moment I'm
really here to talk to you about this
though which is the criteria that
influence design typically when I'm
working with a client and we're talking
about the existing architecture the
system and how to drive it forward or
we're talking about designing a new
system we're thinking about constraints
and principles we're thinking about what
the system needs to do and so we're
thinking about these criteria and lots
of these they often called the ill at
ease so but maybe the scaling how do we
want to scale our application maybe with
a latest zombie farmville plant Ville
mashup game from zynga and we need to
deal with the thundering herd from
facebook so that when people start
throwing cheap at me on my myface page
that i can scale to handle the load so
maybe I'm worried about linear
scalability I might be worried more
about durability maybe I'm the Danish
medical record system and I need to make
sure that my prescription records are
being stored safely and so I might have
to think a lot in my design about data
replication about durability of service
might think about geographical
constraints I might have legislative
requirements that mean that my physical
hardware that served the site needs to
be in the place where I'm doing business
people in the gambling sector have these
sorts of issues you might have to have
your kit in Gibraltar in Germany to do
business there compliance obviously fun
some of you might have been unfortunate
enough to work for a PCI level one
organization and have to jump through
lots of Hoops you might worry about the
technology what technology are we going
to build our application in is it going
to be a ruby on rails stack is it going
to be dotnet at performance these are
the standard things we think about
consciously or unconsciously when
thinking about designing the system that
we have it for the problem in front of
us but what about making it easy to
release our software how often is
something that's something we consider a
problem
most of the time it seems to be an
afterthought for many of the clients I
work with they've been developing a
piece of software for one or two years
they get the first release out and then
find it takes them another six months to
get the next release out and often it's
because they hadn't considered the
aspects of their architecture or the
design of the system that make it easy
for them to release software we're going
to look at three things really we're
going to try and look at design
characteristics that make it easy for
you to make the change in the first
place well then going to make it easy
for you to deploy that change and then
we're going to reduce the risk of the
release to your to your users your
customers your you know your front end
desk if you're in trading house and
these are the three things we're going
to look at today let's imagine an
example a second example here I am with
a music shop uh it's a very great site
it's an awesome sight but we found a bug
with it namely I put a Metallica album
in my shopping basket and the
recommendation system keeps suggesting I
go and buy Robbie Williams and justin
bieber CDs now clearly there's something
wrong fundamentally wrong with the
recommendation system but now there's
the wrath of sites doing quite well but
I need to make a change and it's a small
change maybe only impacts one part of
the system a very small part I system
maybe it's as small as a couple of lines
of code maybe some logic condition I've
got wrong but nonetheless were big
monolithic system like this that small
change to deploy it I effectively have
to redeploy the entire system which is
one big box so it may have been quick
for me to make the change assuming I had
a good unit test coverage to find the
problem implement a test to fix it but
the impact of that deployment is quite
large take a different situation let's
imagine now my music shop is actually a
collection of components services then I
need to make that same change and maybe
the size of the change is exactly the
same
but the impact of deploying that change
is sort of fundamentally different now
the impacts and therefore the risk
associated that deployment is
significantly reduced and if you think
about the fundamental is what we could
be talking about today the same change
has very very different impacts in terms
of what happens when I release it to my
customers it's another aspect here as
well it's not just about making small
changes and making those changes have a
limited impact in terms of releasing
it's also about freeing us up to make
small incremental changes if I want to
make a big change to a system what I
want to try and do is actually phase
that large change for system building it
up over multiple releases the nice thing
is every single one of these releases
that I make every single incremental
deployment into my system it's a
rollback point that's a great risk
management to achieve a risk mitigation
strategy now I can release a small
change knowing if something happens i
can quickly roll it back but i also
gather a load of data maybe halfway
through this cycle i decide i don't
actually need the big thing i thought i
needed and if i'm releasing these things
frequently in small chunks I get very
good at the release process so releasing
small chunks frequently helps me reduce
the risk helps me learn information at
learn learn about my system how it
behaves and so really we want to be
aiming toward small incremental releases
so what do we need to do for our design
of our system to allow this to allow
these small incremental changes well
let's take our big music shop how do we
go from the big box to the little boxes
I showed you earlier well let's imagine
one scenario here here I have my big
music shop and I started breaking up my
system into a series of Charles may be
shared libraries see here I've got my
recommendation library
this is the part of the system with a
problem why it keeps recommending Justin
Bieber to me I've probably also got some
invoice creation library maybe to the
third party library that allows me to do
PDF generation useful things like that
and of course it's a Java program so I
have to have a string utils library to
do useful things two strings because
Java doesn't let me do useful things two
strings now there's some benefits this
approach going from one big monolithic
codebase now to shared libraries for a
start it becomes easier to reason about
where functionality might be in my
system what I'm thinking I've got a
problem with the recommendation system
it's probably in the library called
recommendation jar you can hope anyway
um it can also enable actually quite
fast see I turn around cycles so if I
need to make a change the recommendation
library I just need to run the
recommendation library tests and then
maybe the tests of the overall system as
I integrated but I wouldn't necessarily
run all the unit tests to say invoice
creation the string utilities library
those other things that's beneficial me
so I may be easier now to make the
change there's a problem with this
approach so when it comes to actually
deploying it so here I am I've got
version 134 of my recommendation library
in production I find the bug would make
a few fixes a few performance
improvements and I now want to release
my library into production now if I'm in
a Java shop for example this is
effectively statically linked library at
this point unless you're just throwing
jar files into your servlet container or
you're using jboss in which case it just
randomly pick up a jar file anyway but
at some point I then need to go release
that change into production so out goes
version 2 I still have to release the
whole of that music shop web application
to get my new share my new version my
library into production um effective
this is because it's a statically linked
library so I haven't necessarily reduced
the impacts of the release into
production let's think of a different
scenario
let's now think of the recommendation
system as a separate service what
happens when I want to release a change
that new service all i do is i deploy it
and then i redirect a link now this is a
configuration change of the music shop
yes I will need to have done an
integration test before i deploy it but
in terms of impact to the running system
my music shop could stay up during that
transition if my music shop can stay up
during the transition to the new version
of the recommendation service I'm
reducing the risk I'm reducing the
impact to my users I'm reducing impact
my business but we can do other things
in this situation when I deploy the new
version of the recommendation service if
I can run them side by side I get to do
other things I might want to run some
smoke tests on it before I actually make
it live I may want to actually run a
showcase going eyeball it and I can do
all of these things while the rest of
the system is running quite happily I've
deployed it into a production system now
I couldn't do that if I was deploying a
new version of a jar file straight into
a servlet container directory or
dropping in a a new dotnet assembly to
hot patch of shared library so I've
given myself the ability to actually
manage the risk of the deployment and
make sure that I've made the right
choice if I need to back this out so
quit up quick operation this is
effectively what we often call Bluegreen
deployments and so once i'm finished i
redirect the link and then i can turn
off the old service jess is going to
talk about this later this is the
believe it or not the single best
picture of jazz I found on the Internet
he looks even more horrendous in real in
person he's got a book called continues
delivery he'll be talking about stuff
later on it'll really be very good I
don't know we'll find out later I guess
jess no pressure this is really the best
picture of you there is two blue green
deployments are nice so I think about my
service design I think about our
managing the risk of those deployments
in
in that way I can deploy my service I
can test it I can switch over when I'm
ready but there can be challenges it's
that mean maybe constraints in my
environment or in the problem space that
mean I can't do bring Bluegreen
deployments in this way easily some
constraints that you might have in your
systems right now that might stop this
from happening here's a fun one one of
the classic places where we do Bluegreen
deployments are actually with customer
facing websites so here's my user he's
using the music shop right now and of
course he's shopping is putting things
in his basket and because as any good
enterprise developer i have read what
the vendor told me about how to store
baskets rather than looking at the HTTP
specification and so as a result i am
saving the state of my basket actually
on the application server of course it
is always the best thing you can
possibly do now i have a situation
winder to deploy a new version of the
music shop now i have to deal with the
fact that once i've tested it and smoke
test it and make sure it's happy and i
want to redirect my user / I now have to
move that state over as well so that's
problematic or I have to decide to kill
the state that then becomes a business
decision there's no real need to do this
most of the time just use cookies
instead often people end up using
clusters servlet clusters at this point
which has all kinds of inherent issues
in terms of increased network bandwidth
money going to vendors doesn't need to
go to vendors so I would say in general
avoid stateful services store stays in
the database I think that's fine just
not in application memory state it's
very hard to make transition to that
point what about expensive hardware oh
no we can't afford another box to run
your system in parallel on this is
becoming less of a legitimate concern
than it was in the past for those of you
using external cloud infrastructure
you're talking potentially about running
an overlapping system for an extra
couple of hours that might be a few
dollars depending on how big the system
needs to be it can still be a legitimate
problem so how can I redeploy my
recommendation service with and keep my
system running thereby limiting the in
back to that deployment without
requiring more hardware so one option is
to use a manual circuit breaker here's
my website right now I've been buying
Queens as donors take that into new dog
and it's recommended i buy the brakes
the brakes were great band I always go
around telling people are very bad so
then Here I am running live and it's all
going well but we find the bug with the
recommendation service and I want to
make a deployment but I want to keep the
site running while I make that
deployment but I can't bring up another
box I don't have a spare box deployed on
maybe the size the service is too big
maybe require specialist hardware well
what we can do is effectively put a
circuit breaker around the connection
between the music shop and the
recommendation service when I want to
deploy the service I blow the circuit
breaker now at this point I need to
degrade the quality of service to the
front end web site now this is something
you need to be considering anyway when
designing distributed systems you need
to understand what happens when a
service is not available that you depend
upon so in this city particular example
we just don't display the
recommendations at the moment now this
could happen during a normal network
outage here it's a purposeful thing I've
blown the connection this now allows me
to deploy the new version on the same
hardware as I had before run my tests
once I'm happy I redeploy the service
reset the circuit breaker and back comes
the connection now to an extent the
music shop has to be quite aware that
I've severed that connection so you have
to consider that but if you've got
synchronous downstream connections to
services anyway you need to understand
what happens when that service isn't
there for accidental reasons like
someone pulling out the power but here
I've had to think very concretely not
just about how one service talks to
another but also about how the user
behavior needs to be affected and
impacted by that sort of deployment Mike
mentions the circuit breaker pattern in
his book there it's talked about more in
of a way of managing downstream
deployments you can actually take that
manual circuit breaker make it an
automated circuit breaker by putting
health checking on it so for example if
the downstream connection responds
sluggishly or doesn't return quickly
enough you can automatically sever that
connection so it's well worth reading
Mike's book on that subject there's
another approach which is to make the
connection between your music shop and
the recommendation service asynchronous
so in this situation I'm firing say the
basket contents out to recommendation
service and I'm expecting a request back
to the music shop to say here's what the
recommendation should be now here things
are a little bit different if i take the
recommendation service back down the
music shop kind of doesn't know it's
still throwing those requests out
assuming I've got a persistent Q sitting
there he never need to know anything's
happened but he does need to know that
he hasn't received the response yet as
the requests build up responses will get
slower and slow and stop happening and
at a certain point again you still need
to degrade the user behavior and the
user's experience sorry there is a
subtle difference here in terms of what
happens for the user though in the
previous iteration we knew the
recommendation server hand gone we knew
that was definitely an error state but
with an asynchronous service it's not
always immediately obvious that
something's not there and not going to
happen versus just being a bit slow
these can have quite subtle impacts on
user behavior so I wouldn't necessarily
suggest changing your service or service
communication to being a synchronous
purely to allow you to remove these
services easily there are lots of
emerging complexities that happen any
sorts of situations so here I say
waiting I don't know I'm in a narrow
state right now I just know it's taken
longer than I thought it should normally
but nonetheless once my new service gets
deployed it just starts eating back
through those messages and my
recommendation start flowing again if
you already have a service that is by
nature a synchronous in terms of its
communication style then maybe just
using persistent queues allows you to
deploy those services
fairly freely there's a lot of
interesting patterns around how you work
with a tinker's communications in the
enterprise integration patterns book so
it's worth a read if you are doing this
stuff a lot there are some other things
to watch for though when thinking about
your service design i've talked here
really about how you take a big system
break it up into chunks to allow you to
deploy those chunks independently of
each other there are numbers a come
number of anti patterns that can emerge
though when you're moving towards these
sort of distributed architectures I
would describe a couple to the first one
is one called the trifle I'll explain
what trophies later Here I am on music
web shop and I've just I've gone to sams
talk but I fell asleep at this point and
thought the thing I've got to do when I
get back home is I need to split my
system up so the first thing I do is I
look at my code base and I see a thing
called the repository layer and I think
great as a perfect place to split my
code base into two services it's already
there I've got an API call so now I go
my persistence layer is now a separate
service the problem is now when a
feature changes you'll typically find
that one change now needs to be applied
to two services remember what we were
trying to achieve by decomposing into
services we're trying to make it quick
to make a change and quick to deploy
that change and reduce the risk of that
change now if I've got to make a change
that you've been one code base and now
that same change needs to be applied to
two code bases and I now need to deploy
two services I am NOT better off I am
worse off and this is a very simple
example they can get worse when you have
multiple layers the other thing that
happens here though is when you slice
services sort of horizontally across
arbitrary technical background
boundaries you also tend to find that
the communication between those services
becomes very very chatty you're making
multiple calls across the wire that
becomes inefficient and slow to manage
and you'll often also find you want to
change
those API is far more than you would
normally and if you've got a giant stack
of systems like this that can get
difficult now I did this talk recently
in Hamburg and it was pointed out to me
that not everybody knows what a trifle
is so that's a trifle there you have
layers of sort of custard and things
it's at rifles are bad that's what you
need to know unless they've got
sufficient brandy in them we really
we're aiming more and this is also in if
you're German this is like a black fri
scatto so think this is the black crowes
gateau patent if that's helpful to you
we were a more for sort of a Battenberg
cake thing where there's this is like
hexagonal architecture let's put your
whole set foot tall comparing cake to
Architecture patterns it's yes it's
marzipan and apricot jam is quite tasty
there's another anti pan out there which
I see quite a lot which is the spider so
here we are with our CD ordering system
and they are other services I need to
talk to you to accomplish my tasks I
have a white male system which is not
the opposite of blackmail these are
often the systems that send letters to
people let us still do exist we have a
system for doing data warehousing
because you need a data warehouse to
store your data in otherwise it gets
lost I don't I've never seen data come
out of a data warehouse system but it's
definitely got to be there so you've got
to send it somewhere I need a third
party supply to send me all those justin
bieber cds i'm going to end up ordering
after my recommendation system glitch
and some finance system to make sure we
all get paid and what happens at this
point is you find out about something
called business process modeling or
workflow management and you think great
what i'm going to do is create a nice
flow chart of how my system works and
i'm going to put that cyst at that flow
chart that business process modeling
somewhere and of course i put it in the
middle and so this guy now there's all
the orchestrator I to do that then I'm
going to do that then I'm going to do
that and what you end up with is for Dom
systems and one giant snag in the middle
the god class we had assists a suicide
is my worked on recently and we had a
very simple class called the scheduler
and the shed his only job or two
good jobs at a certain time of day I
went away came back six months later and
they renamed it the director the
director did everything the problem
again now is I want to make a change I'm
probably going to have to change the CD
ordering system right in the middle
because he knows everything why is that
a problem well because now this is the
most important system in my entire this
the most important service in my entire
system I probably need to change that a
lot and it's the one thing that's
everything else is relying on I haven't
reduced the risk we haven't made it
faster to make the change either uh Ian
Robinson I was talking to him very early
about services near trenton some of the
service was and he had a nice definition
he used which was that a service is a
set of capabilities on an endpoint and
talking to him help me understand what i
was doing wrong previously when I was
breaking up these services across these
arbitary boundaries or having single God
services sitting in the middle what do
we mean by sort of capabilities instead
of capabilities at an end point when you
see services and components that are
well factored what you actually see our
services are grouped around to the
capabilities that make sense for your
domain your business user these are
business focus capabilities CD shopper
focus capabilities I might want to add
things to a car I want to check out my
basket doing a latest release is
searching listening to previews these
aren't things around an entity or an
arbitrary technical distinction these
are things that anybody in the company
working on that piece of software be
them a technologist or non technologist
should understand and when you start
identifying these capabilities as they
exist in your system you can just start
grouping them together just kind of like
what you're doing with the main given
design and created bounded contests and
when you've collected enough of these
together they start becoming effectively
the boundaries for your services the
reason this is great is because your
communication then becomes focused
around what you're trying to achieve
with your software
it doesn't become around arbitrary okay
find by ID with no I'm checking out I'm
placing an order removing something for
my basket the benefit then becomes is
that well what do we do when we roll out
a feature some change we want to give to
the customer in this case some buying
CDs that's going to be a change in how
CDs are bought and that is much much
more likely now that changes much more
likely now to be limited to one or two
of these services not rippling out
across the entire system I often when
doing these exercises with clients will
almost do if you may remember from
University when we talk about
object-oriented programming we did the
crc card exercise where everyone got to
pretend to be an object we did that very
enthusiastically for one tutorial then
never did it again I actually do it for
services role-playing the exercise is
okay so I want to achieve this task so
how am I gonna cheer that well first I'm
going to go to you and then you're going
to go and do this and then you're going
to go and do that you start to uncover
problems in your design very very
rapidly have I got snags and I've got
circular dependencies are things overly
confusing and chatty you do not need
someone very technical to do that if
you've got these boundaries correct
that's a very good way of keeping your
eye and am I factoring these correctly
so really think about modeling your
services based on your domain and I
would say your domains capabilities so
operations high level operations rather
than entities another real problem
though when you're breaking up into
services is how those services talk to
each other let's consider some more
scenarios so here I am with my music
shop with a recommendation system now if
I make an internal change to the
recommendation system maybe a small
change I maybe add some logging
statements internally the interface has
not fundamentally changed as long as I
haven't changed the semantics of that
interface I'm fine the music shop
carries on as it was before maybe now I
add some new API calls but the old API
calls i could make across the wire stay
the same this is now an expansion change
again
I don't need to redeploy my music shop
the music shop carries on he's very
happy what we have to deal with are
breaking interface changes these are
either fundamentally different api's or
very very different semantic behavior of
an existing call which is always bad
this is a problem because again if I
want to limit the impact of a change and
I keep breaking api's to remote services
on suddenly starting to increase the
size and the risk of my deployments how
can we manage API change well the first
thing is if you're going to introduce a
breaking change is consider not
introducing the breaking change that's
always good but consider also having two
end points so let's imagine I'm rolling
out a new iphone application and it
needs to communicate in quite a
different way and actually we've looked
at the old version one endpoint and it's
getting quite crafty and we're not
really very happy with it so we've come
up with a nice much better fact it
easier to support api that we so what
can I do well just roll out the new
endpoint but have them running side by
side I can now release my iphone
application on the new endpoint I allow
other consumers of the old endpoint to
continue as they were before buying them
time so if i have 2 3 4 5 10 consumers
they are unaffected by that change so
now i get time to talk to those teams or
schedule that change when they do their
next release and then they've won ton so
ready we can redirect that change so
that's one thing we can consider doing
to limit the impact of interface changes
there are other things that can go very
badly wrong though when your turkey
talking across a service boundary this
is a classic one that I did about five
times before I realize it was a bad idea
to services now of course I'm
communicating I'm taking some in memory
object state I'm creating a serialized
form of that object state and I'm
sending it over the wire and the other
guy well he's got to deserialize that
now any good developer who has been
raised on don't repeat yourself is
immediately seen
King our code reuse and what they do is
they create a library they create a
library that can take the in memory
object state serialize it deserialize it
back into the same object state because
that means less code they then use that
same shared library on two services so
here I am service a objects your lies
and sent over the wire fantastic and
then I go and release a new version of
the shared library code and I did when I
deploy the next version of service a can
i still send stuff over the wire maybe
maybe not one system I saw are they had
a fairly behaves of pervasive shared
library representing their domain
objects that was shared across four
services they could not reliably
guarantee they could deserialize objects
when it had different versions that
shared library it was worse because
those like those objects were sitting in
message boxes throughout the system so
when they needed to release a service
that needed a new version that shared
library they had to synchronize
deployments that share library the
entire system it has to take all the
services down they then had to have a
job that rewrote all the messages on
this on the message buses and put them
back in so really your way of shared
serialization protocols so things like
Java serialization wisdom binding can be
quite bad at this things like Jack's be
there are some binary serialization
protocols that give you a bit more room
to maneuver things like crota buffs and
thrift however they don't really solve
all the problems here and typically you
see people never changing their binary
serialization protocols because they are
too scared of the impact really the
thing we need to embrace here is
something was detailed in RFC 761 which
is one of the early tcp/ip rses and it's
something that's been called postelles
law just be conservative in what you do
and be liberal in what you expect well
what does that mean what it means if I
get sent something and I've got to react
to it don't find to the whole message
and as I need the whole message now with
binary serialization
I'm kind of forced into that I have to
unpack everything and if things are not
there that I expect but don't use I fall
over if I need three fields from a very
big soap payload don't bind to the
entire schema because that just
increases the surface area of me getting
broken by something our best practice
advice when consuming soap services use
XPath don't use a Wizzle binder pull out
the little bits you need and then if
somebody change parts of that scheme at
outside of things you care about you
won't even notice often when we're doing
shared services we will actually not do
code reuse across those services it can
often be significantly better few just
to copy and paste code between services
and reuse them and accidentally get
yourself in a situation where to deploy
one change you have to redeploy the
entire system this can be very
counterintuitive for developers but
believe me the alternative is far far
worse another way you can think though
about I mean I've talked about things
you can do to avoid breaking changes are
there ways you can catch that though
before you get into production and the
answer is yes and consumer driven
contracts or a great great way of
avoiding that so with consumer driven
contracts here's a music shop is
consuming the recommendation service it
has an expectation about the quality of
service for that set for that downstream
service it expects that when I make this
kind of request I get a response that
looks like this now when you're
designing these service boundaries
you're having that conversation maybe
within your team may be across the team
but often that band that becomes an API
and that's often the end of the
conversation what if I we actually
codified our expectations of that
service as a test see the music shop say
here is what we expect your service to
do when I do this that test then gets
run by the recommendation service in
their build so every time the
recommendation service makes a change
they go out okay let's look at our
consumer contracts let's run them if we
break them how we broke them okay great
well we may have changed our API we need
to go have a talk to the people that are
consuming us or we need to change what
we've
this is a great early warning it allows
the recommendation service to keep
changing keep changing keep changing
knowing they've got that safety net in
place that once they go into production
they've done as much they can do to
verify they won't break any other
changes you can be braver than in
releasing the change into production
unfortunately I've talked about all the
easy stuff so far what I haven't talked
about much is databases the real problem
we've got as any of you may know who've
been to the big data tracks is that data
is really really cool and it's mostly
seems to be a volume thing like one
gigabyte is definitely better than one
mega by a terabyte is better than the
gigabyte a petabyte is awesome I'm
actually quite looking forward to the
Hadron Collider data storage talk later
on the clearly volume is the thing we
put aside petty concerns like how we
might use that data or using it to drive
business decisions because that's crazy
talk but data is very very cool the
problem is that databases are inherently
evil things and they are evil in the
context of making things easy to change
here's a really this is probably the
most common distributed service
anti-pattern we see hands down the most
common and also the most destructive in
terms of making it easy to apply changes
to your system my music shop talking to
some database schema are we Oracle racks
I've got lots of money from selling
those justin bieber cds and i pull out
the recommendation service because
that's the important thing right but i
still keep talking to the same schema
really standard stuff why is the problem
well if i want to change the music shop
now and maybe i want to change the
schema design to support a change the
music shop can i do that kind of might
not know i don't necessarily know what
the recommendation service is doing my
schema am i going to break the
recommendation service
don't know equally if both these
services are writing to the same tables
but they have business logic that's
different how do I know I'm going to
meet my data changes in a consistent
fashion kind of don't know at this point
you need to treat almost your database
schema as a separate service with a huge
undefined API that is sequel at that
point you start realizing how bad this
is I would actually advocate if you are
in this situation you've got two choices
you either start trying to separate out
your database schema or you merge the
services back because this is worse
significantly worse for us because what
is it we're trying to do limit the
impact of a change and be able to
release effectively and efficiently I
now can't make changes without knowing
about the ripped out affect what we want
our separate schemers the music shop
want to talk the recommendation service
goes by the service API boundary
typically this won't require any more
hardware just a separate schema
separating them is not always easy but
it can be done and it is significantly
better so each service should own its
own data typically you think in terms of
entities being owned by services and
having control over the full lifecycle
of those services why is this great or
we wouldn't make loads of cool changes
to make our services better let's
imagine now that I've decided that my
recommendation service really really
really need to move to react because I
saw Preston talking about it last year
and thought react is cool I've got to
distribute my data across the world but
i can now freedom i'm now free to make
that change because as long as my API a
doesn't change and the semantics of that
API do not change I am not impacted
Crescent actually outlined a nice
approach to how they handle the
transition for the medical record system
from my sequel to react as worth
dwelling on here so here I am I need to
route release to react but I don't know
make that a big bank change
I don't know suddenly go okay i was now
my sequel and now I'm react so instead
the first release i duel right I write
my data to both places I'm still reading
for my relational database management
system why am I do writing at this point
I'm jewel writing at this point because
I want to roll back remember we're
trying to make small incremental
releases with reduced risk I want about
to roll this change back quickly at this
point if we act collapse in a heap the
previous version I can go back to and I
can still have all of my data that I had
before assuming react holds up
operationally it's scaling everything
else I can out reading from I can now
read from react I'm still writing though
to my relational database management
system again I need a rollback point and
only when I'm ready so I actually need
to remove that system this is kind of a
variation on what's often called dark
launching in fact you I brought up a
subsystem without anyone really
realizing it I've been using it in the
background and anyone already do i
effectively release that feature to the
customers the interesting thing here is
is that for the point of view the
customer there may not be any impactful
change but it could be a fairly large
scale change I've made without anyone
really realizing what's going on this
can happen for services to I come out
with a brand new version of my
recommendation system this one's written
enclosure so it's obviously going to be
better and faster and will definitely
not ever suggest I get justin bieber cds
its do we like five lines of code
compared to like twenty thousand lines
of scholar in the recommendation service
but here I am so I make my change and
again I could do it with the services
the recommendations maybe I sent them to
both services in production but maybe
I'm only looking at the responses from
the recommendation service I can make
sure that it's not i'm not getting high
error rates i could actually have
someone look at a log of the responses
and see if these things look sensible in
a production setting and then when I'm
ready i can retire the recommendation
service
so we talked about a few things in this
session I'm on the time I've talked to
you fast we've talked about decomposing
our system into small units and doing so
we thought about modeling the domain
we've talked about how you when you do
that how you get the interfaces right on
your system and we talked about a number
of patterns where we separated the
deployment of something from releasing
it to our customers bluegreen
deployments I deployed than I released a
feature we talked about dark launching
there are lots of reasons why you might
want to move towards component based
systems going from say share gain from
nice package structures to module
structures to distributed services
that's a fairly sensible progression by
breaking up our system into components
it becomes easier to reason about if we
take that to the logical conclusion it
becomes easy for us then to replace
those systems without affecting the
overall health of our entire service
there are lots of reasons why we might
want to go that route I might want to
split these things up for Team reasons
for performance for scalability for
technology but ultimately we need to be
thinking as well about how easy it is
for us to actually release our system I
used to look through the ill at ease
lists that the software engineering
Institute has there was always
maintainability I used to think that
maintainability was all about code
quality doing TDD maybe some functional
testing but maintainability is no point
in making easy for me to make that
change if I don't think about how it is
that I can make that change in a
production setting and all I think we
need to do is consider that what do I
need to do how how would it be if I may
be released this feature now what would
happen to my overall system I've also
outlined those some approaches that make
sense if you need to maintain up time
some of you might not have those sorts
of challenges
but nonetheless we're seeing a movement
away from large monolithic systems to
smaller services talking together
microservices this is much more viable
than it used to be because we have cloud
providers that allow us to provision
boxes just big enough for our services
we have infrastructure automation
technology that allows us to bring these
services up and down and we're getting a
lot more experience about why our PC is
bad and why rest is good and all those
sorts of things so this has been a
whistle-stop tour through some examples
of how you can change your architectures
your designs of your systems in order to
make it easier for you to release
components but it's not exhaustive the
key thing is just applying conscious
thought is the ability to release your
software frequently important to you and
if it is think about it a lot more when
you make your decisions I am a little
bit under time so I do have time for
questions sure the question was when
integrating services together I could
either make lots of calls across all the
services or I could have a music shop
service that pulls these services
together to present something to the
user and the question was what would my
preference be I think when you're going
to a web page as a user that web page
have to be hosted somewhere that is
always going to be an integration point
for a simple user facing website the
question really is about how thick or
thin that experience might be and
there's a balance between creating a
compelling user experience versus you
know decomposing behavior into the
systems so i would think that service at
the top needs to be extremely thin maybe
all it's doing and if it's you may just
be serving back some HTML and javascript
and CSS so the music shop may just be
responsible for the commune oh the
consistent user experience and then the
calls are coming straight from the
client back those end systems that might
not be viable though depending on number
of services you have involved and you
may need to be doing some server-side
aggregation before serving it back to
the customer I have experimented looking
at actually serving up whole snippets of
you I from difference
services and reassembling those the
problem just comes back to how do you
maintain a consistent look and feel if
you think about limiting the impact of a
change if I release a change that has a
fundamentally different type of user
experience the impact of the user is
quite jarring so probably for a simple
website or standard customer-facing
website you want something but it should
be very I think we fairly thin and may
just be something that takes that that
takes that sits on that domain and
assembled on the client side if you
serve the content that comes back from
your services with decent cache headers
you've got the option of doing
aggregation in the client or aggregation
in the server you can use reverse proxy
cdns to mitigate the risks of those
things so the comment was that you've
got lots of soap going on lots of
schemers for the messages being passed
between the systems and you're trying to
move away from that entirely have you
seen that elsewhere if you mean moving
to more lightweight schemas I mean when
designing what I'm talking went the way
one service talk to another service we
just model it in a very lightweight way
based on the business itself so it
should be the payload you should be able
to show that payload to a business user
and they should understand what that is
almost the serialization protocol is it
XML is it Jason almost isn't kind of the
point but the key thing is our very
lightweight and certainly I have yet to
see any benefit from wisdom has given us
other than the ability to very quickly
generate a programmatic API that then
won't be able to talk to a different
programmatic API generated from the same
wisdom I had lots of fun doing that with
talking to British Telecom for example
we had to find out the exact point
release of Apache axis they had to make
our version of apache access generate an
API that would allow them to talk to
each other so yes we are seeing people
moving away from that type binding to
sort of lighter more informal schemers
the key thing is if they're human
readable is probably very easy for them
for you to write code that can consume
them and if they are based on how
your business operates they're also
going to change probably weigh less than
they might if they were just an
arbitrary technical message you're
sending along because developers like
shift f6 seeing stuff in IntelliJ for no
apparent reason other than they prefer
the name of something else they tend not
to do that with business concepts so the
question there was how she managed
changing in the database so I've got two
versions of the service and I've
deployed the new version of the service
and it still need to talk to your
database and maybe that version of the
service requires a change the schemer
how am I going to run those things side
by side if you need to maintain the
system to be in an upstate you may need
to phase the deployment of your schema
changes so for example you could do an
expand contract type pattern so maybe
the first thing you need to do is apply
a schema change that adds the new
database fields tables columns you need
stitch 1 step 2 would be deploy the
version of the application that uses
that new data and then once you've done
that later on you could apply second or
third change that removes the old
structures so you to expand that
database you end up having to phase it
fits into three releases many of the
organizations that practice quite
frequent release cycles thinking of the
Exies their flickers of the world they
may be releasing service changes to
component services multiple times of day
they are not doing the same thing for
database changes when those databases
are shared the key thing is that becomes
significantly more problematic if
different types of services are talking
to the same database if you can segment
that and have services I own their own
database you at least slim down that
complexity to when you have a schema
change here but a schema change here
doesn't need to affect a service over
here but you may need to phase it you
need to think very carefully about how
you do database changes and there's no
way around that especially for those
systems which is where the schema is in
the database I would also argue that
this problem does not go away with
so-called schema lyst data data stores
like Mongo you do have a schema it's
just an implicit schema in your
application code you are choosing to
name a field a certain thing and if
you've got two versions of server
you're calling those think those servers
those fields different things you have
the same sort of issue going on we're at
time well thank you very much I'll be
around all day if you've got any
questions and the slides and video will
be up soon thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>