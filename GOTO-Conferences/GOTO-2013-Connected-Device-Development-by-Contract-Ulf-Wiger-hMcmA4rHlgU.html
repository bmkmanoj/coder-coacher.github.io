<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Connected Device Development by Contract • Ulf Wiger | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Connected Device Development by Contract • Ulf Wiger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Connected Device Development by Contract • Ulf Wiger</b></h2><h5 class="post__date">2014-04-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hMcmA4rHlgU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're in the business of connected
device management and the connected
device market is fairly big today but
it's a I think it's on the verge of an
explosion and a transformation what
we've seen so far is essentially stove
pipe type connected devices either your
mobile phones that are managed by
operators and it's it's pretty a closed
system or even your Android or iPhones I
would say that they are reasonably
closed ecosystems as well if you want to
program it use those as a as a device
for your application you kind of have to
buy into their entire culture and they
will also have a lot of requirements on
on your code to even allow it to run on
their devices we are betting that what
the market will want and we're trying to
tell the market that this is what they
want is a more open system a system
that's more friendly to entrepreneurs
because nowadays you can buy a fairly
capable small device for a few hundred
not even a few hundred bucks like less
than that you probably many of you have
a Raspberry Pi lying there at home
somewhere gathering dust how many of you
have actually used your Raspberry Pi ok
a few how lonely you haven't yet about
as many I have 12 I haven't unpacked it
yet because my I let my colleagues do
that and I program them program the
server side so we want to provide a
connected device management as a service
and
we try to visualize it like this where
our stuff is the blue stuff in the
middle we have a server side that does
device and traffic management we do
provide software device components open
source software for device programming
but essentially you do the device
programming and you do the backend logic
a typical web server the interface here
that we provide for now is JSON RPC and
the interface on this side at least if
we get to choose is Burt RPC which is an
erlang style RPC format but at least one
of our customers is actually using their
proprietary protocol with devices that
they have written in C++ and we provide
a plug-in than in our server so some of
the challenges briefly about device
management connect the device management
one is coverage if you have devices that
are actually going to be out in the
field you can't really depend on the
communication or the connectivity
they're being that good this is Sweden
2013 Sweden as one of the country's with
some of the best mobile coverage in the
world this is SMS coverage a little bit
bad up here this is 3g coverage you can
see that in half the country there
aren't that many people living there but
in this half of the country you really
don't have much 3g at all and 4g well
that's not much unless you're in the big
cities you don't have 4g i have almost
4g i have a 4g modem that i'm running 3g
on because i can't really get a lock on
the signal at my house so looking at you
the u.s. this is a the results from a
survey of what kind of download
throughput you have a different
measurement site and you can see that in
most cases here you have less than 768
kilobits
so the normal case in many places
especially if we talked geographically
is that you have very poor coverage and
if you're going to make a device
management service you have to be aware
of this and you have to be flexible you
you really have to also know about the
rate plans if a device happens to be
roaming you don't want to push firmware
upgrades to it your customer is probably
going to switch to a different provider
then so what our server does is it's
essentially a store and forward system
you could look at it as a request router
between your back and logic and the
devices any keeps track of when when the
devices are online and what kind of
chronic connectivity they have if
they're not online we will cue the RPCs
and if you have a push notifications
enabled we may push an SMS to the device
letting it know that there is stuff to
be fetched from the server so that the
device can connect when it's convenient
now in our model it's always the device
that connects we don't want to actively
connect to the devices unless we have to
so we also support scheduling operations
in time so if you want to do firmware
upgrades of a lot of different devices
you may actually want to like you know
for example Apple does and that once
they have a firmware upgrade it may be a
while before your phone is actually
scheduled for upgrade so this is fairly
standard stuff it's the kind of stuff
that you don't want to do yourself if
you have a great idea for a new smart
connected device you don't want to spend
most of your time building a management
system that keeps track of it and does
the
upgrades and you don't want to spend the
majority of your time plowing through
legacy device management protocols that
is not fun so one thing that we and
that's what I want to try to illustrate
today is sort of the lead time challenge
if you have a great idea and you can buy
the device or you got your Raspberry Pi
handed to you at some conference and you
want to go home and you want to play
it's it's loaded with linux you know how
to program that and you can buy some
connectivity stuff for it and you can
have a lot of fun what we want to
support is to allow you to go from a
great idea to an end to end working
prototype that you can show potential
investors preferably within a week if
you're a smart guy and and very
motivated so we try to be not bloated
and we also try to not be too limited
that this is the challenge to allow you
to very quickly get started but not to
cover all the functionality that we can
provide within a week you want lifecycle
management let's see so
we haven't really we do have a free
server up and running for the Linux
automotive foundation people who are
members there but the the plan we have
is that you get the first 10 devices for
free so that you can do experimentation
and end demos to impress people with
your idea and then there will be a
progressive licensing scheme once you
feel this commercially and some of the
features more complex features that we
have are really intended to allow you to
evolve your devices so that you can have
multiple generations out in the field
and still be structured in how you how
you manage those so and this is the
programming by contract part we have a
specification repository in the server
and so what you do is you specify your
your our pcs the AP is the and the
notifications that come from the devices
in a fairly a nice-looking specification
language you tie that to different
devices and the system will then
validate all incoming and outgoing
messages against the schema you provided
and the specification language is yang
it's actually an evolution from xml or
SNMP xmlrpc various other technologies
so if you've heard of the the standard
net comp for network management this is
the modeling language for net conf and
it's about as nice as they come and we
would like to push that as a more
general way of specifying api's some of
the customers we have that are in
commercial service right now is a
peer-to-peer carsharing
company in cattle in San Francisco where
the idea is if you have a car that
you're not using during the day you can
register it with their service and they
have something called they call the car
kit that they install in your vehicle so
when someone wants to rent a car they go
to their service they check which cars
are available in the vicinity and they
can choose which kind of car how much
they want to pay fancier cars higher
rates and so on and they go to the car
they identify themselves with the iphone
and the service get around can remotely
unlock your car so they can get in and
drive away so you don't have to be there
and they monitor where the car is with
the way point tracking and they have a
kill switch so if someone tries to run
away with your car they can actually
stop them from doing that so that's
these are the guys that have device
coded in C++ and a proprietary protocol
another system that we support is a
little fingerprint scanner that actually
one of our founding partners designed
and manufactured for the customer where
patients can identify themselves with
with a fingerprint and and some other
authentication and that ties back into
the information repository on the server
so that doctors can get their medical
records and things like that so the
thing I'm going to talk about today is
we had this demo with Jaguar Land Rover
and that is one of their chief engineers
matt jones who was talking at the linux
your linux foundation collaboration
summit and the idea was to very quickly
come up with a prototype of some kind of
connected car
application the entire car industry is
trying to figure out how to in make cars
connected and interesting so that you as
a driver get a get a good experience
their problem is that if they ask people
what do you want in your car in terms of
connected experience nobody really knows
it's essentially they will know it when
they see it and typically they will
probably know what they don't want when
they see it so this was a way to try to
stimulate some prototyping in the for
the car industry so what we did was to
remote control the the air conditioner
in the car I don't know how useful that
is but essentially we had an iphone app
and a web app and you had the you had
the touch screen in the vehicle where
another company programmed the web
interface using web kit and that
application talked to our device
software that talked to our server which
forwarded information to the web server
and also the iphone so you could control
it from your iphone and from the the
website and from the car this was a
three-week project and this is the
reference hardware that they use in the
automotive sector it's not an extremely
impressive CPU or anything so I would
say the main thing about it is that it's
very rugged and it has the interfaces
that you need to hook up to the car so
it's not the kind of hardware that you
would probably buy so here is a
schematic of the application so the can
is a controller area network that's a
kind of network that you often find in
your heat pumps and stuff like that at
home also in cars and in a lot of
different machines it's a fairly
low-latency a a network so our XO sense
device used uses our can protocol stack
to talk to the the network bus and the
climate system and then we have this
application that I'm going to walk
through and the web app the WebKit app
use JSON RPC to talk to a little web
server in our device software and then
we use some go went through our little
proxy application called XO port that
talks to the server which in its turn
talks to the back end web app using JSON
RPC sounds a bit complicated but i guess
the complication for you is how much
code you would have to write this would
be the basic steps and it really didn't
take many days to to do this our side
you create an account on the server
that's a well simple registration you
write your yang spec there is a nice
little Python program called P an that
will parse it and validate it and tell
you that it's syntactically correct you
store that using for example a curl
command that we provide then you go in
and you define your device type and you
link that to the yang specification and
then you start defining devices and give
them this device type and then you just
write some device code and demo and then
you get lots of money actually we didn't
get paid once and for this particular
demo but theoretically you get lots of
money so the specification this is yang
you create a module you give it a name
basic namespace stuff we have a
specification called XO cell
that you can import and that gives you
access to some basic types and request
parameters and this specification will
then be used in this validation loop
where anything that doesn't conform to
the specification will be rejected the
requests that actually do conform the
specification will be converted to or
normalized so you deal with the
structures that the validator spits out
and then that's forwarded to the device
so an RPC specified in yang here we're
going to look at the set fan speed
request RPC so it has an input section
an output section and in this case this
is a standard here you inherit the
standard request parameters that we have
provided that tell the server what
device it is and there are some other
parameters you can set optionally like
request timeout and things like that and
these are the standard reply attributes
so here you don't really this is just
boilerplate this is the stuff that isn't
boilerplate the fan speed attribute
which is here and unsigned 32-bit
integer so that was your specification
for this particular request now if you
would want to test this what we normally
do we write a curl script sort of copy
and paste you put the JSON here so this
is just the standard json-rpc you call
the jl our demo call and set fan speed
request and here you provide the device
ID and the fan speed that you want to
set so far fairly simple now we get into
the actual code and
erlang code how many of you have ever
programmed in Erlang here whoa a few so
the rest of you are going to be experts
after this the so the entry point here
let's see this is from the from the
local web server so that was from the
WebKit application so and that request
is also validated but on the device ID
on the device ID we actually take the
yang spec and compile it to ur line code
because we have less CPU power there and
fewer specifications to worry about so
we just check what the method was and
here it's set fan speed requests and
what we do here is we call this this is
just the helper function down here where
we so we pick out the fan speed argument
and we send that to the can library to
create we're going to look at that later
what we also do is we forward this
upstream we do an export our PC and we
just forward that request up to the
server which is going to forward it to
the to the web server on the back end
and this is the entry point when the RPC
comes downstream from the server and we
call the same helper function here and
then we send it to the HTTP via the HTTP
client to the WebKit application running
on the on the panel in the car so
essentially it's it's just sort of a two
way switch here or a three way it's also
talking to the can the canvas the canvas
code this is almost all of it that
pertains to this particular request
here's the start function and you call
you start the
can router and this is actually the
initialization code for this where you
we tell it to start the can protocol we
just get a start the socket server and
then we send an initial can frame and
then we set the refresh timer here is
the code that is needed to set the fan
speed we extract an offset and a length
for the fan speed part of the can frame
and here we have the packet which was
the initial can frame inition from the
beginning and that it can be updated
later and we just pick out the what
comes before the the fan speed attribute
and what comes after this is Erlang bit
syntax which is pattern matching on an
octet string and then we put in the
speed here with a length indicator or
the length indicator just tells the
compiler how many bytes to insert here
and then we send that packet and we're
done so that was actually
yeah that was it that was the only
difference in so not a whole lot of code
and of course the the main change here
from from the past is that these devices
are actually real CPUs they're about as
powerful as your desktop was some years
ago so they're running Linux running
something like Erlang actually earling
has a smaller footprint than Java so if
you have well say you have 128 megabytes
of RAM which is nothing then you can run
very comfortably 64-bit megabytes of RAM
it depends a little bit on what you're
doing but for most device side
applications it's not a problem at all
to to do this within 64 megabytes of RAM
and of course the advantage is you you
can do this very quickly it's not that
much code provided you have nice
libraries so I'll list some of the
libraries that we have built so far and
these are all open source these are the
ones we have released so far as open
source we're a little bit unstructured
in our release process so this may have
passed you by most likely even if you
were looking for them we have an SMS
library that allows you to for example
subscribe to messages from a certain
phone number or whatever you can pattern
match on the actual content of the the
SNS so that you can get sort of contact
content specific subscriptions only gave
me an SMS where the text is prefixed in
a certain way we're actually we've been
running our pc / SMS using this which is
a bit perverse perhaps but it does work
we have a net link
the library so netlink I don't know how
many of you know that but that's
basically the subsystem that keeps track
of the different communication protocols
that you have in Linux so this will
notify you when for example the Wi-Fi
comes online PPP and SMS data
multiplexing that XO port which is the
proxy application that connects to our
server a fairly nice and pretty speedy
gpio library for example if you want to
this is sort of low-level communication
you want to if you want to control
diodes and stuff like that or pretty
much any types of physical interfaces
you can do that there an input device
management library a GPS manager so that
you can collect GPS data and also a
database management system this is the
same database management system that we
use on the server and the what we feel
is fairly nice with it is that it
handles tree structure data so if you
want to deal with and traverse
configuration data this is a very handy
way of doing it it also has support for
the young the queuing and dispatch
needed for X support so it's the same
thing there if you're on the device ID
and you want to issue an RPC to the
server and you don't have coverage it
will be queued by X support and
dispatched once you're online so some of
the things we're working on EPX is
actually a frame buffer graphics library
with the support for 3d and animations
to make nice touch screen graphics on
your device
also working on the sort of
prioritization component that that will
be rate sensitive and try to make sure
to always use the the most efficient and
most economical the connection if there
are more to choose from and also make
sure that you don't send stuff that
would be too expensive or unnecessary if
you happen to be on an expensive link
and also a configuration manager a
little bit more extended than we have
today and a package manager we've gone
through a number of iterations here it's
it would have been nice to just pick one
of the ones out there but I think we
realized that we're going to have to
support a number of different package
managers and then provide an abstraction
on top that works with our system and
also support for chunked file transfer
between server and client so for example
if you want to send the big firmware
update and you lose coverage in the
middle you want to be able to pick up
where you left off I'll show you some
more code examples this is sending an
SMS you basically just provide the the
number and the and the text fairly
simple receiving the SMS you can
subscribe to a certain number and then
this flush this is just because we're in
the Erlang shell and this is the way to
tell the the Erlang shell to present the
messages that have come into the the
shell processes mailbox so now it's
actually the shell that's subscribing to
these and you get a fairly detailed
message now you would use the record
syntax in Erlang to to select data from
this but it does provide you a lot of
with a lot of meta data
so here's an example of one slide
version of how you could do a remote
unlock of a car door for example and
this is actually all the code so here's
the start function you start the UART
you start the SMS subsystem you start
the PPP manager in the can router and
then you just spawn a process that
subscribes to SMS messages and you're in
the loop here you receive an SMS a bit
simplistic but this is a slide where
although working slide where an unlocked
request you compose a can frame this was
for a little demo campus vehicle that
our partners had built you composed the
can frame that matches whatever unlocks
the car this is not standardized so it
would be specific to your certain device
and you send that message and supposedly
the car will and car door will unlock so
device programming nowadays can be
pretty high level and actually pretty
comfortable and you can do some pretty
awesome stuff in just a few days and
with fairly small amount of code so and
this is sort of the the altruistic part
we feel that if we want to do this there
is sort of the boring side of device
management where you try to go for those
who have a lot of money we want to go
for the people who don't have any money
which seems like a lousy business plan
but it's more fun actually try to
provide something to the community and
the open-source users so that there is
sort of an entrepreneur packer friendly
way to get into connected devices and
and do rapid prototyping end-to-end that
was pretty much it do you have any
questions yes where did you get the comm
matrix for your caustic from came stack
from the for the which one I'm asking
your iPhone the so the actual
specification for that came from from a
vendor obviously so we had to cooperate
with them so they told us basically what
the can frames would look like and we
just formatted them so like I said there
is no standard for that so what what we
provide is is a library to to be
flexible about what how to do this we
also have full can open support and can
open is a fairly ambitious framework for
so industrial can applications question
is how many are actually using that in
practice I don't really know but there
is a lot of hype about can open and so
if you need can open we do have can open
support security so on the JSON RPC side
it's it's HTTPS we try to use best
practices for password handling and
things like that we do support various
authentication methods basically any
anyone's that the the yours web server
supports which is just about all the
standard authentication methods on the
server to device side we use Burt RPC
over SSL the for example the car sharing
company they have their own secure
protocol which they take responsibility
for and they have designed and we just
provide the plug-in and the the system
on the server side is sandboxed when you
get your your account you can create
users and per user you can specify which
resources they have access to so it's
essentially a role based access control
protocol where you you can define this
or rather it's it's fairly statically
defined right now but it's going to be
become more flexible like all these
things it's not so hard to implement its
a user interface issue its that's the
tricky part making it user-friendly is
harder than actually making it work so
it works it's not necessarily user
friendly but it works so in that
particular case we actually did
introduce optional semantics for whether
you want to do store and forward or not
so the default was to have store and
forward but obviously when you do the
the typical maintenance commands they're
not queued in the server because they're
actually handled directly by the server
and so we do have a mode where if the
device is online we don't go through the
persistent Q we just dispatch it
directly so in that case what we do is
dispatch it directly there is no point
in storing it and then serving the
requests that week later so and that's
actually optional per request or per the
specification however you want to do it
okay then I thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>