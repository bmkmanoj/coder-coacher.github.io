<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • ECMAScript 6 &amp; Web Components • Brian LeRoux | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • ECMAScript 6 &amp; Web Components • Brian LeRoux - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • ECMAScript 6 &amp; Web Components • Brian LeRoux</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2w4sRkTnhPM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm gonna talk to you guys about web
components and a little bit about es6
the next version of JavaScript and to do
that I'm gonna go a little bit backwards
in time to start and go through how we
arrived at web components then I'm gonna
talk about web components themselves and
then I'm gonna go through a little bit
of the es6 goodness that we're starting
to see pop up in javascript talks she's
guys since you guys building apps of
javascript today and how many people
here are using like Babel or tracer to
transpile from es6 okay like three
people and I'm one of them that's cool
yes six is fun so we'll check it out I'm
gonna go through the sort of the
beginning of time here and we'll look at
some of the early JavaScript frameworks
and going to put scare quotes around
that because I don't really think these
things count as frameworks I'm more like
libraries and the big reason that these
things kind of came about is because the
browser used to be really bad the
various browsers had a lot of
inconsistencies especially in the Dom
this is one of the predicates for html5
where they standardized all the bugs in
the Dom so that everyone had the same
bugs and I'm not kidding that's exactly
what happened so around 2006 this
library called prototype came out and
had no Doc's whatsoever and everybody
kind of just got up to speed with it by
reading the source code mostly painted
over those differences in Dom
implementations across the browsers it
also kind of made life a little bit
easier for working with remoting and the
term Ajax got coined it used to be all
caps Ajax but that became uncool to do
so I'm not doing any more if we look at
prototypes API you can see that it's
it's pretty pretty simple stuff we
grabbed a div element of the dom or we
created a div element in the dom and
then we extend it and this little act of
extending the development actually made
prototype really unpopular you were you
were messing with built-in objects and
you could change the behavior or the
expected behavior of a built-in this is
the venerable Ajax that kicked off the
browser becoming an application thing
you can see it's pretty verbose
it's interesting that we've sort of
moved away from this but the
asynchronous nature where we pass the
success and a failure callback is is
pretty commonly seen today prototype was
really good at working with the dong
that painted over the differences in
adding and removing elements it paints
over the differences in eventing but it
didn't do anything for effects and
Thomas Fuchs who's one of my favorite
JavaScript developers in the world who
rides amazing code it's totally worth
reading even today created an extremely
hard to spell and find library called
script oculus and it was back when it
was like popular to do you know dot us
so it was like script dot C ul or I
can't remember it it doesn't matter
because you don't need it today
effectively it would use timeouts and
absolute positioning to move elements
and you'd have beautiful code like this
where we would inline on click handlers
to move stuff around which interestingly
react is bringing back then the big boy
came along jQuery and this sort of
changed the entire world
jQuery is big win I think truly was that
it gave developers a really intuitive
API to work with it was very simple for
anybody to pick it up and start running
with it and building applications in the
browser that appeared to be fairly
responsive it definitely dominated I
think it's still in over 90% of the top
100 websites something like that and
it's around even today there's some
times that you'll see on the internet
about once a year people say you don't
need jQuery anymore and I think they're
probably right but jQuery does paint
over a lot of browser differences
especially if you have to go back in
time to browsers like IE 8 so it's still
a big deal one of the more interesting
things about jQuery is that very early
on a built in an extension model where
it would map the prototype of the jQuery
object to a name function and so instead
of walking over the prototype you were
walking over this sort of built-in thing
called function this huge ecosystem of
plugins erupted and even today and I
think there's a lesson in there for
developers about building pluggable
libraries and so you've probably all
seen code like this you know this is
classic jQuery except for usually it
turns into this huge pyramid of code
over time and jQuery can I took a lot of
the ideas that we saw in libraries like
prototype for doing things like Ajax but
made things a little nicer a little
cleaner syntax jQuery also baked in
animation so you didn't need to load a
separate library to do that and that was
you know probably something people
wanted and then around the same time
another library came around called
mootools
anybody here build anything of mootools
a few people cool
yeah mootools was pretty sweet actually
I liked it a lot
very similar API to the other guys very
similar kind of semantics where you're
passing callbacks into like these
constructor objects mootools was the
first one that kind of introduced a
class system and a class-based hierarchy
the code for this was I felt really
beautiful and created kind of nice
components but the internet voted and it
decided that it like jQuery better I'm
gonna mention Yui because Yui actually
was really popular for a flash in the
pan and people were building a lot of
stuff with it
Yui a couple years ago was completely
deprecated and walked away from the code
the code still there it's just not being
maintained in any way and I think this
is an interesting thing to note for
yourself from a risk profile when you're
evaluating technologies if there's a
single vendor behind that technology it
might have some risk in the future when
the corporation decides it doesn't want
to fund it anymore
Yui was also pretty verbose and Java
like and so they later changed things to
look a bit more like jQuery Douglas
Crockford was a big part of how this
library kind of became what it was so it
was very idiomatic JavaScript another
library and it's still kicking today and
it's called dojo and it does all this
stuff - in fact dojo likes to brag how
it already did it before everybody else
and it really really quite literally did
dojo has a big community behind it has a
lot of people that work on it and
there's a ton of enterprise applications
that are built with it still to this day
so it still remains pretty important a
lot of the concepts that we're now
seeing kind of roll into the broader
mainstream er were probably first
prototype tin dojo including things like
asynchronous module design like we see
with this require function problem is
all these things kind of did the same
thing and it also had all this
problems they-they-they they built on
top of the fact that the browser's kind
of sucked
now the browsers don't really suck so
maybe we don't need them animation with
CSS and being declarative is kind of
like a thing you want to do now you
don't want to you set timeouts this
mobile thing appears to be happening and
so we want to have the smallest
footprint of code possible so that you
get the best execution time all of these
things had a concept of a module or
closure or a module pattern but none of
them out who did it the same way and so
they all had their own Island ecosystems
whether you couldn't interoperate
everybody was recreating the data grid
like a million times
and this actually still persists to this
very day I guess one of the other things
that kind of became tough was iterative
apply and chaining like we see in jQuery
can be really tough to test the big
problem really is that these things were
really quite bloated depending on what
you were doing and had a lot of tightly
coupled code it would be at least two to
three hundred kilobytes before you could
get hello world on the screen and that's
that's a lot of that's a lot of code to
do not much
another issue is most of these things
poke at the Dom and every time you
interact with the Dom you force a
repaint and it can be quite slow
somewhere around after the iPhone was
released we realized that we would
probably need to be building more
performant applications now that people
were accessing these apps with low
powered phones and so micro libraries
kind of came around very briefly I
worked on one called xgy back in 2008 I
like to think that maybe we seeded the
term micro library but I doubt we did we
just said micro tiny and actually why I
had like a very jQuery like syntax
except for it targeted only mobile
browsers and I think we got it down to
something ridiculous like four or five K
it was really tiny lawnchair was another
project I work on I had the concept of
models it's actually still kind of
truckin today people do use it very
simple idea where you would just get you
know data and you would set it using
either local storage or web SQL or other
things that can store stuff on the in
the browser like window dot name Thomas
Fuchs that guy from script Acula saw xui
and he thought that's pretty sweet I'm
gonna do
the exact same thing but I'm gonna clone
the jQuery UI or API and so he took the
the spirit of xui but he applied it
directly to jquery's api creating kind
of a work alike Zepto is really nice and
it's actually still really popular in a
lot of mobile applications and I totally
recommend reading the source code if
you're into doing that sort of thing
this code would look just the same as
jQuery but there'd be far less code for
it it's also worth noting today jQuery
is really well maintained its really
battle-tested and they have slimmed it
down substantially so maybe you don't
need it maybe you do who knows either
way this is just redoing the same thing
over and over again and we maybe as
collective consciousness realize that if
we keep doing the same thing over and
over again we're probably going to keep
having the same problems over and over
again and then the next generation of
frameworks came along and so gonna
quickly run through these guys backbone
was easily the first of its kind and I
think it disrupted things people realize
that hey maybe we should separate our
concerns and start treating our clients
a lot more like we'd architect our
servers we'd separate our concerns
around views and models and even routing
backbone is really well written code and
it's really tiny and as a JavaScript
engineer it's a joy to read so even I
know I recommend doing this all the time
but you learned so much by reading other
people's code and I don't know if Jeremy
oshkosh was doing meth or what it was
but he wrote a lot of code and it's more
small period of time and backbone was
one of those things also CoffeeScript
yes I did just sneak in a joke about him
doing math so backbone grew quite large
I think today a lot of people are sort
of moving over to this thing called
ampersand I should say j/s whatever and
this is the the thing I want you to like
internalize or check out so you'll
notice here we got a view and a view
really is just a tag ultimately
and that tag you know we're gonna give
it some class names and we're gonna bind
some events to it if I had an open
method on this thing when I clicked on
the icon thing it would fire that event
you get the idea this is really similar
to how web components look today from
100 feet
Google came up with this thing called
angular is anyone building angular apps
here yeah that doesn't surprise me quite
a few of you are anybody here her too
ionic yeah I onyx totally sweet I might
be biased so angular took a lot of the
nomenclature of server-side Enterprise
development and then reassigned it into
the client in different ways it's sort
of weird it has these these things that
it calls like controllers or models or
whatever and it does not quite what you
think it will
you can't build an angular app without
buying into this whole set of
nomenclature and ways of working you're
not going to just like take part of your
app and make it angular if you're going
angular you're going all the way on
angular one nice piece about angular or
one of my favorite pieces is Karma's
test Runner fantastic software really
good for doing development it's like
this live reload thing that can test in
multiple browsers simultaneously ionic I
mentioned it's rad it's a mobile library
for building native apps using HTML CSS
and JavaScript based on Cordova they
basically took Cordova and then they
plop the UI on top with with angular and
it's it's quite good the big deal about
angular for me though is angular
directives and if you don't know angular
a directive is a custom tag of course
because that makes sense
not really but whatever so this hello
person tag is defined in this directive
right here in order to create a
directive though I have to have a module
and in order to actually make it bind to
some data I have to have a controller so
that's that coupling I was talking about
where you get this sort of like nested
dolls situation going on or you're
separating your concerns maybe a little
too much but regardless custom tags
interesting ember is another one is
anybody here building member apps okay
you you are cool it's it's making
headway ember is strongly inspired by
rails whether this is good or bad I
don't know but if you're used to using
rails then you're going to be very
comfortable in the Ember ecosystem
super well-written Docs super great
governance and onboarding for the
community I really really respect how
they handle that it's also kind of big
and it's kind of slow it came from a
thing called sprout core and there's a
lot of legacy code in it it's really not
appropriate for mobile part of my job is
to test these things on phones and
Amber's not quite there yet but it's
getting better all the time it's got a
new rendering engine called glimmer and
they're doing a thing called fastboot
where you can pre render your your app
to a string and load it load it faster
interestingly it also has components and
so you're starting to see a theme here
and ember components are actually script
tags embedded in your application I'm
not really sure how that weapon perhaps
packing their docks to web components
but this is what a what an ember
component would be very much like
angular you end it so this is my my
component I guess or this is me invoking
my component this is my component
definition and this is me creating an
app that loads it and so that's kind of
like angular where you get this a little
bit of coupling between the different
layers but pretty cool works well
anybody here building react applications
oh like two of us three right on okay so
react has been getting a lot of
attention because it instead of copying
server-side development paradigms and
just like wholesale bringing them onto
the client the Facebook team decided to
like actually address real problems that
they were having and the big real
problem they were having is that the Dom
was super slow it came up with a whole
bunch of new concepts that the other
frameworks are quickly copying now key
one is the virtual Dom and so instead of
touching the DOM and playing with it and
modifying it all the time that'll batch
requests using requestanimationframe and
it'll do dipping dynamically for you so
you only update what you need when you
want to do it there's two promising
early mobile libraries touchstone
jeaious andrey app and so if you're
looking for like an equivalent to ionic
in the react world those are worth
checking out I've seen apps built with
it that you seriously no can't tell
the difference between a native
application really well done one of the
key things about react to is it's it's a
functional programming style and so it
explicitly avoids mutating
which makes it faster but it also makes
it a lot easier to reason about and
again custom elements so one thing that
people hate hate hate is that in react
you you define JSX files which allow you
to inline HTML and not a lot of people
like this it's very similar to an early
proposal in JavaScript called a 4x we
would be able to embed XML and your
JavaScript not a very popular thing but
you end up with these neat components
and this neat component lifecycle that
you can just render into a page on any
element that you want to probably the
simplest of them all but it also doesn't
include a lot of the plumbing and so if
you need to like compose your
application have things like routes and
models and the rest of it that's up for
you to solve the Facebook team has a
concept around this called flux and if
you want to talk about later we can I've
got I have opinions polymers from Google
this great Eric Schmidt quote from a
long time ago where they were like wait
a second you got Chrome OS and you got
Android what's going on why do you guys
have two operating systems and Eric
Schmidt said well a lot of companies
would like to have one nice operating
system very humble Eric Schmidt anyways
I guess they feel the same way about
JavaScript so they've got two frameworks
polymer is a forward-looking framework
it's ideas to battle test ins in kind of
like progress specs around web
components they're not really they're
saying now you can use this and people
do use it in anger for production
applications the current Google i/o app
is actually a polymer application it's
kind of big and it's kind of slow legit
once it loads it's good
polymer really took this custom tags
thing all the way to they it's custom
tags all the way down so like everything
you do is a custom tag maybe this is
good maybe it's bad I don't know and so
this is a custom element here called
hello world element and I'm defining it
literally almost entirely declaratively
which is kind of cool kind of
interesting so this is sort of the state
of the art these are the the various
JavaScript frameworks that are probably
the most popular or getting the most
attention
and there's still issues so the module
systems generally are incompatible
there's not totally the case transpilers
help us get through this but it's it's
either common j/s or AMD or good luck
with that and they all have kind of
different concepts around what
networking is gonna look like or how
routing is done or how it does data
synchronization but one thing these guys
all have in common is a custom elements
implementation so this is the part where
I'm gonna go through web components
themselves Douglas Crockford is really
famous for having a book called
JavaScript the good parts and everybody
likes to joke and put it beside the the
JavaScript definitive guide javascript
definitive guides like this big and web
cam you know javascript the good parts
is like that big and you can read it in
like 10 minutes
web components I think is kind of
similar so web components is this
blanket specific set of specifications
for four different things about the
template tag HTML importing the shadow
Dom which sounds way cooler than it is
custom elements so let's go through
these you notice the number and this is
really common in a lot of JavaScript
applications to fake out the the browser
and to put inert templates inside of a
script tag and we'll call it something
else
the problem is script tags block
execution and so if you have a whole
bunch of these things your page can get
quite janky especially if you're like
doing time any kind of scrolling and
your dynamically inserting these things
famously Facebook used to do this for
it's like button and so for every like
button on the page as you scrolled it
would get this like stutter effect is
the thing scrolled the template tag will
fix this problem it'll give you an inert
spot to put strings kind of nice
you can put anything you want in there
and you can call it like a regular Dom
element and do things with it I don't
really care I don't I don't embed script
tags I would compile these things down
to a single JavaScript source file you
shouldn't be embedding script tags so
it's like you're you're almost incurred
in my view encouraging worst behavior
but that's fine
so web components template tag it might
help who cares HTML imports is an
interesting idea this is HTML that can
load HTML
maybe he's a good idea maybe isn't a
good idea it has a lot of problems first
of all it's slow you could imagine if
you had a complex hierarchy of
components it could be calling all cut
making all kinds of Network calls that
are blocking each other resolution of
those network calls one might fail and
then cause the rest of the application
and all it load HTTP two should solve a
lot of those concerns but you know it's
not fully deployed yet Mozilla has put
out a statement that they don't want to
add HTML imports Google says they want
to apple says they think it's a good
idea but they want to do it differently
and Microsoft's just staring at everyone
trying to not rock the boat too much or
cool again so I don't know like HTML
imports might happen it might not it's
it's really unclear currently from a
specification standpoint the shadow Dom
which sounds hella cool it the idea is
that it hides the implementation and so
like based basic any kind of built-in
component right now you don't have to
like drill in and see what's going on
and a good example of this would be like
the video player in your browser you
don't see like individual elements
unless you want to the shadow Dom would
give us this capability possibly in the
browser
it's it's in a weird state it looked
like no one was going to implement it
and then suddenly in the last couple
weeks
a lot of the browser implementers have
come to the conclusion that maybe having
totally global CSS is a bad thing after
all and that we might get some level of
encapsulation for styling but I don't
know when that's going to land or how
it's going to land there's a lot of
complexity associated with it so that's
kind of a bummer but then we get to
custom elements and this is a good part
this is the interesting part and we I
think we've got good validation at this
point that this is probably an okay idea
we know that all the major frameworks
implement the concept in some fashion
one of the problems with the custom
elements spec is that it's a single
blocking call and so if you have a whole
bunch of these things in theory could be
a little bit slow it supports the idea
of extending built-ins and so you can
extend already existing HTML elements
and win all
they're like accessibility features
should you so want those and then
otherwise it's just a regular Dom
element so this is pretty exciting
here's the most simple syntax possible
that I could cook up this is the
blocking call that registers the element
to the page and so we're saying alright
I'm gonna create a thing called a hello
world element another thing to note and
I don't know if it's in spec or out of
spec but custom elements are defined in
the Dom parser by having dashes in them
just sort of freaky I don't know why
initially they were talking about doing
a leading X Dash but then people felt
that smelled really bad
so just dashes in them and then here I
just append it into the Dom and it
creates this you know tag called hello -
world if we want to take this idea a
little further and I think this is
probably the most popular way in the
more purist web thinking is to extend
built-in elements and the reason you'd
want to extend a built-in element is
that you'd get all of the accessibility
features of the elements and so if I
wanted to create a button instead of
creating yet another span element that
looks like a button maybe I extend
button and this is how you do that the
syntax is pretty obtuse there's a lot of
stuff going on here this could
definitely be cleaned up a lot I
particularly don't enjoy the fact that
I'm defining the tag name and then I'm
saying I'm extending something and I'm
extending it here it's like I don't know
I feel about that and then this part is
very contentious right now with folks at
the w3c in particular Apple really
doesn't like it and I kind of don't
blame them because you could imagine a
world where we'd have something like you
know input type equals you know submit
is submit thing role equals button it's
like I have role I have you know is I
have type I mean that's that's not very
easy to follow my argument against that
type of thinking though is that if you
think that the web has nice symmetry and
beautiful API is you haven't been
painted
henshin anyways so it we should
just do it so if we're gonna have custom
elements and we're gonna have to have a
lifecycle for these things and this is
where stuff starts to get pretty
interesting I think and so very similar
in fact to how we see all of the user
land frameworks approaching things we've
got these lifecycle callbacks and so
when I create a new element I can set
the innerhtml this is also contentious
Apple thinks it's it's redundant to add
callback at the end of everything and I
kind of agree it's sort of ugly once we
attach something to the Dom it'll fire
this callback we remove something from
the Dom and we want to do some cleanup
maybe we've got you know hanging event
handlers elsewhere in the in the
application we can we can hook into this
detach callback and then this allows us
to create all kinds of problems in our
code if we want to where we can watch on
attribute changes and we can
programmatically intercept them and add
different behaviors again we have a
blocking call down here for this supe
hello pretty verbose pretty stinky code
but very powerful so we can do this now
you know this isn't you know a fiction
this is stuff that we can do today both
Mozilla and Google agreed that it would
probably be better if there was only one
polyfill is the specs we're advancing
and so there's a polyfill out there
called web components Jas it has all of
these things baked into it we really
only care about document register
element and there's actually there's a
dude that works at Twitter his Twitter
handle is web reflections he's got a
fantastic library that just polyfills
register element if you're feeling like
the entire web components JSP feels too
big it's only a couple hundred K so it's
not too bad and ideally at some point
this thing is baked into some form of
module system so we're where we're at
today right now it's basically only the
Chrome's support this natively Firefox
is extremely likely ie like I said
they're kind of eyeballing the whole
thing and WebKit Safari Apple
effectively wants to do this but
just want to do it differently so let's
talk about es6 really fast is yeah I
asked you guys there's a few of us that
are programming in es6 oh I'll try and
explain this stuff so everybody always
says you know what's the next big thing
you know node came along and JavaScript
was a big deal all of a sudden and
there's got to be another thing to
satisfy my ad/hd
I don't think it's gonna be like go were
rust personally I think it's actually
gonna be JavaScript there's enough new
toys that it's an exciting language to
learn and to use again and it's a lot
prettier than it used to be so one of
the biggest feature to me is that we
actually get syntax for defining modules
finally kind of pythonic in a way and so
in this case I'm defining default
exports for my my person function here
and we can consume modules also looking
a little bit Python it where I can say
alright give me the the hi function from
this hello module and there you go
pretty neat this is beautiful if you've
ever worked with object literals now you
don't have to append
a function inside there you can just
give it a name and you're off to the
races so much cleaner this removes the
tonic code looks way better we have
classes just as Java gets lambdas
JavaScript gets classes so that's pretty
cool this works the way you would think
it would work you've got a constructor
function you've got inheritance
you can add static members pretty clean
finally JavaScript sorry
can you know you cannot do well it's
JavaScript you can you can create a
multiple inheritance nightmare if you
want to there's there's ways you can
either there's a thing called object
assign which would allow you to add as
many mix-ins as you want to get that
kind of behavior this is another
personal favorite of mine the fat arrow
function if you come from CoffeeScript
lend you you've probably seen the single
arrow so this is now finally in
JavaScript itself this lets us do a
shorthand for a function call so much
cleaner than
writing out an entire function in this
case I'm passing and you know each fruit
one at a time that I'm calling an
uppercase not really all that big of a
deal remember earlier how is hating on
the template tag this is kind of why in
es6 we get a concept called template
strings which allow us to have
multi-line strings and do string
interpolation like right here this is so
nice if you're if you have templates I
don't know why you wouldn't use this
personally it makes a lot more sense to
me to embed this type of thing in your
program there's a ton of other niceties
just a lot of sugar really there's
nothing super new in the functionality
of JavaScript you just have to write a
lot less of it which usually results in
better programs we can't do this
natively today you can do some of this
stuff natively today and I ojs the node
fork but for the most part if we're
gonna go back into browser lam we have
to transpile or compile it but the good
news is there's great tools for this
babel jeaious is probably the most
popular one right now but tracer from
Google also works well I like to do
babble with browserify and a thing
called babble fi which you know I like
how we've run out of names for things so
now just programmer talk is like total
nonsense I babble if I'd my code and
that actually meant something so I
personally like to publish modules in
NPM everybody has their own sort of
thing that's that's fine
I found MPM to be a little bit better I
don't want multiple package systems and
my production code base but you know
your mileage may vary one of the things
that we do very explicitly when we
publish a module is that we compile it
back to es5 we don't publish modules as
es6 source or CoffeeScript or typescript
or anything
if someone's consuming your module they
don't you don't want to also put the
burden on them to figure out how to
compile this thing back to es5 their
their build chain would turn into a
nightmare so if we pull all these
concepts together we can get a pretty
good look at how code might be written
in a few years here for the web so you
author your source code in es6
you compile it down into es5 and you
distribute it that way we can use
package.json to point to the dist folder
we can deploy this thing to get hub
pages and we can even use source maps to
have step debugging if we want to walk
through these components I created a
very trivial silly date element I
actually stole the idea from github who
uses custom elements themselves for the
date/time helper in in their UI and for
fun I did it using es6 syntax and so
here we are just extending the built-in
span element and when I'm creating as
soon as this thing is created we're
gonna just insert this text node inside
of it where we're gonna grab the date
that I have the source code for this
running I'll give you the links for it
so you can check it out
so there's obviously problems remain
this isn't like going to be the ultimate
solution but component izing is is
definitely a trend that we're seeing in
all the various JavaScript frameworks
and so it feels like this is the right
direction the collective has kind of
agreed that hey maybe encapsulating my
code might be a good idea web components
j/s is kind of big it's a little bit
strange it has to go backwards in time
and support browsers that are a little
more hostile so the source code for it's
a little weird it is worth checking out
none of this solves CSS so you know you
get to keep that problem which is kind
of unfortunate I think shadow DOM is
gonna help us a lot there but we're just
not there yet
if you're doing a lot of these register
elements it's conceivable that your app
could get quite slow because you're
blocking when you're doing this is a
synchronous call there's no other way to
really do it no one's figured out a way
to do it yet anyhow if you're rendering
the page and you've got these these
custom elements in it they're
effectively going to be treated just
like a span unless we can stop execution
register this thing with the parser and
then do the right thing when when we hit
it something else worth noting in react
really forces you from writing code that
could mutate state and have side-effects
which I really like and I think we could
learn a lot from in web component
and you know you've got all the rope to
hang yourself so if you mutate state you
know it's it's your problem to solve
Henrick Joburg Joburg god I can't
remember his last name right now I think
it's Joe Burke Joe tag anyways the guy
behind ampersand J s says that the
future is probably not going to be the
same as today and so your best bet is to
optimize for the future and I really
like that I think that's a nice way of
looking at things Andy Hunt from the
pragmatic programmers recently said you
know we should be thinking more about
disposable units of code instead of
reusable units of code and it's more
likely that if you're as your code base
goes on you're going to be rewriting
parts and encapsulating these bits so
that we can pull chunks out and change
them it just makes a whole lot of good
sense CSS is still a mess there's really
nothing to be said about it's it's not a
good idea we're combining so many
different concepts at the same time from
layout to aesthetic to reset at some
point this is going to have to be fixed
and encapsulating these bits would
really really help a lot it doesn't make
sense that if I'd have a tableau
implementation that it could override I
don't know my my side menu
implementation I think react is really
proven that a mutable state is a good
thing and the veto and the batching
concepts I should probably be brought
into your development methodology
whatever it might be and I think if we
could see it happening in a web
components land at some point if you
want to check out the source code for
this stuff and actually I'll jump over
there right now so you can oh god what
did I do
so here here's my web component and if I
inspect this element you can see date
today which is pretty cool
and if I take a look
Oh Firefox you failed me I was just
about to say Firefox developer editions
awesome and it is you can check out the
source code anyhow on my github at
github.com slash Brian the ruse last
date today eventually when it loads come
on there we go and so if we see the
source code it's like literally almost
literally what I had in that slide where
I'm defining a class and I'm registering
the element and I'm exporting it and I'm
using Babel if I to compile this down to
es5 code it's pretty clean I think this
is a nice way to work and I think that
we're starting to track onto like
building better apps by doing this sort
of thing and that's it that's all I got
for you guys but I think I have some
questions maybe</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>