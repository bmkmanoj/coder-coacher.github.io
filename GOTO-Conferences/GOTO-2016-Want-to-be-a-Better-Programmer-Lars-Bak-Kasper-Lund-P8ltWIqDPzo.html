<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Want to be a Better Programmer? • Lars Bak &amp; Kasper Lund | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Want to be a Better Programmer? • Lars Bak &amp; Kasper Lund - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Want to be a Better Programmer? • Lars Bak &amp; Kasper Lund</b></h2><h5 class="post__date">2016-09-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/P8ltWIqDPzo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right want to be a better programmer
isolate title first of all I want to
introduce Casper my colleague do you
want reduce me I can do that
this is Lars do you you've probably
heard all you need to know about him
already so let's stop right there too
much yeah
so before we start with us recap so most
of Dane said we've been doing virtual
machines high-performance virtual
machines for many many years I started
working on the beta programming language
30 years ago
you all know beta right power 5 3 3 5
pretty good but it's been fun
so the first 25 years were spent on
making them fast and small and dynamic
and that's the reason why you have I
guess some if I can rely on dynamic
class loading and poor morphing inline
caching and what-have-you the that's 5
years we worked on that and this talk
will be related to that mostly and but I
want to tell you about the threat
throughout the at least my career has
been to empower programmers so they can
do abstractions at no cost it's super
important that programmers when they
scaled applications are not forced to
flatten out remove functions and and
basically you turn the implementation
inside out to make it fast there's
always been important all these systems
we built that if you add abstractions we
will inline it and make it no cost I
work with Casper the last 16 years yeah
so that has been fun and so he's been
trained and it's probably better than me
now and well we got when we joined when
we joined Google nearly ten years ago we
started building the v8 engine I hope
you heard about JavaScript but when we
joined it was very well slow and I was
task was to make it much faster so we
came up with a way to make it
object-oriented and then we knew how to
make it fast so that's how we ate came
about and it turns out that wait at this
point is used for everything it's used
for nodejs even a camera's programming
environment is built on top of v8 which
is scary but true and we have a lot of
browsers that are also using technology
the best part about this system here was
it was open sourced so and competitors
browser competitors they had to at least
match the performance otherwise they
looked like they couldn't do JavaScript
so I think this friendly open
competition for JavaScript has created
the world we have today with browsers
that are across the board very fast and
I'm very pleased with that so one one
question you can ask yourself is that
did this performance improvement that we
delivered as a sort of a combined
ecosystem but then really make you all
better programmers I think there's a
good question to ask so I went searching
online for finding out how people use
JavaScript today and you find code like
this I don't you can read it from that
from the back I hope so and it's very
hard to tell what that does clearly
doesn't quite work there's a weird
assignment there we assign 0 to I inside
the loop and it's this is the kind of
code you still find around there's just
something rotten about that and it gets
it gets worse right you can find so much
extremely poor code in JavaScript out
there and then you find things like
people want to figure out if something
is a function they'll use like two
string conversions slicing and dicing
and trying to figure out if m if this is
a string so I think you can ask yourself
like does performance in itself really
make you guys better programmers and I
think the answer is a resounding yes of
course it does clearly we did I think we
did it we made you all much better
not I there's there's something missing
here and and that's what we want to try
to dive into and in this this talk so
like we both live in brief performance
and it's a whole lot of fun to try to
make a code run fast but it's not
everything and so that's what we want to
try to cover I don't think the the fact
that we made javis was faster on the on
the web was there I wasted effort at all
and like it does enable a lot of
innovation we've seen very very cool
things come out of that thing
richer frameworks better abstractions
like Lara for telling about and much
much louder applications are now running
online and on top of a infrastructure
like nodejs it is though true that
developers still such sort of suffering
from somewhat puzzling semantics and and
very hard to identify errors in their
code bases and still almost like no
declarative syntax anywhere it's very
hard to find dependencies it's a very
loose relaxed keep on truckin kind of a
system that we have errors are sort of
consumed by the system absorbed even and
people and the system a sort of
implicitly
converts values in weird ways all the
time as part of the core program model
so not a wasted effort but there is
something missing here all right so um
it's great to have a festive event in
people start making more and more source
code and they figure out is very hard to
manage it so what do they do what they
always do they come up with a
preprocessor or compilers that will take
another source language and compile it
to JavaScript and I think most big
companies are good guilty in creating
one of these transpilers and you can see
a list here you have typescript
CoffeeScript silence scale today's hacks
Elm a closure script width
closure compiler and even dot now
translate source of JavaScript and it's
interesting and the whole thing stems
from that it's really hard to manage a
large code base in JavaScript
so the reason why we're here is to tell
you that we might not be able to make
you smarter but we can help building
some systems that will make you more
productive as a programmer and what we
believe is that simplicity simplicity
and consistency in the programming
language and the frameworks are using
will help you make you a better
programmer so what we'll cover in this
talk here we'll talk about simplicity of
consistency with a programming language
talk about some issues with JavaScript
and Java and C++ compared to that we
actually learn from the past in
designing the dart programming language
I think and the second one will show you
an example of a framework that actually
tries to also be simple and consistent
yeah why don't we start with the
language part and I think this is the
right quote to start with and clearly
the right guy to deliver it and
shouldn't listen to us you should listen
to Bruce Lee instead but simple language
semantics is really important to make
people productive and make people write
better and cleaner code and I don't know
how many of you are actually familiar
with that and raise your hands
fairly few oops
was that a comment on that no I'll walk
you through what what what what dart is
it's it's actually fairly simple and
it's an unsurprising object-oriented
language it's based on classes it does
come with support for interface and make
sense it's very familiar syntax with
curly braces and everything you would
expect from a sort of a language derived
from the C school of thought and it's a
kept simple through a single threaded
model with the isolator or actor based
concurrency and it comes with optional
static types here there are quite a
number of differences and so on this
slide from from JavaScript but I'm just
curious how many people here know
JavaScript hmm I thought so how many
know it really well
there are people that erase the hands I
like that so I'm gonna need a volunteer
oh just back up a little bit can you go
back to the previous slide yeah
one thing we forgot to tell you guys is
that if you don't translate that to
JavaScript but run around there it's
native what a machine it's actually
twice as fast as JavaScript so if you
want speed it's an option Sher Khan I'm
still gonna need a volunteer so in
JavaScript you can do interesting things
with fairly simple operators like the
Equality operator and I just need
someone to tell me what will this
evaluate to in JavaScript any volunteers
it should be C no nothing I'll pick you
then okay yeah I recently read the egg
musket 262 standard version 5.1 and if
you go to paragraph nine eleven eleven
nine three you will find the abstract
equality comparison algorithm and there
you will find a very complicated way of
computing this it turns out what happens
is first expression
you're comparing 2.0 to the string to
it'll try to convert the right hand side
to a number so the string will be
converted into the number two and the
first expression will return true then
we have true equals new boolean true now
here's the hint in JavaScript there's
values and objects two different things
so true is not the same as new boolean
of true but if you look at this
paragraph I talked about before you'll
figure out that you'll then have to
convert the boolean to true boolean true
to a primitive type this is true so we
have true equals true it rents returns
to true and then you have true equals
that string one that's simple because in
the first few comparison we can build
the right hand side to something else
but that's not true
when you have true equals a string then
you first convert
the left-hand-side true and they'll be
converted to a number which is one and
then you have a number one compared to
the string 1 and again you then convert
that right hand side the string 1 to 1
and then 1 equals 1 is true and the
result is true you all knew that right
yeah yeah good it's interesting at least
I feel like this is more than enough
some implicit conversions happening
behind the scenes to make my head
explode the thing is this actually
happens in real code not intentionally
you probably will not write expressions
like this very often and but these kind
of conversions happening behind the
scenes just because you're unaware of
how things work out it's kind of painful
to say the least I think so Todd is an
attempt to try to fix some of these
things it's an open standard and and has
been since 2013 we've gone through a
number of revisions and we'll walk you
through a few of the things we've added
over the years and but it is it's also a
governed by the the economic committee
that Albert also sort of oversees the
the the evolution of of eco script maybe
you'll talk about something else Lars oh
yeah so we have a small section here
about constructors we all use
constructors great to create new
instances of classes and most people
believe semantics is clear for different
programming languages so I took the
liberty of trying a different a few
different language see what actually
happens so let's say let's go at it so I
decided to look at three different
languages C++ Java and that and see how
constructors works I'm only looking at a
particular aspect of it but the
situation is very simple we have two
classes a Class A and a Class B B is a
subclass of a and they both have virtual
methods or both called F
and constructors of a we'll call if and
constructors of B will call f2 and then
we will see what happens when you
executed these different languages I did
not include JavaScript and small talk
because they don't really have
constructors you have to do everything
by hand and that's even worse so let's
go at it yeah
the Constructors in C++ I hope you can
read the cross bus it's very simple you
have an include you have a Class A and a
Class B and then the a constructor calls
if and if it's a virtual function that
prints out a and B and also has
constructor calls F and a function f
will write that prints RB and you have
the main function and you create an
instance of B what happens it will print
out a and B and you'll wonder why since
it just have one instance and why is it
not a B in the two cases it is because
in C++ they have chosen that when you
evaluate the constructor of a you have
not initialized the B portion so you can
only see what an a instance could see
but this actually might be confusing to
two people and it surprises the most
when they try it out in Java it sort of
solved it you have a Class A again it's
exactly the same scenario except that
you have to wrap the the main in there
in the class which is pretty annoying
and you say new B and it will then
execute the construct of B first by
executing the body of the constructor of
a and then afterwards the body of
Catoctin P and you are lucky in this
case it's the same word to the calling
it prints out b and b this is what you
expect and you are sort of happy sort of
let's see how we can expand this example
just a little bit
in red you'd see I added a final string
X and its values will be said to be the
string this is cool final means that
that field will only have one value ever
and I really mean ever and we run the
program again and as you expect it you
get B &amp;amp; B out so this is behaving like
expected so to pay careful attention to
the red line now I'm going to make a
small change to the program I will say
string dot trim I don't think is going
to matter much in terms of functionality
since there's no spaces around the B but
what does it print out and you take us
it'll print out the same right
KeSPA well I mean it really should right
I mean it's a final variable you would
expect that to always have one value and
this should be B so yes it should be B
but I know it's not if it's null it
prints null of course and you take us
why is it not oh of course the reason
why this is printing out and all is that
in the previous one where the right hand
side is a constant that the ever C
compiler will inline it so this is
actually another will field and then it
behaves like expected if it's a real
field like in this case and the right
hand side is is computed when you
initialize the B portion you will not
have initialized to be portion when
invoking the if method in the
constructor of a and that surprises
people and this is real problem in my
mind because you have a final field and
you get two different values
out of it first null and then the real
string and and this also happens in in
real code and it's the kind of issue
that's really annoying to track down
like actually having final fields and
being able to observe that their values
change over time is not a pretty thing
though anyways I give you these examples
to show that when we designed the dart
programming language we we try to learn
from the past so when you run the same
code in Dart
please note that the code and that is
shorter than in any of the other
programs but you get B &amp;amp; B and any
combination will yield that same result
and the reason for that is we decided to
have clean constructive semantics we
decided to split up the constructor
evaluation in two parts first one is to
initialize all the fields and the second
pass just evaluate the body of the
Constructors this might seem like a
simple thing but you get the consistency
we're looking for you are not surprised
about what the program length is doing
and when you debug you know exactly what
to expect basically so this is one of
the issues we talk about when when going
for a cleaner semantics that will make
you a better programmer finally we also
this is just like an add-on in addition
to the constructor semantics explained
before we can have a factory
constructors so unlike in Java where you
your self bound to returning the
instance the system creates for you you
can cheat in them in dart and in this
example here we have a simple class and
the constructor will take a string and a
turn a simple but these symbols are
canonicalize so sometimes it will return
a a symbol that has been traded a while
back so this is a complete
implementation of a simple table in dart
this is
and not that complicated and it shows
that the you'll get and you look I to
new symbols and it will get exactly the
same if the string is equals that's it
so let's go to boilerplate code in
programming languages you actually want
to go to the yeah at least an attempt to
to go for like the lack of boilerplate I
think everybody who writes code for a
living and has to be willing to write a
certain amount of boilerplate but it's
very painful for all of us one thing is
writing it the other thing is actually
reading it as well some people argue
that you just need a good tooling
experience in your IDE that would just
fill out this stuff for you but it's
those common comes with a textbook you
have to pay for reading it and
understanding it over and over and over
again we really need to try to avoid
some of that so I'm gonna do some
comparisons between Dada and Java and
like the two languages are fairly alike
in many ways and we just try to make
things more concise and better is of
capturing the intent of what you want to
do instead of being sort of garbled up
in too much ceremony so here's an
example of this in that you have the
ability to write very simple
constructors but just feed values and
that passes the constructor into fields
and you can of course do the same thing
in Java it just takes more writing that
is not the only language in the world to
have these kind of features I think it's
really important that you you aim to
make simple constructors really easy to
express and we found actually that by
allowing people to where to have this
shorthand notation for writing these
kind of constructors people tend to
prefer writing really simple
constructors so that means that people
really want to have a constructors
without complicated method bodies or a
constructor bodies and actually comes
with a number of positive side effects
for the understandability of their of
their code like having less side effects
as part of construct instances of
classes is a very good thing and so by
making this easy to write your encourage
it and people and will definitely use it
so I hope you can all read the Java code
as well it's nothing fancy nothing
interesting about that except that like
actually having public fields in Java is
sort of frowned upon so if you want to
fix this and
is more real you probably have to go
through like something like this right
adding get X and get Y feel some
churning that the double fields X&amp;amp;Y into
private instance fields and yes it's
sort of intention to overflow here it's
it grows right it gets bigger and bigger
and bigger even for simple things like
this you have to write well this is a
fairly large fund right but it adds up
and you don't have to do that in dart
like the X and the y are properties and
you can access them and you can of
course also overwrite them and subclass
and provide an implementation often that
is based on something that executes real
code so this is actually asking an
important thing that even the simple
case looks better and dot but once you
start using it for real having less
boilerplate makes it much more clean
clear what you're trying to express here
another I think important point is that
can just interrupt this of course so you
all know these programming environments
whatever and they are so helpful because
if you start writing writing your
constructor and constructor parameters
take final fields it will expand it will
add half a piece of code to to your
class and you don't have to do anything
and I understand what that why they're
doing it is to help you but at the end
of the day right you you end up getting
generated boilerplate code and that's
just hard to change and and refactor
afterwards so the less code you have any
program the better this in my mind
within reason I they're a complicated
languages where you can express just
about anything in one line and maybe not
the array me for one other important
thing is that and often when you write
Java code you find yourself sort of
being forced to prepare for the
possibility of adding implementations at
some point in the future so you you have
to basically not write a just a class
definition you have to like it's good
it's good form at least to write an
interface a separate thing and then go
ahead and implement that interface with
a class a lot of people either forget it
or just dislike it and get this sort of
duplication of the interfaces
even for the simple cases where
may not need it in the future but you
have to prepare for it and in fact we
decided that actually being able to
treat a class as an interface in a sense
at least allowing it to have an implied
interface that you can go ahead and
implement is very useful that means that
in that you don't have to worry about
splitting the the point into a Cartesian
point and a point interface from the
get-go
you can go ahead and add a separate
class over a point in this case it just
implements the interface of a concrete
class point and here it also shows how
you can then go ahead and and instead of
materializing the X and the y and
properties as fields you can go ahead
and compute them instead and you still
implement the same interface so in a
sense this just makes it easier for a
for a programmer to avoid getting into
this problem where they have to write
too much stuff write duplicate
interfaces and end and then classes just
to prepare for what might change in the
future does it make sense you probably
all been forced in a code review to add
more interface to your to your stuff and
for simple things it doesn't really help
the readability and again this is a
little bit bigger on the other side and
then if I were to type out all of the
stuff you would find that they would not
be able to read it because the font
slash will have to be so small there are
other things that are livid more sort of
technical in its nature that it's just a
little bit better in Dart
and so on the right hand side I know how
many of you are familiar with sort of
the idioms that are associated with
churning collection types into more
primitive array types in Java the one
problem that they have in Java is that
the actual a type of the of the elements
in a in a collection type like a set of
string it's not reified at runtime so
the system doesn't really know that you
have a set of strings it just knows it's
a set so it's system kind of really help
you when you want to extract a in this
case a primitive array of strings from a
set of strings you have to tell it by
passing in a that primitive array you
want to be filled in otherwise the types
don't really match up and you cannot get
the right runtime type out of the system
in that we've decided to to reify but
it's materialized the runtime type
information that you need to be able to
do this without requesting a user to
pass in
but of explicitly what he wants
everywhere here just let the set of
strings know that actually contains
strings and allow a method like to list
on that string to return the right kind
of list of strings it's not just a
random list and that really helps to in
in terms of making it much easy to
express these things without having to
write error-prone code that ends up
looking a little bit weird I mean I
think people coming to Java from from
different backgrounds would find this
this s2 array a new string a size thing
kind of convoluted and weird in terms of
what it tries to express feel it bit off
at least I just want to add that in Java
there's a reason why they don't have
that because they could not change the
JVM specification when they introduced
generics and so they had to do a ratio
of that you know types so the only data
type in Java that have generics is a
primitive erase because they have
reified types yeah there are other
things we're drawing sort of picking up
good features from other languages and
implying them in a new context here it
works out pretty well we have a notion
of cascaded calls very often at least in
certain kinds of code you end up calling
lots of different methods on the same
object like the trick usually is to
throw that outfit into a a new local
variable and then just repeat that all
along but small talk had a pretty neat
solution to this that allow you to send
multiple messages through the same
object without having to do that and and
we sort of cloned that and put that into
a and C syntax and made it possible to
actually in this case call one two three
four five methods on the canvas context
object and without having to materialize
that in a you know in a new local
variable here I mean the difference if
you actually went ahead and put context
in a local variable or we wouldn't be
that big but we do find that people
write better code and can stay within
what is a what sort of an expression
context you don't have to be in place
where you can write statements to make
this work and it makes the code a bit
simpler and it it I think it encapsulate
what the intent here is even better than
actually pulling out the the context up
into a local variable there are other
places where this actually works pretty
well and that's where um where you
initialize objects and right away want
to do something to them so in in small
talk this is a very common idiom with
one twist in small talk the the the
evaluation of a set of a a set of
messages all-race evaluated to the last
expression evaluated here and we've
decided in doubt that that was not
really necessary that we always wanted
the overall operation here to evaluate
to the original object you are invoking
these messages on so the code for
creating a small initial set here could
easily look something like that it's a
method that returns a set and on the
right hand side you see us creating a
set and right away adding a single
element to it before returning it it
works pretty well in practice and we see
a lot of people using these things for
just writing slightly better code so
sort of encouraging people not to have
to invent names for all all the
expressions that they want to reuse in
this context so it's a way of making
things more concise it makes sense to
you great so just to sum up the Cascadia
things maybe you haven't seen these
things before right but it does allow
you as a programmer to do have a
chaining of methods on any kind of
object with a different ID with a set of
message without having the API is
prepared for that and in Java we see a
lot of people writing these sort of
fluent style or method chaining style
api's where they always return the the
object or invoking on to be able to sort
of and just have a chain of method
invocations but that it looks a little
bit off-putting when you look at the API
I think why at the exact API is always
returned in the office is that just to
prepare for something where someone who
wants to use the API as a need to do
this and in a row it feels weird like
why'd I do these methods returning this
all the time so you don't have to do
that in dot and as I said the
expressions always return the receiver
object the one you invoke in the methods
on and it's certainly inspired from
small talk there are a lot of things in
that that there is inspired for other
languages and I think find that's the
that's that's the best way of actually
building pragmatic useful languages
and people generally find this is our
experience that it's kind of easy to
pick up a language like that because it
feels very familiar so just one more I
just want to add one more thing here
first of all I hope you see a theme here
if you want to use method chaining in
Java the implementation ahead of time
has to be planned for it
everything has to return this so we can
do the method chaining in that you can
also you can use at the client side on
any interface it's exactly the same as
with the polar point in that you can use
any class as an interface you don't have
to pre-plan for for doing an extra class
whereas like in Java you have to do that
so we really believe that creating
frameworks for one use case is not a
good idea in software I know many people
like that but it's a terrible idea
because you don't know how the second a
client will be using that interface so
in my mind is better to have a
programming language that makes it
flexible and when a second user is
coming in I want to use that interface
they can use it in any way they choose
to now let's get back to Eric so this is
a Maya used to be at Microsoft did a
synchronous support in c-sharp has added
to almost any language in the world by
now and I'm going to go through a small
spiel how we did that in in that so I
assume all of you guys that have
programmed in in JavaScript you try to
block the UI thread and then everything
goes to hell sometimes the browser even
time you out and stops the whole web
page and it's just really annoying in
Java you have multiple threads so you
can always spin off another thread
working on it that's not possible
if you run inside the browser for
instance so the browser enforces a
single threaded execution and the big
problem here is how do you deal with IO
without killing responsiveness because
if you read something over the network
you don't know when they will return
many people over the time has said that
multi-threading is it's a solution but
even that is not a problem even that is
not the solution because often when you
make a new thread in a programming
language you bind it to a native threat
and there's limited threads you can
allocate so in Java if you allocate much
more than 10,000 threads they start
killing the machine you're running on if
it's digital so what is the solution
because the code you want to have is
sort of on the right this is simplified
IO code it reads something and it writes
it and that can be errors you want to
handle that with a catch Clause and when
you're done with the whole thing you
want to close the the streams you've
been working on so very simple so in the
browser we're without having real
support for asynchronous programming the
simple solution is like if you used OS 9
on the Mac many many years ago you put
down a callback so when the i/o
operation completes that'll be called
and then you know that the i/o operation
has terminated
so in them here's some pseudocode that
can handle it and what you do is you
make a read operation that will you can
pass in the closure and that closure
will be called with what was read when
it happened and then you can do whatever
we want with it in this case say you
want to write it to some place the
contents see and then you also pass in
an error handler which is a callback if
something goes wrong it will be called
please note that we don't handle handler
finally because then this becomes
completely unreadable and this is the
absolute simplest case file one read one
right imagine if your logic in order
this then it becomes completely
unreadable
so smart people have come up with
abstractions called futures to make it
better and a future is just a dumb
object that can contain a closure and
the idea of the futures is that when a
future completes you'll call the store
closure on the future and then you also
have some library routines on a future
that will help you organize your code in
this case here you can actually handle
the finally clause that's on the right
and you can see you have a then Katz
error and when complete it makes the
code more readable
especially when you have sequential a
code like I do a read and I do a write
if you have any any kind of looping
going on this gets really complicated
because you have to replicate all the
language constructs in library for the
future so you get this duality in the in
the system that's hard to to deal with
so for those of you were more familiar
with this JavaScript I just think
promise when we say future and you'll be
fine same issue same deal let's call the
promise I promise to do that in the
future good so Sarang Maya just left
Microsoft so we hired him in as
consultant to make sure that our
libraries was fit with a new a
synchronous design so we came up or he
came up mostly with a new keyword for
our language called a sync you can put
on methods we already have libraries
that have streams and future so that fit
really well into the system the solution
is inspired by c-sharp but now they say
they have it everywhere either way so
this is mostly for a place you probably
know all of this but if you introduce
the Essen keyword you can come back and
get some code that's almost readable
please note that the code on the right
looks like the code on the left now we
have now gone back to using try cats and
finally yes we have some awaits sprinkle
around they'll say this actually can be
suspend at this point in time but the
logic in the program is restored behind
the scenes is all awful because you have
to terminate an actuation in mid-flight
and then you have to reactivate it again
when a certain future fires so we have a
compiler that compiles a method into a
state machine where the locals in the
activation has been migrated into a heap
representation and so whenever you
continue after a wait it will basically
resume that activation on the other hand
you get readable code and we make the
call that this is better to have
readable code than a complicated
implementation behind the scenes so
that's pros and cons will a sync await
the pros are obvious I talked about them
restore the normal control flow of the
application is super important because
then you can actually maintain the code
you even have the try and finally
clauses and then you can do incremental
a migration of code you can take one
method at a time and convert it from a
method recall backs and futures to a and
a sync method and I think that's really
nice so the combination process only
changes around one method if you have
the s and keyword on the negative side
right you get this duality between s and
code and sync code and it's like Const
in C++ it seems to spread out but that's
sort of the drawback of it it has more
positive sides that negative sides
one problem is of course that stack
traces disappear because whenever you
are adding a weight point you unwind the
complete stack and then when you fire
the next future you'll reestablish that
activation the debugging this is not
intuitive
especially when the system's a guy's
tells you that I if you step into an
async method there's two results anyways
people love this and so I am glad we put
it in and thanks to Eric for it so we
run through a few examples here in this
presentation I hope you convinced you
that having simple and having a simple
and consistent program is it's important
for you to understand how the program
executes I've spent too many years to
small talk and I really really like that
there's a one-to-one correspondence
between what you see in the source code
and one you ate or what do you acute
when you run your program that I leave
out the async stuff um but that's
important so now we'll talk a little bit
about the framework that's also
important to make it simple and
understandable to make you a better
programmer
Kasbah so the name of the framework
we're gonna get over this yeah some of
you but I'll take it anyway
and all right it's called flutter and
we're gonna just give you a brief
overview of that but I'm gonna metal it
with some machines up here to actually
show you a demo off this stuff running
for real so I'm gonna switch over a few
things here so so I'll do later the Lars
do a bit of the talking here while I
start sweating and moving machines
around so it I guess you can get a a
first taste of it while I start working
on this all right so um we need a freeze
the frame signal here and then we can
I'll take this Wow thank you so we have
a new project at Google called flora
it's open source flood that IO and
these are all about making mobile
development faster so today when you
have to do a mobile app you first have
to do it for iOS or for Android and then
make a similar app on the other side so
one of the main points of Florida is
that you can write this as a source code
in once anyone's on all these devices
and caspere's rated low or demon your
not the machine is still building so you
have to stall a little bit but the more
interesting part of this framework here
is all written in that and they start
out as a as a product from the chrome
guys and they wanted to make something
that's simple than the browser so they
start making a simplified Dom model and
in the face to that and try to be the
framework on top of that got too
complicated so they took that out and
replace having more dart code and they
eventually it ends up that they only
have a C++ low-level a graphics API
the rest is implemented in Dart and the
point is in this project here is that
when you run the debugger all the code
isn't that so you can see what's going
on and that is - a big contrast to most
of the systems that being implemented
they you have a demo I'm ready now
can we switch over to the live HDMI it
is on we're on great let me start this
up here's a a flutter based
small sort of gallery app that shows
some of the things that that flutter can
do and as Laura said almost everything
here is brought written in dot and and
right now I'm actually running it here
on on this small device at the iPod and
I'm just gonna show you a few of the
things be aware that the frame rate you
see up here is probably not gonna match
what I see here so things that look
really nice from he might looks somewhat
crappy for you guys but should come up
here afterwards and I'll show you the
real live devices so on my device up
here this is super smooth and you have
to trust me on this just okay 60 frames
per second easily this runs really nice
and it shows great animations frame
rates and
consistently frame rates as well is all
powered by that and and the the flutter
framework and I mean this is a fairly
simple thing but a lot of these sort of
more high-level managed systems out
there have a hard time delivering these
very consistent frame rates and the
session area where we're done is doing
really really well so let me go back to
something that might look a little bit
better even on the on the screen here
and pick a through the flexible to one
thing here here's a another part of this
sort of gallery app that shows some of
the transitions that you would expect
from make modern mobile apps are all
working in this this framework so it all
has a nice fluid and feel to it again
like the frame rates look really nice
here but you can see that there's a some
attention paid to the details and it
actually looks like a real native app
and the thing is that this does not just
run on the on the iPod here if you come
up here and I'll I can show you this on
a different device let me just wave it
about them you get a feel for that it
actually is real but here is the the
same thing running on an Android phone
same codebase same system and it works
really nicely there as well and that is
a big reason why this this works out and
of course the other reason is these is
the implementation quality of the of the
flutter of framework so what you have
here what you see is basically to a
separate a phones or in this case an
iPod running a native app built with a
flutter further stack and from the same
code base I think this is kind of thing
that we need to make people much more
productive and in terms of delivering
apps across the at least the two major
and a mobile and platforms if you want
to add if you want to show you should
really drop by afterwards in there and
form a line and I'll show you all do you
how the whole works out in practice it's
much much nicer they're not connected
here we'll see how many people we can
get to see yourself once use back oh
yeah let's try it out
all right yep all right so this is the
architecture overview of flutter ah much
better so you can see it's a layer
approach at the bottom you have the dart
VM skia which is the graphics library
used in chrome you have something called
mojo which is just a an isolation shell
around it and then you have a flow
Indian for text the rest is written in
that which is really cool they love it
because they can all they have to debug
in is in one program language you know
when you build a a big system and you
use different components it could be
JavaScript angular and HTML there's
always a blame game when it comes to
performance like these are the guys
that's not performing stuff like that
and it's never-ending the cool thing
about this is if there's a performance
problem we can fix it in the in the dart
VM to get good framerate
and for the flutter system we have
actually done a lot of engineering in
the dart VM with on ahead of time
compilation we have done dynamic stories
of dynamic to generate the code on
Android so if the underlying system
kills it and restarts it you can use the
code that's already compiled and so this
is this is a fairly good fit for the
dart program lengths and the VM one
thing you should notice why didn't we do
this in JavaScript yeah okay you should
try to pre compile JavaScript and come
back to me then because that's nearly
impossible
devs could be so dynamic that you cannot
a pre-compile mods so this is great you
should go look at the florida io home
page and try it out next page please
here's a sample application
from the sample code from from flora is
a rack to framework and the way that
works is that and you can see an
increment if somebody called increments
a set state will be called the closure
and safe state will just they render the
system dirty and the underlying system
will call the bill construct and create
a new UI tree and then only give a great
display what's necessary for the update
this is a very modern way of doing UI
stray and it's very clean so we are very
excited about sending this house soon as
an SDK and we haven't even a quote for
from a fellow Googler they just love it
right now which is good I hope they'll
continue so M run program aims to roll
the move or rule them all and then I
really believe in this and it's sort of
going back to the old days where you had
lists machines all in lists or small
talk systems all in small talk but
actually that's something to it you you
become a much more efficient programmer
because when you have to cross the
boundary between one language n and
another one there's always what happened
to say in the interfacing part and you
have to change the mental model this is
actually very clean an example on that
if you start with angular and HTML is
actually very complicated to figure out
where the time goes and who initiated
what code so very good so let me give
you an update on like where dart is at
in 2016
thank you probably all familiar with the
fact that 2016 at least a good chunk of
it is the year of the selfie and dart is
actually doing pretty well in this year
so I just got to give you an update on
how we see it used today and there's a
lot of internal Google properties that
are using it I just want to let you know
I a few details on those things so
Google Fiber for those of you let's say
lucky enough to be in an area where you
can get that and it actually using dart
for some of the UI heavy stuff that
they're building
and they're very happy with with with
the the benefits that they also get from
that maybe our sort of most the biggest
customer we have internally is the
AdWords team that are rewriting the
entire AdWords product which is a very
important product to Google in Dart
and this works from within browsers
across mobile devices and and it's
actually being being launched more or
less as we speak this this new version
of it all built into hop so we're seeing
really really really healthy uptake F of
the technology and and we're really
shipping these large very critical web
apps built in dart and there are a lot
of people writing dart code and the
reason why we we see these internal
teams moving to dart is that they can
actually see that they are highly
productive as as they scale upwards and
there and one of our friends there I
work on on AdWords Josie and was kind
enough to provide a small testimonial
for here but I think the core a cost
thing here is really that that is really
in quite heavy use probably more than
the inside of the company than outside
but I guess part of a part of me and the
reason why we're also here is just to
let you know of where we're going with
this technology so you can you think
about well that it fits your you bill so
that actually runs in a lot of different
places just to make it very clear where
it runs and it runs in browsers through
a translation process of JavaScript and
it also runs on mobile and you sort of
saw a demo and you should definitely
come up here and see it for real
but there it actually runs on top of an
optimized dart VM and that gives us some
really nice frame rates and some good
debugging properties as well it runs on
service as well we use it for a lot of
different things but the sort of the
latest things we've also sort of
venturing into is a it's a plan to
actually run these things on much
smaller devices IOT is probably the most
famous buzzword for these things and I
like to think of it as embedded instead
and Meli's we want to run dart on small
microcontrollers and and it's actually
working very well for us they certainly
work in progress it's not a product yet
and but we have thought running really
well on on small cortex based and
microcontrollers and and it scales this
is not like really low-end device at all
it's sort of the the high end of the low
end you could say small devices 32-bit
microcontrollers with maybe around 100
128 kilobytes of RAM and a good chunk of
flash as well this is where it starts
getting interesting having a managed
language that actually works well in
that space and that gives you some of
the benefits and the productivity
benefits in particular and that we see
for like desktop and and mobile on these
small devices is a very powerful thing
we're not the first to have tried this
it's been done in the past thing they
probably have some more stories to share
with you and but it feels like the
market right now is in terms of hardware
capabilities it's really getting there
and the the difference in price between
a a chip that can run a high-level
letter- language like that and one that
cannot is really really shrinking quite
dramatically these days so it feels like
this is actually a pretty good fit for
that one thing that's really important
to stress here is and the embedded space
is a very interesting space lots of
closed software stacks that you cannot
really get access to unless you pay a
very high premium it's still like
developers seat licenses and it's very
old-school model for it we're going for
a heady the more modern approach with an
open source sort of alternative to to
those systems and even though that some
people find that sort of it an
interesting change I think it's it's
it's highly critical that we we get much
more open and much more accessible
stacks out there that people can really
use it's a it's certainly an attempt to
also improve software for embedded
devices in general so I think we're
getting close to the end yep now in time
that looks good we start early oh I see
all right so let's try to conclude
before we have questions so we believe
we did after spending 25 years doing VMs
we got set up did a new program lines
and we think we've learned from the past
we think it's readable and it's concise
and I think you should try it out if you
haven't
and we've heard from other projects I
like it
which is nice and we already have
several million lines of code of that
with me it's like goo goo and the good
thing about that is that it means this
is not a fluke and a dad is going to be
around for a long time so get used to it
so
so we created the Casper and I created
that and I think we uh we at least have
an attempt to make something that's more
concise and so that's good
and we hope you like it too so let's go
to the questions do we have any
questions from from the the audience
here if not I have a good list here of a
question that you all sort of like the
right questions are are really good so
please take a mic if you want to ask
questions about VMs or languages oh I
don't have a question about that sorry I
wanted to ask a quick question about
flutter even though I could probably
look this up I'm just wondering what the
current support is for the native API is
such as interfacing with Bluetooth
accelerometer etc etc so the flutter
apps are native apps so they and they
have access to all the same native
capabilities as any other native app and
and there's a little of plumbing that
you have to do to make that available in
that but it's certainly possible to
access anything from the underlying
system by in so basically having
interrupts with Java on Android and an
Objective C and Swift on there on iOS
well this is where it gets tricky
because you don't want to use too much
platform-specific code because then it
doesn't work on both so you have to make
sure that when you do and like the
compass interface to that right you want
to make sure that you use the same API
and prior to implementation so people
can take advantage of a common API on on
the two systems but that is the intent
intent I actually have a question for
you here Lars and it's not for me as
well but it says like v8 is very
impressive do you feel any guilt for
inflicting the world's worst most
painful language on the planet I didn't
make this up
the last part of that question I've been
told not to say from my own mouth
because that gets mental problems but
you have yeah I have excuse here because
when we started on on v8 in 2006 it was
gyroscopes was mostly used for
describing an action when you push the
button it was very simple
competing browser would do a full
garbage collection for each 1000 object
allocations so the recommended style of
programming was to do an optic tool for
your whole app so it was pretty pitiful
and do I regret it it's them I don't
like inflicting pain and you never know
how a system will be used I think it's
amazing what people can do with their
script today given the fact that people
are doing pre-processors or trans pilots
on top of JavaScript makes it bearable
to many a big organizations to use it
and there's a reason why I did that is
that when we looked into the
specification of JavaScript we got
horrified and you saw some examples in
the talk I think that most people do not
understand they the corsa Menace of
javascript and that makes you a bad
programmer if you understand this the
core semantics of programming languages
using you will become better and you'll
trust the underlying system so I think
we learned our lesson it's the answer
next I think that's a pretty good good
answer so my question is sort of an
extension of what she asked so a
framework like ionic uses Cordova to
translate the code to the native
platform does dart use something similar
to do that if that is a like a wrapper
framework like Cordova or PhoneGap to
actually translate code to
and notified of mobile platforms for the
flutter framework there's no sort of
translation process involved there and
so it's basically and there is some some
work being done by it mostly the flutter
team at this point to expose these api's
in a in a in a mostly platform-specific
way but and to just avoid papering over
important details in this thing and but
the there is no sort of aim a regular
way of doing this in a in a more general
way right now so but one of the
important things to realize is that the
flutter stack does allow you to do these
things yourself as well but if there are
api you really need to hook up to it's
certainly doable and okay we can take
one more from the from from here I guess
think the dad was a typescript that's
fun dot versus typescript thoughts
well thoughts I guess that's pretty easy
yeah lots of thoughts yes I think dot
and typescript certainly yeah trying to
solve some of the same issues but they
have very we have different approaches
to to this and I think if you dive into
the details in many ways tight ship is
still JavaScript with some very very
nice additional features that makes
tooling much better and makes it
possible to at least a part of your app
have a sort of a much better
understanding what's happening at
runtimes through the static type
annotations in that respect Dada aunt
actually are very very alike but if you
dive into the details there are a lot of
differences as well and you could say
that dot is a little bit more ambitious
right we wanted to fix things like not
and just giving you weird issues when
you try to read sort of out out of
bounds from an array we actually give
you a proper error when you do that that
doesn't happen in typescript and there
are lot of other details where the
implicit value coercion that you solved
before happens just as they should in
interactive because it's based on
JavaScript in dart we actually check
these things to make sure you're not
burned by that at runtime there are a
lot of places where we just in some ways
took the maybe the more difficult
approach of trying to solve these
fundamental issues and guard you well
anyone here that wants to use that at
least from some of these issues at
runtime I think we clearly there's
overlap in in the technology space here
but least personally I find that there's
also lots of differences that only
become very visible if you really look
into the details here the one one thing
I want to mention is that types could
actually an interesting language and if
you program only in typescript it will
help you make you a better programmer
but you can you can fall into JavaScript
at any point in time and then he'll is
loose right but it means that you can
you can manipulate the underlying model
remove properties and whatnot changed
prototypes on the fly and then the
guarantees of types will not hold so I
think if you keep within the the area of
typescript you can actually have a
fairly decent system in that you cannot
break out into Jewish but there's no
unsafe part of that and if that matters
to you then I think that is a is a
better option and then then it runs
outside the browser yes how's the
performance versus the JVM that's a good
question so the question is how is the
dot performance on the dart VM compared
to the JVM that depends that's different
gaya systems out there my favorite one
is hot spot but the and this I think is
still the fastest one I hope so the that
is same speed or even faster when it
comes to inlining of abstractions and so
on there's a big difference between dark
and entierro on a fundamental level in
that in Java you have basic types in the
byte codes of Java you have specified
whether it's an in or a double or stuff
like that we don't have that in dart and
certainly that more flexibility can cost
you so if you do matrix multiplication
say you have to bind all the
implementation types to a certain thing
that will be slower
but for normal application programmer is
just as fast or even faster sometimes
and we decided when we did that and this
is again I was annoyed by writing C and
C++ when I overfilled an integer it will
silently just get the wrong number like
what what is what world are we living in
so in that we have everything we'll also
two big noms when you use it as it
should be to preserve the internal
semantics when you sing it's just I
cannot believe most programmers they
don't even do that and there you have it
actually wonderful it it doesn't have
integers to be gone yeah I think before
we have one more question I want to take
it from the audience yes from the
client-side perspective you say has no
connections to JavaScript so what is the
browser support in terms of different
devices and so maybe you clarify the
answer and so there is certainly is a
way for dot code to call out into
JavaScript you just cannot sort of mix
it in inside a dot method you will not
find bits and pieces of Java so floating
around in there
so there's much clearer split between
the dot paths and the JavaScript parts
but you're right in terms of writing a
software that runs in a browser you need
access to existing Java some
functionality that's one thing but also
just all the browser API is needs to be
exposed to name in it and they're
available top libraries by the way in
the browser but you cannot take a
third-party jerska blob and soak into
your dot program and and and just use
because there's impedance mismatch
between the dart programming language
and the JavaScript program language so
you need to do some interfacing I think
I think that's it that's it
yeah thank you very much for showing up
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>