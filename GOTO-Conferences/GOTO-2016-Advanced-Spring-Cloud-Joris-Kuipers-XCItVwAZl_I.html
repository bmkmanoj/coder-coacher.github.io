<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Advanced Spring Cloud • Joris Kuipers | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Advanced Spring Cloud • Joris Kuipers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Advanced Spring Cloud • Joris Kuipers</b></h2><h5 class="post__date">2016-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XCItVwAZl_I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what I'm going to be talked about today
is spring cloud and obviously as we
could just see with the show of hands a
lot of you will have already seen
Joseph's talk I was actually counting on
that and you can also imagine probably
that's a little bit challenging to
follow up George long to talk a little
bit more about spring clouds after what
you've seen already so what am I going
to talk about today well I'm going to
very quickly cover the idea of spring
cloud but then I'm actually going to
dive into some details on how some of
the stuff that you've just seen them out
how it actually works why it works that
way and how you could apply it to your
own project so in essence when you're
talking about spring cloud what it is
it's really a set of projects it's not a
single project it's a whole collection
and actually it is only becoming more
and more with every major release train
that will help you to build distributed
systems and this can be distributed
systems of any sort and any type of
nature right obviously lots of people
will be using this and thinking about
this in terms of micro services and
that's definitely one of the more
obvious use cases but it doesn't have to
be something that necessarily runs in a
cloud for example this by the name
spring cloud it you even have new terms
coming up like the guys from Enoch you
calling things like self self-contained
systems those are all use cases where
you could use some of the stuff like
spring cloud even if you have a big fat
monolith sitting inside of your
organization but it's calling out to
external systems right over the internet
maybe you're partnering with other
organizations you need to consume some
of their restful services for example
you can use spring cloud for systems
like that so what do I want to cover
today well for those of you who did not
attend Josh's talk basically my agenda
is thinking as a service as a spring
cloud application I'm going to answer
three questions and so firm services
point of view the first question i will
i will answer is who am i right
service wakes up it's being bootstrapped
it bootstraps and it needs to know who
it is that may sound a bit weird who am
i but what I mostly mean is Who am I
this time because you can have the same
service running in very different
configurations you might have multiple
instances of it running in the same
environment you might actually have it
running over different environments you
may have it running locally on your
laptop because you're developing and
we're going to talk a little bit about
how you can find that out and how you
can then do different things depending
on who you are and the next thing it
needs to know since it's a connected
service right we're talking about
distributed systems is where are all the
other services what services are there
where can I find them how can I talk to
them basically right so that's the last
point how do I talk to them there are
multiple ways typically in a distributed
application to have services communicate
with each other two primary ways or sink
in a sink and I'm going to talk a little
bit about those things for those of you
that did see Josh's talk I made a
separate agenda actually basically I'm
going to talk about what the hell just
happened right this is a guy who's going
really fast showing you everything there
is in the kitchen sink coldspring cloud
but by by intense not explaining a lot
about it so hopefully after this talk if
you were there as well you'll understand
a little bit more about how this stuff
actually works so to start with that
first question that I posed like Who am
I this time what we're really talking
about here is centralized configuration
right every application being at a micro
service or not or being a big monolith
needs some form of configuration at
startup and if you've been working with
spring for a while and probably the
traditional way that you've been doing
is is through something like a
properties file that you put maybe on
your classpath or next to your
application somewhere on the file system
and you read it from there when we're
talking about distributed systems and
we're talking about
occasions running then actually in many
cases you will let's try that again in
many cases what you will want is you
will want to take that configuration
away from just the local file system of
a single service for example and you
will want to put it somewhere centrally
so this is for multiple reasons one of
the reasons is that if you have
something like 10 different instances
just for availability reasons of your
service you don't really want to copy
over the same configuration file to 10
different servers to make sure that when
your application starts up it can
actually find the correct configuration
for that particular environment that is
running in another thing is that
configuration may not actually be
specific to a single application you
might have some shared configuration for
a number of reasons simple example even
though it's best practice to have
microservices use have their own
database that may not actually mean that
they're all going to have their own DBMS
instance running right companies
typically spend a lot of money on buying
good hardware with lots of fast disks
and lots of memory to run their
databases so you probably just want to
have a dedicated schema in there so
you're going to end up in case you have
a lot of data heavy services with lots
of applications that need to connect to
your database now I've actually had the
case in one of the applications that i'm
working on where we don't have this
stuff in place yet where our hosting
company said well you know we made you
happy and rather than having the old
boxes in there for my sequel we're
running an active active setup of my
sequel there we have replaced the whole
thing with bare metal boxes very fast
lots of RAM and this is new IP addresses
and what I had to do I had to log in in
like a dozen services and I think I
changed over two dozen configuration
files for all of the various
applications chrome jobs scripts things
that we had running that needed to
somehow connect to the database right so
it makes a lot of sense for all of those
cases to say well
let's just put that in a single place
and when it changes we can let everyone
know so the same thing obviously is true
for running in different environments
right on an acceptance environment or
when you're running locally on your
machine you're probably going to have
some different requirements then you
have when you're running in production
you might even have services running
through a special spring profile for
example where you want dedicated
configuration there and finally if your
configuration does change then what are
you going to do typically if you're
using something like a properties file
spring actually you're forced to just
restart the whole application when
configuration changes so that would mean
that even if you have central
configuration but only that that you
would still need to know okay I changed
this one configuration key now I have to
know which applications are actually
relying on that key and have to find
those instances and I have to manually
restart them so it would also be nice to
be able to push out configuration up
dates back to the services right so
spring cloud has support for this and
they have support in two ways they
actually provide a product that you can
use as a centralized configuration
server this is called spring cloud
config server and just briefly demoed it
in its previous talk but they also have
an abstraction for clients that connect
to such a configuration service and
spring cloud config server is not the
only service that is supported there are
a couple of other ones actually so I'll
be demoing if it actually works because
like I said my computer just crashed
have no idea what is still on my file
system and what isn't so we'll have a
look but I'm going to demo that through
another product of a company called
hachey Corp called console right they
make a number of free tools that are
very popular in the cloud and services
space so to first start with that
console I'm just going to start it up
locally here this thing can actually be
configured to expose a user interface
and that's going to start up right now
there we go it's a bit too small so it's
switching to mobile view there we go so
what you see here is an overview I have
some services but actually my servers
are not running yet so that's why you
see a bunch of orange things here but
I'll talk about that later on but here
we actually have key value pairs this is
literally key value pairs that you can
simply store inside of console that you
can then expose so what do I have here I
have like a directory called config and
under that I have a bunch of sub
directories corresponding to a number of
applications that i have plus one extra
that is simply called application which
is for configuration that applies to all
services right so if we have a look here
at application you can for example see
that i have a key configured called a
login dot patterns council where where
I'm changing logging pattern that is
that is used by spring boots for
producing it's logging output when it's
writing to the console also for the
servers that I'm about to start I've
actually changed the default log level
you can do these sort of things with
spring boot quite easily yeah
you should be it right okay so that's
the server side of things this is where
we can put our configuration now how do
we actually access this from an
application now I thought about doing
some live coding actually and now I'm
really glad that I didn't do that but in
anyways following up on Josh long live
coding is not going to be impressive
anyways so I have some code set up here
and I have a service that will expose
conference talks right because we're in
a conference and we actually have some
internal applications that do these sort
of things so what I have here is a
simple spring Buddha application and the
application basically just shows a
number of talks from this particular
track exposed as restful resources right
there's a simple controller for that
doing that I'm not going to go over the
entire code because it's not actually
all that interesting the thing that's
interesting first of all is when we go
to the maven palm here and look at the
dependencies that this thing has now
apart from just a regular boot
configuration you can see this thing
spring cloud starter console all this
means I want all of the console support
provided by spring cloud so what is that
well if I click through on that you can
see it's actually two things it's spring
cloud starter console config and start
your console discovery so this thing is
about the config part simply by putting
this on my classpath let's start up it
will discover that we need to connect to
a console server for configuration
purposes question is how does it know
how to connect to console right it
cannot actually get the configuration
from that from console this is a
bootstrap problem and as Josh actually
showed already during his talk there is
a mechanism for this and spring clouds
where next to an application properties
file you can actually have a bootstrap
properties file and typically you can
figure this with two things you can
figure a name for the application so
that it knows for example what to ask
for from the configuration server and
you configure it with the actual
location of the configuration service
now in a cloud environment of sorts you
would probably get this from an
environment variable so
that's why you have the gun fixture over
URL there that could come from a system
property or an environment variable but
i'm having a fallback here as a default
which is just the console running here
on localhost so what I'm going to do
over here is I'm going to start the
application like this now the reason I'm
doing it here from the command line is
that later on I want to actually have a
second instance running next to it in
two consoles and I want to show you some
output of that hopefully what this will
do is it start up it will find the
bootstrap properties configuration it
will connect to console it will then
find its configuration and then using
that configuration it will boot strap
the rest of the spring application so
let's make it a bit bigger here we go so
the first thing that's happening is it's
just using may have to start out the
application i'll make this a bit bigger
this is bigger yes thank you very much
so we see the number of things happening
here i'm sorry yeah it's responding
really slowly so when I'm thinking I'm
making it bigger it's actually becoming
smaller there we go that's better we see
number thing interesting things are
happening there is a custom boot logo
here I didn't just put that in because
it looks so nice I'm actually putting it
in to make a point later on and then we
see it starting up if you look very
carefully you can actually see that the
logging isn't has changed there is no
dates in front there is only the time
stamp here and that is because it's
getting its logging pattern from this
remote configuration server so okay you
have to believe me now that this work so
how would you actually notice right what
what is actually happening here when we
do this so one of the things that you
can do with spring boot application is
you can expose these actuator endpoints
and this thing is exposing an
environment actuator endpoint that will
actually show all of the settings that
it has
oh I missed an aid there I'm sorry so
closing some of this here what you can
see here is that we actually have
different configuration sets here these
things are called property sources in
spring so at the top we can see that I
have some local configuration for my
server port that's actually coming from
my application that properties file then
you can see there is a console based
config / talk service one that sets my
debug level and then you see there is
another one config application to
overwrite that logging pattern then
there are also the configurations that
the application can read from the system
properties you have a system properties
as well as the environment and then
finally you see some local data sources
as well so these things are ordered
actually so this will tell you exactly
what configuration your application is
using first of all but also where it's
getting it from right so that's an
important concept now another thing
that's interesting I had a browser tab
open for that but obviously everything
correct so I'm just going to tell you I
talked about refreshing and pushing out
updates right if you were now to look at
the latest documentation of spring cloud
and you check out the console support it
actually says console has a really nice
with hook that you can use to be
informed about configuration updates but
unfortunately we don't support it yet
this will come in a future version now
you may have heard the expression of
under-promise and over-deliver that
seems to be exactly what they did when
they wrote this documentation it does
actually work so let me quickly show you
that if I go over here
and i change this log level here for
example to info and i update i can go
here and actually when i scroll down a
bit here then what you can see here may
be a bit hard to read but i'll just tell
you here is an application context is
being closed and started again and we
see refresh keys changed logging the
level to talk so this application does
know that the configuration changed and
it's reconfiguring itself now the final
thing I wanted to explain in a little
bit more detail here's how does this
even work right because if you are used
to spring applications but you haven't
worked with this then you probably know
that typically when you when you've read
something like a properties file let's
start up that's it right these things
are just cashed in memory and the only
thing you can do to refresh your
configuration is to just restart the
entire application so they use a little
trick for this and that's also why you
have to dedicate bootstrap those
properties file basically what will
happen with a spring cloud-based
application is when you start it up it
creates a separate application context
so it's like a little spring application
inside of your application and this
thing is only responsible for basically
going out to the configuration server
getting all of that configuration and
creating custom property sources and
when that's done your usual spring boot
application starts out with its own
application context which has a
reference to this cloud-based root
context and when stuff changes like you
see in here that's that ultimates
cloud-based application context is being
recreated so it's not the entire
application that's being restarted it's
only that part of the application
context in addition to that but just
already show that so I'm not going to do
it again you can annotate your beans
with at refresh cope and you can
actually have objects in your
application being restarted as well if
they rely on certain configuration
properties that you would like to be
able to change at runtime now there's
some other stuff you can do for demo
purposes like this it's actually nice to
have individual key value pairs in
console if you have really big
applications that take like 50
properties that's not really going to
scale so you can actually tell this
thing I just want to have a single key
value pair for every application where
the value is just going to be the
contents of a properties file or a
yellow file write those things are fully
supported you can even have your
configuration and get and run a script
called get to console that will actually
export all of that configuration and
load it up into console which I think
makes perfect sense right because
configuration is definitely something
you will want to put in version control
so even though i'm not actually showing
it these things are fully supported so
that's the configuration part and so
that's nice now we can start up we know
who we are where are the other ones and
for those of you that were a joseph's
talk you've probably seen already that
spring cloud supports the notion of a
service registry so what's the idea
there with the service registry well
obviously when you're actually building
a distributed system is distributed
because these things are not islands by
themselves right they need to
communicate with each other so the first
thing a service needs to do when it
starts up and it has its configuration
its needs to advertise its present it
needs to tell the world hey I'm here
this is my name this is where you can
find me and even things like this is
where you can check if I'm doing okay
then obviously as a client it also needs
to find out where all of the other
services are that it wants to connect
with now you may use something like DNS
for that and for a particular certain
use cases that actually works really
well right I don't really have to know
where other services are I just need to
know their logical dns name it there
will be something that then provides me
with an actual IP address and then stuff
like that but there are a lot of use
cases for which that doesn't really work
one obvious use case and again just
mention this in passing is that when
you're finding out that there are
multiple instances of a single service
and you want to talk with one of them
you may want to choose which instance
you're talking to yourself rather than
leaving that up to some middleware based
load balancer that you have absolutely
zero control over Netflix actually uses
this for example to find out which of
the service instances
that are reachable are the fastest to
talk to which have the lowest latency a
load balancer doesn't know that because
a load balancer doesn't talk to the
service itself it's your clients who is
talking to a service and there may be
all sorts of things happening especially
in cloud-based environments that caused
that to be slower or faster so if you
can actually measure how fast you can
connect to a service then you are in the
best position to actually make that
choice all right so in that case you
need a complete overview of all of these
services that are there from an
operations point of view also it's
important to have an overview of what
services are actually there and are
those two services that we expect to be
there or is there stuff missing and if
the service is there how do we actually
check that it's running successfully
that it's completely operational that it
can talk to its middleware like its
database like its message broker that
sort of thing so that's health checking
basically and with the service registry
whenever a service registers itself it
can actually talk to the service
registry and say oh by the way this is
how you can check if I'm doing okay
right so that's that's handy now Netflix
has actually open source their service
registry which is called tarika just
demoed it so I'm not going to do that
again but if you want to run Eureka the
most convenient way to do that is
through a special starter that spring
cloud provides and then you can just run
it as a springboard application
basically obviously you should be
running these things with multiple
instances because it needs to be highly
available but the the console project I
just demoed it is actually also a
service registry so you can have both
your configuration and your services in
a single place so to have a quick look
at that if I currently go here I can
actually see already that I have an
overview here but some things seem to be
not so okay now that is because this
thing is actually remembering what
services were running before it shut
down now everything shut down in let's
say not so very clean way just now on my
computer so it says I have these
services they said that they would be
here they've never officially said to me
I'm going away but they're not there
getting failures which in this case is a
good thing right I know that certain
services are not running you can see
that here I'm actually supposed to have
two instances of this particular service
running here what you can see is one of
the services that is running why is that
not working here we go one of the
services that's running is on port 80 81
let's skip that and that's okay that's
green but the other one on port a day
two is currently failing now let me fix
that for you what I'm going to do here
is I'm going to start up another
instance what I'm going to say
a server look port equals a today too
and then say spring boots run and in my
ID ear in the same time I'm going to
start up some other services because
what I've been doing is I've wrote a
very small sample application by the way
i'll put a URL to the source code on
Twitter after the talk so you can
download the code as well that will
simply bootstrap a number of services
that's one and that's one
there we go it's a bit sluggish but it
will be there in a second now while it's
doing that going back here you can see
this one still failing yeah it should be
up in a moment let's see if this is
going okay yep that's working fine this
is running yeah it's just a bit slow so
just to get ahead of myself a little bit
and make the demo go a bit more fluent I
said that these services can register
health check endpoint so that's how
console actually knows if my service is
there it's going to talk to an end point
I can show you for my end point that's
already up and running what that looks
like so that's the slash health endpoint
by default this is provided by spring
boot right so what you see here is that
first of all my service is actually
saying I'm up that's the key thing here
the service itself is expressing the
fact that it's up and sending back a 200
ok with this JSON response but it's also
showing you some of the things it did to
check that so it's not just saying I'm
here it's actually checking some of its
own dependencies as well so it's it has
automatically received a database check
because i'm using any memory database it
actually is going to check if it can
talk to console right because this is if
this is a client to your service
registry well it better be able to talk
to that service registry it better have
disk space left running on the device
that you run right so those are some of
the checks as you can see here that are
automatically provided there now that
seems to be going in the right direction
so in the meantime let me check if my
demo application is already up and
running there
no not yet well it will be there in a
second I'm going to show you a little
bit more of that service registry in a
moment in the meantime let's talk a
little bit more about what happens when
we are actually registered and now we
want to talk to some other services
right now in general this is not
specific to services or cloud or
anything there's two ways two modes of
interaction when it comes to talking to
two other pieces of software running
somewhere you can do it synchronously
right this is typically something you
would do over HTTP for example you make
a request you wait for a response to
come back or you can do it
asynchronously and this is typically
done through messaging right I'm going
to send the message and as soon as the
message has reached some centralized
message broker I'm done I don't have to
wait anymore some other service and this
could be a single service but it could
be a whole bunch of services can then
process that message maybe they want to
produce a response that's okay if they
want to they can send me a response back
but they will again do that on some Q
and eventually i'll just pick up that
message from some other q and both are
typically very important in in an
application architecture to have so
synchronous my blocking communication is
often done for things like queries right
if I want to check a database I'm
expecting a result now I don't say I
would like you to figure that out and
maybe just later on you'll get back to
me with the results no I actually have a
user waiting for this result so I'm
going to call it immediately
synchronously other things like sending
maybe a command to a surface saying I
want you to do something but I am
willing to wait on the result because
the result is very important for me and
it's processed at somehow right now some
concerns that come into play when you're
doing this is are you going to just do a
blocking call which is in java at least
is the most obvious thing to do
typically right you're just going to
block your threats to make an XP request
for example nothing will happen until
that has either worked out or has time
that nowadays there are is a lot of
effort in actually making
these sort of things non-blocking so
that's the whole reactive thing now you
can say whatever you like about reactive
and it's a very important thing but it's
still obviously synchronous
communication right don't think that all
of a sudden doing non-blocking
communication makes it a synchronous
those are two very different things some
things that come into player as i said
already are things like load balancing
right if i'm calling out to some service
instance which one is going to be and if
that thing goes down another one goes
i'll probably wanna make sure that i
actually route my request to this other
instance the other thing and this is
typically where the whole robustness or
rugged thing comes in is that i want to
make sure that when i call something and
something is wrong then i'm not going to
be affected as an application myself
right so there's a number of things
there that are important obviously
things like timeouts right if you're
going to connect to some external
service don't wait forever for the
connection to come there if you have a
connection and you actually make the
request don't block forever until some
response comes back over the socket
right you need timeout thrill of these
things and in many cases it's actually
much worse if a service that you're
talking to just responds really slowly
rather than is simply completely
unavailable because you will find that
out immediately I'm going to try to
connect immediately I'm going to get an
IO exception there is no soccer there
but it's much much worse if it if it
actually does respond but it simply
takes minutes rather than ours also if
something goes wrong then I cannot
simply fail right I need to have some
kind of way of falling back and I also
need to make sure that I don't I don't
overload other services maybe if for
whatever reason my service all of a
sudden comes on a really high load I
don't simply want to push all of that
load out to the rest of the system and
then maybe kill everyone in the process
right I need some way to throttle that
so those are some things that come into
play with synchronous inter-service
goals and the interesting thing is that
netflix has open source another library
of their school districts that will
actually allow you to do a lot of these
things that i just mentioned so i want
to show you a little bit about that some
other things that they have open source
that are very much used in tandem with
this or something called
ribbon this is a client side load
balancer and so this is a thing where
you can say I would like to make a
request to a service you figure out what
service instance and it couldn't do just
trivial round robin load balancing which
if the demo God's will allow me to I
will actually show you in a moment but
you can do fancier things as well like
for example the example I mentioned
where you're doing you're doing routing
based on measured latency and that's
those kind of things right it could be
particular tags that are being set on
request as well there's all sort of
options there and finally but i'm not
going to show you this because just did
that already there is zul which is a
proxy based approach that allows you to
say I have a bunch of back-end services
and I'd like to expose them through a
single HTTP endpoint right and that
single HTTP endpoint may have some
additional things on top like security
requirements but after that it's just
going to propagate my request to those
banking services so what I'm going to
show you in history first of all is
something called a circuit breaker
circuit breaker is a pattern that says
if I find out that some service that I'm
talking to is not there or it's not
responding properly I'm not going to
just keep on trying right I'm going to
give up after a while I'm going to
remember the fact that this service was
not there and then for a configurable
period of time I will simply not try I
will immediately fail if someone tries
to call the service and say sorry
deserves is currently not there and
after a while i will try again i will
try once and then if that request
actually works out i say ok we're back
but if it doesn't then immediately it's
just going to remember that this is not
going anywhere let me first check if
things have loaded already
oops
no it simply hasn't started yet that's
okay though so what I've done in the
meantime let me just quickly explain it
set up here we have two instances of a
talk service we have one instance of a
review service that will allow me to
find out if there are any reviews for
particular talks that we have in the
system and have a single web application
in front of those two or three services
the web application will need to talk to
both services and it's going to do that
in a synchronous matter for example well
things are really really slow here
yeah there we go
so what I have here is a service in the
web application right so this thing is
part of my web application and it has a
method here called all talks that simply
returns all of the talks that are
available in the system for this
particular conference or this particular
track and it does that by using a rest
template here that says get me that URL
there and it's talking to slash talk
service now that's not a dns name that's
the service name tell what this thing
will do at startup is it's going to
connect to my console and when
everything is up and running it should
show up here but I seem to having some
issues here so let's see if this
actually works
yep here we go so first request actually
fails as you can see here now I get a
page so my web app works but there's
nothing there so what happened here well
apparently this method got cold but
there was a problem talking to that
backing talk service notice that there
is an ad histories command annotation
here with a fallback attribute so what's
that saying is that if you somehow fail
to successfully complete this method
execution there is some exception just
call the cast talks method instead in
this method can have any visibility but
apart from that it needs to have the
same method signature at the original
method and that one is just going to
return a cached version of all of the
talks but since I've never made a
successful request yet my cache is empty
so I'm not actually seeing anything now
it does worry me a little bit obviously
that I'm not seeing anything so
hopefully that was just part of the
slowness yes here we go so now you see
that it's doing another attempt and it's
seeing okay stuff is back up I can now
call these services and I can click
through and I can for example find out
some information about josh's talk and
it's actually interesting he has the way
longest presentation summary of all of
the speakers in this track that's
probably because he talks so fast right
so this is my application now by the
thing I wanted to really show you
because that was the demo I had prepared
is this if you look here at the bottom
you can see my two instances of the same
talk service running right one on port
80 81 one on port 80 day too now if
console has successfully picked up on
the fact that these things are both
running which I'm having some doubts
about that we'll see then what we should
be seeing now is automatic load
balancing by ribbons so I'm making a
first request and that was on the right
it says returning all talks it just
popped up I'm doing another oh that was
on the left I'm doing another on the
right on the left on the right on the
left right so this is ribbon in action
so this is a combination of making sure
that we have a service registry in place
that we have hysterics in place and that
we have ribbon in place and it's simply
a matter of putting this stuff on the
classpath putting an Ettin a
the annotation in there and this is the
behavior that you get now if I now kill
a service boom and I make another
request here then this first request is
already done but I'm not actually seeing
anything there now this one goes there
oh nothing oh there again boom nothing
so it doesn't know yet that this other
service is no longer there it will find
out very quickly and that is just
routing all of the requests to the thing
on the left but if you actually look at
the output of my web application now
here then what you will see is that
there are actually some exceptions here
because it was trying to connect to a
service that I simply killed but we
didn't see any errors or exceptions in
the web application that's because if
you're looking at some of the output
here you can see that sometimes it says
talk service unavailable I'm returning
the cash talks right so that's the
circuit breaker in action there now
going back to this many people think of
circuit breakers as the main feature of
history's right this is the thing that
everyone demos this is from a guy called
Ben Christensen he used to be one of the
chief architects at Netflix and he was
responsible for a lot of the stuff that
I'm showing you here today he's
currently working at Facebook but he has
said in the past that actually circuit
breakers are highly overrated we could
drop it from history x hardly miss it
the most important thing is actually
concurrency limits or bulk heading right
so this is another feature and this is
something that not many people i think
talk about so i thought it would be
interesting to show you at least a
little bit of it a bulkhead is something
they're using ships to protect it from
sinking if there is a leak so if there's
a leak in this ship only one compartment
will actually flood with water but the
rest of the compartments will stay
filled with air and the ship will stay
afloat that's the whole idea so how does
this translate into software well let me
show you something I'll just keep this
instance down that's fine for now what
I'm going to do is I'm going to make
some requests to my application that's
currently still running but I'm going to
do it using a little test generation
tool from Apache benchmark so I'm going
to say do a thousand requests do 10
concurrent requests
I want to make them to localhost 8080
now this should work fine right
everything is running you can see lots
of outputs from my controller returning
all of these talks and then in a
moment's time this thing will say I've
just done a thousand requests it was all
a okay how can we see this well there's
actually an application that exposes my
circuit breaker state so here we have
felt requests 0 on the right so
everything works as expected it's not
terribly exciting actually but I want to
show you something else now while this
thing is starting up let's see what
happens if we try the same thing again
as we just did so doing a thousand
requests but this time we're going to
increase the concurrency level 2 15
rather than 10 there it goes spawning
away almost done and now on that side
everything looks okay right because
every request that actually makes it to
my talk service is handled just fine
that's okay but now on the right if this
thing completes in a moment's time you
will see that it actually got a lot of
errors now that's interesting because
it's getting errors my service is
running I have hysterics configured I
have a fallback but still in this case
let's see where the error is completed
tough yeah there were a hundred and
fifteen failed requests so that's that's
not even like some requests right that's
a very significant portion of requests
completely failing and not going through
the fall back so what's happening here
well it turns out that if you're using
history x you're actually getting a
second feature and it's a feature but
you have to know about it otherwise it's
a book and what this thing is going to
do is it's going to limit the amount of
concurrent requests that you are allowed
to make to any surface guarded by a
circuit breaker
all right you can see that here this is
the history x dashboard on the eye can
see my circuit breakers here so my old
talks for example but I can also see the
thread pools below that and this is
actually the bulk heading in action now
oh actually i can see that i already
increase the pool size somewhat but
still this thing has a fixed pool size
and this is to prevent you from
overloading other services right and the
default actually in history is only 10
you get a thread pool of 10 threats you
can never make more than 10 threats at
the same time to some service if you are
trying to make another request while
those 10 requests are already in action
it's just going to fail completely
immediately and it's not even going to
go through your fallback because the
idea is you're being overloaded you need
to tell whatever client you have that
you're simply not available because the
system is too busy this prevents the
whole system from actually going down
and being overloaded but if you don't
know about this it's very easy to say i
have i have configured everything i
think i can go to production and then
before you know it you're doing a denial
of service on yourself because you're
only allowing yourself to make time
request to all if you're backing
services at the same time right so to
configure this stuff and that's really
what I wanted to show you in my talk
service here you can do things like
configure the size of this thread pool
sorry get here you can see I have set
the thread pool properties here I set
the course as 220 now even that's not
enough right if I'm using a tool that I
like a load balancing tool i was just
using even saying 15 those requests come
in so fast that even a threat to love 20
here is not even enough but this is
something to be aware of and you can see
the thing going down if I do it again if
we now go to this dashboard here you can
see it it looks fine for a while but
then BOOM everything goes red and you
can see that the thread pool a lot of
the threads are becoming active it's
starting to queue up things and after a
while things just go haywire then they
go back down again right request form a
are made you can actually make a
thousand requests really quick if you
just let them fail immediately
as it turns out but this is very much
something to be aware of it's an
important feature but if you if you
don't know about the feature things will
just break now finally there's also a
sick messaging through our support for a
sink messaging and this is typically
used for things like broadcasting events
right if something happened in your
application and you would like other
applications to know you don't need to
tell them one by one explicitly that
something happens but you would like to
do is just broadcast a message and
that's particularly suitable for message
brokers also request responses where you
don't actually have to block and wait
for the response because there is no
user performing an HTTP request for
example that you need to result for you
can just send a request and then
whenever the response comes back do you
say okay thanks for the response of this
process it's perfect for a sink now
there's a lot of products out there
there's a lot of different protocols
that you can use for this but there are
a number of common patterns so you can
have point-to-point messaging where
you're sending a message to only one
single receiver or you can do pub/sub
where you can subscribe to a topic and
then whatever a message is sent to a
topic every subscription of it you can
say I have a queue when I have multiple
applications listening to that picking
up messages to distribute workload for
example that's called competing
consumers and these patterns are now
being supported by another member of the
spring cloud family called Springs loud
stream now I don't actually have time to
demo that anymore but there is code in
my demo codes that like i said i'll put
on twitter in after the presentations
you can check out for yourself that
supports these notions is in an
abstraction where you don't have to
actually configure the actual broker
anymore so you're not using JMS directly
or amqp directly or some Kafka client
directly or a reddish client directly
you can actually say I would just like
to have a notion of some some topic that
I can publish on and something that I
can listen to and it will figure this
out for you it even supports some more
fancy concepts partitioning for example
means producer actually tags certain
messages and then they will always
arrive with the same competing consumer
this is cool for things like sensor data
right if I'm keeping track of a moving
average of certain
answers I really don't want my sensor
information to end up with lots of
different listeners because they will
not have the previous information so you
can actually take it so it always
reaches the same one or you can make
sure that if a consumer goes away
temporarily it will still receive the
messaging right so this is a fairly new
addition like I said running out of time
to to actually demo this but just so you
know that it's there so this gives you
hopefully a bit of a bit more insight
into the main components of spring
clouds namely the configuration stuff
the services registration and the
synchronous invocation through all of
the netflix libraries of course there
are many other things that come into
play right when you're building a
distributed application like if
something is really slow what is
actually making it slow maybe what if I
have to do things like oh well thought
sent occasion i need to actually
propagate that info to banking services
or what if i want to know about other
service instances of my service and i
want to know how many are there like
significant others so there's there's
project for that as well so there's this
loose stuff that's for distributed
tracing there is something called spring
cloud bus that will actually allow to
propagate commands to services there is
a part that integrates with security
particular 40 off and there's something
called sprinkle cluster for coordination
right so this is a big topic area
obviously not something that you can
cover in any depth in 45 minutes but I
encourage you to check it out if you're
interested also switching back to a
trackhoe smell here and please remember
to rate this session when you leave the
room or preferably before you leave the
room I'm sorry that some of the things
that I plan to didn't quite work out but
it was a bit stressful here with all of
the crashing and slowness here but I
hope you learn something I hope to see
you well let the last keynote of today
Simon Singh I'm actually looking very
much forward to that if you have any
questions left do we have time now
there's a first time for questions okay
well there's a few questions from the
from the audience and one I think is a
short one your first request earlier
failed is it intended that every first
request fails
no that was a very much some slowness
weirdness issue on my laptop that just
recovered from a crash that was not
expected what is this suggested fallback
if the remote configuration isn't
available when bootstrapping a service I
would say it depends normally the remote
configuration should be available right
it should be a highly available
components so normally it will actually
just prevent your service from starting
you can actually configure it to ignore
that remote server is now being
available and then you can fall back on
some local defaults that is fully
supported but that's more intended for
development purposes rather than for
production purposes so my recommendation
would be if the highly available you
should make it highly available
configuration service is not there
that's actually reason enough to simply
fail and startup config server itself
may actually get certain things if
you're using something like spring cloud
config server which is backed by a git
repository it does a clone of the remote
git repository so the git repository
itself doesn't actually need to be
highly available it will use a copy but
for your service clients I would just
fail in production I think guess that's
it looking at the time so thank you yo
Haskett and thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>