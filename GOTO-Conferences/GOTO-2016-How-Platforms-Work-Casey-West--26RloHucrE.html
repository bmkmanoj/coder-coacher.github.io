<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • How Platforms Work • Casey West | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • How Platforms Work • Casey West - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • How Platforms Work • Casey West</b></h2><h5 class="post__date">2016-08-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-26RloHucrE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how is everyone
excellent excellent I'm also well so
here's my source code run it in the
cloud for me I do not care how this talk
is about how platforms work we've had a
lot of talks about orchestration of
infrastructure resources we've had some
talks about scheduling workloads across
those those resources and this talk is
going to sort of move up the software
stack into what we what it looks like if
you have an operationally mature
production environment so I want to
discuss platforms but I need to make
sure we're on the same page so I'm going
to be defining what I think a platform
is so that where we all agree and then
hopefully you agree with me and when you
talk about platforms after this
conference you'll say what I say because
I think it's a good idea all right but
first and foremost the most important
thing who has Twitter its 2016 folks
twitter twitter if you have twitter you
can tweet at me if you disagree with
what i say please feel free to live
tweet that we'll see how it goes but you
can reach it reach me this way who's
heard of email e-mail email yeah if you
disagree with me a lot more you can
email me this is my personal address
feel free to reach out to me that's fine
I write some things on the internet from
time to time you can read them there
that should be something you can check
out later so I worked for this company
called pivotal who's heard of pivotal
just a few folks actually a lot of folks
that's great we build a lot of
open-source software we also sell some
things but I'm not gonna talk about that
today we believe in giving back we
believe in giving more than we get I
think that's great and I really
appreciate that pivotal lets me come to
places like this and give talks like
this so that's their due so let's talk
about Minimum Viable platform we like
MVP we heard MVP in the last
talk that's a great thing to talk about
we don't always spend enough time
figuring out what viable means right we
spend a lot of time with minimum and I
like this that it's MVP Minimum Viable
platform so let's describe the
operational characteristics of a mature
environment using a set of rubrics so
I'm gonna describe a few capabilities
that you should have in production today
if you have an operational immature
environment first you need fully dynamic
DNS routing and load balancing if you
want to push a new application or a new
service into your architecture you
shouldn't have to talk to anyone in
order to get resources provisioned you
shouldn't have to talk to anyone to get
DNS entries poke a hole in a firewall
adjust the load balancer update
configuration management inventory files
if you have to do any of that it's not
very automated is it and give it some if
you have to manually adjust automation
how automate it is your system you
shouldn't have to talk to anyone to do
that you shouldn't have to file a ticket
and wait for IT or wait for anyone else
it should just happen and it's not just
important for pushing new things but
also scaling out existing applications
or even scaling them in in order to get
more efficient resource utilization you
should be able to do that again without
the intervention of another human being
in fact it should be fully automated and
that'll be a theme the automation should
be there already
so we need a backing services broker if
you build an application and it isn't
just a toy then it probably talks to
other things all right this is a
datastore or a database a caching layer
message bus perhaps an existing API that
you've written that that exists
somewhere else or even a mainframe that
you're trying to interact with 8 an
Oracle database over here that's
absolutely massive that you have to
interact with whatever it is you have to
connect an application to other things
and you should be able to do that in a
fully automated way when you deploy an
application you shouldn't have to go ask
for authorization credentials and
network access information in order to
connect to Redis right you have to send
a ticket
somebody generates hopefully a new
password for your particular use case
and application and then they probably
encrypt it they put it in another ticket
they send it in an email your developers
copy and paste that into their code
maybe into a configuration file that's
again not very automated that's putting
a lot of human beings in what should
otherwise be a fully automated process
so we need to be able to auto provision
backing services new ones that we need
for our services so if we're building a
new micro service and we need Redis or
we need MySQL we should be able to
provision them one-click no humans
involved in that process if you want
access to existing infrastructure or
existing services you should be able to
provision the authentication and and
network access information automatically
and that should be provided by the
environment your applications live in
you need infrastructure orchestration so
we talked a lot about this today you
know this is your eye as layer your
programmable infrastructure the ability
to on-demand provision compute storage
and networking resources but I want to
take this a step further it isn't just
about the ability to automate
infrastructure it's about having that
automation already in place you should
not have to go through a provisioning
step or a procurement step in order to
get new resources when you want to
deploy an application you shouldn't have
to wait days weeks any amount of time in
order to get those those raw
infrastructure resources the production
environment should manage that for you
automatically and again it should be
fully automated
this isn't about programmable
infrastructure it's programmed to
infrastructure it's done if you have
that if it's good then you can get
really good health management monitoring
and recovery at several layers of the
stack if your cloud provider loses a
virtual machine or in an instance for
you which happens from time to time that
should not be a paging incident that
should not be a downtime that shouldn't
be a service disruption your production
environment should notice that that
infrastructure failure it should know
what to do about it and it should just
do it automatically it should fix it
should recover and you should be able to
know that happened but hopefully after a
good night of sleep when you get into
work whatever next day you get into work
no big deal
and then if we move up the stack when
you deploy applications and you fan them
out over a distributed cluster and
you've got maybe 50 or even 500
instances if a few instances misbehave
maybe they die that shouldn't be an
in either your production environment
should notice that and recover from it
you need an immutable artifact
repository who here has heard of
containers hopefully by now everybody
raises their hand so containers are neat
because they force you to isolate the
build deploy and run phases of managing
and upgrading applications you have to
build an immutable artifact a point in
time a snapshot of your application
something that you know about something
you can inspect something you have
provenance over or you understand the
provenance of that container you know
what's in it
and once you build it then you have to
deploy it and once you deploy it then
you can spin it up you can run it and
you can spin up more of them and that
happens very quickly in order to get
that you need a repository someplace to
put that image or that immutable
artifact that is very close to
production so you can get one of the
major concepts of a 12 factor app or a
cloud native app which is the ability to
spin up quickly and also have graceful
shutdown will talk about graceful
shutdown in in a little bit but to be
able to spend quickly means you can
respond to incoming events you can do
things like auto scaling and you can't
respond quickly if you have to build the
world every time you want to add a node
to your infrastructure that's that's too
slow if it's minutes it's too slow
finally and this is again minimal Viable
Product platform you need full log
aggregation if you again are
distributing an application or many
applications across the cluster of
compute resources you don't necessarily
know where they are you shouldn't really
have to care but it's important to be
able to get the logs and understand the
operational characteristics of that
application in the event that it's
misbehaving or you want to do analytics
or you want to do a event monitoring and
you shouldn't have to SSH into your
production environment in order to do
that and go searching around all over
your file systems to try and find logs
so from this day forward if you take
nothing else away from this talk and I
hope you take other things
no more SSH into production from this
day forward no one in this room will
ever do that again right we don't have
to do that or you know whatever they do
on Windows RDA RDS or no RDS is
something else remote desktop so this is
the bare minimum set of capabilities you
need to have what I
consider to be an operational immature
environment it's important for them to
already be in place I guarantee you that
if you look at this list
you either have these or you're trying
to glue some components together to have
it or you're trying to find someone to
give it to you maybe off the shelf but
whatever it is you're trying to get
these set of capabilities these will
lead to development enablement so this
is where I want to ask another question
how many folks here would describe
yourselves as application engineers or
developers you're building something
that executives and boardrooms like to
call business value how many people are
doing that a pretty decent number okay
and then maybe on this side how many
people would would say that your job is
more managing applications keeping them
alive keeping the fires from from
overtaking everything keeping those
applications up and running how many
people are in the operator side of the
house far fewer people are responsible
for the mess that first group made the
the in this room and then how many
people here would say you're somewhere
in the middle and you sort of do the
DevOps you have both the responsibility
of building the business value and
managing that business value right so
that's that's a few folks here good so I
just like to get an idea of where we're
at in the audience that's how that helps
me a lot so I want to make one specific
point and I'm going to use a little bit
of an analogy here in order to have a
fully functioning car you can't just
have the electrical system of that car
now the electro the electrical system is
already fairly complicated it's a big
system it's important you must have it
but you need a bunch of other systems as
well they are all so complicated and
they're complicated within themselves
and then the integration points between
them are complicated but what's the
point of having a car it's to get in and
drive it somewhere like right away
that's what you want to do right so
similarly I want to make it really clear
that when we talk about platforms
they're not just talking about
containers it's not enough to have
containers there's a lot of other stuff
we need we've talked about provisioning
layers we talked about orchestration
layers today in this talk I'm going to
talk about the interfaces that go on top
of all of that then interact not just
with the other components of your
architecture but also the people
you have to interact and manage your
applications in the first place so we're
moving up the stack closer to the
applications that you want to build
every day that that give you your unique
business value so I'm going to use open
source Cloud Foundry to demonstrate
these capabilities just to give you a
very quick overview the top boundary
comes in two basic layers the one lower
subsystem layer is called Bosch this is
distributed system lifecycle management
so this is your upgrade you know rolling
complete upgrades with no downtime your
versioned infrastructure install
on-demand but with the primitive being a
complete distributed system not just the
server here and a server there that you
have to put together yourself the entire
distributed system is managed as a
single entity and you can do this Bosch
handles stateful distributed systems
just as well as anything else and one of
the stateful distributed systems that we
put on at is Cloud Foundry Cloud Foundry
is more of your application elastic
runtime plus automated services this
gives you the same sorts of resilience
and rolling upgrades and management for
applications that you're building that
you get at the lower level there for
Bosch so where Bosch is more of an
operator interface IT and operations
might interact with this may be of a
team called platform engineering we have
one called cloud ops so we like that
name you can steal it steal cloud ops
that's cool
and then this is more of your developer
interface so this is for your
application engineers and your
application operators and we're going to
be mostly be using this today to do a
little bit of a demonstration this is a
very high level sort of bucket list of
things that you get when you use Cloud
Foundry out-of-the-box a lot of this is
in the Minimum Viable platform that we
talked about I'm not going to talk about
too many of these things but I will
highlight these little cloudy bits here
that's important because one of the
things about Cloud Foundry is it's
completely infrastructure agnostic you
can run it on premise in a data center
on top of like VMware stuff if you're
into that or OpenStack and then you can
also run it on AWS as your Google Cloud
whatever you want and you run an
instance yourself you manage it so I'm
actually going to be demoing running a
very lightweight instance on my laptop
here
so I've crammed like a whole cloud right
in here but but that's
neat that you can run it anywhere so
let's do a live demo I use a gargoyle on
this slide because nothing could
possibly go wrong in a live demo see
where we're at we have about 20 minutes
that's good so what I want to do is
demonstrate the minimum viable platform
capabilities using Cloud Foundry and so
I want to show you a little bit of code
here I've got this little app it's a
it's a micro service it's my girl
because it's small in this case and what
we want to do is do a little bit of a
code review how many people here do do
Ruby or know about Ruby heard of Ruby
whew out of curiosity how many folks
here are doing dotnet or interacting
with net heard a lot of questions about
down that clap foundry fully supports
net on Windows and you get with twenty
twelve you get process I resource
constraints and with Windows 2016 you'll
get that full containerization that was
talked about yesterday it's pretty cool
but let's take a look at this Ruby app
it's very simple and easy to read so
let's first look at our gem file in the
Ruby ecosystem this is how we we
mentioned third-party libraries that we
that we're going to rely on so I'm going
to use the excuse me the Puma web server
and the Sinatra web framework can we
read this in the back yes good and the
Sinatra web framework is very
lightweight particularly good for
building JSON API very quickly good for
demos that sort of thing people even use
it in production and there's absolutely
nothing wrong with that let's take a
look at the SAP again very simple we're
going to bind to the IP address that
says we'll listen on any interface when
you're running in the containerized
system you have an isolated network
interface you don't necessarily know a
lot about that network interface and
when you're running on a distributed
cluster you also have to get information
from your environment about what port we
expect your application to run on so we
don't hard-code you don't have the
guarantees of port 80 or port 443
anymore so because of that we will also
get our port number off of the
environment this is one of these twelve
factor principles to get our
configuration information off of the
environment maybe for development if I'm
not running this in a distributed
cluster I'll just go ahead and default
to a number and that's fine and this end
point as I said is very simple it's
going to emit JSON the key will be
instance and the value will be the CF
instance
index another environment variable the
Cloud Foundry provides us because as we
fan out or horizontally scale in
application Cloud Foundry will keep
track of how many instances we have and
how many we want and it'll guarantee it
and make certain promises about always
having that number of instances so it
will keep track and it's important to do
that because we don't have a pre forked
server anymore
running on a sink on a single node we
have we have scale out via the process
model another 12 factor app but
happening happening on a large
distributed cluster or in this case is
somewhat small distributed cluster but
nevertheless this will help us
demonstrate ideas around horizontal
scalability and load balancing and that
sort of thing so I have this application
and what I want to do is deploy it into
the cloud I'm going to use the CF
command-line utility we'll be operating
somewhere in that region of the screen
the CF command-line utility is a go
wrapper around a restful api everything
that i'm doing here you can do fully
programmable via a rest api and that's
pretty great but this go utility can
also be run anywhere and i'm targeting a
specific instance of Cloud Foundry via
this API it's running on my laptop as I
mentioned I am an admin user I will I
will also be targeting this org in this
space all of the applications and the
services that I deploy will be isolated
into a space which is just the general
bucket inside of an org which is another
general bucket and you can have as many
of those as you want that's kind of nice
for a multi-tenancy
that you have that level of isolation
but what I want to do and just to give
you an idea I am in this application
here so I just want to type CF push and
deploy this app before that do that I
want to show you one more piece of code
it's this manifest the ml file that's
trippy right manifest that yamo manifest
that llamo file is something that Cloud
Foundry expects and it's a basic file
that lists the operational expectations
we have of this application when it runs
on the platform you can put various
resource constraints in here and other
operational characteristics I just have
a few things I'm gonna give my up a name
I'm gonna give it a memory limit if this
application had a memory leak and hits
that limit the platform will shut down
that instance of this application
because I hit its memory limit and it'll
spin up a new one in its place it will
err on the side of availability and then
I'll just give it a basic command to run
application so when I wanted to play it
I'm just gonna type CF push I'm gonna
use a little bit of the internet now so
if you could stop streaming from Netflix
that would be fantastic okay so here's
what's happening when we hit when we
type CF push this takes my application
and puts it into a stager so the stagers
responsibility and Cloud Foundry is to
build that immutable artifact that we
talked about it needs to build that
container that image so what it does is
it takes the app deploys it into the
stager it starts with a very sparse
Ubuntu based file system Linux file
system and then it will inspect the
application it knows it's a ruby app so
then it will put down the Ruby runtime
it'll put down the resources that we
need on top of that base file system
it'll do the same thing for Java PHP go
binaries Python net whatever you've got
it'll put the the runtime on there and
then because it's Ruby it knows that we
need to run bundle install in order to
install a third-party libraries it'll
cram our app into that container and now
we have a container that's really nice
so it builds that container and then it
stores it in what we call the blob store
which is an immutable artifact
repository that's like a it's analogous
to a docker repo but all of that build
pipeline is already baked into this this
production environment that I have here
and then of course it'll just spin up an
instance by default it'll spin up one so
let's see what happens if we go to this
in our web browser we can see that we
have an instance that's good that's
helpful it's very good for my demo but
maybe we want to scale it up so I just
want to scale it so there we go
now we have three and if I want to look
at this application in a little more
detail I can do that using CF app and I
can see that I have three instances
running what I'll do down here is I'll
actually go ahead and tail the logs I
want full log aggregation all right so I
have three instances and I want log
aggregation
and you won't be able to see the logs in
quite detail but if I start reloading
you'll see that we have we got DNS
automatically we are obviously routing
requests and we have full load balancing
support we're load balancing across
these instances and we can also see the
logs being aggregated so something that
I will do here in this little box right
here I'm just going to run a little wild
where I curl this endpoint and so we
should be able to see the instance is
that we hit and we'll just keep this
running for a little while now this
application is very basic
I mentioned that anything that you build
that doesn't connect to something else
is a toy so we want to save some State
or interact with some state but of
course we're building stateless
applications another big-12 factor app
and what that means is that the state is
gonna be managed externally from the
applications that provide the business
logic so let's take this up a notch who
here would say that you build
enterprise-grade software like we're
here to build real stuff right you've
certainly been in a meeting where
somebody said this must be
enterprise-grade well let's go ahead and
take this up a notch so i'm gonna check
out this branch enterprise features and
of course i'm gonna check out a branch
because I'm a professional and I check
my code in all right now we have some
enterprise features let's take a look at
it let's first look at the gem file so
I'm going to use a little wrapper around
getting environment information from
cloud foundry called CF app utils this
is just something in the Ruby ecosystem
makes a little bit easier to interact
with environment variable information
and then I'm also going to use Redis so
Redis is gonna store my state now I know
that everyone here knows that Redis is
like the first stop in a fully
enterprise grade data store that you can
rely on without anything else right
you're all just gonna let me say that ok
Redis is a great cash great caching
layer right very good at cashing up
until very recently the primary
contributor to Redis worked for pivotal
he chose to move on but we're really
happy about about Redis we like it so
I'm gonna use Redis it's very good for
demoing in this particular case and it's
very good as a cache but do not actually
use it as a primary datastore so let's
take a look at this app what are we
going to do to make this enterprise
grade well we're gonna build analytics
so this is free career advice from me to
you if someone comes to you and says we
need this application to be enterprise
grade and you're not quite sure what
they mean just say sure thing I'll add
analytics they don't know what it means
but they read about it in a magazine and
they know they want it so let's look at
what we're going to do here we need to
get a Redis connection so if we want to
store state in this backing datastore we
need a Redis connection so what I'm
going to do you know
put this in the center here is I'm going
to inspect the environment using this
object-oriented wrapper we won't do that
we will do this and if we have
information about Redis then we'll go
ahead and fetch the host port and
password for that Redis connection now
you'll notice I'm not hard coding it
here alright and it's not in a config
file anywhere there's nothing on my
sleeve it's just it's just here but what
I want is I want the environment to tell
me when I say I want a Redis I want the
production environment that's running to
tell me here's your Redis and then I
just want to connect to it now the
analytics we're gonna do is they're
gonna increment visits every time we hit
this API endpoint and we'll go ahead and
emit visits as well when we when we hit
it so we'll be able to see visits
increment across a horizontally scaled
set of front ends right so that's just a
relatively basic still but it does
demonstrate this capability which is
pretty good so to deploy this
application again let's call this
version 2 maybe I'm gonna type CF push
so what this is going to do is build a
new image a completely new one
we have immutable artifacts they're
completely distinct from one another
so it will build a new image and then it
will shut down destroy the old instances
of my application and replace them with
new ones because we don't patch or
update in this cloud world anymore right
we don't we don't update in place and
restart a you know web server on a on a
virtual machine somewhere we don't even
care about that we just destroy and
create that's all we do and we can see
that what we're getting here is an
internal server error which is a little
bit alarming can anyone does anyone have
an idea of why we might be getting an
internal server error right now while I
look through this stack trace over here
no Redis whoever said that gets a free
beer when someone else is offering them
I will give it to you myself so we don't
have we don't have a Redis and we expect
one so we currently have an application
that's failing so what I'm going to do
is check out my working code which
happens to be a master I'm going to go
ahead and push that into production
right now so that you know we fall back
we roll back to a working version but
what I want to also do is create an
instance of Redis so down here
what I'm gonna do is type CF services
and you can see that we don't have any
services running right now so within
this org in this space there are no
services we want to create some so I'm
going to go to my CF marketplace the
marketplace is a list of things we can
provision access to or provision new
instances of so you can see here that I
can provision a couple variants of my
SQL I can provision rabbitmq and also
Redis the Redis again is very important
to me right now
I'm also again running this on my laptop
so you can see that these are relatively
small and you might say okay see these
are single points of failure in your
application architecture and that would
be correct for my particular development
machine but in the more production-grade
versions of these you can turn on plans
as you can see under plans you can turn
on plans for each of these that RHA and
quite large so you can get high
availability out of these back-end
services but again I'm running it on my
laptop here so I want an instance of
Redis by the way we can see that our
application is back up and running
that's good maybe nobody noticed my
mistake so I'm going to create a service
it's called Redis I'm gonna run it on
the shared VM plan which means
specifically that we're just gonna spin
up a virtual machine somewhere and it's
job is to run Redis instances and it
will do capacity planning on that
virtual machine and anytime we need more
it'll automatically spin up more and all
of these Redis is are isolated from one
another which is also good and then what
I want to do is also give it a name it's
gonna back this application so we'll
just namespace it because why not now I
have an instance of Redis if it takes
you more than a couple of minutes to get
a new piece of infrastructure or
architecture for your application that
you're building in production then it's
too long a couple of minutes maximum so
it just took me a couple of seconds to
create a Redis and if I type CF services
you can see that we now have a Redis but
one thing that you will notice is that
under bound apps there are no
applications bound to this instance so
this is a very lonely Redis instance
it's all by itself and that's important
because sometimes you want to auto
provision things from scratch and
sometimes you want to connect to
something else that already exists but
the actual connection between
applications and services should be
brokered as we talked about with a
service broker and the way we're going
to do that is by binding
application to the service so I'm going
to bind the service this is the
application and this is the service and
now if I type CF services you can see
that this application is able to
communicate with a service now what does
this do if we get configuration
management information off of the
environment if we get credentials for
connecting to other instances off of the
environment it's a lightweight way to do
service discovery there are some more
automated ways but this is a this is a
good model that leads to good
architectural design principles if we do
that though in order to do in order to
update the environment information or
update credentials and access
information you do need to restart
instances of an application right so the
application is currently running a
couple of instances we can see that up
here with CF app and what we want to do
is we can just restart them if we want
to but I also want to try to deploy this
codebase again now you might not have
seen it before but whenever I was
deploying our new enterprise grade
version I mentioned that we destroy
instances and then we create new
instances and if you do that in the most
basic example you'll have downtime
alright so when we actually deploy
applications we want to deploy with no
downtime right so sometimes we call this
Bluegreen deployment sometimes we call
it zero downtime deploys and what I want
to do is I want to deploy this new
version with zero downtime so what I'm
going to do is a CF zero downtime push
this is a plug-in for Cloud Foundry
that's called autopilot and what it does
is it automates Bluegreen deployment and
that's pretty nice so I need to give it
a path to an app for this particular
command the app exists in this location
now doesn't even need to give it a path
to a manifest file which happens to be
here oh and I also need to give it the
name of the application where were my
pair of programmers at anyway so the
application that I want to do Bluegreen
deployment on is named cos 2 CF env the
manifest is in that file
and of course the path is in this local
directory so we'll go ahead and get that
started what this is gonna do is build a
new immutable artifact a new container
it's gonna spin it up it's gonna give it
a random hostname or a random route and
then you can also choose to do things
you can inject things like Canary
deployment or testing into this mix if
the application looks good you can take
the high level route that that was given
to our initial version and you can map
that you start mapping that traffic over
to the new version of our application
you can do that in what's called a
rolling or zero downtime deploy we got a
new sir we got a server error let's take
a look at our logs
I will admit I wasn't expecting that one
can't connect a Redis okay let's try a
node a downtime deploy so another thing
that I'll show you here while this is
deploying is if you have the right
credentials you happen to be able to
type CF env in order to get the
environment variable information
provided to your application instance or
your application so this will
unencrypted them and provide them to you
the same way it does whenever it spins
up a new application instance and one of
the things that we can see here is that
we don't have any we don't have any
Redis in here which is quite surprising
no bound apps let's try that again why
don't we will go ahead and tail the logs
here as well while we're deploying it
must a bit I am a little surprised but
this is the nature of live demos so now
we should have a bound app looks a
little better if we check out the
environment again we can see that we
were provided credentials information to
connect to Redis the host the port and
the password now there's some important
things I want you to know I do I started
up an instance of Redis I didn't care
where it was running you don't notice
that I didn't mention an IP address a
host name or report I just let the
platform do it for me I don't care right
I don't care where it's running but my
application does care where it's running
so when I created the service binding it
asks for that that information for the
instance of Redis it said what's your
host and what is your IP or port number
and then it also said I'm gonna generate
a password automatically so you can see
that here we generated this password
fully automatically no humans were
involved in the making of this service
connection it's also nice because the
application didn't need to change so if
you want to cycle credentials which you
should be doing on a regular basis in
production you can do that very easily
by unbinding an application from a
service rebinding it which will generate
new credentials and then restarting or
doing
deploy of that service which by the way
like I'm feeling a little a little saucy
here so I want to try something I want
to add let's see go to beer in our
source code and try another zero
downtime deployment let's just see what
happens so while that's happening we've
demonstrated now five of the six
capabilities in a Minimum Viable
platform we've demonstrated the routing
and load balancing service discovery
mutable artifacts and immutable artifact
repository log aggregation there was one
more but one of and also infrastructure
automation but we didn't demonstrate the
capabilities of the platform when it
comes to managing failure so I want to
go ahead and type a new end point here
and I have two minutes and 30 seconds so
I've done a few deploys here in the last
25 minutes but why don't why don't we
just do another one here we'll call it
ouch very basic endpoint and what
happens in this endpoint is we have a
little bug and that bug crashes our
application now it does it in
spectacular fashion this is about as bad
as you can get for an application bug
that crashes its application but I'm
curious about our rolling downtime did a
rolling upgrade didn't work I'm curious
about what happens here if the platform
detects failure in the application if an
application instance actually crashes
and now I have two minutes and I'm gonna
go for it are we into it can we try to
go for it okay you could ask me
questions after well no we rebuilt in
time for questions so we have five
minutes I might take a few of those
minutes so we're gonna go ahead and
deploy this application it has a new
endpoint we're also going to bind our
instance again because I had a mistake
in my zero downtime deploys and we're
gonna go ahead and restart the instances
so now we have go-to beer that's cool
I'm gonna go ahead and scale this out as
well let's scale it out to six
and then we're going to type watch we're
gonna watch this application if we watch
this information what you can see is the
application starting up and running and
that's cool we can also see down here
that we've got this ongoing constantly
hitting the end point that's good but
let's say and I never know ordinarily do
this well I shouldn't say that anymore
because you saw a bug onstage I was
gonna say I never write bugs but
sometimes it happens so what happens if
I go to this this workflow this user
workflow that happens to crash the app
again like this could happen so it
crashed that instance right away and
that's no good so I'm gonna go ahead and
restart this I'm gonna crash an instance
again and what you can see is a note the
noticing of failure from the platform it
notice that failure recovered
automatically it created instances in
its place I'm going to crash a couple of
them you can also see that this
automatically informs the load balancer
so that we don't route traffic to failed
instances and that we will add them back
in when the instances are back up and
running so you see no performance
degradation down here as we're
constantly hitting the endpoints that
work well you can eventually get to a
place if you don't have enough parallel
instances where you can crash everything
will go ahead and do that and you can
see that eventually we'll get to a place
where the applications aren't running
but it will recover so you do need to
still plan out how much horizontal
scalability you need especially if you
happen to have an application that's
crashing so that's pretty good that was
alright could have been better but you
can you can rate me later so you can
decide you can decide alright but why
would we do this with just a couple of
seconds left I believe in this concept
of cloud native operability it's not
just about being able to manage deploy
new applications and manage them right
it's not about that first install like
that gets us very excited to be able to
deploy a new architecture but it's also
about managing that for the next day in
the next week in the next year in the
next ten years so you have to be able to
manage your application long term and
your business has to be able to afford
to do that right your organization needs
to be able to afford to do that so I
think what we've learned both at this
conference and broadly in our industry
is that micro-services architectures are
a good way to go in order to get the
scale the horizontal scalability the
ability to move fast when you need to
move fast and to iterate at the speed
that you need to iterate on a service by
service level in your
sure it also helps you scale out your
organization or your organization can't
scale if everybody's working on the same
code every day you can't do that with a
thousand engineers you need continuous
delivery
you must automate your delivery of your
software if you don't automate your
delivery and you go from one model if
the 500 micro-services you've taken one
fire one thing that's very hard to do
and you've made it 500 things that are
very hard to do so don't do micro
services without automating your
deployment pipeline and finally we do
need a DevOps culture if we talk about
doing the DevOps what that really means
is a practice about how we work together
a culture of learning and sharing and
measuring automation and collaboration
but and this is the slide detect to take
a picture of if you have a
micro-services strategy continuous
delivery process or a devops cultural
strategy something that an executive
wrote a memo about and and emailed you
about and you don't have an operational
immature environment to deploy your
applications into those initiatives will
not work so you do need something it
doesn't have to be Cloud Foundry but you
need something this operationally mature
so we can be friends on Twitter we can
be friends in real life that's what that
beer icon is about there are a couple of
resources I was using a lightweight
version of Cloud Foundry that you can
run on your laptop too you can see that
demo app on github now you can rate me
and thank you very much for your time
okay
couple of questions questions let's do
it
so Minimum Viable platform you had a lot
of points on that list yeah you really
believe that that is the minimum
that's a great question yes those are
the minimum set of capabilities that you
need bare minimum and you may need more
depending on your context you may need
specific fine-grained authorization
controls and access controls you may
need some specific types of security
expectations around encryption and and
workload placement now you may need a
lot of other things but you'll never
need fewer okay so another question here
didn't the whole platform-as-a-service
thing fail low adoption of Google Google
App Engine Heroku login and so on right
no so I put my hat pivotal hat on for a
moment we sell to like one third of the
fortune 100 in the United States is our
customer running on Cloud Foundry and we
do business with large organizations all
over the world who love what we have to
do one of the things that people are shy
away from and I think perhaps rightfully
so is putting your sensitive
applications and your sensitive data in
a multi-tenant environment that's
managed by someone else now that's not
to say that say AWS has all the
compliance regulations you need
definitely run your apps on AWS you can
feel secure in that environment but when
you take something like Heroku and you
put your sensitive data there you may be
a little less safe in that way so one of
the things I like about Cloud Foundry
one of the things that people who adopt
it including you know bluemix which is
run on cloud foundry its core is open
source Cloud Foundry is that you can run
it in your own environment you can run
it where you feel safe you can run it
where your security and compliance and
expectations might match okay so you
asked if people build enterprise-grade
apps yeah and there's there's a question
here so our architects told us to
implement an abstract Enterprise factory
bean factory does that mean we're doing
enterprise software
it means that someone somewhere thinks
they've they're building Enterprise
great suffering no enterprise software
especially in a micro-services
environment and a distributed systems
environment I think what that means what
that means for a modern technology is
that you respect Conway's law which
we've talked about today I don't need to
rephrase that we expect that we respect
the cap theorem we expect failure and we
build resilient systems that can respond
to that failure so we use the circuit
breaker pattern we use service discovery
we use good load balancing and caching
mechanisms in order to have services
that are resilient in their ecosystem
when they fail I think we learned that
from Netflix thanks to Adrian and and
his teams and I think that's the way you
build Enterprise great software last
question what's the difference between
services and apps right a service is
something that can be managed by the
platform or managed outside of the
platform but a service in our context is
usually something that you want to
provision either new instances of on
demand or provision access to again on
demand so you can write your own
services and you can start to decompose
your architecture that way and then at
when we say applications these are
usually applications that you're
building that and managing that are part
of your business value and it's usually
something that is either an API or
backing service for for another thing or
we're an application that actual you
know human beings might interact with
okay thank you Casey
thank you thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>