<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • The Front End Architecture Revolution • David Nolen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • The Front End Architecture Revolution • David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • The Front End Architecture Revolution • David Nolen</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nDNU2pmuJA8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we also work on something called the
atomic incoming it's our one product
into the beautiful database so it takes
the ideas popularize good enough we're
ready mini program so they these ideas
were taken and sort of taken into the
database context so we basically build
persistent disk relational opinion so
it's not everything pretty unique you're
familiar with it when it get worse very
simple it has the you know a version of
your resource tree when you change
something it does not record elements
okay get simply got some pointers to all
eight blobs or to your files we changed
one pilot it points to a new reference
that change one of all the layers all
the other blocks
okay so the atomic takes this as it's
basically in storage mechanism stores
it's basically water bottle data on that
it gives you relational barrier that
stuff so that's a good example for prior
to working at my detector I worked for
nearly a decade doing JavaScript
programming on the front end or to New
York last four years I was lucky enough
to work on the the 2012 presidential
election for hours we got 40 million
pageviews twenty million of them are on
mobile a lot of the app was just you
know serving up real time in JSON about
the more hours you serve 18 terabytes of
JSON so this is a lot of fun I got to
work on device do I feel like trying to
get a long bit of experience with doing
UI development a lot of done definitely
a lot of this sadly at the end of my
tenure at thearc I'm as sophisticated as
beautiful as it was really combining
visualization you know good solid after
a graphic style at the end of the day I
still felt that JavaScript programming
it's still true today regardless of all
these frameworks that you see and still
I would say primordial soup we're still
sort of in the dark ages of client-side
correct a lot of this is because
that's not yet fully accepted the fact
that most people there write web
applications are distributed systems
programmers most of the technologies
you're picking in the way you're
combining them together does not want to
deal with them this is a fundamental
issue with the text a credibility mostly
complexity rights with back to people
try to put this another rug into the
face and so a lot of this talk is is
actually saying let's take this problem
panel on and start removing lots of
complexity that exists in most stacks
really this is really all stacked why
changes coming the simplicity that whole
point is that by actually embracing
simplicity we can build systems by a
simplicity I don't mean something that's
going to make your life necessarily
teach you in the beginning you may have
to adopt practices the technologies that
are extremely unfamiliar or maybe grow
anything but on the other side of that I
guarantee you you will have a simpler
system the end I think it's the end of
the top you will see what I'm talking
about that notice that there's probably
a lot of a place of experience building
your applications they talk about
simplicity you know I really like this
metaphor I recently saw this awesome
special I know about the cathedral
points I know like 100 years ago what
did
don't sort of an embarrassment part of
the problem was that the dimension of
the computer was so large that they did
not know how to construct and don't
write the actual the base of the dope is
so huge the rid of documents behind
another task Planck famous team knows
this part but there was no living
architect that knew how to construct
such a thing so pretty let's get ended
up winning the competition and he ended
up building it and my favorite thing
about this is to me this really relates
to software architecture often when
people see something beautiful and big
like this they think it must have been
like the most complicated engine the
most sophisticated engineering what
submit put into play to make this work
and it's just not true
so I highly recommend looking star
commander and reading about Brunelleschi
real SD ended up because the dome is so
large they cannot use the traditional
method of a wooden infrastructure to
hold up the dome as a building they
would have to construct the entire dome
without any underlying support and this
is this was a huge conundrum pretty
lucky actually ended up taking in common
brick layer and with well known it's
just the most powerful the people who
build these little bits right you use
the same technique bricklayers call them
the carrying going technique and it's
just this sort of stacking of the bricks
in such a way that the bricks are
supporting as you build it up bricks for
actions putting into them but if you do
it the traditional where you stack
bricks just like this it will tear it'll
tear it's by using the americano
technique
there they laid down four million bricks
in the dough still stands today
four million bricks were placed using a
technique done to color difference so
it's simple simple systems have this
property but it might not be obvious of
accomplishment and it may even take
somebody with some deep insight but
often the patient is right solution is
optimism okay baby so I you know the
bottom post a blog post about 18 months
ago about react versus more traditional
NBC's and caused quite a stir ballistic
wrote submitter really cop equals I go
to the top was a ninety version of react
rendering like five minutes so to do
items I think and the bottom does the
dining faculty and so what beautiful is
that is that reactive to something it
says it's very simple due to the very
simple dipping approach in the batching
approach which is well as well known
this technique was well known to
computer graphics programmers and
backbone is doing the nice thing was
talking to the Dom and you end up
getting a really
turn in the Dom and slow I mean I think
at least four times faster it's also
faster than the top because I excited to
use immutable data structures to drive
significant and so it's completely
unintuitive Frank in the same way that a
common bricklayer campaign could allow
you to place four million bricks at the
top I'm using a compiled language in
this case literature I'm using a new
construction no we're gonna be slower
ones and I'm using a tipping up which
sounds like conceptually must be slower
than just you taking enough and it's
just not true these these things
combined completely blew away in fact on
the blank application to Gandhi this
includes inverts including the also
problem so the state is a bit forum so
the big ideas that I'd like people to
take away is we're gonna talk about a
lot of different technologies but
recently certain technologies because I
think these things actually have simple
properties the great thing is that the
abrasive listy it actually does skin
right so at the top even though
different communities you're not never
heard of at its core that's the stuff at
the top of the main that makes the top
craft work this semantically similar
stuff right
simplicity scan off to get progressive
formation simplicity
it's more opportunity for global
optimization pervasive simplicity
permits more operating for global
optimizations so that's also an aspect
of that first flame graph that's
actually global optimization in order in
order to make you could make the
backbone app faster but you'd have to go
into the view and manually do batching
logic you would have to manually fix and
micro optimize your code and to me if
you embrace simplicity you can often get
global optimization so it's not this you
know 10 developers trying to find all
the bottlenecks you can just fix the
bottleneck in one place and you're done
go home early question designs tools
processes that don't lead to global
optimization I think most most the
tooling around client apps do not lend
themselves towards global optimization
fundamentally flawed stuff and also you
might think you might think at the back
your head may be global optimization is
that odds with modularity you often want
to keep things distinct things separate
separation of concerns but global
optimization is not always out at odds
it's a modularity garbage collection is
a great example of something it's a
global service to the programming
language runtime on it that's what
permits programs to be more modular
right just it so it's not like in a C
program you free some pointer and that
blows up something you know a mile away
right it's it's specifically a global
optimization that permits your program
to be more modular okay so let's talk
about one possible stack mentally for
anything any any element of the stack
that I talked about you can replace it
with something that is better for your
team or something that might be easier
for you to adopt there are many reasons
why that might be true I'm going to talk
about the stack that I'm familiar with
and I'm going to describe the properties
that I think are important if you don't
want to adopt that technology for some
reason find something comparable there
are comparable things out there and I
will I will talk about comparable things
that are that have the same properties
that aren't the ones that I think so
reactive relay at the bottom so react I
think is great there are very
interesting other
tipping solutions coming out that are
worthy of assessment but react is very
well maintained it's very popular large
community we'll talk a little about
relay which is as of yet unreleased but
I think is a good design I use
clojurescript I actually the lead
developer on clojurescript closure
script is is great not because I mean it
is great because I like happen to like
Lisp but the great thing about closure
script is that it ships with persistent
data structures
they've been tuned continuously for
modern JavaScript engines now for almost
four years and so that's what we get out
of the box immutable data structures
that are battle-tested
another thing is transit so the moment
that you decide that you want richer
data structures than javascript objects
you need a way to transport this stuff
from the server to the client
so at cognate eck recreated something
called transit which is available in
Java Python Ruby you can use it from
Scala you can use from closure script
closure quite a few languages there are
community versions and for Erlang o
camel but but the problem we're trying
to solve is that we want to move
different types of information than what
Jason provides Jason only lets you do
arrays strings maps and numbers that's
it boolean's you might want to move in a
mutable data structure and transit lets
you do this efficiently at the backend
you can have there's lots of solutions
the ones the big ones that were top of
the day that could be relay which is
Facebook's as of yet unreleased thing
but remember relay is an idea as much as
it is a specific piece of technology the
atomic won't let you do this sort of
things I'm talking about on the backend
directly against the database of Netflix
that's something that's going to come
out soon as well which I'm going to talk
about called Falkor
slash Jason graph okay so the big idea
here is we want us for at least from my
perspective is that your technology
stack should support immutability at
every layer and so that's definitely a
huge focus in this talk at least the
benefits by picking a stack where you've
got immutability every level and you're
trying to you're really thinking about
how does data move how is immutable data
going to move all the way from the back
end to the front end is that it's going
to enable simpler reasoning and if you
if you have simpler reasoning they're a
lot
lots of times what happens in the
systems that people build today is that
you have hundreds of components you
don't know how they're connected you
don't know how your event graphs are
connected and in fact you're struggling
to just fix bugs you're not you're not
thinking about features you're not
thinking about enhancements right you
have so many bugs to fix and the complex
system that you have that you're never
going to get to the point of having a
wider or deeper reasoning about your
system and by embracing immutability and
also by embracing the react simpler
approach of it's not eat its notes
one-way data-binding no two-way but data
binding by eliminating these ridiculous
event graphs you're going to get a lot
of reasoning power at the other side of
that and by getting more reasoning power
it means you're gonna be more agile
you're not solving incidental complexity
well later we'll talk about how actually
this stack can also remove needless
coordination towards the end of talk I
mean there's a huge problem with
applications front-end applications that
need to conform to a rest design which
requires a lot of coordination between
what the front-end dev needs and what
the backend debs needs and finally if I
think if you have a stack that looks
like this this whole performance thing
is not quite as challenging as it
normally would be so the client layer so
why not backbone so if some of you may
use backbone
why not backbone doesn't backbone solve
this problem or solve this problem I
mean the earlier slide says probably not
but there's a specific reason why not or
ember and these are all fine
technologies and nothing I'm actually
saying says you can't be affected with
it effective with these things right
people are being effective with backbone
and ember and so on right but the point
is how much of your complexity budget
have you spent and have you spent so
much that you're not going to get to the
goal that you want to get to so ember
similar suffers from similar issues
angular does as well and from my
perspective really really what's wrong
with these systems is that there's no
support for anything except for mutable
data structures right you can only build
a backbone app on top of mutable data
structures this is this true for ember
this is true for angular and and
actually finally people are accepting
the fact that it's actually a
performance problem and also a reasoning
problem angular 2 is going to actually
have
first-class support for immutable data
structures so the things I'm saying up
here are things that other frameworks
are realizing this was the wrong design
right we baked in a requirement that we
have to use immutable data structures
and this is I think in the next 10 years
is just going to die if your framework
doesn't support and meet ability it's
probably not going to be used very much
so react react react go out the door
they were the very first framework
JavaScript framework I mean there are a
lot of other interesting properties
about that system but the most important
one was they did not make any
assumptions about what your model looked
like your model could be immutable and
their rendering works just fine for me
this was like a revelation
so clojurescript was interesting prior
prior to the arrival of react but it
really was more of a curiosity it had no
truly measurable benefit and when react
came along it was perfectly natural to
combine immutable to immediate immune
Abul data structures with react and it
was great again the action of that flame
graph the react flame graph that I
showed earlier that's actually faster
than the the exact same react program
with mutable JavaScript data structures
it's faster with immutability ok
so if one one huge takeaway back to
simplicity is that you know a lot of
people think that that algorithms matter
and I think for most of this talk that's
just not true
data dominates a lot of the benefits
that we're going to talk about come just
fall out of data Rob Pike has a great
quote this is actually about C
programming he says data dominates if
you've chosen the right data structures
and organized things well the algorithms
will always be self-evident data
structures not algorithms are central to
programming almost everything I'm
talking about is by picking the right
data structure and moving data around
simple data around you're going to get a
lot of value out of that so I don't have
time to dig into persistent data
structures I've talked about them in the
past you can find my talks about this as
well as Ritchie has great talks about
this Lee Byron from Facebook as he's
actually the lead maintainer of
something called immutable J s so
Facebook itself is actually doubling
down on their own immutable data
structure library there's a great talk
from react conf that he gives on
how immutable j/s works it's awesome
okay so what is it what is it what does
it get you
so this is I love showing this one this
is when I showed almost every talk I I
sort of said when I released my this
library called ohm which is a version
which is sort of a binding of closure
script to react and I said I bet you can
do state management undo trivially so in
something I would normally require a
programmer to spend a lot of time and a
lot of thought I think you could
probably do this in you know five ten
lines definitely four to do MBC and in
fact I showed you could do it in five
ten lines for to do MBC so this
gentleman Jack Scheidler from Ableton
Live he's a C++ UI programmer took me up
on this challenge he had never used
clojurescript he learned closure script
in two weeks he said I'm gonna build a
canvas editor a pixel pixel graphics
editor and I want to see how hard it
will be to have effectively infinite
undo/redo
as well as playback of my application
state minutes as well as exporting to an
animated gif so we spent about a month
at the end you came out with this this
is not a non-trivial application it's
about two thousand lines of Clojure
script and then how many of these lines
out of two thousand lines this is a
complex app how many of those lines were
about state management and doing undo
and redo this is the end this is all the
code this is all the code for infinite
undo infinite redo export animated gif
as well as the live scrubbing of the
preview it's sixty lines of code there's
nothing else there's nothing else here
most of the functionality is two or
three lines of code per function and
that's because he just picked the right
data structure right persistent data
structure just gave him what he wanted
there was no there was no code for him
to write so there are more examples like
this coming out and again people are
again if you don't want to use closure
script people are taking immutable j/s
they're pairing it with react and
they're coming to the same conclusions
okay so which language again I've
already said that I pick clojurescript
there but there are a lot of compelling
options these days that's another thing
that's really changing on the front end
it used to be that JavaScript was the
only game in town right it really was
and that's just no longer true anymore
typescript is very cool up
love typescript because it has great
integration with Visual Studio it's an
awesome solution Elm is very interesting
it's sort of bringing advanced sort of
functional programming to the browser
and a really cool event handling a model
dart which is a custom VM but also it
has great compilation of JavaScript is
also really cool Scala now has a really
great compile to JavaScript solution in
Scala j/s they it's now considered
production ready by typesafe one of the
oldest ones is CoffeeScript CoffeeScript
I think got released a lot of a lot of
people didn't like it but then plenty of
people did in some sense CoffeeScript
validated that compiling to JavaScript
is not a bad idea what's funny is now
with the release of Xmas script 2015
which I think was the final draft
specification was a couple weeks ago
javascript people are compiling to
JavaScript right people want to have
sugar they want the shorthand lambda
they want sugar for classes they want
annotations on classes and on their
methods right this is all stuff that
they cannot get from JavaScript today if
you want that stuff because you want to
be able to write programs without you
know being stuck in the guts of like the
old version of JavaScript people are
embracing things like babel which is
javascript of javascript compilation so
everybody's made that compiled in
JavaScript even people that use
javascript this is not gonna be a crazy
thing so the thing I'm most familiar
with though is close your script and
Google closure Google closure is sadly
not that well-known outside of the
Google community Google uses it for all
their major consumer facing applications
Gmail Google Spreadsheets Google Docs
all that stuff uses Google closure
library as well as the Google closure
compiler so close your script actually
marries the closure language we compile
the JavaScript but it's designed to be
optimized by Google closure what's
interesting about Google closure if
you're building client apps we'll talk
about that in one second so one one
thing that's nice about closure script
it's worth assessing I would say
actually now closure Script effectively
are the lead you know the industry
leading experts on doing effective UI
and UX every me
data this is what everybody does within
16 months all nearly all closure script
programmers use react and they pair with
immutable data now with react native its
kind of awesome because any closure
script developer can take the same
things that they're doing on the for the
web and you they can target both iOS and
Android and that's great so what's
interesting here is that closure script
has a really nice story which is a
little bit different from what the
previous slide with the exception of
Scala j/s and dart actually dart has a
good story because you can use it
server-side as well but Clojure script
is is those these three are a bit
different because on the back end when
you're writing server code you write
closure and that's multi-threaded server
programming you get all the advantage of
the JVM when you go to the client yes a
single-threaded but we have a solution
there that's close your script and I
think if you have a team it's very nice
to be able to take your engineers and
say you can work on the backend you can
work on the front end and it's not
really going to matter JavaScript you
can do that with JavaScript but the
problem is that you're sort of adopting
for no good reason a single threaded
model on the server which i think is
personally i think is ridiculous
closure compiler so why do we like
closure compiler closure compiler gives
this whole program optimization it was
released I think in 2009 and still is
unparalleled there's nothing really as
good as it
people are trying in the JavaScript
community but the closure at Google
closure is actually to actively develop
and it's just winds it's just better it
does whole program optimization which
means it does dead code elimination so
it can take your entire code base and
anything even if even if you include a
library and the library has 10,000 lines
of JavaScript if in my module
I invoke only one function in that
library Google closure will analyze it
and say those other nine thousand lines
of code that are in that library aren't
used we're going to erase it so this is
this is something that that I mean as
far as I know no popular JavaScript
concatenate er minify or does so closure
does the minification the concatenation
but it does dead code elimination which
is very powerful it also does something
that's also not that well-known which is
optimal code splitting so the state
the art the state of the art in the
JavaScript world is to handwrite modules
of the right size and then to load them
by hand up you know in the correct way
in the running applications it's
terrible so Google closure and 2011 said
no way no human should be involved in
the computation of the code splits and
so Google closure actually you say which
namespaces and where they belong and it
has this really amazing thing called
cross coughs module code motion where
you may have a very large library and
you have two modules that depend on it
and what Google closure will do is it
will split the shared module and move
all the methods and all the objects that
to where they actually belong again
something that if you're not using
Google closure you don't have it and
close your script users have get this
for free so that's another reason we
like closure script because closure
script generates code optimized for
these optimizations it also supports
es2015 commonjs and AMD consumption and
that's really cool so I also think it's
really important whatever-whatever
client-side thing you're picking and
you're doing JavaScript your tool
probably needs to be able to consume all
these things it's a lot easier these
days with webpack which you might have
heard of okay so that's that's that
piece let's talk about moving data so
once once you've decided okay we know
we're having to render things we've
picked some client-side technology
whether it's JavaScript or something
compiled JavaScript then you're like
well we got to get data from point A to
point B there's actually not I'm
surprised there were there are really
not that many great solutions especially
if you want to go from the backend
directly into mutable data that's really
the only reason we created transit
transit when it got released got a lot
of sort of flack we were like why
another data format and we were like
examine the spate the the sort of the
space of options nothing exists to go
from a JSON representation directly into
something that can be that's an
immutable data structure so transit does
this it's pretty cool it leverages tant
transit the encode supports both a
message pack based encoding as well as a
JSON based encoding a provides richer
types out of the box so we have full
support for if you want to represent
64-bit integers you want to represent
dates there's no you don't need any
coordination between the back-end guy
and
frontend guy as to the date format right
we figured this out for you we encode
the date and we we transmitted to the
client and the client decodes the date
nobody's in the right hand you know hand
right date parsing code saves us a lot
of time and people the people that adopt
it love it you just don't get into these
error-prone how do i parse this
information it's extensible so like you
know XML kind of sucks but you know the
one thing we lost when we dropped XML
was something that was extensible so
transit makes it easy to extend you can
add custom types and people do this all
the time in fact that's I mean there has
to be the way our immutable data
structure support works and it's fast so
you know I've been spent a lot of time
doing JavaScript and I know a thing or
two about JavaScript performance so it
is the case that in closure script there
are many there we have especially
particularly v8 because v8 is really
good and their JSON parts is really good
we can actually decode an equivalent
transit payload into immutable data
nearly as you can
json.parse the same logical set of data
and that's because we have just the
encoding format that we use as well as
we have a caching mechanism which is
very good so you're not paying very much
over JSON which is important and there's
actually more caching opportunities I
recently wrote a blog post which shows
that especially for you is where you
will have shared shared portions of the
graph you might have shared information
like the value may appear multiple times
it's very easy to overlay your own
caching mechanism over the one that we
already have and that's because the read
the read and write on traversal order is
exactly the same and we guarantee this
so for example in like ten lines of code
I added my own caching object caching
layer whereas imagine I encode a
geometry point and the caching layer can
say well we already saw that this is the
second time you wrote it and it will
rate it'll basically write out a cache
and then a transits own caching kicks in
and then you get just this ridiculously
short thing so this is actually what's
going to happen on the read side when it
this gets read it's going to read this
object for the first time
and then it puts it into the cache the
next value it's going to read out the
identical thing and again the next time
so if your serializing values that need
to be shared which again is extremely
common in the UI case transit has a
really good story again because it's
extensible and it has sort of again
strong traversal properties alright so
hopefully you see the benefit of
something like transit if you're
adopting this so let's get to the meteor
part which is more radical this is sort
of like critiquing you know the way that
people this is really the part where
we're really critiquing the way people
build apps so you eyes are fundamentally
trees so having done UI programming for
a very long time having to deal with
rest endpoints really introduces
complexity into the client code because
often when you hit a rest endpoint you
have to hit multiple ones you have to
hit one and you have to go hit another
one and what happens is that often the
cases is that whatever comes from that
rest endpoint is not in the shape that
it needs to be to actually populate my
application so almost any app that you
see you have it you see there it's in an
undisciplined way hitting many rest
endpoints and then you have error-prone
reshaping logic to get it into the right
form that you can actually render so
this I think is not a good thing and in
fact it's such a terrible thing that it
does not might not even my own narrative
here Facebook and Netflix have both come
to the same conclusion so at react comp
earlier this year they announced
something called relay and basically
what they get to do now is the client
the person writing the actual UI says
these are the properties that I need
there is no rest endpoint no back-end
person says what's going to be in the
payload the client gets to determine
what they want and the structure that
it's going to be and they pass a
recursive JSON description of what they
need and the server simply supplies it
to them which means there's no reshaping
logic there's no for loops there's
nothing right you you request something
from the server and everything is ready
to go there you don't have to change the
structure of the data so if you've never
looked at reactor graph QL there's a
bunch of talks on it I highly recommend
it whether whether this particular thing
is the future or not
as I think is irrelevant I just think
it's a better overall design Netflix
came to all it came to separately
independently came to their own
conclusion and they have their own stack
to do this Jafar Husain at the ACM queue
conference applicative talked about
their thing called Falkor and Jason
graph and they used to have a restful
api they got rid of it they use the same
technique they basically the client gets
to aggregate a recursive JSON data
structure which represents what's needed
they pass it to falcore falcore is
basically a fan out fan in thing where
it's a router for each key in the json
data structure they fetched they call
the right micro-service and then they
compose the result and pass it back to
the client by by dropping their rest and
adopting Falkor they basically
eliminated 90% of their networking code
so this this is this is again going back
to if you think back on what I said oh
we picked the right data structure we
don't have to do undo/redo logic if you
pick the right data structure and you
give the server the thing and the client
just gets to get what they need you
don't need all this networking code you
don't need it it just disappears because
you picked the right design big ideas so
the takeaway here is that UI components
should be able to define what they need
whatever you're doing now is definitely
not the right thing and it creates bugs
it creates complexity use a recursive
description so there have been lots of
proposals and I think Netflix and
Facebook have come to the conclusion
that you don't really want some sort of
normalized thing sent to the client you
really want the client to just ask what
they want what they need in the shape
that they wanted and batching so that's
another thing that I didn't really have
time to talk about too much but both
Falkor and relays support batching so
you can have an arbitrarily complex UI
graph and what happens is that when you
make the first request basically all the
query pieces get filtered up to the root
and then then basically the root of the
application makes the request on your
behalf so components no longer ask get
to make their own requests so this is
the global sort of optimization idea
right every component has the piece of
the query they need you compose them on
the way back up you send one batch to
request on
that means that your app boots really
fast because you're only getting what
you need and it's really that simple
so just just to see a concrete example
because I haven't shown any syntax for
what this might look like I'm just gonna
show it a comic you don't have to use
the atomic but the atomic is it's a good
sort of like peek into what would this
look like so the atomic immutable
relational database it's got powerful
editing capabilities you can efficiently
query arbitrary points in the past it
has data log of Style queries which are
themselves data which is cool but I
don't want that's neither here nor there
the coolest part about the atomic is
support something called pull pull is a
is a recursive data description so here
us imagine I have an entity in the
database and I only want the artist name
and the artist year so even if that
artist has a hundred fields I can I can
say only pull this little bit and again
this is data this is not like a sequel
string and because this data it means I
can compose it easily in the same way
that could compose a JSON data structure
so here I'm asking I only need these
elements and so you could imagine I
could send this directly to the endpoint
that's gonna basically hydrate this into
a JIT into a JSON structure of some kind
but it can be recursive so here I'm
saying I want I want to match the media
and this happens to be an album for that
album I want all of its tracks I want
every single track that that that that
that album has and for each track I want
the name of the track and for each one
of those tracks I want all the artists
and I want their names this is something
that you that would be what I mean
number one somebody would have to write
this query which is like and then if I
need to change it like you'd have to go
back and rewrite that that joint here I
could express this in the client this is
what I said and I don't have to write
the for loop this is this is a very
complex nested query and this is I mean
imagine like this is literally every
iPhone app or every Android app that you
have right this is what they present and
instead of writing all this complicated
networking logic reshaping logic I
simply describe what I need and I can
populate the information how I want and
what's nice about this because
is data and data composes each one of
these fragments can be supplied by a
different UI component so for example
artist's name that could be the artist
view only the artist view says this
little piece of data is what I need
above him is the artists list and that
person supplies the the sort of map
structure and so on all the way up so
you can basically divide your query into
the components and it's really beautiful
and again that's that's definitely in
the realm of react and relay so if you
haven't looked at the relay graph QL
talk that that I think is a huge
revelation representing your query
directly on your UI components and
building them back up on the way out so
radical simplicity I don't have much
more to say I join I hope this has
helped you to revisit some of your
assumptions and biases you know really
rethink about any element of your stack
that creates complexity
I think rest is actually really cool and
it's actually a lot I think people will
see as they adopt stuff like this it's
not like you're in your gonna completely
get a get rid of react a rest but what's
gonna happen is that I think you're
going to dismantle the Church of rest
there are a lot of thing that people say
about rest that's just not true it
doesn't make things simpler and the
things that don't make things simpler I
think need to be removed and examine
unfamiliar but time-tested ideas for
complexity reduction even though a lot
of these things I'm saying might sound
like cutting edge technology a day Tomic
what is the atomic the atomic is
immutable like a mutable data right it
uses the same model as git git isn't it
a fairly old thing now it's query
language is based on data log data log
is from the 70s and you know of course I
love closure shrimp close closure clips
Lisp and Lisp is very old but a lot of
it again a lot of the things I'm talking
about are not as radical or as new as
they seem they're they're very they're
old pipe time-tested engineering ideas
so that's all I had
if you have some questions go ahead feel
free to ask them
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>