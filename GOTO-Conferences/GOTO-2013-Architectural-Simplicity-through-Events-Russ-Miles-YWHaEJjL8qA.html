<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Architectural Simplicity through Events • Russ Miles | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Architectural Simplicity through Events • Russ Miles - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Architectural Simplicity through Events • Russ Miles</b></h2><h5 class="post__date">2015-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YWHaEJjL8qA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name's Russ miles I speak regularly
in London and other places when I'm
invited and mainly my whole shtick is
helping people build software as simply
as possible and I have some very firm
ideas very strong ideas of what that
means and how to do it so it's something
that's become a very guiding light at
the moment because I think we've spent
last 10 12 13 years doing a really good
job of optimizing process but we've kind
of there have been a few standout
individuals moving architecture and
design and coding along certainly in the
craftsmanship area but I think we've
sort of we sort of left behind why we do
a lot of these things why these
techniques are important because they
help us overcome a particular enemy that
I'm going to introduce to you this
morning ok so what is the alternative
title for this particular talk it's
essentially approaches to dieting for
elephants in software now how many
elephants have you met in software very
few I imagine although you wouldn't have
necessarily recognized the particular
elephant I'm going to be talking about
this morning so what does architecture
mean to to me anyway
so I'm going to put across my
perspective on what architecture should
be and the common sort definition if you
ask a lot of people and I've asked a lot
of people in my consultancy what does
architecture mean as opposed to design
as opposed to code as opposed to
everything else we do well it tends to
be about decisions and there's always
this phrase that says it's about the big
decisions but what is a big decision
unfortunately I'm an amateur philosopher
so definitions are my thing and so I get
a bit I get a bit picky about big
decisions because that doesn't mean
anything everything's a big decision to
somebody having what picking what for
lunch is a big decision to some people I
would like to characterize this as being
the source of decisions that have a
significant scope that will actually
change a lot of people's lives ok may
make the difference between success and
failure and also being able to
understand that there is a broader scope
that potentially there is multiple
systems involved there's multiple
players
there's multiple teams multiple
stakeholders I can understand how we
might differentiate between a designer
and architect in those circumstances so
having awareness of all the different
facets of the system being able to step
back a touch from what's being written
in the code and submit an understanding
okay how do all these pieces fit
together where do things go so a lot of
work I do is architectural consultancy
essentially I'm not usually with a
client long enough it's not a bad thing
but I'm always there long enough to do a
huge amount of the coding for them
however I am there to make a big impact
a good impact hopefully to improve that
codebase and improve that architecture
and design so I'm there to help them
make the riskier decisions and to help
guide them in so maybe some tools and
thinking tools of overcoming those
decisions in the future so working
within that remit I'm really there to
help them build the right thing right
that's pretty much it okay I'm kind of
hoping they already know what the right
thing is I'm very careful here to use
right thing not right software I often
come in and actually spoken to people
about well why are you building software
at all you don't necessarily need it for
this problem I've had a look at it I'm
not sure you need it it's not always the
most popular answer but it's often the
case you maybe don't need software for
this so building the right thing or
doing the right thing the right way and
it's that last piece the right way that
I think most of us in architecture are
driven by is what is the best we can do
with what we have right now to deliver
what we think is the right thing okay
with this I'm going to try something new
please bear with me I'd like to take the
lights down if that's all right bit
further whoa hi how you doing I'd like
to tell you a story I'm even gonna take
the lights down on the slides okay I
apologize for light coming from the
go-to conference this is ruining my
stick right now I want that gone sorry
okay a story this is a story I'd like
you to take yourself
if you've got a bit of light in your
eyes check your eyes what we're doing
here is are taking you back to sprint
maybe 10 maybe 12 maybe 13 you're
standing there with your team teams and
a question comes up in the standup
someone turns around and goes what we'd
really like to do is reprioritize a
little bit we'd like to introduce this
requirement that's down here in the
backlog off in the ether wasn't even
thought about much we want to bring it
in now you are the developer I don't
care what you do for a living you're the
developer you're responsible for
building this thing and you have a
moment that moment is one of
unparalleled fear you start to weep
because that particular requirement is
one that you hadn't thought about it's
called change and it's different and
unnerving and you didn't think about
that yesterday
does anyone feeling slightly scared
because I'm a little bit scared of my
own voice at the moment so you've got
this thing dropping in your lap and you
and your team all are sharing your grief
because you know you know yesterday you
didn't consider that that wasn't
important yesterday you may have not
even been aware of it but now you have
to be and you have that moment where you
have to turn around and say the words
every developer fears it's not as easy
as their I know it looks easy
I know it's just insert whatever you
like there it's just moving the button
but that's hard and then you know you're
looking in the eyes of the person who's
just asked as they look at you with
utter disappointment can you feel it
and your next reaction is usually one of
defiance well of course it's not that
easy Wow yesterday we were doing other
things we were prioritizing other things
okay if you could bring the lights back
up I'll get rid of scary voice okay so
hopefully that's taking you to a place
and it's a place where I like to call it
there's an elephant in the stand up and
the elephant isn't necessarily entirely
your fault okay
the elephant is more about all of the
assumptions that you made in the past
all of the assumptions you made in
building your software in architecting
and designing all those decisions you
built upon such assumptions and you've
got to that point now where those
assumptions are in conflict with reality
okay so that's the elephant the stand up
that is the enemy okay we can be as
agile as we like we can have every
process imaginable but if we don't
recognize the elephant in the stand up
we don't realize it's there and it's all
the code we've written before then we're
looking for trouble and we're going to
experience that moment I hopefully took
you somewhat towards just a moment ago
okay I said I'm not a mature philosopher
so I wish start with axioms things I'm
gonna ask you to believe without
questioning me get out clauses yes okay
these are the sorts of things I like
only a build I'm building you up from
ground up here towards what the sorts of
tools I want you to take away your
software's first role is to be useful
anyone going to dispute it I have had
one was a very interesting conversation
it went on long into the night and I
still don't know what you're talking
about the best software is that which is
not needed at all
we could write less we should if we
could get away with less we should the
trick is figuring out when less becomes
problem so I'm hoping that no one's
particularly disputing this one now but
if we can reduce the amount of software
rewrite surely that would be a good
thing human comprehension is king it's
the one limiting factor to moving your
software forward is human beings being
able to understand what the heck it is
as I'm sure everyone's had that moment
where they turn up on the first day of
the job they're keen they're happy they
just got through probably a very
extended interview process excuse me and
they're there and they're faced with
their first day and looking at the code
and going I have no idea what this thing
does
and I have no idea why I don't know why
it doesn't I just don't get it
and there's nothing worse than that
feeling because that first day you want
to usually impress so human
comprehension is king it's the limiting
factor to an awful lot of software that
cannot move forward I've seen
multi-million pound projects created
because no one can comprehend the code
any more mechanical sympathy will know
the term akattak or sympathy
yes yeah that's Queen it's a ruler it's
certainly a ruler and some would argue
the most powerful but in my view of the
world it's slightly ever so slightly
potentially slightly secondary in a
patriarchal monarchic monarchy and its
job is to remind us that there is
another audience for the stuff we're
writing the architecture a building in a
design we're building software is a
process of slightly more controversial
of research and development okay is a
great tool coming up next by Neil Ford
on evolutionary software and design that
directly recognizes the research element
of this I think
we've done ourself a disservice cooling
software development just software
development it does sound like we're
just cranking the handle okay I remember
my first job I think I've told the story
couple times now but my first job when I
started in software development I was
brought into a company and they said we
know how to do software development
I thought brilliant I'm on day like I'm
21 years old
fantastic I'm going to learn everything
that's perfect the arrogance here in the
room was massive okay we know software
what we do is spend eight months
building a model and when you hit use
your mail I've written a book on it so I
have to stick my hand kind of high I can
also apologize we do UML from eight
months and then and I kid you not the
reaction the actual body language at the
end was then we just crank the handle
and build it do do the code for one
month and we always deliver on time into
budget now I was too young and naive to
smell the distinct excrement in the room
but I can I can honestly say I spent
eight years with that company probably
far too long best when eight years been
in that company and I never saw a
project deliver let alone on time into
budget it is research and development we
are dealing with unknowns even when we
think we're dealing with knowns we're
dealing with unknowns and if anyone's
seen anything by Dan North recently on
deliberate discovery and let's work on
this these are attacks on the fact that
we don't know what we're doing it's
research and development and when you
consider it research an development you
approach these problems slightly
differently and I like this one because
it kind of kind of flatters our egos
it's an extremely challenging
intellectual pursuit how many people do
you know that go to work all day and
come home at the end of it and have no
idea how to explain what they did to
their spouses or anyone else in the room
and we all use labels for this I'm an IT
consultant can you fix month no I can't
fix your PC I've even gone to analogy I
said I'm like a Formula One car designer
and you just asked me to look at your
Fiat Uno to see whether it won't start
in cold weather it's an extremely
challenging intellectual pursuit what we
do is come up with something out of
nothing and we try to understand other
human beings which alone is hard
whenever we try to communicate with
anyone else that's particularly apt to
this talk we're sending all sorts of
events and we don't know what we're
sending half the time if anyone's ever
been to marriage counseling you'll know
what I'm talking about
okay moving on simplicity if I have
other stories when we go to the bar
later you'll find them out simplicity
what does it mean for this well my
proposition I suppose is that we should
be concentrating on how to build
software that can adapt okay I don't
mean configurable software that kind of
got a different reputation about sort of
seven and eight years ago configurable
software was always I want to build
something that I can change either at
runtime or close to run time and maybe
flips features on and off and all that
sort of good thing anyone knows whenever
you do that the complexity goes through
the roof and it's a nightmare and no
matter what technology we apply to it
whether it be configuration from spring
or aspect-oriented programming or any of
these other things it's always difficult
and it also gives anyone involved in
testing an absolute nightmare I'm not
talking about that I'm talking about
building adaptable software that helps
you deal with change helps you deal with
the known unknowns and unknown unknowns
and all the other ones that Donald
Rumsfeld talks about because that's what
we do that's what I'm putting to you is
we're doing research and development so
we need to adapt back in the day all of
our agile processes were about being you
know dealing with change embracing
change was the tagline and I think to
some degree we've started to do that but
we still got a lot of work to do when it
comes to how we architect and design our
software one last thing why don't we
just do this what it sounds a little bit
like a no-brainer right surely we never
build complex solutions right you would
always do the simplest answer to a
problem right well apparently not now
this is an odd slide to put up Michael
Jackson not this one
wrote a paper on why we don't do the
simplest thing as human beings
particularly as developers so you won't
want to shout out some of the reasons
why we might not change changes pilot
James does drive a more complex answer
to what could be an oversimplified I
would argue oversimplified yes absolute
and passion patch oh my goodness what is
this thing yes moment absolutely
absolute change itself is a complicating
factor yes absolutely not the reason we
do it ourselves though we actually
there's two types of complexity
intrinsic is I know mentioned what's
already in the problem and extrinsic
everything we bring to it those patches
are something we bring but we might be
able to if we consider things a bit more
avoid some of those problems that we
bring why don't we any ideas I know it's
early on the first day and there's no
beer in the room yet okay well one of
the answers I've come up with is
potentially ego right maybe we're just
kind of invested in doing the
complicated answer it turns out it's not
that simple it turns out we're bored
we're truly bored by the business
problem the business problem is not as
interesting as the business thinks it is
and we're looking to express ourselves
so whilst we're bored of your problem we
do know ways to make it interesting
and one of those ways is to come up with
a more complicates the reason but when
someone sits there and goes I've got
this spreadsheet of data and I need to
apply these things to it to get this
other answer and there's maybe a few
spreadsheets and it's ok it's the reason
we don't sit there and go write a word
macro and tell Excel matric macro that
could do that in five ten minutes or
I've been meaning to have a look at
Scala and I've wonder how it
interoperates with Python so instead I'm
gonna advise you the best and this isn't
a conscious decision we're not being
slippery here what we do what we're
doing is naturally making something more
interesting for us because we do we want
to care anyway this is what we fit this
gentleman found out an optically this
one but Michael Jackson found out that
his evidence supports that we do what we
are bored by the business problem we
would like to do something more
interesting please so we have to fight
this ok you may not be aware you're
doing it you may be one of the few that
don't but I for one certainly do when
given an option yeah yaa
who does it who's a complexity a addict
stand up there we can do that later on
the bar ok so yeah we are addicted to
this sort of complexity it's it's not
it's not something we consciously decide
upon so we need some techniques to help
us fight it ok so what does it mean to
architecture well it turns out
complexity is particularly nasty and has
the ability to really hog-tie things
when it comes to adaptable software when
you have the bit the slightly bigger or
should I say more insightful decisions
to be made so I'm gonna tell you little
story of the relationships I component
it wants freedom to express itself we
have a component in our system it
doesn't know where it's going to go yet
bless it it doesn't know what its
purpose in life necessarily is yet
although it has an idea and it wants to
be able to do its job well
ok we've all come apart across in
producing a new component whether we're
doing it in PowerPoint or whether doing
an actual code but it doesn't want to be
tied down okay a new component the
system doesn't want to be tied into the
system too much doesn't want to end up
have being restricted later on in life
it's kind of like a windy teenager you
know life's a bit unfair and it doesn't
want to make a commitment just yet and
it's very it was freedom to move around
even though you know that might be
tricky and it definitely doesn't want to
make a commitment okay so what it really
wants is to be movable removable
substitutable combined able and
extendable so when anyone got a teenage
daughters or sons no say I can't wait
until I got like a four and
five-year-old I'm waiting for them to
get there so I can say this is what you
want then and what I want is you to be
clear comprehensible and understandable
because it's certainly not so this is
what we also want in order to enable
some of these things we need clear
comprehensible understandable code base
and we've done a lot of work along those
lines but architecture has a huge part
to play here and I think architecture
needs some help okay
we need some principles as a start which
I call or only because it makes a word I
could have chosen other other words that
were been equally as good essentially
what we have is organized reduce and
encapsulate okay first of all we cannot
we need to organize our thinking and our
architecture and design as much as we
can and we need tools to help us
organize because the load of tools we
have right now are poor in fact we're
part of the problem ourselves if it was
ever prepared a PowerPoint presentation
of extremely high level concepts the
sorts of thing I call it bid we're so
sorting you put into an organization say
I want to do a project here's this and
then it becomes the real-life
documentation your system because it's
not it's devoid of all reality the
software never looks like that but some
for some reason that still exists at the
end of the project
so we need tools throughout us to
organize tools help us to reduce the
amount of software we've got but do it
intelligently because if we reduce too
far we end up with problems and we also
need encapsulation so first let's look
at organize organize is simple where
should I be as a component where should
I go it's kind of amazing to me I'm a
and not inexpensive consultant so most
of my life consulting not on stage and
as a consultant I get I was getting the
same question over and over again where
do I put my clasp not always in a deep
voice but you know where do I put my
clasp where do I put the tests
associated where do I put things and I
would look to the architects involved
people who you know had the role of also
understanding the bigger picture to some
degree and they didn't really know
either they all had differing opinions
you should sort of put it in a package
like this has anyone ever created a
common package or utils that's the other
one yes leave these packages should have
a different name big bucket of stuff we
don't know where to put or worse stuff
we might use in lots of places don't
know where yet we're good intention
right so that's the latter ones are
slightly better intention then they know
where it goes maybe it's common so where
should I go is one of the first problems
and so at all that helps us understand
where things go would be very useful it
turns out a lot of the answer was
already there and I was not blissfully
unaware of it so you want aware of
hexagonal architecture the view of
hexagonal hexagons right cool
they're round for some time in fact 2005
as the code was talking about it writing
about it telling people about it and
promptly seem to get nord so I'm hoping
that's not a trend and so I want to talk
about it again because back in 2005
certain people were just learning to
drive Alonso was I think one Formula one
probably not okay this man was
champion hasn't been since and the
problems seem to be caused by this idea
that software was layered okay so is
anyone ever drawn the typical enterprise
architecture diagram yeah right we all
know it without me even describing it
people know what this thing looks like
okay yeah you've got this claw cake
right the bottom layer is stuff
infrastructure stuff the next layer is
repositories because we kind of know
that in DDD we should use that word and
then there's services which is business
logic and then on top the candles are
things like web services web
architecture and I have to hold my hand
up here and say I did this - ok I still
used to deliver courses that use that as
the view of the world and the problem is
no software I've ever written actually
follows it ok it certainly doesn't help
me make many decisions my decisions as
I'm developing my software and the
team's developing software where do my
components go if they've got these
responsibilities where do they live
layers don't really help at least they
used to confident these to go to
conflict because then they'd just be
this other layer which kind of ruin the
cake analogy which was domain objects
we've seen the bubble through the whole
lot and then someone would say well we
need separation of concerns then look at
going how can we have separation of
concerns when we've got domain objects
everywhere they're not separate from one
another at all ok so I started to look
at other tools because I couldn't use
that diagram to help people understand
where to put their components so a lot
of noise I was getting on site I would
prefer someone to have the tools to
think for themselves and layering didn't
help didn't even help when it evolved
into the next level of diagram which
affectionately I got I cannot take the
name for this one someone came up named
the Snowman pattern ok the Snowman looks
a lot like the layer except they sort of
shortened it up at the top so you got
three
but instead of integration happening
through the database or something
horrific like that integration was
happening at the business layer sort of
these arms are coming out from the
business layer they look just like a
snowman the way they drew it but it
still didn't help with my answers okay
it still didn't help and I think
layering itself was part of the problem
it didn't help with not only did not
help with where my component goes it
didn't help me handle what something I
was recognizing as being the major force
against adaptability in my code which
was entanglement and coupling coupling
in particular I wasn't forced to ask the
question what components should my
components depend upon and use layering
didn't help me with that it tried it but
some boundaries in but it wasn't enough
within a layer I could do pretty much
what I liked and I didn't like that
because I knew I could make bad
decisions an entanglement was like the
worst version of coupling where there's
so much bunched together that any
adaptability is gone the analogy I use
which is where most software I've
encountered ends up is this idea of if
you've got a bucket of Christmas tree
lights okay some are attached some are
not you want that one in there or you
want to remove it or change it so you
put your hand in you pick it up and you
realize you're taking the whole bucket
with it there's is this cranny of lights
it's a little touch so you've for CH
initely you've picked one of the ones
that's entangled with everything else
you have already encountered this I
could almost guarantee it have you ever
done a change to your code
who writes code by the way who's doing
writing code every day roughly not
Saturdays and Sundays I let you off that
okay cool
excellent okay so in terms of ideas
who's using an eclipse variant oh good
okay and IntelliJ thing okay cool
roughly balanced okay both tools do the
same thing roughly when you go ahead and
change piece of code making a small
change right
those things have could you just change
this and you end up with 20 to 40 files
changing now
we're lucky we've got refactoring tools
in our IDs but what that's actually
showing you is what Fred Brooks would
have called the ripple effect you've
actually identified a problem in your
code base but it's okay because the IDE
is helping you with it so you could see
entanglement try changing something and
see what happens try moving something
around or repurposing something see how
many files need to change and where they
are okay
so Alice is thinking at least how I
summarized it in my own head is that
your application or your component or
your system is an island it has its
world it has its palm trees and it's
grass and there and everything internal
and core to it and then it has pretty
much everything else it has to work with
the surrounding worlds ok now when we're
building systems one of my jobs this is
an integration developer one of the
things we consider are what are the
touch points between systems because
that's where most friction occurs we
call it you know evolutionary friction
between systems two systems need to move
forward at different rates we need to
think about the glue between them right
glue by the way is a terrible name for
this because if you put glue between
them what it does is break so you end up
having to consider all sorts of reasons
why these things need to be loosely
coupled if you consider your we're sort
of already familiar with consider our
applications as Islands but I put - you
think of your components as islands how
easy is it for your how much does your
component know about the other
components it works with it because the
more it knows the harder it is to move
remove extend etc
and part of this idea from Alice there
was this idea of ports they were sort of
abstract ways of getting off the island
okay ports were there to support the
challenge of integrating with something
else and inside a port there would be a
number of adapters whose jobs were to
take the outside world's view of their
world and made it your view of your
world okay all about loosely coupling
these different systems to support
system evolution now what we need to do
is now quickly move on to to 2012 where
this guy was winning everything again
and again and again and he's gonna do it
again there's anyone German in the room
I bet you guys aren't booing him and I
think we should be either anyway 2012 in
complete isolation I was sitting in a
room deciding how the heck I tell people
where to put components or how I give
them tools to think about it and I came
up with the life preserver not my name
again I'm rubbish at naming things I
never named anything even my children
the hive preserver it really wouldn't be
good but yes that's not a great child
name now to be fair but it's a great
name for what I'm gonna show you so a
life preserver was almost another
picture that look very much like a
hexagonal architecture but I'd smooth
the edges off it was a perspective at
all an approach okay so his perspective
it's it very analogous to hexagonal
architectures it was at all because what
I did was draw it on a wall and say to
people if you want to know where your
component goes where your thing goes why
don't you go to the wall and try and put
it somewhere if you find you can't
easily put it somewhere maybe you need
to split it in the first place
consider splitting your component up so
it's all those three and this is what it
looks like now I'm no designer
developers should never draw anything
other than on whiteboards and most of
mine are done on whiteboards and it's as
simple as it looks
okay do I am i creating component
that goes in the middle of my world am i
creating a component whose sole
responsibility because it should only
have one is to work with the outside
world and that's a decision between core
and integration the next question is how
do these two views of the worlds or
these different worlds interact because
I want this software to be adaptable I
want to be able to change components in
the core without seeing a ripple of
effects around the different areas and
domains in my integration circle okay
but I managed to organize and visualize
this way and if it was interested in
seeing a bunch of real life preservers
from different projects I can give you
some anonymized after the session so
it's an implementation of the hexagonal
and it helps me understand my core
literally I could watch people get their
component talk about how many
responsibilities it had hopefully one
and then go to the board and go oh yeah
this is totally central to the world
this has no knowledge of the outside
world this is purely about us goes in
the core or this goes in the integration
because it's only job is to glue with
the outside world
you could ask Who am I peer group do I
sit with a bunch of other components
that do notionally roughly the same
responsibility if I do I have a domain
okay so I have multiple domains inside
the core of multiple domains around the
integration circle as well so
organization was beginning to be done
then the question arose how old do
domains talk to one another
where's options the simplest option is
to use something like dependency
injection to provide components to one
another so they are unaware of each
other's implementation at least but this
talks about events and for good reason
because I wanted to produce things down
I wanted the responsibilities to be such
that each domain didn't need to get too
bogged down in everything else that was
going on around it
I desperately wanted to reduce
entanglement because life preserver
helped people organize their components
it didn't stop people entangling
components I still could end up with my
Christmas tree lights out of a bucket
and I wanted to reduce the concerns as
well I wanted people to ask why is my
component there at all in fact what I
found was components ended up being
almost functions in this world and so
one interesting side effect is of
applying this this strategy people end
up doing functional programming without
knowing it and I think that's wonderful
because one of the reasons for
functional programming is to help us
write better more comprehendible and
more adaptable software that gets lost
in strange easier Turek discussions
around what is a monad and what isn't a
monad I don't think that matters so much
what matters is can I change my codebase
extracting side-effects one of the
questions you get is where should state
manipulations sit where should database
manipulation sit where do these things
go they go in the integration domain
somewhere in the integral integration
segments that's where they go but I'm
still concerned about coupling I was
concerned about coupling because one of
my goals is to make it such that people
can use different languages I delivered
a talk this year at go to Amsterdam on
using different languages source sneaky
little techniques to get new languages
into your architecture ahem and very
simply if your components are small
enough and single purpose enough then
you can do like what I call lunchtime
spikes at the end of a lunchtime you can
say does not does this component look
simpler I've written it in closure
sometimes you'll get a positive answer
all the times you might not but at least
you have an opportunity to try if the
components are too big if things are too
entangled then you can't even attempt to
use other languages because the decision
name becomes is everyone going to learn
this language or not and that's usually
a well not or if it's yes you're lucky
an entanglement came in nasty ways
coupling came into nasty ways what I
asked myself was and when I asked the
team's to ask themselves when looking at
components and the interaction between
components in different domains on the
life-preserver because you can see the
lines across what do they need to know
about each other these two components
okay
just that simple question was key what
do I need to know for these two
components to interact what do they need
to know about one another so one of the
things I always disliked was the method
name why do I need to know a method name
I want to send some information to
another component I need to know its
identity in java land and i need to know
the method name that's coupling because
of those things change i changed there
we go we are back ER refactoring change
hell oh by the way i should talk about
my opinion about refactoring i think
it's a wonderful technique that is
massively abused by almost everyone has
anyone ever and but you don't have to
eat your hand up because this is
slightly embarrassing anyone have a
venous stand up they said yeah we need
to do at least a few days of refactoring
to improve the code base there
that's not refactoring that's a redesign
you don't use the word redesign because
that sounds embarrassing it sounds god
I've got it wrong whereas refactoring
everyone sort of recognized as being
improvement ok another phrase is we're
going to alleviate or pay back some
technical debt yes we've made decisions
yesterday that are hurting yesterday
redesign ok parameters are another level
of coupling ok so when I was building
these systems and helping people
integrate these different domains the
first thing we tried to weaken was
method names themselves why do I need to
know across domains right two components
discussing and working together what I
need to know the method name well maybe
I don't maybe I could put a component in
the middle that basically decouples the
knowledge of the method name the next
thing I looked at is when we're sending
stuff back and forth between these
components parameters are a bit of a you
need to know a lot about parameters you
need to know the type you need to know
the order you need to know if there are
any default values
or appropriate values that need to be
present you need over there constant or
not there's all sorts of rules to
parameters so what I did was say well
can we reduce things down to one
parameter we just pass for what sake of
an argument add eto which again isn't a
pattern I don't necessary believe me but
let's take a component that just
captures some data and pass it over and
then the only thing we have to agree on
is that component and we don't really
have to agree on that because we have
got this intermediate component that
could translate okay so we a new domain
appeared where we had the integration
domain and we have the core gluing
everything together became the glue
domain oh yes my name is awesome which
eventually someone turn around and when
we got there and called it something
else which is good but eventually it was
the glue domain as soon as we realized
that reducing parameters and ordering a
parameters and reducing that cognitive
overhead that people have to consider
when these two components need to invoke
one another we ended up with for all
intents and purposes events we were
passing objects between components and
returning objects sometimes okay it was
such a small step but asking the
question what do I need to know 22
components was the big step okay because
everything I need to know between these
components stops them being movable
removable repurpose of all extensible so
sustainable whatever the last one was
okay so what we ended up with at first
was a bunch of objects that became
events right if there was some type
events that's what we had and we renamed
the glue domain to the event domain some
clever folks decided they might call it
the event bus as like bus I would never
a thought bus could be a word that would
make people nervous but it does okay
okay we're quite the event domain
because then doesn't have to be a bus in
there alright okay so an event domain
and so we we decoupled our components
such that the only agreement they had to
have was that there were these types of
events
we're gonna be received and emitted from
either end of the of the link and we
decided those things should be immutable
because that was a good idea frankly we
didn't want we didn't want questions
around what if this component over here
changes the event and what order is that
event being passed around to other
components so to get rid of all that
noise all of our events are immutable
we're still in Java by the way nothing
fancy happening we started to look at
temporal coupling between domains do we
need a response or do we what we were
actually doing an asynchronous dispatch
then what asynchronous we could make the
exchanges between the domains the more
complexity we brought in so we're very
careful about how much temporal
decoupling we introduced by using a
synchronous features but where possible
where appropriate we could and again
that knowledge was constrained within
the event domain with the last thing
that we started to question was this
knowledge of what type the event is now
this is where it got controversial if it
hasn't already we were looking at what
needs to be again what needs to be known
between the two components so now we've
reduced it down to the fact that its
component a is going to create a type of
event and component B is probably going
to receive that type of event doesn't
necessarily need to but something needs
to understand either that type of event
is sent all the way through or it is
translated and so what we saw was there
was still some ripples in our software
and worse we saw there was still some
ripples across domains so that life
preserver was are actually like our
checks and balances we did a refactoring
in our code base and the life preserver
matches the code base that we had so all
the domains end up being packages if you
saw a leaps between packages of
refactoring actually changing things
then we knew we well we could possibly
do better and so what we started to look
at beyond immutable events was starting
to pass where it was between domains
immutable data in the state this reduced
what needed to be known between two
components quite dramatically but with a
cost so I put it to you assigning to
consider but not for every component
your system okay what we were doing was
passing documents of data data
structures okay lists hashmaps
essentially Maps sets between components
and what was happening is the receiving
component that was receiving its data
driven event was looking at data and
applying pasta's law to it
so postres law is a simple thing of
saying well you might you've noticed it
yourself you get a letter in the post
and it spells your name wrong you don't
stop reading the letter okay it's still
addressed and it's probably relevant to
you it's just probably written by some
insurance company that hasn't got a clue
you are really but knows you pay your
premium so you get a letter and you
don't immediately validate it perfectly
and ignore it if it's not perfect what
you say is I'm looking for information
in this letter that's arrived to me this
event and I'm looking for what I can do
with it
okay so we were writing components that
could take data structures and flexibly
look for the data that was important to
that component without absolutely
stating it has to explicitly contain
everything that we could possibly ever
imagine one of the phrases I like for
this was coined by martin fowler and i
think it's used in his book and then no
sequel distilled we talked about
explicit versus implicit contracts okay
this is saying that it between some
components the contract of data exchange
was implicit okay both ends still had to
agree a little bit right so you couldn't
send garbage to another component and it
would just magically know what to do
with it but there was some implicit
agreement between components because we
wanted to buy that
moveable moveable characteristics at
least between domains and it was
postures laws in from the implementation
that we applied to do that which was
take whatever we get try and do
something useful whether if we can then
send something we think is perfectly
valid back out how many people who have
implemented document based Web Services
Wow okay
some people have avoided a landmine
that's good and that I've done if he is
the whole idea is you're passing
documents okay and you in you have an
option to implement postures law to
deliver very flexible web services okay
but it is a trade-off right you could
just validate when document comes in and
say it's not quite right off it goes
which would be which would be easier or
you could try and do something with what
you get because it might contain
information you need which means you
don't necessarily need to update when
whatever the document gets passed in
changes so what pastas will buys us with
a trade-off is the ability for our
components to change in relative
isolation with one caveat your testing
will need to improve probably okay
because of different flavors of document
that could be passed into those
components are now many many more than
they were before okay it's not
necessarily the end of the world though
if can feel and unnerving at first but
what you're doing is remember you're
doing this between every component your
system you're only doing it between the
components that are talking across
domains so that's not every component by
any stretch its way you really want that
loose coupling you want that lack of
entanglement however even with all this
being applied to the architecture and
design of this software there was still
a problem okay intradomain duplication
okay
people were applying the dry principle
between domains
the challenge here was suddenly I
components in multiple domains that
depended on one another because of the
implementation okay so I'll just put it
you to be aware of it because even with
everything I've said so far this is a
nasty little insidious one under the
under the hood whereas inter domain
duplication is okay it's okay to have
two components in different domains that
actually look very very similar they're
just in their own worlds and with
something like the life preserver you
can start to see where the worlds are
rather than the layering which just had
very very brutal strange worlds okay so
what we ended up with on the end of this
journey this real world journey that we
were working in is moveable removal so
substitutable combine all an extendable
code that was clear comprehensible
understandable and could adapt and does
adapt even today and it's easier to
strangle I'll leave that with you okay
hello that's kind of good anyway if you
see hitta strangle because of that
removable piece okay if you look up
martin fowler's Strangler architecture
and ster angle application this idea
that you can remove things right and the
hardest things in our software is
removed taking stuff out safely what we
found was by applying these approaches
to building if gradually moving towards
using events and looking at different
areas these events should be used we
ended up with a software that could
adapt and we could have end up with
components that could be strangled okay
so summary simplicity helps with the
elephant in the standup apply or it's
really simple it's nothing dramatic it's
just a lot of brain power applied to the
problem and realize that organizing and
reducing encapsulation so organize your
domains organize your components reduce
them down to the bare minimum and then
encapsulate where there is intrinsic
complexity has to be there encapsulate
it effectively we use a life preserver
to organize and that is on four
a life-preserver of sorts it's when I
use one of my training courses and these
are the characteristics you're looking
for okay move will removal substitute
will combine extend all I couldn't come
up with an acronym if anyone does
maybe there's something in Danish clear
comprehensible understandable because of
the humans involved and we are the
humans involved events decouple and the
more adaptable your software is the more
chance you have of winning and the more
chance you have of not having that
moment and stand up where you go it's
not that simple thank you very much for
your time this morning I hope you have a
great conference maybe see you later on
in the day and I'm speaking again on
Wednesday as well I've got a lightning
talk so that'd be fun thank you very
much
so we had two questions coming in and
I'll let rust choose which question to
answer
okay I'll take I like both of them so
I'm doing both quickly right can we
measure simplicity how do we do it
simplest method method I've got for
measuring simplicity if it's not
circular referencing is to look and
count the number of things someone needs
to think about when they're looking at
the code literally count them okay and
you'll find there is an objective number
to this so look at the code and to ask
yourself and look at the component ask
yourself how many things is someone
having to think of and ask yourself when
you're invoking a method how many things
someone is having to think of you're
trying to reduce it down to as little a
numbers number as possible it is an
objective measure okay if it wants know
more about it there are other measures
as well that's my favorite isn't event
types just a name for method names yes
and that's what we found is that we were
raising event types and we need to know
a lot on either end what the type typing
information was so that's why we reduced
it down to data and passing data
structures there's always something that
needs to be shared there's always a
contract that needs to be somewhat
honored what you're looking to do is
weaken that contract enough so that in
the eventual atiim adapter adaption
being required evolution being required
between the two components things are as
easy as possible at that point just
asking you to think about that even
inside your software okay thank you very
much I will be hanging around for the
rest of the conference pretty much part
from a bit of Wednesday where I'm
getting a flight please go to a talk
tomorrow
Joel Jacobson is talking about I believe
something to do react he I love the guy
he cracks me up and make sure you've got
lots of complex questions for him he's
an old friend</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>