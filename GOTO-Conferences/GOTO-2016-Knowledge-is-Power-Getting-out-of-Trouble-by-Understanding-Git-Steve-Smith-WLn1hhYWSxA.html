<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Knowledge is Power: Getting out of Trouble by Understanding Git • Steve Smith | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Knowledge is Power: Getting out of Trouble by Understanding Git • Steve Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Knowledge is Power: Getting out of Trouble by Understanding Git • Steve Smith</b></h2><h5 class="post__date">2016-10-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WLn1hhYWSxA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so knowledge is power understanding get
okay so one of those things where you've
you saw everything are that the hang of
get and then you do something and it all
goes horribly horribly wrong
so this is where the point of get where
you have to learn a bit about how it
works underneath the hood to truly
understand it it's got very leaky
abstractions and you need to sort of be
able to understand those who really get
work done see the problem is there's two
ways of learning gates one is from the
bottom up and then people will say
things like this git is fundamentally a
content-addressable file system yeah
that's great
there's also bugger all use if you
actually just wanna get your work done
on a day to day basis you work you you
some B's come along said we're moving
some flux subversion movin CVS we're
moving into gate and you will know what
do I actually do what is the equivalent
of SVN checkout and what does he
couldn't of SVN commit things like that
and so this content addressable file
system acyclic graphs all that crap is
of no use to you at all
when you're trying to get work done now
at last year I was at git merge in
France along with a github who spiked me
or you may have heard actually lacking
get get up get on quite well a personal
level we suddenly go drinking a lot so
but it's get much Emma Jane has been
wispy great speaker if you get the
chance of Seir do I recommended we
actually didn't in the pulling her along
to all of our I'm Alaskan events because
she's really really good has interesting
insights but she works a lot in
educating people about has learnt about
how to learn get not and she comes with
me very much the top-down point of view
people will get their job done here's
how you get started here's how you get
you get your code out here's how you
commit his little gotchas like the state
the staging environment and stashes and
things like that this is the list of
direct acyclic graphs is no use to you
at that point however after a while you
start getting a bit more confident after
while you start building real things and
get you start actually seeing it oh yeah
I can actually do this I've heard about
this gig gets reset I've heard about his
guidry rebates
sounds great I'll use that and that's
when things start to go horribly wrong
even the simple thing the things that
get is really really good at like
branching and merging can rapidly get
out of hand this by the way this is not
a nightmare scenario this is actually a
recommended workflow I shit you not do
not do this okay start the bots are very
simple one branch one merge if you need
to get more complicated add on top as
necessary this is your this completely
out of control
but thing is you start getting to this
or scenario that kind of clone versus
commit versus you know stash and all the
rest is not re going to help you very
much at some point you're gonna have to
get untangle this mess and then there's
gonna be some guy in that organization
who has to understand get so presumably
you've all seen this xkcd comic from a
couple of months ago well for that year
ago now if it's basically true very this
basically most will get to this stage
where they go Donna says anymore and
they have just blow it away and star
starts again could have got into such a
complete and utter mess now you're also
if you if you know xkcd there is the
hidden text in it as well there's always
that one guy he will wash shut up but
he's really really useful you have a
looking for oh yeah yeah yeah what
you've done is you've rebates but you
haven't you haven't reset before you've
done that so you can working directory
is now out of sync you've done a git
rebase
soft is it a risk git rebase hard etc
etc you know sorry reset soft reset hard
cou even I'm doing it
eventually you'll get what you need to
do the thing is this guy doesn't know
what those commands are the secret here
is the commands I mentioned there he
doesn't know that they exist he's
assumed they exist because if you
understand the underlying model of get
from the bottom up you will know what
commands must exist logically to get you
out of trouble
you assume if I know that get model
works like this then there must be a
command that makes it do that
I wouldn't off and find their command
and later I'll show you literally a
real-world example
or how I did that when I show you with
that that one weird trick that every
talk has to have now so where further
ado we're going to move on to get
internals and hopefully by the end of
this talk you will be that really
annoying guy in in your team the one who
understands gating gets people out of
trouble which is really good job
security by the way so well further ado
get internals let's start right down at
the bottom we're gonna we're gonna go
back about a cyclic graphs yet we're not
gonna go on about content addressable
file systems I'm gonna show route rather
than tell I'll tell you later don't
worry at the bottom of the stack that is
get is the blob that's really everything
these blobs all chained together at the
end of the day now what's in the blobs
changes so it's kind of its contextual
but the bottom level everything is a
blob the simplest blob is the content
something that is essentially a binary
blob that git has no idea about now that
includes text files
he does have no fundamental awareness of
text files at its lowest level higher up
when we start looking at things like
merging yes git will understand that
certain things to text files and it will
understand how to operate on them but
its lowest level it doesn't care
everything is just a blob a blob is
nothing more than the contents of a of
an object its compress said lib
compressed it has a header stuck on it
just to help identify it on the file
system if you do come across a road one
and then it is hashed there's a sha-1
hash and that identifies it that's kind
of the way the content and restful
fascism comes in but we will get to that
don't worry about the next level up is
the tree a tree is also a blob but it's
a blob way get understands what the
content is and in particular tree points
at other blobs and potentially which
could be other trees and it gives it
additional metadata to say there's no
farm aims associated with these blobs
the tree gives it the farm name now
trees can point to other trees or they
can point at blobs and they can give
them names they can give them a
additional method date data such as file
permissions whether it's executable or
not this looks an awful lot like a UNIX
recursive file system which is not
surprising given it actually written by
a UNIX kernel developer and at the top
level we have sang call to commit a
commit points at a tree well we could
point to the blob
usually will point at a tree but we can
we could manipulate this any way we want
so commit points at a tree and battery
defines a set of objects now the fact
that there's no file names associated
with low-level blobs what we talked
about contente it's a file system and
I'll show you that now so let's go let's
just do this let's show this from the
ground up we're gonna just go to the
command line and do git init getting
this gives you an empty git repository
now it does actually create a bunch of
additional boilerplate that isn't
important and has no role initially
which I'm not gonna you know brush over
that now because it's not not important
it creates a bunch of dummy hooks so you
can in a enable if you want but we don't
worry about that and it's cool a gator
nest creates a completely empty
repository of nothing in it so if we
look at the there's a and as you
probably know the inside the git
repository there is a dot git directory
and inside there is all of the
information about your repository the
sort of the outside of that your actual
files what's called a working tree when
it looks inside that and rebuilds the
working state of any given commit
however that is really additional you
can wipe all that out and just pretend
gets to reset and it will pull right
information out again so the real
information is stored inside the docket
directory inside the docket directory is
a directory called objects and this is
where all of our blobs are stored so
let's get in there let's add a mini
placing creating some content for git
by the way if you jump back a bit so
they get in it's obvious but tree is
just a command that is will do a
recursive listing of a directory so this
is just showing you via the coloring
that there is nothing in these
directories these are two empty
directories info and pack so we're gonna
do two more come
touch touch in UNIX world could mean two
things it's over updates at the
timestamp on a file or it's a convenient
way of creating an empty file if one
does not exist so going to create a
completely empty file called some file
and then we're gonna add it we can say
get please track this file don't commit
it yet just be aware this is something
we're going to want changes to be
tracked in and then we can let's go back
and have a look at our gates objects
tree as you can see there is now a
single object in there it's said live
compressed it's sha-1 hash and a sha-1
hash is used as the file name that's not
the files file name the files file name
is some text or something like forget
what you said but as you can see we it's
inside another directory a6 that's the
first two digits of the sha-1 hash the
rest of it is the remainder of the sha-1
hash the reason it does that is to
spread the load out across the directory
system
Robert having one directory with all the
files you have 255 directories with the
file spread out across them that's
really it's the local filesystem
optimization and not particularly
important you could do it you could
implement it differently if you so
desire that's so important but we're
gonna do a commit we want to say well
now we've got this state we've put this
file in there that's empty and we're
going to commit it so we'll just do a
git commit with the first commitment now
we have free objects in free blobs the
first one is the is our object our empty
file the second one is our tree and the
third one is our commit this is it this
is the lowest level now interesting fact
can I talk about content-addressable
file systems that blob is of an empty
file now I go to another completely
separate repository and create another
empty file
what will our hash be it'd be the same
if I create another repository another
file in this repository is empty and I
could I I add it what's going to happen
it's gonna be the same anywhere in the
known mathematical universe where the
laws of maths apply or laws of physics
apply any empty file in a git repository
will always be that and that is what a
content-addressable file system means it
means any object anywhere in all in the
universe that has the same content will
have the same hash against it we can add
additional metadata data on top of it
with that's all in the trees but the
objects are always the same if they had
the same content to them so in summary
that is get in a nutshell at its
simplest level so it's not that
complicated with one little caveat
commit scan points as trees commits
could even point directly at objects
they are used sometimes in that way
however they can also point at other
commits so what we have here is commits
can point to other commits which point
to different trees which point to
different objects and this is the
contents of your repository changing
over time so this really is the core of
get everything else is built on top of
these basic abstractions and I'll sort
weekend in a minute we'll build our way
up that tree and talk about some of the
high-level abstractions but this is why
that person can sue that person in that
text file you can say oh I know there
must be a way to do this because he's
look at this and reasoned about how
these different three different types of
objects might be links to get together
and assume there must be a fast command
somewhere that allows you to manipulate
and change that relationship just to
show you another little aspect of this
we're gonna do we're gonna make a minor
change to that file we're gonna add an
empty comment in it or a very simple
comment in it we're gonna add that file
again and have a look at the tree again
this is an entirely new blob this is the
content addressable again because that
file is no longer empty it is actually a
completely separate object now so this
isn't really
at its core get it's really just objects
and objects that points to each other
but objects for themselves are just
hashes and hashes on the hell of a lot
of you sure you can you can use the
trees or point at the objects and you
can use the commits the point of the
trees or the other objects or whatever
but you gotta point of the commits and
what the hell is that use of they're all
hashes and those aren't very practical
so gonna think a little bit of more
about what we want on top of that to
make it a little bit more usable in the
real world so I'm one level up the tree
now I'm going to look at the refs
branches and tags so you probably heard
of refs super we don't know much that
much about about them possibly you do
you thought you almost certainly
definitely heard of Brandt Brandt
branches and probably tank as well these
are all very much to say the same thing
so what is a riff a ref is just a
pointer to an object simple as that as
all this is it is literally a name given
to a hash of an object that object might
be a tree might be a blob or it more
likely in practical terms it's going to
be a commit it's a way of giving a
commit a name is nothing more than a
variable now by the way if you see any
similarity to programming languages and
in particular JVM is a fairly good model
to actually think about it in some ways
that's very very real reason for that
refs are basically like variable names
and objects are very much like objects
stored in memory with relationships to
each other so as one loved way to bear
it in mind as well the rest is just a
pointer to an object and we don't
generally manipulate refs directly very
often we more often use the high-level
abstractions they're using refs are just
or branches and tags or just refs they
have some special semantics but there
that's convention but branches and tags
are just refs a branch is just a
different ref into a different object
now a objects can have multiple children
and that is how you create a branch what
you do is you have rather than merely
moving up along on along a linear path
you created a new ref a branch and that
takes a different path the parents
aren't remains the same at some point in
the history but you are now gonna on a
divergent brand path briefly what is a
tag well tag is just a special ref
that's used to mark a commit in the
history usually this will be the most
common one is a release point so this is
the version of the the code that was out
went out with version 1.2 so you can
track your ver you at that point in
history it's nothing more than a marker
there are special tags you can attach a
commit to a tag and that tag points at a
another committeth an object and that
gives you the way to annotate a given
tag and give you a way to sign tags by
simplest level a tag is just a by
convention a point in history you can go
back and actually manipulate those like
many things and get it shipped by verge
from traditional version control systems
you can go back in history and modify
history
you generally shouldn't unless you have
a good reason to but you can go back and
manipulate these tags if you need to so
let's once again jump down into the
command line how quick look at this so
we're gonna create a tag just call it a
tag and we're gonna touch a message to
it which is just a tag we're also gonna
create a new branch and we're looking
inside a different part of the git git
repository you can see what's happened
in here is we now have a directory
called gets refs and Athar stores are
refs now we split them up into useful
it's in two different parts of it
one for the tags which is obvious yeah
when it's heads heads are merely how we
refer to branches on the whole it a head
will normally mean a branch will
generally point to the end of a stream
of development a stream a string of
commits so these are the heads are our
two brawn branches there's a branch and
master-master is the default branch but
the gain
that's just convention if
you don't want masses to be the default
branch you can create your default
branch if you want and destroy master it
doesn't prescribe anything like that
it's just convention and the tanks we
have the tag in there and if we do cats
if you don't know cat just blast the
file out by you by defaults will just
display a file as you can see all it is
in the branch is the hash this is my
branching in git is so incredibly fast
it's literally writing a bunch of
characters to a file but it's all it is
to create a branch it's almost free so
we know a bit about branches and tanks
now and riffs let's talk about one of
the things that Jenny people often screw
up briefly what is a reset now there is
a reason to be bringing this up in the
context of refs and I'll show you in a
second but what is a reset how many
people here have used reset in the past
how many people fucked it up yeah the
rest are lying all right it's a rite of
passage in get to do a reset hard and go
all shit what have I just done we'll get
back to that I'll show you how to tell
you how to fix that if I'm gonna give
you a heavy clue any second now
but all git does with reset reset you
don't have heavily overloaded commands
inside gift but its simplest lower level
it does all it does is we'll take a tag
a ref a branch usually and change its
states so what we're going to do here
new git reset hard is one as the
overloaded part when the git does the
reset and moves the reference most
usually the branch end point well it
does it has a choice what's gonna do
with the working directory it's changing
internal state but you have your checked
out copy as well what happens to checked
out copy after you do that move hard is
the most extreme one it says forget
whatever was in the working tree blow it
away reset it to the state that I'm
giving you now the last bit the feature
was the up little up tag little carrot
on the end
means parent there's a whole little sub
language inside get for referencing the
relationship between different refs nine
times out of 10 you're not going to need
to know that's one of those things
that's kind of handy to know if you're
really into into the weeds but by then
you really should understand what's
going on anyway there's a little mini
language was saying this commit but to
behind it things like that but the
carrot means just whatever is but this
is pointing to one back so we're gonna
jump back to the parent blow away the
last commit and replace it with with
whatever the last commit so that is that
and now it will just move that tag the R
if there's a simplest level there are
different things you could do as a side
effect but that's all it really does now
because you're doing for this fruitier
you're not going in there and writing
these files auricular you're telling it
I want a ref to move well gets going
this is kind of high-risk stuff here
when you're messing around with this
this one little least understood feet
features inside get inside called the
ref log whenever you manipulate a ref no
matter how you do it other than if you
feel you can go in and manipulate as
falls directly don't recommend doing
that but anytime you manipulate or if in
any way creating a branch destroying a
branch make doing a commit or whatever
anything that moves a ref get makes an
entry in something called the ref log
this is really really useful and we're
gonna use that later dish to get out of
trouble this is one a simp the most
important ways of getting out of trouble
and get if you do something and you
don't know what the hell just happened
go look in the ref log and you can get
back to the previous state now he's a
couple like Kathy it's here it's local
only to the local the route to local
repository not only have pushed up when
you do a push wouldn't make any sense
and it does timeout after a certain
amount of time ninety days by default
and you can if you can't change that
there's a date a git config file you can
in your home directory or inside the git
repository itself you can change that
you can sir I want to be longer shorter
whatever but it keeps a ref log for 90
days that's pretty that's pretty good
so I hate these things I should go back
to bloody text files so but as you can
see as we've made changes within commits
checkouts commits cherry-picks all this
stuff you heard about anything that
manipulates a ref will get entered in
the ref log and it will also show you
the hash which gives the ability to
directly manipulate that and get out of
trouble and we'll come to that in a bit
and show you how you can do that now
there is one other gotcha here this is
where the JVM side of things really does
start to show now if you think about it
a little bit it creates a lot of these
objects and you do an ad and add an ad
and you're changing one character at a
time and do an ad on one character and
add one character in an ad or one can't
really commit all of these all these
build up over time a lot of these if you
have a temporary browser you work on in
throw away what happens to all of those
objects now one of the fundamental
insights of gifts ad in his original
form it's changed a little bit since
then but it'll form one of the insights
of it was that disk space is cheap so
the original gate had this idea of not
storing deltas in the same way the
subversion does subversion will every
time you make a commit it looks at the
changes and only stores the bits that
have changed the problems that makes
manipulation of subversion history very
very hard subversion was a good idea
everyone who's ever seen somebody check
all the company passwords into the into
a public repository will disagree with
that slightly been there done that
cleaned up the bloody mess it was a
nightmare so git has this concept of GC
there curse a certain times and you can
do it manually so gets GC is actually
remarkably like GC inside the JVM how do
you have familiar with how the JVM or
generally any other garbage collected
virtual machine language works I'm
assuming most people here have had some
exposure to it so what happens is
generally objects to be a root object
and lots of objects point to other
objects and then what the GC will
was occasionally going to look at the
object emits over a certain man certain
age go okay this do we need this anymore
and trace it back through its history
and at some very elaborate algorithms
for doing this but it's a simplest idea
so what I've done here I was replay this
so weapons we do to get reset we've
moved our tag back and we done a GC well
because that object that we've moved
from no longer has a parent because it's
no longer a tag so again inside the JVM
if you've got a variable pointing to an
object that's because that keeps it
alive it's only when that variable
disappears the reference if you'd like
that's the object it's cleaned up
GC will destroy all of these old objects
now there are some some cat some caveat
so that the main one is it generally
gives you two weeks grace period so if
you do a reset and then do a GC it won't
actually go and destroy the information
straight away it'll wait two weeks I've
done it I force it here the GC prune
equals all says forget about that to
weak limit destroy everything right now
and that's purely for the purposes of
this demonstration I wouldn't recommend
doing that again that the grace period
is tunable inside your gates
config if you so wish you want a longer
great grace period there's one other
thing it does and I almost love to
mention this because it's not really
important in terms of the get model but
it is important if you're gonna go poke
around inside your get doc git
repositories software should bring it up
for you and it is important if you're
looking at the the networking protocols
which again you probably don't want to
do I'm not going to go into here because
lab rating of itself but the other thing
that the get GC does is it does a pack
now I mentioned that gets fundamental
idea in the original days was that every
object is kept around all the time we
don't go saving deltas and stuff like
that turns out that works great on the
local file system not so much over the
network and not when you have something
the size of the Linux kernel as well and
you are say the new store
and constantly merging all these stuff
in that's creating a ton of garbage
objects in in them so what was
introduced early on and gets history was
something called the PAC file the PAC
file does what subversion does upfront
but only does it after the fact and it
basically Delta encodes things it says
this file here is almost the same as
that file here so we're going to only
save the differences between them it
does this quite intelligently after the
fact and it didn't does a bunch of extra
compression etc except etc this is
useful for cleaning up when you've got a
lot of objects on disk and it's also
useful when you're sending stuff across
the network which is obviously going to
a little bit more constrained than your
average disk nowadays the reason I was
almost loathed to talk about this is
it's not really important it doesn't
change the unfunded ental underlying
nature of gifts that model of objects
pointer objects remains the same and you
can take that PAC file I'll explode it
back out into that really wasteful huge
system again if you wish so it's merely
an intermediate compression it's like
pointing out that you know HTML can
sometimes be compress when it comes over
the wire it's not really important to
understanding HTML so this is not super
important to understanding get but it is
important if you're going to poke around
inside your git repository and you're
curious it would have a quick look at
this this is actually what happens after
the get GC by the way G C will happen at
certain times during pushes and pulls
and so on obviously when networking
involved it does a quite aggressively so
if you actually have any background in
database design this will probably look
quite familiar to you as well there's
two files here a PAC file and a an index
file that tells it's used to look up
certain files explain how to basically
rehydrate them from this compressed
format and this is why you could
basically go off and just reapply the
PAC file if you so wished now if you're
really interested in this stuff it is
documented sort of this is a Linna store
valve special it's highly formats highly
optimized for spinning discs in the
format designed to be able to randomly
exercices as fast as possible on
see spinning disks it's documentation is
very is basically somebody said what the
hell is his pack file install balls went
pound pound pound pound pound on in an
email message and that is then email
message was copied into the
documentation directory of get and that
is basically your documentation for the
pack file it's black art shit it is fast
thing to go and read if you're into drug
binary encoding file system optimization
sectors on discs etc etc this is clearly
written by a file systems guy but as I
say not important no more it's no more
important than understanding the the
format of a HTML file that's come over
the network compressed you don't
compress it that's that's all it is it's
compression format useful but not super
important in our in our mental model so
we talked about objects and commits and
strings of commits and brant branches
which basically just says you are you're
a different point and neither virgins in
the history of course diverging history
is great particularly if it's really
cheap to do but at some point you want
to pull that history back in and that's
where things get a bit more complicated
next level up which is the merge now
merges are quite complex and I'm going
to skim over a couple of things here
there are a bunch of articles we've
written on Atlassian's developer classy
and calm which explain some of the
details about it aren't used to the core
methods of merging and it's used the
core ideas but I am going to skip over
some bits here because the main system
is used for merging some called
recursive merge which is been optimized
for the Linux kernel is they're very
powerful but it is a little bit outside
the scope of this talk the other thing
is it's also not necessary and I'll show
you one so what is a merge a merge is
the re integration of two diverged
points in history this is what you this
is what you want when you brush is you
do your merge so you've got these two
points and they have digressed someone's
plugging away on master they shouldn't
be they should be brought branching off
but let's not worry about that and
someone is working on the feature in
parallel they're both making changes and
will make possibly but not necessarily
making changes to the same file how do
we resolve that well we use a commits
algorithm emerging our algorithm rather
I'll talk about those briefly but that's
again is a detail what we want is
because there is going to have to
resolve these two sets of changes which
overlap we are going to create a merge
commit this is going to store any
changes necessary to resolve the two
sets of changes to calls or text files
to go like that it is quite good about
doing that and it's then going to store
any additional information we need about
that one interestingly one of the things
it stores this is where commits are
quite powerful is commits can have more
than one parent so we talked about you
know each commit has a parent that
points back to the previous one that
gives you the chain back to the history
in history to the original creation of
the project at the start but commits can
have two parents to them so you have a
point that says well this commit was
made out of the joining of two other
commits to of a branches in its history
now why only two it doesn't have to be
two it could be many you getting crazy
then there are cases where it makes
sense no we'll explain one but explains
the history this is why incidentally you
can delete a branch after emerge and not
lose any history very very useful
generally speaking so there's a bit
bitbucket does this not sure I get up
and saw it so on and stash does as well
for a bit bucket server
weapons is when you close you do a pull
request and that effect he calls the
merge you can optionally say this delete
the branch afterwards that Deleasa
branch but it doesn't destroy the branch
history because we can walk back through
our history to the merge commit and go
ah which path we're going to go down
down the master or we're going to gain
that off for down the feature branch
because it will actually say that we
have merged the branch there
so even if you destroy branches which
are only just refs the point of the
commit you blow it away
you'll still keep the old branch around
because it's been referenced by the
merge commit that tells you that
divergent this piss tree was merged at
this point now that is not necessarily
what people want and I'll talk about
that in a bit and it's actually not
saying that will happen in every single
case if you consider the concept of well
what happened if I created a branch
there's me and worked on my feet feature
away from master and then do a merge
back onto master and nothing's changed
on master what happens then this is
where you've heard possibly of a
fast-forward merge a fast-forward merge
is a handy little optimization and not
everyone likes it what it does it goes
look if I've branched off and I've made
a bunch of changes but nothing's changed
on the point from the point of Bronk
Bronk branching on to to semantically
equivalent now and the answer is yes
they are so at that point we just do a
little hack let's pretend it never
happened and we're just going to say
we'll replace the bra the master now
with or the target branch with the other
branch and you'll never know what no
what happens now this has two
interesting side effects one if you do
as I say delete the bra that the branch
reference you'll lose our history you'll
never know what happened literary will
do we know record that or even if you do
keep it around though you'll never know
what which point the branch occurred
there's nothing that's in there to say
that we branched at a certain point and
merge at a certain point all you know is
there's a spare branch tag branch
reference hanging around so there is a
way around that if you prefer to keep a
a history that contains the full history
even if there was effectively a null
operation there you can do put a flag in
called no ffs you go get merged no ffs
and that will create a dummy merge
commit for it for you that contain
upon the the pointer to the master at
the point of divergence and the endpoint
of your branch and you can basically
recreate that it's a way of storing
additional metadata data things like
bitbucket will do that for you
automatically however not everybody
likes that some people would like a
clean history and I'll show you how you
can create a clean history and remove
all merges from your history some people
prefer to have a true history one that
contains all of the merge points along
the way now whether or not as a good it
is entirely up to you Atlassian we tend
towards the truth we have the open
company no-bullshit motto that's a real
motivation and we it's even the most
sweary one so that we always say you
should keep the history do do not
destroy that information always do no
fast forward and make sure we have a
dummy merge commit this shows a branch
and merge occurred we prefer the truth
some people for various reasons
sometimes the legitimate that preferred
that they have a clean history does not
show the full expose the full process of
the order the full development process
sometimes if you're a contractor working
for a third party in the management of
it if that why's all these branches in
here what are you doing something wrong
then do you for a clean clean one but
lastly and we prefer a a true history
but that is really just a matter of us
of our personal preferences or our
philosophy now well I talked about
merges I said I promised I was going to
skip over them slightly so there are a
number of merge strategies when you that
merge there are different ways that you
can resolve the differences as you see
if there's not really any differences we
won't do a merge at all and obviously if
we and if we say no fast forward it's a
no op anyway we're just replacing one
piece of history with another resolves
though is when you actually come to do a
real time when you come to a real merge
you will want to have some method of
resolving the differences
now what that method is depends entirely
on what you're trying to merge no
different strategies for different
different needs traditionally the one
has been resolved which is the normal
merge strategy was used I think believe
was using subversion other ones which
probably didn't work very well
that Regis looks at the two end points
and goes okay let's see if we can get
these together without any conflicts and
if it's conflict because I can't do
anything and we'll dump out your set of
files with a bunch of you know noise in
them that you didn't have to manually
clear up recursive is slightly different
this is the one that was introduced with
the loose kernel has been battle test
with a Linux kernel what it does is it
uses gets history gif knows about
branching point she's pointing bluer
branching points and merge points so
what you can do is walk back down the
tree rather than just taking the
information it has you can go back down
to the point where divergence occurred
and say ah right this is where they
changed so only the changes that along
here are what and once you have to worry
about not everything and then we'll walk
back up the tree creating a any
intermediate commit and merge points and
then up to the end is it quite complex
in itself and I've chosen to skip over
this purely for time and introduce some
other interesting things I'd like to go
into it but if you do one look into it
we do have a bunch of articles on
developer classy and calm about the
different merge strategies resort
recursive is the default and it will
work for you 99 times out of a hundred
because it's been battle tested on the
Linux kernel if you can't resolve
something is probably a good reason for
that a lot of interesting one is very
much told you that a merge commit can
have two parents or maybe even more
there are cases where that actually does
make sense we actually use it on develop
relation calm so we have this static
site generator that we use so finish
making lots of people you working on
different articles for developer dollars
you know calm at different times but
generally speaking then on cooperating
now our each wor operating in their own
directory each article exists in its own
directory and the people are all working
on that we also have a staging certs
that where we push up all the change
changes now obviously if I make a change
to my article and say push and that
pushes up to the my branch gets pushed
up to the developments serve the staging
server I'm gonna stomp over whatever
changes other people have made because I
haven't incorporated them into my branch
I'm working in my own feature branch
from an article branch meanwhile Tim
does the same thing do we do we do
commit push our bamboo continuous
integration server automatically goes
off and pushes that up stomp some of
mine if you go to the staging server
you'll only see the last commit not all
the articles that can't be what being
worked on but because there are very
Israel little or no overlap between the
two brought these Brandt branches all
these dozens of branches of the articles
won't be worked on at any given time we
use the octopus merge we say take all of
the current unmerged brought branches
that have the word blog in the tyent
title and merge them all together
octopus merges if you do have conflicts
or an absolute nightmare to unravel but
if you know that you have a bunch of
different code that has no oh overlap or
different branches have no overlap
between them maybe some people working
on different module systems and so on
you can pull them in and have a merge
commit which has multiple parents
possibly even dozens there's one call
and then of a most strategy called hours
hours is when and it's having people
have done this you do see occasionally
you had it once or twice it'll ask you
not not not often you're working on a
new version of your tool application and
you've got version two and now you're
working on version free meanwhile your
work you're also doing patches and so on
fixes on version two but the version
free is completely different our new
toolset using a completely different
you've gone from iPhone to and Android
or your you completely you're on GG TK
to you know whether it whatever pure
HTML native with it whatever the suit
application they have no relation to
each other when you go to release
version free you want it to become the
new master you want to completely
replace a no overwrite the previous
history you don't destroy
old history you maybe want to say I'm
gonna merge this in but don't even try
and do an actual merge just take the
this new branch of a ten disty it's been
merged in but don't actually try and do
two merge for completely basically
overlaying one completely different he
piece of history on top of another
that's what ours does it gives you the
ability to say create a merge but
pretend that we complete destroyed it
now you could do that manually you can
literally just do delete add your father
in all your files in and then do a
commit but that's all going to tell you
very much what you want is that in
branch history that tells you the
branches occurred branches was merged
here because we did a release of version
free
and it's completely superseded version
two we want version two's history to
remain around as well you want that
merge point to occur as well subtree is
an interesting one I'm going to too much
here subversion had extra external
externs that allows you to pull in other
subversion repositories into a novel
repository as the pendants ease subtree
is a closest answer the gate has two
that you can take another repository and
pull it in as a as a subdirectory of
your current repository it's handy I
user for instance I've got my very
complex Emacs setup and I want to pull
in various modules when wanna lock them
to certain for versions so what I do is
actually go to the git repository and
say pull in this tag of the closure mode
a tool and put it to the lips sub
subdirectory Lisp sort sub rectory and
then later if I want to I can go do a
pull from a different tag and pull that
down and so you get subtree understands
that I don't sense that there is a a one
repository may rely on other
repositories the other thing though is
this is as you can see pluggable that's
quite interesting if you've got some
proprietary file format its binary it
doesn't understand it I can't merge that
in this replacement won't already what
with the other but what if it's
internally it's a tree model say it's
one will be mkv files if you know
there's a met Rosco's they're
essentially binary XML you'll actually
merge these together you explode them
out you to look to look at two files
explode them out look at the endpoints
motion together XML you could do that
XML if you've got if they've also
generate XML might look complete god
good nonsense when you try and merge
them because they've all and if it ever
all everything different places these
try moments text files but you know
they're XML files you blow them out into
a Dom look at the end points merging the
bits of change and then dump that back
out again so this is possible if you
have some proprietary file format you
can plug in your own merged system the
other thing I'll talk about is what is a
rebase again this one is things every
sort of looked at and gone oh this is
great I'm gonna do this then screw-up
so re rebase is one of the things one of
the rebase is one those things in get
where it's very powerful but we can use
very carefully indeed what it will do
say you want to actually have fast
forward mode but have a fast would merge
you you want to keep a clean history it
looked like it's a linear line how do
you do that well what you can do this
I'll get to rebase to a certain point
but since history didn't occur you
replay commits on top of each other now
it does a merger each step along the way
but it is very very powerful and I'll
come to this in a bit because if you're
replaying history you can change history
and I'll show you how to use that in in
a little bit now I'm actually getting a
little bit out of time so I'm gonna rush
forward but quickly here and introduce
you a couple of course on concepts of
how we can use this to get out of
trouble this is really the sort of the
you know to pay off at the end now it's
how do you get out of trouble in get
using what we've just learned we've
shown you how to get into trouble as
well by the way this is a this is a
finger in repeat in Australia it's
actually the advertisement TV
advertisement for the original Prince of
Persia sands of time so you have played
that game you'll understand that so
quickly let me show you a couple of ways
that we can get out of the trouble we've
managed to get ourselves into I'll show
you how to get in let's show you how to
get out okay
resit heart we've blown away our a
working tree we've moved a history oh
shit I shouldn't have done that I wanted
that commit actually how do I get out of
it anyone know nope ref lock you have a
record of what you just did you can see
that we reset them to one step backwards
but we can look at what the previous
commit was we can see where where we
moved from so we can undo that the way
to get out of that we just do a
different reset we put our reset back to
where it used to be so let's show that
again we did a reset heart here that
moved the tree move the Rif and that we
have no way of getting that lets me know
what that magic hashes of that object at
the end no longer has anything poison to
it we need to find out what the hash was
to reset it well that's okay because we
have it in the ref log and we just do a
reset hard again but we use the hash of
the one the of that end object cuz we
look it up in the ref log level one is
if you done ever gonna re rebase and
somehow the rebase has broken the bills
at what point did the breakage occur
somewhere along that's replayed history
something went wrong what went wrong how
do we find out where the breakage
occurred well we know how to go back to
the previous state we were in the pre
rebased state because we got the Rif log
so a little riff log and look at what it
was before we did the RiRi base what our
branch named a branch tag was pointing
at our branch a reference so we look it
up and then we push it back to the past
now we can do a reef we can try it again
but this time we're going to put
something into the command it's going to
be called exec because it is replaying
history we can actually at each point in
the history as we replay it we can do
anything we want we can merge different
commits to
things like that and that's where you
want to rebase interactive we're not
gonna go into that here we can also do
this we're gonna we can execute any come
on we want as the rebase is playing so
one of the things that very useful to do
is run all of our tests after each step
of the re rebase if our tests fail the
rebase will stop and we can go and
examine what's happened so that's it so
basically it's a way of looking at each
merge point and ensuring that the merge
point is same now there's nothing to
show you this is your not so much used
in healthy projects however it is used
in the Glynnis kernel quite extensively
not to say that it's not unhealthy but
Linux kernel has different constraints
it has a handle lots of hot hard-wearing
it Todd we make change over time it
makes six months until a regression is
noticed so somebody had to go back into
history and find out what broke we can't
replay a thing or we can because it's
geta we can go back look at any point in
history so get a thing called bisect
bisector that gives you the ability to
say I know that the car did this but the
current point we're looking at the head
is broken but I know back here at
version 1.2 there were that regression
didn't occur what happened so we tell
git this is the good point and this is
the bad point please go off and find me
the midpoint between these two commits
and now you can do this manually if
you're doing the Linux kernel you you
can manually go and check these things
you pretty much have to if you're doing
Hardware regression testing but in a
case if you got automated test suite
which I hope you have you guys run that
automated test suite each step along the
way and get will do it all automatically
for you what it will do it'll go back
and find the midpoint and say is this
midpoint broken well let's run it run
the tests to find out no right in that
case the breakage must be somewhere in
the future let me find the next midpoint
between these two points so the
automated way of doing this though doing
regression testing so now we're fixing
things now I'm going to run through one
thing very very quickly because I'm
officially out of time which is going to
come
shouting in a bit introduce that one
ways trick powers of invisibility now we
know about objects so we know about
trees objects can have to exist inside
to keep repositories why do they have to
be part of a tree what can it be part of
another tree why can it just not exist
in themselves
you can hide files inside get done
unless you know its name
the file is invisible to you it's not
part of any history I'll show you how to
do that quickly
now it's an example of where if you know
how git works you must know that this is
possible I didn't know any of the
commands here but I knew this must be
possible and I went out and found what
the commands are because I understood
the underlying get model how do we do
something like that well we know that
objects our hashes so it must be a hash
object command to look up the hash of a
file theoretically so we can take any
file it's in in here we've got a hidden
file and it's created then we'll destroy
it afterwards gets hash objects and that
will tell me the hash of a given object
or what it would be if I put it into the
insert into the repository now I did
also a minus W that says actually do
that put it into the repository create
an object's from this file don't bother
it's far name or anything like that just
put the contents of this file into the
repository and it's just sitting there
floating no not part of any chain of
commits no trees and nothing now that's
not a great amount of use to you because
what's gonna happen is obviously in two
weeks time GC is gonna come along and go
ah that's not being pointed to by
anything so it's going to destroy it
unless we give it a name in this case a
tag it could just be a ref but we're
gonna use a tag it seems appropriate to
it so when the hash was created we had
the hash when we now use the hash to
create a tag called hidden and now we go
off and we delete that file and we go
back we change back to our main branch
on master branch that
object is floating there it'll never be
destroyed and it'll have no record in
there beyond Z in the ref log
there's no commits associated with it no
trees no nothing it's a blob of
information hidden in there how do we
get that out well we've got the tag if
we know the name we know it it must be
some way of getting this out then all it
must be some way one let's look pretty
through the manuals there you go
we've got cat file cat file we'll take
any reference or hash and it will pull
out that information and dump it out
onto the screen so let's run that and
here we've got what is the current the
contents of that that's the old Smith
family recipe for the Chien gonna Irish
background and some of its highly
suspicious which is why my name is Smith
now I thought I believed that they're on
the lam from the the tax man in Ireland
now this seems there were theoretical is
interesting it's a bit of fun however
it's actually used fun story when they
were I'm adding it to sports a bit
bucket he kept blowing up when they
tried to pull in the gate repository the
reason was someone had hidden aid an
object in there and they weren't we'd
had no idea about this what happens
inside the gifts repository itself gets
owned git repository Junio who's the
maintainer has dumped his PGP key so you
can actually verify the repository
against itself and verify the history
it's just hidden in there and it blew up
bit bucket when we're trying to add get
support to it so that's it so I'm well
and truly out of time now please use the
app to rate and there will be a
speaker's clinic up the other end I
haven't I saw where it is but I'll go
and find it if I if I can find I'm sure
you can too but just to recap that is
get in its fundamental element objects
there are trees that can be commits the
point to each other and you can chain
your commits to get together and that
gives you history so now a smart go off
and hack on you'll get repositories go
poke around see what happens and do it
on your production one as well that's
fine don't worry about it
so have fun thank you see you later good
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>