<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Software-Defined Culture • Tim Gross | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Software-Defined Culture • Tim Gross - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Software-Defined Culture • Tim Gross</b></h2><h5 class="post__date">2017-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/57EwcEP8qOA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay my name is everything we do is open
source so you can take the same software
that we use to run our public cloud and
run it in your own data centers but it's
way cooler than OpenStack our customers
include some of the world's largest
customers or largest retailers yeah but
this talk is gonna be a little ranty so
it's really not about the work that I do
on a daily basis I want to talk about
software and culture you have to be a
little careful when you talk about
culture though right because culture is
a sort of thing that people can people
can get very offended by people have
very strong feelings about it and as
technologists we have a habit of being
incredibly tone-deaf right I I will have
I will admit to having being guilty of
this to myself in this talk I'm going to
poke at some techno pop fun at some
technologies that I've used some of
which I even like if I don't include
your tech your favorite technology it's
not because it's any good or bad it's
just because I haven't personally used
it so Bridgette who was just hit up here
on stage is fond of saying containers
won't fix your broken culture right and
she's right I was at velocity velocity
conference in New York last year and
Catherine Daniels was on stage she's the
co-author of effective DevOps which is
great book everybody should read it and
she was saying tools will not fix a
broken culture and she's right and this
is basically the problem that we're
facing right now in technology right we
have an embarrassment of riches in terms
of technical tools and best practices
but none of it really fixes the human
problems that we have
it doesn't even fix most of the
technical problems that we have so it's
not very realistic for us to assume that
I could fix our cultural problems as
well so I live in I live and work in
Philadelphia and like many cities there
is we have a slack Philly dev
and there's of course a DevOps channel
in there right and every so often every
it seems like once a month or so this
this exchange more or less happens right
very excited a new person comes in and
says hey I've been instructed to to do
DevOps at our company right I don't
really know what that means but so
should I be using puppet or chef right
and you know and maybe the conversation
is not as constructive as it could be
right this this could probably been
handled a little better but the point
here is that Jay random Mouse person is
telling the if excite a new person that
they're confusing tooling for the model
of working right this is gonna be a bit
of a weird analogy anybody here do yoga
yeah a few okay good that's great
so there's a particular practice called
Kundalini Yoga and some practitioners of
that call it a technology it's kind of
an interesting idea which is that it's a
practice it's a human created practice
to a tool rather that we use to improve
ourselves to improve you know generally
speaking our self as individuals but
perhaps the people around us but there's
this notion that people talk about in
Connell you know the mindfulness
community called spiritual bypass and
the idea here is that rather than doing
the real work on yourself right actually
itself improving you kind of just use
the tool right so like I I have green
juice in my fridge but I don't actually
drink it right
I go to a yoga class but then right
afterwards I'm you know lighting up a
cigarette and and gossiping about people
on Twitter right so so in that case like
even better than just using the tool
you're surrounding yourself with the
trappings of the tool right I am the
kind of person who uses this tool so
therefore I'm good so a lot of the
tooling that we have in this kind of
DevOps universe this obsession that we
have is a form of this spiritual bypass
just apply as applied to technology
using the tools do not themselves turn
you into a successful organization right
like that's not enough to implement this
cultural changes that we need and the
reason there a lot of the reason behind
this is something called Conway's law so
this is this is from Melvin Conway
think it's back in the 60s but but the
idea here is that an organization that
designs a system and this can this is
this can be information systems but can
be larger systems like the cultural and
organizational systems that we create
will produce designs who structure a
copy of the organization's communication
structure right this is also sometimes
called shipping the org chart right
I don't have it up here but has anybody
seen this like it's the the org charts
of different like major tech companies
right now it's like Microsoft and they
all have guns pointed each other and
it's like you go in they're all like
this big thing and like the way that we
build our technology is influenced by
the kind of the structure of our
organization and so in a broader sense
I'm saying that you know we say and I
think we all kind of agree people who
are in this room probably at least agree
that cultural our culture influences our
technology and so this is our shared
assumptions our shared values our shared
beliefs how we make decisions influenced
our technology but I mean this is a talk
called software-defined culture right so
I you know clearly there's a but here
right which is I'm going the option I'm
gonna try to go in the opposite
direction here culture is a very complex
system though right it's subject to
chaotic feedback instinctively I think
we all know and probably agree if we
think about it a bit that bad technology
choices can influence our culture if we
don't build reliable software right if
we if that isn't baked into the into the
core of our software our operations team
will probably hate the guts of our
development team well that's technology
affecting our culture if our operations
teams build software that isn't it
builds delivery systems that aren't self
serviceable right so that everything
that a development team needs to deliver
is involves this like annoying change
process the development team is going to
hate the guts of the operations team we
know that if we don't build for
flexibility and rapid delivery that the
product management team is going to like
you know be very frustrated with
development team and and kind of like on
and on through the different iterations
you know the different kind of
permutations of the different groups
that we can have in our organizations my
favorite column here is the system in
calm as a neck system in myself if we
spend our entire weekend up all night
because Pedro Duty is going off and
waking us up and then we come
on Monday morning and we're all snipping
at each other and we don't like each
other anymore because we ruin each
other's weekends we have a case where
technology has influencing the culture
of our organization if we start ignoring
our mail because we've done something
silly like let's send all our meeting
requests and all our inter team chatter
and all our code reviews and alert
messages and I've seen this actually
happen once all our HTTP 500 error stack
traces through email so that we then
start just ignoring the email right
technology is influencing our culture if
we if we can make if we can make
decisions and have communication that's
asynchronous that gives us a little more
time to think that allows us to have a
distributed team technologies
influencing our culture there was a
great blog post earlier this month Bill
Higgins an IBM distinguished engineer
where he was talking about a new project
that had started at IBM and bringing in
kind of more modern tooling to this team
and he saw he saw a really radical
change in the way that the team the team
worked with this new tool and he this
quote starts with the word starts with
magic and he uses the word magic like
eight times in this blog post because it
made a major difference for his team
right he says all the tools we used had
excellent surface usability right like
you know I mean the tools that are
coming you know and I'm gonna you know
pick on Silicon Valley here right like
there's a lot of beautiful tools coming
out of out of Silicon Valley right now
but the magic was in the new workflows
and collaborations that they write
github yes is a pretty UI on git web
right like yeah I can do get web and my
way on my debian server and like I've
got I've got right it's basically the
same thing it's not right when you buy
into this pull request based workflow
you've enabled social coding within your
organization right you've allowed for a
greater peer review slack is it's just a
pretty UI on IRC right isn't it just the
same thing but the magic as he was
saying who is that it's it becomes this
touchstone for the whole team
and not just the technical team but the
technical team with the non-technical
teams who aren't gonna get in login and
IRC by the way and also the also the CI
CD tooling that can interact with it as
well
there was a so Conway's law tells us a
lot about the cultural influence how it
culture influences tools but tools also
influence culture right and so there's
this back and forth there was a there's
a great quote in this discussion a few
years ago by some Etsy engineers who did
a reddit and AMA of all things and there
was actually a really good discussion
that came out of that and they had this
kind of they talked about this kind of
inherent back-and-forth between tools
and culture so while kind of thinking
about this idea i've come up with what i
call four principles for
software-defined culture and and maybe
principles is too grandiose for you can
we can call them guidelines or whatever
but that's that's what i want to talk
about and they're building for
reliability building for operability
building for observability and building
for a responsibility when i first wrote
this up the last one was build for
impact and i gave it to a friend of mine
who's in marketing i was talking to him
about it and he's like no it has to be
in ility like they all rhyme so that's
why I don't work in marketing okay so
the first one is building for
reliability a failure to build for
reliability as kind of the core the core
concept of how your design is built
leads to firefighting right and
firefighting becomes a rut for
organizations the patch fixes that we
make for problems today are all kind of
like temporary hacks which means that
the problems come back and they grow
right we have the zombie bug that keeps
coming back in this environment
everything becomes urgent which means
that the things that are important to
our organization and which I mean by
which I mean our LARM
our long-term goals the things that
provide business value for us those go
by the wayside while we're constantly
fighting fires and without a culture of
reliability we miss align the incentives
of the team right rather than rather
than rewarding the creation of business
value we're rewarding the prevention of
largely self-inflicted harm
and this is going to lead to burnout on
your team right so the people that the
the people who are your best
firefighters the hero-worship right some
time we've seen this this is a really
this is a really common pattern in
operation it seems in particular they're
going to burn out the people that we
bring in two organizations came to your
organization largely because they agreed
with your mission because they they
wanted to do work on interesting
problems right like nobody would go
through the typical techie interview
process if they didn't actually believe
in your mission right like they would
find some other easier place to go work
right we know what kind of we know how
organizations hire right so people don't
like to be paged right like they didn't
come to like do a bunch of packs thick
patch fixes they came to bring some kind
of value to them into your mission so
you're gonna lose your you're gonna lose
people to this and you're going to lose
your best people to this you'll lose
them to either them just quitting or
actually them burning out and actually
there and having their work suffer right
where it becomes time to maybe have
uncomfortable conversations with them
and what's very strange about this is
because these people were typically your
best put your best people beforehand
right they were your best firefighters
they're going to leave in it will be a
surprise to you because you won't
understand why they seem so happy
everything was going so well so this
starts the guide are technology choices
right like that this principle can guide
the way that we make decisions about how
we take about how we select technologies
so for starters let's stop with the
resume driven development right new
software new technology is broken all
the time it's almost by definition right
like until until people work with it a
lot we don't know how it's gonna work
this is gonna normalize risky decision
making right so like if it's always okay
if it's okay for your developers to say
hey you know this week we're gonna we're
gonna start a new project in elixir or
aerospike DB or you know view J we're
gonna rewrite the whole front end and
you gjs this week if that's okay and it
isn't vetted and it isn't done in first
in internal tools development tools
rather than just kind of yoloing that in
a production you normalize risky
decision making right and you're telling
people this is how you get rewarded
right you ship the new thing that we
rewrote the whole
and for no reason for no business value
at all right a kind of subtle effect of
this and that can be very toxic in the
organizations it is that this attracts
like-minded hires people who only are
there there are kinds of there are some
people in our industry who only really
like to work on new things they don't
really like to maintain things and they
will tend to attract people who are like
them to your organization where they can
get away with this and then they'll
leave when the fun start when the fun
stops I'm going to tell a slightly
anonymized version of this story that I
have witnessed so I was at an
organization and a senior engineer
brought in a very good senior engineer
said you know I really am interested in
this new programming language I want to
introduce it and he convinced the CTO to
go along with it it doesn't matter to
the for the purposes of the story but it
was go which tells you a lot about you
know the the kind of decision-making
involved there perhaps so they said okay
well we're going this we want to switch
all this all the new stuff that we're
building we're gonna we're gonna write
all that and go and it will be all our
new software and so he started to bring
in people from other organizations that
he'd previously worked with who all
wanted to work on this new stuff with
him and they ended up building a lot of
kind of toy implementations of
production software right they didn't
really care or know how they were gonna
do handle logging how they're gonna
handle the dependency management how
they were gonna deal with health
checking for example if you you know if
you are a if you're running a native US
ELB load balancer in front of these
things like you know you shouldn't
return 200 okay if you're not okay just
yeah and one of the up happening is that
that that software was all built and
they got bored and they left and they
all kind of one by one left and they
went onto a new company largely together
right and so the company the
organization was left with this kind of
like crap code that these people had
left behind and this isn't the talk to
other people and this is a very common
property well yeah and there's kind of
like plague of locusts of people who
like to do work only with new technology
which would be okay but it doesn't
provide any business value to you at all
right like this is and and it increases
your hiring cost because they're going
to leave
this kind of resume driven development
is going to end up biasing you against
experienced hires they've already been
through a couple of burnout cycles right
if you've if you've got somebody who's
been working for 20 years they've
probably been burned out at some point
just a quick aside that's really messed
up by the way they were like yeah
totally like they've been in 20 years
how have they not been burned out yet
it's gonna by us you against older hires
just in general maybe so maybe if they
weren't experienced but like experienced
but second career types people with
families right like if people with
families generally speaking don't want
to be up all night debugging your
software because you decided to like
swap out for the MongoDB newest storage
engine and you only tested it for three
days right like that's that's not that's
not going to keep these people in your
organization so we need to talk about
you know so how do we solve that you
know so how do we know we we know that
we need to innovate you know as
technologists so one of the kind of anti
patterns for trying to solve this is
called bimodal IT right so we have one
group of people in organization in large
enterprises right so we have one group
of people who get to be the innovators
sometimes they'll be called like the
labs group or the Innovation Lab and the
other group of people who get to work on
like the production software right and
scene that's called awesome mode versus
sad mode
I think Bridgette told me that one right
and it should be obvious what this does
to your morale right like you have
people you've hired as technologists and
like these are the people who get to
work on the cool stuff which by the way
probably will never actually go into
production and these people have to get
the benefit of saying oh we get to work
on cool production stuff but we don't
get to learn anything new right so
without a culture for reliability we
have misaligned incentives right we're
at risk of creating a culture where we
simply lurch from crisis to crisis so we
need to choose where we innovate wisely
right and we have to choose we have to
choose to innovate where it's going to
have the most business value for us okay
the second principle building for
operability and really took mostly
talking about orchestration here
monitoring and debugging I want to talk
about a little bit later so having the
automated build test
workflows reliable deployment easy
scaling ideally in kind of a
self-service push-button sort of way
when I when developers can provision
resources that they need without having
to go through some kind of like approval
process this is really great further
morale of course but it also in systems
where it works very well you have
everyone has their own kind of like
staging test environments you have a lot
of velocity and how you can deliver your
software and it empowers or development
teams and promotes shared shared
ownership over both the infrastructure
and the code so one of the models around
this one kind of the notional frameworks
is this giffy Google infrastructure for
everyone else and it sounds like a cool
idea and there are some you know
organizations and projects that you know
kind of are associated with this so
kubernetes and core OS and if you were
building a distributed system of micro
services that only speak HTTP to each
other
does anybody building a piece of
software that only speak HTTP right
everybody has a database probably but
maybe this is the right answer for you
if that's the case but when you're
taking on you know I want to do things
the way Google is doing you're taking
all the cultural baggage from them right
they're not the same as your
organization the application behavior
becomes split between the application
and the platform right we've which are
typically in most organizations as much
as we would all like to believe
otherwise are going to be managed by two
separate teams like a development team
and an Operations team and because the
application behavior is split between
the application and the platform the
application developers can no longer
fully understand how their application
works without without the underlying
platform right that often the developers
will not run the platform in their local
development environment often just cuz
it's too heavy right there's too many
things involved with it which is gonna
bias them towards unit testing and you
know so called integration testing which
is really like well my service works and
I have a bunch of mocks so it must work
right a lot of these platforms require
some kind of integration code between
the application and the platform that
code is generally not going to be
portable between the platform between
the operator between different platforms
which means that operator
get locked in and they can't make
decisions to change platforms based on
cost and and infrastructure reliability
so this tight coupling of all the
application components right the
application the platform and this
inhibition tooling has actually
recreated a lot of the same problems
that we were trying to solve by using
these kind of cool platforms instead we
could consider an application design
that allows for applications
applications to be self-contained and
self
I've been working on a project at joint
called autopilot pattern which is the
idea that application should share with
the infrastructure responsibility for
their lifecycle start up shut down
scaling discovery recovery telemetry the
applications can be more intelligent
there are a number there are a couple
tools that can help you out with this
container pilot is a tool that I've
written an open source project that
we've been working on there's also chefs
habitat it was an excellent example of
this of this same design habitat from
chef axe as a process supervisor it
triggers lifecycle events and gossip
service discovery and configuration
changes and container pilot triggers
lifecycle events and got some service
discovery and configuration changes so
there's actually kind of this
interesting parallel evolution between
the two projects both are pretty cool
well of course say checkout container
pile because I wrote it but so by having
the application own more of its
lifecycle we can achieve stronger
platform independence and platform
independence allows for more laptop
friendly orchestration right so if the
behavior of an app of the application is
as self-contained as possible then that
means that the application developer
doesn't have this works on my machine
problem anymore I'll talk about two
examples where this has worked out kind
of it one has worked and one has like
hinted that it might work so there's an
organization I worked with recently to
implement this pattern large retailer
and the head of their platform team so
they had this like that a terrible
anti-pattern right so they had an
application development team and a
sysadmin team and then a an
infrastructure or devops team like in
the middle right and order the platform
team and this poor guy was basically
getting kicked from both sides
on a daily basis and he'd said to us you
know I get told I'm a road block 100
times a day kind of a miserable
situation so he brought this pattern to
the application development team so he
was in charge of the the underlying
platform which of course was our
platform but by bringing this model to
the application development team they me
were able to make their software more
operable and more understandable and so
it empowered the application development
team and now that platform team is seen
as facilitators rather than it than
roadblocks the system and team we still
haven't won over but we'll get there I
spoke I presented this pattern to a
government agency recently I can't say
who so we'll just say as these guys and
during the meeting so these large
government agencies work just like large
a large enterprises right like there's
all these little fiefdom that all hate
each other
and during the meeting kind of an
argument broke out and with all the
different you know managers kind of
pissed off at each other
and one of them said you know the thing
with this is that it makes the
application developers responsible for
knowing how their software works in
production and I said yeah and you know
this was pretty much the reaction I
don't think that's in the Unicode
standard yet so both the application
development teams in that room and the
operations teams are like whoa now we're
onto something right here because this
actually gives both sides what they want
and then there was kind of this bright
flash and I remember it happened after
that but I think they implemented it all
right so the idea here is we're going to
make the production behavior of our
application understandable by the
application team and so this will
empower our development teams to
operationalize our applications so
Google infrastructure is probably
awesome but does it solve a problem we
actually have okay
the third principle building for
operability so I think in this room
right we're all you know the kind of
people who come to a DevOps track at a
conference right we all know we need to
monitor all the things right you even
know what Giff is mit what the image is
missing here like all the things okay we
know that this is a quote from my CTO
Brian control who actually be doing a
keynote tomorrow this was in ACM queue
11 years ago now we've built
mind-bogglingly complicated
that we cannot see allowing glaring
performance problems to hide in broad
daylight
in our systems right but now we're built
this is 11 years ago now we're building
everything with microservices right so
we have these really complex distributed
systems so every birth bug is now a
murder mystery like who did it I don't
know is it the cache layer wasn't that
right we don't know and because these
systems are distributed many of the most
difficult problems that we're going to
face and trying to debug are only ever
going to happen
in production so you know what I was
saying earlier about laptop orchestra or
you know being able to orchestrate on
your laptop still holds right because
that's just your table stakes like if
you can't understand how your
application works on your laptop wall
and like you're never gonna understand
how it works once you go to production
and so this so but debugging in
production means that we need to be able
to debug safely right if we if the
observing of the system changes the
behavior of the system kind of in that
was that Heisenberg kind of way right if
it changes the behavior of the system or
worse causes of the crash then we can't
reliably use it to debug the hit
behavior of our systems so it's time to
move on from like the dashboard right
dashboards are great from Tillet for
telling you what you already know you're
known knowns or maybe you're known
unknowns right but they're not going to
help you with that unknown unknowns from
that quote ahead or order so instead we
should be selecting tools for monitoring
that allow us to explore and to disk and
to discover what's going on this is a
very awesome blog post about a year ago
from John auspi from Etsy an open letter
to monitoring metrics and alerting
companies right this is this is a group
this is an organization that knows a lot
about this stuff right
they wrote stats t-take is it and he's
basically saying hey folks who are
building monitoring tools for people
this is what I'd like to see take is a
first design principle that outages and
other untoward events are handled not by
a lone engineer but are more often than
not handled by a team of engineers all
with their own different expertise right
so we shouldn't be right now the tooling
that we have is all optimized towards
like you know how do I one person
digging into this but it is an optimizer
I'm working with a team monitoring tool
selection can
a way to improve communication and
create durable and persistent records of
that communication of not a
recommendation but of our very xplory
exploration and discovery of the
problems that we're trying to solve this
is a screenshot from a new company
honeycomb i/o the air beat building a
tool that isn't an answer to you John
all I think the idea here is that you
know you send all your logs to it and it
allows you to iteratively build up
queries on those logs and as you're
doing so and I kind of cut it off here
what it's doing is it's creating a
playbook as you go so you're you're
exploring through here and you can take
that cure book that playbook and now you
have a record of how you debug the
problem that you can share with other
members of your team and it becomes it
becomes a an opportunity for new
mentoring it becomes an opportunity for
training an opportunity for
communication and and post-mortems as
well check that out that's pretty cool
monitor ability should be considered a
functional requirement of our systems
this is an embarrassing story because
it's my story so this is this diagram is
DFS are distributed file system
replication which is something in
Windows back when I used to do Windows
stuff
it's an eventually consistent ish when
replication of block storage which is
just about as bad as an idea as you can
imagine we we were running it where we
had a main office and then a bunch of
satellite offices and the idea is of
course it like you know the end user
experience that the end users are
expecting is I saved my thing and then
it shows up in the other office right
that's that's kind of like what they
want but replication performance between
our different satellite offices this is
you know before the you know getting a
high speed in getting reliable high
speed internet some are satellite
offices at the time was very difficult
this is like 2008 2007 and file system
locking over the when was basically a
farce and we had some software that we
were using that was you know didn't
expect that you were trying to do file
locking over the lan because why the
hell would you do that
and that caused a lot of problems for
our users and so the
was really problematic for us and the
reason that was really problematic is
because when we try to get into figuring
out what was wrong with it we there was
no monitoring right there was no way for
this thing to tell you what was wrong
with it
you could bring up you had this thing
where it could say okay bring me up a
report of what's going on and it would
bring up this thing that was like a
webpage that you could view only in an
internet explorer of course and it told
you like here's how much bandwidth
you're saving with our compression
algorithm that was the monitoring that
was it right like you know in the last
month it's like thanks that's very
helpful so we went through what I call
the five stages of an honourable systems
grief so you know denial well we don't
need to monitor that anger well how
aren't we monitoring that bargaining and
this was this was where I kind of came
in which is hey Microsoft's surely you
have a tool even if it's only in house
and I spent quite a bit of time with
them trying to get them to admit whether
or not they actually knew how to do this
and then depression we had basically
been in this call with them for 60 to 90
days and we're getting nowhere on this
so then that that kind of led to the
okay well we're gonna do something about
it
right we're not just gonna sit around
and do this this was this was kind of
the annoying scale of bug where it was I
or the anomie scale problem or it's like
this isn't this wasn't shutting down our
business like we weren't shut down so
you're like oh you know but it's just
enough that you just complained
constantly about it so it was this kind
of like low-level harassment for like
three months so we fixed it right so we
said okay you know I can do Python so we
wrote there's a thing there's an
interface called the windows management
instrumentation and so we built a client
for it which basically involves like
sacrificing coats like that it includes
my favorite comment I've ever written in
a piece of open-source software which is
note WMI returns the year 1601 or 9999
to indicate unfinished processes I don't
know why that is that's that's kind of
like the weirdest API ever all right
like hints at this like deep
terribleness that's under not underlying
this thing okay and so now like I've
discovered since then I mean this was a
long time ago
has actually fixed this and you get to
use this delightful looking tool to
monitor it but the point here is that
we've when we made the design decisions
around selecting this as our way of
syncing data across our organization we
failed to include modern ability as one
of the primary requirements for for that
selection and it burned us big time it
burned the organization a lot because in
the long run we ended up web sourcing
this tool please don't look it up it's
terrible it's embarrassingly bad code we
open-source this and I presented it to a
Philadelphia Python users group and the
CTO of my last company hired me after
that so that they so they lost me as a
result of that because it was like oh I
built this really cool tool and I shared
it with everybody and they said oh we
should get you so in the long run this
was bad for our organization okay
observability isn't just about
monitoring and logging them right it's
also about how we build our software
right so we should be building our
software for rainy days anybody can
build tools that work when everything is
working right that's easy if we only
build for the everything is working case
then we're tying our hands when things
go wrong so let's tell a story so we've
got our startup and I kind of wear
skinny jeans here so of course we're
gonna write it in nodejs and
unfortunately our first attempt at this
has a programming bug in it
I'll get know what that is now the right
way to do this is to build the way that
we operate our software for saying debug
ability right so we're going to abort on
uncaught exception which means that we
get a understandable error message right
it's a type error that's easy and we get
a core dump so we can take our debugger
we can take that core dump and we can
load it into our debugger this tool is
MDB v8 so giant is a little crazy and we
build our data center software and
nodejs
we were for a long time the corporate
stewards of node and so that's where
that relationship comes from and so
we've built this kind of tooling into
our operating system so we can take our
debugger to find the stack in that core
dump so because this is a VM right and
javascript is an interpreted language
like all the source codes right there so
we can go from the core dump and be like
well where's the source that was
associated
and then we can get the function for
that exact line of code and and then we
see kind of here at the bottom the
object that created that problem and we
saw the error message and we realize
that oh we've you know we have an object
here that wasn't expected so we went
from one bad request to the root cause
right that's a really powerful way to
build and operate software right it's
not like oh well let's run it through
the you know the logging for the next
six months and figure out right but you
know we were startup and so we read
hacker news and there was this really
cool blog post on promises so we decided
to rewrite the whole back-end and
promises overnight and there's no no no
longer this idea of like automatic abort
and and and core dump and no I want to
point out this is a programming a
programmer error right that I per is a
programmer error it is not like a
esoteric io air or like something was
flaky in that right this is like you
made a mistake you have a type error in
your code right in more robust languages
with better type checking you would just
like you do this a compile time right
you would never do this would never hate
production so we have to remember so we
have we have a programmer error here but
in order to get the values that the the
values we need to debug this we have to
actually manually remember to do a
process abort right which is kind of
funny right because if we could remember
to do that every time we made a
programming error maybe we just wouldn't
make the programming error but let's
assume that we've done that but now we
because we're using promises we've
completely mangled the stack right so
all our cool debugging tools that now
have to deal with this extra complexity
well that's kind of like mingling so
even if we get that information we can
dig up the error message but it's kind
of like isolated right it's not
associated with the code anymore and so
we have to kind of dig through the
functions associated with that we have
to find all the closures that the van
references I promise then and then we
kind of have to go spelunking through
the heap to find all the possible
objects that might have been passing
this thing and if you're using anonymous
functions and you're passing those
around basically your answer to these
things is like guess you're screwed
because it's just gonna be like a non
anonymous as a non all over the place
but we're gonna cheat to be here because
the code base is really small and so we
know where things are and finally we can
print out and compare this against the
error message and dig back to the source
code and get what we you know realize
how we screw to those Wow this was an
awful lot more work right and you know
we're a start-up and we don't really
have the time to do all this stuff and
we've we've create a lot more burden on
ourselves and you might be saying
yourself come on right when Ruby we just
you know if we're we're crashing more
often because of this is not really a
big deal right when when when base camp
came out they were restarting the really
on Rails server like five every five
minutes but that's like a literal thing
and that was fine like they were very
successful so we're you know we're
web-scale we'll just scale horizontally
it'll be fine but you know that costs
more money so you know that's gonna
increase our burn rate we're gonna have
to go back to our VCS lawyer right which
means that we're contributing to the
bubble right and eventually you know
this kind of money is gonna dry up and
you know that's gonna start to have like
larger effects on the global economy you
know not just the national economy but
the global economy you know and that
could lead to some really nasty things
and then before you know it you know
it's strapping on the power armor and
fighting radioactive mutants and and
zombies and stuff right okay so of
course I'm not saying that promises are
going to lead directly to radioactive
zombies what I am saying here is that we
made a seemingly small technical choice
right for what is really just organ amah
treasons and we've made it very very
difficult for us to understand our
understand the behavior of our
application and it's made it difficult
for us to observe its behavior in
production I wanna have a little aside
here if you don't know how to do this or
nobody in your organization knows how to
do this you should probably learn how or
hire somebody who does if you were a
junior or a mid career type person and
you're looking to level up your
technical skills like this is a great
place to start for whatever your
language is right and don't you note you
know whatever your language that you
love is and if you're on a platform
where you can't even get access to this
stuff right so you know so this is you
know App Engine and Heroku and Beanstalk
right you you you have no shell right
you can't do any of this stuff
so I'm not saying never use a pass right
that would be a that would be a very
silly thing to say what I am saying is
that you do need to understand what
you're giving up when you do that right
if you choose a platform where your
engineers are going to the people who
are paying a lot are you Nevel are you
going to run into a situation where they
have to just throw up their hands to say
I guess we're just gonna have to call
support on this you might kind of
introduce a culture of learned
helplessness helplessness around
understanding how your how your
application behaves so we should
definitely take advantage of all these
modern abstractions that we have but we
should be aware that there are
abstractions right we need to know
what's going on under the hood when
things go wrong and so I would encourage
you all to err on the side of choosing
for observability and a platform just
isn't where you're hosting it's also the
tooling you're using right so I'm not
saying that you shouldn't pick a
language where their documentation says
well you know debugging is hard let's go
shopping
but if you're going to do that you
should definitely know that you're
making a trade-off right I'm picking on
go a lot because we're good we adjoin
are adopting I've written a lot of go
and we adjoin are adopting go in some of
our systems and pretty much the first
thing we did was say how do we make this
as as observable as the rich tooling
that we have for note this is a
developed James Newseum one of our
developers who's come to us recently
from hashey Corp and this is a dtrace
pit provider and so what he's done here
and this is kind of like the hello world
of dtrace he's got a running application
he's poked into it from the outside and
said stop and core dump when you
dysfunction gets this argument and so it
does that and then resumes immediately
right that's a really powerful tool so
we have a choice to understand what we
built and trying to understand what's
normal what the normal behavior of our
application is right we should be we
have a choice to use our observability
tooling all the time so that we have a
lot of facility to with it when things
go wrong and we can use this to build a
culture of engineering excellence within
organizations or we can pretend we don't
need to and I know which organizations I
would bet on ok the last principal
building for responsibility if you are
not already annoy to me
hold on to your butts every tool we we
choose comes with a community attached
particularly in the open-source world
some of these communities make it a
point to be opening open welcoming
inclusive this is the rest code of
conduct and I'm not saying you should
all use rust right because I can't say
boot choose boring technology and then
say go out and use rusts right that
would those would be opposite statements
but there's a lot to pay attention to
here right from the very beginning of
their of the of this project they've
decided that we want to make sure that
we have an inclusive community other
communities have kind of a well deserved
reputation for being toxic and hostile
I'm not gonna call them out specifically
so but we can choose which community we
want to be a part of right choosing a
tool means choosing its community
particularly with the languages and
frameworks we use right your team is
going to interact with people from that
community all the time right look you
may have a great team but if but you
know your team is gonna submit bug
reports to the frameworks they're going
to submit patches they're going to read
blogs about your software the software
choices that you use they're gonna
attend conferences like this one so if
you if you can build the best team in
the world but if they're interacting
constantly with a really toxic
environment as a result of that they're
not gonna that they may have a long term
impact on their happiness the tools you
select are also going to affect the
people that you hire if you select tools
with deep roots in academia you may find
yourself hiring from the same pool now
if you were building very innovative
deeply innovative work where knowing
that a monad is a monoid and the
category of endo functor no idea what
that means then maybe that's exactly
what you want right but if you're
building crud web apps like and you
would or say well let's build them all
in Haskell and you hire a bunch of
people who are really interested in that
sort of thing they're going to be really
bored with your crud web apps right and
this goes all the way down to the design
of the tools that we use if your
programming language is intentionally
designed with the idea that you're not
smart enough to use a better one I won't
call out what this one is but you can
tell who it is
that may make you think about the
the community that you want to enter
this particular community is fond of
saying that you're holding the phone
wrong when it comes to your programming
language which I find to be really
obnoxious when a community not only
tolerates exclusionary behavior but a
segment of the community decides we're
going to fork this runtime over this
principle that we don't care about this
gender stuff right that says something
really nasty about that community many
of the systems that we build are ripe
for abuse right inclusivity doesn't just
stop with your team
we have misaligned incentives around the
way they were building things so I
mentioned the beginning you talk we have
this kind of embarrassment of riches of
tools right we talk a lot about
JavaScript fatigue people have heard
that term right like there's a new
framework every week and it's like how
do you even keep up with this stuff and
of course to some degree that's great
right like that's the victory of open
source right like every like anybody can
make something new and toss it out in
the world and it will get like chosen on
its own merits maybe but if we if we
thought about like why we hit what why
that happens right like some of it is
gonna be this resume driven development
of course and just a quick aside on that
like if you as a hiring manager if your
things are like well let's make sure
they all have five years and all these
new technologies and like you know this
hard list of technologies for every job
posting like you're encouraging this
behavior right you're encouraging resume
driven development because everybody's
like to get a job with you they have to
be like constantly in on the bleeding
edge well they're gonna want to bring
you the bleeding aids to you too and if
you're you you that is not compatible
with the idea of choosing deploying
technologies once you actually get there
that's an aside but perhaps another
reason why this is happening is that the
missions of our organizations are not
enough for us right we're not being
fulfilled by our work we're we're not
being fulfilled as makers as builders as
creative professionals so I'm gonna ask
a question here don't raise your hands
cuz like your bosses may be sitting next
to you right just like you mean like
stern eye contact if this is the case
okay how many of you are working on
something that makes the world
right some uncomfortable giggles that's
okay all right
so and this can be for whatever
definition you want right like you may
like say you know I would never work on
an ad product like that would be
horrible and you over there maybe saying
like I'm fine with ad products but like
bombs are right out and there's probably
something in the back with a beard it's
always a guy who's like well you know
bombs are okay so long as it comes with
a GPL license right like but for
whatever your definition is right okay
now okay and that for this one raise
your hands if this is true for you how
many of you are working for
organizations that are hiring okay
basically everybody right left up
without comment for a moment I want
everybody from that first group to go
find someone from the second group
during the breaks okay we're all hiring
right every one of us is hiring these it
and we we as technologists are in huge
demand right now this is a seller's
market you do not have to work for a
company where you are making the world
worse you can actually make work for a
place that is at least not making it
worse right maybe it doesn't make it
better maybe it's kind of neutral thing
right the work we do we the work we do
creates the community that we live in
right it reflects our values it reflects
our blind spots to our blind spots is
how we end up with companies like
Facebook and Google saying we demand
your real names which is very harmful to
people who are trans to people who are
political activists who are going to be
actively harmed by the giving up of
their real names in public it's how we
end up with mobile sites that blow away
the cheap data plans of working-class
users to send them a really giant ad for
a product they can't afford our
profession doesn't have licensing which
is probably right like there's a very
large gap in the kinds of things that it
involved in what it is to be a software
engineer right like someone who works on
like embedded avionics like does not
have an overlapping skills I would like
the person who does web stuff like those
are not like the same thing and and not
to say the one is harder than the other
you know I don't ask me to write
airplane stuff that would be a very very
bad idea right so like but but so given
the diversity of skill requirements
it's probably fine that we don't have
licensing but I think that we can learn
from our brothers and sisters in other
engineering professions right so this is
the American Society of Civil Engineers
what if instead of seeing this imagine
instead if we had a code of ethics like
this right I'm gonna read this because I
think this is really important engineers
shall hold paramount the safety health
and welfare of the public and shall
strive to comply with the principles of
sustainable development engineers shall
act in a manner as to uphold and enhance
the honor integrity and dignity of the
engineering profession that would be
really cool right like that that's
really different from this right I think
we can do better I think that software
can improve it a culture and I'd like
you to join me and starting today Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>