<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Programming in Interesting Times • Russ Olsen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Programming in Interesting Times • Russ Olsen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Programming in Interesting Times • Russ Olsen</b></h2><h5 class="post__date">2014-08-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g3lnH4x7pHg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I want to talk to
you about programming language too is
today and this is kind of a meta talk
and I kind of want to start with
something I learned really early in my
career about programming languages and
in particular about the programming
language that I was using at the time
really early in my career and so really
what I want to talk to you about today
is the programming language that you're
using right now I don't know what that
programming language is but I want to
talk to you about it
because I have some sort of it's a
good-news bad-news kind of thing about
the programming language that you're
using right now whatever it is the and
it's gonna kind of come off as a
negative thing but it really isn't a
negative thing it's a mixed bag so they
tell you when you do this public
speaking thing to put the most important
thing first
so my next slide is going to be the
thing I want you to walk out of here
remembering if you remember nothing else
if you fall asleep in the next couple of
minutes I want you to remember what I'm
gonna tell you next and here it is that
programming language of yours it's going
to die it's either going to completely
go away or it's going to sort of become
a zombie
you know the smelly quirks that you're
not going to want to go anywhere near
now this may happen sooner or it may
happen later I'm gonna try and make the
case here that it's gonna happen sooner
rather than later right but sooner or
later this this tool that you have
poured all of this effort into learning
and mastering and sharpening up it's
gonna go away it is gonna croak on you
and how I know that I know that because
of something that happened to me very
early in my career you see see I was a
programmer back that's more or less the
beginning of time I was a professional
software developer in the late 1970s in
early 1980s so you know we had killed
off the last of the saber-toothed Tigers
we had invented electricity and call
Phee so now we could program right and
and I was actually making my living in
the late 1970s programming writing code
and back in that era back if you were
living in the United States and you're a
professional software developer in that
era you lived mostly in one of two
places there are a few people who lived
other places but most programmers in
that era lived in one of two places you
either lived in the southern regions of
hell where you programmed in COBOL this
is a sample of COBOL right COBOL was one
of the original very early programming
languages and they late made a lot of
mistakes they were pioneers right the
people who invented COBOL you can't
really make fun of them because they
didn't know they were discovering this
stuff so for instance if you look at
that third line this is how you did
arithmetic in COBOL multiply hourly rate
by hours work giving gross pay that's
one multiplication all of that all
spelled out they just didn't know they
also didn't know that it was a bad idea
to have a programming language that had
wait for it 500 reserved the words 500
words so if you lived in the southern
regions of hell back then this is what
you program them but I lived in a much
better place I lived in a much better
place I live in the northern regions of
hell and I programmed in Fortran this is
a sample of Fortran I will note that
there's a go-to right this is a sample
of Fortran and fortran's kind of an
interesting case Fortran was invented to
do scientific computing and what
happened was and it was the very first
higher level programming language and
what happened was it spread with the
computer industry so where Fortran was
supposed to be this scientific computing
language people started using it for all
kinds of things including wildly
inappropriate things
I personally programs graphic user
interfaces in Fortran okay menus and
things like that it was crazy but it was
one of the two choices you had to
choices it was COBOL I don't want to go
there we're Tran okay I'll go there
right and there are sort of this despair
in the land there was this despair that
these tools have been in rent invented
in the late 1950s and we were still
using them in the eighties right and
there was this feeling that we were
never ever gonna get rid of these things
they were gonna be with us forever and
in fact there is a famous quote that I
think I almost killed myself when I read
it says Tony Hoare and he's one of the
pioneers this is the guy who invented
quicksort right and during that era in
1982 he said that I don't know what the
language of the 21st century
is gonna look like but I know that it
will be called Fortran we were never
ever ever going to get rid of this thing
but a funny thing happened just like
almost at the moment he said that people
were like stepping back and saying okay
enough I can't take this anymore I just
I just can't do this anymore and people
started looking at other programming
languages and so almost at the moment
that that Tony was saying that the
underpinnings of the whole Fortran COBOL
duopoly were kind of coming apart and
they started this long decline so almost
at the moment he said that they were
dying these languages were dying and it
was a wonderful marvelous time because
it was like suddenly okay I don't have
the right graphic user interfaces and
for train anymore but it was also a
really frightening time because it
wasn't clear what programming language I
should invest in next right I'm a
professional software developer and I
need to invest you know I need to have a
programming language a viable one and
this programming language that I had
spent all of this time with kind of went
away and there is no obvious replacement
there was a lot of competitors there was
Pascal then there was modular - and
there was this programming language that
we would call agile today because it was
the programming language that people
just did stuff in called basic and then
there was this weird little programming
language from New Jersey of all places
called C and of course we know today
they would sort of see that can I rose
up and took
/ but there was this period where it
just was not clear which programming
language you should invest in that the
two major ones were clearly going away
but it was you know kind of a period of
chaos and it was a period of chaos and
it just wasn't clear what to do and that
is kind of the time where I learned that
all programming languages die if these
two giants that have been around for 30
years because some suddenly in a few
years just crumble away you needed to be
ready you need to be ready to grab on to
the next programming language you needed
to be ready to move before you know the
world moved out from underneath you and
it's a real problem because guess what
programming languages are really
expensive to acquire this is data from a
survey that somebody did they took a
bunch of programming languages and they
said how long does it take to become
productive in these programming
languages so C++ gets like a year or two
well maybe Ruby gets three months I
think that that is the just long enough
to become dangerous number but even at
three months three months is 500 hours
of work programming languages are these
incredibly expensive tools right so how
likely is it that you will need to
acquire a new programming language
sometime soon well let me give you
another graph this is from the TOB I
think that's how you pronounce it index
of programming language popularity they
do you know the count Stack Overflow
questions and github projects and job
openings and all that and it's the top
top five or ten programming languages
from 2002 to 2014 now Mike Nygaard would
tell me that this is sort of
statistically a little suspect but I
think you can sort of spot trends over
you know 12 years even with a little bit
suspect data and what this trend that I
see when I look at this is that the
popular programming languages are going
down and the more
or languages or killing up now maybe
that's just visual but if you look at
the numbers so these are the numbers
from that chart in 2002 the top 5
programming languages were 74 percent of
the total popularity whatever the heck
that means today those programming the
top 5 programming languages are 54% they
dropped 20% how much difference this 20%
make 20% is the total footprint of the
next 11 languages combined right 20% is
c-sharp PHP Python JavaScript Perl Ruby
f-sharp plus 5 more languages that I
couldn't fit on that slide combined
right I think we are entering
interesting times again the same kind of
interesting times that we had back when
I was a newly minted programmer so the
question is if you got a move if you got
to find yourself a new programming
language how do you pick how do you pick
one there's no obvious choice which
programming language do you invest in so
how do you pick well it would help if
you knew what you are picking it would
help if you knew sort of what exactly is
a programming language because they're a
programming language is actually a lot
of things programming language is sort
of this you know we can think of it as
this description Java is an
object-oriented language independent
statically typed blah blah blah and
that's one aspect of a programming
language but another aspect its syntax
right here's the BNF for a java class
declaration so languages syntax - a
programming language is also a whole
pile of software there's compilers
there's interpreters there's Eclipse
plugins if it's at all a popular
programming language there's a giant
pile of libraries maybe maybe open
source libraries programming language is
a whole bunch of software or maybe
that's how we mostly interact with
programming languages right as software
and then programming languages
or people right you me there's a
community around every even moderately
successful programming language right we
go to conferences we write books we
write magazine articles we answer
questions on forums programming
languages are people too so how do you
pick a programming language I think the
most obvious sort of Lee default choice
maybe is you picked a popular
programming language right it's maybe
the low-risk choice you just go and find
yourself a popular programming language
that's it's safe right it feels like a
safe choice it might be a safe choice
but it's not a great choice and I'll
tell you why they do survey somebody
does survey and they said they asked a
very specific question what programming
language are you currently using not
which programming language do you like
not which programming languages are
favorite but which programming language
are you actually using right now and
then they asked the second critical
question which is why are you using that
programming language and here's the top
five reasons people gave for using you
know programming language X number one
is the availability of open source
libraries this is a survey of open
source developers so it's sort of
slanted towards open source I suspect
that if it wasn't open source developers
you could just drop open source I
suspect the real thing is the
availability of libraries okay that's
number one number two is I'm extending
some code that's already in Java or
whatever number three is I'm already
using Ruby or whatever number four I
find the little frightening number four
is I'm familiar with it the thing I find
frightening about it is it's after I'm
already using it that that seems
frightening to me number five is the
people around me are using it notice
these are all pretty much community
based things people pick programming
languages based on the ecosystem and
that makes sense
the next six reasons why people use
programming languages are more about the
tooling
around that the software around it great
there's performance which is part the
programming language but also part the
quality of the you know the compiler or
the interpreter or whatever there's
portability there's development speed
number nine is the tools number ten is
safety and correctness which is part
tools and part the programming language
but here's the punchline number eleven
is language features it doesn't even
make the top ten reasons why people use
programming language a particular
programming language right if you pick a
popular programming language you are
picking the echo system and you're
picking the community you are not really
picking a programming language and maybe
that's that's okay
but you have to go into it with your
eyes open this is probably the ugliest
chart I'm going to show you today but
this is a really interesting chart I'm
going to here's my simplified version of
it so I can talk to you this is from a
survey of open source program projects
and it's basically here's the most
popular programming language and here's
the one hundredth most popular
programming language and the line is how
many projects are using this thing and
note that it's a logarithmic scale it's
110 100 and and what you see there is
the most popular programming language
which I think in this survey was Java is
used 10,000 times more than the
hundredth most popular programming
language the number of projects drops
like a rock with popularity this is a
familiar kind of phenomenon this is the
hit song model of popularity right
there's a few songs that sell millions
of copies and then there's everything
else right and this is the trademark of
a runaway positive feedback loop right
for some reason one thing gets a little
bit more popular like a hit song or a
programming language and because it's
more popular it gets more buzz which
gives it more buzz which after a while
it just runs away
and there's a there's a something
associated with this they're better this
kind of behavior no matter if you're
talking about programming languages
Hollywood blockbusters work the same way
right a movie gets a little bit of buzz
and then more people know about it and
then where people know about it and the
problem with it is in technical terms is
that the popularity is not really
related to the quality of the product
right so if something gets a little bit
more buzz say a Hollywood blockbuster it
runs away with the box office sales
without really being all that good in
programming languages kind of seemed the
work the same way it's not necessarily
related to the quality so you look at
programming languages as sort of like
Hollywood blockbusters where the
popularity isn't related for the quality
of the product right so you know for
instance I would not say that JavaScript
is the snakes on a plane of programming
languages but you know with JavaScript
to be where it where it is today if it
hadn't come out at just the right time I
wouldn't say that layout but so the
point is that if you pick a programming
language based on its popularity
you are basically factoring in this huge
random factor of this language got
popular simply because it got a lucky
break early on
hence snakes on the plane there's one
final problem with picking a programming
language based on popularity and that is
you're gonna be if you're following the
crowd you are gonna be one of the crowd
right it's hard to get any kind of
competitive advantage out of simply
following the crowd it's sort of you
know you're picking it as commodity and
that's okay but you need to know you're
sort of picking things as a commodity
actually it's not the final thing the
final thing the final final thing is
that popular programming languages have
another drawback which is that it's hard
to get new feature
it's hard to get innovation into a
really popular programming language
because there's so many people watching
they have to be compatible with all of
the the people who are using it and all
the programs that are using it and so
you know it's going to say that popular
programming languages include new
features at the rate that grass grows
but that would actually be an
overstatement right it object-oriented
programming was invented in 1967 there
it was all there in 1967 classes
subclasses objects methods the whole
nine yards took 20 years for
object-oriented programming to make it
into a popular programming language 20
years right you could grow an awful lot
of grass either variety in 20 years so
but if you do if you do look at this
kind of survey data
the popularity of programming languages
you can actually if you dig a little bit
there are some interesting things you
can find out from the popularity of
programming language is something you
can actually act on and the question is
where is the you know a given
programming language popular if you dig
into this kind of survey data you can
kind of make a DNA fingerprint of a
programming language you sort of divide
it up and say what domains is this
programming language popular end so
maybe engineering calculations or
medical applications or whatever and if
you make a little rectangle for each
domain and you make the rectangle darker
if the programming language is put more
popular in that domain well you get
something that looks like this and if
you pick a proper popular programming
language like Java you will discover
that it's kind of popular across the
board and there was no big surprise
there it's a popular programming
language but if you look at less popular
programming languages you get sort of a
surprise and that is less popular
programming languages if they have any
footprint at all tend not to be
uniformly less popular they tend to be
popular in specific domains and not
exist non-existent in other domains and
that's something you can actually act on
if you're looking around for a new
programming language one of the things
you can ask yourself is is
there's some lesser-known programming
language which is actually pretty pretty
highly used in the domain that I'm
interested in you know a good example of
this is Ruby I say Ruby you say Rails
right Ruby is not a widely used
programming language except in let's see
small to medium-size web applications
backed by a database where time the
market is important that's where you
find Ruby that's its domain so it's got
a little dark rectangle there you can
actually even follow the life cycle of
programming languages like this if you
go back to my old buddy Fortran Fortran
started out in the scientific domain and
then it grew with the industry until it
was everywhere and that's where I came
along right and then it started to die
and I said that it died but if it really
died it returned to its original home it
returned to its ancestral home and so
the reports of fortran's demise are a
little exaggerated portrayal is still
the language to beat if you're doing
like just pure calculations Fortran is
still the fastest thing around people
still use it so the takeaway here is
that less popular programming languages
tend to be popular in specific domains
and they can be quite popular in those
domains so if you're looking around for
a new programming language ask yourself
the question what domain on my end what
other languages that I might not have
otherwise considered are popular or what
widely used in this domain but still
question is sort of the more general
question that's kind of a special case
the more general question is how do you
pick a programming language if you're
going to pick a programming language to
follow how do you pick one um one thing
you can do is you're gonna ask which
family of the programming language is in
this is actually again there's survey
data behind this but there's a wonderful
little story from Rob PI crap Pike is
the guy behind the go programming
language and they desire and as
colleagues design go to be a better C++
there
they didn't like about C++ so they tried
to build a better C++ cuz that's never
been done before and they expected that
the people who would use go would be C++
programmers right it's a better C++ and
in fact what they found is that this
actually people maybe like me who are
using go people from the Ruby world of a
Python world or the Perl world and if
you think about that for a while it
actually makes sense if you're a Ruby
programmer you could learn Python Ruby
and Python are very similar you could
say I'm gonna learn a new programming
language let me go learn Python that'll
be easy because they're similar there's
actually sort of an input problem and an
output problem with that the input
problem is that there's like 10,000
little details you need to know to
really know a programming language in
Ruby the constructor method is always
called initialize spelled all the way
out in Python its underbar underbar init
underbar underbar and you've just got to
know that right it doesn't have anything
to do with the model of the programming
language or any of that you just gotta
know it so it's actually harder to learn
you know a supposedly similar
programming language then you might
imagine and then there's also sort of
the mental interference and I've
experienced this myself recently Ruby
programmers trying to do Python oh god
is that the Ruby way of doing it is that
the Python way of doing that the fact
that they're so close together means
that you have a hard time remembering
which ones which I also do closure I
never have that problem between Ruby and
closure because they're so different
so it's actually harder to learn a
similar programming language than you
might think so that's kind of the input
side the output side is stuff I'm a Ruby
programmer and I learn a similar
programming language Python what if I
really got Python is about as capable as
Ruby so I end up not really you know
work all this I work really hard and in
the end I can do pretty much the same
thing I get to do before on the other
hand if I learn go or Objective C
there's suddenly all kinds of different
things I can do yeah it's a little
harder but there's other things I can do
so we can actually
can a manufacturer families of
programming languages write like Ruby
Python Perl go Objective C and and say
to ourselves so we make a periodic table
of programming languages and we could
say okay find yourself on this table and
I will admit I have no idea where
JavaScript goes on this table it could
fit in a dozen places it's like there's
elements at the bottom of the periodic
table find yourself on this chart and of
course this is in all the programming
languages so maybe I know Ruby don't
learn another language in the Ruby
family go find a different family go
learn closure right go learn a lick sir
if you're a c-sharp program or go learn
Ruby or closure okay find a different
family it pays better
right and in fact they've done surveys
and it turns out that people who know a
lot of programming languages don't know
a lot of similar programming languages
they tend to know one from each family
right that is something to know that is
something you can act on but I will tell
you this if you do try to learn a
programming language that's in a
radically different programming language
you are going to run into a barrier that
barrier is syntax syntax is the iceberg
of learning new programming languages
you know every time you come to a
significantly different a significantly
far in syntax let's be honest you look
at that and you get a pain in your
stomach grade does that really code the
people really write that up you know and
I've spent I spent a few years teaching
Java programmers Ruby and it got to the
well and if you teach Java programmers
Ruby there's a whole list of things they
will ask you you will you know you hear
the same questions over and over and
some of them are quite rational and
worthy of talking about I don't
understand how you can build reliable
software without static typing that's a
good question that's a question that the
deserves an answer it's this question
that deserves discussion I don't
understand how this you know code
replacement thing where you can modify
the code on the fly I don't understand
how that can come to any good Martin
said that this morning what we could
talk about that that is a rational
question where the irrationality comes
is when you start talking about syntax
and I used to keep a running list of
like the silliest things that people
would say about Ruby syntax let's say
Java programmers because that's who I
was dealing with this has got to be my
favorite
I could never program in a programming
language that didn't use curly braces
for statement grouping really Wow
you know is that God's anointed way of
writing code right is that how God
intended code the look or is it just
what you're used to but so you won't
think that I'm picking on the on the
Java programmers if you take a Ruby
programmer and send them off the closure
you are about 50 percent likely to hear
that that's right is that an evil way of
writing code right or is it just not
what you know is that just unfamiliar
right is it you know we all have this
feeling whether we put it in whatever we
put voice to it or not we all have this
feeling of I know what code should look
like and when I see something that
doesn't look right it grabs me somewhere
deep inside and makes me feel like it is
evil right just keep in mind that any
sufficiently foreign syntax is
indistinguishable from evil as far as
your emotional life is concerned the
problem is that if you like the syntax
thing like rule your life rule your
choices of programming languages there's
an enormous cost to it and the cost is
you know go back to the periodic table
right I'm a ruby developer and you know
that is God's anointed way of writing
code it's got to look like Ruby well
what do I have available depending on
how Orthodox my religious opinions are
great I might be able to do Python or
Perl
god bless them I might be able to do a
lexer since 2012 but that's it
but the Lisp languages are close to me
the Java languages are close to me
javascript is close to me maybe a mixed
blessing but and the other thing is well
I can do a lick sir but look at the date
elixir came out in 2012 Erlang is 1986
if you're you know if you hold on to
your syntax if you say I just you know
it's gotta look like Ruby or whatever
your favorite language is you're gonna
wait for you know you're dependent on
the kindness of strangers to bring new
technologies to you alright and the same
thing if you're a Java programmer well
you got a few more choices but there's
still a whole portion of the periodic
table which is just plain close to you
you got it you got to kick the syntax
habit you got a you got to just work
through the pain but so what am I saying
I'm saying look at the domains your
programming language is it or are what
the domain that you're working in maybe
that will clue you in to a new
programming language you know jump to a
different family you know let go with
the syntax but I still haven't really
answered the question of how do I pick a
new programming language and the answer
is I don't have an answer for you I
can't tell you what what the actual
rules are for picking a new programming
language but I can kind of tell you the
meta rules the meta rules that I think
are involved in in picking a new
programming language are that you need
to know the questions that are important
to you the questions about how do you
build software think to yourself what do
I think the important questions are in
building maintainable reliable software
that you can reason about think about
what those questions are come up with
your answers and then chase the answers
into a programming language so I don't
know what your questions are
I don't know what your preferred answers
are but I know what mine are so let me
let me kind of take you through mine
just the
give you a feeling for what I'm talking
about so I think the fundamental
question that all programming languages
have to answer is how do I organize my
software how do I organize my programs
so that they're reliable and
maintainable and I can reason about them
and the standard answer for the last 25
years has been object-oriented
programming right that is kind of the
default answer that we have and it is
the answer that we kind of measure all
the other answers by so let's talk about
object-oriented programming for a minute
the thing is that object-oriented
programming is not one thing it's whole
family of ideas right there's the
standard object-oriented model that you
get in say Ruby and Python and C++ and
maybe Objective C which is you have
classes and you have subclasses and you
have instances of those classes right
it's the familiar model but it's not the
only model the go programming language
has classes but no super classes there's
a type hierarchy in Kiowa is that a good
idea do you like that
does that seem like that makes sense I
mean they have things that effectively
replace the super classes the class
hierarchy but is that an answer that
works for you maybe right
javascript is not really a classic
class-based object-oriented programming
language it's an object-oriented
programming language but it's based on
prototypes right where essentially every
object can borrow behavior and data from
any other object is that a good idea
does that strike you as a good way to
organize software there's also the
question of information hiding object
you know classical object oriented
programming says you should take your
data and stick it in this object and
hide it away so languages like Java they
have keywords like public and private
then they help you like Jam the data
into this effectively armor-plated
object right it's got a really thick
skin and you know you put the data in
the object and you seal it off and then
you drill some
in that armor and then you carefully let
the data in and out and of course the
idea is what you're trying to do is
you're trying to isolate the complexity
you know inside the objects but it's
that really a good idea some functional
programming languages and Ruby Rubeus
and various other programming languages
they say no that's a bad idea you don't
want to hide the data away you want to
take your data and you put want to put
it in these generic transparent
structures so if I have an employee I
just have an a hash a key value set of
key value pairs I've got name and
employee number or you know if it's a
book its title and author and it's just
a plain old map or hash and if you got a
bunch of them you just put it in a plain
old vector or a plain old array nothing
is hidden right who are you hiding the
data from these people ask right you're
hiding it from yourself you're making it
hard for your for you to get at your own
data is that how you think you know
programs should be organized chase the
language from there and then there's the
whole question of whether you want to do
object-oriented programming right do you
want to hide your code or segregate your
code by these classes stick them inside
of objects package them up with some
data and do that that has been the
standard answer or do you do want to
want to do the functional thing where
the code is kind of like the key thing
and you've got these data in these more
or less transparent data structures
which way do you think you want to go
what makes sense to you that's how you
pick a programming language
alternatively you could do the Scala
thing you have both right it's
object-oriented it's functional peanut
butter and chocolate right the other
thing we were just talking about this
last night is do you need data types
this is completely orthogonal to
object-oriented or functional do you
need data types do you need to say that
everything is a left handed widget
sifter and then make sure that it only
touches left handed widgets where do you
just say I'm a thing you know
is it do you want dynamic typing do you
want static typing how complicated do
you want that typing system decide the
answer to that and chase the language
there right there's the whole question
of concurrency right for years we've
done I've got a bunch of threads and
they all fight over the same data and
deadlock each other that seems like a
bad idea I will tell you that that seems
like a bad idea but do you do you solve
that problem the way elixir in Erlang
and go do by having these tasks that
communicate over channels with each
other
closure does the same thing or maybe you
treat the the changes to share data like
database transactions this is another
idea from closure where they change the
some shared data either either goes in
in its entirety or it gets rolled back
and retried just like say a relational
database is that a good idea right do
you believe in mutable state is that a
good idea can I just take a new salary
and jam it on top of the the old salary
and an employee record or do you think
that you should just the only thing you
should be able to do is make a new
employee record that looks just like the
old employee record but has a different
salary so the question of which language
really I think is the wrong question the
start with the right question the start
with is which questions do you think are
the better questions to start yeah are
the questions that you think are
important for building software decide
on the questions decide on the answers
and then work from there because
remember your programming language is
going to die right sooner or later
you're gonna be faced with this choice
if I'm right if the sort of dominant
programming languages of today are
declining then it means you're gonna be
faced with this choice pretty soon if
I'm wrong well it'll be a little longer
but you're still faced with this choice
so I kind of like to leave you with a
variation on the quote I started with
I don't know what the language of the
year 2000 is gonna look like but I know
it'll be called Fortran so here's my
version of it I don't know what the
language of the year 2030 will look like
but I do know where to look for it you
know where you look for the next
programming language you look down here
you look at the obscure ones you look at
the marginal programming languages
because it's down here on this curve
this end of the curve is where all the
innovation is happening it's this end of
the curve where all the interesting
things are happening just remember
change doesn't happen in the mainstream
change happens to the mainstream right
and you're going to decide if you want
the change if you want to be part of the
change or you want the change to happen
to you that's all I got thank you all
for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>