<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Elixir: The only Sane Choice in an Insane World • Brian Cardarella | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Elixir: The only Sane Choice in an Insane World • Brian Cardarella - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Elixir: The only Sane Choice in an Insane World • Brian Cardarella</b></h2><h5 class="post__date">2017-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gom6nEvtl3U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so first start by saying that the title
is a bit of a loaded statement further
strategy of getting a talk accepted is
to you know give kind of crazy idle talk
and hoping that it stands out and then I
am burdened with having to defend the
the title talk during the talk I do
think that there is some truth in it
though and hopefully I'm able to at
least get some people on my side
tradition so I like curiosity first of
all are there any people that are
actively developing their day job in
elixir in the room no name buddy
unfamiliar with elixir they're just like
what is that I came in here to learn
more about it okay all right so about
half the room it's familiar with liquor
the other half so I'm familiar that's
good mix alright as I was introduced on
the CEO of Dockyard we are a software
consultancy and we do full stack
application development so if your
company has a project that they want to
ship out to a company that has a very
good track record of delivering on-time
and on-budget application build issues
please consider us so why the infinity
I'm going to try to define the insanity
in today's terms as the amount of demand
that's being put upon engineering teams
to deliver today's problems on today's
problems we're starting to have
requirements that may have a mix of
distributed systems mitigating downtime
cell failing systems real-time etc and
these are difficult problems of solve
for the tools that we've been using for
the past few years on top of that your
systems must be fast and they also must
scale to ever-increasing demand as more
of the world gets turned on and mobile
device is getting faster
interconnections there's going to be
more demand put upon your applications
that are coming from a global demand now
the most part as I said we're using
yesterday's tools but the way that we
reach for new ideas like entrepreneurs
or managers or teams or part developers
in general is we've taken like the older
problems which was how do I build a
dynamic running application and we've
kind of bullet down to get push Roku
right so that problem is solved it's
hyper optimized and now that the cost of
building those outs are so nominal now
the problems that were that felt
unreachable before are now problems that
are within our reach but we're going to
need the tools to build this out so
before I get into the elixir stuff I
want to take a step back 30 years and
talk about the underlying technology of
elixir and it's early so for those of
you that are from unfamiliar with Erlang
it was a rather it is a technology that
was built by Ericsson on the
telecommunications company out of Sweden
it was like mid eighties late 80s when I
was build a thing it's really 28 29
years ago not exactly around 30 but it
was meant to handle global
telecommunication systems so the some of
the requirements of it are like almost
zero downtime right so if you have a
telecommunication system worldwide you
can't really deal with downtime you have
to have fall backs you have to have fail
shapes you have to have systems that can
monitor other systems to ensure that
they're going to be bounced properly you
have hot code loading so think of your
phone right when's the last time you
received an update from your provider
saying we're taking down the network for
an update you know it doesn't happen so
in Erlang you can actually have the
system in production and you can push
code deltas up without taking the
production server down and it will
absorb these code deltas and incorporate
them into the runtime that's currently
live in production these are some really
incredible and kind of
they feel like cutting-edge technologies
today that have been around for a long
time so if that's the case if they're
lying so awesome then why aren't we
using our line I mean there's a couple
different potential answers to this a
lot of them are opinion based but this
is my opinion why we're not using our
line it's just in tax so I mean it's
against one of the reasons but Erlang at
the time was based upon prologue syntax
which has a I think the way to describe
it it's like a sentence like a like
programming structure where each line is
eliminated by a comma the statement is
finished with a period but it kind of
grew over time organically and so
something that should feel simple ends
up looking difficult for those that are
used to more modern syntaxes in their
languages I personally came up learning
C C++ assembler through Microsoft
assembler and then he jumped over to
Ruby and been doing JavaScript so I
don't want to think those steps I don't
take a step back and tactically like if
I'm working in my day job I'm working
with a language I wanna use something
that I enjoy it feels like a bit of a
cop-out I think some people that perhaps
have been programming for a long time
they may be thinking like all that
that's a stupid reason but the the proof
is there and that Erlang has it reached
math adoption
despite its incredible power despite how
well its solutions applied to the
current problems or doing with today on
the web and this is where elixir had an
opportunity so this is Joe Armstrong
this is much younger picture of Jill
Armstrong so Joe after elixir a pickled
version but early on in its inception he
on his personal blog he wrote a link
down the bottom anyway is it just a blog
post and he's they got I'm going to
check out this elixir thing and one of
the quotes in there he recognized the
syntactic issue of her Langan
what electric brings to the table here
so he said quote what elixir brings the
table is a complete different surface in
text inspired by Ruby well you might
call a non-scary
plum code syntax and loaded extra
goodies so elixir a little bit of
history of elixir is that it is created
by a programmer name is Jose a Bellini
and he was at until maybe two years ago
somewhere around there on the Ruby and
rails core team he came up learning Ruby
gone through the rails core team was
probably one of the top developers on
the core team but while he was working
on rails he saw a lot of the problems
that the rails core team was trying to
solve
especially around concurrency and how
difficult it was to solve these problems
with Ruby as the language that they were
limited to so I'm not trying to talk
down to Ruby at all ruby is an awesome
language they gave me a career I I was
not doing anything after college and
then I got into Ruby and I had about ten
year career working in Ruby so I'm
particularly rails I'm very thankful for
for that technology but you know we
can't use the same technologies forever
and as I said earlier as the problems
become more complex
we'd better tool to solve those so in
kind of the bit of research on how best
he can solve these concurrency issues
within rails
josée went back start reading a lot of
papers he always had an interest in
Erlang and he decided you know Oh screw
it I'm going to try to write a syntax on
top of the Erlang virtual machine the
first pass was a bit of an
object-oriented application sorry
object-oriented syntax of a compile to
the Erlang functional byte code that
didn't work he then backed up and said
like look do I have to try to create a
whole new language or can I just kind of
keep this like this light sugar on top
of her line and that's where he really
found a good place to excel with elixir
so
the elixir itself it's you know it is a
language but it is you know it's really
a surface level language that doesn't do
much on its own beyond once it compiled
her line it allows erlangs virtual
nation to handle all that stuff so when
you compare it to other languages like
Scala or other like the JVM has a whole
bunch of languages that run on a virtual
machine Lister is probably less involved
with the nuts and bolts under the hood
then some of those other languages are
elixirs probably more complex part of
the source code is really a parser and
tokenizer once you get past that a lot
of the language itself is actually
written in a lick sir so if you were to
check out the elixir github repo you
would see I think it's something like 80
north of 80% of the actual repository is
an elixir itself so simple statements
that you may be considered to be like
compiler keywords like if statements are
actually just elixir code that is you
can write your own if statement through
a macro system that I'll be talking
about a little bit later but anyway so
let's see what some of things that
elixir inherited from our line so as if
there's the battle-tested 30 drill
technology if you're in here like
wondering like is this a good technology
for my company so nowadays we're kind of
overwhelmed with the number of new
languages new frameworks are coming out
almost on a daily basis like if you're
reading hacker news it's you know the
running joke like what's the new
JavaScript framework this week and we
kind of have this sense of anxiety like
you know should I be on the latest and
greatest thing all the time I think I'm
a hiring perspective sometimes that may
be easier because people like to work
with and tinker with the newest thing
but anybody that's been a manager in a
technology company for any period time
could tell you that well there may be
easier to hire when that person leaves
your company I mean the technical debt
that you leave behind is very very
expensive so I in my career I tended to
actually look back and try to look at
things that have
work from technology perspective how can
we leverage that in the future and our
link to me makes a lot of sense here so
it's not like an unproven new language
that we're taking on this significant
risk into our organization this is
something that is being used in our
global scale by multibillion-dollar
corporations right now when it comes to
managing distributed systems there is a
library within so I've actually bold the
James River there's a library within
Erlang called gem server and we will see
code examples on how easy it is to write
a gen server how easy it is to work with
doing asynchronous and concurrent
computing we can get self-healing
systems through supervisors so what do I
mean by self-healing a fillip feeling
system is one that recognizes when
something goes wrong and puts us back
into a good state and the supervisor
pattern within Erlang is a very simple
idea that ends up being incredibly
powerful and if you've done any type of
programming where you're having to
predict how can the system go wrong and
having to basically do a lot of error
caching and if statements or case
statements I think that the supervisor
pattern is going to be an eye-opener for
you based upon one simple principle
which I'll get to on those floods and it
can quickly feel to me tomorrow's
demands and finally a nice kind of
syntactic thing is pattern matching
which I will show so nuclear elixir so
those visual things that all those
things from our laying is what elixir
inherits and these are the things that
elixir adds on top of it so it adds a
clean familiar syntax if you've worked
in Python if you worked in Ruby if
you've worked in c-sharp there's all
different aspects of those languages
that Joe's a look so he looked at the
kind of the landscape it said like okay
I really like Ruby syntax but there's
some things that are wrong with it
some things I wouldn't have have done
myself he took all the best things that
he thought were the best things from
different languages and brought them
into a lecture for the syntax as amateur
tooling system
so for a language that just hit 1.0 in
the past year and a half or maybe closer
to years at this point ie launched with
a task running tool called it's that one
called mix it mix brings in debugging
tools linting tools documentation tools
dependency installation and dependency
resolution tools generating tools so all
these things are already built into
language this is in a separate library
that you have to bring in that's just
something that as part of the core
languages made part of it built-in unit
testing again through the language grew
way of it's called X unit meta
programming so meta programming to you
and different language may be may be
considered dynamic programming right
like how do I declare a class
dynamically or how do i define a method
dynamically meta programming and elixir
is actually a lot more deeper than that
so it actually tries to do away with the
idea of dynamic application like code
creation and it brings in this idea that
what you're generating is only being
generated at Build time so I forgot to
mention elixir is a compiled language is
not a naughty language said that is at a
runtime type language
so during compile time the macros that
you're doing better program with well
actually view the pile down to bytecode
and you can do language extension
features at this point so when I was
measuring the if statement and things
like that earlier those are all done
through the macro system the meta
programming system in elixir built in
documentation is the documentation is a
first-class citizen inside elixir in
fact it's not just documentation itself
but there are this concept called doc
tests which I wasn't able to add to my
slides but doc tests will actually route
allow you to write small little unit
tests inside your documentation and so
that when you run your test suite you'll
run the doc tests as well to ensure that
your documentation is actually showing
the proper working code which is really
important so Joe they want to make sure
that documentation was you know
something that was really
first and foremost the mind of Alicia
developers pipes which is another
syntactic sugar and filing Phoenix which
I won't get to today but Phoenix is a
web framework that is probably if you
heard a lecture that's probably the
reason why you've heard of elixir so
let's look at pattern matching so this
is a simple statement eight equals one
but we have to consider that in a
lecture we're not doing what is done in
other languages so in other languages
you'd be looking at this is saying this
is an assignment now look sir it's not
an assignment it can feel like an
assignment because after you've done
this the a variable has the value of one
what you're saying is that a is equal to
one so you have to look at it like an
equation the left hand side on the right
hand side of the equation operator
because what you can also do is that
after you've said a is equal to one you
just say that one is equal to a both of
these are valid statements but only
after you've done to the first one so
this is the basis of pattern matching
you're saying that some variable is
equal to some value this is also a valid
statement so these are not arrays user
lists there's no concept of arrays in a
lecture but lists have mostly the same
purpose there's another type called a
tuple that can also act probably more
similar similarly to a list a to an
array but anyway in this case I mean
these are exactly the same values right
these have equality you can go on to the
elixir IEX which is the kind of repple
for a lecture and you type this in and
it would be a true statement so you can
do this what I'm saying now is that a
list with a variable a in it is equal to
a list with the verb with a value of 1
which means that a is has finished is
equal to the value of 1 so if I were to
unwrap the a variable from the list the
value of a would be you know
a list one rapid list but in this case
were pattern matching or we're saying
that based upon the pattern the right
hand side we have pattern a left hand
side and matches it but we're saying
that this variable matches the
particular value that knot that pattern
matches on the right hand side we get
more complex so here's a here's a two
dimensional list and of course all the
values were able to capture those and
finally we can get you know you go to
end and any gap so we can say that the
third element in here is also a list and
if the third element on the right hand
side is also a list we've properly
pattern match upon that and we capture
the value inside so what this ends up
doing is that this kind of primer right
here it will prepare you for writing
functions with an elixir so typically
when you're in other languages you only
get to write like one in function
definition there's plenty of other
languages you can write multiple
function definitions you know based upon
the arity of your arguments but in a
lecture you can write multiple function
definitions with the same arity but have
different patterns within that area so
here i've declared two functions foo and
i put values directly inside the
function arguments and this is
completely valid syntax if i call foo
and i pass the number two to it it's
going to call the second foo function
because it looks at the values there and
just matches it it says okay this
pattern matches this these values
matches pattern if I were to have a flu
with just a named variable inside of it
then based upon the order that it is
defined in it will match so it kind of a
first win so if I were to have like flu
and then bar up above blue one that
would be a greedy matcher and and that
one were always wanting to just the
order what you tries it but if I put it
last then if I pass blue three it would
pass to that one and then the variable
in the argument would be
would have that value looks you're smart
enough that if you were to put the
greedy matcher
above a function that otherwise should
match it will warn you when you compile
and say that this function on this line
will always match and then functions XYZ
can never be can never be matched let me
back up for a second so this pattern
ends up being really really powerful
because what it really does is kind of
breaks out branching logic right so you
may have functions that you've written
our methods that you've written in other
languages where we get passed into the
function now you have some like really
nasty if statement in there to kind of
you know break up the conditionals or
you may have to sacrifice on your
function naming by basically creating a
bunch of different function names that
are you know maybe things is hard and
programming languages what this ends up
wanting you to do is doesn't so much
obfuscate the the conditional logic but
at least allows you to give a cleaner
pattern for having branching in your
code and having specialized function to
handle things
pipes allow you to clean up messes like
this so I super guilty of this and other
languages you may try to clean up a
little bit by doing something like this
so you take the innermost function
assigned to a variable and you keep
passing it down and down and down and
down well this is another feature that
electric soul so it's piping and the way
it works that it takes the value that
you're piping and it will inject it as
the first argument into the
corresponding function does that mean no
so if you know the result of bad taking
the hello world value gets piped into
the first argument to bar and the result
of bar gets piped into the first
argument of foo
the pattern that starts great for you in
your in your your elixir code is that
you start to really write for
composability right so a while your
functions end up corresponding to this
simple idea that the first argument
should be to carry out
to carry value in fact elixir wraps a
lot of the Erlang API and it rewrites
the argument order to try to ensure that
the primary value being passed in is
always the first argument to allow for
easy function it starts yes a lot of for
easy function piping the scalability so
that was all syntax those nice stuff and
there's a lot more really cool syntax on
lecture but I'm limited on time your
length VM also known as the beam I do
not recall but it stands for at the
moment so the Erlang VM is almost an
operating system onto itself its primary
purpose is to monitor and schedule its
own processes so within within and if
you're confused on inter changing or
Lang elixir just let me know and I'll
okay explain a little bit more but again
Erlang is the underlying system of
elixir lecture it depends upon our
length and so a lot of this kind of
low-level stuff is our traits of our
life but a lecturer gets everything so
in in in our length you have the idea
that it is a very concurrent language so
you can create very small and cheap
processes very very easily and all those
processes are monitored and scheduled by
the Erlang VM so in the same way that
your operating system monitors and
schedules operating system processes or
Lang VM monitors and schedules its own
processes so it will make sure that when
these processes die that the right error
code is being reported if the processes
are kind of eating up a lot of resources
it's probably distributing them within
the system as it said so it's
contributing them it can actually
distribute them across all available CPU
cores this is a huge performance gain if
you have anything that is fairly CPU
intensive and it happens automatically
so as long as you're running your
application in a concurrent manner and
using processes then all the processes
will get the Shoojit cost be available
to you cords to the Erlang PM
so one of the more popular deployment
targets in general right now is Roku and
everyone's wondering if the point is
still kind of a difficult answer to give
us the straight something difficulties a
straight answer to an elixir the problem
being solved but we don't have an
awesome deployment story yet there's
decent ones but not awesome ones and so
the reason for that is you can do get
push Roku
but Roku is not a good deployment target
for a lick sir and the reason for that
is because Heroku shards your CPUs you
can pay for dedicated you know system
where you're going to get a multi-core
Roku box but then you're paying a lot of
money for me right now I think it's
better to go with like a Rackspace or an
LED note or something like that so that
you get those dedicated course work at a
better cost just deal with the
deployment headaches for now so the nice
thing is that the Erlang processes are
incredibly cheap compared to operations
and processes so each process is a
little bit over a kilobyte so you can
spin up by ton of them it's been a very
very fascinating diver very quickly and
on top of that each process carries its
own garbage collector
so what depends on meaning for you is
that in other languages where you have a
single thread our main thread and the
garbage collection ends up happening it
may be a marking sleep you may be a
generational garbage collector but in
any event it still has to stop the world
and do its work while it's collecting
all the garbage now if you take another
language with a center of objects and
compared to a Erlanger literature
application with the same number of
objects these objects may be distributed
across multiple processes and if you
process runs concurrently and has its
own garbage collector then the surface
area in which it's actually supposed to
for cleaning up its own garbage is very
very small so that garbage collection
process goes very very fast on top of
that those those processes are there
aren't currently garbage collecting are
still running so this is where Erlang
gets a ton of it
from because it's not lot its main roads
not being blocked by any garbage
collection any one garbage collector
rather so a lot of the the process work
process kind of skilling within Erlang
was evidenced through work that employee
of ours Chris McCord who created the
Phoenix framework was doing with a with
WebSockets in Phoenix so he was around
like early 1.00 Phoenix someone came
into one of the channels or an IRC and
said hey I tried to scale up to 60,000
concurrent connections and started kind
of bombing out on me
so Chris started poking with it and
after a week he got up to two million
concurrent connections and at that point
I figured this was good enough that's on
one box that is one box it has a ton of
memory but it's one Rackspace box that
was able to scale up to two million
concurrent connections these are not
just dummy connections sitting there
doing nothing they were actually
simulating real conversations real
message passion between each other the
latency for distributing a message
across all two million web sockets at
that point was lucky two seconds so you
can imagine that you know real-time
communication system that is dealing
with a lot of people like to think of
slack like I can't imagine how much
money slack is paying at server power
right now because I know that some other
underlying tech is PHP I don't know if
that further real-time side of things
but I know that is part of their stack
but I would just be I mean it wasn't
surprising that they were using Erlang
in some way but I don't know what they
are if they weren't I can imagine I can
only imagine that something like this
could really cut down their cost if
you're doing anything that is a
real-time messaging system I you
immediately can start to see the
benefits of this from our business
perspective and how you really can bring
down your overhead big time so let's
look at a case study specifically on one
company that was able to have massive
infrastructure savings by moving from
one language over to elixir
and sweet report so they had an
eight-year-old real gap and here are the
here's the architecture of that real tap
for anyone that's not familiar with
bleach report it's a Sports News website
so they do a lot of reporting they have
a lot of video when I top of that they
also do like a lot of push notifications
right so a big thing in the sports news
world is who pushes the sport who's
pushes the sports news first
prior to this which herb if you had like
a CBS Sports and ESPN and Yahoo Sports
and whatever applications on your phone
you have bleach report on there it would
take sometimes up to a few minutes like
if they bleach report person plugs in
the report bang it took a few minutes
for you to receive that push
notification i'll tell you what it was
afterwards so they had a hundred fifty
eight of us in instances supporting this
application even at this point their
servers were jammed up with requests so
there are many times in which they were
steaming too many requests and they can
get responses out they and this is you
know of course the big problem there
engineering teams were fairly large and
support each of their apps each their
own individual apps our main app with
the eight-year-old little dab and so
there's a lot of personnel overhead for
each application and they had multiple
complex caching strategies the tacking
is you know not putting on easy problem
to solve and getting something in place
that is that works well can be expensive
at times so afterwards this is after
they moved over to election or phoenix
they had one fifth than a number of AWS
instances for one of their applications
they went from twenty servers down to
two and the only reason they had two is
because the second one was there for
redundancy now they're averaging about
ten to thirty millisecond response times
the larger largest average spike is
about 400 milliseconds and they have one
outlier spike of 800 milliseconds these
numbers are good ads of six months ago
so I don't know if they've changed much
but which reports been pretty
vocal in their elixir in Phoenix case
studies so imagine that are still pre
similar on some of that they have the
one engineer per application now and we
have time we'll get to why why this is
important and how this is possible and
they're also doing no caching so other
examples I promised you the the push
notification thing so which report went
from like three minutes to get in to
push notifications down to within like
three seconds so all of their
subscribers get a push notification
almost immediately when when the
reporter actually publishes the article
so the business value back which report
for this is that if you're competing
with other applications on phone to be
the first one to publish an article
you're you're to get the push
notification you're computing all these
other applications get people to push in
your push notification and to bring you
back to butchered part so you can start
getting eyeballs on ads so it's very
important to be the first one there so
look sir you know brought in you know
significant business value for them
almost immediately other examples and
these are more Erlang examples but kind
of demonstrates the scalability what DAP
is a classic example within our link for
those that may be unfamiliar with
whatsapp it is a it's a messaging system
right so it has you know phone text but
it's all over all over the internet
they're famous because Facebook bought
them I think was Facebook but they were
but for a lot of money so they bought
for like seventeen billion dollars or
some like that and they had an
engineering team of less than twenty
people so they were able to develop
build up playing that scaled to billions
of connections per minute with a very
small team relatively and because
they're able to build them that scaled
that high you know the amount of return
they got on that when they got bought
out with significant age a bird is a
pretty good example but open source
their online application is one check
one out Riot Games uses are lying
eternally for their for their messaging
system as well League of Legends that's
good right here next
okay junkies all right
work you had no idea how long it took me
to get there right okay
so this is a simple gem server you know
what we're just going to do is create a
stack so you really point on my pointer
but would I think this is actually a
real kind of first comprehensive lecture
could I've showed you but the idea here
is that we have a module module simply
just a namespace so we don't have
classes we don't have objects for the
whole lecture it's not object oriented
language it's a functional programming
language but the the namespace allows us
to organize our functions in such a way
so we don't have this you know one
monolithic neo space so we have to avoid
name collisions function names main
event huge gen server allows us to bring
in some functionality of the gen server
module so now we get some code injected
into our module automatically and start
link allows us to create the new process
so in this case our start link function
is calling a gen server start link
function the underscore in scream module
just away to reference you go to college
otago stack module state is going to be
the starting state of the gen server so
in this case we're going to pass it an
empty list this is going to be our
starting state and then options we'll
ignore for now so there's two functions
here handle called halo cap handle call
allows us to what you call a gem server
it's a blocking request and when you
cast a gem server it's basically just a
fire-and-forget to quest so the handle
call we're using some pattern matching
here and we're going to say that on a
pop request you can ignore the second
argument from for now just know that
anything that starts with underscore is
a argument that gets ignored by the
compiler if you have an argument that is
not underscoring don't use it you get a
warning saying that even unused argument
and then just intact and there is a way
for us to reference the parts of a list
so you have a head and tail and head is
going to be a first element and tail as
the remainder of the list so in this
case if we passed we had one two three
a tree would be one and then tea would
be two and three it should be a single
value the tea would be a list it'll cast
so we're pushing into the list at this
point and we want to we give it the the
you know the the request we're pushing
and then we give it a value W want to
push onto it and then T is the state and
so down bottom we have a reply no reply
rather and we're basically pretending
the head on to the on to the stack so
the way we end up using it is that we
can call start link we pass at that
initial state with an empty list and we
get back this this reply says okay and
this is kind of semantics with in Erlang
for things that are going well to say
okay you know some of the things that
don't go well we may get an error but
the second argument within the tuple is
a second element rather is the pit so
similar to an operation pin this is
going to be our reference back to this
given process so in this case we're
going to tack to the gem server so cast
again is a fire-and-forget so we pass to
the pig because we need that unique
identifier back to our gem server
process and we're going to do the push
we're going to push in a hello onto the
stack and then finally we we make a
block request because we're waiting for
response from the server and we do call
a passing pig because we need to
reference the gem server and call pop
that is gen server in a bit in a
nutshell it's a very simple system that
allows you you know kind of abstract
from more complex system within elixir
each process has its own mailbox and you
can do message even reference other
processes in past messages and these
messages can get processed will do get
processed signaling so you can build out
something like gen server on your own
but gen server gives you this really
nice kind of abstract layer for dealing
with message passing you guys think a
bit like a web server right so you have
your web server educated you give it a
request and it gives your response
so supervisors and
the tree or the supervisor it's resigned
the tree there so let's look back at our
gem server for a minute so let's say we
started it up again and we did the push
into it okay that's great but what if we
gave it a request with request something
that we didn't previously find what
we're going to end up getting is this
error back and the most important thing
is the last word on the first sentence
is terminating so when an error occurs
within our process the process just dies
out and this brings us into one of the
more important aspects and ideas within
Erlang which is called let it die and as
those thing or you may you know go
through a lot of trouble trying to
figure out like here where's different
ways in which my plot my application can
error out and I should try to capture
those errors and handle them gracefully
but in Erlang they realize that there's
you know almost infinite permutations in
which this can happen so the only state
you can bring your application back to
what you just guaranteed to have a good
state is when you initially started it
so why not just let it die and then just
restart it so you're back at that clean
state again so even like right here we
can see that with the or the process
even if I try to call it the pit is
undefined now the process is gone it's
no longer available so the supervisors
this is a looks like a child's drawing
but this was made by an adult Hey the
website learned you some Erlang calm
it's kind of like a you know funny let's
say for learning our line but the idea
here is that you have all the green our
supervisors and all the Blues are purple
and colorblind can tell the difference
but our workers so the idea you have a
supervisor that's either watching other
supervisors or watching workers and that
supervisor watches other supervisors and
workers so you have this infinite depth
treat potentially at the tree and so if
a worker dies then the supervisors are
watching it is notified and the
supervisor can decide what it wants to
do with that worker does it want to
reboot that worker does it just want to
keep it dead or should it
go back up the tree further if your
Riesling a worker there different
strategies in which you can reboot the
worker do we just reboot that one worker
do we look at all the worker siblings
and kill those off and then reboot
everything at what to put everything
within you know the siblings processes
back into a clean State so these are all
different options you have for working
with supervisors and elixir I work so
hard I had to put it in toys okay so the
defined supervisor looks a little bit
similar to the gem server so then you
supervisor we have the start link on
this the difference here is this init
function gets called after the
supervisor starts after the start link
so supervisor sorry a certain link gets
called passes in this state that was the
last argument on that and then I'm
creating this list called children which
is just the supervisors child processors
that's monitoring you get this worker
function from the supervisor module
above and I am passing as the first
argument our stack that previously
defined and then it looks a little bit
another you really saw what's going on
there but there's the list with two
arguments in it the first argument is
going to be the state that we rest start
our our gym server with the second
argument is off the options that we had
just a default and you list for
previously the reason for that is
because the worker starting within the
context of the supervisor now we don't
get access to pin and so we have to give
it some sort of unique name that we can
identify it on so that we can reference
it so in this case we're passing at the
name option and we're just calling it my
stack and then we call supervise can we
give it the children list and the
strategy here is one-to-one you can look
up there's a whole little good
documentation on lecture on what all the
strategies mean okay so if we were to
start our supervisor now again it looks
similar to when we started our gem
server we get back to pit we don't
really need it you can if you're using
it within another system you can hold on
to it but for the purposes of this we're
not using again anyway so now we're
calling the gem server for calling cast
so again we're making that
a fire if we get requests to the gym
server to push in the flow value onto
the stack but instead of referencing the
pit we're going to reference the unique
identifier for which was my stack so you
get back okay
and now we're going to call Pater and
called pop we get that close it's great
now we're going to call that same
function that came one before that
caused it to die and oh it died but the
supervisor we starts it oh I think I
actually had that on your twist and that
you have the death on the other screen
sorry oh now I have to go through all my
steps again okay so this is this is when
we kill it right here and but this time
instead that should be sorry that's the
syntax are that just a kid that should
say my stack that also should say my
study that's a complication error so
just over cast my stack what we find is
that the supervisor saw that the worker
died and then automatically started
whereas previously if you recall back in
the previous slides that when I tried to
cat when I tried to push a new item onto
the stack to the gem server is no longer
able to do so because there's no longer
available the process had died out the
difference here though is one thing to
be aware of is that it will reboot
itself with its previous state I'm sorry
with the state in which the supervisor
is to find us there are strategies for
getting around that and there's the
concept of an agent within elixir
basically when you instantiate your gem
server you can have it but you can push
all that all those values into an agent
which live outside the gem server and
then when the Jets ever dies you can be
populate it with your populated state
from the from the agent okay so this
last part is more opinion based and more
subjective than objective but it's one
thing that I've experienced doesn't let
you develop over the past four years and
something that I've thought a lot about
and what type of impact this means to
engineering teams and the question I
pose is you know panel language make you
happy when I first got into Ruby one of
the
kind of core tenants of ruby was that
ruby makes you happy there's a language
that was written to kind of do away with
this idea that the end here had to be
the slave to the to the computer and you
know the computer should be doing the
work for us
so we have this nice you know beautiful
looking language but it you know as we
indicated has its on locations so with
literature I found that it actually took
that argument a bit a lot further or a
bit farther and the reason for that is
you know some of the stuff that object
oriented programming brings in olp and
here's the kind of classical hopi
structure and you know this idea that oh
it's just objects and we have
inheritance and we have objects can
inherit from other objects it's so clean
it makes so much sense but you know yeah
how many people seen this in a book and
then a year or two from now this is what
they really got yeah have something like
this it's absolutely nightmare it
happens to everybody and that's because
you know P gives you a lot of rope and
this is true of any language and it's
kind of like my argument against
javascript in general is that it gives
you too much flexibility and limitations
are actually better there's power in
limiting yourself and what what you can
do you know one of the kind of I don't
know if they're going to see that but
the basic idea here is that you know as
you know programmers you know we we sit
there and we you know we have at least
an hour to ourselves we can build up
this amazing state in our head on
exactly what's going on and then you
know once we get interrupted it's gone
right and so that he that ends up being
the big problem of object-oriented
program is state so you have these
objects that are carrying state around
they're not immediately accessible but
buried in the memory somewhere whereas
functional programming is right there in
your face the idea of data and data out
you do not have in a classical pure
functional programming language
you should not be able to access
anything outside of the different
function that you're currently in now
lit sir on our line does violate this a
bit through its process message passing
so it's not 100% pure but within its own
process it's completely pure I think I
had someone correct me before on the
message passing thing so something wants
to correct me on they completely pure in
the process I'd appreciate it
but you know list of being a functional
programming language this has a huge
advantage not over just your ability to
learn it quickly if you know we took
existing rails engineers and we gave
them give them the programming elixir
book like the Atomics which is published
by pragmatic programmers if you're
interested in lecture I highly suggest
that you read it the first part of it
was about two hundred pages and
introduced convey ideas of functional
programming the syntax within a week
this is no joke within a week they were
making contributions back to a Phoenix
application that's not to say that they
were expert literature engineers within
a week not to say that they would learn
all the nuances of distribute
programming on the week but just that
you know the idea of funcle' programming
it ends up being very very simple and
very very easy to to learn the reason
why in part like functional programming
perhaps taking a while to catch on now
like you're seeing a lot of articles on
functional programming due in part to
memory limitations right so you're not
passing in values by reference within
functional programming you're passing it
about passing everything by value and so
that ends up being memory copy the
memory allocation nowadays memory is
fairly cheap and so this is less of a
concern but back when you had 16
megabytes of RAM yeah that was you know
that was concerning that was difficult
so you know you could see the value of
an object-oriented language that was
mutating memory on the fly back then but
today the value is is really not there
for that really starting for that is not
there all right anyway I will stop
roaming because I think I'm getting
close to time I will just say go learn
use some elixir it's an awesome language
and just to
put myself again again CEO of doctoral
based in Boston we use Phoenix framework
consulting elixir and also energy as
consulting and you can find us at dr.
calm so thank you very much does the lik
sir support protocol only it programming
in the class structure so there are no
classes in elixir
there's modules it's just mainstays but
what do you mean by perfect all work
already programming a turbo when you
have you attempt to write a class
structure and you have to extend it and
based upon pattern matching so there is
an idea of an it's not really so much
inheritance within elixir it's more like
our class extensions you have modules
and you can actually have those modules
to find compiled time functions that
will emit Erlang ASP and so when you
look we do use gen server there's a
compile time function within the gen
server module that will emit the the ASP
code that gets injected into the module
that you're using it in so it's just yes
there is a way to reuse code it's but
it's not through a it's not through a
more like classical like class extension
style but it's it's done in such a way
that it pushes all the work to build
time okay thanks everyone and don't
forget to write in the app have a great
day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>