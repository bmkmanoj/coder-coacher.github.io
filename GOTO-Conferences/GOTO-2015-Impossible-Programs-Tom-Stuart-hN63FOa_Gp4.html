<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Impossible Programs • Tom Stuart | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Impossible Programs • Tom Stuart - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Impossible Programs • Tom Stuart</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hN63FOa_Gp4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thanks very much for coming
to this session right at the end of the
day my name is Tom I live in London I'm
a computer scientist and a programmer a
lot of the talks today have been very
practical and hands-on and this talk is
going to be a little bit more abstract
and a little bit more computer science
II think that computer science is is
fascinating for its own sake really I
mean aside from whatever the practical
applications of computer science might
be I think it's super worthwhile to
understand something about what's going
on inside the computer like what is this
magic box that we're working with every
day and what are these spells that we're
casting on it and sometimes thinking
about that stuff helps me to when I'm
having a bad day at work and you know my
tests are failing or you know the asset
pipeline isn't working or ever it is I
can kind of I can flow off into this
slightly more abstract separate world of
thinking about computer science and it
just kind of helps to keep my mind
engaged and keep my work fun even when
everything is going wrong like that so
on that note I want to talk today a
little bit about developing an intuition
about what it's possible to do with
computers what we can do with computers
and and more particularly what we can't
do what it's impossible to do just like
if you're an engineer it's important to
learn about the laws of thermodynamics
so that you don't spend your whole
career trying to build a perpetual
motion machine if you're a computer
program I think is important to know the
limitations of what computers can do so
that you don't spend your whole life
trying to get them to do things that
they just can't a friend of mine
recently explained to me what it is that
he thinks is so good about James Bond
movies and he said the best thing about
Bond movies is that in the first three
minutes before the opening credits
there's like a mini Bond movie and so
there's like the cold open and then you
get to see James Bond and he's kind of
infiltrating an enemy facility and he
shoots a bad guy and
steals a microfilm and kisses someone
and then he skis down a mountain and
then there's the opening credits and if
you really like Bond movies then that
little three-minute mini Bond film gets
you really excited to watch the whole
like rest of the film that's about to
happen and if you don't like Bond movies
then in those first three minutes you
basically just like get the idea you get
all of the good stuff in a Bond movie
really quickly and then you can just
kind of zone out for the whole rest of
the movie and not really pay attention
and then at the end when the person you
went weird asks you like if you enjoyed
it you can say yeah it's great I really
like that bit where he skied down the
mountain so I'm gonna try and make this
talk a little bit like that I'm gonna
have a little pre credit sequence to
just give you the whole message of the
talk in one slide and then you can just
zone out if you're if you're not
interested after that so this is my kind
of mini mini talk right before the
opening credits so if you're only paying
attention to one slide please pay
attention to this one it's tempting to
think that we can solve anything with
technology and with computers just by
applying enough effort and enough
ingenuity but that is not the case there
are some tasks that programs can't
perform and some of those tasks that
programs can't perform a very esoteric
and they're not things that you would
directly care about but there are other
things that programs can't do as a
consequence of the esoteric things and
those other things are very practical
and relevant to the stuff that you and I
do in our everyday work so that's it
really programs can't do everything
there is such a thing as an impossible
program and then if this was the Bond
move it'd be like the title sequence now
that's sort of the end of the talk so if
that's all you're interested in then now
you can just zone out and look at yeah
thank you you can just retweet rape me
you know high rating it's very concise
talk straight to the point if you are
interested and you want to know more in
a bit more detail then keep listening
and I'm gonna unpacked that simple idea
a little bit and show you some examples
of exactly what I'm talking about
so to start showing you what I mean
here I'd like to walk you through how a
program can be impossible and I'm gonna
explain that by reminding you of two
facts of life two things about the world
that we live in that you just can't
change the first fact of life is that we
collectively demand universal systems
now what do I mean by a universal system
well I'll try and explain that by
comparing two programming languages so
for this example I'm gonna compare say
Python and Ruby and by the way I
personally like Ruby and that's what I
use and in this talk I'll be using it as
a kind of executable pseudo code to
explain the ideas but the specific
programming language doesn't matter and
you have my permission to like mentally
translate the code on my slides into
JavaScript or Java or C sharp or
whatever else you're most comfortable
with so it should hopefully be obvious
to you that we can take any program
written in say Python and translate it
into Ruby that's actually pretty
straightforward we can go through a
Python program kind of one expression or
statement at a time and replace each
little piece of Python syntax with the
equivalent piece of Ruby syntax and when
we're done with that we have the
original program converted from Python
into Ruby and we can go in the other
direction as well we can take a ruby
program replace every piece of it with a
piece of Python and then we end up with
an equivalent Python program so in some
sense
Python and Ruby are sort of exactly as
powerful as each other right you can
just take a program written in one of
them and just mechanically translate it
into the other one and you end up with a
program written in a different language
that does exactly the same thing so
anything Ruby can do Python can do and
vice versa and that's cool but there's
something a little bit more powerful as
well which is that it's possible to
write instead of just translating
individual Python programs into Ruby we
can write one special ruby program that
can do what any Python program can do
and what I mean by that is so that we
could write a Python interpreter in
so that means that if you've got a
Python program and you want to run it on
my you know my Ruby virtual machine or
whatever then I don't need to translate
it individually into a ruby ruby program
I've already written a ruby program that
will do what that Python program does
you provide it as input to my Ruby
implementation of a Python interpreter
and then my ruby program that I wrote is
going to do whatever that Python program
says to do and again we can do it the
other way around as well so in both of
those cases we're able to write just
this one magical program that is sort of
sufficiently general-purpose that you
can feed it a program written in another
language and it will just do what that
program says to do and again there's
nothing special about the pairing of
Ruby and Python here I mean those two
languages are quite similar but you
could just as well you know write a
Python interpreter in JavaScript or you
could write a Java Script interpreter in
Python right so all of these languages
have got some kind of relationship with
each other which is that you can
implement interpreters for each other
for one of them in any one of the other
ones and actually there's a whole
constellation of systems that have this
property that if you pick any one of
these systems you can implement another
system in it so I could implement a
JavaScript interpreter in Haskell or I
could implement a Ruby interpreter in
the land of calculus I don't recommend
you try and do that but you know the all
of these systems are sort of
implementable in each other and this is
that sort of this is what I meant by
universal systems the property of these
systems is usually called universality
or also concurring completeness so
there's a large number of these systems
and they all share this property of
universality and that's something that
we want because Universal systems are
able to run software that's kind of
their defining characteristic and in
general we don't want this situation
where we have to make individual
programs to do individual jobs or
individual machines to do individual
jobs we want general purpose machines
and programs we don't want to every time
we want to do something different go to
the shop and buy a different box that
does
we want to be able to buy a box that can
do anything depending on what input we
feed to it and that's really what's
captured by this idea of universal
systems right we can feed them programs
and they can do arbitrary things the
second fact of life is that these
programs that I was talking about these
inputs that we can put into Universal
systems to get them to do anything
these programs are themselves data now
that will be a fairly obvious statement
to anyone who's a computer program and
maybe I don't really need to unpack it
but I'm going to unpack it a little bit
in order to make my point and again I'll
be using Ruby as my example language
here but any other language will do
there's nothing special about Ruby so
here's a very simple ruby program this
is me at the Ruby a read eval print loop
just kind of typing in a program I type
puts HelloWorld and it runs and it
prints out hello world and that is a
program but another way of thinking
about that program is as some data I
mean what I've done is type in a series
of characters and so actually I can type
take that series of characters that I
typed in and I can put that just in a
string and so now I've written a
different program that sort of got my
original program inside it as data and I
don't want to over egg this I mean it's
quite an obvious thing that a program is
just a series of characters but the fact
that you can take one program and put it
inside another one as a piece of data
might be obvious to us but its
implications are quite profound it turns
out if you look at this you can see that
the hello world program is really just a
sequence of characters a sequence of
bytes really and inside my programming
language I can investigate that a little
bit I could literally unpack that
HelloWorld program into a series of
bytes that make up all of the characters
in that program and as you look at that
sequence of bytes it starts to resemble
just one very large binary number which
is what it is really when a programs
written on to the disk it really is just
a long sequence of ones and zeros and
here you
see all of those ones and zeros and
actually if I concatenate all of those
strings together and convert them into a
decimal number then you can see the
decimal number that represents this
program and this isn't a reduction of
the original program it is that original
hello world program just showing it to
you in a slightly different way so in
some sense hello world is Ruby program
number nine seven nine six and so on now
if I gave you that number then I've
given you the original program it's got
all the same information as the program
I started out with I could give you that
big long number and then you could
unpack that number into its component
bytes and then you could turn each of
those bytes into a character and turn
them into a string and then you could
you know evaluate that string and you've
run the original program that I started
out with now some of you might have used
these sort of so-called homo iconic
languages like some of the Lisp
languages that have these sort of fancy
features that allow you to represent the
syntax of programs in the language as
kind of first-class data structures
inside the language and they have
first-class operations in the language
that allow you to manipulate them and
that's a really cool feature but to a
greater or lesser extent every
programming language has this feature
every program is ultimately just some
data a big number and every programming
language is able to manipulate those
things so the homo iconic languages are
just the ones that make this
manipulation of programs particularly
easy with sort of native features that
support doing that but in any language
you can manipulate programs because
they're just numbers and incidentally
the fact that programs are just numbers
means that you can in principle
enumerate them like this is Ruby program
number nine seven nine and so on but you
could start out by just generating you
know Ruby program number one and then
generate Ruby program number two and
then generate Ruby program number three
if you kept going like that you know
you'd eventually generate the next hot
asynchronous web development framework
and you'd be able to buy your own Island
it would be brilliant
so those two facts of life are firstly
we demand these sort of programmable
general-purpose Universal systems
they're really useful and the other fact
of life is the the programs that we feed
into these things are just data like any
other data and those two facts of life
are kind in aspect in inescapable
consequence which is infinite loops and
I'm not sure that it's obvious how the
existence of infinite loops necessarily
follows from those two premises so I'm
going to show you how it follows
so just to recap why I just said every
universal system can simulate every
other universal system so Python can
simulate Ruby and vice versa and the
fact that there's this sort of
equivalence class of universal systems
that can all simulate each other means
that each of those systems can actually
simulate itself that's just a special
case of any universal system can
simulate any other one and more
specifically every universal programming
language can implement its own
interpreter that's essentially what
universality means so if all we know
about Ruby is that it's one of these
Universal systems who we didn't know
anything about its syntax or its
semantics we were just told that it was
Universal that it was sure and complete
then that means it must be possible to
write some method or function or
whatever you want to call it in Ruby the
implements and evaluator for Ruby
programs so here I'm imagining that this
evaluator gets two arguments against the
source code of a program and then it
gets some input that that program is
going to read on standard inputs a and I
don't have time to show you the full
implementation of what this evaluate
method would entail but briefly it would
parse the program so it would take that
big string and it would break it down
into its component pieces and figure out
what the structure of the program was
and generate some kind of intermediate
data structure probably an abstract
syntax tree and then it would evaluate
that program and sort of buffer up the
output of that program and it would
evaluate it probably by walking over
that abstract syntax tree and every time
it finds a node that represents some
particular operation or instruction it
would actually do that
operation or instruction it would keep
walking over the tree and then going
round in loops and doing stuff until it
was done and then it would just return
the output that had been sort of
buffered up as it was executing all of
those instructions right now this is
actually quite easy to implement in a
dynamic language like Ruby because Ruby
has got an eval method that lets you
just evaluate a string and you know you
can use the platform that you're sitting
on to do the the parsing and the
evaluation of a ruby program but even if
Ruby didn't have that eval function you
could still do this yourself right even
you know the Ruby is itself running on a
computer program written probably in C
and you could just take all of the logic
from that computer program and re
implement it in the host language so for
languages that don't have eval built
into them you could always go to the
effort to implement that yourself so
once we have this evaluate method we can
use it to essentially ask questions
about programs and the question we're
asking is like what would the result of
this program be so I can say what would
the result of this program which reads a
string from standard input and reverses
it and prints it out B if I fed it the
string hello world and evaluate is going
to answer that and say the result would
be hello world backwards now if we were
able to write this evaluate method which
presumably we can because this is what
it means for a language to be universal
then we can write another method called
evaluate on itself and this isn't
anything special this is just instead of
being a two argument function like
evaluate is it just takes one argument
and it calls evaluate with that argument
twice so this means what this is asking
the question what do I get if I run this
program with its own source code as
input because programs are just data
writers you can always do that so I can
ask the question what do I get as output
if I evaluate this program with itself
as input and what I get back is well in
this case the source code of that
program reversed because what this
program does is reverse its input and if
I'm able to write this then I can write
this larger program which
reads a string in a program in from
standard input and then it evaluates on
itself and looks at what its output is
and if the output of that program is the
literal string no then this program
prints yes otherwise it prints no so you
have to focus a little bit here to keep
track of what's going on but I'm gonna
call this program does it say no dot RB
and this is really asking the question
of when I run when I run some program
with itself as input does it output no
or not so for example I can say I can I
can echo into it this program and say
when I run this program on its own
source code does it say no and in this
case the answer is no it doesn't say no
it just says its own source code
reversed we just saw that whereas if I
give it this program that prints know if
it's standard input includes the literal
string though if I feed those own source
code as input then it will see that its
own source code contains the string no
and it will print no so the answer to
does it say no is yes so nothing I've
shown you so far is particularly dodgy
but the DA genus arises when we ask what
happens if we feed this program into
itself it's not actually very obvious
what happens if you feed this program
into itself so let's let's walk through
it so I've got my does it say no dot RB
and then I feed a copy of it into itself
and then there are some possible
outcomes that could happen I mean the
two obvious ones are that it could say
yes or it could say no now if outputs
yes then that means that the answer to
the question of does this program say no
when you feed it its own source code as
input is no it doesn't say no it says
yes so the answer yes is incorrect here
the answer we were looking for was no
but it said yes that's not right so if
that output comes out then that means
our program isn't doing what it's
supposed to do but exactly the same
logic applies the other way round if
when we feed this program to itself the
output is no than the answer to does it
say no is yes it should have said yes it
should
No so that's wrong as well so assuming
that our program is correct which
judging from what we saw on the previous
slide it seemed to all be correct
neither of those outputs is acceptable
because either one of them is giving the
wrong answer so what else could happen
well there could be some other output
like it could output the string maybe
but just by looking at the source code
of the program we can see that that's
not possible there are only two things
that it could possibly output and maybe
isn't one of them so that's not right
either so the only other option here is
that this program never finishes it
never gives you an answer either a
correct or an incorrect answer because
it just runs forever with no output ever
coming out of it and in reality that is
what actually happens although what
actually actually happens is that it
will keep allocating more and more stack
space until your computer runs out
memory and then everything crashes and
it stops right but that's not the
program's fault that's the computers
fall and in principle we could keep
adding more and more RAM to the computer
and this program will keep running and
running and it would be able to exhaust
as much as many resources as much ram
and time as we were able to provide to
it could exhaust them and still bust
through the amount we'd allocated to and
that's really what it means for a
program to run forever that it can
exhaust all of the resources that you
provide to it so the argument I've just
shown you goes like this ruby is a
universal language so we must be able to
write this method or function called
evaluate in it but if we can write that
evaluate method then we can construct a
special program that has to loop forever
that does it say no dot RB is built so
that when you feed it into itself it can
just keep looping there's no other thing
that it can do that would be correct and
this argument doesn't depend on any
knowledge of Ruby or Python or
JavaScript or whatever language you're
thinking of you don't need to know the
syntax or the semantics of the language
because obviously if you know the syntax
of say Ruby you can say well I could
have demonstrated this much more
straightforwardly by just saying you
know
while true do end or whatever that's an
infinite loop but you can only write
that if you know what the features of
the language are whereas I mean I Ellis
trated it with a concrete program but
the underlying argument here is that if
you have this self interpreter this
evaluate function there's always a way
of building this special program that
loops forever so that directly gives us
or gives us a way to to come up with an
impossible program and I'll show that to
you now so these infinite loops that I'm
talking about that are an inevitable
consequence of universal programming
languages are bad like infinite loops in
the in the normal code that we write day
to day usually indicate that we've made
some kind of mistake I mean that's not
the case if you're writing a
long-running system like a like a web
server whose whole job is to sit there
in an infinite loop serving individual
requests but the code that we write
day-to-day tends to not be those kind of
long-running systems so much as if they
we tend to write small algorithmic
pieces inside those systems like an HTTP
request Handler and you don't want your
actual request handler to go off into an
infinite loop because that means that
the client is never going to be served
so if we don't want these infinite loops
to happen when we don't intend them then
we could try removing features from a
programming language until there's no
way to cause an infinite loop in that
language and this is totally doable this
is just an engineering problem there's
nothing to stop us doing this so you
could take your favorite language and
just start crossing out features from it
until you've eliminated the possibility
of having infinite loops and just very
briefly that you know you could do that
by doing things like removing unlimited
iterations so you could allow you know
you remove things like while loops that
just have a sort of dynamic condition
that you're hoping will eventually
become full so you can say we're going
to allow finite iteration over of you
know bounded data structures and things
like that or between you know ends of a
bounded range but we're not going to let
you just sit in a loop arbitrarily long
because you might never stop you would
have to remove the ability to make
whatever your programming language cause
lambdas or closures
or functions or whatever those are to
prevent things like this is the Omega
Combinator in the lambda calculus so
however you would implement this in your
programming language that's a that's a
lambda calculus term that when you
evaluate it it just runs forever and
ever in ever stop so we have to rule
that out
and that's actually a special case of a
more general thing which is that we
don't want to allow recursive function
calls and one way of preventing that a
simple-minded way of preventing it might
be to only allow a function to call
another function whose name comes later
in the alphabet so if you have a
function called a it can call a function
called B and then that can call the
function called C but then eventually
you run out of functions so the maximum
stack stack depth of your program is
bounded by the number of functions in
your original program and that's gonna
mean that you also want to outlaw you
know metaprogramming and dynamic
function definition and stuff like that
but that's fine we can take all of those
features out we don't know allow
blocking i/o because we don't want to be
waiting for a bite on a network socket
that never arrives and so on there are a
million other things that we need to
take out but you can definitely do this
so we took all this stuff out of your
favorite programming language we would
end up with something called a total
programming language so this is a
language where every program is
guaranteed to finish executing because
you've taken out all of the language
features that allow it to sit in an
infinite loop forever now if you've got
a total programming language like that
let's call that language T then it must
be impossible to write an interpreter
for T in the language T now why is that
well I've showed you why it is because
if we could write an interpreter for T
in itself then we could use that sort of
self interpreter to construct a special
program that loops forever but this
total language that we've built doesn't
allow you to write programs that can
loop forever so it must be impossible to
write this self interpreter in this new
language that we've come up with and
that's actually really counterintuitive
because an interpreter for a total
language is a program that is guaranteed
to finish
you know evaluating a program in a total
language is something that always stops
eventually so that feels exactly like
the kind of thing we should be able to
write in one of these total programming
languages but we can't so although a
total programming language can express
some programs that always finish it
can't express all programs that always
finish and I've shown you at least one
that it can't Express which is its own
interpreter now that's not to say that
we can't write an interpreter for that
total language in some other in some
other language we could we could write
it in a universal language like Ruby or
Python or JavaScript that would be fine
we can also write it in some other total
language because then you've got you
know if we had some other language
called you then we could write an
interpreter for T in you and even if you
use a total language there's no reason
why we couldn't write the interpreter in
it because it's a program that's
guaranteed to finish but we just can't
write that language that program in the
language itself so all of that stuff is
to be charitable kind of mildly
interesting but the question that
amazingly presents itself is like how
does this connect to reality because
that total programming language that's
had loads and loads of juicy features
taken out of there doesn't really sound
very much like the kind of programming
languages that we actually use so that
evaluate function the sort of self
interpretive program is impossible for
any total language so there is no total
language that's universal these are sort
of disjoint classes of programming
languages but just like total
programming languages have this
interpreter program that's impossible
for for them Universal systems universal
Turing complete programming languages
also have impossible programs it's just
that they're a little bit more difficult
to see than that that interpreter so
let's have a look at some examples of
some programs in universal programming
language here's a simple program in Ruby
this just reads in a string from
standard input and then it prints that
string
now just by looking at this it should be
obvious that this program always
finishes I've got a little asterisk
there and it says assuming that standard
input is finite and non-blocking so I'm
not really interested in the program's
interactions with the rest of the system
here I'm just interested in the behavior
of the program itself so assuming that
it's always going to be able to read
that string from standard input then
this program always finishes let's look
at another example program this one
reads a string in from standard input
and then it tries to print it out but
before it prints it out it does this
while true do nothing and just by
looking at that it should be obvious
that that program always loops forever
right it's just gonna hit that loop in
the middle and then just sit there
indefinitely so these are specific
examples of programs in in this case
Ruby and just by looking at them we can
tell whether this program is ever gonna
finish or not just you know just by
looking at them but the question is can
we write a program that can decide this
in general for it for any program so
that means given the source of a program
and its input can we decide whether that
program is going to loop forever or not
and that question is called the halting
problem the question of you know does a
program ever finish so let's look at
some examples to see if we can develop
an intuition about how difficult this
problem is like is this a super easy
thing I mean it seems simple for the two
examples we just saw is it quite hard
like we're on the spectrum of difficulty
does this problem sit so here's another
example does this program always finish
well this reads in a string from
standard input and then it initializes a
variable end to the length of that
string and then it sits in a loop
concatenating asterisks on to some
output string and decrementing the
counter and then when n dot zero returns
true it's going to print out the output
so this is a program that essentially
takes a string and just replaces all of
its characters with asterisks so just by
looking at that for a minute you should
be able to convince yourself that that
program always finishes but the reason
why always finishes is quite subtle like
it the reason
this always finishes is the when you
call read on standard input you always
get a string object back and when you
call length on a string object you
always get a non-negative integer back
and then when you call -1 on a
non-negative integer you always get
another non-negative integer back and if
you do that enough times you will
eventually get a special non-negative
integer which when you call the zero
method on it is going to return true
so that loop will always terminate and
then you can print it out so being able
to answer yes in this case involves
quite detailed knowledge of the
semantics of all of these methods in
rubies so it's not as simple as just
glancing at the program you need to
understand what all of these things mean
and how they all interrelated about why
this program always finishes involves
lots of knowledge so it's clearly not a
trivial problem because it up it
involves understanding all of these
specific features of the programming
language let's look at another example
so without focusing on the detail here
this is a program that initializes a
variable called n to the number 4 and
then it sits inside a loop where it
checks to see whether n is the sum of
two prime numbers or not and if n is the
sum of two prime numbers it increments
it by 2 and then keeps going so this
program is going to check whether
successively larger even numbers are the
sum of two primes or not so it's going
to check you know 4 is 2 plus 2 and then
6 is 3 plus 3 and then 8 is 5 plus 3 and
10 is 5 plus 5 and 12 is 7 plus 5 and so
on it's going to keep going until it
finds an even number that isn't the sum
of two prime numbers and then it's gonna
stop and print that even number out and
so the question is does this program
ever finish and the answer is we don't
know so this program is checking the
gold back conjecture which is one of the
sort of oldest and most famous unsolved
problems in number theory this was first
conjectured in the year 1740 to that
that all of the even numbers are the sum
of two primes now this has been checked
empirically on a computer for all the
even numbers between four and four
quinta
and they all are the sum of two prime
numbers so it looks empirically quite
likely that this is true but we don't
have a proof of it and that means that
it's possible that if you left this
program running for long enough it would
eventually find an even number that
wasn't the sum of two primes and print
it out so mathematicians have been
trying to decide this question one way
or the other for over 250 years if you
could write a program that could read
this in and tell me whether it was going
to finish or not then I'd be quite
impressed so and that's not to say that
you can't do it it just because it's
difficult doesn't mean it can't be done
but now we're venturing into the
territory of being really quite
astronomically difficult you would have
to write a program that contained all of
modern mathematical theorems and
knowledge and it would also have to have
the ability to synthesize new
mathematical theorems and knowledge from
those existing theorems and keep
generating more and more theorems until
it found a proof of one way or the other
of this and that is really getting into
the territory of being very very
difficult to do and you know you're
gonna win you're gonna win the Nobel
Prize if you manage to figure out so
this is now starting to look like a very
hard problem indeed but maybe it can be
done let's assume that it can be done
then that means that you can write a
program like this or a method like this
and again this is just the outline of it
but roughly what this is gonna do is
it's like evaluate but this one is just
gonna instead of returning a string it's
just just going to return true or false
and tell you whether a particular
program that you passed into it is going
to finish or not if it was run on some
input and in particular we can't just
run the program because this horts
method has to return true or false it
can't sit there forever part of the
specification of this of this thing is
that it always gives you an answer so
this is going to do something a little
bit like evaluating it's going to pause
the program into an abstract syntax tree
but then rather than running on the
program it's just going to do it's just
going to do some analysis on the program
and figure out whether it will
eventually finish or not and then it's
just going to return true or false to
tell you and again this is you know
quite reasonable you can say you know
does this program eventually finish this
print
standing in don't read and then you just
come back and say yeah sure it does or
you could say does this program
eventually finish while true do end and
it can come back and say no it won't and
you could easily write an implementation
of this horse method that gets these two
cases right I mean you can write an
implementation that answers correctly
for any finite set of programs because
you can just build them into the source
code of of horse and look them up you
know in a hash table or whatever
assuming you know what the answer is but
if we could do this in general then we
be able to take this horse method and
we're going to do essentially the same
trick as we did with that does it say no
program we could write a new method
called halts on itself which tells you
if a program ever finishes or not when
it's given its own source code as input
and then we can write this longer
program which reads in a program from
standard input it finds it uses this
halts method to check whether this
program ever finishes when you run it on
its own source code and then it just
does the opposite so if halts on itself
returns true and says yes this program
does eventually finish then this one is
going to loop forever and if it returns
false and says no that program never
halts then this one is going to fall
through an adventure and immediately
halt so I'm going to call this program
do the opposite Darby and as before the
important question is what does this
program do when we run it on its own
source code now before we looked at a
program that produced output but this
program doesn't produce any output it's
just going to have one of two behaviors
if we take its own source code and feed
it into itself there are only two things
that can happen it can either eventually
finish or it can loop forever but this
is we're in the same situation as we
were with does it say no Darby
if this program eventually finishes then
that means that the answer to the
question of what does this program do
when you feed it to itself is that it
eventually finishes so what it should
have done is the opposite should have a
looped forever because this program is
supposed to be doing the opposite so
that's not the right outcome and the
same argument applies the other way as
well if it loops forever then
it should have done the opposite have
eventually finished so that's the wrong
answer as well and what's going on here
is that we've designed a particular
program a special program where neither
of the things that it can do is correct
behavior because it's inherently self
contradictory now every program that we
write has to either loop forever or
eventually finish but whichever one of
those happens in this case that means
that that halts method was wrong about
what was going to happen so by
construction of that that program that
we wrote we forced that the answer that
comes out of that halts method to be
wrong because we're just subvert it what
when it returns true to say that the
program eventually halts we just keep
looping and vice versa so because of
this sort of self referentiality we're
able to write a program that does the
opposite of whatever this halting
checker says it's going to do so we've
sort of caught it in a trap by writing a
program that makes it impossible to be
right and this is what the argument
looks like it says if we could write
that halts method then we could use it
to construct one of these special
programs that forces that halts method
to give the wrong answer in at least one
case but if that halts method gives the
wrong answer in at least one case then
it's not a correct implementation of
halls because a correct one would always
give us the right answer so it must be
impossible to write that halts method so
depending on how much of that made sense
to you it might be slightly mind blowing
or it might be completely uninteresting
but either way it does leave you with
the question of like who cares you know
this isn't the kind of thing that
actually affects us in our day-to-day
life it doesn't seem like like we never
actually want to ask a computer to write
a program that will loop forever I can't
remember the last time someone asked me
to do that but we do often want to ask
computers other questions about programs
you know like when we when we're writing
tests that's really us teaching the
computer to answer questions about
programs and we want that to work so
let's say that I've just started working
for a new VCE funded startup in the
valley
my boss has come to me and said that he
wants me to write a program that prints
hello world I've got a month to do it
I'm gonna do it in you know we do scrum
and that so I'm gonna you know do some
iterations and things and because I'm a
software craftsman responsible
programmer I'm not just going to sit
down and bash out this program that
would be ludicrous first I'm going to
write some tests and then once I've
written my tests I'm gonna write my
implementation and the test will tell me
whether my implementation is correct so
let's say that for my tests I'm gonna
I'm gonna write some method like this
this is a this is a print HelloWorld
checker and I can feed a program into
this and it's gonna analyze it and tell
me whether that program prints hello
world and I don't know about you but
this seems eminently reasonable this
seems like the kind of thing that it's
quite sensible to be able to ask about a
program so if I implemented this I'd be
able to say does this program print
HelloWorld this program that reverses
its input if I feed it that string as
input does it print hello world and it
would say yes it does your tests are
passing whereas if I feed it this
program that just up cases its input and
I feed it the same input it will return
false no your tests are broken so that
all seems like something we should be
able to do in a fair world but
unfortunately if it was possible to
write this prints hello world method it
would also be possible to write this
halts method and I apologize for the
Ruby syntax here if you're not familiar
with it but essentially what's going on
here is that this horse method builds a
slightly larger program from the one
that you give it you pass in a program
that you want to know whether that
program eventually finishes or not and
then we just build a slightly larger
program that will read
in that program from standard input and
then evaluate that program and then
after the program is evaluated it prints
hello world and put it in particular
evaluate here is just throwing away any
output of that program the only thing
that this HelloWorld program can do is
print hello world but only after the
evaluation of that program has finished
and so once we've built this larger
program we passed it into that hello
world checker and then that will tell us
whether that original program finished
or not because when the original program
finishes then this larger program prints
hello world and if the original program
sits in an infinite loop forever then
this one never print hello world and
this is called a Turing reduction we've
reduced the halting problem to the
problem of checking whether a program
prints hello world and that's a bit
suspicious because that tells us that
the the prints hello world problem can't
be any easier than the halting problem
because you can use it to solve you know
the halting problem so the argument says
if we can write this prints hello world
method then we could use it to construct
a correct implementation of that horse
method but we've already seen that it's
impossible to correctly implement that
horse method so it must be impossible to
write that prints hello world checker as
well and the source of the difficulty
here is that even if a program does
contain the command print hello world
you to write this checker you do need to
be able to tell whether the execution of
that program is ever going to reach that
command which involves deciding whether
the part of the program before that
command will ever finish and that's
where the halting problem lives so this
is bad news it means that not only are
we not able to ask that very specific
program does this program ever finish we
also can't ask does this program even do
what I want it to do so you can't ask in
general whether a program meets its
specification or you know does this
program not contain any bugs this is a
problem that Apple has they would love
to be able to take all of the
submissions to the App Store and feed
them into some magical machine that
tells them for sure
or whether those submissions are calling
any private api's or whether they have
any malware in them or or anything like
that but in general that kind of that
kind of operation is not possible to do
correctly and this observation is called
Rice's theorem which roughly says any
interesting property of program behavior
is undecidable and just to tell you the
meaning of those words the word
interesting means that any given program
may or may not have that property so
it's something that's worth checking for
behavior quite specifically means
something about the function that's
computed by a program and that's a bit
vague but it doesn't mean things like
syntactic properties of the program
obviously you can decide whether a
program the whether the source code of a
program contains the literal string foo
just by looking at it but these
properties of program behavior are about
what happens when the program runs an
undecidable means that you can't write a
program to decide it in general
so this Rice's theorem is a massive
downer but this is why being a
programmer is so annoying you can't get
the computer to tell you things about
programs even though it would be really
useful for the computer to be able to
tell you things about programs so
briefly why does this happen why are we
in this situation and roughly it's
because you can't look into the future
and predict what a program is going to
do in general the only way to find out
for sure what a program is going to do
is to run it and Stephen Wolfram calls
this computational irreducibility the
problem is when you run a program you
don't know in advance how long you have
to wait for it to finish and some
programs never will finish so any system
that's got enough power to be self
referential like these Universal systems
can't correctly answer every question
about itself that's the essential
content of girdle's first incompleteness
theorem and you know we didn't this was
only discovered in 1936 and it was a
massive bombshell
and in mathematics and it continues to
be a massive bombshell today in computer
science that like we can't we can't
build this system these systems that are
able to answer every sensible question
in order to answer questions about self
referential systems we have to be able
to step outside of them and use a
different more powerful system to answer
questions about the self referential
system and that was fine in the case of
these total programming languages
because we could just say oh we'll just
step out of it and use a more powerful
programming language to answer that
question but the problem here is that
when we're talking about Universal
systems there is no more powerful system
for us to upgrade to these
turing-complete systems are the most
powerful computational systems that we
know how to build so we can't do this
step outside to answer the questions
we've hit a kind of a ceiling of
capability so I'm nearly out of time I'm
just going to very briefly try and leave
you with information about how we can
cope how do we live in this this
difficult world we can cope by asking
undecidable questions but then giving up
if we can't find an answer in a
reasonable time so if we want to make a
HelloWorld checker we could just run a
program for 10 seconds and if it hasn't
printed HelloWorld within 10 seconds we
can just give up and say oh well it
hasn't printed HelloWorld and we'll just
put it in the know bin but sometimes
that's going to be wrong because if you
just waited another second maybe it
would have printed it out it might have
been one of those programs that prints
hello world after 11 seconds but if
you're going to wait around for those
ones then why not wait 12 seconds or 13
seconds or so on so eventually you're
going to have to accept that you're
going to make mistakes
you could ask lots of small questions
that collectively provide evidence for
the big question that you want and this
is really like writing acceptance tests
you know you're not trying to prove that
a system meets its specification but you
just take a bunch of samples that give
you collectively confidence that it does
what it's supposed to do you could ask
decidable questions by being
conservative and this is something that
optimizing compilers do they do an
analysis called unreachable code
elimination and in order to decide which
parts of a program are on
which is an undecidable property by
Rice's theorem
they just overestimate which bits of the
program are reachable
so by overestimating reach ability
sometimes they fail to remove pieces of
code from your program that are actually
never reached in practice but that's for
safety that's a reasonable trade-off and
finally you might decide to approximate
a program by turning it into something
simpler and then ask questions about
that simpler approximation hopefully
decidable questions and Static type
systems are quite a good example of this
if you have a program that talks about
values you know x equals 1 y equals x
plus 2 you could turn that into a much
vaguer program about types you could say
x equals some integer y equals x plus
some integer and by making it more vague
you've made it quite likely that the
questions you wanted to ask about it and
now decidable in the realm of these kind
of vague types and hopefully if you've
designed your types correctly that tells
you something interesting about the
original program so there is some hope
all right I'm out of time if you're
interested in this stuff I've written a
book about this stuff I don't have time
to tell you about it but I go through
all of this kind of cool crazy
computation Theory stuff so if you're
interested you should take a look at
that I'm you know I'm not gonna say
anything that's on computation book com
there's a free chapter if this has
piqued your curiosity thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>