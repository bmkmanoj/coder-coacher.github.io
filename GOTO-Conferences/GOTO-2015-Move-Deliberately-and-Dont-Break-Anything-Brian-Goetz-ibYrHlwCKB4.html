<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Move Deliberately and Don't Break Anything • Brian Goetz | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Move Deliberately and Don't Break Anything • Brian Goetz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Move Deliberately and Don't Break Anything • Brian Goetz</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ibYrHlwCKB4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Thank You Crescent
so this talk should be a good contrast
to Eric's talk last night because I'm
covering some of the same topics from a
slightly different direction so
everybody can take away the viewpoint
that that you find personally compelling
so when I was writing this talk one of
the topic ideas I was kicking around was
trying to illustrate what separated what
you might call grown-up software
engineering from well for want of a
better term kid stuff and aiko I
collected some stories about some heroic
feats of software engineering such as
how a strata systems anybody remember
strata systems a few of you okay
so they made these amazing systems in
the 1980s they were fault-tolerant
systems which were super redundant and
they were designed to never go down
under any you know condition they could
tolerate multiple hardware failures and
all of that but the really cool thing
was that you could also update the
device drivers in the operating system
while applications were still running
without losing connections and this was
one of those amazing you know superhuman
feats of software engineering that you
know would inspire us all so I you know
I I I had you know I had some ideas for
this talk and I'm really glad I didn't
write that talk because it would have
looked really pathetic next to Anita's
keynote yesterday which gave us a
glimpse into what real grown-up
engineering looks like so compared you
know to the challenges of landing a
rover on Mars or building a
self-sufficient system that has to live
on Mars for years with no hope of
resupply or repair what we all do sounds
pretty easy to me and as software
engineers we also have a different sense
of history than some of the other
engineering disciplines for example in
in conventional architecture we've you
know we've known how to make buildings
that could stand for a thousand years
for almost a thousand years and it's all
for engineering five years is a long
time a lot of systems you know that
we're working on I mean how many people
here
the system that you're working on in
your primary workday has been around for
more than ten years
so it looks like about 30% so most of
what we're working on has been built in
the last 5 to 10 years and as a result a
lot of the focus then what we do is
aimed at building new systems to do
something today and not necessarily the
building to stand for a thousand years
or even 10 now the system I work on is
old by comparison to most offer systems
that you know this year Java is 20 years
old and for the last five I've had the
privilege of piloting the evolution of
the Java language and today I'm going to
share a few thoughts on the challenges
of evolve in the mature platform and a
few lessons I've learned along the way
and a few thoughts on where we're going
next because we want to ensure that Java
remains vibrant for the next 20 years as
well so the title of this talk refers to
the slogan Eric mentioned last night
move fast and break things so Facebook
CEO Mark Zuckerberg advanced this as the
motto for the Facebook engineering
culture in the early days basically
telling the team that it was more
important to make progress on improving
the user experience than it was to worry
about preserving what was already there
and this may have started a Facebook but
it's become you know emblematic of the
startup culture and you're starting to
see it you know even filtering into open
source projects as well and it's not
surprising that developers are drawn to
catchphrase like this you know breaking
things gonna be fun right
and it's often a lot easier to break
things than to build them and the parts
that slow you down or often the boring
unglamorous parts so who wouldn't want
permission to ignore all of the things
that slow you down we do have to be
mindful of the logical fallacy just
because some progress entails breaking
things doesn't mean that breakage
indicates progress some people have that
a little bit a little bit backwards
now this phrase really isn't about
breaking things it's about building
things breaking things is rarely a good
idea on its own in fact usually breaking
things comes with legal and financial
consequences and obviously the intent of
saying move fast and break things is not
to say go out and commit vandalism right
or to celebrate destruction it's to
create the opportunity to build
something better without getting slowed
down by the need to preserve the status
quo and in other words it's a way of
giving people permission to value what
could be over what is and that's a
pretty good thing and giving permission
to break things so that better things
could be built in its place isn't really
expressing a technological or social
viewpoint it's expressing an economic
one so zugerberg was knowingly or not
appealing to the work of the economist
Joseph Schumpeter who coined the phrase
creative destruction to describe the
inevitable fact of capitalism that that
progress comes at the expense of what
came before the growth of new industries
like automobiles inevitably brings back
the DES prints out the decline of old
industry is like horses
so it's notable that Facebook doesn't
say this anymore last year at the f8
conference superb retired the old motto
and offered this much less catchy one in
its place and and this really was saying
something I saying that yes what
progress is still important but not at
the cost of destabilizing the user
experience so what change for them well
when you're a start-up with no users and
a Minimum Viable products the economics
all point you towards making a lot of
progress fast regardless of the
collateral damage or the accumulation of
technical debt because if you don't make
some progress fast you're going to run
out of money you're gonna get scooped by
the competition and it's game over when
you're the market leader with a mature
product the economics points in a
different direction and you don't have
as far up you can climb and you have a
lot farther than you can fall so it's
not surprising that startups are more
concerned with progress than while while
more established businesses care more
about stability and you know for a good
summary of this we we can look at the
the poet Bob Dylan who said it pretty
clearly when you ain't got nothing you
got nothing to lose I'm not gonna sing
it for you so move fast and break things
is a sensible strategy when you're a
plucky startup hoping to rise above the
crowd to get some attention but it's a
less appropriate strategy when you have
a billion users
and and the point of all of this is the
priority between progress and
preservation is a business decision move
fast and break things isn't a philosophy
and it's not a strategy it's a tactic
its business tactic and hopefully it's
one supported by a sensible cost-benefit
analysis of whether this is going to
further your business goals or not
one of the things that separates the
grown-ups from the kids in this industry
is the understanding that programming is
fundamentally an economic activity
technology is exciting it's fun and
we're all lucky that we get to do it for
a living I mean I'm thrilled that I get
to do what I do for a living but
technology is a means to an end it isn't
an end unto itself if it were cheaper or
faster to build Facebook add of rubber
bands and duct tape then then out of PHP
then that's what they would have done
and I know what some of you were
thinking you're thinking PHP is rubber
bands and duct tape and that's perfectly
valid conversation but that's a subject
for a different talk you know but if
programming is economic activity we
should be able to measure the the inputs
and outputs and so the inputs are pretty
simple right
you need programmers and you need pizza
and the outputs are a little harder to
measure but you know in any successful
scenario you're hoping to get some
working code and you're also bound to
accrue some technical debt which you can
think of as the obligation to provide
more developer time and more pizza in
the future assuming you're planning to
stay in business so moving fast and
breaking things is a choice that I want
to get more of both of these outputs
more working code and also more
technical debt for a given amount of
pizza and you know in some cases where
you've got nothing to lose and your
investors are breathing down your neck
it can really be a smart choice but
again this is a business decision based
on business conditions and those change
over time and it's it's important that
we not confuse this for a philosophy so
by moving fast and breaking things
you're choosing to value time to market
over stability and future maintenance
cost and sometimes that's a perfectly
sensible decision
so to bring this point home I've picked
out a few quotes here from a great
article I just found a few weeks ago by
Jocelyn Goldfine called the right way to
ship software so I'll skip to the secret
there's no right way to ship software
but you know it all depends on the
business context so cold fine says in a
profession where we carry out decades
spanning holy wars over tablets and
capitalization it's not surprising that
people get attached to their development
and release habits but if shipping so
much software has taught me one thing
it's to be agnostic different
methodologies optimized for different
goals and all of them have downsides if
you maximize for schedule predictability
you'll lose out on proton engineering
productivity and this leads up to a plea
to developers please stop asking is this
process good or bad and start asking is
this process well-suited to my situation
now Goldfine was knowingly or not
appealing to the philosophy of Charles
Saunders purse sometimes referred to as
the father of pragmatism who in 1878
framed what is now called the pragmatic
Maxim I know it's a little bit wordy so
I'll summarize it for you
pragmatism means judging the thing based
on its practical effects on the world
around us rather than on their innate
properties as we perceive them so and
we're all like to think of ourselves as
pragmatists as engineers so it's useful
to go back to what pragmatism really
means and you know you could imagine
that purse is in turn appealing to the
works of a much older philosopher from a
galaxy far far away who might have said
although he didn't
there's no good there was only good for
and if Master Yoda had said this what he
would have meant is that as engineers
who are supposed to be pragmatic we need
to be willing to look past our own
aesthetic and principal beliefs about
what is good and what is bad and instead
judge things on the basis of whether
they work in the real world and we
should judge the good of something based
not on its intrinsic properties but on
what it is good for so in that light
what do we think of this move fast and
break things strategy well as probably
no one will be surprised the end you
know - if we say either good or bad
we're wrong right the answer is it
depends is it right for the situation so
this brings me to the main topic of my
talk today which is about engineering
closer to the bottom of the stack
and how you know the the engineering
decisions you make in that context are
different from what a lot of us are used
to and one reason why this might be more
relevant to you than you might initially
think is as our careers as engineers
progress we have a tendency to move down
the stack not because we make a choice
to move down the stack but because the
stack is growing above us there's more
layers up there now than there were 20
years ago so if you were comfortable at
a certain layer of the stack which might
be the middle when your career starts
it's gonna be closer to the bottom you
know as you get later into your career
so you need to think about this so you
know I googled around for some Java
software stack diagram so I found you
know found a lot here's one I found
internally this is the Oracle middleware
stack
most of these are Java based software
services you know for building
applications and you can see you know
there's Java there at the wave very
bottom actually in the official version
of this stack it doesn't even show Java
because they they can't even see that
far down but you know and here's another
one this is the the spring stack and
again you know what you see is javis
down there at the bottom right and of
course it's not really the bottom right
you know below that you have containers
and virtualization operating systems and
hardware but it's the bottom most part
that's visible to the developers in the
programming model and when you're the
platform that everything depends on
moving fast and breaking things isn't
such a great approach because down here
you know the term for breaking things
this book right and with millions of
users there's there's no such thing as
oh we can just we can change that no
it'll notice right
here everybody notices everything it's
it's really it's really scary
so you know when you're down here you
know you have to place a very high
priority on stability and compatibility
and you know there was a time in Javas
history when it wasn't the bottom of the
stack or even part of the stack and in
those days we did move fast and break
things and the amount of churn and the
language and then at the end design you
know leading up to the first release was
really pretty incredible but success
comes with a price and once you have
users counting on you your your choices
are a little bit more constrained
so when we talk about not breaking
things of course we don't want to break
our users code right that but this
aversion to breaking things doesn't end
just with the code the people part
matters a lot
we don't want to break our users
expectations or their confidence in the
platform or their mental models of how
things work or the value of the
investment they've made in their
technical skills and each of these forms
of people compatibility adds additional
constraints to how we might involve all
of the platform so you know in my role
as architect for the Java language and
also for the core libraries my job is to
shape the developers view of what Java
is the user-visible programming model
and of course there's no shortage of
well let's call them helpful suggestions
that I get from developers in the
community Eric had one onstage last
night but there's a big disconnect from
my perspective between what people think
I do and what I actually do so I made
some charts to illustrate the difference
so here's one possible view of what an
industry focused language designer does
from the perspective of our academic
colleagues and in this view my job would
mostly that about the technical aspects
of language design creating more
expressive type systems adding features
that let us express more kinds of
program safely or to make the intent of
the program more clear
and okay these things are part of my job
also but this view completely omits the
human side of enter when we're doing a
particular group of features we will
have of course a time budget and a
resource budget to get it done but we're
also mindful of what we like to call our
complexity budget a complex feature
might allow you to do some really cool
new things and express some interesting
and valuable new programs but it can
also do a lot of damage both directly
and indirectly so directly you know a
complex feature can cause damage because
it's easier to misuse and indirectly it
could cause damage by distracting the
developer from the task that they're
really trying to accomplish so keeping
it simple means that things can actually
be used and used correctly by real
developers and even simple and otherwise
sensible ideas might be discarded on the
basis of cultural constraints because
they're too disruptive or they're just
too different from the existing mental
models of our developers so for example
to take an example from Java 8 in in
Scala if you have conflicts between
members inherited from multiple traits
the conflicts get resolved by
linearizing the super types you give
priority to the ones that appeared first
in the extends clause totally sensible
way to do things except we couldn't do
that in Java because Java developers
have 20 years of experience that tells
them that the order in which the
superclass that super types appear
doesn't matter and to pull yanked that
out from under them and say oh just
kidding for the last 20 years it's been
this way but now you know the gong rings
and all of a sudden you know your
program semantics are frozen you know
the way they are people people are gonna
be happy about that would have been very
disruptive
so these considerations are something
you know that someone coming from an
academic programming language background
might never think about but when you're
involving a plan evolving a platform
used by millions of developers they
become very important so this next chart
is a little bit less charitable and
therefore more fun and this is what I
sometimes think people in the community
imagine I do based on what they say so
if you proceed around clockwise from the
top you know you've got your secret
backroom meetings and then every once in
a while you poke your head out of the
secret backroom
and you make some obnoxious comments on
a mailing list maybe you come to a
conference and makes himself promoting
comments and you know and from a
technical perspective it's mostly about
stealing features from other languages
and of course the most important topic
is syntax
now it's fun to complain about how
people don't understand what you do and
certainly it's somewhat therapeutic but
it's it's also important to remember
that these the people were doing it for
so in some sense what success looks like
is not correcting their wrong ideas
about how it works but just making it
work better anyway now james gosling
described java as a blue-collar language
and what he meant was it's a tool for
working programmers to get their jobs
done it's not an ivory tower creation
right and there may be a lot of rocket
science in designing it or implementing
it and certainly in specifying it but
you shouldn't have to be a rocket
scientist to use it and we heard from a
rocket scientist yesterday and of course
you know we want to have a broad
spectrum of users right and we can't
alienate any of these segments of our uh
you know of our user base we need to
have a wide range of users but otherwise
we risk sight of losing where's the
mainstream going
so while java primarily today may have a
tome and server-side business logic we
can't afford to alienate the high
frequency trading crowd because that you
know that they may be niche today but
some of those concerns may be mainstream
tomorrow
okay so this version of the chart is a
little bit closer to reality from my
perspective and there are some
structural similarities with the
previous chart you know there's
definitely a slice for for meetings and
interacting with a community but what's
really different is the technical focus
if you look at some languages it seems
like the goal is to add every feature
possible and certainly if you listen to
the users what you get are requests or
sometimes demands for more features
features features features but in
reality adding language features to
generally be your last resort and
because every feature adds some bad
weight to the language every feature may
interact with not only every feature
that's already there but it may interact
with features that don't exist now but
that you're considering for the future
and so we have to choose our features
very carefully because we're gonna be
living with them for a very long time
and a perfect example of this which is
on the chart here is serialization which
is managed to interact with every single
feature we've added since and you know
for example in the process of adding
lambda expressions in Java 8 the
interaction with serialization took
literally hundreds of hours of analysis
and discussion and I tell you I want
every one of those hours of my life back
the remaining slices mostly have to do
with the consequences of feature
interaction you know a common
misperception about language features is
that the hard parts either the idea or
the implementation and of course these
are important but for the most part we
consider these things to be the first
zero percent of the work right you know
that there needed to get started but
that's not where the hard work is the
hard work comes from fitting them in
with the existing features you have and
analyzing and testing them for
interactions with other features and not
just with the features you have but with
the features that you might have in the
future and you know the the most
important aspect of this is the
compatibility analysis you know
analyzing the compatibility consequences
of everything and of course there's
serialization now the really fun part
and the part I get to do just just a
little bit of the time is this slice
here at the bottom that's what would
James do right that's where you get to
go into your cave and meditate on what
is the true spirit of Java I get to do
that for about three hours a year but it
but it's but it's good okay so let's
come back to this theme of don't break
anything the biggest slice on the
previous slide was compatibility and
compatibility comes in a lot of forms
and we worry about all of them
the most important of these is binary
compatibility and this is about whether
call sites that are embedded in your
class files will continue to link when
you run them you know again against
again against other other newly compiled
class files remember all method
invocation Xand field access and Java
are dynamically linked to runtime
they're linked by name there's the name
of the method the name of the signature
is embedded in the in the class file and
it gets connected at runtime with the
implement you know with the method that
you that you're trying to call and
dynamic linkage is like what a job as
secret weapons right this is what
enables you to just drop a new jar in
your class path and not worry about it
but it's actually a pretty strong
constraint you know and class files that
are compiled in 1995 still run today and
we you know expect that they should
still run 20 years even though linkage
is happening every time you run there
you run your program source
compatibility another form of
compatibility we worry about a lot
that's whether clients or subclasses
will continue to compile after you make
a change to a class and so I've changed
superclass I go to recompile my subclass
does it still compile right that's
source compatibility there's behavioral
compatibility do things continue to work
the same way after a change there's of
course civilizational compatibility
bring up my favorite subject
well instances that have been serialized
on an older JVM or maybe a newer JVM
will they deserialize properly and then
there's a whole host of more subtle
compatibility issues such as changes in
the in memory footprint or the
performance characteristics and you know
there's this cross-cutting concern
that's fun you know that cuts across all
of these compatibility modes which is
separate compilation
so because of dynamic linkage you're
always having to deal with the fact that
part of your system may have been
recompiled and part of it hasn't been
and normally you know if you follow some
reasonable rules for evolving your code
this doesn't you know turn out to be a
problem but these things can show up if
you change your compilation code
generation strategy or when the
generated code for a class depends on
information from other classes that
shows up with bridge methods you know
that our consequence of generics and you
know it's happened more than once that
an otherwise where the idea has gotten
dropped because we have it we have an
ongoing compatibility concern whether it
be a binary compatibility or source
compatibility and that's not to say that
we would never ever violate any of these
forms with availability you know after
all you can't fix a bug without
violating behavioral compatibility on
the other hand there are times we don't
fix bugs for that reason and so you know
it has to be a very careful decision you
know so after you know sufficiently
quantifying the amount of code that
might break well we can consider whether
this is the right thing to do but it's
not something that we do very lightly
now a lot of people think we're crazy to
be this concerned about compatibility
but my claim is there really isn't any
other responsible choice when you have
billions of lines of code out there
nearly any incompatible change is gonna
break someone's mission-critical code
and some people say so what right but I
think it takes a certain kind of
arrogance to say yeah yeah you should
break his code it'll be for his own good
right but still people actually say this
to us with some frequency and I'm sure
they think they're being helpful rather
than arrogant but that's but the mistake
that they're making is they're only
focusing on part of the picture and what
I see is that developers tend to
overestimate the importance of code and
underestimate the importance of stable
programs now this shouldn't be
surprising to anyone right what a
developers stare at all day code right
so for them it's their whole world but
it's really only part of the picture
it's just the part of the picture they
see all day so it's a little bit like
one of those optical illusions where
depending on what part of the picture
you look at you see a different answer
does everybody see it good evil good
evil okay good
so you know when users look at a
language feature they're imagining all
the good things they could do with it
which is great you know that's that's
what they're supposed to do they're
imagining what code could I write with
that that I can't write with the
language that stands today and when we
look at a language feature we do the
same thing but also we would have to
look at the bigger picture of how not
only how it might be used but how might
it be misused
how might it interact with other
language features how it might change
the style in which developers program
how it might affect the migration of
existing code to use these new features
and whether it'll cause subtle changes
and one of those changes are overall
good or bad for the ecosystem so when we
when we look at the changes and how they
might affect your code we're not
thinking about how it will affect your
code we have to be thinking about how
does it affect everybody's code now at
this point you're probably getting a
little bit depressed right you're
probably thinking well it's impossible
to change anything
Houck how can you make any progress if
you can't change anything and so you
might conclude the sensible strategy is
just do nothing right and that is a
guaranteed pass to compatibility but
it's also a guaranteed path to
irrelevance so evolving things
compatibly is not impossible it's just
harder and it's like working in pretty
much any other difficult environment you
have to approach the situation with the
proper precautions and training and
safety equipment so you got to suit up
this is an actual picture from our
offices just kidding okay so how do we
do it well if it's not acceptable to
change the meaning of existing programs
our language designers next best trick
is to expand the range of valid programs
that you can express so to assign
meaning to programs that previously were
invalid so ideally what you want to do
is add features so that they abstract
over other existing features so instead
of adding a completely new feature take
an existing feature and extend it to a
broader range of situations the reason
we prefer this is that this builds on
the user's existing mental models of how
things work and is also less likely to
create interactions with other features
now the really hard part in this is
coming up with a sensible semantics for
the abstract feature such that when you
restrict it to the conditions where it
used to be valid they match up with the
existing semantics right that's the hard
part so I'll give a quick example of
this this is like I think the only code
and the in the talk so apologies if
you're not Java programmers so if we
were going to start you know it's a good
example of this is when we added default
methods in Java 8 so Java 8 adds default
methods you can add behavior to methods
and interfaces it's a form of multiple
inheritance of behavior not multiple
inheritance of state but multiple
inheritance of behavior and if we were
starting from scratch with multiple
inheritance behavior the rules for
resolving conflicts but when you're
inheriting behavior from two different
super types probably would have been
very different from what we came up with
so to summarize briefly in you know Java
starting from Java 100 interfaces could
contribute only type information and
members so you have interface I with
member em and then class C has a member
M and then you have this class D that
extends both C and I and what happens
there is Wendy inherits M from both C
and I
the compiler just merges the members
because it says okay I have a contract
declaration in this super-tight I have
an implementation and that supertype I'm
gonna declare them to be the same thing
and everything's good so in Java 8 we
added the ability to add behavior to the
interface by marking it as having a
default implementation which can be
inherited in classes that don't declare
the method but now if you look at D you
have it inheriting behavior potentially
from two different super types so that's
a conflict that has to be resolved and
we want be adding a default
implementation to be a binary and source
compatible change so we don't want D to
all of a sudden be broken and have the
compiler say well you have a conflict
now you have to resolve it and so you
know what we what we did here is we
looked at how does the existing
semantics you know behave and let's find
a way of defining the semantics of
multiple inheritance to be you know to
be consistent with that so what we did
was we used a standard evolutionary
track which was to adjust the rules to
give the priority to the old way so when
resolving a conflict we have three rules
rule 1 says we prefer the implementation
from a superclass to that of a super
interface so if there is an
implementation in the superclass super
class wins we don't even look at the
interfaces and this gives us absolute
compatibility with this existing code
because this rule one is how things
worked you know before we added behavior
interfaces and then like you know the
second rule is if two interfaces have an
implementation and one's a subclass of
the other we prefer the subclass that's
pretty obvious and then the third rule
is well there's no rule 3 and then the
programmer has to resolve the conflict
by overriding the method and picking
which implementation
right so this is what I meant by you
know adjusting a feature to fit in with
other other features right the rules
that we arrived at that that
implementations interfaces are just
defaults and they're subordinate to the
implementations and classes probably
wouldn't be exactly what we came up with
if we were inventing an object-oriented
language with multiple inheritance
behavior from scratch that's okay
there's this is also a perfectly
reasonable and sensible model and
there's more than one reasonable way to
design a programming language and we've
used this trick before this is the same
trick we used when we added autoboxing
in java 5 so we added these new implicit
type conversions where you could convert
from an int to an integer and this is
great except that all of a sudden the
set of applicable methods now is larger
than it used to be and that could
perturb overload selection decisions and
we didn't want code that used to compile
to not compile because now the overloads
are ambiguous so in order to keep this
from being incompatible we said we took
the overload resolution rules we said
take the old rules that's step one and
the new algorithm and then if step one
doesn't come up with anything then we
move on to step two which is consider
boxing conversions it's a trade-off of
complexity for compatibility and if you
don't make that trade-off too many times
you don't get mired in complexity if you
do that over and over and over again
eventually the rules that gets so
complicated that you you don't want to
deal with it but if you do it
judiciously it's a pretty good trick so
I call the strategy embrace and extend
because first you have to embrace the
existing semantics before you can find a
sensible generalization that both stands
on its own and matches the existing
semantics so it's like one of the tricks
that we have in our toolbox
all right so I've talked a little bit
more philosophically now about the
things that we learned the previous
example default methods this worked out
pretty well and we were pretty happy
with how that came out
but the idea did not spring fully formed
on day one it took probably two or three
years from the time we first cooked up
the crazy idea of what if we could
attach behavior to to interface methods
and the time we arrived at a sensible
model that Java developers don't look at
and say what is this alien contraption
you've nailed onto the side of my
language well people say that anyway but
you know some people don't like to learn
new things and so you know the solution
of course of how you get there is
iterations we went through a lot of
iterations of the language design you
know for this and each one seemed like
an improvement over the previous one but
it probably wasn't until we got to about
the sixth iteration that we got it down
to something that was simple and clean
enough that we could fit on one slide
like the slide I just showed you the
danger is because each iteration was
simpler than the previous one at almost
any point we could have easily made the
mistake of saying oh we must be there
because it's definitely simpler than
what we had yesterday and it's way
simpler than what we had last year and
we could have easily convinced ourselves
we were done and it you know the reality
is it takes a long time and sometimes a
lot of iterations to find the right idea
and more than once I had to tell my
management actually the man sitting
there hi George we weren't there we're
not there yet and it's gonna take longer
and thankfully the answer was always
take the time to get it right because
when contemplating something that you're
gonna have to support for 20 years and
it's going to constrain your evolution
for over the next 20 years you want to
be able to take the time to get it right
or be willing to not do it at all so I
recently came across this quote which I
think really echoed our experience here
this quote is from Steve Jobs where he
says when you start looking at a problem
and it seems really simple and you have
all these simple solutions you don't
really understand the complexity of it
and then you you know you start to
understand the complexity and your
solutions are you know are really
complex and you know that's when you're
at the middle of the of the process and
that's where most people stop and the
solution is there ten maybe to work for
a while but the great person will keep
on going and find the key underlying
principle of the problem and come up
with a beautiful elegant solution that
works and the really hard part you know
is when you found something that feels
like it works realizing that you might
still be in the middle and you probably
are still in the middle and having the
faith to keep going that there you know
that there might be a better answer in
there even if you don't know what it is
because it's really tempting it suggests
a clear victory and stop there you know
cuz after all you've been thinking about
this for two years you know the problem
is complex and yes your solution is
complex but of course it's complex it's
a complex problem right and you know
externally you could be dealing with
forces pushing you to ship what you've
got and and you know you need to be able
to take the time to find the simple
solution that's lurking in the in the
complex solution and it's amazing how
often this happens if you give yourself
the time to do it an even more extreme
example of this is generics themselves
so last year at JavaOne James Gosselin
told the story about why generics
weren't included in Java from the outset
and it's not because we didn't
understand parametric polymorphism in
1995 and it's not because we thought it
was a great idea to have a static type
system that wasn't strong enough to let
you put typed elements into a container
and not retain their types when they
come out it's because we didn't know how
to do it right and if we had kept going
anyway we would have ended up with
something like C++ templates or patterns
from beta and I think we're all pretty
glad we didn't get those solutions in
Java 100 and it may have taken 10 years
to get there but the generics we thought
were much closer to the spirit of
language and the generics we would have
gotten in 95 would not have been so if
you don't know the right thing to do at
least don't do the wrong thing and
sometimes that means doing nothing
and you have to be okay with that
another way to say this is reality
hardens like concrete before you do
anything there's lots of paths forward
once you do something there are many
fewer paths forward and maybe only one
and this is true for the little things
as well as the big so always be thinking
about what doors are closing in addition
to the doors you're opening a related
aspect to this lesson is you need to be
skeptical of the inclination to punt on
the hard cases when you're tempted to
punt on some case because it's too hard
that's generally a sign you're not at
the middle yet
oh sorry well a question is what does
punt me and give up say oh forget about
that I'm just gonna you know I'm just
gonna ignore that
it's a term from American football so
the reason this sense of finishing the
job is so important in language design
is that what might seem like a clever
compromise of we're gonna handle cases a
B and C and forget about case D this may
seem like a good compromise today and
tomorrow it is just another
incomprehensible irregularity that makes
programmers crazy and it's often
tempting to you know to get into that
because you can at least say well it's
better than it was before before a B and
C didn't work at all now a B and C work
and we still haven't solved D but you
know that's got to be better right but
you know irregularity really bothers
developers and for good reason because
irregularity breeds complexity and
complexity distracts you from the
programming task at hand so the kind of
naive suggestions that we sometimes get
of well just make another language
restriction that you can't do this when
that happens you know it may seem like a
practical shortcut but it's always gonna
be tomorrow's what in God's name were
they thinking topics
so this last bit advice is might sound
almost like the opposite of the previous
one which advises against accepting
irregularities because building a
regularity regular solutions too hard
the opposite of that which is also
important is to be skeptical of the
motivation to do anything for reasons of
consistency consistency is a good guide
and of course and and but we often you
know allow the desire for superficial
consistency to replace the deeper
analysis of the problem and you know I
came to this by you know observing many
of the most poorly thought-out
suggestions that we get always start
with for a consistency we should do dot
dot dot and invariably you know these
are terrible ideas and they're just you
know people are justifying it to by
consistency well the reality is when you
have a complex system you can find a
consistent the excuse for anything right
and so you you know when when
consistency see you know feels like the
best explanation you got a Diggy broom
and of course that doesn't mean
consistency is a bad goal it's great
goal right just don't use it to justify
anything and you know we have this great
quote from the American philosopher
Ralph Waldo Emerson a foolish
consistency is the hobgoblin of little
minds this is often misquoted though
people leave out the word foolish so
just be aware that some consistencies
are foolish and guard against that okay
so I want to talk just a little bit
about where we're going in the future
you know I talked a little bit about
some of the lessons we learned during
the you know the Java eight evolution
and Java which is a great upgrade it was
probably the biggest upgrades the Java
programming model ever involved
coordinated updates to the language the
library and the JVM and you know we're
seeing renewed excitement over Java you
know in the community these days which
is great so we're done right time to you
know time to rest on our laurels of
course not ok so how do we pick the
things that we we decided to work on
because we can only work on a few things
we don't have infinite bandwidth we have
a limited budget a limited complexity
budget so we have to pick our targets
carefully
and our approach for picking targets I
think is a pragmatic one look at the
pain points that developers and and
deployers are suffering from pick the
biggest one and beat on that
so in Java 8 you know these pain points
were mostly language driven specifically
improving the ability to abstract over
behavior using land expressions that was
great in Java 9 our focus is on the pain
of programming in the large reducing the
pain of assembling large applications
out of components and using those
techniques to module lies the platform
itself and get us out of class path hell
or jar hell but pain points can also
come environmentally so sometimes they
bubble up from the hardware and we since
we want Java and the JVM to continue to
run well on the moving target of modern
hardware every once in a while we have
to look at Java's relationship with the
hardware so let's talk about hardware
for a second and how it's changed in the
last 25 years and the summary is a lot
right most of us don't pay attention to
this on a day-to-day basis which is
great but hardware has really changed
dramatically in the last 20 25 years in
the very old days we had systems that
were single course and single socket so
the green thing represents your core and
the blue thing represents main memory
they had no cash no instruction parallel
no instruction level parallelism no
pipelining
so in those days an arithmetic operation
cost about the same as a memory fetch on
the order of you know 1 2 3 4 cycles so
the performance model was really simple
count instructions you could just do it
statically you could look at the
assembly dump of a program and model as
performance in your head
over time our systems got more
complicated so we added cash and we
added multiple layers of cash and then
we added multiple sockets and we added
multiple cores and the core accounts
grew and as these systems got more
sophisticated the cost of memory access
got less predictable and it ranged from
you know couple of cycles to get
something that's in your l1 cache to a
few hundred cycles if you cache miss all
the way down to main memory usually
three hundred plus three hundred cycles
is a reasonable estimate for a full
cache miss and at the same time the
cores got more complex with deep
pipelines and superscalar execution and
we can execute four arithmetic
operations on a single cycle so if a
cache miss cost you three hundred cycles
and you can issue forth batik operations
in one cycle a cache missed is now
costing you potentially a thousand
instructions so twenty-five years ago
one to one today a thousand to one now
it stands to reason that given a three
order of magnitude shift in the cost
model whatever engineering trade-offs we
made in 1995 about how Java lays out
data in memory can't possibly be optimal
for days today's systems unless we got
really lucky and we've been suffering
with some really bad decisions for the
last 20 years so it further stands to
reason that periodically we need to you
know update these things so let's look
at the JVM type system so you've got
your 8 primitive types
you've got objects you've got arrays and
this is super flexible you can model
anything you want with this but the
flexibility isn't in exactly the right
places so primitives are more rigid than
we'd like you know if you want to
represent you know a 65 bit integer
you're out of luck right you have to you
have to do that with objects and objects
are really flexible but sometimes more
flexible than we need and the big issue
is every object has identity which
exists to serve mutability and
polymorphism but not all objects need
this even though all object pay for it
and you might think that the VM would
just be able to figure it out and
optimize around this and VMs have gotten
really good at slicing through the the
cost of code abstraction
but they never really got very good at
slicing through the cost of data
abstraction and the reason for that is
that the VM can never really figure out
whether an object is gonna need its
identity or not because any code can use
any object as a lock at any time and so
the VM has to be pessimistic in the way
it lays out data so to illustrate this
you know imagine you've got a simple
tuple like class like an XY point and
let's say you know this is an immutable
class and it's fine also it's not
polymorphic so it doesn't really need an
object either than identity but it gets
one anyway so now let's say you've got
an array of those things so the array
has an object header and each element of
the array is a reference to a point
object which has its own header and you
know from a memory efficiency
perspective we're not doing very well
right we've got two words of data and
for each one of those we've got two
words of object header and a pointer so
that's like 60% overhead right and you
know because these objects are allocated
on the heap that's gonna be work for the
allocated on the garbage collector and
after garbage collection they may even
get shuffled in memory right
but the real cost comes from the
indirection cost of these pointers so if
you're walking your way through an array
events you get great locality right so
you pull the first one in and you know
it pulls the next 7 or 15 into the cache
line and by the time you're on the third
or four if the hardware prefetcher is
kicked in and it's already pulled the
next slug in and everything's great on
the other hand if you've got an array of
objects like this you may catch miss on
every one of those T references and
cache misses like I said before it can
be really expensive now maybe this is
fine maybe your data set is small maybe
you know your performance requirements
are you know are moderate and it's not
an issue which is actually the case for
you know ninety ninety-five percent you
know of Java deployments but if you're
doing something like high frequency
trading or big data analytics these
costs really add up and you didn't
really ask for this layout right what
you'd really rather have is this layout
you have an array of XY points you'd
like them to be laid out X Y X Y X Y
now when confronted with a situation
like this developers sometimes take
things into their own hands sometimes
they have to sometimes they just can't
help themselves but developers will do
ugly tricks like this where they'll
shred you know an array of XY points
into two arrays you know one of X is one
of Y is hoping to regain the locality
that they lost and you know this code is
harder to write and it's harder to read
it's order to maintain and the sad part
is developers often do stuff like this
for performance reasons with no actual
evidence that their code isn't already
fast enough or maybe in fact without
having performance measurements or goals
at all but regardless of whether
developers do this had a genuine need or
out of some destructive obsessive
compulsive disorder you know we have to
blame ourselves for this to some degree
right we've put developers in a
situation where they feel like they have
to choose between their the good stuff
good abstraction and capsulation and
good performance and if you put people
in that choice so you know sometimes
people will choose wrong so this brings
us to the feature that we're working on
it's a vm feature and it's designed you
know because of the you know change in
hardware characteristics which is value
types if we recast this point class as a
value class what we're saying is we
don't care about identity we don't care
about all the baggage that brings with
it
and by giving up on this flexibility we
gain the ability to treat it as a value
so values are implicitly immutable and
final and they derive their equality
from state rather than identity which
means they can be passed by I value you
can pass them in registers or on the
stack instead of on the heap and this
means that if you have an array of them
they automatically find into an array
and if they're embedded in classes they
automatically get flattened into their
enclosing classes
and so when you traverse them you don't
have those interactions that you had in
the previous example so the cool thing
about values is that can have most of
the things classes have they can have
methods and constructors and fields and
their methods can be private and they
can be generic and all of that and
because they are not polymorphic there's
no dispatch cost when you invoke their
methods and so you can essentially use
them as cost free wrappers that give you
abstraction with no runtime cost so this
is great
and so our mantra for value types is
codes like a class behaves like an INT
the applications for this are obvious
right alternate numerix tuples algebraic
data types like optional or choice STL
style cursors and you know there's no
expressiveness benefit here you can't
write any new programs that you couldn't
write today with objects but what it
means as it lets you do that without
worrying about the cost and you know we
definitely you know we definitely
worried about cost as programmers even
when we shouldn't worry about cost
because we're wired to worry about
performance it's just how we're built so
by making the right thing also be the
fast thing we remove a whole set of
sources of friction from the development
process and because value types you know
have access to encapsulation just like
regular classes you know we can use them
like I said as secure cost-free wrappers
around sensitive data and get this free
lunch
of safety maintainability and
performance so that's really cool it's
been working on this for probably a year
and a half and we're getting close to
having a design that works takes a long
time
we've got a prototype in openjdk if
anybody's interested in so okay how does
this interact with generics remember I
said you add a new feature to interact
with everything else you've already got
so you know when you look at generics
with box primitives you we have the same
layout problem we had with the array of
points before we have an inefficient
data layout too much indirection they
have locality too much allocation you
know so if we have an array list of box
integers you know you have an object for
the ArrayList and an object for the
array and then an object for each
element and you know once you add values
to the language you immediately see that
this sort of uneasy irregularity that we
embraced in Java five which is you can't
genera Phi over primitives you can only
genera Phi are references that starts to
fall apart work for a while remember
like Steve Jobs says those things work
for a while then they fall apart well
we're hitting that Fall Apart point when
there were only eight primitive time
types you can look the other way but
once we add user-defined primitives it
really has to work with generics so you
know we're gonna have to bite the bullet
here and this is involves VM work as
well as language and library work to
support generics over primitives and
values so you could say I want an
ArrayList events and I actually have it
backed by a array events you know under
the hood so these two features that kind
of work together value types and
generics over primitives are part of
actually a larger effort to reboot the
JVMs relationship with memory and the
underlying hardware to try to balance
the need for abstraction and capsulation
with the performance reality of modern
hardware but I think it's a pretty cool
example of being able to teach an old
dogs and some pretty exciting new tricks
so okay time to wrap up I'll just close
with a little bit of a warning be
careful what you ask for we all want the
software we right to be successful we
all want it to be used by many people
for many years but success brings with
it costs and constraints that can be
really frustrating at times on the other
hand these constraints most notably the
need to keep the promises you've made to
your users whether you've made them
implicitly or explicitly they force you
to spend a lot of time upfront thinking
about whether something is the right
thing to do and what the possible
consequences and interactions will be
and most of the time thinking deeply
about something ahead of time pays off
so even if it does mean you can't rush
forward as quickly and you know as you
might have otherwise liked to so thank
you everyone for listening enjoy the
conference and don't break anything on
the way out
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>