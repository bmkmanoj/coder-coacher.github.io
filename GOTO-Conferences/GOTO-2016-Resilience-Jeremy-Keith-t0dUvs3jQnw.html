<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Resilience • Jeremy Keith | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Resilience • Jeremy Keith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Resilience • Jeremy Keith</b></h2><h5 class="post__date">2017-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t0dUvs3jQnw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">dang kazoo right well I better get the
whole day off then if I'm if it's all
meant to be one one long topic and well
what I'd like to do is I'd like to kick
it off with story actually more like a
creation myth you may have heard that
the internet was designed to withstand
nuclear attack and it's not exactly true
what is true is that Paul Baran was
working at the RAND Corporation he was
investigating ways of of making
resilient networks networks that were
resilient to failure and part of that is
to do with the design of the network
itself but he also hit upon this idea of
packet switching the idea that you take
your message and you divide it up into
small chunks and then you route those
small chunks around the network using
whatever the most efficient route is the
same idea was simultaneously discovered
by Donald Davies in the UK but it's Paul
Barron's idea that caught the eye of
Leonard Kleinrock who was working for
the Advanced Research Projects Agency
ARPA on something called the ARPANET and
to begin with the ARPANET which is the
idea of time sharing computers over a
network was very small this is it in
1969 and the very first message was sent
from one machine to another on October
29th 1969 at 10:30 p.m. and it was a
very simple command sent from UCLA to
Stanford and it was simply the command
to log in so that command was sent and
the entire system crashed after two
characters so this was the first message
sent on the ARPANET but they kept
working on it and the network grew and
grew it began to grow so much that other
networks were being connected to this
network and it started to evolve into
more like a network of networks or an
intern network if you will and as
networks joined this network of networks
it became more and more important that
they were all speaking the same
low-level language and that's where
these two come in Bob can and Vince Cerf
and now back then Bob cannon Vint Cerf
for yeah
an idealistic and they were not so much
concerned with making a network that was
resilient to say nuclear attack but they
were extremely concerned with making a
network that was resilient to any kind
of top-down control right any kind of of
ownership really and the idea was that
this network shouldn't have a center
that you didn't need to ask permission
to add a node to the network and they
came up with the tcp/ip the transmission
control protocol and Internet Protocol
and the real secret sauce of tcp/ip is
that simplicity it is very much a super
simple protocol for a deliberately dumb
network the whole idea of the Internet
is that the network doesn't care what's
in those packets being routed around the
nodes of the network and tcp/ip itself
was designed to be super simple in fact
we used to use to joke that you know you
should be able to implement tcp/ip using
two tin cans and a piece of string now
did it was that once you had this very
simple low-level protocol and you think
about what a protocol is protocol and in
diplomatic terms right it's an agreement
that's all it is let's all agree that we
use this same low-level protocol then
you can build on top of that and you can
add you know more complex protocols on
top protocols for sending and receiving
email right telnet to File Transfer
Protocol gopher and anyone could do this
in fact you can still do this if you
want to create a protocol today just go
ahead and do it you don't need to ask
for permission right you just put your
protocol out there see making the
protocol isn't the hard part it's
convincing people to use your protocol
that turns out to be the tricky bit
because you wanna make use of Metcalfe's
law right Bob Metcalfe creative ethernet
says laws like the value of a network is
proportional to the square of the number
of nodes something like that basically
what he's saying is the more people use
a network the more valuable the network
is right so the first person to have a
fax machine had a useless lump of
machinery but as soon as one other
person had a fax machine it was
exponentially more useful right so
making a protocol not a problem
convincing people to use your protocol
challenging so this is the situation
with the internet where we have this low
landline protocol you can create more
complex protocols on top this was the
situation at the end of the 80s starting
90s when a new protocol appears on the
scene the hypertext Transfer Protocol
HTTP and HTTPS just one part of a three
part stack called the world wide web
project HTTP for the protocol layer URLs
for identifiers and a super simple
format called HTML for the resources now
this worldwide web project as you know
is the work of young computer scientist
named Tim berners-lee working at CERN
well what I love about this this is look
how happy is with this project the world
wide web project at this point it only
exists on one computer and yet he still
called it the world wide web project is
that his conference and there's a whole
bunch of influences went into the world
wide web project the Internet itself
right this idea that you shouldn't need
to ask for permission that there is no
center to the network but I also think
that one of the influences on the world
wide web was where Tim berners-lee was
working because this is where he was
right CERN an amazing place right
underneath the border between
Switzerland and France so you've got the
most complicated piece of machinery the
Large Hadron Collider ever created by by
humanity recreating conditions from the
start to the universe you've got this
ridiculous level of international
cooperation required to even make the
thing happen and then you've got
scientists win Nobel Prizes
collaborating with students on summer
internships and there's practically no
hierarchy they're just people working on
experiments and it somehow works and
it's producing enormous amounts of data
and people are trying to collaborate and
yet they're allowed to use whatever
hardware they want they're allowed use
whatever software they want there I
would use whatever formats they want how
do you make sense of this so this was
kind of the the challenge facing Tim
berners-lee and the other computer
scientists at CERN has given this crazy
chaotic and yet somehow working
situation at CERN how do we enable the
flow of information and Tim
berners-lee's Tim berners-lee's idea was
was this using hypertext I didn't create
hypertext
the idea of hypertech's has been around
for for many decades before you know Ted
Nelson and Vannevar Bush and people like
that and and Tim berners-lee himself had
played around with a hypertext system a
few years before it was called Inquirer
and it was it was based off this
Victorian book of manners called inquire
within upon everything which I always
thought would be a great name for the
World Wide Web
right inquire within upon everything so
there's all these influences playing
into this idea of the World Wide Web
and it comes together in this proposal
that Tim berners-lee submits to his
supervisor Mike sender which has a very
uninspiring title information management
a proposal right but his supervisor must
have seen something in this because when
this landed on his desk he scrawled
across the top vague but exciting right
and so we get the World Wide Web
which is excellent but like I said it's
not enough to just create something you
have to also convince people to use it
and what Tim berners-lee realized is
that the way you you get adoption is by
making things well to use the apocryphal
Einstein quote as simple as possible but
no simpler right so it isn't so much
about making the best possible system or
the best possible format or the best
possible protocol it's making something
that people will use and I think if you
look at the pieces of the world wide web
there's something to that none of these
are the best at what they do right HTTP
isn't the best protocol but it's simple
enough to people can get started but all
of these things have their flaws
definitely but they're simultaneously
simple enough and yet powerful enough to
allow people to get started using them
HTML being a good example the first
version of HTML there was no official
version 1.0 of HTML right all there was
was this document called HTML tags
presumably written by Tim berners-lee
which documented the entirety of HTML at
the time which was 21 elements that was
it that was all of HTML and of those 21
elements almost all of them were taken
wholesale from an existing markup
language already being used at CERN
right the scientists at CERN were using
a flavor of sgml standard
generalized markup language to markup
their documents in fact you could take
some of those sgml documents change the
file extension to dot HTML and open it
in one of these newfangled web browsers
and it would probably work so it was
very much about instead of trying to
change people's behavior
just nudge people's behavior slightly
right and then you're bound to get
better adoption and it turned out to be
true and people started writing
documents in HTML which wasn't even what
Tim berners-lee expected Tim berners-lee
expected that the the resources that
people will be sharing would be in all
sorts of different proprietary formats
but there would be HTML documents to
kind of just link to them kind of just
as index pages but it turned out to be
simple enough and yet powerful enough
that people started writing the actual
documents in HTML itself an HTML grew
and grew to the extent that by the time
we get to html5
there's 121 elements and yet it's still
HTML now this kind of blows my mind that
you could have a format that that grows
you know from 21 221 elements over the
course of you know 20 years or so and
yet still remains the same format
because if you know anything about the
history of you know computer formats you
realize how unusual this is if you try
to open up a word processing document
from 20 years ago using a computer from
today you're gonna have a bad time all
right
and yet HTML is still possible an HTML
document from 20 years ago still
possible in a modern browser even better
theoretically if you're building it
right you could take a modern web site
and open it with a web browser from 20
years ago
and that is really unusual right and in
terms of computer formats that that this
this longevity could happen for 20 years
and I think part of the reason why it's
possible is down to a design decision
with HTML so the risk of teaching
grammar suck eggs I want you to think
about what happens when a browser
encounters an HTML element right you've
got a start tag closing tag some content
in between maybe there'll be some
attributes on that opening tag but
basically when the browser sees this it
renders the content in between the
opening closing tags depending on the
element that might
also do some other things that might
style it a certain way it might add
behaviors if it's a link or forum
element or something like that
but generally it's what happens all
right you all know this right give a
browser an element it displays what's in
between the opening and closing tags but
what happens when you give a browser an
element it doesn't understand an element
that doesn't exist in HTML it still got
an opening tag it still got a closing
tag and it still got content in between
what the browser will do is it will
display the content in between same as
it does with an element that it doesn't
understand what's interesting here is
what the browser does not do and this is
the design decisions I think was so
crucial the browser does not throw an
error to the end-user the browser does
not stop parsing the HTML document at
this point and refuse to parse any
further it simply ignores the tags it
doesn't understand displays the content
in between those tags and carries on has
done nothing had happened and that is
how we get to go from 21 to 121 elements
because every time we add an element to
HTML we know exactly how old the
browser's old user agents will behave
they'll ignore the tags they don't
understand but still display the content
so just how we can start using new
elements even before every browser has
support for them and this behavior is
something we can even take advantage of
for more complex elements so you got
something like the canvas element right
very complex requires scripting to do
anything if we know that an older
browser will display what's ever between
the opening and closing tags
well that's say okay if you are a newer
conforming browser and you do understand
canvas don't show what's in between the
opening and closing tags and that means
we can use that space for fallback
content so we can put information there
specifically for older browsers right so
we can start using a new complex element
and still have some kind of fallback for
older browsers now that's not an
accident that's a deliberate design
decision because the canvas element when
it first started life was a proprietary
element created by Apple this is how a
lot of standards gets made you know one
browser will just create something other
browsers go ooh that's good we'll have
that and then they standardize on it
right but when canvas was was invented
by Apple it was a standard
element it didn't have a closing tag it
was during the standardization process
that had gained this closing tag
specifically so that we could do this so
that we could put this fallback content
in between you see the same pattern with
things like video and audio here's an
interesting element the image element I
finally interesting for his history um
because it started the web there was no
image element there was there were no
images right it was a text only medium
and in those early days Tim berners-lee
created the world wide web project he
also was running this mailing this www
talk which pretty much everybody who was
on the internet or on the web sorry and
everyone was on the web was pretty much
making a web browser so basically people
making web browsers getting together and
discussing how they were going to evolve
this project how they were gonna evolve
HTTP or evolve HTML and they're having
this discussion about the idea that they
could perhaps be images on the World
Wide Web and they're debating about what
it should be calls will be called the
icon element maybe we should be called
the object element because one day there
might even be video on the web and
they're discussing it back and forth
when Marc Andreessen is working on the
mosaic project chimes in and says guys
guys I'm just about to ship it it's
called the image element IMG it takes an
SRC attribute you point to the image and
it's landing in mosaic and everyone else
on the mailing list went okay because
what they had then was rough consensus
and running code and that was pretty
much what trumped everything but it's
not like it's a great well-designed
element I mean you see we don't get a
closing tag right it shipped without a
closing tag that means we can't put that
fallback content in between the opening
and closing tags that's why we end up
with this alt attribute right for
alternative text it'sit's a bit clunky
but it worked up to a point I always
felt like there was this clash in terms
of how text is handled on the web where
it flows right no matter what the size
of the container
compared to bitmap images where you've
got like a set within a set height and
it really came to its head with
responsive web design right where
suddenly we're trying to be fluid and
yet we're bumping up against these fixed
width things and so that problem was
solved with the introduction of the
source attribute and the design here
again
I really like this design pattern it's
not just that there's this new attribute
introduced into HTML you know instead of
the source attribute the way that source
set works and you give it a list of
here's some other images that you know
or maybe larger smaller higher density
whatever and you let the browser choose
what the source set attribute does is it
actually updates the value of the source
attribute what that means is you can't
use source set without using source in
other words you can't use this new
feature for newer browsers without also
providing something for older browsers
the backwards compatibility is built-in
because we know exactly how older
browsers will treat source set they'll
treat it the same way they treat tags
that they don't understand they just
ignore it right they don't throw an
error
they don't stop parsing the HTML and so
that responsive images solution it's the
same with the new elements we got has
this backwards compatibility nor you s--
must keep providing something for the
older browsers very smart design
decision and only possible because of
the way that HTML itself has been
designed it's basically it's because of
the HTML fault tolerance that we can do
this that we can simultaneously
introduce new features without leaving
older browsers behind and it's a similar
story with CSS in terms of how it
handles errors and if you think about
you know all the CSS that's out there on
the web which is pretty much all of the
web these days right how different these
websites look you know all the variety
of things being conveyed by these
websites and yet all of it comes down to
one simple pattern and this is it this
is all the CSS ever written ever will be
written
you got selectors properties and values
and that's it a couple of special
characters for the machines to parse or
I curly braces : semicolons but this is
it this is all of CSS of course the
tricky part is the vocabulary of the
properties in the vocabulary of the
selectors and all that but I kind of
find this really beautiful it is such a
simple pattern capable of evolving into
so much complexity and again if you
think about what a browser does if you
give it some CSS it doesn't understand
if you give a browser a selector that
doesn't exist well it simply doesn't
match that selector and so nothing
inside the curly braces gets executed
but again
it doesn't throw an error and it doesn't
stop parsing the CSS and refuse to parse
any further give it a property or a
value it doesn't understand it just
skips that particular declaration
carries on to the next one doesn't throw
an error doesn't stop parsing and if I
think about how CSS has evolved over
time particularly in the last sort of
five six years I think has been two
major developments and one would be that
we'd be using things like pre processors
or post processors right sass and less
stuff like that who is using something
like sass or less or some kind of okay
most people when they're writing their
CSS and the other interesting
development is that we kind of started
to have these conventions around how we
structure our CSS things like object
oriented CSS max BAM you know who's
using some kind of system like that BAM
or some yeah right now what I find
interesting about both these
developments preprocessor postprocessors
these these methodologies if you will
for structuring CSS is that neither
instance did we authors developers do we
have to go to the standards bodies or do
we have to go to browser makers and say
oh please implement this right because
in the case of sass or less it's all
done on your computer and what gets spat
out is still CSS right no need for the
standards bodies to get involved and the
case of these methodologies we're really
just talking about how we name things
and not even really looking at the
properties of values it's just about the
selectors right conventions around
selectors and what's interesting about
that is again it didn't require anything
new and CSS in fact most of these are
just dealing with class names and class
names have been in CSS right from the
start we could have had them 15 years
ago right it's like the possibility for
something like that was there the whole
time it's like it was staring us in the
face and we didn't see it I find that
really interesting not something I want
to come back to so CSS and HTML they're
powerful in a way because because
they're not so powerful if you get what
I mean it's their error handling that
makes them powerful their simplicity
right the fact that they're
fault-tolerant and this this idea of
being tolerant
of errors it reminds me of the
robustness principle probably familiar
with right John pastels law to be
conservative and what you send and be
liberal in what you accept
now John pastel he was talking about
network architecture we came up with
this - he was working on the ARPANET and
the Internet and he was talking about
this idea of how you would treat
packages packets being being routed
around the network that if if you if you
receive a packet that's you know it's
badly formed but you still know what to
do with it
well just carry on routing around a
network be liberal in what you accept
don't throw an error right but when
you're sending packets yourself try to
make them as well-formed as possible be
conservative in what you send now this
principle might sound like it's a it's
it's only to do with engineering right
there's quite a technical thing but I
see pastels law at work all the time in
the world of design in the world of user
experience like let's say you're putting
a form online on a web page
well first rule is you know keep your
form fields to a minimum don't ask the
user for lots of fields which you can
keep the fields to a short number in
other words be conservative in what you
send to the user but then when the user
is filling in that form you know don't
make them format the telephone numbers
with spaces or without spaces or the
credit card numbers right be liberal in
what you accept
so pastels laws is kind of all around us
and I think it's there in how browsers
handle HTML and CSS they kind of have to
write if a browser was gonna be stricter
about the HTML and CSS it receives and
refused to parse HTML or CSS it doesn't
understand well the user will just
switch browsers right so browsers have
to be liberal and what they accept now
when it comes to CSS and HTML I think
that one of the reasons why they can get
away with this loose liberal error
handling is because their declarative
languages right so with a language like
HTML or CSS you're not instructing the
computer exactly what to do you're
simply telling it here's what I want to
happen you go figure it out right I want
this to be a paragraph I want this to be
read whatever but you know the actual
instructions to the computer how you
make something read or make something a
paragraph that's left to the to the
runtime environment and
for that reason I think we can afford to
be you know tolerant in our error
handling now that's different with an
imperative language like JavaScript we
get a lot more control I'm talking about
JavaScript on the client side here where
you do get to say this is exactly what I
want to happen you get a lot more power
but for that very reason and this might
be a bit of a sweeping statement I think
that it has to be inherently a bit more
fragile so a bit of a sweeping statement
say this but I think the clarity of
language tend to be more resilient but
that's powerful
whereas imperative languages are more
powerful but a bit more fragile right
because you can't really have that same
tolerant error handling in an imperative
language if you try to actually write a
computer program but you make a mistake
and the computer just like ah don't
worry about it that's not going to be
helpful so in the case of client-side
JavaScript if there is something that
the browser doesn't understand it will
throw an error and it will stop parsing
the JavaScript file at that point and
refuse to parse any further right it's
got to have a stricter error handling
model kind of needs to do that because
it's an imperative language and that's
okay as long as we're aware of that we
can be more careful when we're writing
our imperative languages than we are
writing our declarative ones now
interesting one point in the history of
the web we almost got the worst of both
worlds in terms of the resilience and
fragility we almost got XHTML 2 a
problem you might remember XHTML 1 that
was fine
XHTML 1 was simply the idea of taking
the syntax of XML and applying it to
HTML because the syntax of XML was that
well all your elements have to be
lowercase all your tags
you know tag names attribute names
lowercase attributes need to be quoted
right that's all fine and in fact it
kind of enforced a bit of a standard
around how we would write HTML because
HTML doesn't care whether it's uppercase
lowercase quoted unquoted
it's fine so XHTML 1 was fine it was
just taking the syntax of XML and
applying it to HTML but it didn't really
change anything about HTML XHTML 2 was
going to be very different it's going to
fundamentally change the vocabulary
deprecated the image element for example
but more
Courtney was going to take on the error
handling model of XML and the error
handling model of XML is this if there
is a single error in the XML file do not
parse the XML file right that's it's
draconian error handling now it never
came to be
XHTML - never came to exist because we
as developers as authors and browser
makers as well rejected this we said no
that's absolutely crazy why would we put
this in front of users something that's
so fragile that could break so easily it
just doesn't make sense I'm going to
stick with you know resilient languages
so we rejected XHTML two because of its
strict draconian error handling and yet
here we are about ten years later and
somehow we've decided that it's
perfectly acceptable to use something
with strict draconian error handling to
render some text on a screen I've taken
the most fragile layer of the stack and
using it for the most important
functionality I remember a couple of
years ago there was a day when nobody in
the world could download Google Chrome's
anybody remember this the web page for
download in Google Chrome was was broken
you'd click on the link all you want to
download Chrome wasn't going to work and
the reason was there was an error in a
javascript file which doesn't seem to
make sense because why should the
JavaScript have any effect whatsoever on
clicking a link but the reason was this
the link had been coded in such a way
that it was using the JavaScript pseudo
protocol right not really an href value
and so what you had was the the most
fragile layer of the stack being pulled
down into the more resilient layer
you're getting you know all the all the
other things that come with that
fragility but pull down until there
that's supposed to be more resilient and
and capable of responding to errors like
this I mean they fixed it it all turned
out fine in the end and the error was
probably completely unrelated it was
probably something could be different
but because of the error handling model
of JavaScript where one error is enough
to stop the parsing of the file there
was a time when nobody in the world on
load Google Chrome and I think this
points to another law that on the web is
just as
pourtant as pastels law and that's
Murphy's Law anything that can possibly
go wrong will go wrong he was a real
person by the way he was an aerospace
engineer and because he had this
attitude nobody ever died on his watch
now we don't like to think this way we
like to pretend that everything's gonna
be fine and you know in the case of HTML
and CSS we can kind of get away with
thinking of that because the worst is
going to happen is that the browser is
gonna skip over something that you made
a mistake in an element or you made a
mistake and some CSS no big deal with
JavaScript it can be a big deal
Stewart language put together a kind of
list of all the things that can go wrong
with client-side JavaScript and some of
these things are on the server and some
of them are on the network and some of
them are on the browser at the other end
but the point is making years that you
can't predict this isn't like you know
oh these particular browsers won't get
your JavaScript it's like well at
different times in different situations
different people won't necessarily get
your JavaScript right using hotel Wi-Fi
I think we've all been familiar with
some of these issues and we need to
accept this and it's okay that this
isn't the end of the world other
industries managed to accept this you
think about you know the auto industry
and okay the probably the reason why
they do this is because of regulation
but you know they thoroughly test their
cars they strap in crash test dummies
and smash them into walls I mean could
you imagine if the auto industry one day
said you know hang on we've been
thinking about this and we're no longer
going to strap crash test dummy dummies
into cars and run them into walls at
high speed because we've been thinking
about it and actually we think that
these cars will be driven by humans not
crash test dummies also we anticipate
that these humans will drive the cars on
roads as opposed to smashing them into
walls at high speeds and they'd be right
but yes that's what we're all hoping and
you hope for the best but you still
prepare for the worst and I don't think
we're really preparing for the worst in
our mindset you can hope for the best
and prepare for the worst at the same
time these two things are not opposed
and my friend Trent Walton who's a
designer in Austin he he wrote about
this he said like cars designed to
perform an extreme heat or an icy roads
websites should be built to face the
reality of the web's inherent
variability the reality
of the web's inherent variability that's
what we don't like to accept that there
is this inherent unknown nature to the
web because of the browser we talk about
the browser it's not the browser it's
the browser's right there are many of
them on many kinds of devices and you
can't know for sure what the situation
is with the network with the browser all
the things go wrong when that's okay we
just need to acknowledge it we're very
good at creating consensual
hallucinations right like remembering
when all websites were 800 pixels wide
or 640 pixels wide or a thousand 24
pixels wide when actually it could be
anything right so we need to acknowledge
the reality of the web's inherent
variability and I realized this sounds
very do me and blew me up till now so
you might be thinking like are you
saying we shouldn't use JavaScript
because of its error handling model no
that's not what I'm saying at all I did
not come to give you problems I came to
give you solutions here's what I think
we can do this is the approach I take
when I'm building websites it's gonna
sound deceptively simple but here goes
three steps one you identify the core
functionality of what you're building
two you make that functionality
available using the simplest possible
technology and then you enhance okay
sounds pretty straightforward let's go
through it step by step first
identifying the core functionality and
you notice here I did say the core
functionality the point here is not to
identify what are all the possible
things that users might want to do with
this service the point here is to narrow
down right converge what's the one thing
you want everybody to be able to do
regardless of what kind of device they
have regardless what kind of browser
they have narrow it down to the core
functionality set your baseline so for
example let's say you're a news provider
well I would say your core functionality
is providing the news that's it stop
there don't go any further we're not
even talking about technologies here not
to matter how you're gonna provide news
just identify what you're gonna do let's
say you're running some kind of social
networking platform where people can
send messages and receive messages from
one another all over the world well
that's it right there that's the core
functionality the ability to send
messages the ability to receive messages
stop if you have a photo-sharing service
the clue is in the name the ability to
share photos again I want to be able to
see photos I want to be able to share
photos core functionality identified and
let's say you've got some kind of
collaborative tool for writing editing
and sharing with people those verbs
right there I want to be able to write
one people edit I want to be able to
share good ok we've identified the core
functionality and we haven't even
thought at this point about technology
and that's the correct way to do it
don't start thinking about the
technology first think about what what
the what the experience is first what
you want to provide the people now start
thinking about technology but this is
the chrismas make that functionality
available using the simplest technology
not the best technology the simplest
technology the reason you want to start
by providing that core functionality you
want everyone to be able access with the
simplest technology is that the simplest
technology is most likely to be well
supported by everyone by keeping it as
simple as possible so in the case of
providing news online I would say well
the simplest technology I could use
would be HTML to markup the news I mean
technically the simplest technology to
be a plain text file containing the news
but I'm going to allow myself to raise
the bar slightly and say we can use HTML
that's it ok hTML is the simplest
possible technology sent from a server
to a browser done in the case of a
social networking site I need to be able
to see messages probably in reverse
chronological order well we've got HTML
for that but I also need to be able to
send messages ok this is where I start
to get a little more complex where
interesting form elements send it to the
server and now I'm able to send a
message to other people all right that's
the simplest possible way of doing this
in the case of a photo sharing service
very similar it's still gonna have a
reverse chronological list but this time
it's not text messages this time it's
gonna be photographs so we need to use
the image element and again a form is
what we'll use to send the photographs
but slightly different this time instead
of input type equals text it's use input
type equals file as far as I can think
this is probably the simplest technology
you can use to enable the core
functionality of sharing photographs
send this file to the server the server
then takes care of
of displaying it to other people and in
the case of some kind of collaborative
writing tool I need to be able to write
need if you were to edit and he was
share text area alright that's the
simplest technology I could think of but
if if I were to stop at this point right
with those those services I wouldn't be
holding my breath waiting for the IPO it
would suck the experience would suck
we've got something that works for
everyone which is great but it doesn't
work particularly well well that's
absolutely fine because we got step
three and this is actually where you
want to be spending your time the first
two steps shouldn't take long at all all
right we just saw there it you know very
simple low-level stuff this is where you
want to spend your time is enhancing
improving the experience making it
really saying this is where you
differentiate yourself from the
competition right well in the case of
providing news what we've got now is an
HTML page sent from the server let's
make it look good let's add layout using
CSS now it might seem weird to think
about layout as an enhancement right but
if you think about responsive design
particularly when you're designing
mobile first and then adding in the
styles and media queries for larger and
larger screens that's exactly what
you're doing you're treating layout as
an enhancement and note every time I say
enhancement don't interpret what I'm
saying as just an enhancement or merely
an enhancement like I said the
enhancements are what matter the
enhancements where you really make the
difference I'm just acknowledging that
they are enhancements on the core
functionality so we can make it look
beautiful at layout we can make it look
beautiful with web fonts write good
typography on the web we have that now
which we didn't have before which is
amazing and again it's an enhancement
not everyone will get that web
typography and that's okay because
everyone gets the core functionality
which is access to the news now in the
case of the social network we've built
yeah technically it works I can see
messages I can send messages but god
it's you know terrible experience well
let's stop the whole full page refresh
every time I send a message let's
introduce some JavaScript some Ajax so
that when I send a message I don't have
to refresh the whole page and let's go
further what other people send messages
that I can see that without having the
whole page refresh right using some
technology like WebSockets or whenever
we got in the browsers that works you
know and maybe not every browser
supports these technologies
again that's okay because the core
functionality is still available to
everyone we're layering this on top of
that core functionality in the case of
the photo sharing app let's do
everything we've said already layout
with CSS far web fonts Ajax WebSockets
all that good stuff let's go further
what else can we do when you know you're
uploading the file well before we even
send it to the server we can start using
the file API which you know modern
browsers have what could we do with that
file API can start playing with the
image even before it goes to the server
do things like add CSS filters put a
sweet sepia tone on that image right and
again not every browser supports all
these technologies yet and that's okay
these are enhancements on top of the
core functionality you're providing to
each browser according to its means and
in the case of this collaborative - well
obviously we're going to use Ajax and
WebSockets and layout and web fonts all
that good stuff but let's go further
let's not be reliant on an internet
connection at all let's start using
local storage of some kind and we have
many kinds of local storage in browsers
these days so that we can you know start
storing stuff locally as well as on the
server and let's go really far let's
start let's start making ourselves even
independent of the network itself start
treating the network as an enhancement
using something like service workers
this is probably the technology I am
most excited about right now in
front-end development it feels like a
proper game changer in the same way that
Ajax did ten years ago that can
fundamentally change how we build and
design these things and yet it's been
designed very true those principles of
the the early web and the early HTML
elements said you can only use
serviceworker
as an enhancement you have to already
have something working before you
introduce the serviceworker to make it
work better because the first time a
user visits your site there is no
serviceworker installed so it's kind of
a genius bit of design because that
means we can start adopting
serviceworker right now even if it were
only supported in one browser we could
start using serviceworker because it's
entirely an enhancement a very powerful
enhancement
yes service workers are kind of
fantastic all right so that's a three
step process
that you can you can build something
that works for everyone
and yet rewards the newer more modern
browsers by using the latest and
greatest api's right in a way it's kind
of giving you giving yourself the
freedom to play with these new cool
tools by spending some time at steps one
and two you're given freedom to go crazy
at step three and what I like about this
pattern this it's really just a way of
thinking it's sort of scale-free it
works at different scales I've only been
talking at a scale of the entire service
right what's the core functionality of
the entire thing you're building but you
can imagine applying these same three
steps at the level of a URL right the
level of a page what's the core
functionality of this page how do I make
that functionality available with the
simplest technology and then how can i
enhance or you can take it further we're
all getting into our systems thinking
and modular design and component izing
everything you could apply this at the
level of a component what is the core
functionality of this of this module
this component how do I make that
functionality available with the
simplest possible technology and then
how do i enhance right like you might
say okay proof of providing directions
somewhere okay that's the core
functionality of this widget here well
the simplest technology to that is some
text with the address fine that's done
we've done steps one and two now how do
i enhance let's add a map that's
enhanced more let's make it a slippy map
let's go further that's added cool
animations and you know neat effects you
can just keep enhancing at level three
because you've kind of given yourself
the freedom to write what I'm getting at
here is that I want to get away from
this this idea that there's a dichotomy
that you can either have an accessible
experience available to everyone but
it's boring or you have this rich
immersive experience but it only works
in the latest and greatest browsers and
devices I'm saying you can have both you
can have both with the same codebase not
at different URLs or different
subdomains but the same site the same
service can provide both at the same
time you know we tend to talk a lot
about technical debt right where some
decision that was made in the past is
now biting us on the ass is sort of come
back to haunt us well what what this
gives you by spending time with steps
one and two what this queue
you is technical credit alright you make
sure you've got the core function
available to everyone then you can go
crazy step three and you've given
yourself that kind of technical credit
to to use the latest and greatest API so
regardless of what the browser support
is like and there's a bit of a myth I
think when I talk about this to people
think ah if I'm considering how older
browsers will behave when I'm building
that means I'll be spending my time in
older browsers and actually nothing
could be further from the truth
in my experience because I know exactly
how older browsers will behave they'll
do it you know the simple technic you
know the simple functionality it works
for them I don't need to spend my time
with older browsers I spent all my time
in newer browsers trying out this new
cool stuff trying out the latest AP is
safe and the knowledge that I know
exactly how old the browser's will
behave now I'm moving on for some time
for questions but I want to preempt some
of the questions you might possibly have
I generally get two categories of
pushback on this idea and the first kind
of pushback against people saying this
is too easy
rather it's too simple it's too naive
right the idea that yeah this this
technique will work for a simple website
but it couldn't possibly scale for the
really complex thing that I'm building
right and what's interesting is that
I've heard this pushback before you know
when we were not gonna show my age now
but when we were trying to move away
from using tables for layout and font
tags and instead use CSS there were a
lot of people said well that's fine for
your simple little blog but it's never
gonna stay a scale for like real you
know corporate websites and in Doug
Bowman launches wire.com Mike Davidson
does espn.com and the floodgates open
and now everybody uses CSS for layout
right when Ethan came along with
responsive design there's a lot of
pushback from people saying well that's
fine Ethan for your little websites here
a simple little blog but it could never
work for this complex web site app that
I'm building and then the Boston Globe
launches Microsoft designer phone
praised page to be responsive and now
the floodgates have opened there and is
the same opportunity here floodgates
could open to build rich immersive
applications that are simultaneously
available to everyone regardless what
device or browser are you using
something that works in Opera Mini on a
slow connection
also works amazingly on the latest
version of Chrome with all the latest
API is enabled right so that's the
pushback against that this is too easy
but the other pushback I get is that
this is too hard that people look at the
three step process and they go are you
saying you know that I'm gonna I'm gonna
have to spend my time making something
that works and it's always you know
client server requests and then when I
started enhancing I replace all that I
duplicate all that work and now it has
to all happen in the client well not
exactly no that's not what I'm saying
because remember I said you identified
the core functionality not all the
functionality the core functionality
there's the plenty of stuff you can add
in step 3 that has no corresponding
functionality and in steps one and two
as long as you make that core
functionality work it's fine Matt Marcus
who worked on the Boston Globe design he
said you know there's lots of features
on Boston Globe com that don't work with
JavaScript unavailable but reading the
news is not one of those features right
so again it's about this difference
between the core functionality and hey
you know these days with JavaScript on
the server side as well as on the client
side you can shave off some of that time
- what are we calling it these days
isomorphic Universal whatever it is
there's now the possibility you could
literally have the same codebase on the
client and the server
but even so no I'm not talking about
reproducing everything on the server and
then on the client or vice versa it's
just having that that that base that you
can fall back to and again this push
back that this is too hard and look I'll
tell you the first time you do this it
will be hard the first time you try and
think this way and build a service build
a site build an application in this way
it will take you more time guaranteed
but I've experienced that before too the
first time I tried building with CSS
instead of tables and font tags it took
me a lot more time but the second time
after that it didn't take quite as long
and then the third time was quicker and
then it just became normal now I
couldn't build using tables and font
tags if I wanted to and one responsive
design came along if you'd spent the
last ten years making fixed with web
pages and then you suddenly decide to
try and make a responsive website it was
a world of pain right right then the
second time well still probably a world
of pain but not quite as bad and then
the third time it gets
and then it gets easier again and now
it's just normal that's just how we do
things so it does take time I'll give
you that but it's worth investing that
time it's fundamental what it does it
replaces the assumptions and these
desires for control that we've had for
years with an acceptance of the of the
chaos of the unknowability of the web
and it's the chaos of the web and not
knowing the browser's not knowing the
devices it stops being something you
fear and starts being something you
embrace and it's very very liberating
but I do see pushback like I said and it
I get I get a bit sad sometimes when I
see the nature of the pushback
particularly people say this is too hard
it's difficult there's a long time what
they're thinking about is developer
convenience and don't get me wrong
as a developer I highly prized developer
convenience I want my life to be
convenient and I think developer
convenience is important but it is not
as important as user needs whenever it
comes to these two things user needs has
to win out over developer convenience
most of the time they're not in
opposition most the time you get to have
both but in the situations where they
are in opposition I'm gonna go for user
needs every time I've often said that if
I'm confronted with a problem on the web
and I have the choice of making it my
problem or making it the users problem
well make it my problem every time
because that's my job I'm getting paid
to do this right so why it's called work
it seems like we've always been this way
right the developers constantly ah
that's too hard that's too difficult
it's if we need to need to make life
easier like web design will be so much
easier when we've more than 216 colors
to play with it's true one time we only
have 216 colors right our web design
will be so much better when we can start
using fonts other than these system
fonts to come pre-installed on computers
right our web web development be so much
better once people upgrade from Netscape
4 then everything is going to be great
if people would just upgrade from
Internet Explorer 6 then life is gonna
be fantastic
it's those Windows XP users that need to
upgrade so that everything will be fine
if those Android version 2 users would
just get off and upgrade their system
right
there's always something there's always
something that we're complaining about
and my friend Frank mirror wrote this
story a few years ago called there is a
horse in the Apple Store
and then it he describes the real
experience of seeing a tiny horse in the
Apple store and he describes seeing a
tiny horse in the Apple store but he
also describes the reaction or complete
lack thereof by all the people in the
Apple store looking at the Apple devices
there's this amazing thing right in
front of your eyes
there's nobody see the tiny pony in the
Apple store and he's taken to calling
these things tiny ponies things that are
amazing miracles right in front of our
eyes but we don't see them we've grown
used to them and I think that way about
the World Wide Web the world wide web is
a tiny pony right this amazing thing
right in front of us stuff we're
constantly complaining about what I
can't do whether it was cd-roms or flash
or native we're always comparing the web
to other media and seeing what the web
can't do yet compared to those other
mediums and completely missing what only
the web can do and that's this this is
the super power of the web this is the
tiny Pony URL so simple how could this
be a superpower and yet the ability to
distribute software instantly right by a
simple link heck by a post-it note is
amazing the ability then to have it
persist at this identifier that you
cannot just build something for people
to use right now but you can build
something over time
that people can use now and in the
future that you can extend the reach of
our networks for future generations
extend the reach of the collective
knowledge of our species that's a lot of
responsibility which means we need to be
good ancestors and leave behind a web
that lasts a web that's resilient thank
you
so the question is are there examples on
the web yeah there's plenty of them out
there things you shouldn't notice is the
thing the great the thing about working
this way is that you know no matter what
kind of device you're using you
shouldn't notice that it's been built in
that way you really only notice under
the extreme circumstances right we're on
the when you're on that crappy network
and you run that older device or
whatever situation where things go wrong
so there's a lot more examples out there
of oh look at how this thing broke under
unexpected circumstances people 10 it's
like air conditioning and nobody ever
points out when the air conditioning is
perfect alright nobody ever stops the
meeting and says can I just say whoever
set the air conditioning it's just right
you only notice it when it's too hot or
too cold so there's plenty of websites
and services out there building this way
but it's not it's not a feature it's
just how you build it you can see some
examples at progressive enhancement org
which is a website that collects
tutorials and articles examples stuff
like that but in general it's more a way
of thinking I think then it puts a
particular thing a lot of big players
ended up sort of moving in this
direction there's just kind of pendulum
swings that tend to happen like I
remember a few years ago everyone was
going down the client rendered route for
everything JavaScript all the things
right Twitter did the whole hashbang
urls structure right we're literally
javascript is requirement just to
navigate from page to page and they
ended up going away from that and going
to a more resilient architecture for
that now the reason for that wasn't this
idea of I'll make it available to the
widest number of users and all know
simple performance it turns out that
front loading everything into JavaScript
means you have to wait for all that
JavaScript to download execute before
the user gets anything so the time to to
the user being able to interact with
something is is just not good enough if
you're doing that Susan a lot of the big
web sites have had
you know swung in that direction but
answer the question checkout progress
enhancement org for some examples but
yeah it's hard to spot these things
because it's more such a low-level way
of working don't be shy all right we're
going here where do you stop I mean do
you have to support think in my view
there's a trade-off between
backwards-compatibility and effort yeah
and to me it sounds like you think that
you should always go with the backwards
compatibility which seems to be a bit
naive in my naive so that's exactly the
pushback I was talking with it's too
simple is too naive yeah so first of all
frame internment the browser's you
supporting is exactly the wrong way to
go around because you think you're not
thinking about which browsers will I
support you think about what's the core
functionality I want to make available
and then whatever browsers match that
core functionality will get it will it
support mosaic depends on how you set
that core functionality the example of
news on the web yeah mosaic will
actually be able to receive that core
functionality the example of the photo
sharing it won't because there was no
such thing as input type equals file in
mosaic now I'm not gonna add in a
fallback for mosaic because I don't
design for browsers I design for people
so instead of thinking about what are
the browser's I'm supporting and then
building for that you think about what's
the core functionally I want to make
available for browsers I don't even know
exist and yes there is absolutely a
trade-off but if you make the trade-off
early the cost of change is extremely
low if you try and take an existing site
or application and retrofit it to work
you know this way so you're providing
the core functionality yeah you're gonna
have a hard time I would say the same is
true of trying to retrofit for
accessibility or trying to retrofit for
responsiveness you're taking something
that already exists and trying to
retrofit it it's definitely tough if at
the moment you begin building you start
thinking about this stuff you make sure
it's accessible you make sure your the
core functionality at least is available
then it's really not that much hard work
I won't lie there's definitely an
additional bit of work to make that core
functionality available but again
remember I'm not talking about making
everything available to everyone I'm
talking about making a distinction
between here's the core functionality
and then from there I'm gonna all sorts
of features that you really need to have
the latest and greatest browsers to
receive now in terms of where you draw
that line between watts core
functionality and what's an enhancement
that's going to be completely different
on different projects but I would
encourage you to draw that line based on
the user needs rather than you know your
particular text set up or whatever
libraries you're comfortable working
with and all that so yeah it's where you
draw the line and it's definitely easier
to do this from the start
than to try and retrofit something
that's already out there good question
okay thank you very much sure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>