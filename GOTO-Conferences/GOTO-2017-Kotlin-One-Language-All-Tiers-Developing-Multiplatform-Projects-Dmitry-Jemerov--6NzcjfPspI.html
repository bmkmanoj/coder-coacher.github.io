<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • Kotlin - One Language, All Tiers: Developing Multiplatform Projects • Dmitry Jemerov | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • Kotlin - One Language, All Tiers: Developing Multiplatform Projects • Dmitry Jemerov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • Kotlin - One Language, All Tiers: Developing Multiplatform Projects • Dmitry Jemerov</b></h2><h5 class="post__date">2018-02-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-6NzcjfPspI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thanks for coming and
yeah so my name is Dmitry general I work
as the team leader of the cotton tools
team in the Munich office of jetbrains
and today I'm going to talk about using
cotton for developing multi-platform
projects so first of all just as a
little like just to begin with how many
of you have never seen any like any
cotton code ever ok so quite some people
well the bad news is that I will not
actually have time to do an improper
introduction to the language but in
order to follow the talk you will not
need to understand it really well so I
will not be referring trainings or tree
features I think distro all be quite
clear so what's cotton so it's a modern
programming language we started work on
the project almost exactly 70 years ago
we released the first version in
February last year and it has been
getting quite a good traction as you
probably know cotton is statically typed
the key traits that we usually highlight
when we talk about cotton is that it's
concise safe and pragmatic means that
using cotton allows you to write less
code using cotton allows you to get rid
or avoid certain classes of errors such
as null pointer exceptions and it's
pragmatics so in the sense that it comes
from the industry not from the academia
we are trying to solve real problems
experienced by real people and we hope
that the result is accessible and usable
in practice and also cotton is
interoperable so for example unlike elm
issue which the previous talk was about
we are not trying to build our own
universe where everything lives
according to our own rules instead we
try to focus into on fitting as smoothly
as possible
on today all the ecosystems that cotton
interacts with so on the Java it's the
JVM in the browser it's JavaScript like
a system on native it's the large set of
native libraries so you do not have to
get rid of all those all of those tools
and all of those
when you start using Kotlin you just
start write as much code in cotton as
you need to and keep the rest in and
used all the richness of the ecosystem
you're living with so when we start the
cotton it was purely a GVM language but
since then we have seen the potential of
supporting other platforms in cotton and
all the opportunities that we have with
that
so now cotton is a multi-platform
managed so JVM is the JVM is the first
platform that we started with I'm not
going to talk about much about it today
because there is lots of material
available elsewhere so I'm going to
focus on the other topics so JavaScript
sharing code between platforms and
content native so with the with the
current set of tools you can actually
you actually have the ability to build
multiple tiers of your application use
the same at the same language so you use
coffin on the server with the JVM and
the jar server frameworks use cotton on
Android with they're like regular
Android SDK and use constant in the
browser with cause in J's so let's start
our discussion with cotton J's so when
you use a we knew compile code into
JavaScript this process works basically
as a regular source to source for
installation similarly to how typescript
does that and how many other languages
that do that so the cotton compiler
takes caught in source code only
Cotton's to it does not able it's not
able to digest Java or Java bytecode or
anything like that just cotton sources
and it generates JavaScript source code
out of them now of course you want to
have access to all the libraries that
exist on the jaws in the JavaScript
ecosystem and you also want to access
them in a type safe way so in order to
let you do that we have actually built a
tool that takes typescript definitions
the type so type ship has a facility for
building definitions for external
libraries and there is a huge community
maintained repository of such
definitions called definitely typed we
have built a tool that takes those
definitions and produces cost and
declarations out of them and you can
link those declarations into your
program so that you can access those
libraries and finally once you have the
Java screen
you can use like any of the traditional
JavaScript tools for making use of that
code for example you can always use
webpack to package the content generated
code along with its dependencies into a
single JavaScript bundle file or you can
use any other tool that you prefer to
use so like cotton is an opinionated in
this regard so you can use whatever dude
whatever tool chain that you want to use
so what do these external declarations
look like so be so basically if you want
to access an external API from cotton
geez you write something like this so
this is a very simple definition of a
class like the window class that has a
location property and it has an alert
function or a load method so there are
no different there are no method bodies
in this class or all of this the actual
implementations are provided by the
browser and but there are types and the
types are what allows you to access
those definition in cotton in types in a
type safe way so with full support for
code completion documentation like type
checking on all of these nice features
that statically typed languages give you
yeah and the window declaration is also
like is how you get act so it's a
top-level property that gives you access
to this instance of this window class
now this is one possible way to interact
with the JavaScript world so in many
cases you do want to have this but in
other cases this does not exactly work
for example you may have a JSON API that
exposed by some by some server and you
can of course also write external
declarations specifying how to specify
what this what what is r it what's
return value of this API and how its
structured and so on but this may be
little bit cumbersome so what you can do
instead is you can rely on the dynamic
type that is supported by the cotton J's
compiler so soon as you declare a
variable of type dynamic this basically
turns off Cotton's type checker so once
you once you have such a variable you
can do anything with it you can access
any properties you can access any
methods they will also return values of
type dynamic so it like you can chain
such accesses and cotton will just
translate this directly into JavaScript
as is
so the generated code will just have
also the same code response that
messages square bracket 0 dot text if
this works you're a lot keep this
doesn't work well the compiler is not to
blame it did not verify anything just
make sure you get everything right so
like you get do not get any compile time
safety guarantees so when we talk about
developing modern web applications in
cotton you of course want to use modern
frameworks as well and probably the most
well known one of the most used
frameworks now is react and in order to
enable you to build react applications
using cotton we have built a set of
official bindings for cotton so
basically it's some kind of something
what the TS 2kt tool would could
generate for you but it's like more more
polished more maintained and just in
general works better and you can use
that you can use that to build react
applications using cotton JS and to make
it easier to get started with we have
also built a CLI tool that generates
such an application for you so you can
install three NPM and then essentially
just run this one command to generate
the application and it sets everything
up it sets the necessary dependencies it
creates an intelligent that you can open
in the IDE right away it sets up
debugging by our source maps it sets up
hot reloading so basically all the
goodness is you need to be productive
when working with such an application
and also we have also built a plugin for
Gradle that lets that provides the
integration of that essentially provides
a bridge within the content world and
the JavaScript roles so you can still
use Gradle for or building your content
project and actually this is the build
system that you have to use if you build
multi-platform projects using cotton and
the cotton fronting plugin builds a
bridge between that and the JavaScript
ecosystem meaning that you have that you
can have dependencies on NPM libraries
it will automatically download Nodin and
vm for you so that you just don't need
to pollute your computer with this
javascript ugliness if you don't like
this like as i don't it will just do all
of this stuff it will run web pack for
you it will let you run
using karma which is a JavaScript test
framework and it also supports hot
reloading of changes to be just as soon
is just what they make some changes in
the editor it will just automatically
recompile and reload the browser window
so that's a brief look at what we can do
for JavaScript but actually just
targeting JavaScript is not the
interesting part of cotton so what I
have told so far it's comparable to what
other languages like typescript can
deliver you but it's not significantly
better so if you just want to develop
purely a purely browser-based
application and cousin is a nice choice
but it's not like the full strength of
what it can offer the full strength
comes with the ability of sharing code
between your front end and your back end
so essentially when you share code you
get a product that has models of
multiple types so you have the common of
essentially two different types so you
have a common modules which contain code
that is not specific to any platform
that would be the shared business logic
of your application and you have
platform modules which run on a specific
platform so either on the GBM or
javascript or potentially native so
native is not supported yet by the
system but it will be supported in the
near future so a very important point
here is that we do not want to have this
right once anywhere right run anywhere a
deal so you run your code so you do not
write your code just in the comment part
you have full x the iran only the shared
business logic as common code and for
the platform specific parts you use the
full benefits full advantages of each
platform by writing a comm by writing
dedicated implementations using the
native platform api s so we are not
going to provide you with a big facade
that abstracts away all of the
differences of this but these platforms
because this would also like destroy all
the unique advantages of each platform
instead we provide you a tool that
allows you to easily write platform
specific implementations and access them
from the common code and I will tell you
how exactly this works
so what how does the compilation process
work for such a mix project so we have
some common code and we have jb on
specific code and we have JavaScript
specific code now what do we do when we
try to compile the common code
the answer is we we cannot really
compile it by itself because there's no
like real destination to it we cannot it
compile it to JavaScript platform does
not know anything about java classes we
cannot compile it to GS because we can
cannot do anything with Jas on the JVM
so in order to compile such a model you
take it you need to combine it with a
specific platform implementation so if
you take the common code together with a
JVM code you can compile the resulting
combination to a bunch of class files on
the JVM if you take common code with the
JavaScript specific part you can compile
them to a bunch of JavaScript files and
then like those combinations you can run
them on each platform as you need now
can you actually refer to platform
specific declarations from common code
and how can you do that the answer is of
course you can and the way you do that
is that the common code can specify that
it expects certain declarations to be
provided by the given by each platform
which is supported by this module so in
this case I'm saying that in my common
code I expect that there must be a date
class provided by the platform and those
are the members that I expect it to have
so in this case I'm having I'm expecting
to have this get full year method and
there is probably a bunch of other
methods to get access other components
of the date and on each specific
platform I provide an actual
implementation so in this case this so
this is the JVM implementation and is in
this GBM implementation I have built an
implementation of this class based on
the calendar class which is part of the
Java JDK and this is a JavaScript
implementation and this is completely
different because on the Java player on
JavaScript there is a date class
provided by the browser runtime and I
can actually refer to it as my
implementation so I can say that the
actual date class on Java platform is
external
is provide it is provided by the
platform and I also specified it yes and
by the way it has all those methods that
are expected to be there and the way the
compiler matches expected and actual
declarations is essentially by qualified
names so they expect and actual
declarations have to have the same
quality the same package or in other
words the same qualified name so the
common code expects a class from with a
qualified name of course and of data
date to be there and if the platform
module provides this class provides an
actual implementation for it and of
course you can also write common code
that refers to these expected classes so
this is just the simple function from a
common module that just accesses these
date class and does some logical name to
check two days are on the same day now
so this expects and actual stuff it
looks kind of like interfaces but not
exactly so why did we come up with our
own thing for this and why did not we
just use interfaces the answer to that
is this mechanism of expected and actual
declarations are is actually is much
more flexible so interfaces are
essentially restricted to class members
so you need to somehow obtain the
instance of a class in order to that you
need to have a factory in order to
obtain the instance of the factory in
your dependency injection and this gets
complicated fairly quickly with our
mechanism there is no such restriction
so you can basically say that you expect
a class and you're also expected in this
class to have a constructor and once you
do that you can simply create a new
instance of a date from common code
without bothering with any factories any
dependency injection just go ahead and
create like new up an instance and also
you can expect top-level functions or
extension functions to be there
so in Causton we we are not really keen
on packaging everything into classes we
use top-level functions a lot and we
also use the extension functions a lot
which allow you to define your own
methods on on classes that are defined
somewhere else and so this multi
platform project mechanism it integrates
very nicely with the with all those
features so an expect declaration can be
anything it can be a class it can be an
interface actually which is not very
useful but you
do that for some reason it can be a
top-level function or it can be an
extension function and one other
advantage that this gives us is that it
gives us the ability to reuse existing
Java implementations very easily so for
example like look at this testing
annotation so we expect so there is this
annotation class test we expect it to be
provided by the platform and on the GBM
we happen to have an annotation that has
exactly the same name exactly the same
semantics but it just lives in a
different package so we can simply say
that the actual implementation of the
test named test of the test annotation
on the JVM is ordered you need the test
annotation you don't have to
re-implement anything you don't have to
repeat anything you just say ok so the
actual implementation of this expected
type is this actually the actual class
and this would also not work for
interfaces because there is no way we
can make an existing class providing it
for coming from a third-party library
implement some interface that we have
defined this is simply not supported so
like once this is one more way in which
the expect actual mechanism is more
powerful than interfaces so how do you
build this thing so as I mentioned this
supported this is only supported using
Gradle and we have special plugins that
you need to hook into a common module
and into platform specific modules and
also you in a common module you can
depend on you can depend on common
libraries because it would be just not
very useful if you had to write all this
code from scratch and or just provide
expected finishes for all the api's that
you wanted to use so of course there are
common libraries and we support them and
like this is for example how you specify
dependence on the cotton standard
lighter on the common version of the
cotton standard library on the platform
for the platform module you do a very
similar thing so there is a separate
plugin for compiling a platform specific
part and you of course can specify like
any any dependencies like on the Java
libraries or on common or you can
specify it depends on Java libraries and
we also have this special expected by
dependency and this is how the link
between a common module and a platform
specific part is created
so for every common module like all the
platform modules that implement a that
provide actual implementation for this
expected repairs have to have this
expected by dependency in the build or
Gradle but how do we actually compile
the common library so I mentioned that
like when you compile a comma in
application you cannot just build a
common code by itself because there is
like no code no way to represent the
code for it but for a library we do want
to have some kind of common
representation so what do we do the
answer is that is that when we compile a
common module which is a part of a
library which we produce these metadata
files which essentially is a sterilised
format of the declarations available in
the library so it does not contain any
implementation code in any format you
just specify basically the signatures of
everything that is available in the
library and then when you compile the
same library for a specific platform we
produce specific implementations in the
normal formats like this would be a jar
file for for Java to JavaScript we can't
also produce jar files which contain
JavaScript files JavaScript source code
and additional metadata that allows the
cousin compiler to make sense of them so
basically yeah each time you build a
common library it produces multiple
artifacts so there is one common
artifact that you reference from a
common module and there are platform
specific artifacts that you reference
from each platform so what libraries are
there actually other than the standard
library and what functional what
features can you rely on in your multi
platform code so yeah
so the first thing is of course the
cotton standard library so what does it
contain it contains like the most basic
facilities that you need in every in
every project so it has strings it has
collections it has like utility high
order functions like width and apply it
support it has a hierarchy of exceptions
which Mesa Kaleem mirrors the hierarchy
of exceptions defined in a JDK it
essentially gives you the essential
tools without which you cannot really
build much in cotton at all but is that
all know if where there's of course many
other libraries which are available as
common once so you may have already
guessed that for for the common code we
also provide the ability to run tests
and this is provided by the special
cotton dot test library and it looks
almost exactly like g-unit because as
you have as I have shown you the actual
implementation of all these annotations
is provided by g-unit when you run on a
GVM and on JavaScript on an end or
native we have custom implementations of
course in essentially there is nothing
fancy here there are annotation there
are certain methods and so you can just
basically write tests for your common
code and you can run those tests under
the JVM to make sure that your code runs
correctly on the JVM and you can run
them under JavaScript to make sure that
your code runs correctly in JavaScript I
will show you later in the demo how this
looks in practice one other library that
is available in as a common library is
cotton X dot HTML and what it allows you
to do it allows you to build HTML pages
using a cotton DSL so instead of writing
just tags and attributes and content
directly using the HTML syntax you can
use cotton strongly typed methods to do
that and of course one of the benefits
of this is that you can you get better
code completion maybe you can get you
get compile time checking to make sure
that you get your like tag names
correctly but in fact this is not that
significant the main reason why this is
a good thing is something else the good
reason is that you can very easily
refactor this code and you can very
easily create abstractions
so you do not need to come up with fancy
mechanisms in your templating language
to do conditions and loops and includes
and macros and substitutions and all of
that because cotton already provides all
these features it has loops it has
conditions it has classes that you can
inherit from it has functions that you
can call with default parameter values
and in this case so between these two
slides I have just extracted a bunch of
functionality in the method this is a
very natural thing to do it can be done
like very easily and by doing that you
can very easily compose parts of
templates in a very maintainable way
which is somewhat better than you can do
with like regular templates and because
this is a common library you can use
this both on the client s and on the
server so you can if in effect you can
do isomorphic rendering so you can
render the same UI of your application
both on the server and on the client and
the demo project I will get to in a few
minutes will show exactly how this works
in a like in a running application but
before I get to that I want to mention
one more library which is caught in
Xcode serialization so if you have
shared code if you have shared like JD
model classes which you want to use both
on the client and on the server then of
course you want to pass instances of the
classes between the client and the
server so that you can just expose the
rest api that includes those classes in
json and access to the rest api from
your browser so that it can do take
those classes and root out something
with them on the browser and the cotton
dot cotton X dot 0 Zhejiang library
provides you exactly that and it's
actually very simple to use so in the
most basic cases it's as simple as
putting the add serializable annotation
on all the classes that you want to pass
in in between the server and the client
and the library takes care of all the
rest the library is actually implemented
the library includes a plug-in to the
Kotton compiler so it does not rely on
reflection in order to understand like
watch what fields are in each class and
how do you actually serialize them and
in so this provides much better
performance and this actually lets the
library run on the JavaScript where we
don't currently have full support for
reflection
for data format to support decent it
supports brought about if you want
something binary and it supports
something else and you can also extend
it of course to support your own data
serialization formats and building a
larger array of common libraries is one
of the main focus areas of the kasnian
team right now so we want to have some
cross-platform ways to do i oh we want
to cross paths want you to write a GTP
clients and a cross-platform way and
also like socket networking like web
sockets on the browser regular sockets
on the client we want to have we want to
have a real common library for dates and
not this like care together started I'm
showing in my demo and of course much
more and we also expect the community to
build many other common libraries for
the tasks that are important to them so
with that said proceed to a demo so
first of all let me run the application
it will not be very fancy but what it
does is actually like how does the thing
that it does is actually much more
interesting than what exactly it does so
I'm running this application it wants to
start it up some kind of a server and
you see that so basically just render
some random messages so there is not
much value in this specific content
shown there but the interesting part is
what we see if if you press view source
so basically you see here that this has
just five messages so the first five
messages you see on the page were
rendered by the server one is sent the
page and the rest of the messages were
rendered on the client by JavaScript
code and now let's look at the
implementation of this so I will switch
to mind energy back and we'll look at
the project so you will see that this
project contains a bunch of modules so
there is this common module called
shared which has the platter which has
also platinum specific parts the GS and
the JVM specific part and there are also
separate modules that contain the
back-end specific and the front-end
specific code so if we look at the build
of Gradle for the common module that you
see that it has a dependency on it has
this common
Gradle plugin
and it also reference is a bunch of
common libraries which are basically the
ones that I will just mentioned so there
a standard library they've got an XHTML
serialization and cotton to test and if
you look at the bills or greater for a
platform module then it also has like
the stuff that you expect this Gradle
plugin applied the budget depends on
Angela's JVM specific libraries
including g-unit which of course is the
Java library and this expected by
dependencies that links it to the shared
project so what code will be actually
having this project so first of all we
have here this very date class that I
was showing in my slides so this is so
this is expected to be provided by the
platform it is expected to have a
construction it is expected to have a
bunch of methods and there are also a
bunch of expected top-level functions
like parsing and converting days to
strings and it has two actual
implementations one for the JVM and one
for JavaScript and this is basically all
the stuff that I have that I showed you
on the slides so the actual
implementation for the JVM is provided
is implemented using Java dot util dot
calendar enjoy the text dot simple date
format and the one for Java Script is
implemented on top of the date class
provided by the browser so the next
thing that I'm going to show is this
message class so this is essentially the
data model of our system so this is a
very trivial example so the data model
is as simple as it can be so it just has
a text author and date and once again
this is common code and also in the
common code I have the function that I'm
using to serialize and deserialize date
instances as the message instances so
I'm have this to Jason and from jason
methods and they use the jason class
from the Cotten's dot X dot
serialization library in order to
essentially to convert instances to
strings
and to parse them from strings and I'm
also really registering custom
serializer for the date class because
the serialization framework does not do
anything it does not know anything about
dates so I'm just specifying myself how
I want them to be represented in JSON
and the last father
I want to show here is this one this is
how we actually render messages to HTML
so this uses the cotton X dot HTML
library and I'm using this DSL so it's
very simple I'm ready I'm creating a div
I'm putting up appending the text of the
message so this Plus this funny plus
character essentially means append to
the output it's likely overloaded unary
plus operator and I'm creating an italic
tag that contains also some other
content by the way here I'm referencing
once again I'm a reference a common
function that has multiple expected
implementations and if I do find usages
on that I will see that this function is
used both by the server and by the
client so on the server when I just may
not just render the initial page I just
generate five random messages and render
them as part of the HTML page and on the
client I'm invoking the rest API to get
some more messages I deserialize the
response and I append them to the Dom so
this is once again this is isomorphic
rendering so I'm using exactly the same
code on the server and on the client end
if I had a larger application I could
render the entire UI of my application
both on the server on and on the client
using exactly the same code so a couple
other things that I wanted to show so of
course the idea provides a bunch of
assistance for dealing with this expect
actual stuff so for example if I create
and expect function the ID highlights
that it does not I have not provided any
actual implementations and it helpfully
suggests me to create some so on the JVM
I will do system dot out just to make
sure that time on the JVM because you
can just do println director on cotton
and this works on any platform and on
the JavaScript
I'm going to do console dot log and of
course the refactoring is take care of
this as well so I can rename this too
I can rename this this will update the
actual implementations I can add a
parameter to it using the change
signature refactoring and the actual
implementations will have been updated
too so now they both have the string
parameter Y and one other thing that I
wanted to show is running tests for the
common code so even here in this shared
module once again this is common code I
have this date test class and you have
seen it on the size of basically so this
is using the Scotland dot test framework
and if I right click this if I select
the run option in the ID I will get
actually two possibilities how I can run
this I can either run this as a mocha
test or I can run it as a g-unit test so
let's try mocha first so as you can see
now he has started note for me and
started this more code Josue test
framework and did a bunch of JavaScript
is tough and in the result I get a
successful test now let me delete this
run configuration I unfortunately have
to do this for the time being because of
issues and now I'm going to run this
again but run this again run this again
and it runs on the g-unit the same test
so pretty cool right
okay so that's multi-platform projects
basically so that's the that's what you
can do to share your code and your
business logic between JavaScript and
the JVM and one other thing and of
course if you looked at the picture that
I was showing pre that I showed
previously with the JavaScript JVM and
Android this is of course not all the
tears of an application that you might
want to build there is one other one
which is called iOS and the great news
is that like whereas we announced very
recently so we we actually made the
initial announcement on cotton con 2
weeks ago in San Francisco across the
native now supports development for iOS
as well and so the way it works is that
we have actually built an LLVM based
tool chain that takes cotton code and
produces native binaries out of that so
so in order to build the iOS app out of
that you still need to have Xcode
installed which takes care of all the
packaging signing and all the funky
stuff that you need to do to get rapid
to App Store but at least for the
initial compilation process we are using
basically the same tool chain that Apple
does so we produce a fully native fully
normal iOS application no GC no JIT no
Dinah no JVM inside it so just basically
a regular native application that is
justice looks exactly like and one that
you can build with Swift and of course
in this application you have all access
to the libraries available in the
platform so you can access core
libraries written in objective-c you can
access just regular C libraries you can
access cotton libraries so just
everything that everything that you need
is available for you and the way this
works is that we have built a special
tool that generates got a metadata from
C header files so essentially what you
do is you feed the header files for your
library to this to it is based on the
sceneline front-end so it just like
shall real c parsing so no regular
expressions no like pet no just fuzzy
pet imagine like the reals
it supports all sea types like in
including that complicated ones like
callbacks to functions that you have to
pass to AC function or structs basically
everything you need
it supports Objective C types because
that's what you need for Objective C
Interop and it spits out a metadata file
with cotton-based basically what cotton
needs to be able to call these functions
to know how to call these functions from
cotton code and using these two we
essentially generate headers for all of
the platform libraries so for example
this is this is what the dependencies of
our demo app look like so you see that
all the regular iOS frameworks are
there's like app kit core data
essentially everything these are
objective-c frames and you have full
access to them from constant code and
this is just in a code example showing
how such an axis looks like so this is a
part of the code from our demo app that
shows the game center in on an iPhone so
once again you don't need to be able to
understand exactly what's happening here
oh I don't understand it myself
but the key thing is that you have full
access to the platform API is written in
objective-c so what about memory
management this is like one of the most
common questions we get when talking
about this stuff so for this time so I
answer to this is like very preliminary
so this is still like version 0.4 and a
lot of things are going to change before
the final release and one of them is the
memory management so for now we have a
reference counting plus cycle collector
the reference counting works rather
efficiently because we don't support
memory shared between threads so we can
we don't need to bother about atomically
updating the reference counters it just
is like there's no memory contention
involved when we do that but once again
maybe we will end up with the tracing GC
maybe we will end up with something
different maybe we will end up with
different solutions on different
platforms this is all still being
designed and of course Casa native is
not just about iOS so we support the we
support just as well Linux and Windows
and Mac and if you have been to been and
that the other guys sorry forgot the
name talk
yeah and rest yeah then Andreas's talked
earlier today about webassembly we have
just announced the cotton can be
compiled to webassembly as well and in
the future we are going to explore
embedded platforms and to provide a
complete tool chain for developing
embedded applications using cotton
cotton native we already support like
some parts required for it so we support
like dinners runner maps for example but
there is much more work to do before we
get to a complete solution as for the
tooling for cotton native we have
recently announced the plugin for sea
lion which is our ID for c and c++ it
has sent it is essentially a customized
version of the regular cotton plugin so
it supports all the features like
refactorings code inspections all of
that is there and its supports like
platform specific debugger and the
platform specific test run and I do not
have time for a complete demo button so
I will just show you a couple of
screenshots so this is native code under
a debugger you see the call stack you
see the variables you can see even the
variable values directly in the debugger
like even a regular Nintendo G and under
the hood this is powered by ll DB so you
can also use a lot EB command line if
you like that this works also for common
coordination code and this is just the
test runner results so showing the
result of running some native tests use
not the same content or test framework
as I will shows previously so that's
what I wanted to talk about it about D
so to summarize our goal is to allow you
to all right all parts of your
application in the same language Android
iOS back and front end if any other
platform comes up we will support that
as well
this basically anything we want to be we
want cousin to really be available
anywhere and with full access to the all
the bests that each platform has to
offer so platform specific API is
platform specific like application
structure features we you will have full
access to it and this means that we do
not do not want to abstract away the
differences between every platform you
will still have access to the full API
which platform when you run this and the
and the shared code will only be the
business logic of your application which
does not inherently depend on the
platform and we have already released
the solution for using the code for
between the JVM and JavaScript and
native will plug into the same system
soon so this is all being very actively
worked on so I'm just talking about the
state of things as they are today so if
you want to learn more about coughing
the official website is caught in that
line across the name dot org there's a
blog where we publish a lot of our
announcements and talk about the new
cool stuff that we are building we have
a slack with a very friendly community
so you can go and ask questions there
and people from the team will are there
to answer you and there's also a book
written by me and my colleague that
basically gives you an introduction into
a course in the cotton language it does
not talk about any of this stuff because
this was all developed after the book
came out but just as a just ways the way
to get started with cotton is just an
excellent way to get to know the basics
so thank you and let's get to procedure
questions
yeah thanks a lot
we've got about 10 minutes and we got a
lot of questions so let's start with a
very simple one
what does Scotland stand for cotton is
an island near st. Petersburg where the
Kronstadt city is located and so we just
saw many languages named after islands
like Java and Ceylon and decided that we
decided that okay we'll have a not an
island of our own so why don't we name
the language after it and Stockland as
an island yeah
can you use dynamic types in the common
code no you cannot use dynamic types in
the common code this is just a
JavaScript feature like it's
theoretically possible to support it but
we just don't have enough use cases for
that could
Coughlin's GS be used to write
server-side JavaScript code that runs on
no GS yes you can use a cotton JS to run
write code that runs on a node.js but if
you are writing in cotton any weighted
then you might as well use a proper
runtime which is a junior does it
support maven instead of Gradle
thank you mention nope I'm not sure so
cotton has the whole supports maven
definitely specifically the multi
platform projects are on only Gradle for
now but we will support me even later as
well so there is no please
no big difficulties just something that
we haven't done yet okay then a bit
longer question your hello go to bear
example gives different behavior between
JVM and Jas different print outputs how
do you how do we ensure that
implementations of a common libraries
then stay identical do we write
extension tests for that yeah excellent
adventure if you want to be here to be
identical then yes you write tests in
many cases you actually do not want the
behavior to be identical you want it to
be appropriate to the platform that you
are running on but yet the common test
facility exists exactly so that you can
do exactly that right test verifying the
compliance of the to be two different
implementations
then something about the iOS stuff well
first of all a question that I had in
mind you're only talking about
objective-c
what about Swift libraries we at this
time we do not yet support Swift Interop
we are working on that it will be as
supported in the future but it's not
there at this moment and then the
question here was would it be possible
to write a library in Kotlin that could
be used from Swift yes it's also
something that we are working on right
now okay and the same more or less the
same question whether there are any
plans for C++ library compatibility with
Scotland native I so as far as I
understand there are some ABI
differences so you can not directly call
a cotton library from C++ but I think
that this it is something that can be
straightened out later so there is no
principal the principal reason why this
is not imported not possible this is
something simply not done yet so this is
just once again this is all very much
preview and actively developed yeah
which would lead to the next question
it's a very strong story already but
when would you expect the first real
applications that are developed and
across way like you showed it to yeah
start to begin or to develop this is a
really good question I would expect like
I don't know early next year maybe there
is still quite a few missing pieces this
is a very rough experience as like if
you get into diary and I did not show
any demos because this it's just
difficult to find the narrow path where
everything is working so but once again
this will improve very rapidly okay the
other questions I think have been
answered during the talk any questions
from the audience right now just raise
your hand I come to you oh that's right
any dependence on the cotton version is
it cotton 1.2 based or so the
multi-platform stuff is available in
cotton 1.2 the native stuff kind of
lives on itself so it has its potent
native has its own release cycle it's
not yet plugged into the main it's like
kind of a separate project but like
cotton it cotton native 0.4 includes
cotton in 1.2 so you can have all the
same features there basically any other
questions I'll be around at the
exhibitor reception so you can just find
me and chat with me I can ask to just
talk about anything costing related or
JetBrains related if you just if you're
curious about started we are doing oh I
would have one I just heard some that
the cotton native stuff is supported in
sea lion
yep will it also be possible to use it
in the Ultimate Edition maybe so this we
had a lot of internal discussions on
that there is no final decision yet yeah
would be great yeah okay thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>