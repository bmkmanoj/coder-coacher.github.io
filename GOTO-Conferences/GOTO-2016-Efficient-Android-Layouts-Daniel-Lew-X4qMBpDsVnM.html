<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Efficient Android Layouts • Daniel Lew | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Efficient Android Layouts • Daniel Lew - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Efficient Android Layouts • Daniel Lew</b></h2><h5 class="post__date">2016-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/X4qMBpDsVnM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone
okay cool the mics working so yes
welcome to this talk about efficient
Android layouts if you've never met me
before I've been doing Android developer
about seven years first a travel app
company then Expedia and then currently
at Trello as per usual my thing doesn't
work all right I mean my presentation
over here you know you can click to
engage to rate sessions and ask
questions of which I would publicly
answer the questions at the end if you
ask them anyway so this is about let's
talk about efficient Android layouts and
when I was writing it what I found that
I was really interested in wasn't so
much so the efficiency in terms of
performance but the efficiency in terms
of leverage that you have as a developer
and so I started thinking about it in
the way that Archimedes was referring to
like how fulcrums work where like if you
just give him a proper place to stand he
can move the earth and so that's sort of
the focus of this talk is like how to
get the most leverage as a developer
because a lot of Android teams are
fairly small and you're asked to do a
lot of things and so in my case would be
if you give me a standing desk I will
write you an Android app and I hope that
you're not expecting me to make any more
terrible jokes this entire time so won't
happen so this is really just kind of a
mishmash of things there's no narrative
so I'm just trying to cover up the fact
I have no transition here let's talk
about view groups in particular picking
view groups which view group are you
gonna use for any particular layout and
I think the main thing is that the
simpler simpler you view group you can
get away with generally the better
because the more complex ones require a
lot more maintenance and you can run
into a lot more bugs and so on the like
higher end of things I'd say probably
relative layouts one of the most complex
constraint layout is yet to be seen but
it looks like it's probably going to be
more complex in relative layout when
it's finally done somewhere in the
middle of there is linear layout and
then down there at the bottom is frame
layout which is one of my favorites
because it's so simple
and there's a lot of other views
in-between but these are the main
building blocks for most applications so
relatively and constraint layout they
sort of occupy the same space and
Android right now which is that Bay
position views relative to each other
and relativelayout sort of limited in
this regard but it's what we've had
since the beginning where it's
constraint layout is new and can do like
all these amazing things but there's
some key problems with both of them
besides the fact they're fairly complex
one is that relative layout is fairly
slow and then the issue with constraint
layout is that it's fairly alpha ish at
the moment they haven't officially
released it yet so there's there's alpha
build out on maven central but you know
a few times they've completely changed
the API around so it's not necessarily a
PR production ready I mean you could
play around with it now and you can use
it if you want but you're gonna end up
with some of that cutting-edge problems
that you end but you end up when you're
trying new experimental technology
linear layout is great you know
stacking views vertically and
horizontally you can distribute the
weight so this is a simple view or like
the view the rows are stacked vertically
and then also I distributed the weight
between those two spinners equally I'm
actually fairly ok with nested linear
layouts as an opposition to relative
layout and actually last time I told
someone this this was like by far the
biggest question that I got is everyone
coming to me later saying but I love my
relative layouts that's all I use I was
told then that nested linear layouts are
the worst things in existence and so I
can't believe that you just said that so
to head off that question that I was
going to be getting on the sessions
thing is that linear layouts are
sometimes slow so if you use layout
weight and you nest them pretty deep
then they can get pretty slow but that's
only a sometimes thing whereas by
opposition relative layout always has to
do two passes it's always slow so the
hope the hope is that eventually
constraint layout will be our Savior and
like save us from the situation of like
having to decide between the two of them
but in the meantime I think really
what's most important is just to focus
on profiling so whatever layout that you
do end up with just like turn on profile
GPU rendering and see if things are
running fast enough on whatever test
device that you're using hopefully like
a really slow one and if you've never
used profile GPU rendering I highly
recommend googling that and looking into
that cuz then you get these nice bars
that show you whether or not you're
hitting 60 frames a second and what sort
of things are spending too much time on
if you don't but really I've talked
about all of that so I can talk about
frame layout which is my favorite layout
in the world because it's so incredibly
simple
all I can do is position things based on
the parent bounds so that is you can
position things inside the center of the
frame layout or you can position things
on one of the nine cardinal direction
wait
nine eight cardinal directions of the
frame layout wait am I getting that
right yeah eight um so but there's a lot
you can do with this it turns out that a
lot of layouts if you just want to have
like say a simple progress bar in the
center of some some large screen like
that's a frame layout you don't need to
do anything complicated with relative
layout or or what-have-you
it's also really great for as a simple
layout for overlapping views so if you
need two views to be on top of each
other frame layout it's a great
container for that it's also good for
things like clickable item backgrounds
so if you have some image that takes up
a very small amount of space but you
want to have a nice or like multiple
views that compose a single thing that
you click it's good to have like a frame
layout as a parent to that that can
actually have like the click detection
so when you click on it it actually
looks like something's happening so a
good example of this like in the trail
application is the notification bar up
in the upper right corner so this is
always present on the screen it's a
single frame layout and there's an icon
inside of it that white icon is always
present and then if you have unread
messages it'll it'll put that little red
thing on top of it and so the white icon
centered and the red icon is actually
pegged to the upper right corner but
then you can use some margin in order to
push it in so it doesn't just like Ram
up against the sides and then on top of
all of that I can just have these views
be very simply positioned and then path
a clickable item background behind that
so when you actually click on it
something happens another thing I like
using frame layouts for is what I'm
calling toggle containers so if you have
two different states that you toggle
between sometimes it's sometimes you
just have a single view that you
actually change sometimes I found it
more handy to have like multiple views
that you switch between and so frame
layouts a good way to like contain two
things in exactly the same spot and then
toggle between them so a good example of
that and the Android app in the Trello
app is the avatar view so this is
whenever you represent a member of a
card or something like that you can if
the user has their avatar set then we
want to show that if they've never taken
a picture then we want to show their
initials and so it's essentially
choosing between an image view or a text
view
little fancier versions of which that
allow you to draw to render a circle but
basically lets you toggle between these
two so the avatar of you brings up the
next thing i want to talk about which is
view reuse we we use this avatar view
all over the application so these are
just three screens like the Trello board
a trouble open trouble card like some
activity on the side and there's like
actually I think three or four other
locations we use an avatar view within
the application and so the question
becomes how do I reuse this in multiple
places without having to rewrite the
code everywhere because that would be
kind of dumb so the most obvious way is
to use something called and include so
if you never seen it before the include
tag allows you to point to a direct
layout and then it's as if that layout
was just copy and pasted into the code
right there and you can't modify much of
what you're including but you can modify
any of the layout params so that's any
other things that starts with the layout
underscore so that's a nice way to be
able include something that may have
been matched parent but you don't quite
want it to be in the end but the problem
here is that okay you get the XML in
every single location but you don't get
any of the logic so now I have to come
up with some way to then apply like find
these particular views that were in the
include and then add the logic for
actually binding that to the view so
what I actually prefer these days is
using a custom view and so with a custom
view I call instead of include I
actually just have the view reference
directly and then you need to write the
actual custom view itself but it's not
very hard because this isn't a custom
view that's like doing custom drawing
right like that it's just taking the
place of what would have been in that
include and so with this custom avatar
view I'm extending frame layout so I'm
saying that the topmost going to be a
frame layout remember I'm toggling
between the two states I've got an image
view in a text view and then inside of
the constructor itself it actually
inflates all the views that are
underneath it so I don't need to
as a parent using Avatar view I don't
have to worry about what's inside of it
it's handling all that for me and then I
can have this one nice bind method where
I take my member object and figure out
whether I should be loading an icon or
loading via the text so this makes my
life a lot easier one thing worth noting
though if you're using this sort of like
custom view setup this
this is like a very hand wavy version of
like what would be the included XML but
if you include the XML like this you end
up with a view hierarchy that looks like
this you end up with an avatar view on
the top that's a frame layout and then
it inflates another frame layout which
then has the text view an image view so
obviously like this middle frame layout
is pointless we don't really need it the
lint check in Android is particularly
harsh when you when you do this
something like has no reason to live or
something like that has no reason to
exist so we want to get rid of that and
the way that we do that is through a
layout inflate or trick which is
normally when you're using layout
inflator everywhere you'll see it
there'll be a third parameter there and
it will be false and that's because most
of the time that's what you want but in
this one particular case you want it to
be true which happens to be the default
and when it's true what happens is that
the the XML that's inflated tries to
attach itself to the view group that you
passed in as the second parameter in
this case it's this and then in the XML
if you use something called the merge
tag instead of a frame layout what
happens is it tries to then merge these
views into the parent view group without
any interstitial frame layout and so
they end up with a hierarchy that you
actually want no unnecessary frame
layouts involved a third view specific
piece of advice I had to do is with
custom drawing so this is useful in
cases of particularly complex views you
can save a lot of time but it's drawing
yourself instead of trying to figure out
how to like wedge these views into what
is the what you want it to look like
into normal views so a good example of
this in the Trello app is the label so
there's these green and blue and red and
yellow and purple labels that are on
these cards so when we first had the
Trello app out there was like six colors
and that was it that was the most you
could apply to any card and whoever was
working on it back in the day did not
know about custom drawing and decided
that those would just be six views so
that meant that every single card could
potentially have six views inflated but
then later on the Trello changed such
that it allowed like any number of
labels to be drawn so you can end up
with this like nightmare scenario where
every single card could have like dozens
of label
on them if someone is going really crazy
and then we were talking about recycling
those views it just gets really slow and
if you talk about putting something like
this on a tablet it gets really really
slow because you can see even more cards
and it's rendering even more views so it
was much simpler than to the does this
take all of those views that were being
rendered and instead have one custom
view that draws like really simple
shapes so there's sort of two steps to
it and custom views used to be very
intimidating to me I used to be very
scared of custom views because I thought
they looked really hard but they really
are not and the first step is just
telling the custom view how big it
should be that is how much space is it
need to take up because I have my label
view which is really nice but no one
knows exactly how much space is going to
take up so onmeasure is what you're used
to tell any parent view group how much
space you need it turns out a lot of the
times you can actually skip this whole
step entirely and the reason I say that
is because in any view you can specify I
you know I want this view to be 48 DP by
48 DP if it turns out that your custom
view is just always going to be the same
size like skip this entirely just to
find it in your XML and you don't have
to worry about that in this particular
case because the size varies based on
the number of labels I had to write my
own measure and so a quick hint a quick
way of going through one measure that's
the message signature that gets called
you have these width measure spec and
height measure spec which was sort of
confusing to me at first but it turns
out that these are just packed integers
so it's a single integer that these two
parameters basically take the place of
four parameters which is that a with
mode in size and a height mode in size
so the size is just a dimension value
the mode though is telling you how how
it wants you to handle that particular
size that it passed and there's three
different measure specs for the mode one
is exactly which means the parent view
group wants you to be this exact size
the other is at most so it take up as
much space as possible
and undefined means you could define
whatever I deal with you would like in
this situation and so your typical
onmeasure looks something like this
where you grab and this is just for the
width then you would copy the same code
for the height you'd grab the mode in
the size if the measure spec
is exactly you probably want to just
pack the pass back the size that it gave
you you don't want to lie to the view
you don't want to like screw up the
parent view group too much or else it
might get confused otherwise you know
calculate what your desired width is and
if the wit spec is at most then make
sure that whatever your desired width is
not larger than that size otherwise if
it's undefined
you just get to pitch pick whatever
desired width you want then once you've
done this for both the width and the
height you are by contract required to
call set measure dimension in order to
tell the view what you've decided for
the for the width and height because
there's no return value on for on
measure you just actually have to call
this method at the end so that's
measuring how big the view is and the
second is on draw and this one is pretty
simple it just gives you a canvas and
you draw and so I'm gonna leave this up
to you because what am I gonna say about
canvas this is not a talk about how to
use canvas another thing worth
considering is maybe in some cases you
don't actually need a custom view you
could just write your own custom
drawable and the advantage here is that
then you could take this custom written
code and like apply it to any different
view so that's good if you like want
some special custom background of sorts
in that case onmeasure just becomes
something like get intrinsic height and
get intrinsic width on a drawable and
then on draw becomes draw but again Mike
I don't want to spend too much time on
this you can research more about it
later I highly recommend zero muddy I
gave a talk about cost about a Android
drawables a few years ago and I highly
recommend that talk if you want to learn
more about that later and I'll be
posting these slides too if you want to
get the links
alright Stiles let's move away from
views
well not that far from views but talk
about kind of another layer above views
which is styles so if you if you are
applying XML to a view this view has no
style
not because it's uncool but because
there is no style tag on it and then if
you have a style all it does is I'm
creating some style resource which has
the same attribute inside of it and then
the view itself then applies that style
on top of whatever actually well
actually the Styles applied first and
then then whatever other attributes are
applied on top of it but essentially
then in the same way that includes are
taking XML layout XML and just stuff it
stuffing it into a view group
Styles basically take a bunch of
attributes and stuff it into a view and
so where is this useful it's very
efficient when you need to style a bunch
of some what I call semantically
identical views the same way and so what
I mean by semantically identical is that
each view does exactly the same thing in
your hierarchy so a good example of this
is a calculator because in a calculator
you want all these buttons or at least
like you know the main number ones to
look the same another way to put it is
that all the styled views should change
at once so whenever you want to change
something so if I want to change the
text size of one of those buttons my
expectation is that all of them change
at once so that saves me a whole bundle
of time I see a lot of people though
myself in the past especially misusing
styles in very inefficient ways ways
that end up biting you in the long run
and one way is single use styles so that
is you have a view that's referencing a
style and that style is only used once
um I feel like that's just extra work
that didn't need to be there some people
really like separating all this code out
but like it's so easy to refactor later
and create a style there's even a
refactoring option in Android studio
that lets you do this
so not really necessary but more
importantly is where you have two views
that are coincidentally using the same
attributes so I've got these two text
views and I say oh look they're using
the same text color and text scalar hand
great I'll use a style here but if you
look at the IDS you can tell that these
two means something very different to
each other one supposed to be a title
and one's the body and so what happens
is suppose later on I decide oh I want
the title to be like a different color
well if I change the color of the title
now that also incidentally changes the
body and so this style which was
supposed to be handy is now just a
hindrance because it's very hard to
modify that style without having some
unintended consequences later I likened
this to in Java imagine I have two
constants one is like the number of
columns I'm going to show and some grid
and the other is a number of retries
I'll do in some HTTP requests if it
fails and so I think ah these are the
same value I'm going to optimize this
and have a single constant and this is
problematic for two reasons one is that
three is already a constant but the
other is I've lost all semantic meeting
these met some something very different
if I want to increase the number of
retries for HTTP suddenly now I've
changed how my UI looks as well
incidentally so that's mistakes that
people can make with with styles so
themes are sort of like styles on
steroids styles you can apply to
individual views themes are essentially
things that you can apply to multiple
views at once and so that can be like a
view group it can be an activity
activity or can be like the entire
application it allows you to apply
default styles as well so if I come up
with I want all of my buttons to look
slightly different along um across the
app then I don't have to
without themes I would have to go take
that style and actually add it to all of
my XML whereas with themes I can say I
would just like to have a default style
for all buttons and it automatically
gets inflated for everything and then
the last lazy thing that it helps you
with at least in the context of my talk
it allows you to configure system
created views so if you've got pop-up
windows or toolbars or something that
the system creates and that's one fewer
thing you have to create but before
theming was before you could theme on a
view level there was a lot of problems
with like oh I have to like create some
attributes that effect just this one
weird pop up but then it screws up
another part of my app but it's very
useful for configuring just like things
that be that the system will create so
there's three ways to apply it you can
apply it like I said to the entire
application you can apply it to the Act
individual activity if you do that it
ends up overriding whatever is in the
application and then on top of that you
can apply it to an individual view and
in the view case it ends up actually
overlaying so you can just overlay like
a few changes to an individual views
theme and the view theming is very very
handy I don't know if anyone anyone here
has worked in the days of holo probably
remembers that there was a holo dot
light dot with dark action bar and that
was because there was no way to theme
just the action bar part of the screen
differently so you had to say in the
theme I want to define most of the
screen to be light but I want this one
part of it to be dark whereas nowadays
you can say I would like just a light
theme and then Manny
really apply a dark theme to the toolbar
itself so it makes things so much easier
so in terms of theming I highly
recommend people looking to app compat
which is one of the support libraries
that Google puts out if you're not
already using it
amongst other things it makes theming a
lot easier for one thing it gives you
material on all devices like that's the
latest design language from Google and
without this there's a lot of subtle
differences between holo and material in
terms of spacing and also in terms of
just like the visual metaphors that
they're using and so it's better to like
it's so much easier to start from one
single base line and then theme from
there another thing is it gives you all
these baseline themes and styles so you
might want to you know change the
default look of all your buttons but you
don't want to have to actually go and
like define a style which defines every
single attribute that a button has to
have you just want to take the main one
and tweak it a little bit like add a
little padding to all of your buttons
and so app compat makes it easy then to
take the app compat button style and
extend from that and then modify it
without that it becomes sort of a
nightmare especially between holo and
material and the other third really
important thing it enables is that it
allows you to do view theming pre
lollipop in XML and that was one of my
favorite things because lollipop had
this view theming which seemed really
cool but I was like oh but you can't get
it back ported they actually did manage
to back port that all the way back to I
think some API that you shouldn't even
be using anymore
I think eleven sorry people who are you
still using having to support apps on
eleven so a few examples of things you
can do with themes the one that gets
touted everywhere are the is the color
theming so in this case instead of
having to use individual drawables for
everything I can just set up colors and
most of the most of the things in
Android will just get colored
automatically so BAM it's like a broad
brush brush stroke you can make these
are some examples of like applying
default styles so it just in case you've
never seen this before so for example
the top line defines the button style
for the entire application so that gets
applied to every button the spinner item
style is handy because like what if I
just want to use the built-in spinner
item layout row that like Android
provides
but I still want to style it a little
bit I can use use that here text
appearance is nice because then the text
appearance can apply to text views and
then you can still apply another style
on top of that another useful thing you
can do with themes is that you can set
up you can set up attributes which are
then referenced in your XML so in this
case selectable item background which is
like my one of my favorite attributes if
you refer to it with that question mark
attribute slash instead of the @
drawable let you normally use then it
derives that value from the theme
instead of going to it directly so why
is this useful if you happen to have an
app that supports multiple themes it
makes it very easy then to like swap
between those values but more
importantly like your system might have
multiple ideas of what a selectable item
background is because pre lollipop
there wasn't any ripple drawables it was
just usually just a flat color that
you've changed you whenever you click on
something whereas post lollipop you want
you want to have these ripples cuz it
looks really cool and so if you use a
selectable item background then the
theme can automatically figure out which
one wants to take alright I'm gonna do a
quick water break before I move on in
the next section sorry all right
resources so resources are you know all
of the things that go into your app that
aren't just pure Java code and before I
can talk about resources I want to talk
about device configuration so if we look
at this screenshot there's like a whole
bunch of things that one can derive
about it in terms of its configuration
so for example I can say it's in
portrait orientation it's got a height
of 731 density independent pixels it's
got a width of 411 of them
it's a nexus 6p so it's got a density of
xxx hdpi happens to be in English right
now the English locale so it's showing
English us and its version 24 because
it's running like the latest and builds
so these are all things that the Android
system knows about the device and you
can query this all manually on your own
if you want but actually with resources
you can just have it select things
automatically and some of these think
some of these devices things will change
throughout X
some of them won't so portrait versus
landscape unless you're locking your
orientation that can change like very
rapidly where you can change the little
Cal people probably won't change that
often but they can't change it while
your apps running and then some things
like the density and what operating
system version probably aren't going to
be changing while you're running your
app so what what sort of things do you
want to vary on this well like landscape
versus portrait I think is a classic
example because it usually presents a
different mode of operation calculate
the built-in calculator app when it's in
portrait only shows four rows but when
it's got more space to stretch out it
can possibly show some of the more cool
functions just by default locale is a
very easy one you want to have it Trant
your app translated different languages
you just have it select different text
strings based on locale so on the on the
left is in English on the right it's in
Japanese you can have things break on
the width of the screen so on the phone
the card when it's open is small enough
that it just decides to take up the full
width whereas at some point if the
device gets large enough it just looks
kind of ridiculous having it be full
width and so we start having a break
point at some some moment with width and
another example of that would be like
our search results we have like the
staggered grid view and again like on
the wide tablet it wouldn't make sense
to have a single column it makes sense
to like fill it up as much as possible
and so we can we can vary the number of
columns based on that and then also on
the mobile phone you can you can see
like the top result is some like small
small board display because it's a
smaller device whereas like on the
larger tablet we can show the nice like
big rectangle which would look nicer if
that actually had a background but
whatever so you could do this all in
Java code like I said earlier but it's a
lot easier if you just leverage the
resource qualifier system and what the
system does is it provides you define
alternative resources for different
device configuration and then at runtime
Android will automatically pick the
correct resource based on the device
configuration so it'll go through and
query everything and figure out which of
the resources you defined makes most
sense in the situation and so you define
this by using by the names of the
folders so in your resources directory
if you have something that's just the
default
values that means it has no resource
qualifiers attached to it it's the
default fallback in all cases whereas if
you do a single - and then a resource
qualifier so this one set this one has
one resource qualifier it's triple xhdpi
and you can have multiple qualifiers if
you want you can actually apply as many
qualifiers as you as you want to a
single value although usually it isn't
handy if you do it to like many
different values and one other thing
worth noting is that if you do have
multiple qualifiers they have to go in a
particular order so look up the
documentation the documentation has this
huge table of all the different
qualifiers that you can use and you have
to put them in the order of that table
for Android to parse it correctly so the
in that same documentation page also
lists out the algorithm but pretty much
it's just like a process of elimination
it tries to find the most specific
resource given the current configuration
so imagine I start with some value and
I've got something in values with
smallest smallest with 600 DP smallest
with means that regardless of
orientation what is the smallest width
that you can possibly have for the
device which is useful for figuring out
kind of like the device class like
tablet versus phone and it also has to
be in portrait so then it would select
from this if both of those are true but
if it turns out one or the other isn't
true then it'll start looking to see
other things that can eliminate so then
you look maybe for the s just the single
SW 600 DP oh it turns out the phones not
doesn't qualify for that so then then
I'll see is the phone in portrait and if
it doesn't qualify for that then it'll
fall back to the the base values here so
that's why it's it's handy to have a
default value for everything the only
thing you don't really need a default
value for is drawables because the way
that Android works it'll automatically
scale if you don't have something in the
right directory so if you only have like
triple xhdpi assets and your device
happens to be mdpi it'll just scale
everything down which isn't great
performance wise because it's having to
do all that extra work but at least you
don't have to worry about that when
you're developing quickly so in terms of
using resource qualifiers in the correct
way what I think it's important is to
think of these resources as code in
particular to think of the each resource
that you're inserting somewhere as a per
to some method function a method or
function and that the parameter is
determined based on the device
configuration so for example if you
think about this in terms of code like
the left the code on the left isn't
insane and dumb because like I'd have to
write a new square function per number
that I want to square whereas the one on
the right has this parameter so you want
to think of it more in the terms of the
things on the right so one simple
example one that I like to use a lot is
actually letting the resource qualifier
system determine some boolean logic for
me so this is a simple one where I
basically just want to know whether it's
in porch or not yes you could query that
some resources fairly easily but this is
just an example so I could say by
default is portrait is false and then in
particular when it is portrait then it's
true and then I can get this boolean
value out but this is really handy if
you have like multiple different
configurations in multiple ways of that
boolean could could run it can do all
that that calculation for you you don't
have to think about it a more classic
example is like using it for different
layouts so I could say I'm I'm gonna
call set content view and I have these
three different versions of layout one
that's the default one that shows up in
landscape orientation and one that shows
up in portrait orientation and I made
this slide far before I realize it's
very improbable to actually end up ever
without it being in landscape or
portrait you'd have to have a square
screen for that but basically it'll
select the right one of these but would
be more clever because you'll probably
end with this will poly end up with some
duplicated code because chances are
there's not that much change that
changes between portrait and landscape
so it's nice then is if you can use that
code reuse the include and then it can
switch on just that part of the code
that changes so I've got my linear
layout and inside of it somewhere
there's an include and that's that's the
pole that's the only part that changes
based on orientation so now I can have a
single activity main and then I can have
a layout that's the default one and then
a layout that just modifies on the
portrait along the same lines let's
let's look inside that include suppose
both those includes have a textview
which are supposed to be like pretty
much the same thing but although they
really modify on is like what the text
size is but that's again this seems kind
of like a waste to have two different
layouts
if all I'm really want to modify is the
text size so here what I can do is I can
send reference a dimension and then that
dimension can be then determined based
on the the qualifiers as well and then
to take this even a step further let's
suppose we have a style somewhere in the
application that's the same sort of
thing all the things that all that
modifies is the text size so I can again
have this be a dimension but now this
style can be applied all over the
application instead of applying it to
like that dimension trick to just one
particular view so like in this example
I have like an activity main on top and
then by default it'll go to one include
but if it happens to be a portrait it'll
go to a different include both of those
include a textview which is supposed to
be ostensibly the same between both and
so they use the same style and then that
style based on the current configuration
determines what the text size is so you
can really go pretty deep with this and
write very little duplicated code
between all of your layouts if all that
you're doing is changing things based on
device configuration and as an aside
this is why generally speaking you
shouldn't override config changes on
Android that's a pretty common beginner
way to get around the problem of like oh
I rotated my phone and then my activity
got destroyed and I didn't want that to
happen because where did all my data go
and then someone says hey if you just
override config changes everything works
out and all of your data stays around
well there's two problems with that one
is that it doesn't necessarily help you
because you probably only over read
config changes for like orientation
changes but there's a lot of other ways
that like the configuration could change
on the fly but for - it means that you
bypass this system entirely and because
you're basically telling the Android
system I've got this don't worry about
it like this is this whole resource
qualifier system is a major part of the
reason why when you rotate your phone
the activity gets destroyed and
recreated again because when everything
gets reinflates
because it wants you to re-inflate
everything because when you re inflate
everything something might have changed
based on selecting a different layout
all right drawables so this is let's see
what how much time good all right so
drawable is the last section I want to
talk about and I want to outline sort of
a nightmare scenario that you may or may
not have gone through I've certainly
gone through this many times so imagine
I'm interacting with design
and they send me a mock-up of a new
screen and in particular like this is
the login screen and they wanted to add
this login with SSL thing at the bottom
so then I look at this and I start
working on it but then I tell design
I need this asset because I'm not good
I'm not good at design or anything I
need you to give this to me so as I says
okay sure no problem so they send you
over a zip file you unzip it and you get
this one file that is who knows how big
this is supposed to be so you tell
design ok this isn't enough I need more
than this like I need one in all the
different densities and designs says oh
sure they go do some research and how
that works and then they send you back a
file like this and a zip that contains
this so now you've got all the assets
that you need but then you have to go
through and rename everything and put it
in the right folders and then import it
into your project it's kind of a pain
and that's a real pain to do with every
asset and then the kicker on top of all
of this is that the very end design says
actually I want to tweak the color and
here's here's a new set of assets and so
now you have to go through this whole
process again and it's a gigantic pain
in the ass
so my recommendation here I've been
working with the design team at Trello
and we figured out like a whole bunch of
waste like reduce all of this pain and
all this friction and it's just made
things so much simpler and it's
basically to think of assets as code as
much as possible like don't think of
them as bitmaps that you get from and
they get from design as much as you can
think of it as things that you can
execute in your application because then
it's so much faster to tweak and change
things on the fly so the first example
of this is drawable XML which has been
in Android since the very beginning and
Java XML is our resources that you can
define you can do things like draw
simple shapes you can do things like set
up state selectors so that's where you
know if you press a button it looks
slightly different that's a state
selector you can use it as a layer list
and this is really handy because if you
have two drawables that you actually
want to like layer on top of each other
with multiple states in between both of
them you might have thought like okay
9eq design to like composite all these
images for me actually you can just set
up a layer list and then change the two
layers independently you get that nice
composition going on so a detailed
example for this are the login buttons
that
worked on once and so these login
buttons are entirely done through
drawable XML so the first step to making
these login buttons work is that I need
to create that button outline and the
weight of the button now a button
outline itself is just its own file so
we're not worrying about the clicked
state right now and it's a uses a shaped
shape drawable the first important part
is it's just you can tell it what type
of shape you want you can also make
ovals and stuff like that but there
you're limited to very simple shapes
with java xml i want to say that it's
mostly filled with transparent space in
fact that should be the default but I
think on some older versions of Android
it was not defaulting to transparent for
solid I don't remember exactly why then
I do want that white outline though so I
give it a stroke which then determines
that outline and I would like to have a
small radius on it so it gets that nice
little pretty button look so that's just
creating the outline the blue actually
comes on the background of the entire
screen I just put it there because
otherwise it would be really hard to see
with my white background on the slides
so then we need to have some behavior to
it when I click it I want to actually be
able to tell that I clicked it and so we
need to add a selector to it which you
can see in this beautiful little to
frame gif and so the way that I'm doing
this is actually layering a selector on
top of that outline I just talked about
so I'm using a layer list and that layer
list allows me to take two drawables and
put one on top of the other and I'm
saying the top layer is that outline
that I just showed you that's the the
previous code that I showed you is
what's going on top so that's always
going to be drawn and then the other
layer is a selector and the selector
just has two States in it and one of
those states is when it's pressed then I
want you to draw this other shape so
again I'm using another shape drawable
in order to determine what should be
drawn inside of it and in this case it's
a little simpler because I can just say
I want you have a solid color but then
again also have the corner so it doesn't
end up bleeding out of the corners and
then when it's not pressed in in the
default state then it'll just be
transparent so that's great and all but
then in version 21 of Android they added
these nice ripple job also look really
pretty
and doing that require
a whole different set of code and so for
that you end up using something that's a
ripple XML something they added in
version 21 and that inside there is
where to say what the color of the
ripple should be and then after that I
add like okay I still have the same
button outline as what's actually being
drawn in that ripple but then the last
part of this is that I define a mask and
that mask basically so says this is the
outline of where the ripple should
appear and so then the actual like solid
color inside of it doesn't really matter
it's just the fact that this drawable
will draw to this particular area that
that matters and so I was able to get
away with all of this and have a
different version for different versions
of Android by using the resource
qualifier system so at the bottom there
is this the outline that I'm always
going to be using but then the default
button uses the state selector which
will always work all the way back to
version 1 of Android I think and then
drawable v21
for that ripple drawable I can use their
so drawable XML a fairly good way to
skip a lot of work and then I didn't
have to I just had to ask design for the
colors I didn't have to ask them for
anything else in particular vector
drawables so like I said the shape
drawables lets you draw very simple
shapes nothing complicated vector
drawables lets you do any sort of vector
drawing you want or most vector drawing
that you want so it allows you to do
very complex shapes and the advantage
here to using a vector is that you don't
have to then worry about density of the
screen all that much because like before
I was having to get these pngs from
design that was in all the different
densities here they can just give you a
single vector and then it's
automatically drawn at whatever is the
best debt the best resolution for that
screen so that's a huge time-saver but
there is one problem with the way that
Android implemented vector drawable
initially another point is that vector
drawables were added recently in Android
but there is a back compatible library
in the support libraries for for using
vectors all the way back to I think 14
or something like that but there is a
big problem with the way that Android
did it which is that they came up with
their own vector drawable format that is
not actually SVG and if your designers
or anything like my designers they know
how to speak SVG really well all of
their like all of their tools
know how to output an SVG another know
how to output as vector drawables so you
need some way to convert these SVG's
that your designers are giving you into
think into a vector drawables in the app
so there's there's sort of two ways of
doing this a design there's two ways of
doing this and one is when you in
Android studio you can say I want a new
vector asset and that'll bring up this
nice little wizard and then you can pass
in the SVG and it'll it'll convert that
into a vector drawable as best it can it
turn there are some SPG's that it
doesn't work very well with and won't
convert so that's good but I still am
even lazier than this because I don't
want to have to go through a wizard
every time I import a new asset so
instead we actually wrote this we wrote
this before all the vector drawable
bacchum pets have happened but we're
still using it which is this android
plug-in that we wrote called victor and
what victor does is basically to define
any number of source sets anywhere that
you have your SVG's and it'll just slurp
all those up and then output something
that the system can render and for
awhile it just it just output pngs but
then eventually we're able to get to
actually grab the code that he's in this
new vector asset stuff and then use that
to convert it straight into vector
drawables so that's great because
actually with Trello our designers have
their own git repository which is where
they put all of their like compile this
VG's and then we can just like have that
as it gets sub module and import it and
then like we don't have to ever like
they basically we just have to update a
commit pointer to get new assets from
design that's great and then so the last
thing I like to say about drawables that
has really saved a lot of time recently
is the difference between skeuomorphic
and flat design so skeuomorphic design
is where you have things that look
exactly like what they're supposed to be
and so this is on the on the left is
andy graph which is a an app that my
friend wrote which makes your phone act
exactly like any ti-83 80 84 whatever
and look exactly like it so it looks
very realistic that's very skeuomorphic
whereas on the right you have like the
normal calculator which is flat and
every every button is just this flat
color and what's really nice here is
that as nice as the thing on the left
looks on the right all the icons and all
the text is just a flat color and what
that means is that it's very easy to
tint those colors and change them on the
fly with the with the buttons on the
Left it would be very hard to tint them
in any way that would be reasonable so
actually in the Trello app all of our
assets are flat black colors so they're
black on alpha and then in code we can
take any of those and tint it whatever
color we want and so that's super handy
from the perspective design because they
don't have to create multiple assets for
whatever color they want every time they
every time they want to change the
colors we can just say oh that's easy
we'll just go change it in code and then
we're done so in terms of tinting images
there's there's sort of a few ways to do
it one is to do it via XML but but
besides the fact that image view has had
this tint attribute forever which
doesn't quite work all that well it's
not backwards compatible like it got
added in two recent versions of Android
to be able to tint drawables in XML but
they haven't figured out any way to like
actually back port that functionality so
I end up actually doing most of the
tinting in code which is it's very
simple with image view and drawables you
can call set color filter and then just
pass in the color and then it turns out
that for a for a black icon on alpha you
want to use the porter def mode of
source in that's actually why the XML
image view of the tint attribute there I
don't like it very much because it uses
a porter def mode that isn't compatible
like I think you have to create white
icons on alpha which we're not doing at
the moment if you want a really
comprehensive solution this exists in
the support libraries is drawable compat
and with that you actually wrap the
drawable and then you can call set tint
or set tint list on that wrap drawable
and the main advantage that has over
just calling color filter directly is
that it can handle tint lists so you can
have multiple different you know
selected States for that wrap drawable
in color and you can tint all of it
equally but since we're not actually
using that in the app we end up don't
yet we don't end up doing that very
often and so set color filters just a
faster easier way of doing it anyways so
that was all that I've got this was a
slide I was told to put up as well to
let us know what you think
put click the happy face if you liked it
or the sad face if you didn't like it
and thanks very much for coming listen
to the talk the middle the middle link
is to my blog where I've written more
about some of these things and then if
some parts of this talk were taken from
other talks that were like more detailed
in particular like the styles and themes
I went into much more detail on that so
I you can look at my old speaker deck
just like find those talks if you're
more interested in learning some of the
more nitty-gritty details there and
thank you very much
we're there any questions well the
question was whether performance was
lost on virtual machines and well my
take on it is that
well the questioner might mean that if
you use like an emulator and you're
doing this you had a slide with the
graphics performance in different
layouts
what if so and so like see here we're
talking about this one yeah could you
actually find out that your layouts
through an emulator no ideas a real
device for this yeah so like I wouldn't
for things like profiling like the
emulator can really make things awkward
because it could be it could be the case
that like you have this GPU if you're
working on like a Windows desktop or
something you have a GPU that's bigger
than your phone like running the
rendering and that's gonna throw things
off a little bit obviously or like it
could be the case that whatever I think
it used to be that it was translating
from like arm into x86 and then that
would be really slow and so all the CPU
operations be really slow basically yeah
I would use an actual device for all but
for all sort of profiling purposes okay
and you you touched upon this you
constraint layout mm-hmm that's
something you played with oh yeah I
played with Christian layout leave its
the Savior I hope so because it so it
does a lot of things that it's sort of
like this composite of relative layout
and linear layout right now that allows
you to create very complex layouts
without having too much nesting and so
the hope is that you really create these
calm
likes layouts without much nesting and
that through the contraction strain
system it can like better figure out
like though the most performant way to
lay things out quickly so I'm hoping
that it saves us from having to use
relatively out more often
yeah and I think you have if you have
more questions please come down and talk
with me afterwards but thank you very
much then and then yeah remember to rate
the session and I can see some of the
talk speakers here from the Android
track so thank you very much it has been
a pleasure and yeah please give them a
hand thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>