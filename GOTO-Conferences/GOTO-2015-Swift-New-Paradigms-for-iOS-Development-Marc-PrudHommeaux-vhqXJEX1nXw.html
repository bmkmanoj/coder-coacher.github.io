<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Swift: New Paradigms for iOS Development • Marc Prud'Hommeaux | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Swift: New Paradigms for iOS Development • Marc Prud'Hommeaux - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Swift: New Paradigms for iOS Development • Marc Prud'Hommeaux</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vhqXJEX1nXw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we would enjoy the tea now this
morning papito here today which is very
language
so by weight reduction my name is marc
de Vaca writing code in some form or
another for 30 years now I grew up with
visa and logo and then evolved into
Pascal and alldata called a fun-stopper
day to see a c++ and pearl and moved
through java world and sharper old
expose you see the retina there to see
and then i started in working on spin
and i've written and take doesn't match
for mac and iOS
so the asset work on you
ability to the world the best web series
last year apple developer conference
WWDC back into that was worth of data
that came out of the people britvic 10
could not get finalized until summer of
last year and the version that were on
right now what got you there was still a
very young language people to so pick
show dance with anyone here actually
Virginia was with one two three four
five
let's say like attention so furniture
start out with just like a real drag
high level overview of the Swift syntax
and how it's similar to
then I'm going to submit through the
will read them off yet so we can sort
out very quick summary of the language
actually pretty difficult to read in the
lights plan but I'm going to anyway so
give classes that's very similar to
classes in job or their java developers
here so are there any shark filters so a
few so it seemed like a lot of you who
completed sighs pretend you're familiar
with last based on foreign language so
junior class is the bank and it's got
curly braces curly braces are using
Skinner to track
letting out and lock code you have
properties on your classes and
visualizers and you've got methods and
and you've got all of that stuff is
basically following the z nu de facto
that new defective would be long-running
de facto c++ standards impacts will be a
lot more familiar to people then people
who are say coming to objective-c that
has all of the other crazy braces so for
those objects see programs out there
this is a quick example of how you might
implement the same class in objective-c
again really difficult to read but m but
it has all the interfaces and
implementations and separate header
areas and if it doesn't look familiar to
you don't worry about it because you
will probably never have to learn about
it as the Swift is apple's replacement
for objective-c going forward so we've
got a bunch of java and c TR programmers
here as well so i'm going to be from
here on out I'm going to be referencing
things relative to say javis intact when
I talk about the syntax of Swift because
that seems to be the dominant the
dominant paradigm so a very quick start
I'm going to this is a example of a
swift class and this example of a Java
class and they're basically line by line
identical the only major difference that
you can see is the type in Java and in
most of the languages proceeds the
identifier and in Swift the type comes
after the identifier so here you have
this VAR accounts and followed by an
array of accounts in Java you have list
of accounts followed by accounts and to
specify that it's a variable you had the
bar keyword similarly for functions and
methods you have
and Java you have the return type is an
inch and you have this holding function
all these methods that goes to the
challenge and aggregates and number of
pennies in the account and the returns
at the end almost exactly the same with
whips except the type follows the
identifier of the function but you've
got you know some fastener ratio some
fascination and and you aggregate all
the accounts and return it so pretty
standard stuff it looked you know it
auto looks very familiar to pretty much
everyone here so you know the big
differences the other big difference is
you'll notice is a lack of semicolons
and Swift you know the colons are
optional but not required and then these
funkin bar keywords and the identifier
following the type following the
identifier supplied by the function VAR
keyword so there are a few there are a
few modern improvement especially over
objective c you have you have generics
you're able to say that your array is
going to only contain strings are able
to parameterize your types so you know
here you can add a d to my list of
strings but you cannot add a one debt to
that's actually new for objective-c
programmers obviously the rest of the
world as compiled languages has long
since adopted generic you've got type
inference so rather than having to say
you know okay there's a number of type
int N equals 1 array of strings
dictionary of strings to double you can
just say na equals 1 strings as array of
stricken areas of set of values so
pretty smart typing for every once in a
while its breakdown which breaks down or
is slow so you can always opt all they
put by the type but it for the most part
is never required you have optionals so
if you want to allow a value to accept
null or mill in apple's parlance you
just specify it with the question mark
it is regular any any type can be an
optional type so you say give the type
of this is a string to follow up with a
question mark it'll be fallow or it'll
be worlds or if you know if I don't you
cannot assign it to nil so that's pretty
fantastic for people who are we're tired
of their null pointer exceptions you'll
never get
I will never get that issue and you also
have some pretty quick pretty quick
accessing of nulls without having to
tediously go through and check each
individual value for null you can say
okay is the owner of the account no and
if not then go through the deposit of
the count and if not then get the amount
so then you'll get an int value that
value could be nil if any of those
intermediate values were no but if it's
not then you can proceed also notice
there no parentheses around around the
if statement you have two poles Swift
introduces a bunch of new type as i
showed before you have the class type
but you also have two poles which is a
one or more instant value so you can
have two int's you can have two strings
you can have a bunch of different stuff
the tuples are heterogeneous so you give
have string a double and an account or
whatever whatever you want so as with
all twit first let's type tuples can be
used as arguments to functions or return
values from functions all the types can
be mixed with all the other types so you
know functions are not restricted to
just taking individual objects or
primitive they can take and give back to
both the next cool part is enumerations
numeration zar a pretty powerful feature
of Swift that it is a pretty broad topic
but they have them as well being able to
enumerate individual separate values you
can also have associated objects of
enumerations and you have a rich set of
pattern matching that can be to be done
with them you have functions functions
are what you would expect when they
exist within a class then they are
usually referred to as methods but
functions can be free or they can be
they can be you can be constrained
within a class and you can actually have
functions that contain other functions
I'll show it example that shortly
so functions can also have default
parameters they can have they can have
named parameters so you you don't have
the problem where when you have 50
arguments you don't know what the
arguments are you can use them to
compose higher-order functions a
function can accept a function is there
an argument or pass back the results as
a function they're very powerful you can
even do function koreans for some
limited set of functions which is the
ability for a function to be partially
applied so you can call the first
argument of a function assign that to a
variable and then call subsequent
subsequent arguments so this is one of
the first examples of have Swift is a
multi-paradigm language multi-paradigm
is is kind of a highfalutin term that
that means that it takes some ideas from
the academic world from the more
functional programming side of what's
going on right now and it integrates it
with the more industry dominant
object-oriented world so Java is an
aggressively object-oriented language C
sharp is a little less aggressively
because it has a lot nicer support
foreclosures and and and things like
that Objective C has been slowly moving
out of the broadening from the
imperative object-oriented world for a
while and a lot of these ideas have
evolved into into Swift and in the first
example of a couple examples they have
of how how it's a multi-paradigm
language you also have ad hoc
polymorphism which is often known as
operator overloading so you can have
operators that are class passive
functions two things I'm going to show a
quick example of that so here's an
example of a function and all this
function does it takes two strings and
it takes s1 s2 and returns a boolean
value and what is returning is whether
or not the first string is less than the
second string that less than operator is
itself a function that is saying okay is
this I'm going to compare alphabetically
and if the first one is a is less than
I'm going to return true otherwise he'll
return false and so you have this array
the type in fur is telling us this is a
array of strings and you can sort the
array and what you pass the sort is is
ordered before which is the function
they'd find up there that's an example
of how a function is itself a
first-class
you can take it you can treat it like a
variable you can pass it in there you
can pass it to other functions you can
it'll really little clothes over the
environment variables so if you have a
function where there's a variable
defined above it it will it will retain
ownership it will attain possession of
that variable throughout the lifetime
with the function which might pass out
of the local scope you can also define
functions in line so this example where
rather than having a separate function
out there and passing in these curly
braces and then this funny little syntax
where I'm saying these are the two
arguments that I'm taking to the sword
function and then all i do is the exact
same thing as before is a pass in the
whether or not s1 is alphabetically but
needs s2 and then I'll get back cow dog
dog tail and to go even further you can
actually treat the operator itself as a
function so so this is an operator that
is defined for two strings using ad hoc
polymorphism to say okay what is the
what is the electrical parison of these
two strings I can just pass any argument
any operator that accepts to two of
whatever value is in is in the array and
returns a boolean and I can use that as
my argument to sort so I could define my
own crazy thing which just compares the
number of letters in the in the in the
array and in this case would be equal so
and the last value additional value type
thats which defines are immutable trucks
and this is a really exciting feature
and the feature that I'm going to
concentrate on for the remainder of this
talk and then there are a bunch of other
features there's access control you
could have private protected methods
using namespacing so you can have your
own module in a single namespace again
something that the rest of the world has
had it for a long time but is new to
objective-c yeah bridging to existing
objective-c libraries it's really
important all of apple's libraries are
written in objective-c you have
automatic reference counting which is
like automatic memory management but not
quite as good but a lot of GC but a lot
faster
you have interfaces protocols they call
them an apple interfaces they call them
and see and the feesh are basically
saying any of my value types are going
to conform to this contract that you
defined you have categories which is
basically taking class and adding stuff
to it without having to subclass up and
it's got a ton more features and these
are you know very well covered by
Apple's intro to Swift videos which I
highly encourage anyone to watch from
WWDC less here they're a little bit
dated to the language itself has changed
a bit since then but overall it's really
it's really a fantastic reference and it
just takes about an hour naps two hours
to watch so that was a super quick
overview of Swift from about 10,000 feet
it's a really approachable language
especially for people who are coming to
the apple ecosystem for the first time
some other languages has really familiar
Java's csharp style syntax it'll find it
really easy to just get up and running
with it treating it as a run-of-the-mill
auditorium for language which is
perfectly fine very many people are
writing their asses their apps that way
right now but what I'm going to
concentrate on right now is the type
that I didn't talk much about which is
the immutable value support that Swift
has so let's define our definitions ute
ability and immutability usability means
it can change something immutability
means that it's unchangeable all
languages have some degree of
immutability for example in Java you can
declare a veil of variable as final that
means that you will not be able to
change it from there on out and see the
cons and you know objective-c others
opticon in Swift you declare something
as mutable if you say that it's less so
there's a VAR keyword which says that
can change let means that it cannot
change so I plus plus you're not allowed
to do that if you declare to the left so
it affects essentially the primitive
isn't exactly the same way that you
would you would expect it to in the
in other languages and that's basically
mutability so let's talk about value
types so a struct is a value type as
opposed to a class is the reference type
a value type is not shared it might look
like a sheriff it's not actually shared
between multiple owners so the only ever
one owner of value type reference types
are shared in contrast a class can have
multiple people that are owning it right
now and multiple people they're
interacting with them so in Java end of
the languages there's a distinction
between primitives and objects even
though double people call everything an
object is not really true they do have
primitive and primitives behave in the
same way that our intuition has evolved
to to expect them to behave I've been in
today I've signed it to 42 and then I
have another int that I signed to I and
then I increment I I changes what Jay
does not it's just that's the way that
septum is work in every language that
I've ever used has anyone ever heard of
a language that doesn't work with if you
had the pointer to an I'll I can see
then you can change the underlying value
but you can't actually change you can
actually change I in a way that's shared
to other people similarly you have some
degree of immutability for objects so
for classes you can you know here you
have a animal and you assign feed to the
animal
so you say I have a final animal here
and you can assign bday and stuff like
that you can change the underlying
properties of it calling animal
immutable does not magically make any of
the internal properties of those things
immutable so sort of a shallow form of
immutability what the final says is that
be or a cannot be reassigned to anything
so once you've assigned at once you're
not to be allowed to change it so it's
kind of a a very single level shallow to
group form of immutability and switch
works exactly the same way with their
reference type with their classes with
their objects so if I say okay let a be
a new animal dog and that dog has a type
that is a strength and I say let B
equals a so b is now the same animal I
changed B's type now I change A's type
to cow and then B type is going to
change the cow as well just like you
would probably expect so
here's the class and here's a structure
and the only difference between these
two things is the keyword classes and
structures are intentionally designed to
look very similar which is great for
being able to experiment with jumping in
between the two of them but it's almost
deceptive because you can see at the
very bottom the behavior is extremely
different if i have a is animal variable
struck and i assign b day and I change
B's type a change a's type these type
does not magically change out from under
you it is it is it is essentially copied
when when you've changed assignments so
we've got the value types and we've got
the reference types and the similarities
between the two are that they can both
contain properties in other words fields
or elements they can see methods they're
called functions and twist but they're
essentially methods they can't have
initializers they can comport a protocol
we implement interfaces but unlike
classes they cannot inherit from each
other so my class animal could not
you have no intrinsic idea so an object
able to compare whether or not to lock
doors are either semantically the same
using whatever happens in your lab
supplies like a you get my key falls in
Java and important available protocol
effective see but as well as having
semantic equality other languages have
the document of intrinsic identity the
quality so your besides looking for a
pointer into Ottomans you can do a job
at across the country there is no
interesting in any value package it's
like saying was the identity the
identity is defined by the valley at
that Valentine contains or by the set of
a leaf or accomplished melon structure
and destruction other data types are not
shared between all consistent and they
are the lack of sharing makes them for
all US vs in beautiful so do you make
that day to this is beautiful is what
i'm doing here is a destruction let's
that's be beautiful and create a new
animal dog that i can connect a nap so
how how many ways that you let's exactly
the same as as an int you
you change again you're not actually
changing the underlying oneness 440
tunas of the integer you're actually
changing your actually recopy than
inverting to another injury the same
thing happens with the value time you
have a hierarchy of individual values
and any time or any kind of decided
there copy copy that so your example of
a bit but not read this ok so let's get
a little bit more in depth here such as
we have a back scratcher and you have a
list of accounts that i just have
additional into a microwave any of this
function holdings and all this is doing
is this using cooks kind of fancy
sickness I said go 3-2 the count reaches
accounts return to number of pennies to
the town and then reduce or fold it by
aggregating together it's essentially a
one-line way of saying take almost
ending smelly
together at return the current result
and then I've got this account structure
that I defined that is count itself the
count as two field has an odor and the
number of 10 so I crave back and
creative cuddles army I add me to the
list of accountants bank other cover
Dave more safe thank you and then we as
active and we check the holdings of the
and you have the appendix down and then
the records the bank accounts at the
very first index Dustin penny from my
from my back down because it was the bed
and dick dinner and Men Holden's
introduced overall back holders with
introduced them so you can have a very
surprising results that look very nice
flying first lacrosse I could duck face
this way is a bank comes Europe anything
the bank holdings of it if instead I
kicked by 81 which I added record the
bank accounts which should be exactly
the same bank accounts of Europe the
negative activity sense all of a sudden
bank holdings remains unchanged is still
that 1050 when it should drop down to
without and that's pretty deceptiveness
by sandy syntactic similarities between
classes this process can be to some
degree of contusion but it's very
convenient in very powerful especially
the access for syntax that that they
provided so I mention before the topic
of ecstasy springs are referenced by
types designed to stimulate value type
so it looks like they're beautiful but
they're not they're just classes like
anything else you're this classes that
have all their mess is defined in ways
that forbid it from mutated underlying
strength but the Alliance brain is a
single minute at sea and it's just a
pointer to a series of unit
values you know whatever the other line
communication it could in theory be
change we're springs of Swift they're
actually true reference types or
implemented as strokes in an embassy you
gotta cut up bunch of foundation license
you have written you have a rage and you
have dictionaries these are the ball
over 25 years is going to make that into
the next date that's why all the
standard and these are all in one is
less reimplemented a lot of that stuff
for their own separate foundation
library so script is built on its own
standard library and it integrates with
the objective c language you can use
objective c springs which gets your
classes or use scanner swift springs
which article in its reference types and
it has the popping on value
it's Rebecca everything in these woods
near library is instruct there are a few
nominal classes but they're mostly not
ones at the end user uses everything in
there all of your raise its dictionary
eight sets the spring they're all values
and so they come with this this deep
copy semantics you pass an array trenker
of dance or whatever to a function of
that function adds something to data
ready and then return to caller we're
ready to set now he's not going to
actually different different languages
have different ways of doing things like
forbidding collections to be modified
like in Java you have a collection
unmodifiable list I think you have the
same thing in c-sharp although I think
there might be a nicer syntax in
objective c you have parallel classes
you have nsstring you have NS mutable
string of NS array and anitha mutable
array in Swift you have you declare a
list as a constant in which case it will
be you know immutable or you declare the
variable in which case you'll be able to
mutate it locally but in no
circumstances when you pass a straight a
list of strings or a list of anything or
a dictionary of anything to another
function will that function be able to
mutate it and it's a very foundation
very powerful foundation on which to
leverage your own use of the value types
because all the built-in containers that
you'll be using for those things are
going to be conforming to that that
immutability semantics so what what is
what it actually is the benefit of value
types I have not actually gotten to that
I've just talked about how they behave
so I'm going to go over what i believe
to be the four main benefits practical
benefits to you for using value types
they're comprehensible they're testable
they're parallel and they're portable so
before I expand too much I'm value types
I want to step back and say that you're
not ever going to be writing your entire
app using purely value types this isn't
this isn't haskell you've not you can't
adopt an entirely functional approach to
apps because to run to create an
application either mobile or for the
desktop and mac
you have to integrate with classes and
that means you have to subclass other
class and things like that so some
percentage of your app is always going
to be using reference types and that's
going to be true for inevitable future
there's going to be X percent that is a
that is a reference in y % that can be a
value but what you can do is you can
compartmentalize areas of your
applications and implement them purely
as hierarchies of value types and the
logical place to do this would be say
the model of your class like if you have
a document model that you can serialize
and save it's a very good place to start
thinking about how can this be
implemented as as a series of values
rather than as a series of references
but it's a it's not limited in any way
to the model it's just that's often the
most intuitive place that people like to
start thinking about so here in and I'm
going to start using the term model to
mean the portion of your application
that is written purely using value types
so to get over my tangent I'll get back
to the value of values first off they're
comprehensible and what I mean by
comprehensible is that values can be
thought of as data whereas objects can
often be thought of as a combination of
data and behavior generally speaking if
you have a purely value based model
performing operations on that model is
not going to have any side effects with
the rest of your system which is
fantastic for being able to reason about
your code because you know that no one
is able to get going to be able to
change a value that you own no matter
what other part of your system you pass
it around to so you not only have safety
you have the ability to reason more
clearly about your code because you know
that things are not going to have any
side effects when you pass them around
if you have a model of a account and you
pass it someone you don't have to worry
that they're going to mess up the owner
or something in the in the function that
you called and then you get it back and
you and all of a sudden the state has
changed to something that you are
confused and upset by and this
comprehensibility leads to testability
when you have sort of an isolated
network
of value types and very easily run
execute test cases on it because you
have a compartmentalized part of your
system that is is isolated from the rest
of it so you can have entire modules
that are sequences of values and you can
have entire test cases they're running
independently of any sort of enclosing
superstructure so you don't have to
worry about doing things like mocking a
server just so you can synthesize some
underlying connection value in your
model it's not possible to have one of
those because you're not going to be
using any reference types in your model
network so you can be sure that the only
things that could break the tests are
changing the tests themselves or the
model which is really good for keeping
your system divided into individual
isolated components which itself is
fantastic for keeping the complexity of
your system from spiraling out of
control a lot of times you know when
when reference based applications and
systems are growing they start out
fairly simple and a single person can
reason about how how everything will
flow and as it grows and as a network
sort of gets more tangled and spaghetti
like it becomes more and more of an
uphill battle and you know I've watched
in the past many applications grow
germinate from very small things to very
large things and you just see the
percentage of time that his creativity
versus maintenance just shrink to the
point of you know I was working at
Oracle for a little while and so many of
those applications are just ninety five
percent of the time people are trying to
fix problems and try to keep things from
blowing up so the testability is really
important and along the same lines of
testability structs are intrinsically
parallel you can pass any parts of your
model onto any thread and you don't have
to ever worry about there being any kind
of raised condition or anyone stepping
on any pointers because two people
cannot own the same object now you do
need to rethink about what you're going
to how you're going to do things you'll
be using a lot more pure functions where
you pass in a value type you perform
some mutation on it and you pass it back
or in the example of multi-threaded code
you dispatch something out using a mom
parameter you perform a series of
operations on it or calculations and
then the results of that model that then
gets passed in to some sort of you know
callback mechanism as opposed to passing
a pointer to something expecting the
thing to operate on that pointer and
then just being able to access the value
directly so there's a very much a
different programming model that is used
when your paralyzing your especially
when your paralyzing your model but in
general with value types but the
benefits are fantastic you no longer
have to to reason about threads and all
the attendant issues with
synchronization and locks and and
multi-threaded performance is going to
be the only way in which computers are
going to be getting any faster in the
near future they can't make processor
faster so they improve overall
performance by increasing the number of
processors and that means that being
able to write robust and fast
multi-threaded code is is just essential
for many fields of competitive
applications and the last one is
portability now I don't want to say I
don't anyway mean to imply that Swift is
itself portable beyond you know beyond
running on Mac and iOS which does not
exist on Linux and exist on Windows and
it's very unlikely to anytime soon but
what it does mean is the isolation of a
network of values leads to a sort of
intrinsic portability because you can be
very confident that you can serialize it
out and you can translate it you can you
know send it off to say your node server
as JSON or you can you can upload it up
to like your Scala you know server or
something and I'm working a system right
now that's doing exactly that and it's a
delight to work with because you can you
know if you are working with other
languages that have some support for
value types like Scala's case classes
you can you can really go back and forth
between between the two the two systems
with a lot of ease and you can evolve
your model with a lot of these so there
are a lot more intrinsically portable
than using than using reference types so
that's what I believe to be the four
major benefits that that values can
provide for your application and for
development going on forward as I say
Swift itself is a very exciting language
and there's a million milli
interesting components to it but it's
also really really approachable you can
you can really get started especially if
you have a background in Java or C sharp
and you can you know watch some videos
and basically get started right away but
I think the the truly exciting part
about Swift is that is really starting
to bring in some of the ideas from the
functional programming world and one of
those is concentrating more on using
immutable values and less on unless on
reference types so with that I will take
a few questions if there are any entered
via the app</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>