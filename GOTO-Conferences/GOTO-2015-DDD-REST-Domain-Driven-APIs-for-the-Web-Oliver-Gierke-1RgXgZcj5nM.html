<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • DDD &amp; REST - Domain Driven APIs for the Web • Oliver Gierke | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • DDD &amp; REST - Domain Driven APIs for the Web • Oliver Gierke - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • DDD &amp; REST - Domain Driven APIs for the Web • Oliver Gierke</b></h2><h5 class="post__date">2016-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1RgXgZcj5nM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the session on domain-driven
design and rest
my name is oliver geeky i work for a
company called pivotal has anyone ever
heard of pivotal Oh anyone ever heard of
Spring Framework okay that's a bit
better yeah we're the company behind the
Spring Framework I'm part of the spring
engineering team taking care of the
spring data projects in their entirety
basically I'm and I'm the project lead
of that and you could ask why as a guy
who's like only working with data
basically talking about DDD and rest and
the reason for that is that I'm involved
into like two major aspects of the
spring data space which is the the
spring data store implementations that
on their very upper layer exposed a
repositories programming model which
gets us the connection to two domain
driven design and on the other hand I've
coined a tiny library called spring
hideous which basically brings support
to create hyper media based
representations to the spring MVC
framework and on combining these two
worlds
I've also also the spring lead arrest
module which is basically taking your
spring data repositories and turns them
into a foundation for what could be a
REST API right and if you look at that
that that's not here you could basically
think we're taking like data from a
database and then flipping the tables by
90 degrees and then turn the turn that
into JSON and call it in an API so
that's not what we want to do and
actually developing spring data rest has
taught me quite some lessons about why
that's a bad idea and how we could
actually do better and coming from the
from the fact that rest is not cropped
using JSON and HTTP I asked myself ok
what's what's actually needed to take
your your domain model or your your DDD
domain model
turn that into a into a need rest web
service or to phrase it the other way
around if you if you don't do any a
particular or if you if you if you avoid
thinking about certain things in in the
ddd area what problems will you get when
you build the rest web service right so
you probably all know the this diagram
here it's from Eric Evans book
domain-driven design what I like to do
is concentrate on these aspects in the
upper right here like briefly discuss I
don't want to do an introduction to
these concepts because I'm assuming
you're here because you already know
them and just take a look at those
concepts from the consequences that they
usually have in like using these
concepts and the consequences that has
into when building rest Web Services and
representations in particular because
that's that's going to be like the main
topic here the as you've seen like if
I'm working on a spring framework that
usually means or mostly means coding in
Java so some of the challenges and stuff
might be related to D to the to the
language actually and others might be a
bit more fortunate here and the first
thing and that's why I mentioned it here
is value objects value objects are very
powerful thing but they are really a
pain in the ass to build in Java right
so if you just want to build an email
address class like you have constructors
and then equals and hashcode to
implement and all this kind of stuff so
that's actually a reason why people
avoid building these or using value
objects the most funny thing I usually
see when it's when it comes to like DJ's
are through your free validation API is
when you have a class that has a string
property that says email address and it
has an annotation saying email address
and then I always wonder okay why don't
you make it a type in the first place
but people are lazy and that's why they
they avoid using value objects sometimes
but the even if you have to call them
manually I think it still pays off if
you do
believe me in that case there is this
like the this talk on on value objects
but I done is something like the
Conway's law reference you know ddd talk
without linking to that talk here it's
like all about value objects and how
they basically allow you to control
complexity in your in your code and make
code easier to understand so this is
that said it they were still worth it
even if you have to like code them
manually however there's Lombok have you
heard of Lombok before so if you like
haven't seen that before have a look at
that
it's basically an add value annotation
on the class that in this case and that
makes it makes it quite usable and easy
to create those types still if you if
you're if you have to take a net hurdle
you get other opponents now that you
have the language out of the way you
face hibernate injection and mostly
they're there the problem there is that
they require you to make stuff or it's
it's hard to really write immutable
types or classes with these frameworks
in mind right so you have to teach them
how to map certain strings like an email
address string from your from your JSON
representation into that class and back
and it's not really hard I'm not saying
that but it's like cumbersome and and
take some some efforts you still value
have objects important important aspect
here so entities and repositories D
that's what what most people deal with
on a day to day basis even if they have
like string fields for email addresses
in their classes but the problem
especially in the Java space is with
there's JPA you in case you familiar
with that one we're sort of everything
is an entity right so it doesn't the
entity concept in JPA doesn't
necessarily match the one in
domain-driven design and that makes it
sometimes a bit hard to differentiate
one from another let me give you an
example here let's say we have a
customer that has an address and some
payment information here and in
email right and there's an invoice
pointing to the customer there's an
order that consists of line items and
the line items point to a product right
this stuff translated into into JPA
would basically mean that address might
probably be an entity the email as I
said rather a value object customer is
probably an entity orders an entity line
item is an entity yada yada yada so the
thing is that like as if as I've tried
to express here in that model there are
certain clusters of yeah functionality
basically so everything related to the
customers can be slightly grouped here
and the relationship between an order
and the customer and an order and the
line item is a completely different one
right
I guess you're trying what I'm trying to
get to which is basically that some of
these entities form aggregate routes and
by that aggregates around them and
others don't and that's something if you
just look at the entities in your
application you don't really eat the
model or D the code doesn't really
reveal that right that that concept it
doesn't reveal what an aggregate root is
in in in your code fortunately a
repository is defined to be basically I
mean it's not defined that way around
but essentially an entity plus the
repository forms an aggregate why is
that an aggregate or yeah an aggregate
is defined or the aggregate root into in
particular it's defined to be the one
the thing that you interact with that
you pull out of the out of the
repository or that you create through a
factory and all of the contained
entities are only referred to or used by
referring to the that aggregate in the
first place that also has the
consequence of that like the aggregate
root or the aggregate has the
responsibility to control invariants on
that on that entire aggregate right so
it makes it make sure that you the
aggregate in itself conforms to certain
constraints and like business logic
right
so that means if we take the
repositories with into into account we
can basically find all the entities that
we have repositories for and then know
that their aggregates which is kind of
useful information because as I said
aggregates are like nice or they they
they create some kind of consistency
boundary and by that fact actually make
up nice representation boundaries for
your for your application for your of
your your s web service
another thing that plays into this is
that aggregates are the things that you
usually refer to so and some some part
of an aggregate as you've seen in the
example before with the order and the
order item the line item where the line
item refer to the product right so an a
nested entity in that aggregate is
referring to some other aggregate and
it's only allowed to refer to other
aggregates not to entities within other
aggregates and the interesting or the
the the convenient thing here is that
because aggregates are the primary thing
that you refer to like you can nicely
translate that into the resources you
exposed they are identifiable and only
those things that can be identified you
can actually refer to alright so we can
only create links to these other
aggregates I just came back like
traveling here from from a customer
workshop with to their customer workshop
on like build a they have this legacy
database and they want to like wrap that
with a nice API and these guys got
started with we take spring that arrests
and we generate our entity API entities
from the database because the tooling
allows you and then we for every entity
creative repository and then we flip on
spring that arrests and then all of a
sudden we have a REST API and it's like
okay that's not really what you actually
should do because as I said the
repository turns the egg the entity into
an aggregate root and if you have a very
fine grained table model and it doesn't
really you don't really create all
aggregated Eero n-- right
so it's a it's a key point to always
return to what's what's your actual
concert your actual conceptual model and
that's what I spent the last two days
doing actually reminding them no I don't
want to know about tables what's what
what does the model look like right and
that's a that's not an easy thing to do
but it's it's it's something you should
remind yourself of another thing that
came up actually in that in that very
workshop is bi-directional relationships
are kind of yeah problematic because
they basically mean that both both sides
have to be be governed all the time and
I'm not sure this is a is it's a Java
problem here but especially in in in JP
a code I've seen a lot of broken
bi-directional relationships that
happened to work by accident because
they were just many manipulated from the
right side but that was just because
nobody manipulated it from the wrong
side by accident basically okay um oh
yeah there was one thing to mention here
um that especially becomes important if
you if you're talking about like what
makes up a bounded context right
bi-directional relationships between
about in the context are like even a
worse version of of the that thing that
you should try to win in the first place
all right so much for the for the very
fun the fundamental things I don't want
to stretch that too long because the or
the more interesting thing to talk about
actually here is domain events so what
what does domain events means and
basically there's a it's actually the
way you express yeah events to the
domain like not not technical events but
like business events that happen to that
domain and thinking in those terms and
the first thing that you could do is
basically not do it at all alright Nets
that space that's usually code that you
that you see or if you see a code like
this it usually looks like you have a
class that has getters and setters like
domain classes and people just call
setters all the way and
these are this is the same on the same
pieces of software that usually
understand dressed as crud over HTTP
right so you you get some data you
manipulate data and you write that back
right it's basically a data basis via
HTTP fine so the next level that you can
get to is basically make the make the
operations to your domain types explicit
by exposing methods on those two main
types right there's this it's like it's
basically that's what I try to boil it
down to if you're calling more than one
setter or if you see a piece of code
that cause more than one setter in a row
you're basically missing a concept here
because you're not changing you know
poking it at the thing but you're doing
something to the thing and that should
rather be expressed as a method right um
classical example is although there's it
could be just like a it's actually just
a single setter if you change the
address on some user it shouldn't be set
address because it doesn't reveal any
conflict any context it could be like
move or something right depending on
your domain of course but be expressive
there whenever I see client code or code
that calls more than one set on on some
object that I rather introduce the
method or more more dedicated method on
the object and then change the state
internally so that gives you quite a
gives you quite a quite a quite a bit
already
the next thing or the next level here is
exposing some of these operations on the
domain model as events to other
interested interests of clients right so
it's basically you consider the these
domain events state transitions which
already brings us into the into the or
state transitions as the main events and
then that actually nicely gives us a
connection to the to the rest world here
because that already gives us a hint to
what we could do with these explicit
state transitions and how we can we we
could actually model them in
in the rest world right and an approach
you see quite often actually is to
export those events into via feeds right
so like an atom feed with the with the
with the relevant stuff that other
parties might be interested here and
like that that can be consumed you could
also use like messaging or or something
to to
inform other parties about about those
events but as we're talking about rest
here I chose the example of feeds the
the reason why I think of the the the
especial reason why I think is - it's
probably another level is that it it
doesn't have to mean that we're talking
about event sourcing on level 2 right
event sourcing is basically or CQRS or
the combination of the two basically is
taking that to to the to the level of
turning everything into into events
right so every operation is expressed as
an event that doesn't necessarily have
to be the case on the on on level 2
because in that if you're if you're
operating on that level you just like
decide okay which which of the events
are really needed to be stored and then
later like publish to two other two
other parties all right okay that's we
will get back to level two in in a few
minutes so I've spoken about like been
covering DDD quite a bit yet and haven't
like made too much connections or too
many connections to to rest yet so you
probably all know that like very
fundamental so we're talking about
resources that are identifiable
referable and they always communicated
with through representations and we use
a uniform what is it
uniform interface but the core thing in
terms of designing the api usually is
designing the representations so
basically finding the resources that we
want to expose
explicitly saying not modeling you arise
finding the resources that we want to
expose and then deciding what goes into
these resources and what we can do with
them by what we can do with them I of
course don't mean like the individual
methods to trigger because that's what
what rest already defines but from which
state into what other state these
resources can be can be yea transformed
and how to express that right so I
already made the point that aggregates
are like a kind of neat thing to look at
in the first place so assuming you you
have your domain model with let's say
like five aggregates or something
because they actually expose certain
characters characteristics like
identification refer ability and also
quite important the scope of consistency
because like changes to an aggregate
should be consistent within the
aggregate they make up a nice a nice
foundation for a resource because like
if you if you put put issue a put
request to the to the resource and that
consistency boundary maps to your domain
nicely then you don't have to think
about like explicit trade transactions
or transactional transaction resources
or process resources in the first place
I'm not saying that that is like is
always doable like just take the
aggregate turn it into a resource and
your bid will be done with it
but it it's at least a good starting
point because resources actually share
the same characteristics here like the
resources to be exposed in the api's um
right so we we got that the next
interesting thing here actually is the
the topic of hypermedia
so orders hypermedia mean I'm not coming
up with the unpronounceable abbreviation
here but it's basically serving like
data that the client is interested in
with navigation information right so
we're not returning just an arbitrary
blob blob of JSON but we include some
means of communicating links like let's
say we use hell or collection JSON or
siren or whatever hypermedia format you
want to use here HTML and the client
actually uses that information to find
out what it can do with the with with
the representation so what that what
that actually means that shift in the
client is that let's say you just write
an iPhone app and I have a have an
example of a bit of an example project
later on that's placing coffee orders
let's say you have an iPhone client with
that actually speaks with that with that
web service and I place some orders into
my into my cart and now have to like
find out okay am I allowed to or I want
to go to the checkout right and the
interesting question is how does the
client actually determine whether it can
actually do that or should present the
button to the user and the non
hypermedia
approach is basically knowing about what
the serve when the server will allow us
to checkout and code that knowledge into
the client right so we actually calling
domain knowledge into the client with
hypermedia we basically trade the
knowledge about the domain complexity or
the don't we trade the domain knowledge
with a little bit more complexity in the
protocol which in the in my previous
example basically means we're not really
binding ourselves to some knowledge
that's documented somewhere but we
actually just check whether a certain
link is present in the in the
representation and act upon the presence
or non presence of links right so the
client as we has anyone been to the
previous talk here
holy of course there were there was the
question came up with like do you
actually recommend hypermedia and the
answer as well yeah sort of people
rather like to like just get the Jason
and Paul
send it back and poke at it and stuff
that's fine but if you have to like
prevent domain knowledge from leaking
into the client then hypermedia is your
only option and it actually is is it's
very aligned to the to the notion of
domain driven design which tries to keep
the the complexity of a software system
in its very core and in that case in
case of a rest api that usually means
the server right right
so we trade this the the protocol
complexity which is of course exposed to
the client so because all of a sudden it
has to know about links and hypermedia
formats and yada yada yada
with the with the we trade that
complexity with the with the preference
or the the benefit of not leaking domain
knowledge to the client or less domain
knowledge in the client because it's
just linked present or not yeah so
another thing that plays into that is
that it's a it's just a general
recommendation I'm again coming from
that that argument that okay we just do
like our resource and then we patch it
like crazy and we just know which fields
we have to update when yada yada yada so
if you want to prevent that knowledge
from leaking into the client don't like
if some some client uses a patch method
that's very often something I look at
and see okay is that really the thing
that it should do or should it rather
like look for a link and then follow
that link and we formally describe as
the as a server we describe what that
link actually does and in which Circuit
circumstances it actually appears right
all right
the final thing on on that front is that
if you're implementing a domain model
you encode on the server then you
usually are exposed to quite a few
technical aspects that like play into
the implementation and it's something
it's a it's a good idea to actually make
sure that these technical or server-side
aspects don't leak into the client which
actually means that you have to take
care of turning them into web
appropriate
because very often times the HTTP or
like rest in general has certain means
to achieve certain things that you could
just map these server-side
implementation specific things to what
am I talking about the first thing is
that's basically the the rule I wanted
to or made up in the in the first place
it's aggregate roots become resources in
the first place and a common pattern you
see and that's that's probably a bit of
my my my flavor of the worldview here
because we're dealing with repositories
all the time they very very nicely map
onto collection and item resources to
say slash customers and slash customers
slash ID that's very very like on the
server side and the client shouldn't
care about your eyes as I said but from
the server side design point of view
that's that's a very nice match the
relations between or to other aggregates
become links in the representation
that's actually what I don't want to be
too implementation specific here but
that's what spring there the rest
basically does right it analyzes your
your it finds out about the entities
that are managed by repositories and
whenever a domain object refers to
another entity that's repository managed
it becomes a link instead of being
embedded and that naturally forms those
like aggregate representations and and
the using using hypermedia aspects i
show you an example in in a bit a very
important thing your eyes are your eyes
are your eyes or IDs our IDs are IDs
there's like tons of tickets going or
being opened in spring an arrest had
asked for why is the database identifier
not contained in the representation
because the resource is identified via
its uri as the name suggests pretty
simple but the the more meta story here
is that there are some some properties
in your code or some some some artifacts
in your code they actually belong to a
very like
door specific like implementation or
whatnot and they shouldn't really appear
in the in the in the representation
right because they would actually leak
information here the same goes with the
ad version properties in the for those
of you not from the Java space JP a or
the Java persistence API has a has a
mechanism of doing optimistic locking
right the the the the server counts up a
version for every safe operation so that
when you when you read an entity let's
say I get customer with version one then
someone behind my back updates the
customer that makes version two on the
server and I send I want to update the
customer then again with me sending
version one that will get rejected
because yeah I basically send in an
outdated version the thing is that stuff
that shouldn't necessarily make it or
shouldn't actually make it into the
representation because there's an HTTP
HTTP mean for that or some some way to
actually represent that which is
basically e-tax
so that you can use conditional get
requests or as I've just outlined the
update scenario conditional conditional
put requests right so we basically move
stuff from the domain object into the
appropriate in this case HTTP headers
the same goes with yep the same goes
with a last modified property so there's
means in in in spring data in this case
to automatically get the last modified
property set and we turn that property
into into the last modification header
that's basically the sort of D that's
the same thing you alright um so it's 30
minutes to give you an example of what
this might look like in like put into
code I created
or actually a long time ago I created
this thing there's this book from Ian
Robinson Jim Weber and that guy I'd
always failed to pronounce correctly
siwash passed adidas or something
O'Reilly restful Web Services is that
that one I always mix them up arrested
practice thank you for that the other
one is good too so don't want to offend
anyone here it the the core of that of
the book is as I said this the Starbucks
kind of shopping experience and modeling
the the ordering flow of that of an of a
shop like that in an API and it has a
funny or kind of interesting it's an
interesting example because it's very
tiny it's very easy to look at because
every time I mean everyone can relate to
drinking coffee or tea or what have you
and it's very it's nothing fancy to it
but it contains quite a lot of
interesting aspects of a more complex
API it's not just like it's not just
crud over HTTP right so that that here
the or that that's kind of state diagram
is basically the the order flow right we
place an order that state transition one
while the order is in the in the state
of payment expected I can update it
which is which is that actually that
part where some sort of crud operations
are just fine right because it's it's
just basically that that very it's that
very returning to the same state here
and we're just updating a could update
at new at new drinks to the order
what-have-you
you could model that through an explicit
state transition of as well but in the
implementation I just go with with a
post or patch patch request in this case
but then there's like two interesting
state transitions the one is like
canceling the order and one is the
paying in this case which puts the order
into a kind of preparing state then it's
it's processed in the in the background
basically until it gets into a ready
state and then I explicitly have to
acknowledge that I received the order to
get it into into a completed state so if
you just go ahead and naively model that
with or let's say even you could model
it this way right
or even like document it this way which
you probably don't want to do because
you expose your eye patterns here which
something that you probably don't want
to do and the even more interesting
aspect for for this scenario here is
that you there are certain constraints
to when you can interact with which
resource in in which way right so you
can the you can you only allow to
trigger the payment if the the order is
in that particular state right and if I
take that kind of order or that
description of API as a client developer
I basically had now have to go ahead and
say and see find out what does payment
expected actually mean and then I have
to probably inspect the representation
for certain fields of certain values and
what-have-you and all of the stuff that
I need to bake in to my clients to know
when I can actually present the button
to eventually issue that that rest call
here so if you take it slightly
differently and just declare resource
types and say okay whenever you find a
payment link or relation types in this
case because yeah whenever you find a
payment link you can just like issue of
course a put request and then you have
to define the the paid out that needs to
go with it and then you submit the order
and that actually brings you very much
closer to D to the to the actual domain
here and the the implementation of the
of the domain meets bring rest box
that's just like the there's an
implementation based on jax-rs in that
in the very book i took the chance to
basically see okay what would the
implementation look like if we build it
on the spring stack and then was
basically going crazy with using like
all the spring technologies that could
help me doing that at it's very core
it's basically just like spring data on
the on the persistence layer probably as
expected which basically means
everything that's white here is we don't
write any implementation code that's
just like interfaces
the service layer for the for the orders
management part that's that's why I
mentioned that before is we use spring
in arrest on top of the repositories
directly which basically means we get
all of the crud operations out of the
box but we take the time to manually
implement the payment process because
that is the core of our API and we want
to use the hypermedia the advanced
hypermedia means for that and so the the
idea of spring and arrest is because it
takes away the pain of of all the the
standard stuff you want to have like a
post to create a new entity
what-have-you we take the pain out of
the the standard and boring stuff and
allow you to basically concentrate on
the more advanced stuff which means
modeling your hypermedia transitions and
yeah making it easy to build the stuff
there's a a certain shade of green here
which means that we tweak the output of
spring that arrests and basically tell
the the the framework that it should
include under certain circumstances
include certain links so that these link
these links then point to our manual
implementation of the of the arrest web
service I show you the the the example
in a second just to summarize a few
parts that you should look at if you
look at the code I try always try to
keep the Jackson customizations which
means Jason customizations to non-driver
people separate from the domain model
it's too easy to just like annotate your
domain classes with a chase and ignore
and stuff you can always externalize
that and that's what I really try to do
just to not mix the representation
specific parts with my core domain we
use spring data for the cruddy parts
that's what I just mentioned and the
other interesting or most interesting
aspect for that like discussion between
like okay what's what does the domain do
and how does it actually play into the
design of the rest web service is the
resource processors that's an API which
basically allows you to tell spring data
rest
whenever you render in order please call
my code beforehand and then I I can
actually add some links to the
representation whenever I want the codes
on github of course let me show you that
thing it's a spring boot app that's just
the best way to build Java apps these
days probably not surprised to hear that
from me I run this thing first yeah run
it java application it ships with the
hell browser that's the nice thing with
that's we are not not something that's
that's something that I actually built
here in the pond that's why I have it
open so I no no no
that's probably just what's going on
there sir how much time do we have ten
minutes there's some Java process
running somewhere it dunk it doesn't
like if you if you have a running have a
running instance of it and put your
MacBook to sleep yeah you look better
all right
so that thing here is that's a good idea
thanks for that's called crowd computing
in case you haven't heard of that
localhost:8080
so all right
hella browser is anyone ever does not
does anyone of you not know what the
hell browser is a few hands okay it's
worth mentioning then let me just go
back here and say HTTP HTTP
increase that a bit 80 18 so the thing
actually exposes a Web API that uses the
hell format that's what spring that
arrests out of does out of the box and
how the format that just like defines
what links look like in in JSON and by
the virtue of that you can build an
application
what the hell browser basically is that
understands these links and presents
them into in in a nicer format than like
just looking at raw JSON which is
basically the stuff down here right so
the hello browser interprets that format
and sees okay there's a rest box orders
link that has a title so in that case
it's internationalized and says like C
or C or create orders basically because
I'm using a German browser that's why
German here and then you can follow
these links by just like clicking these
buttons here that makes it a bit easier
to play with your with your API and you
don't have to pollute your code with
bloody swagger and notations so yeah
that's the let's see that's the an
individual in a table individual order
here so we are exposing a collection
resource for orders I follow the link to
orders and get like the two of them I've
created two and I can just follow that
one the self link here nope that wasn't
quite right did that break something no
what was right okay I just got messed up
in D and you are here so as you can see
the the the service exposes certain
links in this case the the payment link
which I killed like issue a put request
to then and basically submit my submit
my credit card and if I do that it
basically brings the order into a new
state that doesn't actually contain the
payment link anymore I've created a test
case for that which we could briefly let
me just kill that thing and run the test
case instead that actually and that's
kind of neat to see I guess
we're doing a 4-step thing here we
create a new order so issue a post
request then trigger the payment which
is done by finding the pain like we
discovered the link with a certain
payment so the test case basically acts
as a as a rest client here we discovered
the payment link assert that it's been
given and then I post or I put my very
secret credit card information to that
very very to that link that I've just
found here the payment link right and
what I'm then doing and this is because
it's a test case I basically try to
delete the order so I pay first and then
try to cancel it effectively and then
make sure that I just get a no method
total out in this case here let me just
run this thing real quick for you I'll
access first order that's not it
where was it screen resolutions run this
thing that's kind of probably let me
just bring down this the resolution or
the font size a bit what does actually
do that should still be readable right
yeah even better so you see where we're
trigger that we're discovering the
payment link here that points to a new
order here and then trigger the payment
and start the process in the background
and then pull the the server for the for
the result of of the order there's a lot
of api's in here that make that happen
or i mean the the the order the order
subsystem basically the the left column
of of the of the diagram you saw before
is basically that it's just like a few
domain classes that of course used
Lombok and expose a repository and the
integration for the payment stuff
happens through that payment ordering
resource processor so case you may want
to look into this thing that's that's
probably the the interesting part
regarding hypermedia because we we
basically get the order before it gets
rendered and then
links to the to the to the to the
controller to the payment controller and
you see that's like driven by like state
of the order and if the orders paid we
just like at the payment link in yada
yada yada
so yeah it's a bit of a bit of a toolbox
that allows you to start with it with a
like deeply defined to main model expose
your aggregates and then tweak stuff
into it and use that that domain co2 to
transport stuff into into the HTTP
representations codes here any questions
one question in the back I can repeat it
that's fine
okay yeah the question was ok what about
event sourcing and events are saying how
does it works right so that was the
thing the reason I didn't really mention
it because it's definitely worth a talk
on its own the other thing is that it's
not really part of DDD so it's it's not
like it's it's usually like a
consequence of taking the inventing
model to it the very extreme but it's
not actually part of the core book I
looked it up so it's it's kind of kind
of interesting event sourcing sword as a
the the concept of working with domain
events is but the implementation way of
like put having a dedicated event store
and stuff this is not the there's no
support in in the core Spring Framework
dedicated to that there is this
excellent framework have you heard of
that one
there's it's a spring based framework
that actually takes the concepts of an
event store and provides you with AP ice
that allows you to like like capture
domain events store those and then
easily create a read model from the from
the from that event store and and then
use that on on read requests but there's
no dedicated integration with that the
thing is that even with the event with
event sourcing you basically come to a
or you come to a point where you where
you have to find out which are the
important events that you want to
communicate to the client that it can
basically like the state-transition of
triggering a payment right that's that's
an import important event and you have
to communicate that to the client
somehow whether you implement that on
using a the consuming that event using
event sourcing or just like with plane
repositories doesn't really play into
the way you expose your rest web service
so because of that the level 3 was at
level 2 in in in my leveling model there
was to me was the more important one
because if you if you make certain
events or the the most important events
that are the most important ones to your
clients explicit in your model it's very
easy to put some some hypermedia means
on top
of them to express them to the clients
right that was the the reason I didn't
really go that step further it's just
like it doesn't mean it I don't think
it's worth doing it or something it's
just like okay I don't want to over
complicating the topic here in this case
yep well that doesn't isn't really a
question of DDD in this case because
like put requires you to update the the
entire resource and the question was for
the audience when would you use patch
versus put patch is usually used for
like partial updates and there is some
media types like Jason patch and Jason
merge patch to actually Express changes
to an object or a document graph yeah
the reason I don't I liked patch because
of its flexibility but I don't like
patch because people tend to overuse it
to poke at stuff and like arbitrarily
change things which is basically the
opposite of what I try to communicate
here no of course of course not do you
recommend API versioning I think the the
key aspect of rest is and doing rest in
like doing rest with hypermedia is
actually kind of idiotic because there's
no rest without hyper media but the the
a lot of aspects of rest are giving you
or the consequences of doing rest are a
lot more flexibility in terms of
changing your API or yeah evolving your
API that's basically what you get from
that extra effort of using hyper media
and that means you are less likely to
run into a situation where you need what
people usually consider as versioning an
API right so like either by a media type
or your eyes or whatever means there are
so you don't want to do that because
you're in every inevitably breaking
clients with that and that means effort
or and that also means effort in
maintaining different versions of an API
so
if you don't have to don't do it oh it
was too quick okay for your question
okay
so what was the pointing in like yeah
yeah of course yeah that's a good point
so did the DVD parents don't really
discuss the aspect of versioning yeah
yeah of course
yeah yeah yeah yeah oh the question is
where is the weirdest business logic go
if you use printed RS because it
basically takes it takes post operations
to create stuff and it supports like
delete if you have a delete on your
repository and whatnot so there are
basically events that spring that
arrests fire so whenever you a resource
is about to be created
you get the resource before it actually
gets handed to the repository so you can
sneak in or plug in some some validation
logic there of course which is something
that that's usually always in there it
respects security spring security
annotations or out-of-the-box but so
there's the events Rd the primer primary
means to like plug-in just like Java
based business logic what you can also
do is just like selectively override
resources right so we could just like
plug in your own spring MVC controller
and say oh by the way I want to handle
put requests for orders myself and then
just do what the heck you want at that
point
let's let's have that yeah strict answer
yes it is I
I wouldn't want and I think I had it in
the in the in the talk in in the rest
world the things that you know about are
you arise and as the name suggests
unique resource identifiers these are
the things that you should identify your
your resources with everything else
needs to be like done using like career
resources or something so you find
something buy something and that's much
more effort because you basically know I
have to know about your right template
have to expand to your right template
you have to know to which which property
to put in there so of course you can go
ahead and expose in your right template
that just takes a database identifier
and then looks up a resource instance
from that but that basically means that
the client knows about that thing being
an identifier that part of the object
being identifier or that property and if
that's not the case I just like to not
tell the client that's that's basically
it if your eyes are sufficient like and
they should be usually alright
I can I mean
gotta catch the train but we still it
was there time okay interesting question
so what how do you actually like my
return limit your your scope of of
properties you can always take used
lectures they did in in this case the
Jackson customization Jackson
customization so you can add ignore
education ignore fields there's a
dedicated concept we have in the
framework for projections so you can on
the server side define an interface with
only the properties you want to expose
in a certain case and even enrich that
with with like calls to other spring
beans to enrich your representation if
you want to so the other ways around
works well as to and and then the client
can actually ask for the for that
particular projection as we call it so
you can have a customer excerpt and
stuff like that but that's probably like
taking too long to explain in detail
there are means to it and it's an ik
something that we tackle up explicitly
so there are SP eyes for that that's
fine instead of flex in an envelope
representation I'll be back to soap
every back to soap now is it your
question yeah that's that's maybe I mean
yeah I haven't shown you the the
representation actually there is
additional information there is still a
field that says status in the
representation status payment expected
the thing is I don't want the client to
know that this is it's it's that's stuff
for him to display for for it to display
but not to like decide when to do what
right so if it's if it's very clear that
the links are the things that decide
what what to do with that's a lot less
information because then I can change
the status field to to something else or
what-have-you but if it if it doesn't
like build on that property to to to
decide when it displays which button my
API it's a anyone yeah it's very very
yeah I don't think swagger is a good
idea to phrase it politely the reason
for that being that I mean hypermedia is
not a topic for swagger they there was a
ticket foot to add support for that they
outright rejected it so that's that's
the one side of the story the other
aspect is if you've ever done like this
or done swagger documentation and use
the annotations in your code it's
getting annotation hell really quickly
and I've seen a couple of examples where
they spend like 10 lines of code a
notating which status codes could be
returned and like from the method and
then in within that very method they
returned a different status code so it
basically suffers from the the Javadoc
problematic basically the the
annotations getting out of sync with
what what's actually returned the
solution to that is I think actually
writing test cases for your for your
restful Web API and using the test cases
to basically document what the test does
right because that's what what you do to
your API in what's proven to
work because otherwise the build would
break guess what there's a spring
project for that spring Red Sox it's a
very young one admittedly but it does
exactly that so you could use and that's
actually what the author of the project
Andy is currently working on putting
taking that spring Red Sox thing and
just manipulating that that has slightly
to produce some documentation output it
will produce a asciidoctor by default
and can then be included into some
manually written asciidoctor
documentation spring restaurants that's
the that's the link that I want to give
you so thanks for attention and have fun
at the conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>