<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • iOS Animations with Auto Layout • Marin Todorov | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • iOS Animations with Auto Layout • Marin Todorov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • iOS Animations with Auto Layout • Marin Todorov</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/N5Ert6LTruY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">(calm piano)
- Alrighty,
the hour is half past three,
and we can start with
animations with Auto Layout
and stack views.
A little bit about myself,
I'm an independent developer and author,
and I split my time in
between my own little
studio for making iPhone apps,
and working on a website
called raywenderlich.com,
woohoo!
Where we write tutorials,
write books and so forth, and so forth,
it's really cool.
And, since in the beginning of this year,
I published a book called
iOS Animations by Tutorials.
Which is my fantastic
book about animations
on iOS, and I wrote an
animations newsletter,
it's a monthly newsletter on animation
so I do crazy stuff once
a month and send it around
for people who are
interested in animations.
That's why I'm here today
to talk about Auto Layout and stack views.
We can get started.
Animations are fantastic,
especially in iOS 7, and iOS 8, and iOS 9.
Why's that?
Because we don't really have
these rich user interfaces
anymore that have
the wood background or the
steel concrete gutters
and things like that we used to have in UI.
Right now it's mostly text
and text with color.
You have to find new
ways to put your brand
up in the front of everyone
and make your app distinguishable
from other apps.
For example,
this screenshot here
could be one of the built-in apps
eventually that comes with the iOS,
or it could be a custom app that somebody
invested hundreds of hours into designing.
But you can't really
tell right away,
so it's really difficult.
And if you could see how the UI interacts
with the user, and how
the UI reacts to the
user interaction so forth,
maybe there is a delightful—
I don't know... maybe the
handset is jumping a little bit
when you press it, or maybe the
word balloon flies
away when you tap it
or something like that.
This is a really easy way
to distinguish that somebody
put a lot of effort into this app without
having all the
old-timer visual interface.
But, you can't really say that right away,
and animations are really an amazing way
to really make your app unique.
This is the built-in
contacts app in iOS,
but you couldn't really tell
because
it's really about white
space, really about text,
it's really about the color.
Animations are fantastic because
if you have ever written
an app on iOS
you have done
at least one single animation
because it's so easy.
This is how all animation
tutorials start...
with the red square.
Sometimes the square is blue
but it's mostly red.
And then the square moves a little bit
along and there's a single line of code
and people are really impressed,
and they're like,
&quot;Yes, I can do animations in iOS,
because it's just one line of code!&quot;
It's animateWithDuration, you say
how long you want the animation to go,
and then there's a closure where you say
what kind target
final values
for the animation are.
And then, this super
super smart UIKit API
will take the current values, for example,
in this particular animation will take the
current position of the red square
and will create a little
animation over one second
and will move it to

on the x-axis to value of 200.
It will look something like this.
Ta da.
That's pretty cool.
Everybody knows
how to do that on iOS.
However,
things change over time.

That was fantastic when iOS 3 was out,
and that was fantastic when iOS 4 was out,
and that was fantastic when iOS 5 was out,
but then we started
having different screens.
Bigger screens, smaller screens,
split screens, view
controller containment
and things like that.
Moving the red square to
the point 200 on the x-axis didn't really
mean much anymore.
Before having different screen sizes
it was predeterministic, you
knew where the screen starts,
0.0, and then
you moved it 200 points
to the right, that was perfect.
Now, with 6+ or 6, or 5S or whatever,
you don't really know
what it means to move to point 200.
It might be really close
to the edge of the screen,
it might be
straight in the center
of the screen, it might be anything.
And it really pains me—
(clears throat) Sorry, it really pains me,
oh my god, okay...
Emotional here. (laughter)
It really pains me when people
have a problem of this sort
and would run off right
away to Stack Overflow.
And we'll say how to do
this one animation thing
in my app because I don't really get it,
and people will say,
&quot;Oh yeah, sure include
this Bloated.framework
by somebody and paste this code!&quot;
And then sure accept it, it works.
But, that's really not
the way.
It hurts when you—
If you start arguing with people
on these kinds of websites then it's
even worse than
doing nothing. It's always
a question what to do.
But anyways, you shouldn't do it.
My point is that
it's better to understand how things work
and why they happen because then you
know what to do the next time it happens
like that.

Let's get to the questions.
&quot;Animations, y u no work?&quot;
They no work because
Auto Layout is different than
pre Auto Layout.
What do I mean?
Time for a quick demo.
The session's going to be
less slides and more
showing things on-screen.
Eventually and
hopefully you will know how
things work by the end,
and you know how to
approach them, and
how to create animations
with Auto Layout and
further in the session
with the stack views.
Here is my storyboard
and as its present day application,
I'm using Auto Layout.
Not really fitting into
this kind of resolution,
but still you can see most
of it which is enough.
What I have in here,
it's a login screen for
an imaginary app.
And I have the username
and a password field
here in the top because I
have the idea to animate them
towards
the center of the screen
when the user opens the app.
And I have a little
button here which says go
which will do the login, for example.
I have laid out everything
in Interface Builder. I've centered them
and then I put in some constraint here
on username and password,
and that's pretty awesome.
And then, let's imagine I'm going to Stack
Overflow, and I see there
Super Awesome Ninja Dev
has answered my question,
&quot;Oh yeah, sure,
call your animation with duration
and then change the center property
and that should work.&quot;

I go to my code here
in view to the peer
where I'm going to try what
Super Awesome Ninja Dev
recommended. I'm going to put in
UIView.animationWithDuration,
with
half a second duration.
I have two outlets here,
username and password.
I'm going to try to
animate their
center property.
Password, center Y.
I think 200 points will be enough.
And then because I already feel
very advanced in animations
I'm going to add a second one to animate
the username field,
with a little
bit of delay afterwards.
These are the standard built-in
API's, nothing really fancy happening here.
Just running an animation
on the username field.
Okay,
self.fldUsername.center.y
Okay.
Real quick.
One moves down then the
other one moves down,
then it should look pretty awesome.
It does look pretty awesome.
They're still not really visible because
I made them
not fully opaque.
I'm going to make them opaque as well.
Let's do also this.
Alright, you're happy,
you're coding, everything is perfect.
I'm going to also
show it anyway.
And now my transition is perfect.
Auto Layout is not really bothering me.
I change the center property
and it's all pretty good.
Then, I run away to Stack Overflow,
accept the answer
from Super Awesome Ninja Dev,
and then I say,
&quot;Okay, now I have to do the login part
of this.&quot;
When I try to enter the username,
then we have this.
There is the problem.
As soon as I focus on the text field,
everything jumps up.
We can see two things happening.
First the fields repositioned
to where they were originally.
Second, they did not
fade out as they were
originally. They started from
barely visible and they're still
fully opaque as I animated them to.
It looks like this chain—
this animation here was reverted,
but these two lines were not reverted.

That is because it's really
important to understand
what Auto Layout does.
As the name suggests,
it makes your layout
automatically for you.
It takes
care of your layouts for you.
And here you went over its head
and changed the position of these views
manually, and that was not really good.
And you changed the alpha manually
and that was okay, because
the alpha is not really
part of the layout.
It's not really positioning
or sizing or anything.
First moral
of this talk is
not everything changes
with Auto Layout.
Not everything about animation changes.
It's not really a whole new world.
Was it a brave new world?
It's not really
a brave new world.
It is about positioning and sizing
because this is part of the layout.
If you animated the alpha, if you animated
background call
or something like that,
that's fine. That still
works in the old way.
What does not work in the old way
is changing the center manually.
But you'll say,
&quot;No it kinda works.&quot;
It does work.
It is not like it does not work,
it's that it doesn't really
work forever.

This is the really important thing
that I want you to
understand in this talk
and then from then on everything
is going to be really easy.
The question is why did it
jump back like this when I tap
into the text field?
This is a really simplistic
explanation of how Auto Layout works.
We have your views on the screen.
There will be buttons,
there will be labels,
there will be images,
and things like that.
When you lay them
down in Interface Builder
and you set up your constraints,
you're attaching
a list of constraints
on those views that explain
the relationship between
them, in between the views
and between the views and the container
of your view controller.
Which, on the iPhone is usually the screen,
so in the end everything depends
on the size of the screen.
For example when
the keyboard jumps up,
or maybe when the call is incoming,
then also the size of
the container or of the
view controller changes as well.
308
00:12:56,182 --&amp;gt; 00:12:58,400,
Let's not jump too far ahead.
We have a list of constraints
and those constraints, if
you go to the documentation,
NSLayoutConstraint subclasses
NSObject.
It's not any kind of
visual class. It
doesn't really have the tremendous logic
behind it. It's just a model.
It contains few properties that
define
an equation like that so you can
set rules like buttons should be
always centered. It should be always
positioned in the middle
or the center of the
width of the view control.
Or maybe this button
should always have the
same position as this other
button. This is
expressed in this equations,
but what is important is that
these constraints you design
in the Interface Builder
are models, data
objects that contain
few pieces of information.
They don't really do anything
with UIKit.
I mean they don't really draw
anything, they don't really
move your views.
What moves your views is Auto Layout.
The app
structure for Auto Layout.
It would
be more precise to call it
UIKit, but let's call it
Auto Layout for this purpose.
When things need to appear
on screen or things need
to find where their spot is on the screen,
Auto Layout grabs this list of
constraints, solves
all the equations
and finds where all
these views should appear
on the screen. What
this produces is that
it will change the center
and the bounds of your views.
Really simple.
If you look at the
list that I have there,
there's all kind of constraints.
There's width, height,
center x, margin y, ratio
between width and height,
vertical space and
vertical to margins, and all kind
of constraints. But, when
Auto Layout solves all these
rules that you set up, what
it ends up with is
changing the position of
your views and their size.
This is all it does.
All it does is change
the size and the position.
And of course, when it does
that, this reflects in your
views being repositioned, resized.
And this is all Auto Layout
does. That's really crazy.
All it does is just sets
the size and the position
of your views.
Now that we know this,
things get interesting because,
the next thing to look at is,
&quot;When does this happen?&quot;
Why did fields change
position when I clicked
into the text field.
Auto Layout reacts to
internal and external
changes to the layout.
Internal changes will be
if you change a constraint,
or if you remove one of
the constraints, or if you
do something from code, for example.
And external changes can be
if the
user rotates the device,
then also the size of the
view controller changes.
That will be an external change.
Auto Layout only reacts to those.
When you load up, let's say
that you push a view controller,
and this will be
its life cycle. When
you push it, first
it loads
the view from the story board.
And at this time, Auto Layout
needs to solve the layout
so that it knows where to
show things on screen.
Pretty cool. We do one pass
just like I showed you
on the previous slide.
It solves all your constraints
and finds the position
of all the views.
And then, nothing.
Then it's like calmness.
Nothing really much happens.
Things are
positioned, they don't move,
and here you can jump in
and change your center
with no problem.
However, if you tap on a
text field, for example,
like I did, then the keyboard
will pop up and this will
change the size of the
view controller margins.
This will trigger another
pass on the layout
and Auto Layout will
have the orientation change
here, but same thing.
Auto Layout will get again
the list of constraints,
calculate them based
on the container size,
and then reposition them again.
If you changed the
frame or the center of the views,
this change will then be
reverted to what the
constraints say that the
position and size will be.
As said, this could
be an orientation change,
that will trigger a pass like that.
Or, a keyboard pops up. This will
trigger another pass from the layout.
If you change one
of these constraints yourself,
that will trigger a pass.
That's why
this example worked with the
fields going down, because
load view has happened.
The app loads the story
board, shows them where
they were supposed to be,
then I animated them down
myself so this doesn't
really cause any problems.
But then, since the margins
changed when you pop up
the keyboard, Auto Layout
did another pass, recalculated
all the constraints, and
since the constraint
did not change, it moved the
fields back to where they were.
You can
jump in between these
and do some
little adjustments to center,
but then again,
when anything changes
those will be overwritten.
Okay, what can we do
to do proper animations?
Well...
We have a look at
how a normal animation looks.
You change center, or frame
in your code, and that happens instantly.
As soon as you
change the center of a view
it just appears in that spot.
And then you call
animateWithDuration which is
the normal API for me.
Then, anything you do
within the closure that
I put in the yellow background,
all these changes you
do are then animated.
The difference between
these two lines of code
is that one is in the animations closure
and one is just not in
an animations closure.
All changes you do
from within the closure
are animated.
And
there's a list of the
animatable properties,
things like alpha,
background caller, position,
size, and so forth, that
you can change within
the closure, and that will
be automatically automated
by UIKit.
This is what you
hopefully have done before.
What you can do from Auto Layout,
is—you know how this works.
We already said that
this is the way that it works.
Now we need to make the connection that
a pass on the Auto Layout
takes all the constraints,
recalculates them and
changes center and bounds.
Center and bounds are
animatable properties.
We're getting really close
to what was happening
before. What
we need to do is change the
constraints, and then from
within the animation block,
force a pass on the layout.
Within the animations
block, say to Auto Layout,
&quot;Hey, take the list of all constraints,
find where my views should appear now
with these constraints.&quot;
And since Auto Layout only
does change to position
and the size of the views
and those are animatable,
then this will help in an automated way.
Your task is find
constraints you want to change,
change them as you want, and then from an
animation block, trigger a
pass on the layout.

We establish all this,
but let me quickly show how to do it
from code.
This my next
example for showing constraints
and how to animate them.
I have a little app
with a little list here.
It's a to-do app.
And I'm having this top bar in here
which I want to resize dynamically.
To show you the premise,
let me open the story board file.
Okay, it's really easy.
There's one view on the top
and one table view on the bottom.
The top view is
pinned to
the top, the table view
is pinned to the bottom, and then they're
pinned to each other.
I have the height
constraint of this one
that says that it's
going to be height 60 points.
And this is my...
This is my app running.
What I want to do here
to show you how things work
is I'm going to click on the plus
button, and that will enlarge
this top bar and you'll see more UI
in there and so forth.

There's two ways to animate constraints.
Both are very easy, so
I'm going to start with the
first one.
The first one is when you want to change the
constant of a constraint.
Let me open the properties here.
Okay...
Here all the constraints that are applied
to my little bar here,
but I'm really interested
in the height. The
height is set to 60 points,
and when you edit the
constraint you can see
that it just says 60
points and that's it.
It's a hard set height.
I want to change the
constant to something else,
to the value of 200
or so, to enlarge
the top bar.
It's really easy to do
that. I knew which one
constraint I want to animate
so I'm going to go
to my view controller and
I'm going to make an outlet.
Since
constraints are something
that you lay down in Interface Builder,
then you can also make outlets to them
and then use the
outlet to access them
in real time. It's pretty simple.
I'm going to put in an IBOutlet
called menu height,
and it's going to be of type
NSLayoutConstraint

Like so.
And then any other button view,
text view or whatever
you're used to doing
to be using by outlets,
you can go to the story board...
Find the height constraint, there it is,
come to the Connections Inspector,
and then drag from the
new referencing outlet
back to view controller
and connect your outlet
to the constraint.
Now your outlet
points to the constraint,
and you can access it in real time.
Really cool and really simple.

I think I'm not going to have time for
everything that I had in
mind, so I'm going to
skip through a few things.
This action is already
connected to my plus button,
Here I can say menu height,
constant, which is the constant
from Interface Builder,
equals to something else.
I can say, equals 200, like so.
And what this will result in is,
as soon as I click it,
nothing much happens.
That is not what I wanted.
Maybe this is not—
Yeah, looks like it's not right.

Oh true it's not connected, okay.
Thank you.
Okay, as soon as I click it
then it takes the new
height into consideration.
I changed the constraint,
and this is a change that
will not be undone randomly,
because now the constraint
says that it's going to be this height.
But, we want animations right?

Since we can control the
constraint now, the animations
are really easy to do.
Wrap it up with the ration call.
It also can be a Spring
Animation. Let's do that for fun.
I'm going to use a Spring
animation.
This is the default UIKit API, again.
Nothing really crazy going on.

What I said on my slide
and I'm going to stick to it, was
changing the constraints anywhere in code,
and then force a pass on that Auto Layout
from within the animation block.
The layout pass
is the one that changes
the center and the bounds and so forth.
Changing the constraints
doesn't do anything. It does not
do anything.
Having a pass on the layout and
layout changing center and bounds,
this is what does something.
Let's do exactly this.
My
constraint here is updated,
and here from the animations block
I'm just going to say,
&quot;View layout if needed&quot;
which will force
Auto Layout to immediately
consider all constraints,
and if anything changed,
then recalculate everything and change the
position and size of views.
That's why it's called,
&quot;Layout if needed.&quot;
Because maybe you didn't change anything,
then it will not do anything.
This time, when I click it,
then this change in the
constraint is already animated.
What is really important here
to note is that
I don't animate anything
on the table view.
I have only one line
that changes the constraint
on the top bar. I don't really
tell the table view to do anything,
but...
since the top view and
the table view are pinned
together,
changing the height of
the one also changes
the height of the other.
I don't really do
this explicitly, I
leave Auto Layout to solve all the rules
that I laid down. And
since the rules that I did
was so that they stay
together, that changes both.
Also the changes
to both are animated
because
their bounds were changed
from within the animation block.
This is really
easy and now you can do
all kinds of other stuff further from here.
As long as you know why
the animation works like that,
then you're on a good way to understanding
how to do more complex stuff.
The second thing I
want to show about constraints
is—
It is simply amazing
when you have to change the constant on
a constraint, so as what he had now.
We had a hard set height of 60 points
and we wanted to make it 200.
And this is really easy.
I want the constant to be this value.
And then trigger an animation,
All is great.
The problem is
if you want to change the multiplier
on a constraint.
If you say,
&quot;I want to change the multiplier
to 1.5 or whatever.&quot;
The multiplier is
read-only.
You can change constraints
that are hard set values, but you can not
change constraints that say,
&quot;I want the view in the middle
of the screen.
Or if I want the view in one third height
of the screen&quot;
because those constraints use multipliers,
and you can't really change them.
What should we do?
The only way is to loop over
all the constraints, find the one you want
to change, kill it, and then put in
the new one on its place.
Let's do that.

It's really easy.
It's not a problem.
As I said, both ways are really easy.

I want to move the title
a little bit to the left
when the menu opens.
And this is great because
the constraint that
I'm going to be animating is called
align center to x.
And align center to x
has a constant of 0
multiplier 1, and
that positions it in the
very center of the top bar.
In Xcode 7, there
is a new field when you are editing
your constraints, called Identifier.
Identifier is a way to give your
constraint a name.
This property also existed in iOS 8,
but Xcode 6 did not have
this little text box.
If you're still using Xcode 6,
everything I will say is
valid, you will need to
use the user definer and time attributes
to set identifier.
You will have to say here
identifier string, and then
set the identifier like this.
Since Xcode 7 is now stable,
I'm going to use the built-in box now.
Again, this is still
possible with Xcode 6,
you just need to set the
identifier in different way.
Identifier is just a
way to give your constraint
a name. This is great
because you can
loop over your constraints,
check for the name,
and then find the one
that you want to kill.
I'm going to call this center
and now I can find it and kill it.
If I do a print here
and print all the constraints
on my view
to make sure everything works.
When I click it, okay—
That's ugly.
Sorry.
I'm going to write a
for c in view.constraints...
Then print c like so.
This should do it.
Okay.
Here all crazy kind of constraints
that are defining my layout.

I'm looking for the one
I'm interested in.
Too many constraints.
Too many constraints.

Let me do something else.
Title, label, super view.
This should give us only the constraint
that concerns us.
Really?
Okay.
The important thing is
not to lose heart, to keep trying.
(laughter)
Okay,
this will give us
the constraints we are interested in.
Then, we have this
cryptic summary from Apple
that tells us what these do.
You can notice that one of them
says center, and
that's the one that I want to find
and use. This is really, really useful.
What I'm going to do is—

if the one that I'm currently looking at
has the identifier off-center,
then set its active
property to false,
which will remove it from the layout hierarchy
and totally kill it.
If I
click now,
as you see it moved to the side
because there is no
horizontal alignment anymore.
This constraint is
not being considered
anymore in the layout.
It loses its
horizontal alignment is
to the side.

Now, it's as easy as
creating a new constraint and
setting any constraint you want from code.
I'm going to do this real quick.
NC is going to be my new
NSLayoutConstraint and we're
going to use Auto Completion
for the 20 parameters
that come in afterwards.
I want to apply this constraint
on the label.
Pretty nice.
I'm going to change the
center x constraint,
also pretty nice.
I'm going to use an equal,
so all of this is the code that
Interface Builder writes for you
when you create any constraint.
You can be only happy if using
Interface Builder.
Quickly, I'm  going to recreate
this one and change
the multiplier.
I'm going to say 0.5
to move it a little bit to the right.
Any constraint that you want to do
and you've done many times,
and if it's blue we can also create it
from code like that.

This new constraint, the
only thing you have to do
is set active to true
and that will
force Auto Layout to consider it
on the next pass and add
it to the layout hierarchy.

This one kills the old one,
this one creates a new one,
and this one says,
&quot;Okay this new one should be considered
in the layout.&quot;

That's all it takes to
animate a constraint
like this one.
(inaudible question from the audience)
Sorry, to add it?


I see where the confusion comes from;
I hate Apple for doing this.
Usually in Cocoa you
have to set delegates,
you have to build relationships and things
like this, but not with this API.
With this API,
as long as you set active
property on your constraint to false,
next time Auto Layout does a pass,
it will say,
&quot;This constraint is not active,
I don't need it.&quot;
And we'll remove it from
the list of constraints.
And the
constraint
will lose everyone who
retains it, and will be killed off.
This line here is the death sentence
for this constraint. That's it for it.
It's over.
If you don't retain it in any other way,
then it's over for it.
Then the same thing when you are
adding new constraints, this one creates
an object that just
hangs there in the universe.
Then, when you set active,
the next time Auto Layout
does a pass, it will say,
&quot;This is active.&quot;
It will add it to
the list of constraints
and this will retain it.
Since the constraint already has
an idea which are the two views that are
concerned with it, that's everything you
have to do.
This is the way to kill one,
and this is the way to
add one like that.
This is pretty much
all.
There is an API that is a static
method on NSLayoutConstraint
where you can add
more constraints at the same time,
but what it does is
go over all of them
and set active to true.

That's it.
When they click here now this one,
then the packing list moves to the right
because I just increased the multiplier.

Two easy ways to...
(audience member takes a photo)
Okay...
(laughter)
To animate constraints.
It's easy when you know how
it works.
One was make an
outlet and change a constant.
The other one was
if you want to change a
multiplier have to
remove this one and then add a new one.
And then the most important one,
call layoutIfNeeded() from
within an animation block.
Really simple. This is everything that
Auto Layout takes.
Then, all the other
animations you want to do
like alpha, color, tint,
something like that,
you can do this in the normal way.
It's pretty easy.
But, this year
we have stack views.
Stack views are
if you go to the Apple docs,
you can see that Apple
markets stack views as,
&quot;Auto Layout without constraints.&quot;

This is a way to create
Auto Layout animations
without having
to animate constraints.
That's pretty
cool. All the time
that I have left... if anyone would tick me
how much time I have left?
No?
9 minutes, perfect.
I'll skip the
slides and go straight to
the other project.
Do you guys want to see how stack views
are animated?
That's more yes than ums.

I have a third sample project here
to show you how to do stack views.
Its premise is
it's a little shop application.
If you buy it from the app store
it will show you the list of all books
that are worked on that you can also buy.
Which is, I think, a big deal.
There's a list of books
and when you click on
one on the detail view
controller, you will see
the cover of the book
and some details.
I'm going to quickly
do that via stack views
to show you how easy it is.
Alright, my detail screen is totally
empty.
Which is a good start.

What I want to have is
a little bit of text which will
show the name of the book and the
years of release and so forth.
I'm going to call this Title,
one label like this.
Then, this one
I'm going to call Book Title.
This one will be much bigger
and with a fancier font.

Too fancy...

I have two labels like this,
and stack views are
a way to group views.
You have some views, we
want to group them together
forever.
That's the way to go.
And there's a new button in
in Xcode
where there used to be
the fourth Auto Layout button
nobody ever used and
they just killed it off
and put this new one
that hopefully everyone
will use.
It's basically a
little table with an arrow
pointing down like that.
When you have the views that you
want to group together selected,
and just click this one,
and then it puts them together in a
stack view.
Now they're basically
in a group.

There's the outline,
so there's a stack view
and then the two views are
sub-views of this one.
Then, the stack view
is nice because
it can do crazy stuff.

You can do crazy stuff like this...
There's a property called Axis,
which defines
whether the stack view
is horizontal stack or vertical stack.
It is really easy to click here
and change it.
This will arrange it now vertically,
and if I click it back it
will arrange them again
horizontally. It's pretty cool.
And there's an alignment property
which you can change from top
and align them all to
the top of the content,
or bottom like this,
or center, which is pretty cool.
I'm going to put a 10 point spacing
between the two so they will
always have a little bit
of spacing in between.
It's a really new and fancy way to
lay down UI which is crazy.
Android had this forever.

I'm going to have the title book
and then double
this one, and put in here
Year.
This will be Book, Year,
so I have two of them now.
This is a good start
I would say.

But, I'm never interested
in the case for them to
be misaligned.
I'm never interested in the case where
they will be like so on the screen.
I want to also
stack them vertically,
because they would look
like rows in a table,
that would be really cool.
I will select the two stack views
together,
hit this button again,
now Interface Builder grouped
them together vertically,
so I have two rows with a little bit of
information in each.
I have a stack view
of two stack views.
It's also pretty cool because now
on the top stack view I can
change vertical to horizontal,
have them like this.
All this is really cool,
really fantastically amazing,
I would say.
I already have outlets for this label,
so I'm going to connect
them quickly.
And then I will add the image view
for the cover of the book.
I'm going to drag it here,
to put a place holder
image.

And
what I'm going to do now is, I want to group
all of these together vertically.
I'm going to select the image view,
and the top stack view
that I have right now,
and again just press this button here
to put them in a stack.
Now I have a table
of a table, of few tables, of few tables.
People who have ever done web design
will say,
&quot;This is bad.
because we have divs now.&quot;
We don't have divs on iOS,
plus it works
differently so it's fine.
The stack view doesn't do anything,
The stack view does not do
any...
&quot;bleep&quot; thing.
That's it.
The stack view only keeps
reference to these views
that are arranged in there,
and will take in consideration
all the properties
you said should it be
vertical, should it be centered,
should it aligned, and so forth.
All it does is
manage the constraints
for the arranged views so
you don't have to change
the constraint of those
views. It will create the
constraints for you
so that they're aligned
in the way you want them.

Let's connect this one and then
let's move onto animations because
we don't have any time.
I'm going to align this
in the center
and hopefully right now
everything should work
so we can also see some animations.

Good.
Not too good, but
still you'll have to take it.
Alright.
We have this that is
already working.
This is perfect because my stack view
takes care of the layout,
and if I rotate the phone,
this is still pretty good
because
everything is still aligned
in the way that I want it.
But, inevitably I notice that
vertical layout works really good
on portrait, but not as good in landscape.
This is where the
superpower of stack views
come into play.
I can say—

I want
the stack view that shows them to be
vertically aligned is perfect but,
I want to add a
size class in here and say,
&quot;No matter the width of the screen,
in case the height is really compact, so,
in case I'm in landscape,
add a new setting.&quot;
The new setting will be horizontal.
This way I will have
a vertical stack view in
portrait, and a horizontal
stack view in landscape.
Let's give it a try.
Let's see what happens.
This is how
the layout looks,
and when I rotate the simulator,
it rotates like this and
becomes a horizontal view.
This is really
a fantastic way to solve
device orientation changes,
because to be fair,
they're not really easy.
With Auto Layout, you
really could not do this
in any sensible way instead of having
separate constraints on all of your views.
This is really cool
and as you can see,
the change to
the orientation happens
in the transition between
landscape and portrait,
so it's also animated.
And you can see that it changes the
constraints and positions,
so everything
falls into place real nice.
We created an animation that
we did not write any code for,
and that was great.

Real quick...
Real, real quick...
Let me select this one
and do the same thing.
I want to change the alignment
based on whether we're looking in
portrait or landscape.
I'm going to change the alignment
to center in portrait
and...

leading in landscape to show
you how this looks.

We started with this.
The texts here are centered
because I said that in
portrait I want center.
When I rotate, now
they're aligned to the
left side of this particular stack view.
Your
layout literally flows with any changes
to the screen that you are doing, and it's
easy to do.
Which is, I personally think, fantastic.
Do I have one minute?

Because...
(inaudible comment from audience)
Okay (laughs).
One final demo.
One line of code to
show you how to do this
also from code because we did this
from Interface Builder and it was fun,
but I want to
do an animation
when I click on something.
I'm going to say view.addGestureRecognizer,
add a tap recognizer,
UITapGestureRecognizer,
that will trigger a method
didTap.
Here's my method called didTap,
which is—this one's going to do—
Something real quick.
IBOutlet week
I'm not even explaining anymore,
to be sure that they don't
pull me with a—
(laughs)
I need to connect this one.
I made an outlet to the
stack view. That's all you need to know.
I can access on my stack view,
I can access a property
called arrangedSubviews
which is all the sub-views
that a stack view
has arranged. Then,
I can say the last one
I need to access, and it
wants to set its property to
hidden, or to
toggle this property.

Any time I click
on the view controller,
it will set hidden on this one view,
it will just toggle it.
This is fantastic for
showing menus that
fold down from somewhere
if they were hidden
before, and show them.
They can show up
like this and rearrange
your layout to fit in,
and this is really great.
You can do this also from an
animation with duration call.



That will be the last for me.
As I usually say—
Thank you, that was great.
As I usually say, you have to stop me
because I can talk about
animations till April.

Now, since I wrapped this one line in a
animations call, then this
is also an animated thing.
Any property you
change on your stack view
can be animated because
the stack view only changes constraints,
and constraints only
change position and size,
which are animatable.
Everything works from stack views.
That's it, I promise.
That's all of it.
There it is.
The way to get in contact
with me is my page
where all my contacts are,
it's called underplot.com,
like the word underplot.
I am one of the last people who grabbed
the word dot com domain
that was pretty cool.
underplot.com.
Don't forget to rate the session,
that would be very, very nice of you.
That's it from me, thank you so much.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>