<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Model-Minded Development • George Fairbanks | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Model-Minded Development • George Fairbanks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Model-Minded Development • George Fairbanks</b></h2><h5 class="post__date">2016-12-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gAQ6t3F_2Ug" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">nice to be here I'd like to start by
thanking a couple people first the go to
conferences for having me here and also
to Simon Brown for specifically invited
me I also should get excuses out of the
way first because the the track of
speakers here has been very strong I've
been enjoying myself hopefully you guys
have to and so I'm just gonna say if
nothing makes any sense it's because i
slept sitting in an airplane last night
and also unlike the other talks if I say
something that just doesn't make any
sense or if if I if I lose you guys
please just raise your hand and ask a
question because I'd rather the whole
thing makes sense then wait till the end
to clear things up okay so in some ways
you can think of the strength of an idea
as being related to your ability to
never see the world the same way again
like a really good idea means you can't
like look at the same stuff and and and
and see it the same way again so i'm
going to show you something that
hopefully you've seen many times before
and we're going to use this as a test
okay and actually the test is for me
because if i can successfully if I if I
think the idea is really good and I can
successfully you know say it then you
guys will never be able to see this
scene in your daily lives the same way
again okay so my question for you and
this is the part that's the easiest one
what are you seeing here yes but what
are the people doing probably that that
also yes okay so I'm going to just jump
to it I can say what would this what I
was trying to do was show people in a
software team programming ok this is
people programming ok Donna ok that was
the answer the first one and we're going
to see this this picture again and I
hope the next time you see this picture
you will see it differently than you did
at the very beginning so I want to talk
to you about an idea that I call model
minded development because Rebecca told
me to go out that it's a throwback to an
earlier talk so I like to talk about
models i use models everywhere you can't
really do
architecture without talking about
models it seems okay models of the
patterns you're using models of the
systems you've got going but of course
we use models all kinds of other places
people have been using models all the
way going back 200 programs in the late
60s right so you have domain models
coming from that there's a specific set
of models in domain driven design where
a particular way of building systems ok
so there's models all over the place not
to mention the particular styles of
programming which sort of embody their
own models of how you should do things
ok so models models everywhere so when I
say to people that I'm really keen on
expressing the models in my code and
making all these things visible and
talking about them with other
programmers I can't really use any one
of these individual things I so I just
want an umbrella term called model
minded development that's what this talk
is about and I believe that models
should be a first class activity in what
we are doing it is the general idea
behind all those specific ones but what
do I mean by a first class activity
imagine that you were chatting with one
of your co-workers and he says you don't
really need to have models as a first
class activity he's got a perfectly good
process that he uses every day to write
software he probably heard it from
someone else and it goes something like
this collect your requirements write a
test case it's going to fail edit the
code so that the test passes and then
refactor the code to remove duplication
who's heard something like this process
before ok how many people think they
follow a process that's something like
this ok maybe twenty percent people so
not the first one was like ninety
percent of the people had heard about it
and maybe twenty percent think they
follow it ok so the concern would be a
skeptic might say that refactoring the
roof code duplication is the same thing
as doing model minded development and
I'm going to try to convince you that
it's not really the same thing ok so I
think we need models maybe everyone here
thinks you need models because guess
what you came to a talk that has models
in the title right you could have gone
somewhere else so how do we convince
someone who's skeptical the way I sort
of gut feel tell people about it is that
if you're in a company
and your company is exclusively trying
to make as much money as they can every
single day there's sort of a short-term
long-term problem right in the short
term you're focusing on the one thing
but unless you have the long term in
mind for example focusing on RD or any
of the other long-term ways your company
can fail unless you have an eye on the
long term as well as the short term
you're sort of out of balance and you're
going to not keep going okay that's my
gut feel and I don't feel like this
arguments very good but it sort of feels
like this with software right is that if
I exclusively focus on delivering
features but I don't have this idea that
I'm building up models about how stuff
works be them architecture models or
domain models or whatnot that my gut
feel is that we're sacrificing we're
trying to achieve something but we're
not going to get there because we don't
have that balance okay but I don't think
this is very persuasive I think it
already only works on the people that
were predisposed to it so I want
arguments that are pretty solid so
here's how I would express the way I
approach a software process that is
model centric right that has a
first-class version of it instead of
going from getting a new requirement to
writing a test case we instead take a
look at that requirement and take a look
and see if it challenges any of the
models that I have I mean across the
whole stack right you know like am i
doing testing the right way do I have
architecture the right way is this an
interesting quirk of the domain that I
haven't seen before and you say look if
this doesn't challenge anything you're
like okay great no problem I go ahead
and just do it like the old process and
I code it up okay but if it does
challenge it I have to revise the bottle
okay makes sense okay so in order to
support that view i'm going to give you
two arguments in the course of this talk
and i hope that you can use them
hopefully i hope you're convinced by
them and then if you want to convince
other people to use models i hope you
can use these things the first is that
programming is theory building and this
maybe not a term you've come across it
was relatively new to me and second is
that programming is a kind of
distributed cognition yet another term
you may not have heard i'm borrowing
both these terms from other places
so first one programming as the
rebuilding Turing Award winner peter
naur wrote an essay which is fantastic
this is the opening paragraph and i wish
i could write as clearly and concisely
as this maybe if i win uttering a word i
can i can do that or maybe it'd make me
works the other way around ok i'll read
the quote programming properly should be
regarded as an activity by which
programmers form or achieve a certain
insight a kind of insight a theory of
the matters at hand this suggestion is
in contrast to what appears to be the
more common notion the programming
should be regarded as a production of a
program in certain other texts that is a
shocking beginning to an essay right
because it says the programming is not
about writing programs ok so let's dig
into this and see what this could
possibly mean he refers back to a
philosopher who is trying to say what do
we mean when we understand something ok
and actually that's sort of an
interesting question and as an aside i
find that philosophical questions pop up
in software development all the time
it's really striking but rile talks
about knowing that versus knowing how so
imagine you've got a child and you're
trying to get them to understand
addition you start out with knowing that
right they memorize some tables at some
point that transitions into knowing how
and you have a generalized theory of
addition that's inside of you that works
across numbers you haven't seen before
and we call that a theory ok and for the
purposes of this talk let's just assume
that theories and models are
interchangeable ok so what would that
look like if you had a software
developer who understood a system ok had
a generalized theory of a system as
opposed to one who just had a bunch of
facts memorized about the system ok so
let's have two developers one who can
report facts about the system like where
is this feature implemented and they can
go find the module where it's
implemented versus another one who can
give you what you would really like
which is this impromptu chalk talk and
you can say talk to me about how
security works and they would sort of
like cut a slice through the program
and start explaining that or you could
say you know what sort of performance
things are you worried about and they go
oh ok let me tell you about that and
they like you know can spontaneously
generate views of the system I would say
that the second developer has a very
rich theory of the program that you are
revealing through your questions and
that they are revealing through their
answers so some questions that you can
sort of ask yourself is how can we get
more of those developers like if you're
on a team you want to be with those
people you know it's it's it's my
aspiration to be as good at these kinds
of things as I possibly can and then you
know like what are our using
universities doing to get those kind of
people so I think it's useful to take a
look at what understanding looks like in
another discipline so that we can
reflect back on our own discipline ok so
i have a caricature of what it's like to
be a scientist ok and i understand it's
a caricature and it doesn't really work
like this but I've written some
pseudocode for my scientist program ok
so basically there's a do forever loop
and it says take a look at the world
compare the world against your theory if
you go what then you say my theory needs
some work ok but hopefully most of the
time you look at the world you compare
it to your theory and you're like
everything's going great ok so i have
this notional graph where the dots or
observations and the the colored ones
are ones where you go what and you're
forced to reevaluate your theory ok so
if you ask a scientist how well do you
understand some phenomenon right if all
the dots are gray and they just keep
being gray for a very long time no
matter which part of the world they look
in they can't seem to find anything
surprising they probably think they
understand something pretty well right
so the idea is that they're trying to
get a theory such that they no matter
how many observations they make nothing
really gets shaken around too much so
how well they understand it is how well
the theory matches the future
observations you guys buy that okay good
because I'm about to switch it software
okay so here's the pseudocode for a
software developer while forever pick up
a requirement if the requirement is now
very surprising no problem but if it is
surprising I go back to my theories and
I rework them whether it's my
architecture theories or it's my domain
theories because somebody could tell you
something crazy about the domain that
forces you to reevaluate everything I
have a great story for this or at least
I think it's fun at one point back when
people actually had landline telephones
yes I know when dinosaurs roamed the
earth I had a business and so I had a
two phone numbers for the same physical
telephone if it was my business number
it would like ring in a special way so I
could tell and I wouldn't answer the
phone with some silly you know way of
greeting because there was no caller ID
on telephones for those you under 25
right so okay so every month they would
Bill me twice and I would call them up
and they would fix the billing and I go
eventually after the third time of this
I said what is going on here and they go
okay let me tell you what's going on
every time we've been patching the
problem by just issuing you a credit but
what's going on in our software system
is a long time ago someone made the
assumption that one phone number equals
one account and in order to implement
this feature you've got two accounts and
we're supposed to have them set up so
that only one of them is billing and the
other one is not billing and I
understand that and we'll finally figure
it out and so sure enough after that
time I never was billed twice for this
because somebody you know did the magic
stuff to bolt the two accounts together
but only charged me once okay so just
imagine you're the software developer
you've been building software for
billing telephone systems for a very
long time and then someone comes up with
this feature and you look at your model
and you go I can't separate these two
things right I've bolted that together
and like the best you can do is give
them two accounts right and then turn
off billing on one of them which
probably broke another thing that you
would assume which is why have an
account that you don't build people for
okay this sort of makes sense you know
right so the idea is that it's not that
you can't handle new requirements but
some requirements are like no big deal
you know like if my application has
three tabs and you want me to add
another tab to the UI I'm like no
problem i understand how to put tabs on
you eyes okay i can go ahead and do that
so in general like as a software
developer i'm trying to build a model
that explains my world
both the domain the architecture that's
suitable for the scalability the
architecture that's suitable for
security and all the other things that
I've got to do and how well I understand
things is how well my program can
produce the future output that the
requirements got and guys want me to do
okay okay so some models are better than
other models right this this is sort of
an overused example but for a long time
we tried to take a look at the heavens
and turn made an increasingly
complicated model to to explain how the
stars revolve around the earth okay
until eventually someone said I've got a
better model I've got a better theory it
explains more and it's simpler and we've
all had that experience as we're trying
to figure out stuff and we're like
working it around and it was actually
very much like the previous discussion
where you've got this multi-dimensional
state space and you find a point in it
that's like oh this is much better over
here I can handle my scalability and my
security and everything else okay so
this actually occurs when you do domain
analysis as well this is an excerpt from
the domain driven design book and I
remember when I read this the first time
I'm like yes exactly exactly because
you've been sort of plotting through
requirements with stakeholders and
you're like writing them up and trying
to understand them and it's just like it
seems increasingly crazy until
eventually you're like ha and you find
the structure that expresses the
requirements and it makes you happy
because you know how to code them up and
it all works very well so what I'm
trying to describe here is that as
software developers we're trying to seek
out models that explain how things work
models that work for us maybe their
domain models or architecture models or
whatnot so let's go back to this quote
which hopefully won't seem quite as
crazy as it did the first time you heard
it okay the first time you heard it
you're probably thinking like don't let
my manager see this because they won't
let me go to the conference again right
okay so programming properly should be
regarded as an activity by which
programmers for more achieve a certain
kind of insight a theory about the
matters at hand this suggestion is in
contrast to what appears to be a more
common notion that programming should be
regarded as a production of a program in
certain other texts okay where the
second part of the highlight is very
similar to that
that a straw man a model that I
presented at the beginning which is pick
up requirement code a test refactor
repeat forever kind of thing okay it's
not just about writing the program so if
you've ever been on a team and this is a
little bit unfair that I put these words
in the dilbert boss's mouth you know
he's saying look we're here we've got a
business you've got to produce code
because that's what businesses do and
that's how we make money look quit
trying to think about theories and stuff
like this and on the right hand side
you've got this team that's got this
technical debt in terms of their models
not being aligned with what they're
being asked to do and if you keep
putting more and more people behind that
thing they can keep pushing it but until
they're able to or recognize that they
should be refactoring the models not
just you know removing repetition from
the code until they realize they're in
the geocentric model and they should be
in the heliocentric model they're going
to just keep pushing this thing and it's
painful for everyone involved because
the stakeholders get slow requirements
and the developers don't really want to
go to work in the morning okay and we've
all been there right and sometimes
you're like that's the right thing to do
we got to keep pushing this for another
two quarters but at some point we have
to fix the models in fact if you go back
and read the the original text of the
technical debt descriptions you will
find that it looks a whole lot like this
that somebody says I know this is not
the right thing to do but I got to get
this out the door it's not like I
accidentally screwed something up and
he's specifically disclaiming writing
bad quality code in a knowing way he's
basically saying you can't afford to fix
the model right now so going back just
want to make sure this completely clear
on the left hand side this is the I'm
not paying attention to models I'm not
specifically trying to build a model
this is something that works but you
probably are going to end up in a
situation where you or the team doesn't
actually have a theory that supports
what you need to do on the right hand
side models are first-class citizens and
you actually stand a chance of having a
sustainable system of velocity that
continues on forever in the future which
is what we all want we don't want to hit
dead ends so
here comes the quiz and remember these
quizzes for me what do you see these
people doing now yeah I can believe that
two ok but what do you think I want to
hear you say yes yes these guys are out
there building theories theories and
models equivalent in my hand wavy
version of this yeah so think about what
they're doing like if you went and you
pulled any of these people actually if
you pulled two of them independently and
you ask them tell me about the domain
model you hope you don't get different
answers right you know these guys are
really building a theory if you ask them
what's our strategy for testing you're
like how are we going to achieve the
scalability requirements hopefully you
know the team is building up a model
about how that stuff is going to work ok
they're not just typing the typing the
program ok so remember I told you
there's can be two major arguments I'm
going to try to support the first one
was about theory building and now you
know about theory building the second
one is another term called distributed
cognition sorry github I'm going to talk
about something different so distributed
cognition is a term that comes from
psychology and let me just ask you guys
quick question how many of you can
divide to single-digit numbers in your
head like you know 3/2 ok i hope
everyone actually could do this okay so
i'm going to start making this problem a
little bit harder by adding digit so i'm
gonna say how many of you can divide a
five digit number by a two digit number
in your head accurately alright so i see
very few people that you know have good
confidence and I and I could just dialed
it up a couple more digits and it drops
off ok so butch but that's ok because
you're not professional mathematicians
your professional software developers so
i'll make the problem easier how many
people here can write a five line
program accurately in your head all
right 10 10 lines 10 lines who's got 10
lines accurately and your oh my goodness
I think we've got some some
some people who are honest with
themselves how about 50 50 is a really
small program okay who's going to
collect their paycheck if you can only
write 10 line programs all right there's
something going on here isn't there
right because all of us are collecting
paychecks well maybe I hope so hope the
economy is good 90 plus percent of us
are collecting paychecks okay so let's
dig into this idea that we can solve
problems that are bigger than the ones
that fit in our head that's what
distributed cognition is about so here's
that simple math problem and what I've
been told actually is that in Europe you
get taught a slightly different version
of this than the u.s. so you'll find
this fascinating if you haven't seen it
before so this is how I was taught and
what you do is you say 45 goes into 132
times and then you drop it down and you
do the subtraction and you sort of grind
it through and you get it like this but
I don't really care about the scribbles
at this very moment the point is that
strangely enough surprisingly enough if
you let me make scribbles on a piece of
paper I can solve problems that I
couldn't solve without the piece paper
and scribbles which is a pretty cool
trick the thing is we do it all the time
and so we sort of forget that it's a
great little trick whoever invented this
trick like deserves great praise okay
this is a pretty good trick all right
but that's really pretty interesting
isn't it you can write scribbles on a
piece of paper and solve big problems
okay great so there's a problem it's not
just any scribbles on a piece of paper
so who wants to take a crack at it and
you're like look this is completely
unfair because I mean like half the
people here can't even decode I had to
type that into you know the Internet to
figure out what that number was and
Roman numerals fine fine fine no problem
no problem I'll turn it back into Arabic
who wants to do the problem now okay so
the point is the scribbles on the piece
of paper have to be a certain type of
scribbles on a piece of paper right it's
not any scribbles on a piece of paper
it's not even Arabic numerals that I
already know what they mean it's in fact
that the scribbles on the piece of paper
have to be aligned with the model that's
in my head okay so if the model in my
head
and the model on the piece of paper
lines up I get high performance and when
they're misaligned I don't get any
cognitive multiplier okay I don't get
this distributed cognition that's going
on so what we've got here because I
don't know of any studies that have done
the multiplication example which makes
for a great example I didn't want to do
the Stroop effect because there are
plenty of people that do the Stroop
effect but the Stroop effect is when you
put a whole bunch of words and you ask
people to read them except that the
words or colors and the words themselves
are printed in the color so if the word
our ed is actually printed in red you're
going to have the curve on the Left
which says high performance okay but as
soon as the color and the word are
mismatched with each other you get the
curve on the right which means your
brain is trying to fight the external
and the internal representations okay so
I don't have any these curves for
software either but we do have some
things that look similar and by the way
the Donald Norman that's being quoted
here is that Donald Norman from the
design of everyday things who would have
a lot of interesting things to say about
the design of the faucets in the
restroom so if you guys know what I'm
talking about like they had to put
labels on them because the elegant
minimalist design you know is inoperable
by humans without words okay so yeah oh
they're not okay well it probably says
something about gender differences
doesn't it so no I mean like sorry i
meant that in the in the most positive
way okay so the the example that we have
here is the squiggles up at the top
represent the mental representation of
the problem and actually the scribble on
the left is the mental problem and the
one on the right is the what you see on
the piece of paper and the idea is that
you got to combine all these different
things and only when they're aligned you
get high performance and what they were
studying specifically was various towers
of Hanoi equivalent problems and trying
to see how quickly people could solve
them and what they found is that in fact
the way you represent the problem
dramatically has an influence on how
quickly you can solve the problem ok so
again the kind of scribbles on the piece
of paper if they are misaligned with the
way you think about the problem in your
head you don't solve it very well so
another thing that was studied by
psychologists because the Navy is very
concerned about how well a bunch of
people on the bridge of a ship can steer
a ship okay now imagine I take any one
of us and we were in a row boat rowing
the rowboat and navigating somewhere is
doesn't seem like an interesting thing
to study right news point the rowboat
where you need to go okay but if you put
a dozen people on the bridge of a ship
and you rotate them in and out over the
course of the day this becomes a very
interesting and hard problem right
because the Navy is very interested in
accurate navigation so notice over here
on the left they've got some sort of
displays kind of low for some of you
guys but there's a radar display with
concentric circles and some some some
numbers on there so there's an external
representation that's presumably
assisting the navigation and if I go off
cycle and somebody else comes into the
the deck they can look at the scribbles
that I put on there in order to figure
out what was been going on and what's
supposed to be going on right that
there's some sort of hand off that goes
there wait it gets harder presumably
everyone on the deck is not doing
exactly the same job right so different
people have different slices of the
problem in their head and they're all
trying to have an internal
representation of what navigations about
and external representation that they
can make sense of and they've subdivided
across the people oh it's like if you
describe it in the abstract or like it's
never going to work right except that it
does it's really amazing so you've got
one challenge of the team right lots of
different people with partial
understanding you have the internal
external problem and so in order to do
this correctly you got to make sure
everyone has a compatible model or
compatible enough and you have to have
an effective external representation
like no Roman numerals or other sort of
stuff that's an ineffective
representation okay making sense so this
is starting to feel like software
development okay so let's just go back
to the math example and imagine you try
and chop up the math example and divide
it up by people and like how hard would
it be they actually get this problem
done and this is a really simple thing
to do but if you chop it up and have
different p
we'll do it it's going to be much harder
so we don't actually write arbitrary
scribbles into our version control
system when we write programs do we when
we take a program we one run one of
those obvious caters on it right so that
you know when we put it on the Internet
nobody can reverse engineer and
understand our code we're really trying
to take scribbles that made sense and
turn them scribbles that don't make
sense we're trying to remove any
remnants of the model that we have in
our heads okay so that the other guys
can't figure out what we figured out so
what we do is we use programming
languages programming languages and the
actual programs to bridge the internal
and external representations the
internal representation of the model and
the external representation as in the
code that's checked in so we named
variables a particular way we've got
named patterns that you see popping up
in the code and these are really trivial
trivial examples but if you take the
whole code base an example including the
comments and everything else we put with
it it's a way for the whole team to be
collectively editing a model and
understanding what's going on and a lot
of times when we see failures it's a
failure to encode that model in such a
way that when I write it down and then
you read it that with that the same
model pops up in your head so here's a
summary of what distributed cognition is
about we can solve bigger problems than
fit in our head by allowing us to make
scribbles on a piece of paper but only
if the model in my head and what I
scribble on the piece of paper is
aligned okay when they misaligned we
don't get the multiplication teams have
to share those models and the external
representation sort of like if I came up
with my quirky way of doing something
and you're trying to collaborate with me
on the program it's not your external
representation it's not going to work
nearly as effectively so we express
those models and source code both for
ourselves and for the team okay quiz
number two and remember this is the quiz
for me what do you see this team doing
what do you think I want you to say that
this team is doing yeah there's the
collaborating and they're thinking
they're doing this distributed cognition
task right where they're there they have
these mental models in their head
what programming is like what not what
programming is but what the models are
that they're manipulating whether it's
the architecture models or the domain
models or whatnot and they're expressing
them in the code so that when this
person writes it down and that person
reads it next week they all collectively
have the same ideas in their head about
what's going on they're very expensive
okay so these guys are doing distributed
cognition as a team so where are we
we've got this we started with this idea
the gut feel that models are helpful we
learned about Theory building
specifically and we learned about
distributed cognition and so at some
point you got to say hey what are the
models so what are the models I'm going
to start by giving an example which you
may have heard before which is who's
heard of the von Neumann architecture
for computers okay good you have a good
so you may also heard about the
controversy about naming at the von
Neumann architecture because he sat in
he was like the hotshot Brainiac guy of
the day and he sat in on a meeting where
the engineers who had built a computer
one of the very first computers were
discussing the designs for the next one
okay and he took a long train ride and
he had no internet if you can believe it
and so on using a piece of paper and a
pencil he likes wrote up some notes and
what he did was he connected the ideas
that this team had come up with about
how to build the next generation
computer and he expressed them by
connecting them to models that we
already understood logical models okay
models of logic and math okay and the
team that the engineers that had
originally designed this thing said yeah
but you didn't really do anything we did
the thing and this is where the
controversy comes in because we designed
the thing and all you did was express it
using math notation and logical notation
okay and so I'm like I'm not even going
to weigh in on the debate however i'm
going to say that the connection of the
models and the artifact is an incredibly
valuable task okay imagine you're doing
some consulting for your friends and
your friends is hey I don't know much
about software engineering but I'm a
smart person and I built some stuff you
know what they call those people
electrical engineers so
and I know it's a cheap one but the
thing is he get these people and these
other domains with these giant brains
and then they come into our field and
they're like i can write software and
then you get this stuff that's just very
surprising so so for example you're
looking at their code and like they
treat everything as a unique snowflake
in it and then you sort of go hey it
sort of looks like you've got three
tiers because we have a term for that
right and then you say what if I group
these things is related to batch
processing and various other things and
the the lesson to take home here is that
a model that's in a book is almost
useless you've got to connect the model
with the machine that embodies the model
right that's really important and so
that's what I want you to take away from
the von Neumann story is like forget who
invented the computer and who should get
credit I'm just going to say that if he
took a problem that's novel that very
few people understand like dozens in the
entire world and he expresses it in
terms of models that millions of people
understand and he connects the two
that's about it's a huge service to
humanity ok and that's probably why
someone put his name on the paper right
so when we do modeling we can't just do
the right thing like make a program that
happens to work well that's a good first
step the better step is to actually
connect that program with the models
that we've already named and that you
can learn as an undergraduate or that in
conferences like this you can learn
about so we are a bit too close to the
particular problem of programming to
really see it clearly so is anyone in
here tried to write a play or a novel or
something like that ok so if you've ever
tried to do this and I've tried in it
failed you find that there's all these
interacting models that you need to
understand ok so for example the hero's
journey where you know like you've got
Luke Skywalker who's just some you know
schmuck on a desert planet and by the
end he's the hero that was Layton inside
of him right okay so that's the hero's
journey the character development like
you can have really flat characters that
nobody cares about so there's there's a
whole model for how you get people to
care about characters how about for
shouting dramatic irony attention and
humor release all these kind of model
that somebody who's adept at this stuff
weaves through the the artifact okay but
when you're done the artifact stands up
on itself you go to a play and you're
like that was a wonderful play you read
a novel you're like I was entertained
and may be informed okay so you have to
weave all that stuff together and I
think the same thing is going on when we
weave programs we've got both reusable
and ad-hoc domain models right so
sometimes there's things I've never
heard of but somebody's telling me about
them other times there's an industry
standard you know ontology for financial
you know interchange items okay and I
can go look that up yes yeah there's a
there's also patterns and styles which
we pick up from the design pattern books
and all sorts other places and of course
there's development practices and
processes which are models right you've
got models in your head about how to do
deployment you've got models in your
head about how to safely upgrade
features right with feature flags and
toggles and so forth so there's these
models are actually richer than we can
actually describe so that's the kind of
thing that we are doing when we stitch
these things together how am I on time
five minutes okay uh we're pretty close
okay so think about it this way this
first column is what's our the second
column on this is that we've got sort of
off-the-shelf things that we can use and
weave into our programs those are like
standard ontology patterns programming
styles responsibilities driven design
because I like saying driven design a
few more times around Rebecca and then
importantly and this is something that I
missed for a long time is that there's a
lot of logic set theory category theory
metamodeling that we take for granted
because if you can find some problem and
have some iterative like four loops that
do something and you can simplify that
two sets difference of these two
collections you're like a lot of
complexity doesn't just melt it away
because you were able to take a problem
and connect it to math and then everyone
already understands the math and they no
longer have to think about the the
iteration necessary to manipulate
collections but then there's a second
column which is the ad hoc part okay so
it's unlikely that something some domain
model off-the-shelf has all the
domain that you need so you're layering
in the stuff that you have built-in in
your patterns and your styles and even
sometimes people come up with their own
formalisms in math for example graph
algorithms that are particularly useful
for them okay so these are the kinds of
things that we need to express in our
program so that the that we and the rest
of the other developers and the team can
use them and recover them so this is the
big this is the summary if there's
nothing new coming at this point model
minded development is the idea that
developers keep in mind a lot of these
models in their head they're abstracting
complicated things and they constrain
the way we write the code it generalizes
across a bunch of things you've already
heard before but I hope assembles them
in such a way that they're more
comprehensible there's two particular
arguments that I'm making here that I'm
trying to make sufficiently strong that
when I make these arguments you walk
away from this and go you're right I
can't go back to the simple model once
you once you've explained these things
to me because programming is really
building these theories and programming
is distributed cognition right there's
this magic thing when i make scribbles
on a piece of paper and therefore we
should be treating modeling as a first
class activity and i think honestly a
lot of times we don't so the metaphor is
this idea that you have a bunch of
observations of the world which are like
are sorry the requirements which are
like observations the world and what i
want to do is have an infinite number of
those things in the future my program is
always ready and in order to do that i
have to build a model that predicts
what's going to come next I don't like
the the process on the left because
there's no models in it on the right as
difficult as it is to squeeze models
into that process I think we have to do
it and what happens informally I think
is that software developers are doing it
even though the process doesn't say
you're doing it and when we fall down or
when we have a co-worker that thinks
we're wasting time that's just you know
going to be building in technical debt
into the system because we don't come to
consensus on what the models are this a
metaphor of a bunch of people sitting on
the bridge of a ship with people coming
in and out and the need to have a shared
vision about what navigations like seems
to strike a chord with
and I think it resembles a lot what we
consider what we're doing with
programming and you you think about how
hard that must be and how hard it is to
get a good external representation and I
think that's a good metaphor or the good
parallel with software development so we
started with this test which is look
here's a bunch of software developers
and at first we said they're just
programming right and I hope that by
exposure to these ideas that the next
time you see a bunch of people you're
actually going to say well of course
their programming but they're also
building theories and that's a huge part
of the value and of course also they're
doing this distributed cognition trick
right because they can't do all the
programs in their head and they're using
this external representation to get it
done all right thanks very much i hope
you enjoyed the talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>