<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Conflict Resolution for Eventual Consistency • Martin Kleppmann | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Conflict Resolution for Eventual Consistency • Martin Kleppmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Conflict Resolution for Eventual Consistency • Martin Kleppmann</b></h2><h5 class="post__date">2016-12-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yCcWpzY8dIA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody thank you very much for
coming good morning I hope you're doing
well
I'd like to talk today about conflict
resolution in distributed systems that
is if several people change some data at
the same time independently of each
other what happens how do we resolve
those conflicts okay my background is
I'm a researcher at the University of
Cambridge I was previously in industry
in a bunch of internet startups so I
worked at LinkedIn for a couple of years
for example at the moment I'm working on
this research project called true data
spelled T RBE and what we're trying to
do here is to bring end-to-end
encryption to a larger range of
applications so think something like
Google Docs where several people can
edit a document at the same time online
but without having to trust Google
servers because what we want to do is to
be able to put data on various servers
in the cloud but not have to worry about
what happens if they get compromised or
so on so that's kind of the background
of all of this I'm not talking about the
encryption and the security protocols
today I'm only focusing on one little
piece of that whole project which is
what happens if several people edit beta
at the same time and how do we resolve
that so I'd like to start with a
scenario that we'll probably be familiar
with you which is you a little blue
stick figure here are hacking on some
code on your computer and at some point
you decide that this code is done and
you commit it using your favorite
version control system I'll just use git
as an example here and so at this point
you put the code in the repository and
then maybe you push it somewhere so that
other people can see that code as well
so in the case of get you maybe you'll
push it to your repository on github and
this is now the communication mechanism
for people with your team so if there's
somebody else say this little red stick
figure who is also hacking on code then
well you can synchronize up through the
central repository this is all very
familiar this is what we do every day
and so the little red person here might
independent
at the same time also be working on the
same code base and also do a commit and
now what happens if this person now
fetches from github well they'll have to
either do a merge or rebase if that's
how your workflow goes or something
along those lines zones somehow these
changes I don't have to be combined
together and as you've probably
experienced if people change different
files in the same repository that's no
problem they will just get merged
cleanly if one person changes the
beginning of a file and another person
taejun it's the end of the file that's
probably okay because the version
control system will merge them to
automatically if people change the same
part of the same file then you're going
to have to resolve the merge conflict
yourself and so we have these tools for
doing 3-way merges for copying captures
from one side to another and figuring
out what the result should be so you've
probably have to fight with things like
this this is exactly the kind of problem
that I'm talking about but this problem
happens not only in software development
it's a very general purpose problem so
imagine you're a lawyer working in a law
firm and maybe there's a contract being
negotiated with you've got a client on
one side and there are other and the
other companies law firm on the other
side and everybody's sending these
versions of contracts back and forth and
the contracts are probably Microsoft
Word documents because that's how
lawyers work and they sent these things
by email and so you've got one person
making changes to these word documents
and then hit save and then at the same
time maybe somebody else maybe at a
different company is also updating the
same document changes it and now you
email these changes to each other and so
this is actually very much the same data
flow and I actually just reused exactly
the same diagram and changed the labels
you've got the email as the
communication path and at some point
these changes are going to have to be
merged together and now for Microsoft
Word I'm not sure there is even this
kind of nice user interface for
three-way merges I know you can compare
two documents but I think what you what
people then end up doing is manually
copying the the changes from one version
of the document to another and so
performing this merge really manually so
that's it
kind of this aircraft situation here so
in this case it's kind of best to have
like an informal lock where one person
says okay I'm going to be editing the
document now please don't change it for
the next day I'll send it to you and
then you can edit it so people try to
sequence their updates like this through
manual communication what happens in
another let's look at a third example
though let's look at a to do list and so
this is maybe you said to-do list where
me and my wife together have the
shopping list where I can add stuff and
she can add stuff and then whoever next
goes to the shop can buy those things so
here buying milk is added to the to-do
list and let's say this to-do list is
stored on a central server now so that's
what allows us to communicate and so I
add my milk to the to-do list and press
ok button and so it does a request like
maybe an HTTP POST request over the
network to deserve our stores it there
and comes back and says ok that was
added to the to-do list and at the same
time maybe my wife goes Oh need to water
the plants I just remembered so adds
that to the to-do list also does this
post to the server comes back ok and so
in this case actually what has happened
is if this central server stores its
data in a database and it uses something
like transactions if this is a
relational database say then we actually
have serialization going on and that is
these updates are actually applied in a
sequential order in a serial order
that's where serializable comes from in
database transactions which means
they're applied one at a time so you
don't actually have the same concurrency
problem as we had with the code editing
and with the word documents being sent
back and forth because actually there's
only one primary copy of the data and
that lives on the server and that's
being updated one transaction at a time
in sequence so in this case you don't
get this conflict resolution problem so
this seems nice but on the other hand
you have a problem which is well what if
I don't have signal on my mobile phone
right now or if the network is
interrupted for some other reason or I
can press the button to save and I'll
just get a spinning spinning wait
indicator and nothing will happen
so here we have this it's kind of
obvious this problem if you don't have
internet connection then you can't reach
the central server so you can't store
any data you can't edit the data in any
way so it doesn't work offline so these
are the problems yet we get the
advantage from a central server that we
don't have to worry about this
concurrency and these these different
edits happening at the same time and
having to merge those together but at
the cost of it only works online so we
now require constant connectivity to the
server which is not so great especially
if you're doing things on mobile devices
another problem is that these requests
are synchronous so when I press the Save
button I have to wait until I get the
okay back from the server and only then
I know that it has actually been saved
so until I get the okay back I don't
know whether the network request
actually made it through or not maybe if
the network is unreliable so that also
can be a timing problem let's see in the
document editing case so say in the case
of Google Docs you know you can press
one letter and then a second later that
letter will appear on the screen of
another person who is editing the same
document so there the edits that the
unit of editing is a single keystroke
it's not even like a commit or something
like that it's just a single letter and
so in that case if you wanted to send up
through a central server then every time
you press a letter you'd have to first
send up to the server wait for it to be
saved there wait for the server to come
back to you say ok and then you could
display the letter on the screen and so
you would have to wait for that network
round-trip for every single change to
the document which is particularly what
happens exactly if you're editing a file
over SSH so if you logged into an Linux
server and you're using vim or Emacs or
something on the server and you type a
letter then that editor actually lives
on the server so you've actually got
that synchronous round-trip so if you've
got a slow or unreliable Network and
using SSH is pretty painful as you've
probably experienced a final problem
with putting everything on a central
server is that now there's this single
point of failure and people make fun of
github for example every time github
is down people say oh we've got this
nice decentralized version control
system and what do we do we put
everything back in a centralized service
isn't that great so so this thing can be
disrupted if you worry about denial of
service attacks for example or if you
worry about blocking maybe in some
countries that don't have such free
internet access if you're critical of
the local regime or something like that
then actually this kind of block ability
is quite a problem so what we'd like to
do is to figure out how to not have
these problems of the single central
server but at the same time not have all
of the problems of having to do the
merges by hand so coming back to the to
do list example if we think about this
having to synchronously communicate with
our server that's okay if the servers in
the same town but if the servers on the
other side of the planet then this is
quite slow because it's simply speed of
light takes a while to go all the way
round to the other side of the world and
back again so what if we just put data
centers in several different places so
let's say when the blue person adds by
milk to the to-do lists that request
just goes to the blue person's local
data center call it data center one and
get saved there and when the red person
adds water plants to de to-do list then
that goes to the local data center too
those are two different local data
centers if the people are in different
locations and so now that's okay so each
person can get a response from their
local data center and now these changes
will be propagated asynchronously and so
the speed of lights going all the way
around the planet is still as slow as it
was before so it could happen that two
people make these changes without
knowing about each other and then you
simply don't know which one of these
actually came first because you know
it's not really defined did the blue one
come first or the red one from the point
of view of data center one first the
blue one came and then the red one came
in but from the point of view of data
center - it was first the red one then
the blue one so if this adding an item
to dududu to the to-do list means just
appending it to the end
of the list then which order should
these items appear now we suddenly have
to worry about the fact that the data
center one might have buying milk first
and watering the plant second and the
other data center might have them
flipped in the other order oh yeah let's
think this further even without two data
centers we can just make it really
extreme and say ok we're not even going
to talk to a data center we're just
going to talk to our local storage on
the device and I'm going to treat the
storage on my mobile phone as a data
center there it's the best data center
ever because I can't have a network
interruption between me and the storage
on my phone so this communication is
always going to work so I can just store
something locally and that will be nice
and fast and the register can similarly
store something locally and then we can
just kind of have some kind of blah blah
Network stuff to synchronize the the
changes around and if you think about it
this is exactly the same as the
synchronization protest that has to
happen with the with the two data
centers exchanging data and it's exactly
the same synchronization process that
happened with the git commits being sent
by github or with the word documents
being sent by email it's all exactly the
same which is you've got some changes
that are happening concurrently
independently from each other and those
changes are being propagated
asynchronously and here of course now
we're back to this problem of conflicts
so take the example of adding two items
to do to the to-do list you can kind of
imagine that's quite easy to resolve you
just make sure that you somehow decide
on a consistent order may be using some
IDs or something or some user IDs you
can order them arbitrarily but what if
one item is one where one change is
deleted to-do item and the other
actually edits that same to-do item so
the red one changes buying milk to
buying soy milk and the blue one just
deletes the buying milk item and these
two changes happen without knowing about
each other so how do we resolve this
because well if you say that the
deletion wins so okay this item was
deleted the to-do list item was deleted
so that edit to change by milk device
milk is just gone because the item that
it refers to is no longer there but that
means that we've forgotten about the
fact that soy milk was added in there
and so maybe that's an important fact
that we've now lost on the other hand we
could do it the other way around
we could say that despite soy milk wins
but then the deletion has been lost and
so maybe the deletion is meaningful so
how do we resolve this kind of conflict
in general we have concurrent operations
that happen
concurrent doesn't mean necessarily at
the same moment in time it just means
they happen without knowing about each
other and somehow we need to achieve
convergence where everybody agrees on
the same data at the end and so people
talk about eventual consistency which is
kind of the database term that's often
used for describing these types of
system where you simply you can allow
different things to happen concurrently
and you just want to end up in the same
state at the end the problem with the
term eventual consistency is that it's
actually very vaguely defined and so
people are very imprecise when talking
about it and I'd like to break it down
into three points three properties that
a bit more precise so I'm going to
firstly assume eventual delivery and
that is we send messages over the
network and we're going to assume that
the network is not interrupted forever
so we're going to assume that after some
finite amount of time you get a network
connection again and so if you keep
retrying then you can get the message
through eventually you kind of have to
make this assumption because if you
assume that a device can be offline
forever then it can never come and sync
with the other devices again just by
definition of on off line so we're just
going to assume that eventually some
messages go through but we're not going
to make any assumptions about how quick
that is so if I go to Iceland and
there's no mobile signal and I'm hiking
somewhere up on the top of a volcano for
two weeks then I won't get any messages
for two weeks and when I get back to
Reykjavik then I will get some messages
when I reach an internet connection
again so that means my message delay is
two weeks in that case that's okay we're
just going to assume that's all right
secondly the second part of eventual
consistency is making sure that
everybody ends up in the same state that
is if we assume
that eventually everybody gets all the
messages then if two people have
received the same messages then they
should be in the same state
so that means that even if they receive
the messages in a different order they
should still end up in the same state
and finally what we want is to not lose
data now this it seems like a kind of
slightly really ridiculous point because
of course nobody wants to lose data but
it is actually quite important to make
this explicit so quite a few database
users do use this mode called last
writer wins where you say if two people
change the data at the same time we're
just going to pick one of them
arbitrarily based on the timestamp as
being the winner and the other ones were
just going to throw away and so this is
like equivalent if you think about the
word document example of well you've got
two people editing the word document and
one person emails their change to
another and the other person is just
going to say well I made changes myself
as well and I'm going to declare that my
changes are newer than your changes and
so I'm just going to ignore your changes
sorry and so this is not very friendly
to people because changes get lost so
let's let's require not losing data as
well so this is what I mean with
eventual consistency and this is the
kind of data structure to which we might
want to apply it so I'm going to mobile
this to-do list now as a JSON document
and you can just imagine it's like a
list of to-do items which is like each
to-do item has a title and a flag done
whether it's done or not true or false
and then maybe there are some settings
and stuff as well on the side and so the
main data structures that we have here
are an ordered list that is you've got a
list of to-do items and they have to
appear in a certain order and the user
specifies this order and also you have
maps so you've got maybe one JSON object
inside another JSON object or something
like that now once we've got these data
structures we can then make various
changes to them so as the users interact
with the application they will make
changes for example they might set
watering plants to truth so they say
okay this is now done I'm going to check
the box on my phone and what that does
is set this done flag from forth
so the operation here the change
operation the edit operation is
assigning a value to a particular field
in this JSON document another thing that
might happen is somebody might edit a
string so change milk change by milk to
buy soy milk so by inserting a few
letters into that string another thing
that might people might do is insert a
whole new list item of phone mum between
buy milk and before ordering watering
plants so this is editing the ordered
list objects to insert a new item
another thing that people might do is
add another key to this map here or they
might even delete an entire entry so the
top-level to-do item just delete the
entire list why not maybe you have
several lists or something like that
so these are the kinds of changes that
people can make to these documents and
what we want to do is have some way of
resolving those changes so that even if
people make these changes concurrently
to each other we end up with invention
consistency so we can model this
document as a tree and we can have some
data type annotations on it so say the
top-level document is a map and inside
it we have a list under the key to do
and so on won't go into too much detail
so this is actually an algorithm that I
developed together with a colleague and
we wrote this paper about a few months
ago so if you're interested in that you
can find it online it's called a
conflict tree replicated Jason data type
it says is anyone here heard of CRD T's
before ok a few people cool so this is
an example of a CR DT if you don't know
what a CR DT is don't worry okay
this paper is very theoretical it looks
inside it looks kind of like this so I'm
not actually going to run through all of
the operational semantics today so don't
worry about that
I'm just going to kind of give the
intuition about how the algorithm works
and just show kind of some of the
curious edge cases that occur there are
some of the stuff that we had to think
about when trying to do this but so the
hope is that this algorithm would allow
people to concurrently edit json
documents and merge those edits and end
up with a sensible result at the end so
one example of a document we thought a
to-do list example another
one might be simply a text document so
it's a a text document consists of the
file name which is just a string
consists of the characters of the body
of the actual text so each individual
character is like the smallest unit you
can edit and like maybe there might be
additional stuff for formatting setting
fonts and so on I'm just going to leave
all of that out
another thing that's quite useful is
cursor positions so like if you use
Google Docs you can see where in the
document and other users editing right
now that's quite handy to see third that
you don't change the same place at the
same time while you're online and so you
could imagine implementing that as a map
from each client has a position a
position is like a location in the
document and so that would allow you to
keep track of other people's cursors so
I'll just focus on the body characters
for now so the ordered list of
characters is what constitutes the
content of the document you might wonder
why this is why this is a list of
strings and not a list of characters so
begin footnote it's a list of strings
because in Unicode if you actually
represent like one character one or the
smallest editable unit of a document is
not necessarily a single Unicode code
point because you have things like
combining combining marks I think
they're called for accents and
diacritics and various things or for
emoji I think the skin color annotation
is combining mark and so you end up with
a sequence of several Unicode code
points that constitutes then one
character from the users point of view
if you're interested in this look at the
Unicode annex number 29 anyway and the
footnote this is completely irrelevant I
just wanted to mention that as well I'll
give a little demo of the text editor we
implemented because it's just kind of
fun to to make this a bit more
interactive so what I have here is
something that doesn't work hooray
sorry this is always the thing with
demos now
maybe it wants to be under Wi-Fi okay
let's try again
okay good so so this is a very basic
text editor that we implemented using
this data structure this algorithm that
we developed and I've got actually two
windows here left and right which are
both instances of this text editor
running and I can say and and it works
so you can see I can type something on
one side and it appears on the other
side and these two editors are actually
communicating via a network connection
so there are two separate processes that
are otherwise don't share anything so
they could easily be on two separate
computers on other sides of the world no
problem and what I can now do is I can
kill the server so they use a WebSocket
server here to communicate and when I
kill the server what I'm simulating is a
network interaction between the two so
now both editors are offline so this
could be because actually it's a server
outage or just because the clients have
lost their internet connection it
doesn't really matter and so I can keep
editing offline so let's say here so
I'll say hello everyone that go to
Berlin and you see it doesn't appear on
the right-hand side because they're
offline so we have these two now and so
I'm going to restart the server now and
what we want is for all of those changes
doopy preserved so make sure look at
that everyone at is still there and hope
you're all doing well is still there so
when I restart the server the editors in
the background keep trying to reconnect
to the server automatically and keep
retrying in the background and
eventually they will manage to connect
and resynchronize and now you see
everyone at has been coffee'd from the
left to the right and i hope you're all
doing well has been copied from the
right to the left and we didn't have any
like three-way merge user interface for
this like it just did this automatically
now let's have a look at how this
algorithm actually works because that's
kind of interesting this is basically
the same as what Google Docs does right
so
Google Docs is a bit fussy with it
offline support but if you force it into
actually doing it it essentially does
the same kind of merge and I can run
through a better of how the algorithm in
Google Docs works so imagine you have a
document consisting of the letters HDL
and O and you label each letter with the
index of what position it is so 0 1 3 3
and on the left hand side we've got the
green editor on the right hand side
we've got the purple editor and each
editor now makes an edit to this so the
left-hand side insert the second L
character to change it to hello and the
right-hand side inserts an exclamation
mark at the end making it's a chielo
exclamation mark and so now we want to
merge these two changes that have
happened concurrently and so in order to
do that we have this server - this is in
this case run by Google and the client
sends essentially a diff or like an
operation recording what to change what
change has been made by the user and
sent that operation over to the server
and so the left-hand side says insert L
at position 3 so you see 0 1 2 3 4 so we
inserted the L so the oath has moved
from position 3 to position 4 and so we
inserted that L there and on this side
we have the inserting exclamation mark
at position 4 and so that describes the
change that was made and now the
server's forwards those changes over to
the other client and so the green change
inserting the L gets forwarded by the
server over here insert L at position 3
position 3 is the right position here so
you end up with hello exclamation mark
which is what we wanted however if you
think about what happens in the other
direction so this insert exclamation
mark at position 4 if we simply send
that through unchanged what we will get
is hell exclamation mark OH because over
here we inserted the letter L at
position 3 so the O moved along prong 3
to 4 so really we would need to change
that to insert exclamation mark at
position 5
and only then we would get the right
outcome of having hello exclamation mark
and so what has to happen here is that
this position for needs to be changed to
position five because there was
concurrently an insert at position three
so the server has to keep track of all
of these different things going on
simultaneously and it has to transform
the messages rewriting this three to
four some of the transformation happens
on the clients as well but this
algorithm does actually depend on the
server to do some work as well and that
works so this algorithm is called
operational transformation and it's been
around for quite a while so it was first
discussed in the academic literature
back in the 1980s although the first
paper that presented this algorithm was
actually incorrect and they said so in
the paper they said he was a case in
which our algorithm fails can help
someone help us fix it please and then
several people researchers came along
and proposed fixes to it which worked
and there are several different
competing algorithms there the one that
most of the modern operational
transformation based systems are kind of
inherit from is called Jupiter from 1995
and that's what like Google Docs and
etherpad is based off on Google Wave
which is now Apache Wave they all use
this Jupiter design which is to use the
central server that does some of the
transformations some of the others don't
use the central server but instead keep
track of some kind of multi-dimensional
hypercubes of all of the edits happening
simultaneously they start requiring
quite a lot of memory some of those
algorithms which is why they're not used
as often in practice and so this kind of
works fine for Google's purposes but
remember what we wanted is to be able to
work with end-to-end encryption and so
in that case we can't have a server
transforming our messages because the
server would then have to see the
content of the messages and we want what
we want is well we want to avoid one
central server because that's a single
point of failure and we want to avoid
the server seeing the content of our
messages so we want to be able to just
forward the messages and this is where C
Rd T's come in so C Rd T stands for
commutative
no sorry conflict tree replicated data
types which is a bit of a mouthful which
is white
people just say CEO duties and
essentially this is a family of data
structures where several nodes can
concurrently change the data and they
can automatically merge and so they've
got as part of the definition of the
data structure they've got merge
functions or functions which allow you
to apply operations in a different order
and still get the same outcome at the
end and if we want to model something
like a text document like what I have in
our editor example in that case we have
an ordered list of characters and so the
data type we want here is an ordered
list and several different algorithms
were have been proposed to that they are
still more recent only about in the last
10 years these things have come up and
the one that I'll describe now and that
our text editors based off is called our
GA replicated growable array which came
out of a Korean research group in 2011
so let me show you how this one works in
a nutshell we start off with the same
example document which is a chielo
but now instead of giving each letter
just an index 0 1 2 3 I'm going to give
it a unique identifier each letter has a
unique identifier which might be just 0
a 1 a 2 a 3 a and we now have the same
edits happens on the left hand side if
you insert the letter L and on the right
hand side we insert the exclamation mark
and every time we insert a new letter we
have to make up a new identifier for
that letter and we're going to have a
little rule for how we create new
identifiers so we have them they have to
be globally unique and they also have to
have a certain ordering property and so
we're going to construct them as follows
each identifiers a number and a letter
and for the number we choose one greater
than the highest number we have so find
the document and so the document server
file contains 0 2 3 as numbers so the
next number we're going to pick is 4 and
then we call the left-hand one is node a
the right-hand one is node B and so that
will be the letter that we use for the
identifier and so if we assume that the
names of the nodes are unique so there's
no other node called a there's only one
node
they and furthermore we assume that
these numbers are generated by taking
one plus the highest we have so the
numbers per node will always be unique
so that means we generate for a on the
left hand side and for B on the right
hand side it's the same for because
they're both in the same starting
position but they have two different
node IDs so we get two different
identifiers and so that works and now we
can send these things by our server or
it doesn't even have to be a server this
goes by a peer-to-peer network or
anything else you like as well so I'll
just use a server here for simplicity
and instead of inserting at a particular
position we're now going to say insert L
and we're going to say the ID of the new
of the new life which is for a and we're
going to say we're to insert it by
saying after position to a and so 2a is
the first L and so the new L with for a
gets inserted after 2a and on the other
side we insert the exclamation mark
after four after three a 3a is the
letter O and so inserting the
exclamation mark with ID for B after
three a means put the exclamation mark
after di and so we can now afford these
messages so insert L with for a after 2a
2a here still means the first L so it's
going to put the second L in the right
place and give it a ID for a and on the
other side we can take this message and
apply that inside exclamation mark after
three a 3a is still the letter O
even though we inserted the letter L
before it hasn't changed the fact that
the ID of the letter O is still 3a and
so we can put the exclamation mark with
4b after the letter O after four after
3a
and so we end up with the same documents
in both places which is very nice we can
now just have some kind of network
between these two it doesn't have to
transform the messages in any way it
just needs to make sure that it keeps
retrying and eventually the messages get
through that's all we need here we can
encrypt them and it's all very nice now
there's still a problem with this
algorithm which I wonder if anyone can
spot yes
deletion is one thing yes I deletion is
actually quite easy so what we do for
deletion is just to set a flag for every
ID
and say that if it's deleted then the ID
actually remains there secretly hidden
but we're just going to say okay this o
is gone now so don't show it in the user
interface we that's called the tombstone
there's another same position exactly so
what have two people insert at the same
position so let's have a simpler example
document yeah ABC with IDs 1 a 2 a 3 a
and now let's say x and y get inserted
here between a and B so the left-hand
side insert X and y gives them two new
IDs according to the rule that I
specified earlier so 4a and 5a and and
so what that means here is insert X
after a 1 a insert y after for a and on
the other side on the right hand side
I'm going to insert P and Q and we'll
have the same rule again for assigning
IDs so they get 4b and 5b as their IDs
and they also appear between a and B and
now we need to make sure that all of
these letters end up in some kind of
consistent order on both nodes
afterwards and so let's take those
operations and apply them to the other
side so insert P with the new ID for B
after 1 a 1 a is the first letter a so
we insert P there and then insert Q with
letter with with ID 5 B after 4 B 4 B
what's the letter Q which we've already
inserted so we can put the key that's
what's the letter P for B was the P so
the Q with 5 B goes after the 4 B so we
put a P Q X Y B BC so now ok does find
so far now we need to make sure that on
the other side we're actually going to
end up with the same thing so we need to
make sure that the x ends up here after
the P Q but before the B because if we
put the X here then the 2 would be
inconsistent so well how do we do this
now because the message is going to be
the same the message is just going to be
insert X with ID for a after 1 a but if
we put it straight
after 1a then the X will go here and we
have an inconsistency so I'm going to
introduce a small algorithm which uses
these IDs and that is lookups the ID of
the incoming operation yeah when you're
applying an operation that came in from
a different node in this case that's for
a so for a is the incoming operation and
we first find the position after which
we want to insert the one a is here so
we start here after the a and we look at
the next the ID of the next element in
that list which is for B and if that ID
here for B is greater than the incoming
element ID for a then we're going to
skip over it and if it's greater the
next one is greater again we'll again
skip over that and we keep skipping
until we find an element that is less
than the ID of the incoming operation so
2 a is less than 4 a so in this ordering
here we look at first the number then
the latter so here for B is greater than
for a because B is greater than a 5 B is
definitely greater than for a because 5
is greater than 4 but 2 is less than 4
so we know now we have to insert between
the 5 B and a 2 a
whoo and then for the final operation is
actually easy so this insert Y with ID 5
a after for a while for a is here so 5
ages goes after it and that works and if
you're wondering the skipping here
doesn't apply on this side because here
the for B is greater than 4 a so when we
inserted this for B here we didn't skip
over for a because 4 B is greater than 4
and so this actually works and you kind
of have to actually prove it
mathematically to convince yourself this
really works in in all cases but we have
proved it and so we actually believe
this and so Parral we now have an
algorithm which will allow us to make
these changes concurrently without any
transformation without any coordination
and just allow us to end up in the same
place so let's say our document is hey
guys and we decide that that is not
general gender-neutral enough so one
person is going to change it to hey
everyone and the other person is going
to change it to pay folks
and what does our editor do in this case
now so I described just now how deletion
works and so deletion just means setting
a flag on these so if two people can
currently delete the same letter
they both delete the G of guys well that
deleting at once is the same as deleting
it twice it doesn't get any more deleted
through being deleted several times so
those letters just get deleted and the
insertion stayed because one insertion
doesn't replace another insertion so at
least to merge what you're going to end
up with with is the two insertions
concatenated so it'll be hey everyone
folks or maybe it'll be hey folks
everyone so the order of those two is
arbitrary that just depends on
coincidence of how the networking
happens to work out and you know there's
no order that is any one order isn't any
better than the other the problem is
just that what we have here every one
folks is not an English word and so
you've kind of end up with junk in the
document though this is actually what
Google Docs does as well so at this
point I'm willing to just say okay we'll
tell the users that look here this
doesn't pass the spell checker and it's
maybe we can pop up a warning saying hey
several people edited the document in
the same place the actual Google Docs
doesn't even do this warning it just
leaves humans too spotted by themselves
and it seems to work in practice so I
think at this point we just say okay
it's good enough we're not going to try
to do a grammatical analysis of the
sentences and do the merges
automatically so that they obey English
grammar because that's just not going to
work actually people have tried that and
it simply didn't work so we've got this
CR DT this data structure for ordered
lists which several people can change at
the same time describes deletion and how
that works are still a lot of open
questions there so the problem with
deletion here is we need to actually
remember for a long time afterwards
where a pacific particular ID is because
we use these ids as a position in the
list like an address like a pointer and
so we can't just delete if something
gets deleted from the document we can't
then just remove it and forget about it
entirely because then some operation
would come in and insert after 503 a and
we go 503 a sorry that was deleted I
where to put that insertion so we have
to keep those things which are called
tombstones also haven't talked about how
to do undo like you know control Zed
type undo or how to reorder the elements
in the list that's kind of interesting
or how to make all of these IDs
efficient so it doesn't take too much
storage so still a lot of open questions
there I think the basic algorithm is
kind of fine but actually putting it
into practice is still going to need a
bit of work but I want to talk about
some other stuff as well actually so we
were talking about these JSON documents
earlier and so interesting things happen
when several people can currently change
JSON documents that don't happen just in
the case of a text document so let's say
we've got here it's a bit of a contrived
example I'm afraid a map of colors and
so this is imagine this is an actual
structure so it's not like curly brace
quotation mark c/o et cetera as a text
document but it's actually the JSON
syntax tree this right here and so one
person inserts a new color the color red
into this map and so you then end up
with a map containing blue and red and
another person concurrently decides
actually they want to wipe out the
entire contents of the map so sets it to
the empty map and then adds green into
the map and so how do we now all merge
these concurrent changes that have
happened here what happens what's the
outcome what what is even the right
behavior here what what do we expect so
we can think about it systematically and
say well okay blue does it contain blue
well blue was deleted on the right hand
side by setting the whole map to empty
so I guess blue should not be in the
final result because it was deleted and
the left hand so I didn't touch it
what about red red initially didn't
exist but it was inserted on the right
on the left hand side and right hand
side I didn't touch red so I guess we
need red to be in the final result what
about green Green was inserted on the
right hand side and it was not touched
on the left hand side so yes we want
green to be in the final result so our
final expected outcome is that it should
contain red and green but not blue does
that seem
my guess so so we can do that and our
algorithm does this what this means here
is that we have to keep track of what
this setting the map to empty means
because if you just take this and say on
the left hand client you first add the
red in and then you take that change
that came from the right hand side which
is setting the map to empty and if you
just apply that naively and say you've
got an operation of his set map to empty
well then you're going to wipe out the
red because the red was added
concurrently so we have to somehow
remember what the state of the map was
at the time when you set it to empty so
we have here the thing is is known as a
causal context or something like that in
databases like react for example has
anyone used react that they have this
datatypes feature okay it works very
similarly to this that you have this
little extra bit of information that you
pass around in an HTTP header and that
the purpose of that is to keep track of
what is the state what was the state of
the document at the time when you saw it
so that then later you know what the
changes need to apply to so let's look
at a different example here we've got
again and our to-do list example and
we've got buying milk and it is not yet
done and so on the left-hand side and
edit happens and it just deletes buying
milk from the list because maybe it's
been done or maybe we know that no
longer need milk or whatever it's just
removed from the list on the right hand
side somebody sets done to true so taps
the button who said buying milk
done to true what happens if we try to
merge these two different updates we can
apply the same logic as we had just now
with the colors with the nested naps so
with the colors what we said is okay
does it contain each of the different
things depending on who edited what okay
so the title of buying milk on the left
hand side that was deleted because we
deleted the entire to-do item so I guess
the title should not be in the result on
the right hand side we didn't touch the
title so that's got to be deleted what
about done false
well done false was deleted on the left
hand
and over written on the right hand side
with done true
so I guess done false is out what about
done true don't true did not appear on
the left hand side and the right hand
side done true was added so we weren't
done true to be an in the end result so
if we apply exactly the same reasoning
logic what we end up with is a to-do
item that cane contains the flag done
true but no title and this is kind of
not what you expect because like we've
applied exactly the same logic but what
we've ended up with something is that
looks weird and it looks weird because
we kind of have this implicit schema
here we expected to do item to always
have a title and the done field but this
merge here has essentially tampered with
our schema so what do we do here maybe
we need a schema to explicitly say
exactly what fields something must have
but in that case what do we do so if
somebody changes if one person changes
our field within an object that has a
schema and another person deletes that
entire object well do we say the
deletion wins
so in that case any changes to stuff
within the deleted item are just going
to be lost but we said earlier we don't
want to lose data so how do we resolve
this or maybe we say actually if
somebody concurrently changes this and
sets done to true then we're actually
going to bring the title back as well so
even though the title was actually
deleted on the left-hand side we kind of
resurrect this whole deleted item and
say okay it's going to back at both the
title and done true but then we've
forgot about the fact that somebody
deleted this item so it seems like
something has got to give here and we
don't really know what it is we could
say that maybe overwriting something
with an empty map should not have the
same semantics as deleting it and then
we adding it again or maybe it should
have the same semantics so I'm afraid
this is going to end on a slightly
depressing note which is like we simply
don't know how to expose these kind of
concurrently editable data structures to
application in a way that is not
horrendously confusing and so I think
that's I think there's a lot of value in
having these kind of data structures
that you can just merge automatically
and not have to
about writing manual conflict resolution
code but the same time concurrency still
is hard even if you abstract a way that
can color and communication and
everything you've still got the problem
that some how long you can sometimes end
up in these merged situations where
there's no one right way of doing it and
so if any of you have ideas I'd love to
hear done otherwise we're continuing to
work on this and just try different
approaches see what kind of API is make
sense to developers we could go back to
the old bad days and say okay we're just
going to have this this oh crap scenario
we're just going to let users resolve
all of the edits manually I don't think
that's really friendly to users and so I
think that like the popularity of things
like Google Docs and indeed like meld or
things like that for conflict resolution
it shows that actually people do need a
bit of tooling and help in order to in
order to resolve conflicts we could say
okay we'll just put everything on a
central server and serialize everything
that's an option - but again we've got
this problem that you require network
communication all the time and it's
stuff doesn't work offline which is also
a shame so I think it is worth working
on this problem but it is an open
problem if you're interested in more
details on this I've put tweeted the
slides already here so you can find it
there and there are links to all of the
papers here's the second page and here's
a third page of references
so our paper is one of those in there
there are also several others about
different CR duties and different
operational transformation functions so
that goes into vast amounts of detail
here is a book that I've been writing
which I just sent off to the publishers
just two days ago so you can get an
early release of this online already
this is it's not specifically about
merging it's very broad kind of
introduction to the architecture of
databases and what do databases do under
the hood also so if you're interested in
this sort of thing I'd love if you can
check it out maybe give me any feedback
if you have any thoughts about it that
would be wonderful thank you very much
all for coming and I hope you have a
great rest of the conference
do you have a minute or two for
questions I'm a bit short of time we do
okay does anyone have any questions or
comments or anything we have some wonder
app that's right so the question is a
putter apart from the operational
transformation algorithm is there any
algorithm which uses weighted operators
to decide the last operation for
instance the delete operation has the
lowest impact for that losses are they
in terms of weights maybe neural network
probable probabilities making decision
faster so you can use weighting except
that doesn't fundamentally resolve the
problem which is that you can end up
then in some kind of scenarios where
you've just got an impasse and you've
got two things with the same weighting
and one of them has got to win and so
you can then arbitrarily decide whether
one thing should win over another and so
that's what I was getting at with kind
of these trade-offs here of like you
could specify maybe in a schema some
kind of semantic annotation saying we
want delete to win or we want update to
win the problem there is that it's
really hard I think to communicate that
to developers of like what does that
actually mean
if you don't have a PhD in distributed
systems will you still be able to
understand what this flag in your schema
actually means so I think just making
stuff comprehensible in a way that like
somebody you can just go and build an
app and they don't have to know about
all of the internal details of how
conflicts have resolved internally I
think would be very good
and so maybe priorities is one way of
doing that but I'm not sure the other
question just there was how did I make
my slide which is using an iPad I draw
them by hand using a iPad app called
paper by a company called 53 okay thank
you very much for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>