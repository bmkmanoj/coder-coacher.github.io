<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Fun with the Lambda Calculus • Corey Haines | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Fun with the Lambda Calculus • Corey Haines - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Fun with the Lambda Calculus • Corey Haines</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QPqoFCHpLF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we've got lots to go through so
let's get through it so most people have
heard about like the lambda calculus how
many people have heard of lambda
calculus how many people have ever
actually done anything and it one person
awesome a couple people yeah Tom's done
a little bit of it so I'm not really
gonna go into like the details of lambda
calculus and all of that it leads to
church numerals and I find those a bit
pretentious you know fancy list
manipulation stuff like that but the
code is really cool when all you have is
a lambda when all you have is a function
and you don't have anything else so
we've all most people have kind of heard
of it but few people have really like
actually gone in and done anything with
it or actually seen why and a lot of
times if you do see people give talks on
it it's things like here's how you build
lists and they just kind of put out the
code so what I kind of what I thought it
would be fun is to do some coding with
with a couple constraints the main
constraint being that all we have is a
lambda and in fact it only has one
single input and single output so a lot
of the times coding you can learn a lot
if you put these really crazy
constraints on what you're doing so I
thought what fun did a coding conference
and to stand up here and actually live
code stuff with you the other thing is
we're gonna we're gonna do today in
these 50 minutes we're gonna build up
what are called the natural numbers
anybody heard about numbers they're
pretty useful we're gonna do them with
something called piano's axioms anybody
heard of piano's axioms awesome
so piano was a 19th century
mathematician italian giuseppe piano
made these axioms as a sort of a
statement about the natural numbers 0 1
2 all of those we're not going to go
into a lot of the sort of mathematical
formalism about it but we're going to
kind of go through starting with just a
lambda and I'll show you what that looks
like
and we're going to end up with the
natural numbers fun coding exercise
everybody's happy so what I want to do
is I want to look through the piano's
axioms and I'm sure all of you have them
in your clipboard ring like I do
so the piano axioms there's eight of
them the first one is a pretty obvious
one that zero is our net is a natural
number it's sort of like the starting
point the next four are equality axioms
they talk about quality this will take
you back to grade school number four
every number xx equals x that's
reflexive X for everything x and y if x
equals y then y equals z that's
symmetric for all numbers x y and z if x
equals y and y equals Z then X equals Z
that's is transitive for all a and B
this is an important one if B is a
natural number and a equals B then a is
also a natural number this seems like
kind of a weird one that it's we have to
have an axiom about being closed under
equality but this is essential because
it doesn't means that if you have two
things that you're saying are equal one
of them isn't like a cow or some other
thing it's a natural number you can all
you know if two things are equal they're
both natural numbers the next three are
about what it's called a successor
function which we're going to build it's
going to be awesome for every number in
s of in is a number so we're closed
under succession I guess or successor
for all numbers m and n this is
important M equals in if and only if the
successor of M equals the sex successor
of n this is effectively zero equals
zero one equals one two equals two
but we're going to use this to great
advantage number eight says that for
every number in oh by the if you find
the successor of n equal to zero that's
false so zero is kind of our starting
point and we'll actually use this one
surprisingly there's a ninth axiom which
is about induction which is the way of
saying that oh it's true for zero and
one and it's true for everything so it's
true for everything I'm gonna skip that
and just wave my arms a lot so okay
brief aside about how I'm going to use
Ruby most people would think that
like Haskell would be a great thing for
this and it would but we're gonna use
Ruby because because we're because well
Ruby so a lambda and Ruby gets written
like this getting identifier you don't
need to know if you don't know Ruby
that's okay because most of the time
when I'm done with this nobody has
actually recognized that I've written
Ruby we get an identifier in this case
the identity function
the little stabby pointy thing and then
an X which is your parameter we're only
Ruby Ruby lambdas can take multiple
parameters but we're only letting to
have one and what's inside of it is your
return value in this case this is the
identity function
you can actually call Ruby parameter or
Ruby lambdas in two different ways you
can use this wonderful dot parenthesis
syntax it looks like a method call or
you can use this bracket which looks
like accessing an array and doesn't seem
like it should actually execute the
lambda but if you run this and yeah that
actually is my normal prompt it does run
so we're of course going to use the
crazy bracket one because why not the
other one has actually one more
character and I don't like to type that
much so let's get started everybody's
cool we need a good starting place and a
good starting place as I learned last
time I watched I believe it's the sound
of music is that it's at the beginning
so zeros of natural number that's a
great place to start so let's start with
that so I'm gonna actually write
something that is is zero zero that
seems like a pretty straightforward
thing to write but the problem is of
course I don't know anything about this
I don't know anything about is zero
function I don't know anything about
that zero statement there we don't have
any information at all and also axioms
are about statements of fact they're not
about like just having a piece of code
so really the
axiom is more something like this that I
can assert that there's a zero that
there is something so now I've got this
other function assert of course I don't
know anything about that either
and I'm just making stuff up as I go
along so let's take a step back and talk
about assert so the behavior we want
from assert is I assert is something
that I want to use to figure out if a
statement is valid whoops that wasn't oh
if a statement is valid now what does
that mean I don't know yet but I know
that if it's valid I want it to print
out something like a tea and if it's
invalid I wanted to print out something
like an F so it needs to tell the
difference between these two things and
I'm gonna make up two other functions
and two other statements called true and
false
so my assert function if I pass it true
I would expect it to output a tea right
and if it's false I'm going to have it
output an F this is just a statement I
can make up anything I want because
that's I got nothing to work with so
we've got these two new functions now
true and false remember everything's a
function in this so now I've got a
little bit more information I can talk
about assert now so what are true and
false so I've got these two statements
so I'm going to do a little bit of
circular logic here because that's
always a great way to make decisions so
true is the thing that if I pass it to
assert I see a tea right and false is
the thing that if I pass it to assert I
see an F that's great I can make up
things as I want assert if I'm gonna say
the definition of assert the behavior I
expect is that if I pass it a true I see
a tea and if I pass it a false I see an
F does seem kind of circular but the
only way to really talk about things in
to figure things out is how they behave
together because if you abide by certain
philosophies nothing
actually exists in reality except as
they interact with other things that's
kind of how I live so we're gonna do
that so what can I know about assert now
what I do know is that exort accepts
something and it accepts something
called a boolean I'm just gonna make
this term up I don't know if you've ever
heard of this I'm gonna make it up to
mean true or false but we don't know
what assert actually has to do so we
figured out a little bit about it that
it needs a boolean if you look at assert
and you look at the definition in this
sort of circular logic is that it's got
to do three things it has to figure out
if I pass in a true or a false it's got
to figure out what to do so print a T or
print an F and it also has to execute
that function so it's got to figure out
what what are the cases choose which
case and then execute that case that's
three things and of course that's way
too many things for a function to do
will you know one of the core principles
of the lambda calculus and lambdas in
general is this concept called the
single responsibility principle mostly
because you only have like one line in
there and so you can't do much so what
we're gonna do is take a look at assert
and what we do know is that it needs to
either puts a T or I want the function
of puts an F so assert it's job is to
actually do one of these two things so
we've already mentioned boolean's that
are true and false these encapsulate the
idea of two different things all right
we've got them right up there so it
seems reasonable to handle let them
handle an actual choice mechanism so our
boolean czar the things that we're
actually going to use to do the choosing
but we need it one more construct we
have three things to do we've got a
responsibility for assert we have a
responsibility for our boolean z' we
have a third thing and I'm going to pull
just a word out of the dictionary and
I'm going to call that
I know it's kind of crazy
so what ifs job is to do is to actually
execute the final thing so it's sort of
a coordinator between my assert method
and the boolean itself I'm just making
this up and it's got two letters so it's
okay one of the things that I want to be
able to say about it so I'm gonna I want
to give a little bit of definition and a
little examples of it so if I give it a
true and I give it something that says
you gave me true and then I give it
something you know a second thing that
puts you gave me a false and I actually
spell that right then I should see you
gave me a true and you gave me a false
this is what I would like to have happen
I would like the if statement to
actually execute this it coordinates
between the boolean and these two
options for the sticklers out there I'm
kind of breaking the only lambdas rule
here I'm using some Ruby stuff to do
puts and there's a string there but
that's for expediency have to bear with
me a tiny bit here otherwise we're gonna
end up spinning all day generating
numbers and letters and strings and
lists and all of that and I don't really
feel like doing that today
so let's look again at this now what is
if what can I tell about if since I've
wrote these examples so what I can say
is that if it's a function that when
given true executes the first function
that I gave it and if I give it false it
executes the second function that's sort
of the definition that's what I want
this construct to do know because false
execute the second
function so I want this to say the first
time you gave me a true the second time
you gave me a false so awesome so with
this I can start to define a little bit
about if I can start to figure out a few
things about it
so what do we know we know that if takes
a boolean right that's that first thing
it returns a function that takes
something else because remember we only
accept one parameter per function that's
this second thing the true case and then
it takes a false case like that but I
don't exactly know what's what goes here
I know that I want the behavior to be if
boolean is true executes true case if
false false case so I know that that's
kind of what the the functionality that
I want so one thing we're gonna be
implementing a couple sort of functions
that technically take more than one
parameter but because of our constraint
is only one parameter we have to do this
sort of like crazy indented passing in
other functions and things like that I
like to write it like this to sort of
highlight that it actually is a three
parameter function but because I'm silly
and put a constraint on myself I can't
do that okay so also helps with some
indentation stuff so let's keep moving
on so the if statement is responsible
for the execution we decided that the
boolean was responsible for choosing so
we kind of it would be nice if we could
do this now what this says is hey
boolean why don't you choose between
these two and then whatever comes back
I'm going to execute I have to pass in
the identity because remember we have
single parameter functions so I can't
just call the function I have to give it
something and identity is the closest
thing we have to I don't care like it's
just its identity who has an identity it
doesn't really matter nothing exists so
okay so now we have a little bit about
true and false
now we've determined a few of the
behaviors or one core behavior that we
need which is that true
it takes a first parameter and it takes
a second parameter because that's what
boolean z' do and what does it do it
returns me the first one it returns me
the true case false on the other hand
let me just grab that false returns me
the second one so now this if statement
works I pass these the true case in the
fall case if boolean happens to be true
it will return me the first one I
execute it great and let's see if it
runs and sure enough we have our little
sample here working so now we have an if
statement we've did we've devised to
this crazy idea called boolean z' so we
can move on to assert now so of course
our assert is pretty easy because we
have everything that we needed so if my
boolean is true then prints that
otherwise there so I just check it this
is the kind of a standard way to ride it
now I can I would expect my initial
things that I wanted assert true and
assert false to print T and F and sure
enough they do so now I have an assert
method and of course everybody knows
that you can't code if you don't have an
assert method because how do you know it
works so now we have our testing
framework which is really all you need
and we can come back so we've done a lot
of work here just to get sort of a basic
thing and there's this weird thing to
hear the reason you have to put this
wrap this in a lambda and I can't just
say if boolean puts T is because Ruby is
an eager evaluating language
which means that Ruby evaluates every
function argument before it calls the
function and so if I didn't have this
lambda like that it would actually try
to execute that puts T and the puts F
and then it would go into the functions
and you'd you'd end up with a nil
reference exception which is sort of the
general exception that always happens in
Ruby okay
so we've got our assert I'm gonna jump
just slightly ahead because if you have
assert it always is nice to have a
refute which just does this the other
side we're gonna use this later refute
just says the boolean should be false
there's a whole nother talk I'm putting
together where we actually build up
boolean logic in hand and not and all of
that stuff but I'm not this time so now
we've got assert we can get back to this
thing a search so now we're back to
actually doing something interesting if
we try to run this of course we get
uninitialized constant is 0 because I
haven't defined that but by defining
assert I now have a little bit of
information about is 0 I know that is 0
has to take a parameter and it has to
return a boolean because I'm asserting
on it and I've determined that assert
takes a boolean so I'm just going to
return true because that's always the
easiest thing to do we don't know
anything about 0 either the parameter
that comes in we do know that it's a
function because everything's a function
so since I don't know anything about it
I'm just gonna make something up and
give it my stand-in for hmm okay so now
we're passing so we got our T so we've
actually got a 0 now and we have a way
to determine whether or not something is
0 pretty cool right
that's a lot of work so here's our
reward yeah there's my cat Zack okay so
now the piano axioms have a part about
equality all we have right now is zero
we've satisfied axioms axiom one we're
going to start talking about equality
axiom two here states that for every
number x x equals x pretty
straightforward that's the symmetric
property so we're gonna come down here
and say i can assert right that number
is equal zero and zero that's a pretty
that's what axiom two says of course i
don't know what numbers equal is so
it'll help if i actually try to write
that so numbers equal well what is it i
know it's a lambda that takes something
because I've got the axiom that tells me
that it's comparing two things I know
that it takes two parameters so I'm
gonna take the first and the second
parameter now all we have in our
numbering system is zero and zero equals
zero we don't have any other things so
what should this return I know it has to
return a boolean well the simplest thing
for it to return is true because as it
stands
that's all I actually know and if I run
there it is I'm still I'm passing again
and life is good so life is really
simple it's a philosophical point life
is simple when all you have is 0 ok
that's my statement of fact about the
world so let's do it let's move onward
to the building of sort of the natural
numbers we've started at 0 we actually
kind of need to move up otherwise
nothing is really that interesting so
let's take a look at these successor
functions we kind of instinctively know
that the successor function is sort of
like plus 1 or it's the next number in
there but we can't use our intuition on
any of this because of course we're
using these axioms to build up the
natural number so if we come down and
talk about so for every number in the
successor of n is a number seems pretty
straightforward so what I can come and I
can say is let's start building this
function so if I come up and I say
successor
well it's a function that takes a number
it has to return me a natural number
because the axiom says that the
successor of n is a natural number well
I only have two natural numbers that I
know about zero and the successor of
zero and it seems kind of strange for
the successor of zero to return the
successor of zero so since it doesn't
tell me anything else I'm just gonna
choose it to return zero still only kind
of have zero but everything's happy now
so since it's a natural number we can
use our number equality because where is
it this thing for all a and B if B is a
natural number and they're equal they're
natural numbers so I can actually write
that the numbers equal the successor of
zero and the successor of zero how do I
know that that's true there we go
I know this is true because I have the
axiom that says if x equals y zero
equals zero then the successors that's
this one zero equals zero if and only if
the successors of zero is equal two
successors of zero so I can make this
statement this bold bold statement and I
can run my tests and sure enough it's
true as I've said a couple times life is
super easy when all you have is zero so
this point number equals always returns
true it doesn't give us that much
wonderful information but here's the
thing we're gonna do our big
breakthrough comes when we look at the
amazing axiom number eight axiom number
eight says that for every number in the
successor of n is not zero
so if we save it at zero then we're
false so that gives us a little
statement here so we can say that we can
actually refute
the idea that the successor of zero is
zero and we can also refute if we try to
do numbers equal of the successor of
zero and zero so these two statements
according to those axiom that axiom this
should give me truth but my number
system does not work so these are you
know these are kind of the same but so
let's take a step back to the beginning
and look at is zero
this needs to differentiate now between
zero and the successor of zero or zero
and not zero so what we can want to do
is well let's do something let's make it
so that zero it's got to be a function
let's actually make it a function that
returns true that says yeah I'm zero
successor since it's zero we can replace
it with this which was which is zero but
we want to just mark it and say you're
not zero so we're taking the code that
zero was and just saying nope false
let's run it so you can see it so
successors returns a function we need to
effect is zero here because is zero is
just doing that but now each number that
we have is a function that returns
whether it's zero or not so we can just
call it and get that true or false back
so at this point we can just is zero can
ask are you zero or not and we can see
that we got one more T which was this
refutation but our numbers equal still
doesn't work so we're gonna take a
little bit of a step back in order to
get this working and comment these out
and look again at
numbers equals zero zero this is going
to help us build out this numbers equal
method for a second so what we want to
say is that if there if the numbers if
the first number is zero then we can
actually check and see if the second
number is zero make sure that I have
like that and then otherwise we can just
say you're not it doesn't matter so this
says if the first number is zero then
just return whether or not the second
number is zero and if they're both zero
then you get it true doing this it helps
if I actually make that second nothing
okay so this isn't the final solution
but it's something that satisfies what
we have so far and it satisfies axiom
eight so if I come down oops and get rid
of these which is the axiom eight I can
see that it those are satisfied now so
we know that the successor of zero is
not zero and so we can kind of take the
leap to move on to nonzero numbers and
actually start talking about these a
little bit more let's expand this one
just a little bit to show that not
equaling is sort of successor of zero is
not equal to zero but also zeros not
equal to the successor of zero just kind
of flipping them around the idea that
successor of zero is equal to is not
equal to 0 and then the symmetric form
says that 0 is not equal to the
successor of 0 one day I'm actually this
whole like successor successor
successors successor kind of thing we'll
deal with that
okay so let's talk about nonzero numbers
so if we kind of jump up here for a
second we know that zero equals zero
right and we know that M equals in if
and only if the successor of M is equal
to the successor of n this implies that
the sixth this implies this guy that the
successor of zero needs to be equal to
the successor of M 0 but there's an F
our implementation doesn't satisfy this
and this makes sense because if you look
at what we're doing we're always
returning false so what should we do
about this well let's look at axiom
number seven this says oops for all
numbers m and n M equals in if and only
if the successor of M equals a successor
of n this means that this should be true
since we're only working with 0 and
nonzero right now we can put here that
if the first number is not zero then the
second one can't be zero either so I can
just return false if the second one is
zero you need to open and then I'm just
going to return true here oops
now we're back to everything passing off
all the t's yay so this is actually
getting pretty ugly can anybody read
this it's it's kind of hard awesome
until I can but we're we're biting sort
of my usual process of coding which is
make it work then make it pretty
hopefully remembering that second part
of it so we could return false here but
if we do that then we get that failure
so true enough we need to return true to
do it so whoo okay so this works for two
numbers we now have zero and we have the
successor of zero but we don't have
anything more than that so what this
kind of says is I would really really
love it if I could take the successor of
the successor of zero and compare it to
the successor of zero does any does
anybody think this is should work now
this is effectively two equals one
especially if I put an extra thing there
but it passes everybody of course is
heard that two equals one for
sufficiently large values of one but for
us we can't abide by that we don't have
we have just a size of one so we're
going to use the wonderful axiom here
axiom number eight to figure this out
however let's talk about how this is
going to help us so for every number in
the successor of n is equal to zero is
false so there's no number whose
successor is zero now I'm going to do a
little bit of math here so hold your
horses I'm about to do math I'm going to
use a logic or a proof mechanism called
proof by contradiction so we'll walk
through it quickly it's my favorite way
of proving things so let's assume this
is true like our number save
or our system says so let me do a little
bit of setting a variable I'm going to
say M is equal to the successor of 0 n
is equal to 0 so if I repeat this or
substitute this back in that says that
the successor of M is equal to the
successor of n yeah now if I replace
eminent with their definitions right
what am i doing do do to do to do to do
to do to do o M in this says the
successor of M and n we know that the
according to axiom 8 or axiom 7 if M
equals in if and only if the successor
of M is equal to successor of n which
says I should if the successors are
equal then the numbers are equal so that
tells me I can say this M n right just
by substituting well let me substitute
these back in oh look at this what does
that say that says that the successor of
0 is equal to 0 that violates axiom
number 8 so that means that I've reached
a contradiction I've reached something
false which means that's wrong that's
wrong that's wrong that's wrong that's
wrong that's wrong
so since assuming that this was true led
me to a contradiction I actually have
the opposite of what that assumption was
so tech so mine these axioms along with
what I have so far has shown me that I
need to put a refute here but mice my
code doesn't satisfy that because my
code only knows about this who everybody
followed that ok well let's have a
picture of a cat
there's squeeks her full name is you can
do it squeeks the story of little Kerri
Strug by Corey Haims because I find
Kerri Strug to be one of the most
inspirational figures in the world so I
wanted to name my cat after her so
awesome now here we are we've got a
failing test everything's good we've
only got a few minutes left so we need
to build four pages worth of stuff
so let's come up here we're gonna
comment out this stuff for a second oh
and we're going to come up the so we
have tests for successor we have this
final test that if it passes we know
that we have zero one two we've got sort
of the ability to give as the successor
of the successor of zero is not the
successor of zero so what we really want
to do though is be able to come down to
this numbers equal and figure out not
just everything's equal that isn't zero
but we actually want to be able to ask
it are these two numbers the same to do
this we really need to know what are the
things that caused first and second
first and second came about by calling
successor on something we need to find
out what that something is so what we're
going to do is we're going to say we
really would like a function called
predecessor that is sort of the inverse
of successor it's the thing that caused
my successor to be what it is so if I
take the successor of zero and I take
the predecessor of that I should get
zero and a right one that's kind of
crazy just to capture it so the
predecessor of the successor of the
successor of zero is successor of zero
alright so these are kind of their smoke
tests just to help me make sure that
I've got predecessor working once we
have predecessor working then I can rely
on numbers
seven that M equals in if and only if
the successors if I flip that it's the
successors are equal only if the numbers
are equal which says I should be able to
come down here two numbers equal and say
numbers equal predecessor of first
predecessor of second if I do if I build
predecessor I can do this and my numbers
equal will be working but I haven't yet
so I can't so that's our goal is to
build predecessor okay so let's do that
let's come up and look at zero the
successor okay so these have gotten us
pretty far this zero and successor where
we're just returning true and false but
we need to not just mark whether it's
zero or not but we need to somehow carry
along when we call successor we need to
carry along what the number is that we
are the successor of so we kind of if I
kind of pseudocode it it
I'd like it to look something like this
you know a pair and it because at that
point I can just say that the
predecessor of of a number M is just the
the rightmost thing of M I just I need a
pair well of course we don't have a pair
all we have is a lambda and a couple of
these things we did so so let's build
pairs real quick so in order to write
some just some smoke tests I'm going to
actually make a pair that is true and
false and then I am going to make a pair
that is false and true and then I'm
going to assert that the left or the
first part of true false I can assert
that because it should be true and I can
refute the second part of true false and
I can assert or actually I can refute
the first part of false true
so basically I'm making a pair of true
false and false true and then I'm
writing a couple smoke tests to say that
first and second work okay so what do we
know about these functions well I know
that pair has to take a first in a
second right I don't know what it does
with them I know that first is going to
take a pair I don't know what it does
with it yet and I know that second is
going to take a pair and it's going to
do something similar to first but I'm
not sure exactly what feels a little bit
like boolean's again we're boolean the
true picked the first one so makes me
feel a little okay so what do I know
about pair so let's work with first and
second because these are sort of our
outer behaviors what do I know about
pair I know one thing it's a function
which means I can call it with a
parameter wouldn't it be awesome if I
could call it with a function that
accepts the first and the second
arguments in the pair and returns not
true but the first one so this is a
technique I like to call programming by
wishful thinking which is I code it as
though I always say to myself wouldn't
it be cool if I could do that and
actually get the first item yes thank
you
second wouldn't it be cool if I could do
that it would be awesome so how do I do
that well that tells me that payer needs
to return a function
what's that function called well I'm
going to call it selects value so it's a
function that takes a function and then
it calls that function passing in first
and second thank you
so it when I call pair with true and
false it returns me a function that
takes this selects value function I
didn't write cred yet so these are
passing look at that
for T's so now I have pairs pretty fancy
so it passes the test I'm gonna get rid
of these because of course these are
just smoke tests and if you saw Jays
talk then you should delete all of your
tests and we're gonna come down and
we're actually going to use a little bit
of this to write some things so 0 what I
want zero to be is a pair of true and
something else doesn't matter what it is
and whenever I don't care I use my
identity somewhere there's an identity
theft joke in there but it's not now
so is 0 simply needs to take the first
item of that well what a successor do
successor builds me a pair of false and
in that's like saying that the successor
of n is equal to false in the successor
of the successor of n is equal to false
false in so every successor knows that
it is not 0 now what is predecessor do
it takes the second part and returns it
because if you successor makes a pair of
false and in predecessor simply takes
that out that means that if I come down
here and I run my tests my little smoke
test for predecessor are working so now
predecessor is working which means I can
come back to here and do the big trick
which is
take if the first is not zero and the
second is not zero then let me take the
predecessor of the first and the
predecessor of the second and see if
they're equal because if they are one
more no don't need one more according to
seven if first and second are only equal
if their predecessors are equal so now
if I come up and I get rid of all of
those oh look at that that's my
production app they're all passing
huzzah huzzah so what does this mean
dave-o
it means I have five minutes left
awesome
of course I wouldn't expect Dave to know
what all of this means so what does this
mean well this means that I have the
ability to tie I have a zero I have a
successor of zero and I have a successor
of a successor of zero that I know is
different so what I've got is I've got
zero I've got one and I have two and I
know and I've proven that one does not
equal two and that my one is not
sufficiently large so with some arm
waving around the induction axiom what
we have is we have an infinite number of
natural numbers to show that and to do
something really fun with since we have
a couple minutes let's build two natural
what this does is this takes a number in
Ruby and gives me the Associated
successor successors successor successor
like that and then we're going to take
from natural which does a little bit
different it takes a one of my natural
and returns it as a Ruby numeral and so
what I can do with this is say puts from
natural to natural ten and it prints ten
yes yes nailed it
what this does do though is I have three
minutes so we can do we can use these
numbers now to do some pretty cool stuff
such as this what if I wrote a function
called x that took a do this this many
times and said if this many times is
zero then just do the identity which is
nothing of course otherwise I want to do
this passing in you know this many times
and then call back two times except take
the predecessor so this is counting down
and if I wrote it correctly I can say
puts hello the index and say do this to
natural number ten times
am I missing a bracket thank you
this is when it's actually I'm actually
live coding so Oh a proc because n is
actually there so from natural look at
that look at that nailed it
awesome alright so that's my time hope
it was fun this was a fun coding one of
the cool things about this that it
exercise for home is to write add and
when you write add in this way like you
get up to like adding a hundred and a
hundred and you can like visibly see
your process or slow down it's super fun
alright thank you very much
Oh before you go there's pistachio oh I
love her okay and also you can buy my
book thank you very much have a good
afternoon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>