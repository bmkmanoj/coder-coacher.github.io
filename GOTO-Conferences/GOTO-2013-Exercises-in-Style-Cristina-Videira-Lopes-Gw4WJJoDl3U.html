<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Exercises in Style • Cristina Videira Lopes | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Exercises in Style • Cristina Videira Lopes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Exercises in Style • Cristina Videira Lopes</b></h2><h5 class="post__date">2015-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Gw4WJJoDl3U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good afternoon my name is Krista
and I'm a professor at the University of
California Irvine I'm also a developer
in an open source project I've been
doing that since I got tenure because I
was so eager to go back to actually
writing code that I had to find
something to actually get my hands dirty
and get that feel again for what it is
to actually develop systems and I'm
going to talk to you about programming
styles today and this talk is very much
talk for people who who enjoy
programming who actually think that it's
a really really cool thing to do as an
intellectual activity so programming
style let me just tell you why I'm going
to talk about this and why I think it's
important and I don't know about you but
in this large project that I'm a
developer there's lots of other people
committing code to it and sometimes that
actually when I see a piece of code I
can tell who was the people who wrote it
right it just it just can tell you
there's some elements in there that you
start as you start knowing more than
your your co-workers you start detecting
these patterns of writing code that are
very familiar to in very specific to
this person or another and when you go
in when you go in and actually patch
some bug it's important I think that you
given the immediate feeling for what was
the style that was apply there and
either two things can happen either you
don't really really don't like the style
and you better be ready to refactor
really intensively or you just you know
put your likes and dislikes aside and
just try to match the style that was
there in the first place and fix the bug
otherwise if you start mixing your own
style with the style of the person who
wrote the code it's going to be a big
mess now in style if you feel work in a
company so companies sometimes also have
rules
for how to produce the code the styles
that you apply and it's all good and
open-source is a little bit more than in
some projects a little bit more flexible
about people being able to express
themselves in the way that they think
it's best reflects what they are
thinking so what is this idea of style
well
programming styles in general are things
that exist everywhere
this is not new to programming right -
we've had the notion of style forever in
the arts particularly so I could talk
about the literary arts but this is
painting about the fine arts and you see
these different styles they what what
are these styles well we have modernism
Impressionism realism and what these
things really are when you go to art
school and learn about these different
ways of expressing yourself in through a
through painting it really just
constrains about how to express your
ideas so if you want to produce the
painting in impressionist style
well you better avoid very sharp lines
for example the forms are emerging from
a bunch of little dots that you apply
etc if you want to express yourself in
modernism so you better you know real
English the idea that you're going to
depict reality right you don't depict
reality depict some abstraction of
reality those are constraints and those
constraints are can be learned there are
techniques there are ways of thinking
and you can learn them people do a very
good job of teaching in in the art
school how to produce works in specific
styles we don't do a very good job in in
computer science in doing that so you
know if you go to art school and if you
really don't want to get very
sophisticated you and that with like an
art history simplified it all the
different ways of drawing faces right
and and styles in the fine arts are very
often associated with with specific
artists surprise you have the dali style
the Picasso style and those are all
things that you can actually try to
imitate if you want so what are
programming styles in in programming
programming styles are just the rules in
the constraints that that you
you want to apply when expressing what
you want to do so they resisting jumping
on me stop so they are ways of
expressing tasks the other interesting
thing about programming Styles is that
they exist in many scale so they exist
at the small scale of program writing
right and they also exist at systems
level when you design entire systems
made up components you also have styles
ways of thinking about how to decompose
the problem and how to compare how the
components interact and what I find
interesting is that some of those
patterns and of those styles that you
apply at the micro level many of them
actually also apply at the system's
level design okay and so it's not by
accident that a lot of people who are
very good in in programming languages
and people who write compilers and
design programming language is also
often end up being very good at writing
systems because they just have that
conceptual model about how the little
pieces interact together and have sort
of a certain flexibility about thinking
so these these patterns these styles
exist in many levels and of course we
all know that they are in a way frozen
in programming languages certain
programming languages are enforcers of
styles right some people thought well I
think that the right way to express
yourself is to think about objects okay
so now let me design a language that is
forcing you to think about objects or I
think that the best way to express
yourself is in terms of functions so now
let me design a language they think that
forces you to think in terms of function
so programming languages freeze some of
these programming styles okay for a
reason or another so what why are these
important well each one is important by
on its own self but I think what's more
important here is that the the
realization that there are many
programming styles not just one okay and
this is one thing that we are I'm a
professor so I teach students wanting
that we don't do very well is that we
teach people one or two styles at most
when they come out of university and and
people get the wrong idea
that that that's how they should think
about software in fact that's not true
there's lots of different ways of
thinking about software but there they
also serve as common vocabularies for
talk about in within teams right
they are frames of reference over which
you actually write the code and we all
know that some styles are better than
others we all have this idea but but it
depends right it depends on on a lot of
things it depends on what you're trying
to optimize and many times they're not
trying to optimize the same things in
different circumstances so it's really
important when you have those wars among
in teams about what's the right way of
doing things it's really important to
understand what is it that you're trying
to optimize maybe you're trying to
optimize you know the number of lines of
code or maybe you trying to optimize you
know the ability for other people to
understand other people's code or maybe
you're trying to optimize you know the
speed if there's all lots of things that
you may want to try to optimize in
depending what you want to do then you
pick up the right programming salt that
can help you achieve that goal or or or
can hamper you to achieve that goal so
there's not just one there's not one
that's always best it depends all right
so you know being an academia and being
a professor of computer science I mmm
I often find myself you know I actually
taught the programming languages course
introductory and I just shook my head
like you know they are not learning what
they should be learning I mean we teach
them programming language that that's so
much more today are sewing software than
then this really there's all these
different ways of thinking about the
problem and it's these ways of thinking
about the problem that I really I think
it's really important to teach so now we
know this and in fact we have the same
problem when it some other course is not
just programming languages but we also
teach courses on software architecture
for example it's not fact that software
architecture is the same problem like
how do you teach software architecture
and and the the problem there is even
worse because software architecture only
makes sense when you actually have a
large system full you know different
components interacting with each other
so the students
are many times I'm prepared to actually
assimilate those teachings because it
there's just too much complexity yet at
the time they can handle so so it's
important to be able to teach this thing
so in order for me to kind of wrap my
head about to teach it if you already
know some last year so I ran across this
author French author and again if you
want to find interesting crazy ideas
it's always good to take a look at the
French intellectuals of the 20th century
because they are really interesting
anyway so this guy Ramone Kino and he
was part he started this club a workshop
of potential literature if I can
translate it to English all Aleppo is
basically a club of French intellectuals
writers and mathematicians and their
whole moto was constraints so they're
all idea was that you would give them a
constraint and they would produce the
work based on that constraint and you
know a piece of art of literary text you
name it and so these were constraints
you know any kinds of constraints either
constraints about you know mathematical
constraints abstract constraints or you
cannot use that word or things like that
okay so there's a books that we make on
the side is a book that I recommend from
a person who was part of this club I
forget the name because I cannot
remember names but she wrote this book
called them in English avoid is anybody
here and avoid no yeah couple of people
anyway so what's interesting about that
book is that it is the book is really
interesting is an interesting story
and it's not small it's actually quite
medium sized book it's very engaging
it's um what was it but besides the
story what's interesting about the book
is that the entire book is written
without your currents of the letter e
now try to write something without the
letter e right that gives you
immediately something you know a very
strange style right there because some
words that you think might might be the
natural words to flow you cannot use
them because they have a letter e so you
start using
obscure words because you have to to
apply this constraint anyway so this is
an interesting book look it up but
besides that once okay know himself
wrote an interesting book called
exercises in style which consists of the
following thing he took up a little
story that's a completely dumb story you
know can be taught can be told in 30
seconds and he wrote this book with 99
different ways of telling this story
okay just obsessive-compulsive all the
way through right just one way another
way another way goes all the way so so
you know here's some some of these
styles metaphors surprises dream
prognostication hesitation precision
lots of different styles and is that the
names by the way I'm not even sure that
he gave them names I think the
translator gave gave these styles names
to kind of so the association between
the name and the actual rendition is
relatively fuzzy and I'll talk more
about names in a second anyway so when I
find this book is it wow this is it okay
how do we if I wanted to learn how to
write literary words I really want to
read this book because it will teach me
some it will make me aware of how the
different constraints that I can apply
to actually help me write write
constraints are good they help us create
when we don't have constraints it's
really hard to create things so so I
thought about I'm just going to steal
this this is the best idea ever
okay so I'm going to get the program I'm
going to write it in obsessive obsessive
compulsive mode as many ways that I can
possibly write the program so that's
what I'm doing so I am here's here's the
story of my my program term frequency
everybody here can do term frequency
okay take a file count the words you
know normalize them to lowercase
eliminate non-alphanumeric remove the
stop words if you don't know what stop
words are those words that exist in
languages that are so frequent that they
don't have any signal so things like the
in English so remove the stop words and
then count the words and present them
decreasing order of frequency that I'm
just saying the 25 most frequent words
okay so that's my program everybody can
write this every every student in the in
the junior year can write this so if you
get it for example private prejudice my
favorite books you would get a list
something like that okay here's the
input Nets the output over there this
program so how many ways are there to
write down frequency think a little bit
what would be your first approach to
write from for 10 frequency okay there
many ways if I would give you know all
of you this exercise I'm pretty sure I
would see at least 50 different ways of
writing this so before I go on so this
is what I have been doing I know I now
have a collection of them in github you
can you can look them up there you have
and my goal is to reach 33 and then I
stop and I write the book to explain
what's going on but 33 is not you know
it can go it can go much higher than 33
um so let me go here for the rest of the
talk and I will just go through some of
these styles okay no I I'm going to need
your help okay so here's what happened
about the month ago I came here to
office to a meeting of a small club like
the Aleppo Glove experts in programming
languages and I sort of present them
some of these ideas and the styles and I
did something really stupid okay
and they killed me for it here's what I
did I decided to give technical names to
these styles okay and as soon as I
started I was using technical names like
functional style or you know imperative
style they just killed me because they
did you went into a war of names right
you don't know this is not functional
you're forgetting ba ba ba oh no no this
is not imperative you know yeah oh my
god okay so I so in order to completely
avoid the problem altogether
I just took a step back and say okay I'm
not gonna name these things okay you
know what I don't care about the name
what matters here is the constraints
okay you have to write for the term
frequency using these set of constraints
now whatever you call it it's up to you
in fact this is where I need your help
help me name these things okay I'm going
to present you the constraints and you
help me name the things and the way that
you if you want to participate tweet me
hashtag that's my tweet name hashtag
style what style one and tell me what
what the name of that style should be
okay now I should warn you that the name
numbers here do not correspond to the
numbers that I have in github I just
have one two three four five here on the
top but I not the same names that I have
on the github repo okay so here we go
style number one don't try to read this
just to tell you this is a page of code
okay now I'm going to zoom in but even
before i zoom in you can already see
there's a lot of Indian tation here
going on right so there's a lot of
nested scopes so I'm going to zoom in on
different parts of this example program
so that you have an idea of how this
program is actually written okay so it
starts by having a global variable so
word frequencies this is going to hold
on the word the word frequencies over
here and and then i just opened the stop
words and i just load them all up so
that I have to stop words already ready
to go when I need to compare them okay
and then basically what i'm doing here
is two nested loops one that iterates
over the lines of the of the file and
one that iterates over the the character
in each line and you can see the story
right so we iterate over a line you
iterate over character you try to detect
the beginning of a word the end of the
word
try to normalize as you go when you
detect the word see if it's a stop word
you ignore it okay so that's all the
logic that's going there and that in
those nested lexical scopes over there
right so that's one way of doing this so
what are the characteristics of this
style what are the constraints if you
want to write a programming this style
what are these constraints let me tell
you what they are
no abstractions okay you don't define
procedures or functions or objects or
anything you just start in line one and
end in line n another thing that you
also don't do is use libraries so
basically don't choose libraries do it
all yourself okay so I need I need a
name for this style so I'm just going to
give you my my own name actually I think
you have many names for this monolith
might be named nothing they might be
brain dump this is kind of a style that
you end up with when you're really in a
hurry to do something and they don't
even want to think about how to you know
what kinds of abstractions are about
library functions you can use just drink
so that that's one style alright so let
me let me move on to style number two
okay so style number two again if you
want to contribute your suggestion for
name
hashtag style number two this is it okay
I will zoom in but in fact it's so small
then I can just expand it you can see
the whole program now on my next slide
all right so here's the whole program
and I'm gonna I'm gonna walk you through
the lines because there's just five
lines basically so the first one all
right the first one over here just loads
up the stop words the second one opens
the input file and loads up the words by
eliminating by normal it's doing a lot
of things it's it's checking for not
often you know for alphanumeric
characters it's checking for whether
there are stop words are not and
eliminating them so it's doing like at
least three things in here and this one
line of code and you end up with a with
a list of of the words that you are
interested in counting okay
the next one is that you take those
words and then you know there are many
repeated words so now we want to find
out the unique words right we want to
reduce and just find out the unique
words so that's this other thing that
we're doing here we have a set of the
words and the set in in Python
eliminates duplicates now there's this
line over here this line is kind of
funny this line sorts the unique words
by the number of occurrences in the word
the original word list okay so I'm
giving it a comparer
function a lambda function which is a
comparer
and if you will look careful about
what's going on here the comparer is
actually live comparing it's counting
every time that you need the comparison
it's counting the words from the word
list okay and then you print them out
now it's five lines of code okay it's
great if you try to run this it takes
about five minutes okay and the problem
is this this thing here you basically
every time that you want to find out how
you know the word the occurrence of the
word Elizabeth you go back to the
original list of the words and you count
the word Elizabeth so for all the
comparisons that you need to do for
sorting your counting okay so this takes
forever it's very very bad in terms of
performance it's very good because it's
really really short it's very bad for
for a runtime performance so but there's
another style on you right it's it what
what are the characteristics of this
style well in this particular case you
also don't do abstractions as you don't
have named abstractions the goal here is
to have to do it in as few lines of code
as possible all right and in your in
order to achieve that then you you
forego the abstractions because
abstractions at lines of code you have
to have definitions and stuff and the
other thing that you do is you try to
use as much as possible all the advanced
libraries that you can possibly find
that to stuff for you in fact if you
there was already a library in Python
there too the term frequency that's what
we will do and you have one line of code
right
so so so you see and you see people
writing code like this right it's a very
short program but each of the lines has
a huge semantic load and it's not
necessarily easy to understand what's
going on in there even though there's
only five lines of code some of those
lines are really complicated to
understand they're trying to do a lot of
things so I'm calling it code golf I
don't know if you know what called goals
are who here knows what code balls are
okay many people don't know so there's a
whole culture out there on the internet
in development world that has this
challenge called code golf's that you
try to solve these computational task
says in these few lines of code as
possible hook it up Google code golf
you'll see there's all sorts of it has a
culture out there that that you know and
in to some extent that culture
influences a lot of what's going
software that's going on in software
development that people have on the back
of their minds this idea that fewer
lines of code is better right it depends
sometimes it's not better or another way
that we could call it trihard maybe you
see this in when people you see this on
people who are fresh out of undergrads
and they were very good and those people
who got like A's and they pluses and
they're really good and they know you
know how to use all the advanced
libraries and all the advanced features
of the language and they come up to you
with this tiny little program that it's
really tiny but nobody else understands
in the in the team so there's style
number two if you think that there's
other names let me know style number
three okay so this is about the page in
the half of code and I'm going to zoom
in here and tell you what how these code
is is designed over here so there's some
global variables over here data the word
frequency the words and the frequencies
and then there's a bunch of procedures
basically with the file filter normalize
can remove stop words frequencies sort
okay and then here's the main function
and the main function consists of just
calling those procedures read the file
filter in analyze scan remove stop words
frequencies sort to let me print them on
okay I'm sure that everybody here has
written programs in this style yeah yeah
this is a very very recurrent style very
easy so so you what are the main
characteristics of this style well
here's how you have to here's the
constraints that you need to apply if
you want to produce programs in this
style you divide your problem in
procedures okay what are these
procedures procedures are abstractions
that they may take input they don't
necessarily return any output and
certainly there's absolutely no
requirement that they return output
that's relevant for whatever they are
doing they may return may be error codes
or something like that right so they are
just procedures it you know little
packets of instructions there is usually
some shared States that this procedures
operate on and and basically the way
that you compose the larger problem is
by by decomposing it in these smaller
procedures and then just calling those
procedures basically giving these
commands right one by one so think about
what we would call this style I'm
calling it cookbook style right this is
the kinds of expressions that you see in
cookbook recipes mix the eggs with the
butter leave them on the side you know
mix the chocolate with a flower and then
that's exactly that it's very natural
for people I think to think about these
cookbooks okay here's another one this
one I'm going to zoom in it's about the
not a page and a half - and it's really
really similar to the one that I just
presented there's a few differences and
the details actually make quite a
dramatic effect on the end result but
here's what it is so you also divide the
problem into
smaller chunks right but each of these
chunks now takes input and returns
output that's your constraint okay each
of these chunks is a function from
inputs to outputs and now what you do
here so here are the functions and in
fact the functions the division that I
did is exactly the same as the one that
I showed you before but the way that you
compose your problem here it is this
line over here the word frequencies and
I'm sorry I had to rename the functions
here that was it wouldn't fit in one
line okay but basically the way that you
produces your big problem is by
composing these smaller functions
calling them one after the other so the
output of one is the input to the next
and so on okay so that's another style
okay I think about how to call this
style here here the constraint so what
are the constraints
so what really think the constraint you
want to produce programs in this style
you have to decompose the problem in
terms of functions and when I mean
functions I really mean functions as you
learned it in algebra okay as you
learned in mathematics they are
relations from inputs to outputs okay
they're not procedures they are
mathematical functions and in fact if
I'm really strict here about enforcing
my constraints they add so much
relations from inputs to outputs that
they can have no effect in the world
okay you cannot have effects in there
printing things on the screen affecting
file systems that should not be in these
functions okay
they are relations that's your purse
right there's no shared state and what
the way that you compose or produce the
bigger problem is by doing mathematical
function composition you know s after G
just like we had learned in mathematics
okay that's one style constraints that
you have to write it under so think
about what you would call this style I
call it
the candy factory style right candy
factories you have these little boxes
that do one thing only and produce you
know do a coating on the candy and take
the candy to the next box that does
something else and oh that's the candy
factory style okay style number five
here we go page and a half this one some
of you might recognize some of you might
not recognize this one is popping
popularizes recently again there's a
bunch of funky little functions the way
that you do this there's a bunch of
functions here read file they're
essentially the same as the ones that I
showed you before normal eyes can remove
etc but now there's something special
about these functions that was there's
only one additional constraint okay and
the constraint is that every one of
these functions if you notice takes an
additional parameter that's a function
okay and the way that you're supposed to
use this function is at the very end as
you were about to return the value you
actually send that value to the function
that you received as an input and that's
what you return okay you may think what
why would anyone do this ever right wait
you know why don't you just return the
value that you was just about to return
if that would be the case then you would
end up with a candy factory style this
is a different style is an additional
constraint this is it you have one
constraint
additionally that's you have this
function that you get as a parameter and
what you do it is that at the very end
that value that will be returning girls
as an inputs to the function that you
got okay and so you know here's the main
code you just call the first function
read file with the arguments and then
you you give it the next function which
is the filter chars okay
you're chaining functions by giving them
as arguments to the function that you're
calling you probably have seen this
right JavaScript does this all time
right it has been popularized but this
this style is actually one thank God is
one style that actually is called style
it has a style but I'm not gonna tell
the technical name because otherwise
some people here would just shoot me so
I'm not gonna call it that name so
here's that here's the constraints the
functions take this one additional
parameter F that is called at the end
and given that function is even what
would normally be the return value plus
the next function so you just chain
functions like that okay so how think
about how you is going to call this
style I'm going to call it kick your
teammate here basically you're not just
kicking the ball you're kicking the ball
and your teammates to catch the ball
right that's what's going on in here or
another way if you are a little more
inclined to feminine affairs like me
it's called the crochet style you go and
get the next function from there's this
thread that you always go and get the
next function from right you probably
don't know what I'm talking about
anyway so that's that's exactly just
come this image comes to me crochet
style when I see when I see this one
some of you might know what the
technical term appropriate to this one
is but I'm not gonna use it
okay style number six okay so this one
is actually quite different this one is
about two pages of code and let me zoom
in and what's going on in here now with
something completely different okay so
now I'm thinking of the problem as these
classes of things
okay so there's there's a thing called
the data storage manager that very
obviously by the name takes care of the
input well that's the only thing that
deals with the input is this data
storage manager and then there's another
one that it's a stop word manager and as
name says that's the thing that takes
care of stop words and there's another
one that's called the word frequency
manager that takes care of everything
that's related to calculating word
frequencies right so there's these these
managers and controllers and things in
here and so the way that you start the
program here is you you create one of
these the the word frequency controller
sort of the main thing that starts the
program and you call you know the
procedure run on it and you let it run
you know the code run does the right
thing here the right chain of reactions
here now everybody recognizes this right
actually I have something else here just
to illustrate another point of this
style is that all of these things
actually reuse codes that has been
defined in this other type of thing this
TF exercises here just completely
irrelevant just to illustrate the
mechanism of this style that you can
reuse procedures that have been defined
in other things okay so you all know the
technical term of this style right I'm
not gonna say it so what are the main
characteristics here main
characteristics well you define you
design the problem you think about the
problem in terms of things there's
things everywhere okay and and watch it
what are these things they are capsules
the capsules of data and procedures
right the data is never accessed
directly it's only accessed through
these procedures okay it's these things
that define what procedures are they
exposed to the outside
and moreover these capsules can say I do
the same thing as that one anymore
okay so think about how to call this
style I call it the kingdom of noun
style and this is the reference for a
really fun is saying that there are the
internet look it up kingdom of nouns I
recommend very funny so this is what you
end up programs that are written in
these constraints end up with nouns
being very important things in your
programs right you end up with managers
and controllers and
you know adapters and all sorts of
things because those are the way that
you think about the problem is in terms
of of these things we model the problem
in terms of things and the things expose
procedures okay
so here's another one this one is a
variation of the the kingdom of nouns
but with one additional constraint let
me show you what that is so what's going
on in here oh no I'm sorry I actually
removed that one okay so this one is
actually completely different I'm glad I
removed that one because it didn't for a
talk it didn't add much value this one's
actually completely different okay
this one you think about the problem in
a completely different way so here's
here's what's going on in here's the
main masses over here what you're gonna
think here is wait a minute I have a big
file right and it could be really really
big so I could potentially do things in
parallel to speed up right I'm going to
split the data the file that I get into
chunks and now I'm going to give each of
these chunks into a worker that does
exactly the same thing that is doing it
in parallel and then at the end when
these workers stop I just merge
everything okay and I produce the word
frequencies and then in the meantime I
parallelized my task so there's some
gains in here all right so here's what's
going on there's a function that is
called split words that takes exactly
one chunk of input and and splits the
word basically tries to identify the
words okay and then you get these splits
that you are very important to apply a
map function
who here has applied a map or equivalent
function your programs
okay so map is an it is a function that
you give it a function as input and a
list of data and you can do you apply
that
function minute ah you know in parallel
to that list to each one of these chunks
that you get it here button and then
what you do with those chunks with those
ass splits you give it to another
function count words that's going to
reduce all of those things that you got
okay and then you print it at the end so
here's the split words and it's a little
complicated you actually need to look it
over and think a little bit if every
anybody has done this kind of style
everybody has done this kind of style
yeah
okay this style is actually very simple
but there's a little details that make
it a little different okay it is like
you a person who is trying always to
optimize things goes into this map step
and thing oh my god I could do it so
much better but then you start thinking
oh what's really going on I'm making the
problem very very simple so that it's
far the reduce step that comes next
okay so here's the reduce step over here
so what are the constraints well the
constraints is that you divide the input
into chunks and you have these two
abstractions you apply a function to in
parallel okay and then you take those
partial results and you reduce them
somehow in a coherent manner
okay so how would you call this style
I call it inverse multiplexer okay if
first multiplexing if you will no
electronics is a concept that has been
around for a few decades okay
and there's nothing new as I said these
concepts exist all over the place okay
in electronics as much as in programming
this has been around for a while in fact
the MapReduce concept oops did I just
say that has been around from from from
the since the 60s okay has been first
introduced in Lisp a long time ago now
it has been popularized with a Hadoop in
fact there's a variation of what I just
showed you and I didn't have time to
look carefully at the implementation of
dysfunctions because you would you many
of you would sell all this is not how I
do does it and you would be right so
there's a variation that that you need
to introduce another another constraint
that you need to introduce if you want
to produce the Hadoop style
okay so style number eight
okay style number eight is also very
different it's a completely different
way of thinking about the problem
different from everything that I showed
you before so the way that you think
about this problem in this style is to
think okay so I have data right for
having input data so what I'm going to
do is I'm actually going to store miss
this data in tables okay I'm going to
parse the data and store it in tables
and then what I really want to do I want
to count the words yes but I may want to
count other things I might want to get
more knowledge out of this data not just
the world frequencies okay and I want to
do it in a way that is very easy for me
to to state these these specifications
and get knowledge out of the data okay
so what is going on in here is that
first I'm creating a sequel light schema
I'm I'm creating so I'm creating the
schema tears I'll show you what is what
it is let me show you what it is
basically these three tables the
documents table the word stable and the
character stable because I might want to
count the characters or or do something
with them and so this is how I'm
creating the schema and then I'm loading
the file into the database okay and that
is at some point here's what it is I'm
inserting the data okay over here
inserting everything populating the
database and then finally once that is
in place then my program is really
really simple I just declaratively say
well select this from the words group by
something or there by something else
super easy right I don't need to program
as such it's just these declarations and
then I print them out
okay so this is another way of doing
time frequency now the way of thinking
of thinking about the problem completely
different so what are the main
characteristics well the way that you
think about the problem is that there
are these you think about the are input
data as entities with relations between
them and now constraint here is that you
have to have a query engine you have to
be able to query these these tables and
and you do it by using this declarative
query language very nice that you don't
write programs as such you just declare
what you want and the query engine does
it for you okay great
so think about how you would call this
I'm calling it tabular okay so I've gone
through eight of these as I said I'm a
little obsessive-compulsive when it
comes to to these exercises and there's
a there's some my goal here is to get 33
and I have about 23 at the moment in the
github repo there I'm writing a book
about this it's a book for the
distillate is for advanced programming
students but also for professionals who
for a reason or another were not exposed
to a lot of these things when they were
in undergrad and they they want to kind
of crystallize I mean there's nothing
new as such there's only trying to make
people aware that there's many ways to
think about the problems and in fact
some of those ways are very old they
were invented back in the 50s for
example I fact figure to my github repo
you'll see the first one is called old
times that is the style of writing
programs that were used in 1951
basically and there's all sorts of other
styles there's the rest style - ok -
heard about rest yeah ok so that I have
a test I have an example where that uses
the rest style so there's all sorts of
different ways of thinking about the
problem and believe it or not these
things only accumulate it doesn't go
away
none of these ways of thinking all the
way they are good for some reason even
the one the 19
51 okay the the styles that you wrote it
of programs that you wrote 1951 people
are still writing it these days and they
are still good for something when you
have in a constraint that you have very
small memory more I mean small in the
sense that it's smaller than the data
that you need to process and you need to
compress things and you really want to
think about your memory right and you
get away with lots of other redundant
things you put those redundant things in
like comments or something okay names of
variables put them in comments instead
of putting you know there's all sorts of
things so the way of writing programs
1751 is still alive today and same thing
goes for objects and functions and
continuations and relations and you name
it lots of different things they all
people will only come up with new ways
of thinking about the problem okay this
doesn't end here and and if you thought
that objects were dead and our
functional programming is there the cool
thing is really it's not it's not how
the things work it's just accumulate and
you have all these way styles that are
good for some things and not good for
other things and it's up to you know the
project and you and your particular
situation to decide what what style you
should be thinking for that particular
case what is it that you're trying to
optimize it's very important so that's
that's about it and I welcome
contributions by the way and two days
late after ID I put the code on github
there were already people contributing
like test cases and the candy factory
was the first one that people provided a
shell script to do it so I welcome
implementations in other languages I'm
doing everything in Python but you know
you can do it in other languages too
because again the styles are independent
of the languages so that's that's about
it thank you very much I'll take some
questions how do you distinguish between
style and patents good question okay so
we're going to world wars again so I
think that essentially this trying to
convey the same kinds of value which is
to convey experiences that people have
accumulated over the years and it's very
hard to codify these experiences in
mathematics or formal ways so a really
good way of expressing them in this is
giving these examples right so the the
patents book has these ways of thinking
about the problem that people have seen
in developing software that are good for
specific situations well I'm one thing
that I'm trying to do here is a little
bit lower level than that if I may say
so which is to capture some ways of
engineering the program's themselves
okay not just solving specific problems
but in engineering in how do you
engineer your code how do you factor
your code basically okay so that's sort
of it's it's very related I would say
it's just different if you if you want
to say different patterns if you want to
use that word and it they're slightly
lower level than the ones that are in
the patterns book thank you very much I
think time is up and the rest of the
comments and questions you can get them
on Twitter okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>