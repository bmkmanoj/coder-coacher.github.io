<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Evolutionary Architecture &amp; Microservices • Rebecca Parsons | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Evolutionary Architecture &amp; Microservices • Rebecca Parsons - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Evolutionary Architecture &amp; Microservices • Rebecca Parsons</b></h2><h5 class="post__date">2015-07-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WhHtVUlJNA0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">respond to changes in customer demand
changes in the marketplace and to
respond to threats and opportunities and
so we have to be able to adapt quickly
and that hasn't been the hallmark of IT
organizations for quite some time
unfortunately so what did we used to do
for those of you who have been around
long enough you may recognize some of
these things remember component based
reuse how we were going to have these
wonderful architecture teams that sat in
their nice ivory tower office and
figured out how everyone in the entire
organization would use these business
components and they would get reused and
some of these unfortunate architects
were even rated in their performance
evaluation on the number of times their
components got reused now unfortunately
because they were so disconnected from
what development was actually occurring
it was very difficult for them to figure
out how to write these components in
such a way that anybody might actually
want to use them remember integration by
databases this is how we used to do
things you have this great big hunking
database with all kinds of stuff in it
and everybody has these applications
surrounding the data and of course the
ever-popular whipping boy of
service-oriented architectures
service-oriented architectures tried to
say they could achieve what it was that
we were trying to achieve now come on as
a way did get some things right and the
first thing it really got right was it
started to allow organizations to think
that everything doesn't have to be a
monolith that you could have things in
smaller chunks it also started people
thinking more about you can have
integration among these functions rather
than coupling you can think about
middleware you can think about messaging
you can think about more loosely coupled
approaches it encouraged a greater
acceptance of this notion of eventual
consistency for a long time the DBA rule
data was this valuable resource and it
was the DBAs job to protect that and
everything was relational everything was
transactional and every time you said I
need to persist this it's like okay you
need to put it in a relational database
and there was no question and everything
had full transaction all the
capabilities of those relational
databases that's how everything was and
so8 at least started the conversation
that perhaps there's another way that we
could think about building systems in
some way other than the mana lists that
we were building in the past so that's
some of the things that SOA got right
unfortunately SOA still made a lot of
mistakes and probably the biggest one is
the monster services when you start to
look at some of the services that were
built under these models you get these
massive services that maybe aren't as
big as the entire model if but they're
still very large very difficult to
change very difficult to deploy come on
and part of the reason for this is they
tended to be producer driven services
and what I mean by that is when you
think about I'm going to write the
customer service and this is the
information I'm going to make available
to people as I am the producer of this
information I'm assuming I know how
people are going to want to use this in
much the same way the architects back in
the component reuse days we're trying to
figure out how people were going to want
to do it these were all producer driven
and very often they came from the IT
organization as opposed to the business
and they were thinking about things from
the context of the systems rather than
the applications the business
application there was a lot of work
astray ssin and the distinction I want
to draw here is the difference between
orchestration and choreography when you
think about an orchestra performance you
have a conductor up front and he's
guiding the entire orchestra he's
setting the tempo he's having the volume
changes all
that he is in control and every single
person in that Orchestra is paying
attention to what that conductor is
doing and if for some reason you need
two things going on you have two
conductors there are some symphonies
where at times you have two different
conductors somebody is always in charge
choreography on the other hand think
about a dance performance what a
choreographer does is they lay out the
vision of what it is that this piece is
supposed to achieve and each individual
knows the part that they are supposed to
play and how they are supposed to
interact with the other players but in
the performance the choreographer is not
out front pointing to people and making
sure they're doing the right thing each
of the individuals knows what they're
supposed to be doing knows how they're
supposed to interact and therefore if
something goes wrong they have an idea
of how they might respond so that's the
difference so was all about
orchestration which gives you a lot of
centralization of control and it's often
very difficult to test the tooling very
often got in the way we had all and I
think part of what made so ago so
horribly wrong
was the fact that we had all of these
tool vendors who were convinced that if
we just had the right services we could
truly have that vision of the business
person sitting in his office with the
doodle we're you know reconfiguring all
of their business processes and that
really hasn't arrived yet but the
tooling was trying to make that happen
and so you had tools that were designed
for a category of user that were being
used by different people and
unfortunately what we ended up with with
things that were even harder to change
than they were before which of course
wasn't what we are trying to achieve
these things were also much harder to
test so I'm going to talk about
microservices to some extent you can
think about microservices as so a done
right we are talking about services we
are talking about an architectural
approach that is looking at services as
their fundamental unit SOA stands for
service-oriented architecture
so this is maybe so a - but we needed we
need a different name and part of the
reason it's called this is we want to
focus people's minds on among other
things let's not produce the monster
services so this is a quote from the
article that James Lewis and Martin
Fowler wrote describing micro services
and basically what this is saying is we
are going to take our single application
we are going to break it down into
smaller components each running in its
own process communicating over a
lightweight mechanism potentially HTTP
but the focus is a lightweight mechanism
come on so what are the characteristics
of these micro services well the first
one is obvious they're small now what
constitutes small that of course varies
but you want to think about these things
from the perspective of these things
need to be smaller rather than larger
you want to build them around business
capabilities one of the traps that we
fall into as we develop things is we
think about things from the perspective
of systems but our users think about
that in the context from the business so
we need to start to think rather than
systems capabilities and systems
boundaries what are the business
capabilities and we want to start
organizing our work around that because
the way our business users are going to
conceive of reconfiguring their business
processes it's going to be in the
fundamental units of how they think
about the business they don't care how
it's implemented they don't care what
the systems look like they think about
this thing from the perspective of the
business concepts and so we should build
around those business capabilities these
things are independently deployable
which means you you can replace one
service without necessarily having to
touch another as long as you don't touch
the contract there is very little
centralized management and part of what
this means is that because these things
are independently deployable there in
supper
processes we can start to break the
dependence on technology stacks as well
it is easier for us to start thinking
about I'm going to use closure over here
because of the analytics that I want to
do but I'm going to use a different
language over here because maybe because
of the strong object model that I need
to model my my domain concepts we are no
longer tied to technology stacks because
these things are independently
deployable we want to have smart
endpoints and dumb pipes basically it is
easier to reconfigure things if the
things on both sides of that pipe are
the ones that are enforcing the
assumptions that are doing the
validations rather than having to
rejigger what's going on in the pipe
when I want to move things around so
smart endpoints and dumb pipes and a
lack of a centralized shared database
one of the things that we start to think
about when we're breaking up these
monoliths is what should the data
architecture look like what are the what
are the units of data that we want these
different services to be effectively the
master of who is going to be responsible
for maintaining information related to a
particular business concept and maybe
other applications need some kind of
cache of that but but we have a much
different view of data architecture so
what are some of the implications of
this well first off the granularity
question is crucial when you try to
decide what your service boundary should
be that is probably the single biggest
design decision you're going to make in
a microservices architecture and you
want to balance having something that is
a cohesive whole with the amount of
coupling now it's interesting internally
we have at various points in time
conversations about well I'm at this
place and they've got a couple hundred
services and I want to merge services
together and another group will be
saying I'm someplace and we're actually
trying to separate our services that is
one of the things that you're going to
be doing a lot of is splitting and
merging particularly until you
understand what those boundaries should
be and I'll come back to that point
later these things are independently
scalable which gives you a lot more
flexibility in terms of how you're going
to deploy so if I need to scale up one
service because of its a compute profile
that doesn't mean I have to scale up
everything else monitoring of this is
critical if you've got a monolith by
definition you have one thing to look at
or one thing in each date data center
when I replace that monolith with
multiple services I need to start
looking at how all of those different
services are working are they all
working are they all working properly
and so I need a much more sophisticated
monitoring regime than I do if I have
them just have a monolith and we have to
design for failures that we don't have
to think about when we're in a monolith
we have to think about okay well what is
the consequence for the this business
process which probably is made up of of
several independent microservices if
this particular service fails we have
lots of failure scenarios that we just
don't have to take into account if we're
dealing with a monolith and because we
are deploying lots of different things
and we've got a much more complicated
landscape than we have with a monolith
we really want to look at things like
infrastructure automation automatic
automated deployment all of the things
that go in with continuous delivery and
of course the downside of flexibility in
your platform is that you can have a
proliferation of technologies there are
times when making a different technology
choice is the right thing to do because
of the increased efficiency it's going
to give you in that component but you
don't want to have it get out of
control I was on one project once at at
one point we had 11 different XML
parsing libraries 11 now there are two
fundamental ways to parse XML so I could
kind of understand 211 was just people
being lazy and so we do need to have
some form of management around this
platform so that we don't have every
programming language Under the Sun and
every database under the Sun etc just
because we can so we need to keep some
level of control over what our platform
stacks look like and then of course
eventual consistency has to be managed
as soon as we start to distribute data
across these different services we have
to start thinking about what does that
mean in terms of propagation of
information one consequence of this of
course is we have to explain to our
business users what eventual consistency
means and as I know pointed out
sometimes they think that it might be
just possibly consistent rather than
eventually it will get there so we have
to start to think about what are the
consequences of some of these state
situations that we might get into
because of the existence of eventual
consistency and again if you've got one
big hunking relational database you
don't have to worry about this so
there's a lot of things on this list
that are a whole lot more complicated we
have to think about things that we just
don't have to think about if we have a
monolith and so that's ought to start
you thinking well why then would I do it
we want to make sure that we are going
to get the benefits from being able to
go as fast as possible to justify paying
the cost that we're paying up here this
should also tell you that micro services
shouldn't just be something you go out
and say ah I'm going to do micro
services now isn't that wonderful I'm
going to be one of the cool kids and of
course finally interface churn needs to
be managed
particularly when you're trying to sort
out what those boundaries should be you
might actually have a lot of those
contracts that are changing and we need
to think about what that means
and for those of you who saw James's
talk that's going to vary depending on
on how how many boundaries if you will
these interfaces are going over how
closely the the teams are connected
because it's easy to change the service
boundary when the person sitting next to
you is the one who's writing the other
service it's much harder if they're half
a continent away or half a world away
okay so those are some of the
implications of making this choice and
some of the things that we're going to
have to think about and the problems
that we're going to have to solve if we
go down this microservices path so we've
got two possibilities
the first is Greenfield we all love that
when we get to develop an application
with nothing no legacy whatsoever it
does still happen occasionally but it's
rare and one of the things Martin is
going to be putting out a post on this
soon the thing that we're recommending
is in general don't start developing a
greenfield application using micro
services you probably don't know enough
about the domain to even get close on
the service boundaries and so start
building it as a monolith try to make a
modular try to make it easy to to
separate these things but don't start
with micro services until you have a
real understanding of where those
boundaries ought to be so generally
speaking you are going to be breaking up
a monolith it might not be an ASCII you
knows big ball of the mud monolith but
you're probably going to be starting
here regardless and so the first thing
is to think about this from the
perspective of a bounded context and
this is the notion of from Eric Evans
domain driven design what is it that you
can draw a cohesive circle around that
self-contained
and and that represents something that
makes sense in the business domain where
are those bounded context and that's
going to be one indicator that that
probably going to be a reasonable
service boundary for you so that's the
first thing to think about it and going
back to what I was saying earlier you
have to have a fair understanding of
your domain to be able to make decisions
such as this and you know we all know
these domain models tend to evolve over
time as we learn more about the
application that we're trying to build
and so what constitutes a bounded
context in your mind may actually change
as well so this is this is the first
hint of what a service boundaries should
look like try to think of it from the
perspective of domain driven design and
bounded context again think about
business capabilities what are the value
streams that exist in the organization
what are the products or services that
are being delivered by this system think
about it from that perspective and and
that will also guide you in thinking
about ok what makes sense in terms of
drawing a service boundary think about
what the consumers need rather than
these producer driven contracts try to
do a pull try to think about this from
the perspective of what is the user of
this service going to want and build
those contracts think of it from the
consumers perspective first because then
you're responding to a real rather than
a perceived need and think about the
communication patterns which services
might be using or which parts of the
system might be using the same data
which might how might they have to
collaborate to achieve a particular
business outcome what do those
communication patterns look like because
one of the things you're going to be
balancing is if I split a process across
to two services I've got a communication
boundary there and that introduces time
that introduces potential for failures
so I've got to think of all kinds of
failures so think about how those things
are going to be communicating when you
decide whether or not you want to
combine those two into one service or
keep them separate and think about the
data architecture people often
think about things like what is the
retention policy what what are the
protections that are necessary what is
what are the impacts of things like
eventual consistency how you think about
the data and what the proper
organisation for the data is also
something that is going to indicate to
you what a sensible service boundary
might be because services own their data
we're no longer thinking about services
that are floating around one large
database we we've got separate
persistence stores for each of these
services as well think about correlated
change patterns if two parts of the
business tend to change together that is
going to be an indication that maybe you
want to combine those into one service
so think about the likely changes that
are going to happen be prepared though
to get it wrong be prepared you might
have to merge services together you
might have to split services back out
again and given the fact that we've got
separate data you might be splitting
data you might have to if one service is
now going to be the master in terms of
updating the data maybe the other
service is going to need to cache that
data if you're going to merge them
you're going to have to do the data
migration so again service boundaries
are not something you want to change a
lot because changing those boundaries
has significant implications as well and
be a tolerant reader one of the things
that we try to do and this is this is
one of the connections to evolutionary
architecture we can't make it so that
you never have to make a breaking change
that is not possible but what we can do
is ensure that we only have to change
when there is no other choice and
tolerant reader is one way of ensuring
that the only time you have to change
your service is when they're changing
something that you need so when we were
looking at this this will allow those
interfaces to change a bit more before
we actually have to change our
implementation okay so what are some of
the other connections to evolutionary
architecture well when I talk about
evolutionary architecture there are lots
of different principles that that I
think are critical and and why I think
evolutionary architectures is actually
so important and these are some of the
principles that microservices exhibit
first and foremost the whole reason
we're talking about micro-services is
because we want to be able to rapidly
change the system so the focus the
reason we are doing micro services is to
allow us to change as rapidly as
possible an evolutionary architecture is
all about making evolvability one of
those first-class illa T's that
architects worry about not just
maintainability but evolve ability and
part of evolved ability is not
predicting the future it's being in a
position to respond to changes
regardless of whether you were smart
enough to think about them or not so
often in the past evolution reuse was
always focused at I have got to be smart
enough to figure out all the different
possible ways this could change and I
write all kinds of things for this
hypothetical scenario that chances are
never comes to pass and so micro
services are focused on evolvability we
want to think about the evolution of the
system as a first-class object talent
reader I already talked about but
obviously tolerant reader is another way
that we make it possible to change
things as much as we can but before we
actually have to break something
exploiting Conway's law we are looking
at how do we structure organizations and
what that means for the systems that
result if we have the right kind of
ownership of services within a team with
the right kind of
focus then what you get are these
loosely coupled independent if you will
services and you've got a strong sense
of ownership many companies who have
adopted something like marker services
have a model where they don't have a
separate support and maintenance
organization anymore the people who
write the services are the ones that are
carrying the pagers and so obviously
they have a vested interest in making
sure that that code is a solid as
possible because they don't want to be
disturbed on a Saturday night they are
responsible and that sense of ownership
carries forward into their stewardship
of these services appropriate coupling
one of the ways that that we look at
evolutionary architecture is what is the
right level of coupling balancing off
the performance and the complexities and
all of that contracts one of the ways
that we allow different parts of a
system to evolve independently is by me
knowing what assumption you're making
about my service some of the best
enterprise architects I've ever known
are the ones who carry around in their
head all of those funky little
connections between systems that
everybody always forgets about the
things that this system needs this other
system to do that really doesn't make
any sense
but they know that those things exist by
using contracts and these automated
contract testing test tools we can start
to document the assumption that
different parts of our system are making
on on each other and that way I can give
you my tests and then I can go and do
whatever it is I want safe and the
knowledge that when that that when that
test breaks that's your trigger for a
conversation you call me up and said
okay we've got to talk because I just
broke one of your assumptions some
change that I'm making is going to
require a change on your part until that
happens I don't need to know a thing
about what you're doing you don't need
to know a thing about what I'm doing we
can go completely independently and so
this this level of documentation in a
test
which therefore we know it's going to be
kept up to date gives us that
flexibility and that safety net to be
able to do things these things
independently and so that's why these
these contracts between micro services
are so important as well and of course
I'm from thoughtworks this is a talk
therefore I have to talk about
testability but but one of the
interesting things that we have found is
if you do nothing else in terms of your
architecture if you concentrate on how
easy it is to test your system you will
end up with a cleaner architecture and
if you think about it that makes sense
something that is easy to test has a
well-defined description you don't have
to say I need to test this and this and
this and this and this you have
something even if it's at a very high
level like an end end test you have
something that succinctly describes the
behavior things are easy to test when
they are visible when you've got the
right knobs to turn you've got nice
separation and in general we have found
that just paying attention at whatever
level you're talking about whether it be
code level or system level thinking
about testing gives you a better
architecture and so this focus on how
easy it is to test these individual
services how easy it is to compose them
how easy it is to then understand what
is the end end behavior expectation with
all of these different services think
about testability and you will end up
with a better architecture and generally
speaking an architecture that is much
easier to change because of the way the
boundaries are defined so then what rule
does continuous delivery have to play in
all of this well first and foremost
Micra services are a whole lot harder to
run in production than a monolith and
it's going to be a much bigger burden on
your operations department there are
more things to deploy there are more
things to monitor there are more things
to go wrong
you've got more databases so you've got
more things to backup separately and all
of those things you have to think of you
multiplied them and so it's going to
increase the burden on operations or
things deploy more things to monitor and
that monitoring and the failure recovery
how you bring a system back up is much
more complicated you've got many more
permutations of how things fail in a
micro-services architecture I put
inadvisable on the slide basically I
believe it is borderline irresponsible
if not outright irresponsible to try a
micro services architect architecture if
you don't have a strong DevOps culture
if you've got to throw over the wall
mentality between your development team
and your operations team this is going
to be a disaster there are so many
things that can that need to be done
properly that need to be understood and
if you don't have the strong DevOps
culture your ops team is going to end up
hating you it's also inadvisable without
a lot of the rigors that come with
continuous delivery when we start
looking at infrastructure automation we
want to be able to reliably recreate
environments when you have all of these
different error possibilities error
scenarios your ability to debug is
critical and if you don't really know
for sure what version is running in
production how in the world are you
going to debug and so the rigors that
come with continuous delivery are also
critical to overcoming some of the
issues or some of the implications of
using micro services so infrastructure
automation deployment automation and of
course test automation you want to be
able to understand how these different
services are interacting with each other
you have a much more complicated test
landscape even the happy path is a whole
lot more complicated let alone thinking
about all of the different scenarios
than just having one big monolith so you
want to think about test automation as
well so how do I get started
as I said what we are seeing is if you
if you start out thinking that you're
going to build microservices and you do
that right out of the gate chances are
you're going to get your service
boundaries wrong and you're going to get
yourself in trouble and so it makes more
sense to really start building a
monolith build it well build it in with
good separation with a good
understanding of what clean code looks
like but start with the monolith and
then as you progress as you start to
understand more about the domain
concepts you can start to break some of
those things out but starting out
building a micro service architecture
unless you are very very familiar with
the domain is probably a mistake and
it's certainly not what I would do the
first time you're ever building a
micro-services system you don't want to
start that greenfield and that's some
time that does seem counterintuitive
because if we're starting with a
monolith we've got all of that coupling
all of those assumptions that are being
made but the complications that come
from starting with a microservices
architecture are such that people just
seem to get it wrong more often than not
and so it's safer to get to a particular
level of comfort with the domain and
with some of the implementation
challenges you're going to run into with
that particular technology in that
particular domain before you start to
separate it up which is of course to say
no it is not a silver bullet we are
seeing a lot of success with
microservices architectures but there
are there are issues to consider now all
of these things that I've talked about
eventual consistency and having to deal
with it
these distributive failure scenarios
this is not something that we don't know
how to do we've been doing things like
this for a long time we do know how to
manage a process a business process that
spans over multiple processes
what happens if one thing fails we know
how to do communication we know how to
do all of these different things it's
not that we don't know how to do it it's
just that it is more complicated out of
the box
however done right what you then have is
the ability to make fairly radical
changes to particular parts of your
overall system you can completely
redesign some particular aspect of your
business and be safe in the knowledge
that as long as you haven't violated any
of those contract tests the rest of the
system does not have to change you have
enforced boundaries which will make it
much easier for you to change your
business process introduce new
functionality introduced new validations
deal with additional regulatory
requirements all of those different
things because those are the things that
are changing more rapidly as soon as one
person on a social media site puts out
some new feature now all of a sudden all
the websites have to have this new
feature customer expectations are
changing that rapidly regulatory
environment is changing more rapidly
business model life times are getting
shorter let alone all the thinking that
people are now starting to do about
security and data privacy and what am I
really doing and and what how secure is
the information that my bank is keeping
so all of these different things are
putting this pressure on us to be able
to change our systems more rapidly and
microservices is an approach to that but
it does come with a cost come on so to
learn more one more there we go so
there's a book on building micro
services this actually started out as a
book about continuous delivery and I
think one of the interesting things
about micro services if you think about
it this is the first major architectural
paradigm that has come along since
continuous delivery started being
something that was
walked about in the industry and I think
you can see that what we're talking
about from from the perspective the
microservices is not something you would
really want to do unless you had
something like continuous delivery so I
think I don't think it's at all a
coincidence that this kind of
architectural style has not come along
before now because even in the old SOA
days you didn't have the number of
services that the the granularity was
very different that was in fact one of
the problems that we had because those
services were too big and then of course
continue the the continuous delivery
book because both of these things are
important together I will reiterate your
operations Department will hate you if
you do this when you have a separate
operations department that you're
throwing code over the wall too you need
to involve them in this because their
processes of how they monitor things how
they do error recovery and such are
going to be very different so thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>