<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • An Overview of Java 9 • Angelika Langer | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • An Overview of Java 9 • Angelika Langer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • An Overview of Java 9 • Angelika Langer</b></h2><h5 class="post__date">2018-02-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vQDS4gYs8fA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to this talk about Java 9 I
tried to figure out what would be most
interesting to most Java programmers
Java 9 as such has been released in
September so it's a couple of weeks old
so to speak I don't know how many people
have already a serious intention to move
on to Java 9 it's probably interesting
to learn a little bit about the module
system because I think that's it that's
the feature of Java 9 that will hit most
people when they try to migrate to Java
9 but I do not want to talk only about
the Java module system yeah there's a
list of topics that I picked there are
some optimizations regarding the use of
strings there are a couple of changes
very minor changes I will just briefly
mention them there is something about
collection literals which I will show
you which might come handy but it's a
very tiny feature because this is the
big feature of Java 9 and then I will if
time allows I will dig a little deeper
regarding things that you might not have
been using so far some applications some
frameworks and libraries use packages
Java / JDK internal packages which now
that the JDK is modularized are no
longer available and that will probably
create some trouble and there are Java
extension proposals and efforts on the
way to come up with replacements for
these internal packages but these are
things that have been made available in
Java 9 in part but the major part is
still on the way and will come in one of
the future versions of Java like Java
1011 perhaps 12 we don't know there are
many many more features which I will not
mention actually have too many slides so
don't be disappointed if I skip a couple
of them you will have the full deck of
slides when you download them ok
regarding me I'm working as so I used to
work as a developer as well developing
in C++ and Java and then I started doing
training for a living for almost 20
years meanwhile and so each time there
is a new
Java version I take a look into what
might be interesting and what knowledge
needs to be spread in order to handle
the new and next version so I looked
into the Java generics with Java 5 or
looked into lambdas and stream throughs
Java 8 and actually I looked into Java 9
ok so let's start with the collection
literacy does anybody remember Java 7 it
for Java 7 Sun Microsystems at that time
asked the Java community watch mine our
language proposals of features or
convenience they would like to have and
one of the proposals that was raised by
the java communities they wanted a
convenient syntax for creating small
immutable collections and they didn't
solve that problem for Java 7 they came
up with a solution for Java 9 now so
what was discussed for Java 7 is the
syntax that I've been showing there this
syntax will not exist they didn't solve
the problem in Java 9 extending the
language and creating new syntax instead
they gave us a library based solution so
what we will have is off functions in
various interfaces in the java.util
package so nowadays with Java 9 you can
create a list off and then just
enumerate the couple of elements that
you want to see in that immutable list
of a few elements and this is in line
with other 50 features we already had
the collections interface already at
something like I want to create an empty
list I want to create a list of one
element a singleton list and now you can
say list of something set of something
and all these collections are immutable
collections with the number of elements
that you listed in this Factory function
named off ok then there are a couple of
further minor language features I doubt
that anybody of you actually missed them
one of them is you might remember that
with Java 8 interface methods were
invented so static and default methods
in interfaces that do have an
implementation and since everything in
an interface is public all these default
and static methods also had to be public
and some people express the wish that
they wanted to have private
two-faced methods just as helper methods
for these public interface methods and
this this is allowed no in Java eat
ramen I wasn't allowed in Java eat then
we have a diamond operator with
anonymous classes the diamond operator
was added in con remember Java 7 I think
six or seven the diamond operator is
convenience if you create objects of a
generic type like a thread local of list
of pair of something then you have a
very long type name when you create a
variable of this type you have to
specify the name of the type very long
typing then you have a variable name and
then typically you want to initialize it
by creating a new object of that type
and so when you say new object you have
to repeat the entire type name and so
they came up with a diamond operator
just saying okay
the compiler can take a look at the
left-hand side of my assignment and
figure out what the type actually is so
that I do not have to type everything so
with Java 7 you could already say I want
to have a thread local of empty angle
brackets and the compiler could figure
out the rest of the type and this wasn't
available for creating anonymous classes
and now with Java 9 we can also use the
diamond operator when we create
anonymous class subclasses of some kind
of parameterize generic type then they
change the try both resources so far
with try with resources you had to
create the variable and the object in in
front of the try block and nowadays with
Java 9 you can use a final variable
instead so that you can create an object
that has already been created before you
enter the try block order that had or
that has been passed on to a to a
function as a final argument to the
function and then you could use that in
the try block that wasn't possible
before Java night has anybody used the
safe Vioxx a notation ever oh one let's
keep it I mean it's a it's a complicated
thing regarding the combination of
variable argument lists with parameter
is types and safe words has to do with
that it's now available on private
instance methods to
and another thing the underscore is now
an illegal identifier it was legal
before Java 9 now it's illegal because
they want to use it in conjunction with
lambda expressions in some future
version of Java okay these are the only
language changes you see minor stuff not
really exciting what might be more
interesting is optimizations regarding
the memory consumption and the
performance of strings one thing they
already added in Java 8 update 20 is the
string deduplication what they did is
they change or they built into the
garbage first
collector a feature that the garbage
first collector knows how to when it
sees duplicate strings then it D
duplicates the strings puts the strings
into an cash and then thereby tries to
reduce the memory consumption of strings
so the observation was that in a regular
Java application whatever that might be
roughly a quarter of the heap memory is
occupied by strings and the idea is we
want to reduce that memory consumption
in order to speed up the garbage
collection basically to use the space
more economically and one effort was
changing the garbage first garbage
collector what it actually does is
during its marketing phase when it does
a garbage collection it needs to
identify all the reachable objects and
thereby it marks and visits all the
reachable objects and among them of
course all strings and each string has
an array attached and since drinks are
immutable objects the array never
changes so the the content of the string
never changes and they take advantage of
this fact if they find an array attached
to a string what the garbage first a
garbage collector does it puts it into a
cache and the next time it finds another
array it looks up whether it has already
the same array with the same content in
the cache and then it changes the second
string object in order to use the same
cache array so strictly speaking it's
not string deduplication but it's
duplication of a race attached to
strings and this is a feature which you
can switch on/off it says there's a JVM
startup option and if you have a lot of
duplicates you might see some benefit a
reduction in memory consumption if of
course you hardly have any string
deduplication or duplicates the
deduplication would only cost you so you
have to really if you try it out you
have to take a look at the consumption
otherwise you would just pay for the
cache and the cache look up and it
wouldn't do any any good so it's an
option which you can switch on if you
use the garbage first collector which by
the way is the default garbage collector
in Java 9 yeah so if you do not specify
which garbage collection algorithm you
use when you start your JVM you will
nowadays in Java 9 have the garbage
first collector as the default collector
ok then string compaction is something
that we really added in Java 9 the
observation is that 90% of all strings
are encoded or use and codings that can
be represented by just one byte and
there's only a minor portion that really
has multipied encodings and really needs
a character which in Java is 2 bytes
long so most of the time half of the
space that the heap space that is
occupied by strings goes unused because
we don't need half of the character and
so what they do nowadays is they do a
string compaction in the change that
whenever you create a string they take a
look at the string content and nowadays
the string is represented by a byte
array instead of a character array and a
flag that says is this a one byte
encoding or do we really need characters
a 2 byte encoding and so whenever it is
possible and feasible they just reduce
it to a byte array plus an encoding flag
and if the encoding says ok it must be
multi-part I really need the character
the two bytes per character then they
interpret the byte array as well two
bytes at a time they interpret this as a
character array so they do this I think
it's the default you do not have to
switch it on ok
then something that affects the internal
handling of string concatenation so far
you probably know that string
concatenation using the string plus
operator is a fairly expensive thing
because for each concatenation Java has
to create a new string because the
string objects are immutable so you
create if you do a concatenation of
strings
hello plus word plus something else you
create a lot of temporary strings that a
lot of copying goes on okay so they
optimize this in Java five anything and
the Java see the static Java C compiler
learned to replace string concatenation
sequences by using a string builder and
string builder append and a two string
operation in the end so this is one
thing it's not optimal in all cases
because it starts with with a fairly
short string even if we know that the
string concatenation would lead to a
large string there is no optimization
like using a pre calculated capacity for
the string so it builds up the capacity
over time which is inefficient I mean we
could do better and then there is a
second construction side that also takes
care of optimizing string concatenation
and that is inside the just-in-time the
hotspot compiler and the outputs hotspot
compiler if you if you specify this
optimized string Concord of team ization
also tries to do aggressive
optimizations mmm
aggressive is already telling you it's
kind of a fragile difficult optimization
and so they have basically two
construction sites the java c compiler
that tries to optimize string
concatenation and the hotspot compiler
and they try to simplify it and what
they do nowadays in java 9 is when there
is a string concatenation sequence the
java c compiler doesn't do any
optimizations anymore instead it emits
an invoke dynamic byte code
invokedynamic is one of the byte codes
invokedynamic has been available since
Java 7 and it was initially added not
for use by Java but it was a byte code
that had been added
to support other languages that run on
top of the JVM and that had difficulties
with invoke static invoke virtual and
invoke special the three byte codes that
were designed for invoking Java methods
because other languages have different
ideas of how to look up methods and how
to invoke them about the calling
sequences and so they needed something
that is more flexible and then they
added invoke dynamic and the key point
of invoke dynamic is whoever emits this
bytecode also has to provide what is
called a meta Factory which is basically
a description of what invokedynamic is
supposed to do at runtime and this is
very flexible and they use it here in
order to add a matter of factory that
says ok we need to do string
concatenation at this place and then
internally the JVM when it runs at
runtime can figure out what to do based
on the meta Factory and it can apply any
type of optimization so nowadays with
this reorganisation of string
concatenation they have one place where
they can do all the optimizations it's
done at runtime and it's entirely
internal so you wouldn't notice any of
this it's just a change that makes it
easier to maintain and evolve the JVM
another thing related to strings is well
we have this class data sharing feature
for some time can't remember how long
but they did they try to reduce startup
time and and footprint of JVM long ago
by creating so-called shared archives
when they deploy the JDK they create a
shared archives and these shared
archives typically contain classes class
files basically already prepared loaded
classes that at startup of the JVM are
simply mapped into memory and the idea
was it saves the time for actual class
loading if we prepare things like object
and throwable all the stuff that every
application already needs and these
shared data archives have been around
for for quite a time and they are an
effort for speeding up startup and now
they use these shared data archives also
to to place all the intern strings into
the same share that archive so that they
need
need not be created at runtime at
startup time the intern strings are
those strings when the Java C compiler
compiles your your source code for a
class and inside the source code it
finds string literals some some kind of
string literals that you have physically
in your source code they are placed in -
they are placed into such as shared
archive nowadays they were usually
attached as a constant pool of so-called
constant pool to the class objects and
now they are put into these shared
archives along with the precompiled
classes so that would speed up startup
time they supported only for 46 bit
platforms which is probably the norm
okay now we dive into the entirely
different topic the module system the
big feature of Java 9 module system
consists of quite a number of Java
extension proposals the first thing that
they did is what they modularized the
jdk itself so the jdk nowadays doesn't
come as RT dot jar one jar file anymore
but it comes as a bunch of modules that
is one thing and then they tried to over
time they try to make available the
module system to the Java community so
that you and your applications and
libraries that you build also can use
modules to express kind of import-export
relationships between these logical
entities that are called modules so the
first thing is the deployment is
different you will not see RT Doge our
two tools jar you will see a directory
called mods I think and then you have
lots of J mod module files yeah and it's
an entirely different organization ok it
also means that the idea is you and all
the library and framework providers that
you rely upon should over time
reorganize and re-engineer their
applications and their tools in order to
modernize themselves and their their
their applications
and Java 9 is just the start of a
transition phase so ideally after a
while we don't know how long this will
take everything should be expressed as
Java modules whether this will happen we
will see yeah I will be probably a very
long transition phase so what is a
module a module is a logical entity that
contains classes native code properties
basically what we put into a jar now
nowadays but a jar file nowadays is just
a container it doesn't have any
semantics attached and a module is
different with a module you can describe
which other modules module one needs
that's the so-called readability
property which you have to describe and
also you can describe which packages a
module makes accessible to other modules
so you have an readability and an
accessibility description attached to a
jar file and such a modular jar file is
then a module in terms of the Java
platform system ok so the idea of the
module system then is once we have these
readability and accessibility
descriptions the Java C compiler the
runtime system and also everything
that's done with reflection tries to
check whether these readability and
accessibility relationships match so
everything that is needed in terms of
readability there's some module that
needs to read another module all these
mud modules must be available at runtime
at compile time for reflection it's all
checked ok so why did they do this I
will say very there are heated debates
and they took a couple of years until
they came up with a module system for
Java 9 one of the problems they try to
solve is well the protection scheme that
we had so far is insufficient so far you
could qualify types as public package
visible protected private so there was a
protection scheme but there's a problem
I mean you can work around it
example is if you think of the early
times when they built the JDK Sun came
up with Sun dot something packages and
every class and every type in these Sun
packages was supposed to be private in
the sense that it's only available for
other JDK utilities or other JDK classes
they were supposed to use these Suns
specific classes but they were never
meant to be available for public use for
everybody so they are actually kind of
private JDK internal packages now the
problem is what if you want to build
some JDK class that uses Sun Micheline
or something one of the classes that is
widespread used a lot is the Sun which
Elena sensei
so many of the JDK classes use Sun
miscellaneous unsafe what could you do
to protect the unsafe class from
widespread use you could make it package
visible but that requires that every
other JDK class that needs some
miscellaneous unsafe must reside in the
same package so basically you would end
up with one huge package and that is
quite obviously not a reasonable package
design so they split up the JDK into
various packages and for this to work
they had to make some miscellaneous
unsafe a public class then they came up
with other protection schemes like
accessibility checks and so on and so
forth in order to somehow make it or
take it away from public use but you can
work around all this so nowadays some
miscellaneous unsafe as a prominent
example is used in many frameworks in
many libraries it is basically it's
public so there was no really safe way
of protecting internals from being
publicly available and that is one of
the problems they try to solve with the
module system and they actually did
solve it so something like some
miscellaneous unsafe now resides in a
package called JDK internal and it is
internal now it's not a not readily
available for anybody anymore which
might create trouble of course because
so many frameworks use it nowadays
okay another problem that people had
hoped the module system would solve is a
form of jar
what if you have a very large
application and one component of your
application uses a certain library let's
say the guava library for instance in
version 1 and you have another component
that needs the same library in another
version version 3 or whatever then you
end up with two versions of the guava
library on your class path and you know
when class loading happens it takes the
first class that it finds on the class
path the second one will be ignored
so which one is the right one that's a
dilemma that you have to solve nowadays
typically you solve it by taking the
latest version and hoping it's backward
compatible sometimes it works sometimes
it doesn't so this is a form of jar hell
people had hoped that this would be that
the module system would solve this
problem but it does not so they started
out when they developed the modules by
allowing to specify that one module
needs another module in version
so-and-so but after a while they
discovered that yeah in order to resolve
all these version dependencies they have
to come up with some kind of strategy
and there's several strategies for
resolution conceivable and already the
build tools have strategies and then
Java would have when they have different
strategies actually and Java would have
come up with yet another strategy and
how to how do we reconcile this and then
also there was there's also another tool
OSGi that also supports version control
and dynamic class loading and modules
and they had entirely different ideas
and they were heated debates they
couldn't even figure out what a version
actually means what should go into a
version so they couldn't come up with
any kind of compromise so that
eventually the people at Oracle said
okay modules don't have a version and we
can add this later but for now this is
too complex we just skip the entire
version resolution problem so modules in
the module system in Java 9 do not have
a version and so though you can't solve
this this kind of Jar help problem in
any different way than you did in the
past so there's nothing new to it ok
another thing they try to address with
the
module system is deployment size
nowadays if you want to create a self
self-contained unity for for deployment
you would include the entire JDK
although perhaps you need only a
fraction of the JDK classes and with a
module system it's not possible to
create so called runtime images and a
runtime image would only contain all the
JDK modules that are actually needed so
everything that you don't need know
isn't included into the runtime image
and thereby you can reduce the the
deployment size of what you deliver ok
so let's look into some of the features
I will not cover all of it I mean the
the Java module system fills books and
you can do workshops taking one to three
days if you want just the bare minimum
the first thing they did is they
motorized the JDK so this is the module
graph of all the JDK modules it took
around five years to take the JDK as it
was to come up with this kind of module
graph this graph has to be a directed
graph without cycles so if you have the
classical spaghetti code you have to get
rid of your cycles in order to come up
with a reasonable module graph that is
directed and has no longer has any
cycles so that alone took five years now
if you imagine you want to modularize
your application you can figure out how
long this will take
okay so let's address the migration
issue basically what does it mean if you
take your applications and frameworks
and try to migrate to Java online maybe
you win it wouldn't even notice that's
the best-case scenario yeah you just
move it to Java 9 compile and runs
without any trouble you wouldn't even
notice that JDK nowadays comes in
modules instead of runtime dojo ok
that's the best case maybe you have to
adjust your program and there might be a
couple of things a couple of issues even
if you do not intend to modularize your
application itself you still can run
into trouble just because you have Java
9 underneath one of the problems could
be you have been using one of these son
internal packages
if you do so I mean they told you you
you're not supposed to use them if you
did now you're in trouble they are no
longer available there are workarounds
you can make them available but the idea
is you should get rid of these some
internal stuff yeah another thing is if
you've been relying in some form on the
on the binary structure of the JDK like
you are reading runtime dojo you're
trying to read class files from Artie
dojo and that is now different the class
were of string dot class for instance is
no longer in our tea tour charts in a
Java base module so something things
will change also they changed the Java
version string so if you've been passing
the version string like figuring out
yeah the version is one dot something
it's no longer one dot something it's
version 9 so passing my field so these
are tiny things that might create
trouble and adjustment make make
adjustment necessary if you move on to
Java 9 also if you have split packages
you are also in trouble
split package problem is let's take an
example the e guava library has
interesting classes but many of these
classes are package protected so they
are not available for actual public use
but I mean if the class is interesting
and I want to derive from the class and
add some customization what do I do
yeah I build a new subclass of that
particular interesting a guava class and
since this one is package visible or has
a package visible constructor which I
want to call what do I do
I place my class into the guava package
and that's this is a split package
situation and split packages are not
allowed under the module system as soon
as the guava library comes as a guava
module your bets are off
I mean it wouldn't compile any longer
because you're stuffed I mean your
contribution to that particular guava
package is now in a different module and
a package can only reside in one module
you can't have split packages anymore
yeah so if you have any any situation
like this you have to figure out a
solution so it gets a little complicated
there are ways I mean the after after
why they got a lot of critique and
feedback before they really release it
they came up with with a lot of flags
that you can set for starting the jvm so
you have to figure out workarounds for
these things and the idea is long term
you should have any of these problems
anymore because you changed your source
code okay what you can do in order to
prepare yourself
they added already in Java eight
actually a new tool which is in the bin
directory of your jar JDK deployment
which is called Jade EPS it's the
dependency analyzer and it can for
instance figure out the dependencies
among your packages it can also generate
module descriptors or suggest some
initial form of module descriptor and
one thing that it can do is it can check
for use of JDK internals all these if
offensive uses of Sun Micheline or
something and then you have to start it
with a certain option jaidev's check for
jdk internals there's an option for this
and then it comes up with messages like
this for instance in this case there is
use of sun security x.509 and a certain
class on that package and this is no
longer available and they also give you
a hint what you should be using instead
so for some of the things that are used
from some miscellaneous or Sun internal
packages there are already replacements
and you are supposed to get rid of this
class and use the new one so you can
check and get a feeling for how much
trouble you might run into okay
the workaround by the way I mean if you
need this particular class and it's now
in the JDK internal module and by
default it's not available but you can
make it available you can break the
encapsulation of modules by starting by
compiling and starting the JVM using
these minnows - - ad exports directive
so this is something you can specify for
compilation and also for runtime and
then you can say ok and I want to make
available this package this protected
strategy internal package oh it's in
Java based I think -
I my packages and since you have
modulized anything all your packages
reside in an unnamed module so what I'm
basically saying is this internal class
I want to make it available to my
unnamed stuff yeah and then you can do
so so this is kind of a workaround if
you stuff for some transition need these
protected and JDK internal things you
can do so but I mean there's no
guarantee that this class will be around
still in Java ten or eleven yeah so the
work for you is to figure out the
internals to figure out which options
you have to set for the time being and
then go ahead and get rid of all the
internals for the next version and
before they disappear and you have no
work around any longer okay if you want
to create modules what does it mean
let's say you really want to modularize
something or you want to start a new
project from scratch where it really
makes sense to just use the new module
system what it means is that you have a
different source code structure so for
if you so far if you have a source
directory you would have one directory
per package so far and now we have an
additional directory level so we will
have a directory that represents the
module and inside that module directory
you would have all the package
directories so there is an additional
level of directory representing the
module and a module contains packages
and the module in addition to all the
packages contains a module info dot Java
file and this is the so-called module to
scripture that actually has these really
readability and accessibility
descriptions and it must sit well on the
top level yeah directly in the module
directory and the module directory as
with package directories it must match
the name of the module the name of the
module will also appear in the module
descriptor and the module info dot java
file student.java it and later you have
a module info dot class which you
package into a jar file along with all
the other resources and classes that
belong to the module so it's an
additional entity that you have to come
okay this is what a module in food or
Java looks like you say module then you
specify the name of your module and then
in the body you would specify the
readability and accessibility directives
okay
so you can specify what you want to make
available so a module specifies which
packages it exports and as an exports
directive you know so this module says
it exports package 1 my package 1 you
can also have qualified exports you can
say ok I export it but just to one
particular module yeah so the first one
is an unqualified export makes it
available to all modules that might be
interested the other one restricts it to
certain modules ok so this is the
accessibility specification one module
makes available packages potentially
restricted to some other modules and
this is the corresponding the kind of
import statement you say I require one
module says I require another module so
this is a second module and the second
module requires the first module the
first mode you made available some
packages and the second one is to say
and I require it so there is a bilateral
relationship between these two so it
would not compile if only one module
says ok and I make these packages
accessible and the other module doesn't
say that it wants to read them in that
case it doesn't compile and it doesn't
run so there must really be the export
statement in one module and the requires
in another module it's a little
confusing perhaps at first sight because
you export packages but you require an
entire module or several modules
that's the requires directive there are
more directives I will leave it at that
there's also opens and users and
provides for other special cases but
these are exports and requires are the
basic directives for specifying
readability and accessibility so is this
this bilateral relationship that must be
established in the various module info
files and then Java C checks for it the
runtime checks for it core reflection
checks
right here you can't get hold of stuff
that you haven't required and that
hasn't been made available even at
reflection time okay then there is a
transitive export so if the let's say
the Miller module makes available its
packages to the topmost module and it
uses all let's say it uses a third
module and classes types some elements
from the third module appear in the API
of the middle module in that case the
topmost module has an indirect
relationship and indirect requires
relationship to the third module without
even knowing it and in order to make it
more flexible and more easy more easily
to to to develop later on what they
invented is a transitive requires so if
the middle module says ok I require the
third module transitively then it makes
available to its using modules
everything from the third module yes so
that the first topmost module does not
have to explicitly specify that it
indirectly uses the third one so it just
has a requires directive to the middle
one of the middle one says and requires
the third and requires transitively that
makes the difference okay what does it
mean when I develop modules there are
various new tools and lots of new
options if you want to write Java C or
the JVM itself one thing that is really
different is in addition to a class pass
we now have a module path and the module
path on the module pass they have to
list all the jar files that contain your
modules hmm it's similar to the class
path it's just a second path for modular
jar files you also have other options
like show module resolution if you start
your JVM will show more your resolution
is similar to verbose class it just
tells you okay this is the root module
that contains the main class and then it
requires this inter centers and you will
see the transitive subset of all
required modules and
where they are found we get our messages
if something cannot be found and so on
and so forth okay for diagnosis it's
helpful so a module in the end is a so
called modular Java you create a Java
file and add the compiled module info
the module descriptor so you ever want
to one relationship between a modular
Java file
and yeah the module itself okay then
there are obviously new options needed
for the jar tool you can specify the
main class you can list you can describe
the module describing the module means
it gives you the content of the module
description so there are new options for
modular Java files they already
mentioned runtime image there is a new
tool called J link which creates a
modular runtime image basically what it
does it's not like linking in a language
like C or C++ where you really link
everything statically to create one
executable file that's what it does a
runtime image is kind of a deployment
structure that is similar to the
deployment structure of the JDK in Java
9 and what it does is it includes only
those modules that are actually needed
this is addressing the deployment size
problem that I mentioned so if you
create a runtime image starting from
your top main root module yet will
include only those JDK modules that are
actually needed and they will all be
packaged to a so called runtime image
which you can deliver and then what it
creates is a deployment structure that
has one big module file and it contains
only the necessary stuff so this is
created using the new J link tool ok now
that's more to it but let's keep it at
that one problem you will have over time
is that you have to migrate probably in
steps I guess it will take many many
years until the entire Java world is
modular so what you have today is
probably your application is not modular
third-party libraries or frameworks that
use are probably not anymore not yet and
you have only the JDK which is already
modular so ok now
say you start to modularize your own
application so you do a top-down
modularization but you will use jaidev's
you will write the will figure out what
a reasonable module would be it's
probably relates to what you have as
Java is today that's the most natural
thing and then you write the module info
files everything's fine so let's say
your application is Modula after a while
you might still run into the situation
that other things that you use libraries
frameworks that they haven't catch you
haven't caught up yet so you would have
a mix of modular stuff and non modular
elements how does that work what you can
do is if you have let's say the
non-modular part is a third-party
library like the guava library for
instance or something else what you can
do is this data level deliver a jar file
a non-modular jar file as they did in
the past and you can take that jar file
and put it onto the class path as you
did before and everything that you put
onto the class path not onto the module
path but onto the class path as before
ends up in a so called unnamed module so
everything that isn't a named module is
basically an unnamed module on the class
part the class path is more like a
special module it exports everything all
these packages it requires everything
the only problem is if you have named
modules you can't require anything from
the unnamed module so if you need a
package from the guava library you would
have to say well requires guava package
so-and-so but I mean it's in an unnamed
module you cannot require packages you
can only require modules and if the
module doesn't have a name there's no
way to require it bad luck so in order
to solve that problem they invented
automatic modules so to solve the
problem that your modules cannot access
unnamed modules you take the jar for the
guava jar file and don't put it onto the
class pass but put it onto the module
class although it's not modular yet so
you can take regular non modular jar
files put them onto the module path in
which case they are considered being
automatic modules and an automatic
module is a name
module with a derived name so they take
a look at the Java file name and from
that file name they derive an automatic
module name and since an automatic
module name has a name I derived
synthetic name you can now have a
requires directive to the guava library
module okay the problem is the name that
that is derived from the Java file name
might be different from what the guava
library sometime in the future might
pick as its module name which then
requires that you have to change your
requires directives so this is asking
for a future trouble okay so this would
be the situation then yeah so you have
your application in modules the JDK is
and modules you take the guava library
put it onto the module path it's then an
automatic module and automatic modules
can use unnamed modules so if the guava
library needs something from some other
jar file on the class path that would
work so only automatic modules have
access to unnamed modules you see it's
fairly complex if you have a mixed type
situation to put all the elements onto
the write module path or class path in
order to make it work in the end ok
there is more regarding migration I mean
one substantial problem is if you have
frameworks that access your classes
using reflection and typically using
what is nowadays called
deep reflection if they need access to
private parts of your classes they
typically use said accessible in order
to get access to the private parts and
that is now restricted then there are
opens directives you can open your
packages for illegal reflectional
illegal excess and there is more to it
yeah so there's more trouble to come the
point is for Java 9 this illegal
reflective excess is permitted by
default but the default will change with
the other ten so in Java
10 you will have to figure out whether
you have a new version of the framework
that does need the illegal access
anymore or that you add all the
necessary opens directory
so they made it easy to move on to Java
9 but it's not the end of the story some
things will change when you move on to
Java 10 so you should be prepared that
there's more to come more traveled ok ok
critique yeah it's kind of confusing now
you have package private and so on and
so forth plus you have the module
descriptors if a class is public that
doesn't mean you can access it you need
to require the module and the module has
to make available the respective package
otherwise a public classes in public so
it's more complex there are more places
where you have to look in order to
figure out whether you can use something
ok then adapting existing code to a
modular system module realizing it might
be a lot of work think of the five years
it took to more generalize the JDK it
might be close to infeasible if you have
a split packages so I think the
realization is if you have an existing
application you should probably think
whether you really want to turn this
into modules it's a lot of work if you
see value in having a better
encapsulation go ahead and modernize but
I think in practice library providers
and frameworks will have to moralize
that stuff because they might have used
us that start new projects from scratch
and if you if you start from scratch and
make sense to build your application in
terms of modules but taking an existing
app lamay application changing it into a
modular application is probably overkill
but it's up to you to decide whether you
want to take advantage of the
encapsulation mechanism so much ok then
we don't have the module versions so
there's no solution to jar hell which
has been deployed by many people but
that's it didn't change if you want to
read something about it there is a white
paper by Marc Reinhard who is the chief
architect for the SE version of Java the
tool reference is interesting because
there are lots of new tools and lots of
new flags and you really need to learn
about all this if you want to build
modules I want to get get ahead of it
there are also a couple of books this is
one of them I looked into the one this
and one is on the way will come sometime
next year but there the guy Nicolai
Pollack has a lot of blocks so he writes
a lot about it ok do I still have time
four minutes okay I can give you a
couple of ideas of what is available in
terms of replacement of some
miscellaneous oh yeah do ya the rest
goes deep into the stuff does anybody
use some miscellaneous unsafe okay then
we can safely skip it just very few
people the problem is the libraries that
you are using they typically use it so
they have to solve the problems and
figure out how to replace all these
things from Sandwich Elena's unsafe and
this goes deep into var handles has
anybody been using method handles also
unknown yeah so this goes deep into the
innards of JDK so let's give this one
purpose what is still interesting is the
J shell we have a shell tool into which
you can type in Java source code
fragments and it gives you an immediate
it evaluates the expression so you have
kind of a read evaluate write loop yeah
so you don't have to write an entire
program if you just want to try out some
some tiny stuff of Java code and there's
many more stuff I'll give you an
overview let me see okay there's a new
HTTP client but it didn't reach the
quality level that had that they had
intended it isn't so called incubator
mode so you can try it out and provide
feedback to Oracle so it's not really
usable then we have an improved process
API you get better control for managing
OS processes if you if you want to
create some g1 is the default garbage
collector which is important for those
who didn't specify it's any any specific
garbage collector so far what also
changed is they have unified JVM logging
so far every component of the JVM the
garbage collector the JIT compiler and
other parts have been emitting
Diagnostics information on request using
certain flags like print GC detail
or whatever and it all looked different
and now they unified it which also
changed the flags that you use for
requesting diagnostics information so
there's an entire new flag called X lock
colon and then you can specify wildcards
for the amount of information that you
request as diagnostic so the output
looks different the way it is controlled
is different and I guess many tools that
have been parsing JIT locks or GC locks
or something they will take some time to
catch up with in you format in order to
parse it correctly so there's a lot of
change there's a lot of internals yeah
Javadoc is now in html5 format it has a
search box I mean haven't been needing
this for decades
so there's many most of much of it is
internal ok questions we've got a few
questions in the app I don't think we
can answer all of them one of them is
pretty provocative I would ask that in
this way here is it kind of safe to just
ignore the modular system I mean the
question was a little bit different it
said what kind of problems what I expect
if I don't modernize my application
today if you do not modernize its you
will you can still run into trouble
because most applications use some third
party stuff and the third-party
libraries usually use some miscellaneous
unsafe so they will not compile and
first play right away so you probably
should wait until all the things that
you use come up with some kind of
solution for their problems I mean you
might not necessarily have problems
yourself but you might be using
hibernate and having it does illegal
access and so on and so forth so it is
probably difficult to simply ignore it
and even if you ignore it there might be
hidden problems that will pop up in Java
10 so it's probably plan on spending
some time for migration I think
okay fine and then there were quite a
bunch of questions around how does it
relate to what we know from Gradle maven
or maybe even OSGi and what's difference
around that can we get maybe OSGi is
there's basically no relationship they I
mean there was the debate and they
couldn't reconcile their different views
the idea is Austria does its stuff when
it's way more dynamic and flexible at
runtime whereas the Java module system
is just a static dependency description
and what they provided is if OSGi wants
to rebuild its stuff on top of the Java
module system then there is an API for
creating class loader layers and
rebuilding OSGi on top of the module
system I don't know whether they intend
to do this and mainland and Gradle yeah
they also have to upgrade to Java 9 and
come up with support for describing all
these dependencies for describing I do I
put this as an unnamed module
automatically or something like this and
to the best of my knowledge they haven't
caught up yet so tools support is
insufficient right now I did a workshop
last week and we're actually using
console Windows and UNIX scripts in
order to get stuff I mean one guy just
said that's entirely your rate room is
this awful so there is no IDE support
basically for simple cases yes but as
soon as this gets a little more complex
and you have a mixed situation orb
itself so just wait okay what
interesting last words
just wait but ok fine we keep it at that
because we're slightly over time thanks
a lot for you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>