<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2013 • Taking The Hippie Bus To The Enterprise • Mogens Heller Grabe | Coder Coacher - Coaching Coders</title><meta content="GOTO 2013 • Taking The Hippie Bus To The Enterprise • Mogens Heller Grabe - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2013 • Taking The Hippie Bus To The Enterprise • Mogens Heller Grabe</b></h2><h5 class="post__date">2015-10-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xVAQ87ms00s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this presentation is it's called
taking the hippie bus to the enterprise
it's about three problems that I have
experienced as a in my life as a
software developer and I'm going to show
a solution that I think is a pretty cool
to these problems yeah my name is Monte
laba and I'm a software developer at a
pretty cool bi consultancy and software
development consultancy called 80/60 and
and I'm also a software developer at a
company called particular software that
develops actually a competing product
called
in-service bus so it's kind of a finicky
situation for me but but I'm still
allowed to work on a rebus and I'm still
allowed to talk about it so that's one
well that's what I'm going to do today
if you have any questions or think of
anything afterwards please write me an
email or contact me on Twitter yes this
presentation will be about I will start
out by talking about what I think your
problem is and by that I mean possibly
actually I may mean that that's my
problem so I might be protecting here
but in my life as a software developer I
have often come across these three
problems that I'm going to talk about
and I'm seeing them solved in a many bad
ways so I'm going to talk about how to
how to solve it in a in a better way so
that's the part where I introduce my
rebus project which is a dotnet service
bus actually I like to think of it just
as a messaging library and then I'm
going to show you some fairly concrete
examples on how these problems can be
solved yeah and some wrap-up afterwards
I will start up with some slides and
some talking and but after all this
talking on the architecture track I
think some real live running code is in
place
I'm going to show you some code as well
I hope that's a ride alright so what's
your problem I'm guessing that some of
you might be struggling with systems
that are challenged because they have
become big and they will continue
becoming bigger and bigger it usually
starts out like you have to build some
something as simple and then your
customer or your employer wants
something extra and then you add it and
you keep on adding stuff to the system
and you end up with this huge monolithic
pile of spaghetti so I think this has
pretty much been a recurring theme on
the track today so I'm going to show you
where one way to perhaps attack this
problem moreover I have seen many
problems with integration with external
parties I think it was Sam Newman who
mentioned the elytis this problem with
integration with external parties that's
basically an availability problem where
the availability problems of those
external parties are imposed on you so
if I've seen so many systems fail
because some external party failed or
wasn't there so I'm going to show you a
way to handle that moreover I have seen
in many systems very complex logic that
is sort of stuff happening that makes
other stuff happen that makes other
stuff happen and then maybe the system
sort of waits for awhile and then some
other stuff happens again and usually I
have seen stuff like this implement it
in a very implicit and fragmented way by
possibly having a pool somewhere and an
integer in another place and together
these things actually compose the state
of some kind of process that is going on
in the system but it's a fragmented and
it's it's implicit and spread all over
the system so I'm going to show you a
way to
perhaps make this a little more concrete
yeah so to sum it up you're struggling
with a monolith perhaps you have some
integration problems and you have
perhaps problem coordinating your logic
or reasoning about which processes are
going on in your system and one solution
here I'm saying dissolution but I don't
want to be so bold as to claim that this
is the solution
I mean maybe tomorrow we will figure out
a better way to handle these things but
the best way that I know of at the
moment to handle these things is by
using messaging in intelligent ways and
if you're if just so everyone is clear
on what I mean by messaging I mean when
you want to perform some kind of
operation you can model that operation
as a chunk of data that can be persisted
somewhere and can be delivered to
somewhere else so basically that's just
that's messaging it's just storing and
representing operations as chunks of
data that can be exchanged and saved
yeah but in order for all of this to
work this messaging has to happen by
using durable asynchronous queues they
had to be durable so that when we send a
message somewhere we can see that this
message is saved so the message is just
as important as a piece of data that we
might want to store in the database so
it's very important that these messages
are treated with the same with the same
care as the data in our database so
therefore we have to use durable message
queues moreover it has to be
asynchronous this way we have this a
fire-and-forget way of sending messages
and this way we will we will never block
when sending a message so we will never
wait for some recipient to be there or
anything like that we can always count
on being able to deliver to get our
messages sent so whether they're
actually delivered to the recipient
that's
that's another story and that's handled
by the Q's or whatever yes and other net
developers in here okay cool and if
you're the nerve net developer chances
are that you are running your code on
Windows and then you're in luck because
Windows since Windows 2000 has had a
built in asynchronous durable missed cue
called a miss FQ Microsoft message queue
that you can enable by putting a check
mark and at remove windows components so
their action actually is a queue that we
can use to do these things build into
minnows
so that's pretty cool yes and now I'm
going to talk about rebus rebus is it's
an Enterprise Service bus but I think
when when I say Enterprise Service bus
or service bus then people will be
thinking in like they have people have
experiences with service buses and
there's a lot of commercial products out
there that that are Service buses but
then yeah so to avoid I mean to avoid
confusion and I just want to tell you
that rebus is not a huge broker thing or
a huge monolithic central thing that can
do everything in the world and and
translate messages and integrate with
all kinds of systems it can't do
anything like that rebus is actually
just a messaging library it's a very
simple messaging library that can help
you exchange messages in intelligent
ways so that's basically it so it's a
it's a thin layer on top of some kind of
queues and I'm going to show you today
with MS MQ underneath and yeah so that's
basically it
and moreover I'm I like to call it a
hippie bus but that's that's sort of to
to counter this a white collar and tie
thing that people usually think of when
they think of service buses I like to
think of rebus as a very very nice and
relaxed bus
that is very forgiving and it's free and
that's a lot of stuff that is kind of a
hippie like with it so and it's not
capitalistic in any way yeah and yeah as
I said it's a messaging library and it
sits there as a layer on top of an smq
and Reba's core is one single letter
made for diello sorry you're guaranteed
to be able to include rivers in your
project and not have any conflicts with
anything and then if you want
integration with the different
third-party stuff then that can be
achieved with the small dedicated
integration projects so for instance
rivers can actually use RabbitMQ as it's
a messaging transport and can save stuff
in different kinds of databases and more
stuff my motivation for creating rebus
was that I've worked with
I've worked professionally with
in-service bus for a couple of years and
but after a couple of years who lead on
the guy who created and service bus he
changed the license so that you had to
pay in order to use in service bus and
that made me really sad because I really
like this I like open source and free
software and so yeah moreover in service
bus had some problems it was really hard
to to get this started a - I mean it had
some problems with the arrows it could
would throw a null reference exception
in the middle of when you were invoking
the configuration API and stuff like
that so there were some stuff that
really annoyed me about in-service bus
then I wanted to use mass transit with
which is another free service pass
implementation and that net but I
actually could I couldn't make it work I
had two days in a summer cottage at some
point and I I just couldn't make it work
so maybe I'd check out the code at some
unfortunate at some unfortunate time or
something but I just I gave up on mass
transit then I wanted to fork and
service bus from when it was still free
but the in service bus was like a 250 C
sharp projects and 60 thousand lines of
code and it was totally
at the time it was a complete mess so um
actually they have have cleaned up a lot
I just want to say that but at the time
the code base was really messy and huge
yeah so I wanted to create rebus and it
has always been free and it will
continue to be and moreover I want it to
be really easy and really a key part of
that is it has to have really awesome
error messages so when you get an error
message in rebus it's not it's not a
slap in the face
it's always a step forward so each error
message in rebus will explain you
exactly what is wrong in pedagogical
terms and then it will it will suggest
some kind of solution so for example if
you if you rebus can encrypt message
bodies so if you want to configure
encryption and you forget to provide the
key then rebus will generate a key for
you and actually type out the XML that
you can put into your configuration file
so it I just want to make stuff like
that really easy so that it's easy to to
get going and easy to actually easy to
get past all of the reaper stuff and
just start working on your real code and
solving your real problems yeah moreover
I just because I've started out one is I
wanted to create rebus in a way that you
could start out using it at the
beginning of a project and then at some
point if the project became more serious
and you could warrant the licensing
licensing cost you could easily port all
your code to an service bus so therefore
all the api's in rebus are actually
stolen from in service bus so all the
api's you're going to see except from
the configuration api all of the other
api's are stolen from in service bus so
yeah right now it's a fairly small
project three thousand seven hundred
lines of c-sharp code the code is on
github and it has contributions from 12
developers besides me so I'm not the
only one
developing it and you get up and running
with rebus by using nougat so
that's basically the way you you get
started doing stuff internet nowadays
the current version is called 0:43 one
it's a pretty cryptic version name and I
have often been asked when version 1o
will be out but I don't think it makes
that much sense I mean at some point I
wanted to create a version 1o because
this sounds kind of unofficial and
sounds kind of alpha but rebus has been
moving money around since version 0 14
alpha and here it has controlled a
couple of power plants since 0 17 alpha
so and I mean the version is just that's
just a number it doesn't mean anything
so that probably will never be one oh
yeah I'm going to show you a previous
demo in a in a few seconds but before we
begin there's just a few things that are
good to know with rebus all messages are
plain old still our objects so when you
want to create a new message type you
just create a class and then you put in
some fields if you want some data along
in your message and then instances of
that class can be sent as messages and
in rebus all endpoints have their own
input queue so the input queue of rebus
endpoint is sort of the ID of the of the
endpoint and then each message type is
owned by one logical service so that
means that for each message type that is
in in your in all your systems you can
always map that message type to one
endpoint somewhere and that endpoint
will be the owner of that message so so
this way there is a an ownership mapping
you could say and I'm going to show you
that in a few seconds yeah and then it's
already time for the first demo yeah so
let's hope that this works I have a
simple solution here with two projects a
client and a server both
our simple console applications that
don't do anything at the moment so now I
want to now I want to be able to send
messages from the client to the server
so in order to do that I will install
rebus into the server and now in the
server I can configure and then I
provide this container adapter in rebus
rebus always wants some kind of
container adapter which is usually the
place where you will use one of the
flavors that exist for the ioc container
that you're using because it would use
this container adapter to look up
message handlers so that's usually where
you will bridge somehow to the ioc
container of your choice then you go
transport this basically the avi always
starts like this and then you can dot
and then you can discover all the
different configuration options
available here so this way the API the
configuration API is has this discovery
thing going on and then I configure the
transport to use MSM queue and get input
queue name from app config that's a
little long and then I just create the
bus and start it so right now I will
have a bus running but the program will
exit immediately so in order to avoid
that I will just go press ENTER to quit
like this I told it to pick up the input
queue name from app config so I just
have to provide a little bit of XML in
app config to tell it which input queue
to use I do that with this rebus
configuration section that I will just
make a little more simple so to reduce
the noise so basically what this one
says is that this rebus endpoint has an
input queue called server dot input then
it has an error queue called error this
means that if the
message processing from server on input
fails more than five times in a row then
it will move the message to the error Q
so this way rebus will never lose a
message it will never ever lose a
message actually it will always make
sure that the message if something goes
wrong is brought back to the queue from
where from where it came and then if it
fails too many times it moves it to the
air queue to avoid denial servicing your
endpoint right so now I should be able
to start up the server and okay I got a
couple of errors now because actually it
appears that there was some messages in
the queue for this endpoint it says that
it couldn't find any handlers of type
four message of type system that string
so actually that there was a couple of
strings in the input queue of this
endpoint so just to prove that I'm not
lying I can start out this a very simple
MSM q q inspector and then you can see
now in the era queue we have the three
strings from from just now so they're
sitting here safe and they're not gone
all right so let's create a message
handler in here this usually you would
you would register magic message
handlers in your ioc container but since
i'm using this building container
adapter which is very simple i will just
i can register handlers like this I will
just go register some type telling rebus
it can use this one as a handler and
then I make this one a message handler
by going I handle messages of type
string this will this will force me to
implement this method called handle with
the type that I specified here and in
this server I would like to handle
strings by just going got a greeting
message
so I'll just start the server again yes
and leave it running so let's create the
client I will install the rebus package
into the client I will configure oh
configure the container adapter I will
tell it to use an smq in one way client
mode this way the client will not have
its own input queue so it will be able
to send messages to the server but it
will not be able to receive anything
back but that's okay and this time I
will call this message ownership thing
which will allow me to tell readers how
it can determine who owns messages of a
given type and in this case I will tell
it to pick it up from the rebus
configuration section so I'll just
provide that message ownership
information in a moment and I will just
read a greeting in here type greeting
like this and then when I'm using the
buildin container adapter I can find the
bus the bus instance that that is the
result of calling this API will be on
the bus privacy so I could just get it
like this usually if you're using an icy
container you would resolve the AI bus
from your container and I will just send
this greeting so notice how in on the
client here I don't I don't worry about
who is going to receive this message I
just tell rebus that I want to send this
message and then rivers will have to
figure out where to send it so that's
sort of where the sort of the this very
very simple bus layer kicks in and they
uses these very simple ownership
mappings to determine where the message
should go so in this case I will provide
a rebus configuration section here
remove all the in perk you stuff and
then I will use one single endpoint
mapping which is the way you map a
message type to an endpoint to the only
endpoint in this case I want to map
system that string from a Miss call tip
to server dot input so as you can see
this is a very very simple way of
specifying that is messages of type
system string are owned by the endpoint
hiding behind servitor input so now I
should be able to start the client and
client is running and the server is
running and sorry hi and I got the green
so as you can see I can now send
messages from the client to the server
and to prove that no messages were lost
I have these three strings in my arrack
you I can I can select these messages
and then since rebus puts the original
the source Q which is the Q where these
messages failed as an extra message
header rivers can return these messages
to the sauce queue and this way
delivered the messages to the server and
yeah this way
no messages were lost yeah so that was a
very short demo showing how how simple
it is to get up and running with with
rebus so now back to the to the three
problems that I talked about we talked
about this system that was becoming too
big and integration with external
parties and some complex logic with
coordination and timing the first
problem and I have a sort of stolen the
setting from from the work at one of our
clients at the t60 where we're building
this trading platform yeah so imagine
that we're building a trading platform
where traders in front office are
striking deals with counterparties and
then some administrative personnel in
back off
this will make sure that these
counterparties are charged so we we have
we have an application that can capture
trades and can do invoicing so already
it feels like we have a system that is
sort of doing too much and it's not
really focused so I want to pull in a
few few of the things that have been
mentioned today and but I'm going to add
distributed to this one because there is
a kind of a kind of domain driven design
that has this extra T in front which is
distributed domain different driven
design which later
I think evolved into all this CQRS and
the bin sourcing stuff that is going on
Internet at the moment and but the key
thing is that we use this concept of a
bounding bounded context from the main
room design to to sort of capture the
fact that we may have different
subdomains in our big domain so in this
case we have this a big commodity
trading domain but actually there are
two subdomains at play here we have this
trading domain where the traders are
punching trades into the system and we
have a billing domain where some people
usually once a month or something like
that will go and select a lot of trades
and then they will make sure that the
counterparties are are invoiced yeah so
in this case in the first demo I will
show how Reba's can perhaps help you
separate your big system into two
separate domains so let's just stop this
again
that's demo 1 in this demo I have two
two solution folders called back office
and front office in front office I have
the trading service here which is a
simple Reapers endpoint that will it
will configure a subscription storage
this means that this endpoint will be
able to store subscribers it will be
able to publish messages to those
subscribers so so this way Reba's can
has this implementation of publish
subscribe that you can use and in this
trading endpoint
I will input the name of a counterparty
and an amount and a price and then it
will publish this new trade recorded
event new trade recorded is just a
simple class that I have made in this
trading type messages assembly so this
way in billing this way billing can
include a reference to the train that
messages assembly and have access to
this type of event and billing which is
also a simple Reba's endpoint can
subscribe to the new trade recorded
event so when it starts up it
establishes a subscription to this event
since the publisher has is using a
MongoDB as a subscription storage it
will remember this forever so even if I
restart the publisher or kill it or
whatever I can think of it will it will
know that this subscriber exists when it
starts up again yes and then the
subscriber registers this handler called
charge the customer which just which
handles this new trade record event and
just prints out the message the
information on the console so let's try
and run this one that was billing and
that was trading so now what I'm trading
I can do this
and
we'll get the published events so this
way you can you can use
publish/subscribe messaging between your
applications and they will oh sorry
there was an error
apparently a string is not a valid
number I'm sorry let's just touch this
one out again I wanted to stop billing I
want to kill building and then publish
some events and as you can see when
building starts up again it will receive
these events as if nothing happened so
this way we can have reliable messaging
and these systems will be very loosely
coupled and will not care whether
they're both there at the same time so
that's pretty neat then our second
problem is integration with an external
party in our trading domain here we have
we have this a new department called
middle office that need to confirm all
trades when they're made and they
confirm these trades by asking an
external soap web service called credit
assessment and asking it whether this
client is is good or not so it's a very
simple a credit assessment service and
here we want it to be asynchronous so
that we don't we don't wait for the
result basically so we if the soap web
service is slow or if it's down the rest
of the system will just continue
moreover it has to be reliable so we
will never forget what we were doing so
if this is soap web service is it's not
available then it's really important
that it will that this call will still
go through when it becomes available in
order to do that we will use rebuses
automatic retries and i've just made
this very simple a sequence diagram to
show you what's going to happen now
trading will publish this new trade
record event which will be now it would
be subscribed to from confirmations
confirmations will send get credit
status requests
to an integration service this
integration service is just a very very
simple rebus in point whose sole
responsibility in the world is to
receive these get created status
requests then make this external soap
call which is the unsafe operation and
then it will return the reply containing
the result of this call and then when
that happens where that reply is
received in confirmations it will
publish this trade confirmed or a trade
rejected event depending on the outcome
yeah
so let's see how we can make a web
service call by using a messaging facade
let's demo - so now I have the same code
as before nothing has changed except
I've added this middle of this thing
middle office has the confirmations
service which was this one and then it
has a a couple of messages a couple of
events that it can publish and then it
has this external folder containing the
integration service which is this one
and and then I've put this credit
assessment very unsafe soap which serves
in here which is has a very devious
implementation as you can see it
actually fails 75% of the times that you
call it and then 25% of the times it
will use the the length of the
counterpart name to determine whether
he's good or not so it's a pretty crazy
implementation actually but the point is
that it fails almost every time you call
it yeah in this integration service I've
made this very simple Handler that
handles the get credit status request
that was this one and then it makes the
call and returns the reply back to
whoever sent this one and it can do this
by creating the client making the soap
web service call and then using the bus
to reply so this way the bus will just
reply back to whoever sent the message
that we're currently handling
yeah last thing to show is in
confirmations we have the thing that
invokes all of this
it's the check credit status handler
this confirmation service has subscribed
to the new trait recorded event and then
it has this handler that handles the
reply when handling me the new trait
recorded it will just use the bus to
send this one and then the bus has an
endpoint mapping that map's this get
credit status request to the integration
service and then since we are the sender
of this request we will get the reply
and then depending on the status we will
publish a trade confirmed or trade
rejected event so let's just try and run
this so as you can see you oh that was a
call waiting in a queue so now the
deeper debugger just broke into the
debugger here but yeah nothing really
happened actually it's still running
back here and let's just see if building
is hiding back here so now we have
trading up here we have the new
confirmation service sorry we have the
confirmation service here and we have
the integration service here so all the
all the gray and yellow logging is it's
okay
yellow is warning so this one actually
hasn't experienced any arrows so even
though it got an exception because of
the automatic retry mechanism it will
retry up to five times it will just lock
this error as a warning and then it
looks like since there's no red logging
in here the the call would eventually go
through so let's see if we can make this
fail oh I couldn't make this one fail
yeah no actually I don't want to spend
time making this one fail I will rather
see if I can make the last demo fail
because it's more important there but
important point is that the calls go
through even though it has some
availability pretty obvious availability
problems
over here yeah so the third prop problem
was this complex coordination and timing
thing so imagine now that the building
needs to charge the customer but but
this process can be optimized by sending
out one big invoice if the credit status
of the client is good but but if the
credit status is bad then we want to
send the invoice immediately to avoid
any risks yeah so this way a billing
will now once this new trade record
event is received it will await the
credit status and then depending on this
credit status it will send the invoice
in one way or another so so we have this
process going on now to avoid by
forgetting to send these invoices in
case this web service called fails and
never returns any reply we want to take
and some kind of alternative action if
nothing has happened within 10 seconds
this is actually what is called a
process manager in the literature which
is a stateful service which is sort of a
state machine inside a service whose
transitions are triggered by messages so
just imagine this state machine where
all transitions are triggered by
messages that's the process manager and
we can have any number of instances of
this of this state machine then we want
to introduce some kind of a timeout
concept to allow us to take alternative
action if if this process hasn't
completed within 10 seconds and we want
to be able to perform these compensating
actions which in this case is very
simple we just want to send an email if
nothing has happened so now the sequence
diagram looks like this trading will
publish the new trade recorded event
which will go to both confirmations and
billing in confirmations we have all
this soap thing going on I just hit all
the integration service stuff in this
small loop make external call so it has
some some kind of local thing going on
but we don't have to care
about that with this confirmations thing
is over it will publish the tray
confirmed event event which will end the
process in billing and then billing can
do its invoicing the way that it wants
to but in order to if if this trade
confirmed event never arrives
then this process will sort of continue
to live on and then at some point we
want to wake up this process
so therefore in billing when we start
the process we will send a timeout
request to a timeout service whose only
responsibility in life is to receive a
time not request wait the time that that
is specified in this timeout request and
then will return a timeout reply after
that time so this way we can order a
timeout request a sort of a wake-up call
after 10 seconds so billing will use
that to wake up itself after 10 seconds
if the process hasn't completed yes so
that will be demo 3 so now I have
changed I have changed billing and I
apologize in advance because this code
may look a little bit crazy when you
look at it at first but it is actually
really simple it trust me now the the
message handler in billing called charge
the customer is now what in service boss
likes to call a saga but that's actually
just that's what's called a process
manager in the literature about
distributed systems so why he chose to
call it saga I don't know that's a thing
he he stole from database theory I think
this process processes state is made out
of this billing saga data class so I'm
I've created this class that can model
the state of my state machine but this
process is going on and not in my state
machine I want to store the trade ID and
the counterparty
a name and then I want to store the
trade details and the result of the
credit assessment
so and these are not able because I
don't want to make any assumptions on
the order in which these pieces of
information arrive so when I get the
trade details I will remember those and
when I get the credit assessment result
I will remember that
and then I had this way of checking
whether I have received these statuses
and trade details and I can use that to
complete the process
now this saga is said it's triggered by
incoming messages so I have to I have to
handle all the different kinds of
messages that can trigger transitions in
my state machine in this case I use this
special I am initiated by interface
which is actually just a derivation of I
handle messages that adds some extra
semantics because because it allows it
allows rebus to create a new saga if an
existing one cannot be found for this
incoming message so this way my saga
process here can actually be initiated
both by this event but it can also be
initiated by the trade confirm and trade
rejected events and I'm doing that
because if this new trade recorded event
somehow fails while being handled in
billing it will move to the era queue
and then the chances are that I will
receive the trade confirmed before I
received a new trade recorded or can
process the new trade recorded
successfully in billing so this way I
can make my system robust towards the
order of the messages yeah in here in
the saga I have to specify which fields
should be correlated
so for each incoming message I can point
out a field in the message and tell it
that it should correlate that with a
field in the saga data so this saga
instance if there if an incoming new
trade record event if there exists a
saga instance with the traded ID that
matches the trade ID of the incoming
message then that instance will be
loaded and will be
available to me otherwise since I used
this I am initiated by it will create a
new instance of the saga for these
events yeah I'm just going to run over
this code really quickly yeah the the
code will be available afterwards and
github so you can check it out later on
if you if you're curious since I handled
this new trade record it and trade
confirmed and trade rejected events in
the same way I have to possibly schedule
verification in all of them so that's
the way I handled all of these in this
method I can ask whether the saga is new
if it's new then I can use this defer
API in rebus to send a message into the
future so I can send this verify
complete message ten seconds into the
future so underneath the covers this
will it will say lies this one into a
timeout request send it to the timeout
manager which will wait for 10 seconds
and then it will return it in a timeout
reply and then we will unpack this
verify complete message and it will
attempt to dispatch it to the saga the
way that I've specified here so this way
if the saga has not been completed when
this message arrives then we can write
out some information to the console or
send an email or whatever we want so
yeah I'm just going to try and run this
one and then we'll see if it if it works
so now I actually want to make this one
fail because then you can see the the
timeout being triggered so I have the
confirmation and the expiration service
and then let's do some trading and it's
checking the creditors and it's
completed let's try again and now it
failed so the message is moved to the
error cue
so the process has stopped and then
within ten seconds the process should be
woken up by the time I reply and then we
can do whatever we want send an email or
warn an administrator or whatever it
makes sense to do so this way we can
make sure that these even though
messages might fail and might end up in
our cues along the way and and these
processes might halt then we can resume
the process and take alternative action
yeah I hope that makes sense you can
check out the code if it if it looked
weird yes so to sum it up I think that
the messaging provides a model that that
they really can help you include the
pieces together when you break down this
system into bounded contexts which is
appears to be a recurring theme that has
been discussed all day on the
architectures track moreover it can help
you overcome glitches when you when
you're integrating with stuff that is
not as available as you are and you can
avoid other parties availability
problems being imposed on you so that's
pretty nice and moreover it can be used
to make these these kind of processes
that occur in these messaging based
systems make them explicit and they
create a model that models one specific
process in a very tight and explicit way
which I think it's really neat so I hope
you agree with me yeah and now I'm going
to finish it this off really quickly and
as I mentioned rebus is not really tied
to a mission MQ as such it can do a mess
MQ out of the box but it also happily
uses rabbitmq and SEO service bus as a
transport layer they both support the
same transactional guarantees so that if
a message fails it can be rolled back to
the source queue and stuff like that and
when you send many messages they will
either be sent all of them atomically or
not so it has the same transactional
properties when you're using rabbitmq
and SEO service bus as well and it can
use sequel server as a transport so if
all you have in the world is it's a
sequel server then you can still do this
messaging thing then it can install
subscriptions and sagas in sequel server
and rave in DB and MongoDB using a
document database to store Sarah is
really obvious choice because the saga
is just a document then you can use
these icy containers to activate
handlers and use different kind of
logging frameworks it can send messages
in patches so you can optimize certain
stuff about the overhead so even though
you have small messages in your code you
can avoid the overhead of sending many
small messages then it can it can do
handle pipeline reordering so if you
have multiple handlers that handle the
same messages and you can tell rivers to
invoke one specific handler first so you
can use that to for example do some kind
of authorization of incoming messages
and then you can do polymorphic dispatch
which is a way that you can for example
make an I handle messages of object and
then it will receive all messages so you
can use inheritance and interfaces on
messages and then use those interfaces
in your handlers then it can encrypt
message buddies this is not the NSA
great encryption this is more meant for
I mean if you want to send messages
around in organization with payroll
information or some kind of a little bit
sensitive information then you can just
tell rebus to encrypt the message buddy
and then it will not be immediately
visible in your queues what is in the
message and they can compress message
buddies so you can send pretty big
messages and yeah maybe I will call
rebus a100 at some point I don't know
one of the contributors Eska is right
now working on having this central
monitoring service for rebus that you
can start off somewhere and then build
into the central monitoring thing there
is a web endpoint that will show you all
the rivers endpoints that you are
currently running and all the rivers
endpoints will periodically send a
heartbeat to this central service so you
can get a really good overview of what
is running so when you have if you have
lots of endpoints then that's pretty
neat then rebus actually already has a
HT and HTTP gateway which is provides a
way to send messages
from one location to another over the
internet for example so you can fairly
easily proxy this one with an HTTP proxy
or something like that so you can make
sure that the messages are securely
transferred but this allows rivers to
cross boundaries where MSM queue for
example would not work and then it could
be interesting to add some additional
transports but right now it seems like
no one has really asked for for more
than MSM queue and RabbitMQ and SEO
service bus so maybe there will be
additional transports in the future and
then since MSM q doesn't do competing
consumers well it would make sense
perhaps to create some kind of
distributor process that will load
balance your MSM q3 percent points but
the SEO service bus and RabbitMQ don't
need that so if you want to scale your
message processing you can just use web
lmq and have multiple multiple endpoints
checking out with one queue if I've said
something that the sounded that sounded
cool it probably came from one of these
books which I really encourage you to
read if you haven't done it already and
then I also yeah you could also read
what they would either Han and quick
Young at the north and some other people
are writing they're doing some really
cool stuff with these things which the
Han is the guy who created this service
bus project whose ideas are still so
yeah and yeah thank you for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>