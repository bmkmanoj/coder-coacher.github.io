<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2016 • Cryptography Pitfalls • John Downey | Coder Coacher - Coaching Coders</title><meta content="GOTO 2016 • Cryptography Pitfalls • John Downey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2016 • Cryptography Pitfalls • John Downey</b></h2><h5 class="post__date">2016-08-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nucBqQLHv-A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright welcome this is the last talk of
the day thank you for all for sticking
around so this is cryptography pitfalls
my name is John Danny as you can see if
on the slide so I want to first frame
this up with some context why do I want
to talk to you about cryptography
pitfalls and part of it is I whenever
I've you know visit with developers you
know I am a developer I want a team of
developers but I often see we're making
a lot of the same mistakes over and over
we're building these crypto into out
these systems and we're just we're
really bad at it and it's causing kind
of some of the same failures to reappear
over and over so this is really a
cautionary tale I personally love
hearing stories of failure I love trying
to learn from stories of failure and I
wanted to ground this in real events so
I tried to tie into like real research
site real papers real events in the news
and kind of present that to you because
my goal is for you to take this back and
go back and go okay am I in over my head
do i need to get professional help do i
need to seek a consultancy to kind of
help with these systems because all
these folks who ostensibly should have
known better have made these mistakes it
while implementing crypto in their
systems all right so a little bit about
me real quick I work for Braintree if
you're not familiar Braintree is a
company that helps businesses accept
payments visit you know companies like
uber Airbnb in github which I'm sure
folks in here are familiar with at least
one of those so at Braintree obviously
we have a very you know concrete
interest in cryptography and security
and so I do security at braintree you
may not also know Braintree was founded
here in Chicago the founder was a
graduate of the boo school and so I my
team's here I'm here in Chicago and very
happy to be speaking at go to Chicago
another thing you may or may not know
about Braintree is Braintree was
acquired by
hey pal a little over two and a half
years ago so we're now part of PayPal
and if you've ever worked for a publicly
traded company you'll recognize the
statement the user expressed in this
presentation are my own they do not
reflect paypal so now that that's out of
the way icon to start with a modern
overview of what what what modern crypto
means and we can talk about some common
mrs. along the way and then you know
kind of go from there so in cryptography
we in the modern sense we have three
needs the first one is confidentiality
this is about keeping messages secret
generally what you think of when someone
says crypto you think of like no one
else can read this message this is like
the using encryption all right
authentication this is also called
integrity protection this is making sure
that if I send a message that the
receiver can validate that it hasn't
been changed and then last one is
identification this is knowing who sent
the message these days we often see this
combined with the previous one
authentication in the form of digital
signatures so John sent this message and
it hasn't been modified since John
sensitive cryptography modern
cryptography is a very rare a science
it's based on some of it is based on
very hard math problems and these math
problems are largely considered hard at
least the ones the we use day-to-day are
considered hard on were called classical
computers that's red non quantum
computer so there's a whole new field of
study on like what are we going to do
when we inevitably do design practical
quantum computers that is totally out of
scope for this but for example one of
the mat one of the math problems we rely
on day and day out for our digital
communication especially in e-commerce
is how do we factor large numbers into
their base primes and this is the this
is the science behind our the RSA
algorithm and we're really doing with
crypto these days is we're betting that
there are no major advancements in
either math or computers at least for as
long as we want to keep the data secret
so like any science crypto should be
peer reviewed this I feel like the
security community has been able to kind
of successfully beat into folks heads
like don't design your own crypto so
that mantra was really taken hold I'm
very happy about that but this also
should be extended with like don't
implement your own so you know sometimes
you would see folks take like oh I
didn't I didn't designed our essay by
when I implemented it and you know you
then are stumbling down stairs very
quickly so included with the peer review
is the kind of a statement of you the
only thing in the system that you want
to be able you want to have to keep
secret is the key so this is something
called kir cops principal you can well
sometimes here called security through
obscurity or not doing security through
obscurity so I should be able to give an
attacker a layout of the design of my
system but not give them the keys and
the system should remain secure that's
that's the goal here and while
cryptography itself is very strong the
individual primitives are often very you
know can be are the individual
primitives are very strong but when
they're combined that can sometimes be
very weak would it be possible to get DS
lights turned down so that way there's
the that way this will show it better
the I don't know nope ok fair enough so
systems window built with cryptography
it's this composition that will
sometimes you know can bite you and when
they're you know the primitives can be
misused and the missteps here are
catastrophic you know you're this one
small misstep means your entire systems
insecure even though the other parts of
it may have been used correctly so I
really like this this quote which I'll
read to you real quickly there is a book
by raphy engineering and the
the quote is you've probably seen the
door to a bank vault at least in the
movies you know 10 inch thick hardened
steel with huge bolts to lock it in
place it certainly looks impressive we
often find the digital equivalent of
such a vault door installed in a tent
people standing around it are arguing
over how thick the door should be rather
than spending their time looking at the
tent so what I take away from this is
you know you'll you'll hear arguments
with with folks when they're building
systems with crypto with like we should
use 128-bit key no it needs to be a
256-bit key and kind of going back and
forth with this and they're not really
paying attention to the fact that there
the system has like trivial a cross-site
scripting or some other bug into it and
they're like so they're staying around
arguing over how thick this door needs
to be so if there's one thing you take
away from this whole presentation
besides that you know oh boy
everything's on fire is that if you're
going to be sending data in transit this
is data going across the network use TLS
we used to call it SSL but SSL we don't
we don't call it that anymore because
that's the old thing TLS is the new
thing use TLS SSH or some kind of VPN
and if you are just sending data if you
could do that if you can work it into
that right if the data is going to be
sitting at rest try to use gpg to to
encrypt it and have it set at rest at
rest means like it's sitting on a hard
disk it's sitting in s3 it's sitting in
you know somewhere and if your model
doesn't fit into one of these to see if
you can rework it until it does because
you'll save yourself a lot of pain by
being able to do one of these things my
general advice is always to avoid
low-level libraries libraries like
openssl a PI crypto bouncy castle I tend
to describe these like I'm giving a
developer a bucket full of razor blades
and asking them to build me a saw it's
very easy to take these razor blades and
Miss assemble them in her ear
off using a high-level library you will
often you can still make mess ups but
often a lot of these edges have been
smoothed over for you something like
live sodium or salt NaCl which has
bindings in to see Ruby Python most of
you know most languages you use or
Google really still a library called
keys are in Python and Java and I think
now also C++ so these these high-level
libraries have abstract over a lot of
the mistakes that are commonly made and
hopefully takes some of the edges off so
I promise pitfalls so let's talk about
some pitfalls in places where crypto
goes wrong all right so first up is
random number generators randomness is a
central part of any cryptosystem it's
used to generate things like encryption
keys API keys you know session tokens
all these various things are required to
be what we think of as cryptographically
secure otherwise an attacker can try to
guess them which would end up being bad
so the first pitfall I want to talk
about is not using a cryptographically
secure random number generator so there
was a paper this was it the used next
conference a few years ago called I
forgot your password which was about
randomness attacks against PHP
applications what this what they did is
they were actually able to successfully
because these applications were just
using like the built-in Mersenne twister
algorithm and PHP to generate these
password reset tokens they were able to
through some work figure out what the
password reset token for a user would be
as it's been generated an e-mailed to
the user so that they could reset their
password before the user acted on the
email and the reason they were able to
do this is because if you're not using a
cryptographically strong in a number
generator if you're looking at this fate
war face on you'll have a better view of
it than if you're off of the side like I
am but the one on the left there's a
very clear pattern there's a period
'used
how the data kind of repeats which is
not what you want in your random number
generator there should be no pattern the
one on the left was was I made that
image under the worst possible possible
circumstances it was like Windows NT PHP
very old PHP and it had just this really
bad algorithm the one on the right is
some quick you know cryptographically
random noise and this just kind of to
compare and contrast the next one using
broken random number generators all
right a few years ago so this is in that
you know late 2000s 2008 it was
discovered that Debian had for a number
of years shipped a broken random number
generator and open SSL so they had
patched openssl and in it they broke it
and this went ended up going downstream
two things everything based on debian
like a bun two and all those packages
and they all picked up there pat their
patches and were similarly broken from
about two thousand six to two thousand
eight and what it was it was this line
so this is a line of c code in openssl
and this line mixed in a random data
from the system and it was commented out
in two places and it was not discovered
until two thousand eight and for those
two years if you use the system where
this liner was commented out the your
random day was hopelessly broken there's
only about 15 bits of entropy that would
have been present in there a number
generator which you can exhaust very
quickly and this kind of goes to show
that unfortunately in many cases good
crypto looks a lot like bad crypto and
so you don't always know which one
you're getting the message when the
person committed this was don't add
initialize data to the random number
generator to stop bal grind from giving
an error message I Val grind if you're
not familiar is you know the sea memory
leak analyzer and they really they did
this to like squash a like a debug
warning or like a build warning for Val
grime and they ran it by the openssl
mailing list which is the scary thing
and no one like jumped at them and said
oh my god no so subsequently every ssl
certificate ssh key generated using
these using on the systems work just
broken they needed to be replaced so I
went back and look this is that line
today there's a gigantic comment letting
you know this is a bad idea to touch
this line so that's one way to solve
this problem but this this problem of
using broken random number generators
has you know it's happened quite a bit
so this was the android android phones
had a broken random number generator for
a while and how it was discovered was
folks using Bitcoin apps on their phone
starting those their bitcoins were being
stolen and so they you know they
eventually did some investigation they
found out that the Brandon or January
ship that the system was broken and
that's how it manifested itself this was
just in December of this last year it
was discovered that juniper had been
shipping ecdsa are sending that I'm
sorry Dooley see a random integer based
on Dooley see in their systems and not
really being very public about it you
may remember dual EC because that came
out in the student papers as hey we
think that there's a you know there's
something here that the NSA is
exploiting and this was actually known
long before the Snowden papers there was
these two folks who work at Microsoft
give a presentation at a conference on
the possibility that this could be back
doored and so juniper had to kind of
come out and be like hey we ship this
random originator and these products we
don't know where this we don't know
really know where the code came from we
don't know where the parameters to it
came from more importantly so that they
there was a lot of consternation and
investigation about that and then the
last one not using random data when it
is required alright so the sony ps3 was
using a lip to curved
signor out the signature on the ecdsa
which is a variant of the you know the
government's digital signature RM
standard and one thing that to know
about ecdsa is it requires a parameter
called k that must be uniformly random
every time you sign use the signature if
it's not with by observing a few
signatures you can break it and you can
get the private key that was used to do
the signature so they were not using
random value came back to I believe it
was a static value it was just hard
coded and people eventually figured this
out and they used it to I probably like
load homebrew apps on the ps3's so now
comes the recommendation so if you're
using a unix-like system so this would
be unix bstr like linux bsd read your
random data from Deb you random open it
as a file read the amount of data you
need close the file move on and keep
doing that whatever you need random data
there's a lot of discussions and
arguments and going back and forth about
this I'm in the camp of just read Devi
random use a rapper that reads Debbie
random just use that don't worry or like
don't kind of spend your time with the
other stuff if you have to be on windows
in your net there's a random number
generator create there's Krypton random
pick whichever one is for your operating
system but generally those are my
recommendations when folks come up and
ask next I want to talk about hash
functions so hash functions are often
also called a fingerprint and so like
fingerprints no two things should have
the same fingerprint it's one way
meaning it's not reversible if you just
you know come up and look at one of my
fingerprints you wouldn't happen to know
that it was mine unless you had some
fingerprint database and ideally no two
people have the same fingerprint so for
hash functions are we're finding still
in systems folks using older week our
rooms so this was in 2008 md5 considered
harmful today this paper was the one
this is where they used a whole like
cluster of ps3's to
to generate a certificate that match the
same signature as one that was going to
be generated by a CA so they were
basically able to get a you know a CA
certificate signed by a legitimate CA
due to flaws in the md5 signing
algorithm or the md5 hashing around and
this really catalyzed the CA the
certificate authority industry to just
drop md5 like a hot mess on the floor
which people have been trying to do for
a while and it been very slow this one
so this crypto breakthrough shows flame
was designed by world-class scientists
if you don't remember flame was one of
the you know kind of came out around the
time of like Stuxnet and was a piece of
malware that was discovered and I
believe it was an Iranian nuclear
facilities that had started messing with
their industrial controllers for their
centrifuges and in it there was a
breakthrough an md5 which had previously
not been known and they used that to
bypass the Microsoft Windows Update
facility and have the program appear
like it was a legitimately sign program
this is why folks kind of look at flame
in the like well clearly this has like
intelligence community like NSA Mossad
you know someone worked on this for a
more recent example free start
collisions in full sha-1 so there's this
move right now and it has been for all
over a year to get off of sha-1
certificates in on our ssl for our
websites and the browsers have been
moving very aggressively on this the in
date to buy one was december 31st there
have been a couple instances where folks
have kind of broken down and been like
oh we missed the deadline where we're
going to break things but this paper was
one of the ones that kind of helps
continue to catalyze this forward that
Shah ones you know although not broken
it's kind of the writing is on the wall
that you need to be moving systems away
from us so this is this is an
interesting aside about hashing
algorithms so this is the logo for US
Cyber Command US Cyber Command must
love Hashem garland so much that the
inner gold ring here has a hash in it
and if you look at its this which it's
like okay turns out that is running md5
on their mission statement and this was
this was way past that when they should
have used md5 but like it was sort of
like isn't interesting like aesthetic I
guess all right misunderstanding
checksums so we often use hashing
algorithms as check sums on file so when
we download them we know that nothing
got corrupted so that's the sha-1 shot
256 sums file the misconception here is
that when you download and check these
that the assumption is ah this software
hasn't been modified and it's not that
the software is Amit modify is that your
download didn't get corrupted someone
could have clearly just modified these
tarball files and then also updated the
sha-1 sums file and like unless there's
like some kind of gpg signature
something on them you wouldn't you be
none the wiser at which I just want to
make sure folks like draw that dichotomy
and don't make that assumption all right
the last one is the length extension
attack so bear with me because this is
where we're going to get a little
technical length extension attacks
exists when you use an algorithm lecture
1 or shout 256 like this so we have a
secret value this is like a key we have
a value and we just have a pin them and
we take the shots 56 hash of it and we
call that our signature and you know we
kind of assumed that if both sides can
do this and they have the key or they
have the secret then bait you know they
must know the secret and that's how we
can validate that the value hasn't been
modified so unfortunately all of our our
current generation of hash algorithms
are all broken in such a way that that
is not true and the bergen because just
like a under you know basic fundamental
of how they're built that you can
actually arbitrarily append data at the
end if you've observed the signature and
be signed about and like the kind of the
value you can of you can append
arbitrarily date at the end after some
garbage
and Cory compute the new signature on
the full thing so this is called a
length extension attack and this this
could be bad news if you've built a
system that has relied on this not you
know does not being here this was why
when the they announced the shot 3
competition they said that your
algorithm had to be secure against this
like it couldn't allow this the way you
should be doing this is there's an
algorithm called H Mac which takes a
hash algorithm and use it to build an
actual message authentication code
message authentication code is just a
fancy way of saying if two parties share
secrets they can produce a signature or
something called a tag on a value that
basically says this value hasn't been
modified in transit and we know that
because we can use this algorithm with a
secret so unfortunately no one told this
to flicker this was 2009 so flickers API
had this this length extension attack
vulnerability and they ended up having
to go back and fix this so fortunately
this was 2009 this was like before maybe
they should have known so this was from
februari 2016 visa released a new
payments API where they were doing this
exact same thing so people brought it up
and now if you go back and look at the
documentation this has been fixed but
this kind of goes to show you like we're
still making these mistakes so
recommendations if you need a hash
function you know you just need
something to compute a checksum or
fingerprint use sha256 its suitably fast
it's good for right now if you need a
signature use H max shots 56 if you want
to share something that as a signature
relate on a shared secret stop using md5
don't use sha-1 and new projects and you
might be time to start looking at
project plans to get sha-1 out of your
existing projects all right now and
everybody's favorite topic this would
not be a crypto hair's on fire talk if
we did not talk about password storage
so it turns out I really missed an
opportunity to update this
turns out organizations will sometimes
not do very good job storing their
passwords and then those password
databases get out so LinkedIn had eight
million and then this very recently like
in the last week it was found it to be a
whole whole lot more so they leaked a
bunch of passwords a last.fm to theirs
yahoo dropbox ebay slack and missing
like tons and tons in here this is more
to illustrate a point and and in some of
those cases but not in all of them this
was how they were storing their password
so they were taking the sha-1 of the
password and they're putting in the
database so that's not good so it does
have one desirable property and that is
the values one way I can only be used as
a verification if I have a developer who
has access to the database they they can
look at this and they're not just
staring at passwords so that's great
that is beneficial many of them were
doing this which is they're taking the
sha-1 of a some value that was
randomized of assault in the password
and they were storing that in the
database this is like UNIX circa like
1970 like style security here so they
had this in the 70s and this has been
officially you know there's a randomized
value in here it can defeat these
precomputed tables called rainbow tables
there's another buzzword in the if for
crypto talk and it forces an attacker to
focus on one password there's still as a
problem with the that though that is
hash functions are designed to be very
very very fast like billions of hashes a
second on a modern GPU fast and that's
because it uses the underlying part of
all of our other algorithms like SSL and
TLS and things like that we want those
to be fast so what you want here is you
want one way randomized and somehow
adaptively soil and for that there we
would use adaptive hashing so there's
bcrypt s crypt and then there's another
album called pbk tf2 or password base
key derivation function to say that ten
times fast so use one of these doesn't
really to me it isn't really matter
which one
there there's other ones that have just
come out called you know there's one
called argon these are kind of like the
staples for today if you can delegate
your authentication so if I'm going to
comment on your blog I don't need to
create a username and password just to
comment on your blog let me log in with
like github or something so that you
know I can comment and you don't need to
take a password if you do need to take a
password like I know if you're building
a payment gateway then store one way
verify using one of these algorithms and
then also make sure that you're tuning
the algorithm to be as slow as you need
it for your your systems all right so
some of you in the audience may be
freaking out a little bit because you're
like i know our systems do shall one and
we don't have this and oh my god so
it'll be okay you can fix it so the
naive case that we often come up with is
so we have a password hash column that
is sha-1 of some salt appended with the
password and what developers will
instinctively say is ah i will live
migrate these when they log in again and
that's that's great except for you may
notice that your long tail of logins
will last a very you know very very long
time in fact some users may never come
back to your system don't they deserve
password security too and so don't wait
for the user to log in and just silently
upgrade my recommendation and i've
written a blog post about this a wrap
bcrypt around the existing scheme so
your password storage becomes bcrypt of
shah one of the salt and then upgrade
all all the passwords in the database so
this does require that your previous
password scheme wasn't like really bad
like des crypt bad is like it truncates
the passwords to eight characters so now
you password hash column is bcrypt of
this and you've upgraded them all and
when your password database leaks you
can be ah we use be craft and hopefully
folks will feel better about that and
your investors won't get upset all right
let's talk about ciphers for a little
bit once again using older week
algorithms and ciphers for ciphers
this was a paper from a long this is I
think early 2000s if not late 90s so
this is back when des the digital
encryption standard was all the rage and
this was the federal government standard
before AES and eventually got to the
point where it was almost trivial to
break this and there was this project
and paper called Copacabana which was
you know hey for less than ten thousand
dollars you could build a system that
could break des in a very reasonable
amount of time today it's even less like
your amazon bill would you know would
probably not be too much to break those
by yourself and the unfortunate thing is
there are still systems out there that
have des in them there are still people
who will build new systems that use des
I'm not talking about Triple DES I'm
talking about just like kind of the
plain old digital encryption standard
and that's that's scary this is another
one so we've known for a very very long
time that rc4 has flaws it has a lot of
flaws it's kind of it's a very elegant
algorithm if you've ever kind of looked
at it but it has biases and there's you
know kind of all kinds of issues and yet
rc4 is still used for a lot of websites
it's still used in a lot in a lot of TLS
sessions there is an attack in a
movement called rc4 no more that is
trying to get websites to stop using our
c4 and I encourage you to go back and if
you're you know if your service was
still using our c4 you really should be
finding an alternative there are many
other good ones in TLS two years all
right next up using ECB mode for block
ciphers to first we'll need to do a
quick refresher on what AES is so a s is
a block cipher yeah it's a pair of
functions and encrypt function and a
decrypt function it does take two values
the first one is a key which comes in
three flavors per the requirements and
the second value is this either plain
text or cipher text which is 128 bits
period that's the block set it's called
the block size and that's all AES will
do so you pass one in you get out the
Saket x you pass on the ciphertext at
the plaintext that's great but what if
my data is longer than 128 bits
so trivially what most would come to is
Oh we'll just break this up into 16 16 x
220 bit chunks and just encrypt one at a
time and so the industry's way ahead of
you this is called ECB or electronic
code book the problem with this is that
if there's any kind of structure in the
data you're encrypting that structures
are going to shine through so here is
the braintree logo and then it here it
is encrypted using ECB so the structure
clearly shown through if you don't think
your document has structure you're
probably wrong a lot of documents have
structure so what you ideally want is at
the bottom we're just like looks like
random garbage so if this is kind of
kind of demonstrate if you see the word
ECB and fortunately it's the default in
any case in your system you could be
potentially leaving something in there
that you don't realize so the last one
in this not using authenticated
encryption so it has been shown and
proven now that remember at the
beginning we had confidentiality and
integrity it's now been shown that if
you don't have integrity you will lose
confidentiality so this that's what
authenticated encryption is that is
saying that when I transmit a value the
other end needs to not be needs to be
able to validate the integrity and then
decrypt it and if they can't do that
then there will be there will be issues
and there will be vulnerabilities that
will allow the value to be modified or
you know some other similarly bad thing
so padding Oracle attacks are very old
news so this this paper was in 2010 but
the original thing about padding Oracle
isn't flows from 2002 from Baden a the
these folks went on to do what the beast
vulnerability and TLS based on this and
then later on poodle that's what poodle
stands for padding Oracle so that these
are practical attacks and the the other
thing is you could build authenticated
encryption into your system that you
could build it wrong like they did
originally in TLS
and you know TLS kind of grew up in
those dark ages where we didn't have a
lot of reasons you know solid research
into crypto at least via not that we do
now and he unfortunately built the
signature so it is authenticated but
they built it backwards they sign it and
then they encrypt it and they need to
encrypt it and then sign it and so that
has allow a bunch of different attacks
one of them was called Lucky thirteen
because there's aa there was timing
differences in the code and that leaked
information and so you were then able to
use that to have a vulnerability there's
one more recently called lucky minus 21
which is this code that they thought was
timing complete later got modified and
it was now once again timing sensitive
and left had issues Apple very recently
had an issue in I messages where they
didn't they didn't valid it they didn't
have integrity on top of their site for
tax for I believe these were like SMS
attachments and I message so there's a
paper from the John Hopkins University
that kind of talked about this they
called it dancing on the lip of the
volcano which is chosen ciphertext
attacks in Apple I message so this is
another practical case very recently of
a system being built that didn't have
authenticated encryption in it and it
was subsequently broken and I don't
really always blame the developers
because they're really we're in a world
of hurt so behind this is an image of
the pie crypto documentation which has
gives you this like litany of options
one of which is ECB mode and then you
know it doesn't really give you any kind
of information about like which is
secure what will be causing a problem do
you you know it doesn't tell you
anything about protecting the integrity
and then the example at the top which I
know you can't you can't see this uses
cfb mode which is cipher feedback mode
which nobody uses like that's like one
of those things were like yeah it exists
and it's described on Wikipedia but very
few systems actually use that and like
why is that your example at the top like
your example the top should be a
practical example that folks can copy
and
news so my recommendation here prefer
the box secret box from lib sodium stop
using des stop building your own on top
of AES stop building encryption without
photography what if you have to use AES
so occasionally folks will be like I'm
in an industry where I have to use AES
so my recommendation there don't use ECB
you have to use authenticate encryption
so GCM mode even then you have to verify
the tag or the Mac first there's like
all kinds of other stuff that you know
will cause an issue it can go wrong is
all I'm saying so good luck TLS ssl
verification so there was a paper the
most dangerous code in the world which
talked about non browsers doing TLS
these are like mobile apps and
server-side apps what they found is that
they were not really upholding the two
kind of things you must do in TLS very
well so the first one is they were not
there some of them were not verifying
the certificate chain if you never know
what a certificate chain is this is what
it is this thing at the top where it's
like bear sign is a route that's on your
system change to this change to this
this is a chain of trust you know these
are protected with digital signatures
all the way down to the websites so if
you don't validate the certificate chain
you can just give them anything and
don't think it's a valid website and so
you know someone can sit in the middle
interceptor traffic and present you with
a completely you know fake certificates
and you'll papal Eason your traffic to
them which is not great if you're
thinking application so what would this
look like in code or in command line so
curl has this flag Club dash K which
will basically turn off TLS verification
if you're using curl and this is like a
PHP code you can say verify peer equal
you know set it to zero verify peer
means I I don't want to actually verify
who I'm talking to that seems like a bad
thing to turn off the second one that
they found in a lot of cases is that are
not verifying the host name of the other
party so if you don't verify the host
name of the other party they could
present any balance certificate like I
could
my certificate for JT Danny calm my blog
and you think you're going to paypal
your your mobile phone or whatever
system would just accept it because it's
a valid certificate but they don't
actually check who that certificate was
issued for and so there there are
problems here so hostname verification
is protocol independent meaning like
HTTPS different from smtp is different
from all the other systems and so thusly
openssl doesn't have it built in so each
system has to kind of do it itself like
a lib curl does it so each so if you
have an HTTP library just sitting on
openssl if you haven't done your own
hosting verification you're probably not
doing it and rust actually just found
this out and like hyper the really
popular HTTP library and rust was not
doing a host hostname verification so
also so we will just you can turn it off
there if I host false not good next
using a broken library hopefully by now
we've all heard about heartbleed this
was another one this this was an apple
this was the go-to fail where they you
know it was because of issues in C code
that it just skipped over the handshake
verification so this is another case
where these libraries were just broken
and some I'm guarantee you this was over
out there that's still vulnerable to
heart bleed so ensure you're validating
connections lean on your library or
framework whenever possible set up
automated testing my recommendation so
you can look at bad SSL com for examples
of how they do it if you have no idea
what to set your server settings for TLS
for Mozilla has a great like generator
like i'm using engine x i'm using this
i'm using this and they'll just drop
configs out for you to copy so you can
get my slides later last stuff let's
talk about trust so raise your hand if
you've seen this before okay now keep
your hand up if you validated the
fingerprints before you actually type
yes alright so SSH unlike TLS uses a
trust model called tofu or trust on
first use so this is this is ssh saying
you validate first time I will
mathematically guarantee that you're
only talking to the same person after
that so if you type yes here you're
telling us this age that you've upheld
your part of the bargain later on the
that other host gets reinstalled or
something else pops up and this is ssh
saying whoa you said that that was the
thing now it's not the thing anymore and
if you read a blog post about this it's
usually just going to take you to like
RM the known hosts file which is not
great all right next up so this is
Mozilla's list of included CA
certificates by default I just kind of
scroll through the list and took a
capture so I would ask you to think like
do you trust all of these companies do
you trust their hiring practices their
fire you know the termination practices
they're auditing practices all these
things because you implicitly trust each
and every one of these in Firefox and
their companies there's government of
the Netherlands hongkong post office
Department of Homeland Security you know
there's all kinds of organizations up
here and so last one of the lessons I
want to talk about a certificate pinning
so certificate pinning lets you kind of
say let you get around this trust model
a little bit and that you can kind of
say only trust these certificates in
this chain so if I have if I'm serving
up one of these it's okay and you can
kind of signal to the in point device
the only kind of either you bundle in
with it a signal to later and it will
remember that and it will kind of fail
the operation if someone later tries to
you know someone signs a like digi noida
where they found the iranian government
had signed you know mail that yahoo com
illicit way so this will help with
things like that there's a public key
pinning standard for HTTP it's still a
little bit experimental under review but
it's called HP KP i definitely recommend
checking it out think about what
organizations you really trust
investigate certificate pinning all
right it is actually over the last thing
i want to say check out Stanford's
crypto class if you're interested in
learning more this is a free Coursera
class I had
commend it unfortunately there are no
sessions listed for like the future
things i would just subscribe and wait
for the next one montesano which is now
called NCC group released a set of
crypto challenges these are you take
some development the these are developer
challenges so you kind of go you like
self guide and they'll help you break a
bunch of crypto stuff so it's a lot of
fun is it questions follow me on twitter
if you're interested I sometimes tweet
about these things sometimes I treat
pictures of my cats so all right I don't
know if we John do we have any questions
and that were submitted to the app
otherwise I'll take live questions or
you can all leave just a question have
you removed all traces of openssl from
their systems so the the question was
have you removed all traces of openness
itself on your systems I will so no and
I'll tell you why so I I think I may be
a little bit different than some of the
community and that I still I still
believe in openssl and I'll tell you why
so Google has forked it into boring SSL
and I've like tried to like feed things
back so it has google kind of behind it
there but you know backing it in for all
their servers and in chrome they're kind
of you know sitting on openssl as their
foundation and trying to improve it the
liber ssl folks from the openbsd camp
have a kind of hard for fit and done a
few things so i think there's hope for
it the reason why I'm not so keen to
like just switch is because if you do a
survey the landscape all the all the
major competitors of it especially in
the open source space have all had very
nasty vulnerabilities in and around the
time of heartbleed they've had the go-to
fail was apples but there were similar
ones in New TLS that's new is in big a
new organization and then a polar and a
bunch of others so I'm not so like quick
to drop open SSL is uh is the devil we
know and I think it's the devil we can
like tame a little bit more so yeah all
right
all right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>