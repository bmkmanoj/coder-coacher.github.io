<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Software Architecture vs. Code • Simon Brown | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Software Architecture vs. Code • Simon Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Software Architecture vs. Code • Simon Brown</b></h2><h5 class="post__date">2014-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GAFZcYlO5S0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Simon and the purpose of this talk
is basically to look at architecture
versus code so as I said in the opening
session this morning pick to the scene
you pitch up to an existing team and
somebody buys you a coffee and they take
you to the whiteboard and they draw an
architecture picture and then you get to
the code base and guess what it's
completely different right so that's
basically that the thesis of the talk I
live in Jersey and Terrell Islands why
is a long answer basically it's a nice
place to live try to simplicity what
I've been doing over the past couple of
years is really helping teams understand
how they can do software architecture in
you know a lightweight pragmatic way but
I still do write coder and I think we
should drag architecture kicking and
screaming back down to earth if I want
to try to really into the classic
architecture books I think they're quite
inaccessible so I've put my own boat
together and what I'm again we're going
to be talking about is basically some of
that stuff I'm really interested in the
intersection between software
architecture and code so although the
title pictures these two things
head-to-head it's really how we can make
the two worlds converge and therefore
make sense to the rest of us as software
developers now you know what software
architecture all about well a lot of
people think it's this big conceptual
fluffy thing right and this is evidence
in a lot of the software architecture
diagrams that I see out there in the
world for me software architects is
basically about two things its structure
in other words how we see the thing
we're building and how to break it up
into modules component services layers
and it's also about the journey of
getting to that structure right so
weaving in all the significant things
that we need to think about and then
communicating them to the rest of the
team and that's really what I'm focusing
on here so my real interest is how we
best communicate software architecture
to a team of developers why so we can
all build the same thing in the same way
show of hands who uses UML here on a
regular basis part of their job
it's like a tiny tiny percentage so
what's everybody else doing I've asked
this question a lot from the US all
around Europe China and yeah most people
don't seem to use UML anymore and this
seems kind of odd because UML's you know
the the one standard notation that we
have as an industry to share our ideas
but few people use it so I guess we're
doing this I guess we're doing no UML or
something right just boxes and lines and
this is a great way to screw up very
very quickly if you don't follow some
simple tips so why is your mouth fallen
out of favor fallen out of fashion I
guess a bunch of different reasons um
you know it's too complex is too
low-level it takes you down certain
paths the notations a bit scary now
there are a bunch of reasons that people
throw at me for just not using UML
people often throw out this immediate as
well you know we're agile we do TDD
instead of doing UML okay some people
say well actually we don't need to do
architecture because we do TDD and they
think that TDD somehow a substitute or
replacement for doing architecture and
that's not the case for me after to
provide boundary to which you can do TDD
inside so when we're communicating
architectures it's really hard to share
everything on a single picture right
because we want to show lots of
different views of the same system and
this is why those classic architecture
took books talk about these things views
the logical view the physical view the
development view you know the list is
endless this is Philip Krypton's four
plus one model there's a logical view a
development view a process for you in a
physical view and basically these are
brought together by the UCS use cases
that you're trying to implement anybody
use this si hands are getting fewer one
or two people it's a nice way to think
about a software system but it's kind of
confusing so if you read Philip
Christians original paper this will
makes perfect sense if you read people's
interpretations of Philip krypton's
paper all the names of jiggled around
and they mean different things in
different versions and that's
the thing I find most confusing about
this whole views thing right so I've had
arguments with architects about the
difference between a conceptual and a
logical view of an architecture what
right maybe I'm just too stupid but they
sound like the same sort of thing to me
if I'm a developer writing lines of code
you know it's the physical view some
view of the files on the file system
no because the physical view is normally
an infrastructure related view but what
happens if our infrastructures
virtualized do we have like a physical
virtual view or a virtual physical view
the whole thing doesn't make much sense
and this is what I have to see were
these different ways of representing
software architecture you know the the
logical view is separated from well the
code right we're trying to force
ourselves to think about the architect
of a system independently of the code
and you get this weird situation where
you have your software system with views
around it and the logical views have a
one side and the development views on
the other side and this makes my head
hurt right so my kids eat ice cream too
fast and they get brain freeze
if you go into Wikipedia and do a search
for brain freeze there are some hints
and methods to prevent this drinking a
hot drink beforehand these are two
workarounds the easiest way to avoid
brain freeze is not eat ice cream fast
the easiest way to not to get brain
freeze when we're looking at these
logical views and things is just to do
something else
right so how do we do something else
well if I need to communicate a software
system maybe I just go to Google and ask
Google what it thinks I should do right
so if we go to Google you get stuff like
this right if you do a search for
software architects a diagram on Google
you get stuff like this and it just goes
on for page and page and page page page
now there are some UML pictures in here
but guess what if you guys don't know
UML those options kind of go away lock
diagrams let's draw a block diagram of
our architecture and you get stuff like
this I can see people nodding you've all
seen these in your documents empty
enterprise architects love these things
because you can do the powerpoints nice
gradient shading that kind of thing this
one here is great you know we always
talk about layering being importance we
have horizontal layers some of different
sizes don't know why some of the boxes
of different widths don't know why nice
gradient shading they you know these
diagrams don't make much sense and what
I've discovered over the past few years
is that that teams really do struggle to
communicate the design of their software
so I was running my architecture
sketching workshop here on Wednesday and
I've put some diagrams at the front here
there are two piles there's a pile that
we did in the morning kind of before
guidance and there's an after pile and
if you look through the before pile
you'll you'll see that people do
struggle so I'm a big fan of doing
architecture cartas way to practice this
stuff and something I do very simply is
just a financial risk system which
basically takes in data from one source
take some data from another source
merges the data together perform some
calculations and essentially produces
some Excel reports right it's a simple
batch style system how hard can it be
right but these are the sorts of people
sorts of pictures people draw right so
we have like a shopping list of stuff
right let's weave all these technologies
in and let's just draw a picture of it
it doesn't tell us anything about the
system we get boxes and no line style
pictures right this is a three something
layer or tier Microsoft solution why
because it's got asp.net at the top
there are no people using it so I hope
we're not buildings for no reason
database is stuff in the middle module
services don't know the functional view
right people love drawing functional
views of systems imagine you were
getting a new house built and your
building architect drew you a functional
view of your house it's basically a
bunch of boxes sleeping eating relaxing
right it's it just doesn't tell us much
just color coding on this picture I
don't know what it means but I'm sure
the people drawing it did
do you like this one the central spine
is kind of nice it outlines the major
steps of the process that we're trying
to implement here this green blob is
like skiffle it's a huge Airport hub
lots of connections stuff on the Left no
idea different colors shapes lines
styles of lines this box here says UI
upside down I don't know I
Australia this is like architecture 101
doesn't tell us even with better risk
calculator look we're building a system
with business logic excellent I'm glad
we cleared that this is our logical view
I've you know how to architect two
diagrams and documentation reviewed and
passed by objects and they've complained
because my logical view includes
technology choices it's apparently your
logical view should not include
technology I see a lot of this you've
had a pocos plain old C sharp objects
and pojos plain or Java objects homeless
addition nobody tells you about right
it's just a bunch of C sharp objects
kind of floating around a cyberspace
let's want to give them home you know
wrap them up in something this is like
the middle part of a bigger picture it's
a complex asynchronous Avenger of the
solve architecture you start at the top
you weave your way down to the picture
like they're storybooks you have when
you're a kid you choose your own path
through the book by turning different
pages eventually in the story you die
this diagram is exactly the same you
follow different paths you will end up
in the trap this is a lot of
architecture for basically adding two
numbers up
we love engine everything's so when I
kind of did these architecture Carter's
I asked people what they find
challenging and they say well yeah we
don't know where to start we don't know
how to express the solution we don't
know what your notation we should be
using we don't know what level of detail
we should be dropping down to there are
normally a whole bunch of unanswered
questions right so people can't draw
pictures it's a summary so how do we
communicate our architectures well maybe
we're tackling this from the wrong
perspective so let's look at code right
let's start from the bottom up and see
if we can weave some magic in here
somewhere we're not drawing diagrams
during the design exercise really this
is the question that I'm trying to get
to the bottom of right so is this what
we are planning to build right can I see
the implementation strategy and of
course if we're drawing pictures
retrospectively then we're trying to
answer the other question right is this
what we actually built code is really
you know the single source of truth and
it's our representational realization or
embodiment of the architecture so when
we draw pictures do we want to show all
of that stuff right so if we have a
system with two million lines of code do
we want to draw a diagram with two
million things on it not really so this
is why we drop up to the architecture
views and we're talking about
abstractions here aren't we right so
we're talking about abstract concepts
that allow us to essentially reason
about a complex or large system we chunk
stuff up so we can refer to things much
more easily and this raises a bunch of
interesting questions I think you know
does the code reflect those abstractions
that we think about and this is really
the whole question I started out with
you have a nice architecture picture on
the wall and look at the code and the
codes complete mess but on the wall it
says we've got this nicely stacked
layered architecture with diagram with
lines going in one direction only
and the co doesn't like that and of
course we often think in terms of
components when we're drawing pictures
but actually Java C sharp doesn't have a
component key what does it write we're
writing classes and interfaces and
packages and namespaces and these sorts
of things so of course there's a
mismatch between our coding world and
our architecture odd who here uses a
layered architecture
ah now we've got loads hands going up
yeah so most people adopt a layered
style of architecture
what's a layered architecture something
like this maybe now we have presentation
stuff and business stuff and data stuff
and we wire them together neatly and six
services or components and each and the
world is happy place
why do we do this a bunch of reasons
separation concerns
substitution mocking testing yeah de
list goes on why do we do this people
tell us it's a good thing right if you
go and read lots of books about software
development they'll normally start out
with here is a stereotypical application
so this pictures from one of the
introducing spring books and it
basically says yeah do stuff like this
have a presentation layer this is C
layer and a data access layer what to
layer well it's all about decoupling
right so that the the purpose of using
layers is decoupling it's about
isolating changes making sure the
changes you make here don't ripple up
unnecessarily to the top you download a
bunch of tutorials and starting points
you know this is an empty project the
spring this is the sort of thing you
should build notice here look a domain
package or a post repackage or service
package so if this is your starting
point how do you make your application
you just plug stuff in each of those
levels you go on Stack Overflow how do i
structure my project people respond to
this kind of advice in fact there are
even tools out there which generate the
start of project for you and of course
it's exactly the same the run soft world
right so all of the starting points for
learning spring MVC asp.net we see
they're basically started with layered
architectures
and that's fine but what happens to a
layered architecture does it stay nice
and clean
not so much salt ends up looking like
that doesn't it people nodding
because this is all public we can kind
of skip around layers I did the
sketching workshop with a customer a
couple weeks ago and they drew their
diagram of some nice set of layers and
then we looked at the code and we had to
add some more arrows and the resulting
diagram I look like this we have other
options we can use hexagons and onions
and all this kind of stuff these are
basically just laid after it's just soup
all right so essentially it's all about
ice icicle business code decoupling that
kind of thing
hexagons onions still later
architectures right in terms of how we
organize our code we normally Cikini
things into different projects or
packages or namespaces that kind of
thing and we can still scrub and they is
actually bad la is hurting the way that
we build software because I do see lots
of software systems that start out nice
and neat but end up as big balls and mud
well I don't think so
I think laser useful but are they
architectural
the starting point for most people's
architecture diagrams is we'll draw a
big box representing our system and then
we'll have layers and that's the first
thing they show about software system is
that really interesting to us though you
know are the layers the structural
elements or is it the things inside the
layers that are actually the structural
elements that we're really interested in
so maybe the whole layers thing is just
an implementation detail that we don't
necessarily want to see and of course
this reflects itself in the organization
of the codebase and a lot of the ways
that we describe software architectures
again it pits the logical view of the
world versus the organization code and
there's a gap so we think in terms of
components layers services but we're not
writing those things we're writing
classes in packages and layers George
Fairbanks he was here I think last year
with the import he's got a book called
just enough software architecture and in
his book he talks about this the model
code gap he basically says when we're
thinking about architecture we have a
bunch of abstract concepts so things
like modules services layers etc but
these things don't exist in the code so
he's way smarter than I did because he
came up with ages ago in his book as
well he has a table which basically
shows different ways to conceptualize or
visualize or think about software
architecture and they mostly have a
design model and the code model so again
most of these ways that we think about
software systems split out code from
design and architecture so maybe the
trick here is to merge the code and the
model right who's now getting scared I'm
talking about moral driven architecture
yeah no but we do want these two worlds
to overlap and a lion so maybe there's
something in this without the whole
scary generating everything for a model
thing please
George's answer is very simple he says
well why don't you just use an
architectural e-everything coding cell
so in other words when you're writing
koan you're organizing your code why
don't you make it so that the things in
your code reflect your architectural
concepts your abstractions so in other
words now maybe have a naming convention
that says all of our services will be
suffixed with the word service maybe we
will have a packaging convention that
says each service or component will be
in its own package who does this good is
it useful
is it hard work do you have to think
about it good if you're doing that and
I'm talking about diagrams and
communicating software systems why can't
we just generate pictures so if you're
using an architectural encoding sell the
diagramming tools we have available to
us should be able to automatically
generate those pictures for you right
but they can't why because they don't
know what a service or component is we
have to teach them about this
architectural encoding star and these
diagramming tools basically see packages
and classes and that's where whenever
you run the you know set structure one
and one Latics and depend over your code
base it just shows you their mess you
have start cleaning the pictures up you
get stuff like this now they start
drawing pictures of layers for example
you get pictures like this it shows you
lots of dependencies between things
normally between packages or between
classes again these are not showing the
services or components same thing over
and over and over again so maybe we're
not using an appropriate language for
modern software systems so maybe we do
need a language which you know has
components or service or micro service
as a first-class thing I'm not a
language guy so I'm not going to write
this but there are some thoughts sir
so how do we get these two worlds to
overlap well we draw pictures the
picture should reflect the code and vice
versa of course and what I really care
about is a set of abstractions so for me
a common set of abstractions is way way
more powerful and important than common
notation and if you look at UML UML
gives you two things it gives you a set
of abstractions right use case bubbles
classes components deploy nodes and it
gives you a set of boxes and lines
notations to essentially represent those
things now when I see people using UML
they're normally abusing both things so
they have a diagram and they'll be a
class and it won't be a class it will be
a message bus or they'll just use a
class diagram because it's a convenient
way to draw boxes and lines and they'll
scrub all the information out and just
use it as boxes and lines so therefore
maybe we should just focus on the
abstractions and forget the whole
notation thing to some people this kind
of sounds foolish but if we went to find
two maps of Amsterdam those maps would
both show the rivers the canals the
tramway the roads the district's the
points of interest but they might use
different colors notational elements
shapes symbols but we can understand
them because there's a self-describing
notation here there's a key relations in
the bottom corner essentially but it's
the abstractions that they show that are
really important so how do I do this
well I kind of put the whole logical
physical view things side and think
about a software system is basically
being made up of a number of containers
what's a container it's something like a
web server a web application download
application and application server
message bus a database of file system
basically is something that you need to
have running and deployed somewhere that
hosts code or data I break my software
systems up into components so I'm a big
fan of you know chunking stuff up into
components this is a massively abused
word right
my definition of a component is very
simple it's a bunch of related stuff
with a nice clean interface something
you can substitute out and because I'm
mostly dealing with Java and.net systems
these components are made up of classes
right so these are low several building
blocks
maybe these are functions of using
functional languages tables views or
procedures that kind of thing and it
turns out this is really really nice
simple way to think about software
systems and once you have this in your
mind you can draw pictures and each of
those lots of turn so I'll start with a
context diagram which shows my system
and stuff around it I'll then zoom into
my system and basically show the
containers so the you know combinations
of app servers web service databases and
how they make my app work I'll then
maybe open up some interesting
containers and look inside them you know
show a components view of the world and
how I've decomposed my system and then
it might optionally do some class level
design optionally right don't normally
do this to show you some examples I
built a really simple content aggregator
in Jersey it's just an aggregator for
people in the tech world
it lists tweets blog posts jobs
businesses local people that kind of
thing and this is an example context
diagram so this is my system here the
monkey the system I built it has people
actors roles personas at the top who use
my system and essentially my key system
Penn C's at bottom so in this case I'm
pulling data from Twitter blogs github
if i zoom into the monkey's head and
blow them up right we get a containers
view of the world so this basically says
my tech tribe system is made up of a web
application a standalone application
that updates data content information
from Twitter blogs github and a bunch of
data sources in the middle right it's
nice and simple and then if we open up
the content of data thing we get to see
the components view of the words it's in
just a nice logical decomposition of the
world we've got some tech choices on
here some responsibilities you know it
shows us quite a lot of nice things
about our software these diagrams are
available to download off the website
for free by the way these things like
maps on the right so if you go into
Google Maps and do
for Jersey you get that view by default
which is great if you want to know what
in Jersey and how it's broken up it's
completely useless if you have no idea
where Jersey it's oh you have to do the
is it pinch in or pinch out inverse
pinch I don't know to zoom out and
eventually you get the kind of thirty
thousand foot view it's the same with
these diagrams sometimes we want the
zoomed in view of the world sometimes we
just want to step out to see the big
picture I'm not trying to create a new
standards here I just want to provide
some ideas about how people should think
about their software system right so
it's the abstractions they're really
important to me then it was interesting
when we ran the sketching workshop on
Wednesday when I asked the teams what
they found challenging one of the things
I said was we don't know how to describe
our thoughts to other people because
essentially these are small groups of
two or three people and these people
have never met before they've never
worked to go before so they're coming at
this from different perspectives they
have different reference points and
they're all calling different things
different names and it's making the
design process much much harder what
this is basically doing is is it's
sticking the static structure of the
software back in the middle right at
different levels of abstraction and once
you understand the static structure of
what you're building it's really easy to
fold in the other stuff so you can have
runtime and behavior models based upon
your static structure you can have
infrastructure morals and therefore
deployment ones that take containers
onto infrastructure alright so if me
getting the static model right is really
very important this all comes back to
code right so the static structure of a
system is ultimately about the code and
that's where we as developers spend most
of our lives and basically what this
admits is that you know actually when we
talk about architecture and drawing
pictures we as developers are the most
important stakeholders now when I'm
drawing pictures of my software system
I'm doing it for me as a software
developer and I'm doing it for my team
yeah operations people support people
maybe there are a few other people who
want to know something about what we're
doing but essentially
it's us as developers so we have
diagrams we have code and as I said
before the two worlds need to meet and
if they don't the diagrams are pointing
to something this is what I see a lot of
organizations they have these big
grandiose a zero sellotape together a
few times pictures of their system and
nobody look to them why number one
they're out of date number two they just
can't comprehend that amount of stuff
and number three they don't match the
code they're the creation of some
grandiose architects who basically drew
a bunch of conceptual fluffy boxes on
the picture and then the team ignored it
and did what they want ah this is a
rather embarrassing question to ask
isn't it how did this sneak in here so I
showed you some pictures of my tech
tribe site down to component level does
it match the code hmm well I sort of
accidentally open-source the codebase so
you guys can go and have a look at
github and figure this out for yourself
but I can save you the pain the answer
is yes get in because I'm awesome I
practice what I preach so yeah so you
know there's a component view of the
world and I've used a convention where
each component sits in a Java package
there's a nice bunch of stuff a nice
traceability between code and diagram
awesome
did it start out this way not really is
the honest answer
I drew my tech drives pictures from my
book of my training course and that's
the way I'd thought about the
architecture in my head but the code
didn't really look like that so I was
essentially creating a fantasy land
why because I use layers right I did the
stereotypical java thing of just
basically building a web app with layers
so to give you an example there's a
tweet component and basically there's a
MongoDB saw and it stores tweets and
there's a simple component to get access
to that store that's it my first
implementation was this there was a
services package or services layer with
an interface and an implementation and
there was a data access layer with an
interface and an implementation and
weezing spring can you tell that's
services that's layers that's not a
tweet component but my diagram had a
tweet component on it it's really what I
was doing here I was I was you know
mapping in my head the layers in the
code and transposing into a single
component but it's wrong isn't it
the mapping isn't explicit two choices
redraw the picture or change the code I
didn't want to redraw the picture
because it looks complex right because
we have all these layers and things
decide it and relationships and
interactions and stuff
sorry refactor the code and now I have
something like this so all of my
components sit in a package there's a
nice clean public interface and all of
the implementation details are package
protected so they can't be nudged from
the outside world this is kind of cool
but I don't have a layered architecture
anymore it's what people say I do it's
just that my layers are inside my
component so I still have a services
layer I'm still have a data access layer
but they're wrapped up you know that
just distant implementation detail
Abhinay you can't mock your MongoDB
thing out and test it unit test it I can
but I have to jump through a few hoops
annoys me actually you know I've lost
the ability to unit test this thing
easily that's one of the big advantages
layer doctors just give you you know
that's why we talk about clean
architecture and clean code that kind of
thing as I wasn't still going to do unit
testing right so that's the other
approach here don't do unit testing and
I don't mean don't test
I mean don't do unit testing so with my
simple example here what benefit does
unit testing actually give me
essentially all my tweaked components
doing is giving us a way to access a
Mongo database so what maybe I should
just do component testing through the
component interface right so it's
another approach this is whole
interesting thing in the industry at the
moment about testing and how t DD is
dead some of it's quite punch virtual
some of it you probably agree with this
is one the original papers that sparked
all of this stuff we've come in a long
way since we started doing things up
mocking you know mocking out a database
collection because it's slow we've got
SSDs so as a fast we can provision
infrastructure with ansible or vagrant
or whatever and do these things really
really quickly so a lot of the original
reasons for unit testing have kind of
disappeared I love this line in the Jim
Killeen paper he basically says maybe
we're not going to do design and DHH the
rails guy picked up on a lot this stuff
and said yeah actually we are abusing
weight you know we've got tests induced
design damage why because we're having
to separate all this stuff out order in
order to create simple isolated unit
tests and again I think he's got a point
you know I think we're blindly walking
into a bunch of these architectures and
designs because we think we should
because we think it's good to you know
surfing in isolation but maybe we need
to just think of it more so yeah maybe
it's the significant elements that we
want
and we don't want to blindly unit-tests
everything so that's why maybe thinking
about your system in terms of components
and set of layers opens up some
different avenues for doing testing for
example what's the point of all this
apart I get to talk about drawing
pictures and echoes stuff well
essentially a good architecture enables
agility doesn't it right so if we have a
nice clean structure this provides us
the ability to change it to flex it to
enhance it to extend it in the face of
change of requirement but of course
there are different ways to build
software systems right so on the one
hand we have the big monolith you know
these things are normally easier to
write single deployment unit often look
like a big ball of mind if you open them
up especially if they evolve over years
these things can be hard to change
unless you're at sea and then you're
also man over here service based
architectures micro-services this is
what josh is going to be talking about
later right micro-services gives you
lots of agility and flexibility because
instead of deploying a single thing
you're deploying lots of smaller things
and you can change them whenever you
want to you can write them in different
languages this buys you a ton of agility
but guess what
it's more complex than that it requires
orchestration you know there's a bunch
of other things we have to think about
it's not a free lunch whenever I go
insane hotels and I get my cereals for
breakfast I go to the milk station and
it's either full fat or skimmed right
extremes there's never anything in the
middle there has to be something in the
middle here and again you know if you're
if you really do want to create
monolithic systems maybe this is about
structure so maybe it's about injecting
structure and this is why I'm a big fan
of the components thing all right so
even with monolithic systems I like
chunky my monolith existed systems up
into nice neat structures in this case
component
the decomposition strategy that you use
is really important here yeah whether
it's functional versus volatility based
decomposition essentially that's how we
get to a nice neat structure and you
have to take lots and lots of stuff into
account right so you have to understand
which bits might change in Y and try and
isolate the impact of those changes the
thing I see in industry the most is that
people really struggle with these
concepts applied to monolithic systems
and over time now monolithic system is
evolved and they do turn into big balls
mud I've spoken about this whole
component base thing to audiences and
they're like yeah we don't like it we're
just going to do layers right we're
comfortable building systems that are
just layers and they think the whole
breaking your system into components is
hard because you have to think about
responsibilities yeah guess what it's
hard right but if people can't think
about components in model its guess what
we're building microservices are the
next big balls mud they're just
distributed big balls of mud so the same
principles that we have to go through
for decomposing our software systems and
monoliths are equally as applicable to
microservices you know design is key
here Design Thinking is key architecture
is key the whole agility thing is
basically you know inspecting adapting
it's about reflecting on stuff that's
worked and changing what hasn't how do
we apply this in software systems right
if we have an existing architecture and
we need to change it in the face of
change of requirements we need to see
what we've got and this is the thing
people are really hard at doing this is
a whole visualising thing but once you
understand what you have it's really
really easy to see where you want to go
to so again thinking about structure
conscious is really important here so my
key tip here is basically have a think
about how to align the architecture view
of the world and code view of the world
and by creating a really nice clean
explicit simple mapping it opens up a
bunch of opportunities it makes your
software systems easy
to work with easier to understand it
makes those conversations over
whiteboard much easier to have as well
because you can draw things on the
whiteboard and then go look and this is
that thing in the codebase there are no
silver bullets all right so I'm not
pitching a single approach I'm not
saying that layers are bad you should do
compiler bases own I'm not saying you
should do micro services you know all of
us will need different systems we have
different contexts different needs so we
still do need to think and we shouldn't
blindly apply the same approaches over
over again around layers decoupling unit
testing maybe thinking about our
architectures in different ways in terms
of structural elements as I said earlier
it leads us to other options and my
final point is basically this if your
software system is really hard to work
with change it and make sure you have a
nice arc tat to view and a code view
that overlap and reflect you thank you
very much
so the question was when I showed you
the code very quickly there was an
annotation at component with some
documentation there do I use that to
generate diagrams the answer is not yet
but that's exactly why it's in there so
I'm working on a tool to shoot through a
code base extract components or services
or micro services and then we will
automatically draw the pictures based
upon relationships and Pence's so it's a
work in progress thinking thing sorry
some events will get already up yeah so
the the annotation processor for Java is
awesome github I'm not sure if that was
a question or a statement but basically
if you go for a component based approach
mocking still important and I agree so I
guess there are two two things it in my
simple example of you know tweet
component accessing Mongo I can just go
straight through like this there's a
very little point in decoupling my data
access object if I wasn't accessing
Mongo and I was sending email or sending
a JMS message or accessing a third party
that probably still needs to be mocked
so you know there's not one rule fits
all if you look at my web layer my web
layer is essentially very slim MVC style
controllers orchestrating bunch of
components how do I test those I can
actually mock out the components
wholesale so yeah we can just apply
mocking to a different level of
granularity good point right so I guess
the question is how do you how do you
make sure you're you're thinking about
your architecture in a clean way and
you're not mixing up these different
levels of abstraction essentially it's
all about so the easiest way to think
about this is where does the code live
and how do I deploy the code separately
so if I was implementing a user story
that I was deploying some code in my web
server and some code in my database I
maybe there's a sub procedure and a
bunch of code in the web server I would
treat those things as two separate
components rather than one component
that has kind of two implementation
sites if you see only me and again once
you do that you can start thinking but
if you think about them as separate
things we separate interfaces then they
can be changed in different different
frequencies and stuff
so it's really about forcing yourself to
think about stuff in isolation I guess
if you want to be good examples of what
contains stuff is there's a pile of
diagrams here from the workshop which
show the kind of secondary interaction
of the pictures these ones should be
much much clearer than these ones and
this shows you that nice kind of
decomposition of a software system so
the question is if you have an
architecture how do you make sure that
you communicate that to the team
effectively so that we essentially build
the same thing and same way with same
principles and the answer is pictures
right so this is exactly why we've drawn
pictures these pictures go into enough
detail that we can get to view of the
implementation strategy we can see
relationships between our structural
elements and we can see technology
choices there's a lower level of design
inside the components you know design
patterns actually the thing maybe we
should leave that to the developers
unless we want to enforce certain
principles and patterns so that that's
exactly the purpose these diagrams it's
to set a scene this could change right
I'm happy for the architecture to evolve
over time but let's do so in a
structured way so question is basically
how how do you effectively communicate
to non-technical stakeholders and what
sort of questions crop up the easiest
way to do this is you know to use a
model where you can draw different
pictures of different levels of
abstraction so this is an example
context picture there's nothing
technical on here it just describes our
system and how it fits in with the rest
of the environment so this is my
starting point for having those
non-technical conversations if I'm
talking to operations and support people
maybe I go down to a containers view of
the well it shows you know web service
databases app servers I'll stop and the
next levels are just pretend to people
so again it's by forcing yourself to
think in terms of clean abstraction
levels and layers that you have a story
to tell from non-technical down to
technical essentially in silence your
question the pinching thing yeah yeah if
someone could make me a web tool to do
that
please have your 'some
the question is how do you take this
kind of approach and communicate your
architect to operations people who want
to know about deployment and
infrastructure concerns for example so
my containers picture only shows web
application database file systems it
doesn't show that there's you know a
MongoDB cluster a web server farm that
kind of thing so this is a separate
diagram so I'd have a deployment diagram
which basically shows how my containers
are mapped on to the infrastructure also
if you've got a thousand nodes maybe
drawing diagrams crazy but it's a
separate view of the what you know the
static view of the world and ended the
deployment view are separate so I guess
it sorry the question is how do I work
is the short way to put this and the
simplest way to describe this is I do do
some upfront thinking so when I'm you
know attacking a problem I'll draw these
types of diagrams because you can do
that level of decomposition very very
quickly and then if we're doing if you
know if we want to go down the TDD where
it maybe we do TDD in the components or
we TDD from the outside inside this
there's still lots opportunities for
evolving and using TDD or
you know test first test last but that's
you know this is the starting point of
all of that stuff I'll generally go down
to this kind of detail which puts a
framework in place so in terms of
high-level components and chunking up
responsibilities it's the same thing if
you're kind of doing a micro services
architecture you have to figure out what
services are same thing so I have to
figure out what the major components are
and therefore how they interact cool
well thank very much back in here at
11:30 for Josh's talk about Godzilla
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>