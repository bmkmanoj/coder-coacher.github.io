<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Translating DART to Efficient JavaScript • Kasper Lund | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Translating DART to Efficient JavaScript • Kasper Lund - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Translating DART to Efficient JavaScript • Kasper Lund</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GwBb_nqQLuc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is a talk about how we translate
dark to efficient JavaScript and I hope
you guys interested in either javascript
or compilers because this is a the two
topics that I'll be mentioning that of
course plus plus some dart and so first
of all and as I said my name is emma's
Casper I work as a software engineer at
Google and I've done a lot of
programming language projects I used to
do embedded small talk which was a lot
of fun but apparently nobody really
likes the programming language it
doesn't have curly braces so we ended up
doing a v8 instead which is a java
engine and we built at Google and that
got included in Google Chrome that we
shipped in like four years ago and we
had quite a lot of success with that
small project and it's now being used
not only in chrome but also in note j/s
and other setups and and I think we've
helped push the limits on what you can
do with javascript which really brings
me to the next bullet up there dart dart
is a is a language that I help the
co.design it's a new structured
programming language for the web and one
of the core features of it is that it
compiles to JavaScript so it's
compatible with the with the open web
but you can use it in in any modern
browser today so I'll give you an ultra
quick introduction to dart and but I'll
focus mostly on the under compilation
and the compilation of dart to
JavaScript so dart is an unsurprising
opted oriented programming language it
has classes with single inheritance it
has implied interface for those classes
so you have something resembles
interface from other languages and it
has very familiar syntax the familiarity
of the syntax is very important to us
and it's very hard to come up with a new
program language and make it a success
so you need to make it look appealing to
people and a big part of that is making
it look familiar and there are some
novelties in there and and some things
that we really very happy with like
optional static type annotations that
allow you to and in the place where it
makes sense for you document the intent
of fields and variables by give them a
static type you don't have to do it but
you can and it's a very powerful thing
I'm not going to spend the ton of
I'm on that in this and this
presentation but it's a very powerful
feature of the platform that you should
probably try it out if you haven't
already there's a tiny bit of a code
here on the on this slide that just
gives you a feel for what what dart is
this is actually without any class or
anything it just uses a top-level method
called main and it has the familiar see
based control structures like four loops
variables introduced with a prefixed
type like int I equals 99 and some print
statements with some string
interpolation expressions that just make
it easier to work with strings and
hopefully this doesn't look too scary to
you guys it'll get worse in the
presentation going forward but hopefully
this is sort of a somewhat familiar to
most of you so this is this is how we
execute and deploy dart code so you
write your dart code in your favorite
editor and and you write it a source
code then you have two options either
you come you run it directly on the
virtual machine and that's the the right
most part the dart virtual machine which
is either embedded in a browser we have
custom builds of of chromium the soft
base for for chrome that has the this
native vm enabled in it so there's no
compilation step you just run it there
which is really nice you can even run it
stand alone as a server-side scripting
language and it's a very nice feature
and on the other hand if you're in a
situation where being compatible with
existing browsers out there is really
important to you and you can also use
the darts gel should compile it we've
built to translate your dart code to
JavaScript that runs on any modern
browser this is a very simple picture
and there are other tools involved too
but you have these two options either
you compile to JavaScript and run that
in an assistant browser or you run the
code without compiling it just directly
on a native vm so dart to JavaScript
compilation is very important to us it's
very important for us to support that
across all modern browsers and so we we
regularly test on both Chrome Firefox I
and Safari up
it's just around the corner for us and
so we want to make sure that no matter
what kind of modern browser user is
using you can run dart code in that
browser through translation so this
actually means that the dart VM is an
optional component you don't have to use
it it's very cool and it's very fast and
but you don't have to use it we're not
trying to force you into using that
piece of technology so being able to
compile the JavaScript is very important
of course it's also important that we
can generate efficient and compact
JavaScript and that should go without
saying I the team that i'm a member of
we we take great pride in performance
and really what drives us so being able
to compile to something that's efficient
to run and is fairly compact this is
certainly something we care a lot about
and the third thing is that we we want
this translation to implement the proper
doc semantics and one child into
JavaScript there are certain things that
you could decide to perhaps not do like
JavaScript allows you to pass any number
of documents to your functions you can
pass through few you can pass too many
dark doesn't allow that so we have to
make sure then we translate dart to
JavaScript we keep that same semantics
that you cannot pass too many or too few
arguments to a function and we want it
to be more strict and more well less
there's no implicit coercion to numbers
and strings in dark so whenever the
underlying JavaScript platform would do
those things for you we have to make
sure that it doesn't affect the
semantics I'll give you some examples on
what what that really does to the code
and what we have to guard against
essentially in a few moments the other
big thing is JavaScript as a language
doesn't have the notion of checking and
indexes when you access erasing lists so
it's essentially anything goes if you
pass in an index that's not within range
you just get undefined out that's not
the dark semantics we actually want you
to get an exception if you try to go
outside the bounds of a list and an
array
so here's a small example more dart code
it has a main method and it creates two
points in this case I decided not to put
static type annotations on the P and Q
variables so this looks very much like
JavaScript code it computes two points
and set P and Q by calling the
Constructors of those things and then it
computes the distance from P to to Q so
how does this look if we translate that
to JavaScript well it's pretty close
this is actually the Java so we generate
for that so there is a main method well
in this case it's a gelatin function
assigned to the main property of a
dollar optic that I'll tell you about
later and within that function body the
code is more or less what you would
expect there's a two constructor calls
in this case we're not using new right
here it's actually hidden behind this
factory call through to the point
factory and but the distance to call is
also a bit special in that it has a
dollar one suffix at the end which is
our way of making sure that the distance
to method gets exactly want an argument
but if you take a self step back and
maybe have four explodes your eyes this
will look more or less like the splash
there before it's very very close to a I
can want to one translation so I
mentioned that these these tab little
functions and in this case the main
method is put on this dollar object why
do we do that so Java so has a notion of
global functions so you could all just
stuff them on the global object instead
well it turns out that putting too much
stuff on the global object is kind of
annoying if you want any kind of
modularity in your code so if you ever
want to make send code from some other
place and you may have conflicts on this
one global object so instead of throwing
things in the global object we actually
go for putting them in a in a smaller
and object and we just have this
shorthand notation for X in that called
the dollar thing it's actually part of
our an isolate story and isolates are
our way of running multiple independent
units on the same Java VM and so there
every single eyes that would have its
own
and sort of i stood object represented
by this dollar thing so top level
functions constructors all those things
they just go into that one namespace
instead the compiler emits that for us
so the method calls were just simple
jobs of function calls except that we
translate and encode the era t of the
call in the in the name of the method
that we're calling and this is also done
to help us support something like a
named optional arguments which is a
feature of the platform and and
essentially we're just trying to make
sure that the the stricter semantics we
have a start and it's kept when we
compile the JavaScript so the dark
compiler is it's kind of a sophisticated
the piece of code at this point and we
started out with a somewhat simpler
implementation of the of the dark
compiler and it generated quite a lot of
code and it took a long time to generate
that amount of code and it turned out
that we were actually compiling a lot
lots of pieces of the code that weren't
used at all so we decided to try to
tackle that from the from the ground up
and through a mechanism we call tree
shaking think of all your code as sort
of a a tree and our survey weird graph
of dependencies between the different
functions and the classes and think of
the the dependency tree that you can get
off like grabbing hold of the main
method that the one entry point you
notice they're just excited only drops
out that's what we think of when we say
tree shaking it's actually a term from
at least the old Smalltalk systems that
we've just kept in there in the mix here
it has three stages this tree shaking it
starts out on the on the very right that
is the left and by reading in the the
main file which may have imports of
other files and may have the source file
that needs to be read from either the
web or a local file system we just read
them in and we do a very quick sort of a
bit of a hacky parsing of this thing we
don't look at method bodies we don't
look at all the cards that we don't
really need to look at we just
want to figure out what are all the bits
and pieces that we need to to bring in
all the source pieces once we have that
brought in will actually start the the
middle phase which is the resolving
phase where we figure out what every
name refers to and the way we start that
is actually just by putting this main
method of the of the entry point into a
resolution of resolver queue and then we
do a full parts of that when we have a
full part of that we will know more
about the then the method body there so
if main refers to something like the
point constructor it will actually go
back from the resolver and feed that
into the resolver Q and say we we
actually need those constructors to and
because you don't have full type system
in an assistant like it darted it's not
a conservative approach here so if you
see a call to a method called foo on
something you don't really know what is
you just have to make sure that you put
in all the food message that could
potentially be called so this is an
approximation of the set of things that
you need and turns out it's it actually
works pretty well there's a lot of
things we don't have to deal with and in
the common case and but we do tend to
get a bit too much information or a bit
too many methods involved in that way so
this queue actually knows about classes
we know that are in San Shi ated it
knows about which method names are in
use and it knows a bit about type
information for receivers most typically
because you've called methods only on
the dis object where you know something
about the enclosing class once we've
done the resolution we know something
about which names bind to which things
we actually feed that into another queue
which is the compilation queue and we
start over we put in the main method
there and we built that essentially
again that same queue the reason why we
do that is that the code generator
actually has an optimization face that
propagates type information through this
through the intermediate positions we
have in play so sometimes we have more
type information there so whereas in the
resolver you might know that foo is
called on something in the cochin area
we actually may know something about
what it is called on this is very
abstract and but the end result is that
we end up diet parsing a whole lot and
we resolve and parts
be less than that and we actually
compile and generate JavaScript code for
a subset of that the net result is that
something like a hello world example
compiles to a very very short amount of
JavaScript code and and of course the
more dependencies and the more stuff you
import from other libraries and you
include that way the bigger the
application will get so it's it's more
like a pay as you go around than
anything else so so when compiling dart
to JavaScript there are some language
challenges that I briefly mentioned
before I just want to dive into some of
those one of the big ones is that dart
has support for user definable operators
so you could say that on my class my
vector class that I invented I want to
support the plus operation so you can
add these vectors together for instance
javascript has this notion of implicitly
converting plus inputs to numbers we do
a plus somewhere it's either converted
to a number or string the two inputs
depending on well the inputs but there's
no way you can make that plus like the
JavaScript plus and essentially do I
give a more high level plus operation on
vectors for you so you cannot use Java
with plus to implement dark plus it in
the general case it just doesn't work
the other way to do it like the simple
ways just to say whenever we see a plus
and dart code we'll just call a method
on the on the left hand side and we
actually tried doing that just a just
add method calls for all our arithmetic
operations turns out it's just too slow
at the at the sort of the lowest part of
the slide here I've showed how you could
do that by just adding a atmos a
doorstop message to the number prototype
and that actually allows you to call the
add method all the sup method on numbers
so it actually works the problem is this
method is very slow and the reason why
it's very slow well one of the reasons
why it's very slow is that inside this
JavaScript function that this reference
in there is actually a box object so
when you call when you call the add
method on say on the integer 1
JavaScript DJ out- actually has to go
head and wrap that ensure one in a new
object and bind this to that object
before can call that method which gives
you the overhead of allocating on every
single arithmetic operation which is
just painfully slow in strict mode
that's not the case but it's we didn't
want to use strict mode to them to make
this really didn't want to rely on
strict mode for making our stuff work
and be efficient so our solution is
actually to to figure out when we can
use JavaScript plus when it's safe to
use it when it has to write semantics
for us and we do that by tracking types
in the compiler so if we know something
about the operands if we know you're
operating on on numbers it's safe to use
a javascript plus for that the other big
thing is the range checking so Java has
no notion of out of bounds axis and all
all keys are essentially treated as
strings I'm not sure that all people
that actually work with java sins are
sort of amaris they're actually working
in the language that allows them to well
that actually doesn't really help them
in defining a race of a certain size and
checking that you're excellent stuff
within that so in dart we've decided to
to fix this problem that javis passive
sort of keep keep on truckin mentality
that just anything goes and we'll just
deal with it later by inserting these
explicit index checks unless we can
prove that we don't need them so that
means that whenever you access an
element of an array in dart code in the
java code stranded from that you will
see explicit checks that you're within
the range of that which is something
like comparing against zero and the
links and and stuff I'll show you that
code in a moment so here's a nice piece
of start code that then will allow me to
to tell you about these optimizations
here so can everybody see this code at
the back to otherwise you have to come
closer so this is again dart code as a
main method it creates a list there's a
some variable and just run through the
elements of the officer list from zero
to the two it almost up to the lengths
and just add them together and print the
result fairly simple code when we can
publish to JavaScript code it's not a
one-to-one translation anymore so you
can probably recognize some things in
there and the
is unchanged the for-loop looks a bit
bigger but the biggest thing is really
that before accessing the the list
elements we actually insert an explicit
check which is the if I less than zero
or I greater than the length of the list
greater than equal throw this index out
of range exception that's the way the
Pooh reference i order when we've done
that check it's perfectly safe to access
the list as a list as a JavaScript array
actually which makes it reasonably fast
but it's kind of annoying that we have
to insert this check just because javis
wasn't do that for us but to preserve
the right dark semantics we've decided
to do that the other big thing here is
that whenever you're adding things
together to be able to use Java with
plus you have to make sure that the
stuff you're operating on is actually
numbers so we actually check that stuff
we read from from the list is a number
before we operate on it if it's not a
number we will actually throw an illegal
occupant exception instead and you can
see we've done a some amount of
shortening the code here by using
shoulder names just too well for one
thing make it fit on the slide and the
other thing is of course that people
care about code size so if we insert
these checks everywhere in their code
and we have to make sure that then it
doesn't take up too much space either
one thing I probably should mention here
is that we actually never enough to
realize that the list that length
doesn't change in this loop so we hoist
that out of the loop and read it before
entering the loop only once and actually
if i were to recompile this today the
the length check would actually go away
because we've implemented some array
bounds check elimination because in this
case it's simple enough that we actually
know where within bounds so this is
actually kind of wrong to show you guys
but it's just nice to show you what that
you might see stuff like this in your
code if you compile and look at the
output another thing that is fairly
common and dart is to write classes and
so we see a lot of people in JavaScript
using something that resembles classes
by by having these patterns that they
use for setting up
constructor function and adding a bunch
of methods to the prototype off it and
they have different patterns and some
framework support different patterns and
and and it's certainly the case that
even when programming in JavaScript
there's a lot of sort of ad hoc class
definitions floating around in dart it's
even more so people write a lot of
classes and that means that you have a
lot of the Bible boilerplate and for
creating instances of class and
accessing the fields of classes that you
need to figure out how to and have to
produce so we've decided to go for an
like using a simple helper function for
setting up the system and just generate
most of this boilerplate dynamically at
runtime using the fact that javis there
is a dynamic platform that can actually
you can inject and generate new code
into at runtime so it looks like this
the the point is I showed you before and
well I used before we actually compile
something of this this is JavaScript
code it looks a bit foreign it has it
has a assignment to a point property on
the on the ice to the object and it has
it has a method and it has a super class
definition so we hack it all into one
object literal and which is fairly
compact the empty string up there
denotes the the fields that we have so
we say that all points have an X on a
wire field no we're here do we have to
write the actual constructor function
for the point because that is actually
computed at runtime from this list of
field definitions and the super class
definition that is object the methods
however are just put in here like
ordinary properties on this object so
the distance to method with the dollar
one arity encoding stuff and looks more
or less like the joust function you
would expect but the stuff around it is
actually a compact way of introducing
classes so we take this list of fields
like X comma Y and we we turn it into
code like function point X comma Y this
statics assignment all that stuff all
that boilerplate we generate that for
you at runtime of course you only have
to do this once with the point class
once it's in play you don't have to do
any
more but it means that you the code you
transfer to your clients is smaller and
it only sort of expands in size when
it's actually in a run on the on the
client side so we get these helpers
generated for us by the system we
actually also allow you to have feels
lists that have some slightly more
advanced annotations so you can have a
question mark or an assignment and thing
in the in the field name and just that's
just our way of figure out if you need
to introduce a setter or get our
combination of the two for those fields
so this is just a compact way of doing
it nice thing is if you look at the
JavaScript output that we generate it
looks like we preserve the class
structure pretty well so I hope you're
all familiar with closures in java at
least and so in in dart we do have
closure support so you can have these
function expressions floating around
that takes arguments and produces values
and our closure is actually support name
documents and they also have to be
checked in the sense that if you pass
too many arguments to them or to view we
want to catch that so um initially we
wanted to try to compile a dart closure
to a Java so closer it turns out that
it's kind of painful because the
JavaScript oh sure is something you can
just invoke and it has no notion of
checking how many arguments you pass it
at least no cheap way of doing it and it
just somehow it is hard to figure out a
way of making this fit really nicely
together so at some point we realized
that allocating small Java object it's
actually very cheap it's a faster than
allocating closures and in many cases at
least on certain VMs and we found that
even with the up to like six or seven
fields you can create an object of
simple Java object in the same amount of
time as you can create an insane amount
of space as you can create a closure so
we talked about actually just using
objects for representing the the
the dark closures so we actually
implemented this and it turned out so
nice that this is what we kept in the
system so we treat closures as instances
of closure classes so essentially in our
model a closure is just some object that
has support for being invoked it has
these call methods and we use instance
fields in these and these closure
classes to represent the variables that
you capture from your scope and we use
methods on these closure classes to
implement the calling conventions that
we need this is a bit abstract I'll just
show you here's the art code there's a
list and I run through the list and for
every element in the list and I will get
the index and this is actually kind of
weird code but anyway what you have in
the middle of it here is actually a
closure that takes a parameter each and
produces the result of calling list that
index off with that each thing and at
the end we print everything so this is
very short concise syntax for for doing
maps map operations on on a list and
what we compile it to is actually this
at the bottom you can see this closure
class it's it's a class like any other
it's like the point thing I showed you
before it has a single instance field
called list and and it has a method
called call dollar one which is what we
need to the action we need to invoke
when we're invoking this closure with
one argument so in there you actually
see the code for the closure at the
youth site where we allocate a new new
closure and pass it to the map operation
what you what you have there is actually
a standard allocation called to create a
new new closure so it's it's fairly
simple that way the the biggest downside
is that it really rips apart the the
body of the of the closure and puts it
in a different place in the code so
essentially this is splitting it out and
two different pops and the output is
sometimes a bit harder when you have two
deep up because you end up jumping
between different places but it's very
nice for for compiling and having a
unified model of how we deal with
roaches and classes
so one thing that it's probably worth
mentioning here is that it might be a
small details of some but it's actually
kind of important that at the return
dollar index off we're not calling index
off on the list we're actually pass into
this is the first document and this is a
general thing and in our system we've
decided not to it do what people usually
refer to as monkey patching of the of
the core classes so numbers arrays and
and strings of JavaScript we're not
adding a ton of new functionality on
them we actually prefer to keep that on
the side in this ice to the object and
we just invoke this I synoptic with this
is the first parameter instead because
then you don't have to actually add
things to these things again this is a
way of trying to avoid a clashing and
name clashes in these these common
objects so I showed your love code
already and now I want to tell you a bit
about how we actually go about
generating this code so and as I said
the dark compiler is kind of
sophisticated beasts and it's a fairly
classic compiler except for the tree
shaking perhaps and it starts with
building syntax trees for the dart dart
code syntax trees are a very simple
representation of off your source code
and it could look something like this
for a for a simple plus expression I
have a plus note and you have two and a
three and out hanging below it so we go
through a stage that we call the SS a
graph building that actually construct
an intermediate representation based on
an essay form if this a form it's
probably not familiar to all of you so
I'll just give you a brief sort of heads
up on what that is so the essay form is
static single assignment form so it's a
it's a classic compiler intermedia
representation form that people views
over the last maybe 20 years to with
with good results for for dealing with
the dataflow analysis part of the of the
compiler so what we actually translate a
syntax tree like the one above to a
flattened out representation that just
have essentially instructions on what
the the
the resulting code needs to do and just
lined out in a sequence so we have a
constant to constantly and then a call
that asks these two things together so
this is a set of a kind of a high level
intermediate representation that we use
and the nice thing is that it allows is
for certain optimizations that I'll
cover later once we built this thing we
run through a code generator and we end
up with a syntax tree that represents
the JavaScript code instead that can
then be pretty printed and animated and
that's what you see so the the
intermediate representation that we have
four for the SS a form is it's a it's a
graph of basic blocks essentially if you
take the code on the on the left it has
and if with an else in there so it has
two different branches that are possible
and as some some its emerging it
actually compiles to something that
looks more or less like what I have on
the right there it has four basically
blocks there's the the entry one that
everything goes through and at some
point inside that basic blog there's a
there's a split either you go to the
left or you go to the right depending on
the value of of x and y so the basic
block on the left will will call print
of X and the basic block on the on the
right will call print of Y and and then
they will they will join forces again at
the at the return side and will end up
returning either X or Y depending on if
we executed b1 or b2 so the trick with
static single assignment form is that
you end up having these calling Phi
notes in the graph there are nodes that
are serving explicitly merging two
possible values from two different
points in the code the static single
assignment properties that every is that
every single value producing this thing
is only produced in one place so so for
instance when you and when you go to be
three we have to figure out if the
return value that we need to produce is
from T 0 or T 1 and the this is a
classic optimization for
and it allows us to do optimizations on
it and and of course the tricky part is
here is finding a nice way of going from
this rather abstract form back into
JavaScript that looks reasonable when we
optimize it's often very important for
us to have a notion of dominated tree
where a dominant tree is really and it's
a it's a tree of the basic blocks that
you have in the graph where you know
something about and which blocks are
always guaranteed to be executed before
of the blocks so in this case you're not
guaranteed that b1 is executed before be
three you're not guaranteed that be to
is executed before be three but you know
for all the blocks up there that are not
be 0 that be 0 will have been executed
and run to completion before you start
running but b1 b2 or b3 this actually
allows you to start propagating
information that you find in b 0 to the
nodes in b1 b2 and b3 so we use a lot of
dominant treat reversals in the
optimizing phase of the compiler so the
kind of temptation that we do is is
listed here that we do a lot of tag
propagation so we will will know that in
that we can generate much better code if
we know something about the types of the
operands involved so we propagate types
through this this this essay form and
that gives us a lot of information that
helps us up to mice we also do a lot of
function inlining and when we know
enough about the message that we we are
calling we can actually in line the
bodies of them at the at the call sign
which make certain things a much faster
another optimization we do is global
value numbering which I'll cover in more
detail and but i already showed you a
loop invariant code motion face that
move this length accessor from the from
the from the list axis outside the loop
so these are all classical optimizations
it's not something we've invented for
for dr j s but we've we've just made
sure that the compiler has enough
structure to support these kind of
optimizations so i want to give you a
feel for what kind of compilation tricks
we play here so i want to spend some
time on on one of the optimizations
global value numbering so global value
numbering is a way of
of essentially replacing instructions
with other instructions when we know
they're going to do the same thing so
getting rid of of common sub-expressions
is another way of formulating it so for
global value numbering we say the two
instructions are the same if they
perform the same operation on the same
inputs so clearly sometimes the
executing an instruction can have side
effects that may affect other
instructions but in general if you
already computed the value and you
haven't been affected by any side
effects going forward you don't have to
recompute that value that's essentially
global value numbering so here's a
simple example of that here's a small
dark method called wet that produces the
result of adding 1 to X and and
something that with adding 1 to X
there's some refactoring that should be
should have been done on that code level
already then and but if you haven't done
that you again you get an essay form
that looks something like this there are
no branch there so it's very simple you
have t0 which is the x perimeter you
have t1 which is a constant one and then
you you add them together with a call
that adds t1 and T t0 and t1 use the
value and then you more let's do the
same thing afterwards as you can say see
here and we have different calls to plus
we have three different calls the plus
and we've nice to cut that down a bit so
global value numbering will actually
runs through this code and figure out
that the the constant one at the
introduce that t3 is actually something
we've seen before so we can get rid of
that and replace that so at this point
my point was that the t3 one we can get
rid of and we can replace and we can
replace the use of t3 with a t1 and in
the in the call to plus there so that
means that the t3 goes away completely
that was the point so that allows us
actually to keep pushing on this and
reuse the fact that t4 and t2 are now
the same they do the same operation on
the same input so you can replace one
with the other and we end up having a
simpler graph that looks like
this where you're doing less
computations and at the end we can
generate code that looks something like
this instead this is very simple stuff
it just shows you how you run through
the graph runs through the code and
realize certain things are the same they
are equal and you just get rid of the
redundant version of it so the the
algorithm used to actually implement
this thing is is it's pretty simple at
the high level you just walk the
Dominator tree and you keep a set of
live values values that you've already
computed and and if you find an
instruction and you already have a live
value in your set you just pick that
live value instead and replace the
current instruction with that live one
instead and and of course you you
register these instructions in the set
as you go and the the biggest thing is
that you need to make sure that if you
see something that has a side effect
that could affect something in this set
of values you need to remove that from
this from this set so it's really just a
walk through that the Dominator tree
where you keep track of which values are
already computed and can be reused so
the control flow graph associated with
the Dominator tree like this it's still
necessary when you do these operations
because when you walk the Dominator tree
and you may have to kill and you may
have to get rid of live value computed
for one branch based information in in
the control photograph so the example
here is that if you get to the b2 and
basic block you a you actually have to
to let that perhaps effect and the live
value set for for the analysis b3
because b 3 can be reached through be to
in the control flow so it's kind of
complicated but the net result is that
we generate smaller code and more
efficient code one of the biggest things
that we still have problems with is that
we have we have a lack of knowledge in
the in the generated output and so even
when we probably had a tons of types in
the system and we still have this
problem that the code that we can
generate we when we have no type
information is
lot worse than the code will be
generally we have it so sometimes we
feel like we can actually make a pretty
good guess like if you're using
something like a list maybe we should
just treated as a list if you're using
something like a number if you're adding
them together for instance maybe we
could just treat them as numbers the
only problem is that we could be wrong
so we try to guess based on inputs and
and and how how things are used if they
are for instance numbers but when we're
doing what we call speculative
optimizations we have to be aware that
we're just guessing and we're not quite
sure if we're right so let me show you
how that looks if you have code like
this then runs through an array uses the
X at length property adds up everything
in that and it would be really nice if
we could optimize the access of the
array elements of FX and make use of the
fast primitives for that the problem is
we don't know if X is an array it could
be a string it could be something weird
we just don't know what it is and but
the compiler we we we have slightly
allows us to speculate and say it would
be fantastic with extra edge over a at
this point so why don't we just try to
compile it as if it was so we end up
generating code like this the first
thing that we do is we checked if X is a
javis of the rain if it's not with you
or that but if it is a jealous of the
array which is the case from the first
line down essentially we can just go
ahead and do all the operations on that
javis beret knowing that it is a jealous
of the ray and we can access the lengths
and we can access the the array elements
in a really fast way we still have to
check that the things we read from it is
our numbers and we have to check that
we're within bounds but it's still much
better than having to call arbitrary
methods at this point the problem is
this this first line that checks if if X
is a joust array it would be kind of
neat if we just throw an exception there
and say it looked like you were using
this as a JavaScript array and it really
isn't so maybe this is a bug in your
code the problem is that well actually
not a problem it's a feature the nice
thing is that people can write their
dart code and have optics that behave
just like the building lists
and and that needs to work too so we
have to generate a version of this some
method that works without the assumption
that X is a job so great so what we
generate is actually this a separate
method called the bailout version which
has some state that we use to actually
enter the method in different places if
that's necessary and it has the the
environment the live variables that we
need to transfer from one to the other
in this case it's just X and here you
have the slow case version of the code
which is what we would have been forced
to generate if we didn't if you didn't
have the speculate speculative
optimizations in play so what you see
here is many more method calls to
message that try to compare if things
are less than you try to get the lengths
by calling an accessor you try to index
into something by calling the index
operator or lat the end except for in
the index method so this is just much
lower so we'd much prefer running in the
in the optimized version of it so we
have to put this in to have proper dart
semantics but we believe that that we
will never use this method so we really
have to try to cut down the dispenser
temptations in the system so otherwise
we would generate too much code that we
will never need and it's really hard to
strike the right balance between
optimizing too much and too little we
don't have enough information at this
point it's a static static analysis
thing that we think this might be used
in one way or the other so right now
we've cut it down to a point where we're
only speculating about about types for
values that are used from within loops
where we can actually move certain
checks outside the loop as a consequence
so if the speculative tomers a shin is
we can show that it's it's good enough
to actually move things out of loops
will do it otherwise we will try to not
do it we have some ideas on how to
actually improve that a bit so what if
we actually just went ahead and
generated speculative optimizations
about all the types that we would want
to optimize based on and then took that
resulting to big code though but but
just like put that out there and ran
through it and profiled it and that
would actually give us some insight into
how the program is being used
then it will allow us to actually look
at which of these bailout methods are
actually being called it will also allow
us to look at which of the optimized
message that are being being called and
which ones are hot so one neat way of
doing this would actually be 22
speculatively optimize everything and
then recompile with less speculation
where you only allow speculative
limitations in methods that were
actually they're actually hot and in
their optimized version so it's
something we have implemented yet
because the toolchain around having a
profile gadelle optimization step is
kind of complicated for our users so and
but it seems promising in in the way of
getting more information about what the
program actually does at runtime so one
thing I want to say about dealing with
control so in the code yeah we we then
we would generate this as is a form and
it's kind of hard for us to and to take
that form and compile it you too
nice-looking JavaScript the example I've
shown you hopefully don't look too
foreign and but it's actually kind of
hard to translate a generic graph that
has arbitrary jumps between basic blocks
to something that looks like javascript
so what we've done is actually we've
tried to keep the code structure from
dart in the SSA form we built not mess
too much with it and just compile that
to the the same corresponding JavaScript
control flow statements it's not the the
ideal solution right perhaps and but it
actually works pretty well and it's just
there are certain optimizations on the
control field that we cannot do that way
but it works fine for data flow so just
to give you a feel for what that looks
like the kind of place where we have
problems with this is is where we have
to introduce checks in places where the
JavaScript syntax only allows
expressions essentially so in this case
you have an index check that you want to
inject in the condition of a for loop
it's kind of hard to do in an efficient
way so what we end up compound this too
is something where we cannot compile the
for loop to a for loop we compile it to
a while loop
with some breaks in there to try to
escape that boundary this is not as
pretty it it's baker code it solves the
problem in this case and but in general
being able to compile a for loop to a
for loop and a while loop to a while it
was it's just nicer so hopefully this
gave you some insight into how the
compiler is written and what can
optimize asians it does and what we
focused on mainly is in addition to
runtime performance and correctness it's
into really Victor code site that has
improved the most since our first
release and what we're seeing right now
is that small examples and actually do
compiles with small piece of JavaScript
output and so it's not the case anymore
that you will get megabytes of
JavaScript admitted for for a small
hello world example and one thing that
we sometimes do see though is that
people write an application that depends
on a lot of libraries that it pulls in
through imports so if your application
translates to like sizable chunks of
JavaScript it might be because you're
importing and using a lot of code of
transitively we still have more work to
do in this area and will continue to
push on this but it's getting a much
better and it's kind of nice now and one
thing that we haven't implemented fully
yet is support for generating minified
output which is very common in the
JavaScript world where you get this
slightly up you skated and minified
version of your javis of the output
that's a very well designed for trans
transmitting across the wire it
essentially just a rewrite face that
cuts down on the on the use identifies
in your code and makes them as small and
short as possible so you can already use
that and experiment with in now through
the minify option but you should expect
it to begin beginning a lot better over
the next weeks and months so I don't
know if this is actually something you
can see at the back here this is a this
is a slide that shows you our internal
performance tracking site so this is a
subset of the benchmark that we run and
just want to show that we we do care
about performance and we track them
track it every day if you really want to
make it system fast we
to measure performance in every check in
essentially and and we do that we
measure ourselves against v8 because we
have a lot of familiarity with the code
it generates and so what you see here is
actually on the on the very right you
see for all the benchmarks that I've
listed here you see how fast we are
compared to v8 so the the last column
the very right column is start to jas so
that is how fast are we or how fast is
the generator Java code that we emit
compared to just handwritten JavaScript
code and we still have some work to do
we are around seventy eight percent of
the performance of pure JavaScript code
but you have to pay it or keep in mind
that this it actually includes all the
extra checks that we put in there that
might help you catch your your box
before they go to production so we are
generating code that is not as efficient
as native handwritten JavaScript in all
cases yet but we're improving a lot you
can also see that that the native dart
VM which is the second last column here
is actually doing better than v8 already
and something we will keep on pushing on
and but it's nice to see that because of
the semantic start it's a simpler
language to implement efficiently we're
already now even before the first it's a
real dark believes we're already twenty
percent faster than and v8 and we
certainly expect to it to improve that
number going forward so expect more on
the performance front always so
conclusions are very simple you should
write your web apps and dardan you
should be compiling to JavaScript if you
need a compatibility story with with the
modern browsers and you can be more
productive if you have a good tool chain
and goes from editing and a good
compiler to generate these things for
you and you can let us worry about some
of the low lead optimization so you
don't have to argue with your co-workers
about all these low-level tricks and
things you need to to worry about in
JavaScript so last thing is that we
really want to keep improving the web
platform we really believe that the web
is in
need for better support for programming
in the large and in particular on mobile
we see that application startup for big
web apps is still a problem something we
certainly want to solve and we want to
give you more predictable and better
runtime performance and as you already
seen we're getting very close down the
dart2js front with native JavaScript
performance and on the vm front it's
it's already better so that was all I
had so I'm very very open to any kind of
questions you guys may have about the
technology or or dark okay so the first
question is about debugging and using
javascript libraries so am debugging
first so are our debugging story is
really that when you're running with the
dart VM it's fairly simple you have a
debugger API for the vm and you can use
that as is as if you were running in any
other native vm solution for the
generate javascript code what we produce
is a source map on the side that tells
the developer tools that you're hooking
it up to where and essentially gives you
a mapping from the generator output back
into your source code so you can do like
single stepping through your source code
even though you're running the
JavaScript code so we're getting a lot
of help from the fact that others have
already generated this source mapping
format so we use that the the second
part of the question was around
JavaScript integration and an
interoperability with existing
JavaScript libraries it's a really hard
problem and and it's something that
we've talked a lot about the different
approaches to and and the biggest
problem we have is really that we want
something that runs well on the native
dart VM and on the translated version
that translates to JavaScript so we want
a solution where you can take a piece of
Java code and interact with it in the
same way no matter if you end up running
on the dart VM or if you're in a
translated version so what we come up
with so far is a sort of limited way of
synchronously calling essentially
external functions external jobs and
then doing some civilization across the
boundary between these the JavaScript
world and the dark world so it does mean
that essentially doing this integration
is a bit more cumbersome and just
calling java spunctional--
stuff back but we have to do some
checking on them on the boundary to make
sure that the two worlds are in a
consistent format and you don't get a
lot of pointers to roll native Java stop
texts of embedded in all your data
objects so it's it's doable it's a it's
getting easier and easier but it's still
something where it takes a my some
amount of work to integrate with that an
external library one thing that I always
like to ask us what kind of libraries
would you like to integrate with because
usually there's like a bunch of very
very important Java libraries that
people really would like to see like
jQuery and mobile jquery and whatnot but
the list is very short so and if you
have something that you would like to c
integrated they would like to know about
it and so the question is given that we
ask google control of v8 have we have
given in to the temptation of adding
stuff to v8 that will allow us to
generate better JavaScript and fat and
run it faster on v8 yeah so far we we
haven't added anything to to v8 as a
result of our dark stuff except for some
missing optimizations that we found for
instance v8 was not particularly good at
dealing with unsigned 32-bit values and
it only dealt with 31 pits and we had
some benchmarks but really really
mattered so there is some feedback
coming from the dark team to the v8 team
on particular things that are not
performing as well and in v8 as some may
be other java engine so they're up to
optimization opportunities but we really
only want to put stuff in v8 that
generally makes sense for JavaScript
programs so our our style here is really
to try to generate Java code that runs
well on all the modern browsers and it
doesn't really buy as much to make that
run ten percent faster and v8 alone and
so so far it hasn't been something that
has made sense to us I understand it's I
mean you could be tempted to do it but
we wouldn't win anything by doing it
essentially and and to be honest the the
places where we have we ate is also are
also the places where we are more likely
to have the dart VM so I don't think it
actually is a terrible good idea and
except for finding bottlenecks and
existing performance things that can be
fixed
and so the question is that we consider
adding a flag for enforcing stricter
typing to be able to generate better
code and so we actually haven't
considered that at all because we really
feel like dart is a dynamic platform and
it we really wanted to be used as a
dynamic platform so this this notion
that you don't have to write types
everywhere to get a correct and
efficient program out it's very
important to us so no that hasn't really
come up as something that we wanted to
do and some people have asked us if we
wanted to maybe trust type annotations
when they're there to generate code just
based on the type of notation just
assume that they're correct so far we
haven't done it and clearly in some
cases that would allow programmers to
express to us that certain things are
probably likely to be number so or
whatnot but we haven't really taken that
that step mostly because as it is right
now we kind of like to have that extra
pressure put on us to deliver high
performance without changing the meaning
of the static type annotations that
people have put in we really want to
keep that sa as a documentation of
intent from the program are not some
low-level optimization trick so the
question is have any other browser
vendors shown any interest in
implementing a dart VM and I actually
don't know if anyone has shown I don't
think we've seen any public support for
the dart VM across other browsers I
think it's still very early and the dart
VM is maturing as you can see the
performance is getting there and there's
still a lot of headroom we can do much
better I think it's on our table to try
to demonstrate how how how much that
affects what you can build on the web
when it comes to application startup and
peak performance and once we have that I
think that it's very first for us it's
very hard to control what will happen
from that point forward and but we of
course we hope that people will find
that technology to be so compelling and
interesting that they want to use it too
so the question is if when we switch
isolates you're just assigning to this
this the dollar variable and and if
there's any code sharing behind the
scenes between different eye slits so
right now there is actually two
different versions of creating an eye
slit either you're running your spawning
another eyes that based on your own
source code in which case we do the code
sharing
and but your is also possible to spawn
and I slit from a URI where you don't
know what your spawning in which case we
we don't actually try to do any code
sharing so it's actually up to the
program to request one or the other and
and clearly if you're spawning based on
your own source code it makes perfect
sense to do more code sharing and there
are no weird version in conflicts that
can arise because you know you're
guaranteed to be running the same source
code so that's a nice place to be and
that's the place where people usually
end up being when they just want to use
isolates for coming up their application
in more bits and pieces but also either
getting some of the security benefits or
it just leaked encouraged a bit its
benefits of having so actually what we
do is we have a nice little object which
is actually created through a JavaScript
function that has tons of properties so
we just use the same constructor for
creating the next one so essentially
it's a JavaScript object that has it
looks more or less like you have a Java
class as well just instantiate once for
every I slid so it's fairly lightweight
that way and and the idea is that we
want to allow people to either run them
as web workers or not depending on what
they really need sometimes if they have
a need for Dom access from multiple eye
slits and the only thing you really gain
from from having multiplies is this
coming up your application in multiple
pieces and and you also gain the an
extra global namespace essentially so
for all the static state you get a new
copy of all that all the static
variables are just split that way which
is good for some things I think we have
time for one more question but I think
we're running out of time yeah one more
question so the question is do we have
libraries for accessing the Dom API ice
and then databases and and things like
that so clearly these things are being
built as we speak on the server side
there are many different database that
you can access and we have some
interface for some of them built by
people in the dark community on the when
embedded into the browser we have the
full range of dom and and HTML api is
available to us and we do have access to
them through the dart colon HTML library
which is just a simple way for you to
write code that accesses the dom through
dard so yeah there's full support for
that so
that goes for all the index DBS and all
those things that are in the browser so
we are trying to limit your access to
the Dom based ap is we just want want to
give them a a new saner language to it
to write in that and still be able to
use the Browse technology so we're
running out of time thanks a lot for
spending time with me today and they
hope to see more of you in here for the
for the remaining talks in a Java
subtract
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>