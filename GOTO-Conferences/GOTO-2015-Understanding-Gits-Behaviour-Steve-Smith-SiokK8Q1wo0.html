<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Understanding Git's Behaviour • Steve Smith | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Understanding Git's Behaviour • Steve Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Understanding Git's Behaviour • Steve Smith</b></h2><h5 class="post__date">2015-12-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SiokK8Q1wo0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so they give a bit background to this
this is something you're gonna hear a
lot you probably have heard it's just
the directed acyclic graph and this was
saying I was brought up let's get merged
in Paris earlier this year and merging
Hogben and Westby is an educator she
teaches people about how to use gear not
people who are nerds people just trying
to get there through the day and get the
job done and telling them it's an
acyclic graph is bugger-all use for
anything what you really need to do is
say okay this is how you get your job
done task oriented let them sort of work
through themselves okay I want to do
this let's try and use gates to get the
job done but the reality of the
situation is that this is not always
going to get you through the hard times
the reality is that it is an acyclic
graph or it's a set of all objects I'm
never not going to use acyclic graph
again because it's never made any bloody
sense to me
bugger all use for teaching get but when
you hit these Hut these tricky times
you've got multiple merges going on
you've got rebase is you got forst's
pushes all these things happen things
happening understanding what's happening
underneath the hood is very very
important
without this internal mental model of
how git works it's going to become
confusing because gets abstractions or
very leaky they you tented to discover
how it works whether you like it or not
it's one of those things like driving a
car you know you don't have to know how
an engine works to drive a car but if
you know how an engine works you'll be
be a better driver or at least be a
little bit easier on on the car so this
is one of those cases where a little bit
of knowledge can go a long way so to
follow up on that well let's just jump
straight in we're going to take you
through the basics of get from the
absolute bottom layer and all all the
way up to some of the higher-level
concepts it is quite well layered in
that's
his idea concepts built on concepts
built on concepts when we go right at
the bottom it's very very simple indeed
so at its core the basic of the basic
building block of get is the blob
now blobs can be different types of
things but that's ultimately what it is
you dealing with gears you're ultimately
shuffling blobs around and linking up
together and what do I mean by blobs
well it's this what you're looking at
now is the entirety of the low-level get
data model this is it it's that seems
simple simple of course being this
extremely deceptive so what you have
here is three types of blobs one is
content that is raw data that is a file
you've committed an image you've
committed just raw data files and they
are hashed you what do what what kit
does it takes them it compresses them
using Zed lip puts a header on them
hashes the results and then from that
point on that piece of content of the
file will always have the same hash now
this applies to any changes of well if
you change a file and you add it to get
it's a different hash therefore is a
different object and this is how it
tracks it oh over time
every change is it is different this
what they mean by content addressable
filesystem when you hear that phrase
every piece of change every change is a
unique hash in there but objects by
themselves inaudible use you need to
kind of tie them together the next level
up is the tree the tree is also a blob
it says how close for the same process
it's hashed it's it's dead lived it's
compressed is hashed and then it's
dropped in it in in a directory a tree
is very much like the UNIX level file
system really any file system it's just
a file that lists a bunch of files by
their hashes their file names some
metadata like their the file mode where
it's executable readable writable etc
and it'll may also point other trees
so directories contain kind
saying other directories trees can
contain links to other trees they may
also link to other trees eventually to a
file at the higher level than that is
the commit
this is what you're used to dealing with
and get you don't have to you can
actually operate at a much lower level
than that if you'll pair to go through
that process but the commit is the
general unit you're you're working at
it's how we think about either history
get commits pointer trees the point of
files and commits can point to other
commits they could have parents and
importantly they could have more than
one parent but this is all theory let's
have a look at the actual practice this
is like how you can muck around by
yourself on your computer so people see
this No can we possibly turn off these
the flood lights yeah here you go so
getting it creates as you probably know
creates a new gift repository we and
insight that is all it is is a docket
directory and inside there was all the
metadata the gifts contains and its
complete as you probably know
so let's look inside the get objects
here there's nothing in there it's an
it's a new repository it's an it's empty
so there's nothing to attract let's add
some something touch it's just a units
command the crew will update the
modified time or creates a file so we're
just creating a purely empty file here
and we do get add as you probably know
that doesn't actually create a commit it
doesn't give it history it just says I
want you to be aware of this file from
now on this is something I want you to
track I'll tell you when it is when it's
changed so let's go back and look at
that again the tree command by the way
is you say this will just outputs a
pretty printed version of the directory
structure so as you can see here it
creates a blob this is it this is the
this is your basic unit that empty file
has been added it's been compressed
which in an empty file makes it actually
larger and then adds a header onto it
and then put it in rectory
you may notice it's also that East six
at the start what
does is it spread the load you're gonna
be creating tens of thousands of these
over the course of a project to spread
them out rather than dumping in one
directory it uses the initial two digits
to kind of spread them out across
different subdirectories ins stop
overloading the inodes this is one of
samples is written by Lin us talk to
evolve in the original prototype and
it's he's a file system operating
systems guy so he's thinking about you
know how to spread the load but this is
it that you've added a file and now
there's an object in in the tree so
that's pretty much it
now obviously just track just dumping
objects in there with no real way of
tying them together it's pretty much
useless so we're just going to create a
commit very simple very simple and this
is it
that's the blob the original mommy looks
at this is the tree this is the as a
single entry in that tree that points to
that blob and we have the commit which
points to the the tree so that is pretty
much the anatomy of a a commit now
interesting thing I should probably
mention here this blob which contains an
empty file has a hash that hash in any
empty file in any repository anywhere in
the world is always going to have that
same hash that's what we're talking
about by a content-addressable file
system what the file contains defines
what its identity is but so this is what
we already got but this is not a lot
used by itself either we want to change
so it's a version control system want to
add new versions to our project over
time so this is what we do each commit
can point to a previous commit it has a
parent commit it can actually have more
than one parent parent a concept we'll
come back to in a bit but this is how
you chain them together each commit
points to optionally one or more
previous commits and that is how you
define time you start off at the end
your project and you can walk backwards
right to the beginning possibly via
going via branches different little
different sized tracks but ultimately
that is get its core right there
very very simple ideas what this
actually means for you and how you can
use this will come to in a little bit
will just show you a little bit a few
more little key points one here is let's
create an actual commit for our dummy
repository so we created the edits and
weeks notice we have an entirely new
blob it's what I'm talking about every
edition of a change to a file creates a
new blob every file change you take in
an image you put it into get you've
changed one pixel and it is a completely
new file now that can be quite wasteful
and there are it does use some tricks
under the hood to remove that or
optimize this a bit more but you don't
need to worry about it too much
git is has this idea that we're not
going to try and Delta encode everything
upfront we're going to always try and
store the true state of things because
Delta encoding what can improve over
time but the your files will all should
always remain the same so that is the
lowest level of get but once again all
we've talked about so far is hashes
everything is a hash and that's not a
lot of using data they use you want to
talk about master you want to talk about
my feature branch you want to talk about
this particular version of a release how
git does that is a slightly higher level
concept called refs and on top of this
it builds branches and tags which you're
probably familiar with tags not used
quite as much ref branches quite a lot
refs are generally not used themselves
they're a low-level concept so what is a
ref a ref is a pointer to an object and
that's it it is a way of saying
attaching a name to an object to a hash
the entirety of it very much like a
variable and I say the J jvm
there is a an adroit it has an address
in memory you don't need to worry about
the address in memory because you've
given it a name and you use that name
from that point on so what is a branch
well a branch is just a a ref painting
to a divergence from the main tree so a
object has a pair of commits as a parent
but it doesn't happen they don't all
miss we have the same parent so I can
say well at this point this commit I'm
going to go off on my own branch of
control and we just give that object the
parents of that point we want to diverge
from and then we can just add a ref
which we'll call a branch from now on
and that will be the we'll use that to
track our branch that's pretty much it
this is where branching and and tagging
and all these things are very very fast
in get because they are nothing water
moving around a couple of little
pointers in files will actually show you
what it actually looks like in a bit and
what is a tag you probably use tags I'm
probably most commonly used for releases
to say this point is you want to go back
and find this version of release check
out this tag and it will you'll get back
to that point in time and again it's
really very simple the only real
difference with a branch in the tag is
the tags by convention don't change
branch branches do ahrefs they move
forward in time tanks
remain static over time you can sign
tags if you want it to be super accurate
or super secure but generally speaking
and we just trust people to knock knock
around mateo tag there's no reason why
you couldn't go into a git repository
and overwrite a tag but you're just not
going to make any friends doing that so
let's look at this again in practical
terms we're going to have a look inside
our git repository our simple get
repository here so the first command I'm
doing up here is I'm going to create a
tag called a tag and we're going to give
it a name when it can cook a message to
go with it which is a normal way of
doing things that's slightly different
skipping over something here a little
bit but at its heart it's still
basically the same idea it's just a
point in time what a tag does with a
message will actually create a mini
commit object but you don't have to add
a message so you can create a bear tag
that can do is literally just a pointer
to an object a branch is definitely just
a pointer to an object and if we do a
the tree this little useful tree command
on the get refs subtree you can see we
have we've created a bunch of files
we're creating a bra a file called a
branch and we call created a file under
tags called a tag and if I cat that file
can't just blast it out just dumps it
out onto the screen what the contents of
that file is that is it that is the
entirety of what a ref is is just a
pointer to a hash this again is why
branching is so fast under get it is
literally writing orphans I think it's
128 letters to a whatever the number
letters that that is it's writing it to
a file so it happens pretty much
instantaneously so that's basically the
next level up and we're talking about
how we manipulate this on a day to day
basis how many how many people here have
used reset in gates yeah how many people
screwed it up and blew away chunk of the
ripple yeah it's basically a rite of
passage I'm going to show you how to get
out of that situation reset hard it's
great awesome this is what reset is
reset moves rifts around now you can
literally do this if you're yourself if
you wanted to by just going into that
get refs directory and over writing that
files but have you dig around funny
whether an alternative hashes and just
shove it in there so there's always
reset is doing now I am glossing over
something there dude reset has different
modes and it will also modify something
like your staging area and your your
working tree and hard is particularly
aggressive it will blow away any changes
that you have uncommitted things like
that but at its core again it will just
shift the rep the
ref now so at this point as you can see
it doesn't it doesn't actually destroy
any data that's actually inside your
repository it just kinds it you have to
know the magic hash to get back there so
I've reset it I've reset I've screwed up
how do I get back to that state well I
don't know I have no idea what the the
previous hash Wars I'll have to go
digging around the repository with
possibly tens of thousands of objects it
need to find out which one was my magic
object from the past or we could use ref
log every time you modify via gate not
why I'm a minute directly manipulating
files or anything but every time you do
or do a reset or other manipulation of
references get keeps a record of it in a
history file that's called the ref log
so if you screw up anything you do a
rebase you do a rate reset and you saw I
want to get back to that previous state
that state of was honor and undo this is
it if I look through here it's mildly
commented you've gotta know how to read
it a little bit but it's fairly obvious
if you know the history of your project
itself but what we do is we can look up
what the previous hash was so we're back
to hashes again so when we look up we go
our here's where we moved the head we
want to actually go back to the previous
version I shouldn't have done that you
know so yeah we'll come back to that
sorry how we fix that of what was doing
saying else then
so ref log is sent it keeps a history
but he keeps for 90 days by the way now
as you've seen when you add things to a
git repository
it creates objects and you're doing add
add add add add multiple versions of a
adding a file to a repository you're
creating a whole bunch of objects we've
never actually used and this builds up
over time so how does get manage this
kind he's kind of orphaned useless
intermediate objects really kind of
spoiled either reveal eeeh
so what we wait as it has something
called GC gets if you're fit you think
about it if you were worse with a JVM or
really any kind of object-oriented
language or really any virtual machine
system in it at all it has the idea of
garbage collection garbage collection is
just find all the objects which no
longer have valid references to them and
just reclaim them or this case delete
them from the disk so what happens with
GC is it runs around finding any thing
that no longer has valid references to
it and will just still delete them you
know the final references walk back
through them find out which ones are
dangling at the end of it and they'll
delete them now it's not too aggressive
about that in particular it doesn't
delete anything until there's at least
two weeks old however you can override
that you can set it longer you can see
the shorter or in this case use prune
equals all will blow away anything so
this is really why if you do that that
reset don't go running around doing G
GCS aggressive ggc's afterwards because
you're destroying some of your history
or it was a throwing your ability to
recover that's said you wouldn't
normally do this get will generally do
this for you the other thing that it
does and we're down into oh those
reticence even talk about this because
it's not really important but it's kind
of useful to know or in or least
interesting to know is it doesn't just
prune objects out the tree it really
compresses them so what it does is
subversion originally or well in fact it
always has always stored the differences
between files over time that seemed
great at the time but it meant it if you
wants to go back and actually modify
anything in it it was virtually
impossible because you had to basically
recreate the entire repository git
didn't do that get keeps every object
all the intermediate so actually
modifying the history is very simple but
it's also very wasteful so what git has
is Tsang called pack files we do a GC it
will temporarily encode all of these
spread out objects find out their
history work
and store it in what centuries a
temporary arrangement of a pack file
that is Delta encoded and compressed and
so on this is primarily to save disk
space but more importantly it's very
useful for networking when they when you
do over the net over the network
transfers you don't want to transfer a
massive object you want to only transfer
the a bare minimum just to give you a
quick look at this this is what it looks
like we do a GC in all these objects no
longer exist
they've all been packed down into three
files one that references the packs
themselves one that is the actual data
and an index file this if you've mucked
around with on disk databases it looks
an awful lot like this yeah but
generally have an index file and yeah
and the raw data the index file is
looked up and used to find the data
inside the big blob file yeah it looks a
bit of Berkeley DB or anything like that
it'll looks a lot like this if you're
really really interested in this kind of
thing go have a look inside the gates
source that there's a file in the
documentation this explains how the PAC
file works if he's deep black magic it
is optimized for spinning disks to hit
the the distance most optimal way
possible gain this was written by a guy
who does operating systems and file
systems it is deep black magic no one
really knew how it worked for a long
time until somebody pinged him on the
may listens at how the hell is this work
and he just dumped a bunch of
information and they just copied it into
a file and that's an documentation under
the get documentation tree interesting
stuff if you're really into your hyper
optimized database sort of things this
is basically a mini database but that's
that look at that level we've talked
about a low-level blobs we took the
higher level refs branches and
manipulating them and how to screw
yourself up by manipulating them we have
a higher level now branching is easy but
branches are not a lot of use unless you
can get them onto something else
unless you're completely replacing your
entire repository you can do that but
you generally want to merge back into
the main stream of development at some
point so I'm oh so what is a merge
a merger of course is just weari joining
the history we've gone off that our own
thing we decided it's time to get back
into the mainstream and lism des emerge
occurs it's a bit more complex because
some of these changes that have happened
between the two branches might have
overlapped often they don't but it's
possible so this again this will look at
emerged its merge commit that's created
when we re merge these two streams of
the development what does it look like
again very very simple it is just a
permit with two parents this is why you
can go around the leting Brown branches
inside get and you'll still have the
history because you can always walk off
as you walk back through a tree you can
often go down that alternative par-4
look at what happened and then come back
or you can just follow down the main
branch you can sort of see it as a sort
of winding path that you can go look
back on of course getting there is not
quite as as simple as that as simple as
just say saying that although sometimes
it is this is a fast-forward merge if
your two branches haven't read of
diverged are you taking you you've gone
you know master master master I'm gonna
create branch
oh yeah I'll finished now done and no
one's committed on to master again why
bother even making a merge commit you
all you've done is just there's nothing
to merge there's no there's no change
changes and gates by default will do
this it will do a fast-forward merge the
problem there is you don't your merge
commit here doesn't have the two parents
so you're losing history you no longer
have than the awareness that the branch
ever occurred maybe that doesn't care
maybe you don't care
some people like a nice neat tree
personally I like to keep context if you
know they branched it off and maybe that
branch had a ticket name associated with
it an ID for a JIRA ticket or or
whatever and then emerge you may be
losing that information personally I
like to keep that around so there is a
emerge come commander
an option called no FF no fast-forward
and it will always create a merge commit
even though it doesn't really need to
and that keep that's where it's a dummy
commit that contains the two parents so
that you know that the branch occurred
but generally speaking this is not gonna
happen gonna happen if you're in a a
busy team that's good with a lot going
on or a branch that lasts more than a
few minutes from in a non-trivial team
then what's going to happen is you're
going to have some conflicts even if
they don't really conflict it files will
have changed in both sides we need to
make sure that they're not going to
cause any problems there's a number of
merge strategies that get uses this is
an enzyme going to skip for skip over
this quite quickly unfortunately it is a
basically talk to itself suffice to say
get use a multiple merged strategies
they're pluggable which is nice so if
you have some proprietary binary form
format that you know obviously can't
merge binary form formats if you don't
know well what they are but if you
personally know that your binary format
is really just a lot like a binary XML
and you could possibly merge two changes
if they're non conflicting then you can
write your own merge strategy for that
but the one that git uses by default is
something called recursive recursive is
interesting it's been extensively tested
on a Linux kernel tree which is probably
about as busy a tree as you're going to
get and it's very clever what it does it
walks back through the tree and at each
branching point it creates a dummy
intermediate commit and then recursively
works its way up the the set of changes
I'd say this is a fairly big subject in
itself if you're interested to have a
look at it there are other types of
merge that can occur there's song called
hours where you can essentially just
completely forget the history of a
master branch and replace it with the
with a entirely different branch much
while keeping the the context not often
used but it's kind of handy sometimes as
I say I'd like to talk more about this
but it is a fit
massive subject in and of itself I
recommend going and having look around
and some of the discussions of how it
works in turn internally but suffice to
say the the recursive Murchison has been
extensively tested on the Linux kernel
so gonna come to one of our old friends
how many people here have used rebase at
some point right how many people screwed
it up yeah about half yeah again right
of passage so now we know a little bit
about the object graph of guess how it's
all wise together hopefully rebates
becomes a little bit more obvious what's
going on what rebase does is it takes
the branching point that occurred with a
where we decide to move on a set a
separate track and it just says I'm
gonna overwrite that I change that but
because it's all hashed we need to
replay each commit on top of the new
point where we're going to sort of
rebind the history this is extremely
powerful because you if you want a clean
tree this is how you do it because from
this point on you can now do a
fast-forward merge if you want to have
complete a completely flat history it
also is exceedingly powerful because at
each one of those replays you have the
ability to go hang on I don't like that
commit message I'm going to change that
or I would like to take these two
commits and put them into one because
we're replaying and we get to reap like
we get to interject and change history
but tend we did something else we're
gonna cheat but it's also quite powerful
in itself though for reasons I'll show
you
rebase is one of those things it's
pretty easy to screw up but you will
also find it very very useful one of the
most powerful things is the idea of an
interactive rebase so you say I'm going
to rebase it's going to replay this
before you do that show me what you're
going to do and then you can go in and
say well actually these two commits
should be one commits or these two
commits to be one commit and have this
message or this message should be edited
or gonna squash the whole thing down
it's one big commit which is it which
isn't is it an option don't recommend it
I personally like to keep history but
some people like a clean tree as I say
there's a lot more to talk about here
but this is
really the at the core of gets model you
got your objects you've got your refs
which you can build broad branches and
tags and anything else you want on top
of that and and then you have slightly
higher than that you have the idea of
merge where you're going to have to
resolve changes between different
branches at some point and you want to
keep the history so you can get has
metadata in the commits that allow you
to store where a and objects came from
where a piece of history came from how
you got there which is why merging works
so much better than say subversion
subversion does not have its own history
in its repository git does get knows
where it got where it came from
therefore it knows how to get out of
trouble talking of getting out of
trouble did you see this ad here this
would this is for peer in the UK the
original Prince of Persia or they the
new one the sands of time it was an ad I
think wasn't me in Australia no okay
anyway you want to get out of trouble
everyone has screwed up there get
repository generally speaking as I say
it's a rite of passage for new get
people like oh yeah I know what's going
on here go reset or I'm going to rebase
ins oh so here's our favorite one
reset hard everybody's done it no about
half people said no I didn't screw this
up you were probably lying we've all
done it so it reset hard destroy is
pretty much everything it moves the riff
back to some point maybe somewhere
completely else because you can
essentially hyperspace right through the
trees or somewhere else and it will
they'll so blow away any stage changes
will blow where you're working tree it
was very useful I use reset hard a lot
when I've gone like a out hacker
I've got myself into a mess reset hard
mine just puts me straight back to you
know the head in a clean state but you'd
be away when you do it you will be
blowing away a lot of potential data now
I can't help you with the work the work
the actual working change changes I
can't help you with the in each working
interns in the working tree but hasn't
been added to get can't help you with
that
but anything that gets aware of
we can get back to so anyone want to
take a guess at how we would get out of
this situation knowing what we know now
there yeah you can use them too
there's the newfangled ideas over new
kids where we talked about the riff log
so when we did that reset there would
have been a record of that so we can
find out where we were beforehand so we
go as Goods the riff log
find out where this particular riff was
pointing previously and go well okay now
we know we want to go back to our commit
not they this you know mu the moving of
it by the way these are little up arrows
there's a is a whole little mini
language and get about how to reference
refs so you can say like ref - one there
- to soar jump two places back in the
tree whatever it's fairly complex
already use it very much myself it's
just too much to remember most of the
time it's easy to look through to the
Lord logs and find out you know where
you want to get to but that hade uptick
means the previous team commit to the
one I'm currently looking at so we know
the hash nail so we can find up here and
we go okay fair enough
lets us use the same thing that got this
institute to trouble to get us out get
reset hard pushes it straight back on to
where it was now you know you're out of
trouble again
hopefully yellow a great one I'm pretty
sure everyone is rebased has probably
seen this all relate on the non-trivial
ree-ree base you've done a rebase and
you've broken the build and you don't
quite know why somewhere along in that
tree there was some sort of conflicting
error not and not conflicting enough to
cause a merge failure but conflicting
enough to be a logical failure much much
worse than a merge failure most failures
are easy logical ones concerns that we
recently weeks your life so what do we
do about this now this actually can
apply to a couple of things including
merges themselves but rebase is a
particularly good one I like this one
because
it's one point at a long-running branch
now I was constantly rebasing and every
time it would break in some way shape or
form and I had to go and find out so how
can we do this now I haven't quite
covered this in in detail but I didn't
mention that when you do a RiRi base and
you replay you actually have the ability
to interject at each point and change
the history or you could inject it at
that point not change history but for
instance validate what's just happened
in some way shape or form like those
complete a hundred percent test
coverages that you all have naturally
I've certainly got a hundred percent
test coverage as you might've test at
all so we have the ability to not to
undo things
so let's undo that the first thing we're
going to do reset you use RIF log to
reset this now we can actually put a new
song called rebase exec rebase exec at
each step along the RiRi base will run a
command for you in our case our totally
awesome 100% complete test suite can be
run at each point that you of the RiRi
base and it will fail the first time a
test fail so you can find out very
quickly why you'll rebase failed and you
can either decide to fix up at that
point get will literally just stop at
that point and go do you want to fix up
do you want to abort this RiRi base it
gives you a bunch of options you have
the ability to go I can decide how to
fix this up so you can see what it will
we stopped halfway through the RiRi base
here because our tests failed because I
didn't make make tests now make tests
could be anything it can be mvn tests it
could be MV an int test which is our
particularly extreme test which
literally run up Postgres and a full
tomcat server and whole works and froze
a tons of tests at it depends on how you
know bad just your situation is but you
have this option you do the RiRi base
and you get to say let check each step
along the way very very useful tool that
if you do get into this situation
particularly your tests are fast do this
every time it saves you a lot of
couple down the line however it's not
always possible to go back and change
history sometimes you want to fix in
place how do you feel here know about
git bisect okay handful now one of the
classic ways you would fix this problem
because you we can get you can jump
around in history and when you realize
that you go ah what can this go back
through the tree and run the test each
time and work out which one was wrong
and I can fix it up afterwards it has we
narrowed down on what point which commit
broke and it's this apply to rebase is
it can apply to merges it could apply to
just a complete flat tree where you're
making changes you realize later on
weeks later that you felt that you had
broken something somewhere but you don't
quite know where they uses a lot in
there gets in indeed Linux tree but what
it does it basically goes ice I tailgate
okay it's going to start a by a bisect
here we're going to pick this point
though I happen to know that's broken
I'm gonna pick this point which I happen
to know was working run back through
that history running this command you
can never do it Matt do it manually you
can jump through and do a bunch of set
of manual testing and then say that was
marking as good or bad or you can just
get it to run a command and it'll run
those tests it will jump back but it
does it does it the smart way it does
the way you do if you you if you were
four so gonna take ages how can I make
this faster it'll pick a point somewhere
in between the good and the bad do a
test if it's bad it'll go further back
in time if it's good it'll jump forward
in time and it will automate this
process of finding out what exactly
happened now I just realized I think I'm
running severely over time is that true
I'm I figure we're talking for almost an
hour hour now so nobody's coming to
shout shouted at me okay cool
but anyway I'm at the end as you can
tell it's a lot more can be doing here
there's lots and lots of examples you
can give but hopefully I don't need to
with this basic knowledge you got your
objects and your commits and your trees
you've got your refs you can move around
and you can manipulate it directly I
mean if you're really excited you can
jump blow it lower down and and you can
chain these commits together and they
have multiple parent parents and you can
re merge points in history splitted
history but really it's just all just
objects are pointed to by trees that are
pointed to by commits which are pointed
to by references and once you know that
you so many things sort of fall out once
you understand that model everything
else is built on top of that all these
complex ideas are really just layers on
top of that and you can work from first
principles and if you have a question
you can go work through it what what
happened well if I was writing reset it
was writing rebase how would I implement
it all right well in that case I can
probably do this a lot of things become
obvious so now we have all this extra
knowledge now hopefully you can work
through the from first principles for
any issues you have in git and hopefully
you understand it and use git in a in a
different way on the other hand if
you're feeling really excited sighted
there's lots of low-level commands to
manipulate get trees directly so one is
go back to your production trees and
just start hacking on your refs and
maybe look at file and hash objects and
all these fun ways that you can directly
manipulate a tree if it was into it like
a really fun story about how the Linux
kernel completely blew up bitbucket one
time because of some dark magic that
people did with a public keys but feel
free to go off and do learn more about
it and understand it more but and use it
in a more powerful way it's just an
acyclic graph but it's also just a bunch
of object and you can manipulate them in
any and any programmer can mess with
quick
- you know may make the work for a more
powerful or if you're really excited
sighted Goff and implement get you could
actually implement the core of getting
an afternoon now you can't do a lot of
advanced stuff you can't do the pack
files you can't do it unless we do
Network but you could basically write a
program that will actually walk across
the get tree and tell you what's in it
and your report things very very simple
very powerful if you know how it works
so hopefully it hasn't been useful to
you break this on the app if you if you
would and hopefully this will help you
with your obviously the release of
everything local independent
I don't have a massive massive
these quantities saw the biggest man
I would they're released separately and
they talk fryer a well-defined API and
it can be released separately and can
operate independently or they have
implicit or explicit dependencies on
each other on their versions in which
case they are not really separate pieces
of software if I'm using Amazon Web
Services I do not require that Amazon to
upgrade their services the same time
that I upgrade my my system that talks
to it however if I do then I really am
part of Amazon Web web search server
that services we've been through this
it's often one of those cycles of
software where you separate things out
and then you finally have implicit
dependencies and you rejoin them we're
rejoining a bunch of our stuff when we
found out that their API is were not
really as independence before they were
or in some cases we were had a bunch of
modules we really wanted to refactor
them into a different structure of
modules in which case we would rejoin
the mall to get all into the same
deposit Ori treated a single piece of
software on a single foot the version
for each release and then only when
they're fully API separated would you
then split them up again
dad said splitting up something when you
put it into the same repository is
exceedingly hard because once the
possibility of creating tight coupling
occurs it will occur it's just human
nature if I know that that piece of
software over there has a connect on
tact or customer object I'm going to end
up using that customer object rather
than writing my own and having a bunch
of you know data transfer objects
I'm going to take short cuts it's the
the reality so I we have very strong
very separate api's all you have the
knowledge that they are they're all part
of the same project and may need to be
upgraded in lockstep it's not straight
it's it's not straightforward one of the
things that Amazon did in particular
when the reason why Amazon Web Services
exists was because they famously it came
down from the top everything will expose
itself via REST API there will be no
cross dependencies between our different
tools and our storage system versus our
computing system and they enforce that
very hard and from that they were able
to turn it into a product because they
were forced to operate as customers for
each other anywhere where you've got two
people who can collude together you're
going to get this kind of bleeding of
the pit dependencies so they had to have
strong separation there was a fine coat
by Peter site Seibel on Twitter the
other day he's guided practical Common
Lisp even if you not into Common Lisp
read the book it's one the best
technical
introductions to a language or ever read
but he said the this is Conway's law for
the 21st century for the cloud set
century any geographically distributed
team will be talking to this awful talk
via an RPC interface so my color to that
was if you want to create RPC interfaces
physically separate your team if you
want micro services make everyone work
from home so that's really that's a long
long answer git is more than capable of
dealing with massive structured projects
it's it's it's used on largest software
project in the world right now the
weather to split or merge different
modules depends entirely on how strong
your pets commit to a stable API Oh over
time and how much you can stop people
from assuming that they know what's
going on under the hood of different
modules even if you've got strong API is
if you implicitly report them depending
are certain behavior then if you change
that
yeah it will break even capi remains the
same Microsoft Windows is a famous
example of this they had to keep all the
old bugs and quirks over time because
any fixing of a bug would break
something for somebody for somebody for
whom that was not a bug it was a feature
so that's pretty much there so that's
the long rambling answer the question I
hope that helps
any other quick questions don't re re
rebase is when would you use rebase
versus murder sorry yes
okay so rebus vote versus merged
generally speaking merge unless you have
some pressing real reason now some
places will prefer a clean tree rebase
will give you a clean tree rebase is
also you ability Felicity to fix up a
branch it gives you the ability to go
look I've created a whole ton of quiz
I'll go commit a Oh fix the commit a fix
the commune last commit whoops I forgot
this far blah blah each one of those
intermediate commits is broken and what
ideally what you'd like is to have each
commit to be a complete self-contained
change
atomic but discrete so rebase gives you
the ability to do that as part of your
rebasing you can modify that history now
well I think interesting about rebase is
you don't actually have to give it a
different hash you can actually say I
want to rebase on to the place I'm
already pointing from but what but in
doing so please let me interject and
change the history so this one has weird
tricks
rebase can reboot onto anything
including onto itself so you can
actually go read rebase what rebase is
really is should be really really will
be a better name for it so replay this
history
I want the history to start somewhere
else or a lot of history does carry on
starting here but I wants to actually
modify that history at each point so
generally speaking
we prefer merge no fast-forward rebase
when you need to change history or
you've really you've diverged so far
that really the only way to do it is to
is to reread base it doesn't really
happen very often and generally speaking
you're gonna have breakage at that point
I've done that but you can also merge
history back into your tree but that
will often end up over quite a messy
tree you want to keep your tree fairly
clean riri base but don't overdo it and
also you gotta bear in mind if your if
your rebasing a branch and then you push
it up you're going to destroy the brand
for anyone else who's using it he was
you're rewriting history when they pull
it down it's going to kind of change
their history that's why you this we
have this idea of force pushes if you
push something and it's completely
changed of history the Reserve will
refuse it unless you say force that's
because your hash is the head has
changed completely add now is now
completely different to the history if
someone else was using that history and
they go and pull the whole thing becomes
chaos very very quickly indeed there is
something called force with Leafs by it
away I wrote an article about this a few
months ago if you're interested force of
lease when you push and you do a force
you can do a force of lease and what
that does is checks if anyone else has
been using that branch as well and oh
and then it'll refuse to do the force
even if you said force release it will
then no longer overwrite it because
someone else has that has worked on that
branch as well it's not perfect but it
does help but no dairy short answer is
by preference merge merging no
fast-forward riri basis for cleaning up
only unless you really really are
working very much independently and
really want to fix fing things up at the
moment you're sharing a branch you
should never rebase that's a golden rule
on a lynx kernel for instance the moment
you've done a rebase or all pushed any
branch up some sort somewhere rebase is
cannot occur ree bases are local only
operation you can treat them as an
operation to push up to a tree but if
you do so you're potentially stomping on
someone else's work so again that's like
long verb version of it thanks very much
dick
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>