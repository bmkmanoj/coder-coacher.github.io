<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • End-to-end Encryption in Cloud Services • Patrick Linskey | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • End-to-end Encryption in Cloud Services • Patrick Linskey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • End-to-end Encryption in Cloud Services • Patrick Linskey</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/854HdTGkRL0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everybody to the last talk of
the of the day in the security track I'm
Patrick linskey I'm a the principal
engineer the the chief architect
personal engineer in charge of Cisco's
collaboration a kind of next-generation
collaboration product called Cisco spark
and one of the things that we care about
a lot at Cisco is our customers security
so we do a lot of work a lot of work if
you look at the cisco customer base a
lot of our customers are bigger than us
and a lot of them are you know
governments or banks or things like that
and they are very careful about all the
systems that they run and very carefully
peel from the from the switching a
routing layer all the way up to the
application dear security is a
hot-button topic for most of our
customer base so we care correspondingly
quite a lot about about this and so what
I'm talking about today is a an overview
of what we're doing in the end to end
encryption space and we're doing this
I'll have some links at the end we're
doing this through the IETF the internet
Engineering Task Force I've got a link
to the draft that we're working with the
ITF on for deferred standardizing this
this approach but for the most part I'm
going to be talking about this in the
context of our product mostly because
it's it's a more concrete way to talk
about it then in abstract resource terms
and stuff like that so briefly Cisco
spark Cisco spark has said is cisco's
kind of next-generation collaboration
platform we it does the kind of standard
collaboration stuff cisco I'm part of
the the collaboration technology group
within Cisco we like our acronyms ctg
and it's the group that owns WebEx and
telepresence and jabber and bunch of
other kind of collaboration products the
phones etc so Cisco spark is kind of our
like our next generation cloud
collaboration platform you see there's a
is android client
incest top client integrates in with our
telepresence systems does a lot of this
the same workloads as what we have with
Jabbar and webex and some of the other
products but it's all cloud delivered
and it's also an integrated solution
across our portfolio rather than kind of
a bunch of stove pipes that are somewhat
loosely put together so the context that
I'll be talking about here primarily is
gonna be around the messaging component
and then also we use some of the same
techniques or we're working on the same
techniques for our media encryption
story as well so voice and video streams
but mostly we talking this this talk
mostly is in the context of one-on-one
and group messages which is probably I
assume familiar domain for everybody
everybody here so should be easy to
relate to so if you look at what we want
to do with end-to-end encryption we have
a few a few goals that are particularly
important to us so we don't want anyone
to be able to snoop on our customers
traffic and that by anyone that includes
us so we're trying to build a system
where where our customers have a very
limited a very limited requirement to
trust Cisco as a company to deliver to
deliver a solution we also want to use
this not just for snooping but also as a
tool to to prevent accidental data
linkages and there's there's a lot of
similarities between two spaces but
certainly some differences as well also
in the case that there is a leakage we
want to plan for that and make sure that
that we can limit exposure significantly
in a case of breaches of whatever
whatever data stores we're looking at
another big important thing for us as a
cloud service provider is reducing our
legal overhead we don't want to have to
respond to subpoenas we'd rather if
somebody subpoenas us were like yeah
yeah we here's here's the data it's
encrypted you know come up with it but
we also want to let people be able to
view in search data in conversations and
be able to end end at both of the
enterprise level because if you look at
our customer is someone's I tea shop
more often than not and also to allow
individual users to be able to join
group conversations in the middle and
get access to previous data and whatnot
so this turns into some particular
constraints around what we can what we
need to do with our key management table
stakes that should be familiar to all of
us is transport level security so before
I start talking about what we're doing
with with with with end-to-end and key
management let's look at kind of the
baseline that we all need so what this
means is make sure that basically
anytime we're transporting data from one
server to another or client to a server
or whatever that's encrypted so HTTPS
srtp for for media do that both day
between our clients and our data centers
and between different data centers that
we have that we that were deployed to
and also out into our customers data
centers when we have stuff deployed on
premises at a customer site and that
this is a well-known space so you know
we this is if you're running a cloud
service you need to be doing this if you
want if you are not encrypting if you're
not using HTTPS or you're not using
transport level security for whatever
your transport mechanism is your your
customers data is just like out there
for anybody to read you know period
terrible situation to be in so this is
absolutely table stakes but there's some
limitations right if I'm if I'm if alice
is sending some super secret message
over to Bob and it goes up through our
messaging server gets stored in our
messaging storage gets sent to a P&amp;amp;S to
apples servers to Google's servers etc
all of a sudden our transport level
security is great in terms of keeping it
secure from like other people in this
room as you're sending a message but it
doesn't help at all in terms of the
trust in us and also the third parties
that that that we use to deliver our
service so even if someone were to trust
Cisco with with with this incredible
fact that alice is transmitting to Bob
they might not want to trust Apple with
that so transport level security just
doesn't give us enough so
we want to raise the bar we want to do
better than that we want our solution to
be something where it's secure by
default and where customers can can can
really minimize what the what they need
to look at so we want to let our
customers really be the ones who are in
control of access to their data both in
terms of you know adding you know the
kind of the normal flow of work through
our system so normal workloads obviously
we want them to be involved in that also
in terms of the lawful intercept
mechanisms that are required by their
their their company their industry for
example Finance has different recording
rules than then that healthcare for
example and by what what what country
that they're there what countries that
they're there working in so all those
sorts of controlled access we want to
put that into our customers hands rather
than really being the people who are who
are running it we want to support both
communications within a company but also
communications between companies so we
we need a solution that makes it easy
for somebody at Bank of America to chat
with someone at fannie mae and there are
again regulatory concerns with with
doing that so we need to make sure that
we do so in a way that enables our
customers to meet their regulatory needs
and we want to allow the users to have
the capabilities of doing things totally
off the record again that's something
that some companies might or might not
you know enable but we want to build a
system that will allow us to offer a
product where I can communicate with
with Aaron without any without without
my company being able to see that in an
ephemeral way so a bunch of different
use cases that we want to be able to
solve with our crypto story so what if
you look at crypto what it comes down to
is key management the heart of
end-to-end cryptography is what are you
doing with your keys how do you how do
you manage the associate the allocation
of keys to a given authenticated user or
machine and so the key management server
is is the key piece to this and
of course like I said we don't want to
be the anchor of the trust chain so this
key management server need not be
operated by Cisco it may or may not
depending on what a given company wants
to how they want to deploy and the way
that this works is that we do a diff
Hellman key exchange through our cloud
so we have this key management servers
that are kind of deployed out into the
into the internet and they communicate
with our customers phones and devices
whatnot through our cloud but using
diffie-hellman to do a security exchange
between the parties raise your hand if
you're familiar with a dippy Hellman key
exchange channels ok really briefly I
won't get into in detail I can talk
about it more later if people are
interested after the talk but briefly
what it takes advantage of some
asymmetric math problems that are you
know common to a lot of crypto out there
to share us to allow two parties to
establish a shared secret in an
untrusted environment so I could yell
out across the room one number and then
mark in the back could yell out another
number and then the two of us knowing
that we're sharing the same algorithm
for generating those numbers could put
that those two numbers together and
figure out what the secret that each of
us used as the baseline for that and for
that for that shared secret and at that
point we now have a shared secret
mechanism we can use to be able to just
you know yell gobbledygook back and
forth across the room and it doesn't
matter that everyone's heard the entire
session including the this this
diffie-hellman key exchange it's a
really interesting algorithm I'm happy
to dive into it more detail later but
it's not actually all that relevant the
details of that aren't that relevant
here the important piece of information
is that we can mediating through our
cloud meaning that we can manage the the
uptime and availability and scalability
at kind of cloud operator level we can
mediate these exchanges through our
cloud and allow a channel to be
established from my telepresence
endpoint or iPhone device or whatever to
somebody else's and the KMS is then
responsible also for generation of keys
and
keeping track of basically this
association between a key and what we
call a resource and in the again in this
domain the kind of group messaging
domain that means like what's the chat
room or the the kind of conversation
that that that were that that's
identified to as being a key resource in
the back end and that can have one or
more keys associated with it that can
then be used by different parties to
encrypt content so the the users then
encrypt payloads locally on their
devices and send them to our cloud which
stores them so we run a data store
Cassandra store in the cloud that's
storing all these encrypted envelopes of
data all this encrypted data and then
we're routing it out to all of our our
our other clients but the key management
each one of those clients has to then
negotiate with the backend key store in
order to obtain those keith's so what
that looks like in terms of the the flow
that happens is that again we have
trusty Alice and Bob here and the first
thing that happens is that each one of
them performs the diffie-hellman key
exchange back with their KMS the this
the key management server so they
established that that trusted channel
and once they've done that the the KMS
then manages locally in its database the
the session keys that are being handed
out and also the the the the
conversation keys that have been used to
encrypt the the actual payload content
so we have two sets of two sets of keys
in play here one is the is the key is is
the key that we're using to secure the
channel from Alice back to the KMS which
is distinct from Bob's key and then the
other set of keys are the ones that are
actually used to encrypt the content
stored in in the back end and again all
this is happening through the spark
cloud but because we're using the
difficult the diffie-hellman channel to
transport the data the spark cloud
doesn't actually have access to any of
that content so then Alice sends Bob
that message
and at this point the the message goes
from Alice to the spark cloud gets
stored in our database and then routed
Bob through apns or GCM or wns or
directly over a WebSocket or technology
of choice but it doesn't really matter
because in all these cases this is just
a encrypted blob of text with some
routing information so that data is
fully encrypted and no no real concerns
about that Bob can reply back the other
direction the same thing happens and
then things get interesting so again I
mentioned that we have this this notion
of a resource in the KMS and the reason
we do this is we don't want to just
manage rockies we actually want to
manage a collection of keys because
alice is encrypting of content and you
know Bob's encrypt and content and now
and now someone says oh let's bring
Charlie into the discussion and so one
of the things we want to be able to do
at that point is that Charlie goes and
does his diffie-hellman key exchange
once again just like the other two
participants did to establish a session
back to his KMS but also that turns into
a session being established with the the
the KMS that Alice and Bob were using
and this allows a copy of the keys of
basically copy of that resource that was
stored for Allison Bob's conversation to
be copied over into Charlie's KMS so now
that data is in two places and this is a
really interesting thing because all of
a sudden you know Charlie works at one
company Alice and Bob work at a
different company all of a sudden this
data has been shared right so the the
once once this happens now now Charlie
has access to be able to get to the the
conversation that Alice and Bob were
having they wanted to bring him into and
this is again where I said earlier we
want to support a bunch of policy
capabilities for our customers some
people would say oh I don't want to do
that I don't I don't want my customers
to I don't want my employees to talk to
other people outside the company and
what always happens is someone finds
another way to communicate because you
know if you need to talk to somebody
you're going to find a way to do it so
what this does is it pulls that directly
into the model so now it's clear that
the key has been copied so that that
data is now available to to the other to
the
other person just like you said an email
to somebody that the content of the
email is now available on the the you
know Charlie's company's servers so and
again we then do the same the same key
exchange and then Charlie goes to the
spark cloud and can access data from the
conversation database so you can then
download the actual messages that were
being sent and decrypt them locally and
and off to the races now where things
are interesting is when we do key remove
a participant removal one of the reasons
that we have a model that supports a
collection of keys associated with a
given resource is that we want to
support a emeka delight way mechanism to
be able to change keys so that if I were
to remove Charlie from a from a given
conversation at some point in time
because he was an outside contractor and
his contract is over or you know what
for whatever reason we realized we have
to have some secret conversation we
don't want to involved in I can remove
him and at that point from from then on
Newton Alice and Bob can simply start
using new heats that he doesn't have
access to that are then added to the
resource but they're not added to his
part of the resource anymore because
he's been removed from that conversation
so we can essentially combine policy
concerns around the kind of application
level policy concerns push those
concerns down from the policy tier to
the encryption key management tier so
that even if we had a bug in our server
that somehow allowed Charlie to keep on
getting copies of data from that were
being sent well if the underlying key
server doesn't give him the keys then
it's kind of a moot point anyway and
that that there that's essentially no
longer irrelevant he doesn't get any
kind of forward-looking access any of
the the secrets that are being passed so
that's a very high-level kind of the
flow for for what we're looking at from
a encryption standpoint or like a
message content encryption standpoint
and this applies both the messages and
also to files or like I said to to AV
streams or recordings or not but don't
forget authentication
so the the IETF draft we're working on
is leaving authentication out of scope
for for for kind of purposes of being a
targeted spec but without a trusted
authentication mechanism this thing all
falls apart right if you're if you end
up relying on cisco's identity provider
to generate the roth tokens that we use
for for doing compare it for doing
authentication then well we could just
go and ford someone's tokin anyway and
it as far as the system is concerned
it's it's yeah that's a trusted user
this is really important whenever you're
thinking about end-to-end encryption to
think about the key management and also
what your authentication story is
because without that authentication
story everything kind of falls apart
what this usually what this means in the
real world is that your any end-to-end
crypto story boils down to how you're
doing mobile device management for cert
management on your phone or on your you
know device management on your under on
your desktops and other devices and
without a good story there without
having some kind of fundamental trust at
the device level the the rest of the
story ends up kind of relying on some
other weak leg so do make sure you kind
of think through that authentication in
this so this is really cool and it's
essentially something that note that no
one's doing a very good job of the
industry today the cloud in general
today is is has too much too many
companies stopped at TLS and more
companies need to to kind of kind of
move forward past that to full
end-to-end encryption which incidentally
is one of the reasons why we're doing
this in the open with the ITF rather
than as a internal thing only is because
moving the cloud towards that a higher
level of trust is critical but here's
the thing it's a little cup where the
flow is I described there a little bit
complicated there's additional
bootstrapping and stuff like that but it
gets really hard when you want to do
some of the
a kind of more advanced use cases than
just storing data and the big one in our
domain or one of the big ones that our
domain is search so this is where I kind
of the rubber meets the road in terms of
making a solution that both has
fantastic security characteristics and
privacy characteristics but also meets
are our kind of usability requirements
so that we don't end up kind of just
pushing the burden onto the cut on to
the customer because if you talk to
anyone you know who's sufficiently if
you go down any of the security pass far
enough the only true secure system is is
the only secure computer is one that
like doesn't run right if you can remove
the power supply that would be ideal
because you're definitely not going to
leak any information so you this is
always a game of figuring out what what
compromises you can use to to enable
something and we don't want to be in a
position where we say ah you know what
you can't do this because because
security and it's all too common that
you hear people say well this this is a
tough thing to do so we're not going to
do it and and and so it goes so search
is one of the big ones for us and we're
actually still wrestling with this
problem so actually sorry I put that
slide in the wrong spot let me just skip
through OTR because it's kind of not
that important the the slides I just
skipped through our the same flow for
how we do off the record which basically
just means that the keys aren't actually
getting shared into the back end KMS so
the same general flows but but the keys
are only communicated between the two
participants and not to the back ends
its kind of the degenerate case of the
problem encrypted indexing is tough
because as a cloud service we want to be
able to Bert to kind of offload as much
of our of the of the processing into our
cloud as possible so we want to be we
want it to be easy to write a client so
that the cloud can be doing as much as
possible to make client development and
client the client footprint small and
then that pulls out to kind of back end
on-premises deployed things and whatnot
so for an encrypted search to work
we can't do client-side search
client-side search on a device like a
phone or web browsers a disaster because
you've you end up with too much data if
you want to search through all your
powerpoints and find powerpoints that
talk about a given you know deal that
you're working on or whatever that's not
going to work client-side so we need to
do some things server-side but it can't
be in our cloud because we don't trust
our cloud so this is where we end up
having doing a indexing on prem where we
can have an indexer that will get a copy
of the data that's being sent from from
you know Alice to Bob and decrypt that
next to the KMS in the same trust zone
as the KMS decrypt it and then maintain
the index in encrypted form you perform
an indexing operation on it maintain
that index in encrypted form in our
servers and then be able to kind of
essentially have this hybrid deployment
where the the full search capabilities
are delivered by both our cloud as well
as the kind of trust zone that has the
KMS deployed to it so that ends up
looking a little interesting because
well we end up with with is that Alice
sends some some message to Bob and then
that gets sent over to the to the to the
indexer as well indexer then goes and a
has a trust relationship set up with the
KMS so it goes grabs the keys for it
decrypts the content does all of its
token token tokenizing and stemming and
then it sends back to the the spark
cloud the encrypted indexes that we then
maintain server-side so this means that
the the footprint of work that has to be
done on in the same trustzone as the as
the KMS is minimized down to just the
indexing processing work not all so all
the storage work now sir how do i search
because all this data is now encrypted
so from a search standpoint I I then the
and again this is it as encrypted on a
per resource basis so if I'm in
a conversation with you know three
people in the room and then another
conversation with other five people in
the room those those are gonna be using
different sets of keys to perform those
different to encrypt those different
sets of data and so I can't just go and
you know locally encrypt my my my search
queries or something like that on my own
device because as the number of
conversations I'm participating in
expands the amount of encryption I would
need to do then correspondingly grows so
what we do instead is we send an
encrypted search query from our client
to that indexer and the indexer goes and
and does the same stemming work on that
query we perform is that H Mack work and
then sends that data back up to the
spark cloud and we then use that
encrypted h mac data to be able to match
against records that are are stored it
in encrypt totally epically encrypted as
far as we're concerned and then finally
the the indexer then aggregates the
those responses that it gets from the
h-back database in the cloud aggregates
those together and sends them back up to
the end user's device so here you see
we're grabbing those keys we then
basically send that that full aggregate
the full results set and send that back
down to to the client so essentially
what happens here is that that indexer
becomes the essentially my search agent
for my device it's essentially
performing the the the search and
aggregating those results and then send
them back to me but it doesn't actually
have to store into that data so it's the
mediator for the flows but it doesn't
have it the same data data storage
requirements that we would have if we
were looking at a full kind of full
index running locally on Prem so that's
the that's kind of an overview of what
we're doing with our end-to-end crypto
story i have a few areas i want to dive
into it a little more detail but before
i do that i wanted to take a quick stop
for questions to kind of go over
whatever questions people might have
before we go into any
lower level stuff so your questions
about the off-the-record flow yep so let
me just jump back to that real quick so
the way that we do the off-the-record
flow is that the first thing that
happens is that Alice and Bob do a dippy
helmet exchange so my client would talk
to your client to do a diff ahamad
exchange and we have a trust
relationship with with our each of our
clients as a trust relationship with the
our back-end common identity store like
I said before the identity is the key
piece of the puzzle here and that that
piece of information is so so we can
authenticate each other and then we
perform this defeat this Divya helmet
exchange so at that point in time I know
that modulo my trust in the our identity
provider I know that that I've shared a
something that's only available to you
or really only available to people who
are using the same identity provider as
you are and the and you have that same
level of trust in me the thing that
could happen here is that you can you
could if you own your if your identity
provider is compromised then you can do
a back to back user agent sort of thing
where you can emulate the the difficult
flow on both sides and and capture that
data in the middle so the key point of
trust in in this is always comes down to
that identity provider because that's
where you gain your authentication data
from we don't do anything to get around
that because for cisco the our customer
can be sure that it's off the record
because from a customer standpoint they
don't know whether or not we're writing
it maliciously in the cloud but they do
know that they're not getting a copy of
it set up to their cloud so what what
they can what they can ensure is that
there's the keys that because the
customer owns the the trust story on the
on the on the identity side the cost
more can tell that the you know whether
or not any they're the only ones who
could interject them into the into the
picture so if you work for Acme Corp
it's only that company so if you're very
sensitive about this you might you know
run your own identity provider not
really our business to sell that sort of
thing because we're generally kind of
the the market that were that Cisco
really plays in well is the kind of
enterprise market and we have a lot of
partners who then go to the smaller
markets and so a lot of this sort of
stuff would then be you know the partner
is the point in the trust chain where
that would kind of you know where the
rubber meets the road so there are some
other approaches that people have done
with this um like it from cisco
standpoint this is kind of we're solving
we're solving our needs we're not and
what you're describing the kind of
individual user versus the enterprise
we're really tailored towards making
sure that these these guarantees are
made to the enterprise and but but I
have seen a few other companies doing
interesting stuff in the space so for
example there's a chat program what's
Moxie's thing open with open whisper
systems tech secure is that text secure
in any event there's this company open
wistar open whisper systems that makes
this chat client our phone dialer for
Android and one of the things they do
for this is that they the way that you
authenticate in their system is really
clever you place a call and the same
diff extremes happens there etc and the
system then pops up a photo and you
describe the photo on the call to the
other person and once the other person
agrees that you're describing the same
thing you get on with your call so it's
essentially putting in band the
authentication process because there
again there's this is just a individual
level authentication trust is it is a
hard problem the only ways that this is
solved in in a cryptographically secure
way are you know rely on some mechanism
for key exchange for basically you know
like a chain of trust or something like
that
and chains of trust have proved to be
cumbersome they have never taken off so
that's why they generally speaking the
industry tends to look at some sort of a
trust provider that that does the
initial kind of trust level and then
from there on out you kind of
essentially relying on that kind of like
what you see with people either
implicitly trusting all that all the
route certs on their laptop or pinning
certs to a given you know intermedia or
a given leaf to be able to kind of
control that trust and so I guess the
short answer to your question is you
don't know you certainly don't know that
we don't store a copy but if we did
store it's an encrypted format you the
enterprise knows that you aren't storing
a copy or that you don't have access to
the keys and that's actually the
important thing when you look at the
kind of the reasons people want off the
record it's generally because they want
to have something that's truly ephemeral
where there is no record of it and they
can't get subpoenaed for that later and
so in that sort of situation even if we
did store an encrypted format the fact
that you the enterprise knows that the
keys don't exist anymore modulo one of
the clients you know grabbing them or do
something with them there's the the main
use case that we have for that is met by
those requirements
so absolutely the question is the pieces
of the puzzle are all here for subpoena
happens and that's why I talked about
different trust zones that middle part
is the spark cloud and we run that so
someone can come in and subpoena Cisco
the the KMS does not need to be deployed
into our cloud so that that might mean
that you might have a deployment
topology where the it's not sufficient
just as just a subpoena cisco you might
need to subpoena some other companies
too and most companies don't actually
care like modulo the off-the-record
question they don't they're happy to
respond to subpoenas Bank of America's
happy to respond to subpoena if they if
the government comes along and asks them
for some data the key thing is we don't
want to do that um so we don't want to
have to be the one a who manages the
process but be more importantly we don't
want to be put in the position of
needing to you know give the government
or you know whether it's US government
the German government whoever copies of
someone's data without definitely about
it and generally speaking from an
enterprise standpoint all the companies
are generally perfectly happy with with
with that approach they're not looking
to module little off-the-record they're
not looking to have a situation where
they say no we're not going to we're not
going to comply with lawful intercept so
this is not we're not designing a system
that prevents lawful intercept from
being possible we're designing a system
that makes sure that lawful intercept is
is visible to all the parties who would
be involved in in the conversations
itself yep
yep we do currently this this so this is
I'm talking through from an ietf draft
and also an implementation we've got
kind of most of this implemented in our
product right now and we do explicitly
call out certain algorithms in the draft
one of the things that we're looking at
doing within the IETF is moving to a
model where anything crypto related has
an expiration and has to be renewed so
you don't end up with it you end up with
drafts that are like the with specs that
are are basically have a time bomb built
into them so that you know three years
hence somebody's coming to be like yep
those also look good and essentially for
this purpose so that we actually can be
precise about things and say here's what
we're recommending because really the
double the details with with a lot of
cryptography stuff is picking the right
algorithms that make sense for the kind
of data you're looking at for example
there are crypto algorithms that are
great for text but terrible for images
and I don't have an example of this
handy back and I probably probably dig
one up there are a lot of crypto
algorithms where if you're using certain
types of block ciphers you end up
essentially seeing the differential of
the of the of the of the image in the
patterns that are created with but by
the block cipher so choosing the right
algorithm for the right job is really
important and right now what we're doing
this is we're being opinionated about it
and with with the knowledge that we will
need to renew it because we want to have
have an opportunity to be able to come
back and say yep those are old that's
that's compromised that's compromised
here's the new version of the draft
where we've gone and fixed it for the
for the for these things make sense okay
so the question is how are you
guaranteed that the key is secure the
third party isn't going to do anything
to disclose the key you're not if you
are communicating this with some third
party and they are malicious with the
with their key then you know the third
party can do whatever they want they can
take screenshots they could one of our
clients here is a guess what web client
so there's a JavaScript there's
JavaScript source that that you know you
could be putting a breakpoint in and
grabbing the keys and dumping them
somewhere that's certainly possible and
it's it's it's a it's a threat model
that we don't know of any way to avoid
cool place any other questions cool so I
wanted to talk a little bit more about
the this resource model that we're using
let me
Jesus builds take forever to skip
through so one of the things that we're
doing it's that's the UH again again the
model that we're building is one where
our key management system we actually
use it for a bunch of purposes and then
crypto is one of them but we use it for
some other some other internal purposes
as well but one of the model we've been
building it around is one where you have
a resource which is basically a
collection of users authenticated you
know authorized users and a collection
of of keys and so that this gives us a
lot of interesting opportunities and one
of them is that we can actually allow
each client or maybe each user depending
on different capabilities you're looking
for to have their own conversation keys
so in a given conversation when I'm
sending a message to Aaron I encrypt it
with my key he decrypts it with my key
but he doesn't rien crypt it with that
hehe encrypts his his data with
something else and this gives us a lot
of interesting capabilities around being
able to revoke access on a very fine
grained basis and be able to essentially
ensure that if we need to get rid of
data or want to do a key rotation event
or something like that we can do that in
a very targeted way so we have a more
targeted this is giving us a more
targeted granularity for encryption then
kind of all or nothing and it's turning
out to be a really interesting thing I
mentioned earlier that for the this this
kind of highlights the key rotation in
the single key sense versus the the
multiple key sense here and in this
multi key rotation here basically once
we know it for example if someone is
removed from a from a conversation we
want to make sure they can't get get
access to any any data that flows there
in um we can do a key rotation where
each each of the the active participants
is now starting to use a new key to do
that and that means we can let each one
of the active participants possibly go
in rekey old content this isn't
something we're doing right now but
another thing that we've had some you
know kind of p.m. level interested in is
well how about if we kick someone out of
a room let's also go and rekey all the
old content now it takes a lot of time
because
like if you're looking at files the
clients gonna have to redownload them
and rekey them etc but this gives us a
mechanism to be able to quickly
invalidate the old keys like note maybe
we hang on to them so we can run this
rekeying job but we don't hand them out
anymore and then slowly rekey all that
old contents that over the course of the
next week or month or whatever we can
make old content available again that
that we had to you know take down
because we we were worried about the
threat model so it's problem is turning
into a very interesting set of tools
having this per conversation a kind of
resource collection rather than one to
one with our keys it also means we can
do some fun stuff like for example allow
allow people to be able to have right
only access to a resource so i can add a
key to a resource but i can't read any
which is when when you look at things
from a security standpoint normally we
think i'll read only that's safe right
well it turns out in a privacy
standpoint read-only is a dangerous part
writing is just graffiti so if i can go
and write something into into a
conversation that someone's happening
well i mean as long as there's an audit
trail there about who's doing what and
win this really becomes if there's any
abuse it really becomes something that
you know Aaron's talked earlier about
about you know bot detection and looking
for malicious patterns is more relevant
to than really privacy because if all
that those systems can do is write data
into a room then there's really no big
deal so doing this per client
conversation key also allows us to do
some of those sorts of use cases where
you know content can be can be added by
an external system in a right only
manner it also lets us do things where
files can be can use different keys for
encrypting them than what's used for
other messages in the system which might
be useful if you want to be able to
share a file across your nose for space
reasons share a file across multiple
different parts of the system so it's
opened up a lot of doors for us to to to
kind of have a lot of flexibility in the
model and one of the things I'm really
hopeful about is that as we
kind of build that that model out where
we have this essentially resource
centric he authorization mechanism in in
the spec will have an opportunity to
make this kind of KMS model available at
something that's that's useful like much
more broadly than just just in our app
and kind of correspondingly make it
possible for us kind of collectively
industry-wide to be able to deliver kind
of cloud-based end end crypto solutions
without having to re-implement all this
this core resource notions over and over
again because this is well really let us
kind of step up the game for security
for what people are getting out of the
cloud today I mean it's like every week
we see another data breach of some sort
or another and that's really because if
you look at the cloud it's like a big
honey pot right it's just like hey
attack me I have a lot of people's data
right successful cloud products by
definition has a lot of a lot of data so
being doing end-to-end crypto on that
makes the the job of an attacker much
much harder because now they have to go
and attack all the different KMS nodes
rather than just looking for for one
kind of key store or data store rather
so that's that's what I have for you
guys do you have any any more questions
about the resource model or about
anything else to do with our crypto
story yep
sure so the search for the indexing part
of the search bar ok so the indexing
goes the allisons message to Bob that
data gets sent to the indexer which is
in the same trust domain as the KMS so
it can then go and ask the KMS for that
data and as this is as we imply in the
flows here this is asynchronous right so
Alice sends data to Bob it might not be
immediately searchable hopefully you
didn't need to search the thing you just
got anyway hopefully we can make sure
that that asynchronous number is low
enough to be useful and so that it then
generates the so it decrypts the content
so whether it's a file or a message
whatever it then token eyeses it so
breaks out you know all the different
you know words that are relevant and
stems all those words so that you end up
with stamina and instead of standing you
know etc and then makes an H Mac of that
so it then encrypts the the results of
that so the basically it's essentially
building an index but instead of what it
then sends back up to the spark cloud is
the encrypted index now but the but once
we go to the point of dink of searching
oops I went one bill too far the the
indexer goes and performs the same
tokenizing stemming etc and H backing of
the state of the search query of the
user typed in and then sends that up to
the HVAC database in the cloud to be
matched and now we're matching against
the encrypted against encrypted so the
index data is is actually you know
resolvable at that point even even
though the even though it's not totally
opaque to our cloud it's the the the
indexer can you know knows that that's
actually the right search term it looks
like looks like an encrypted a bunch of
you know junk to us
okay miss so the question was the OPI
store that the H back here is the KMS
and the answer is a KMS we're using the
KMS for a bunch of things that are not
and end-to-end crypto necessarily this
is one of them turns out once you have a
key measurement store that's you know
nicely tied to your your your
authentication channel you find all
sorts of things to use it for so it does
I I don't know if it provides that
detail in particular but the draft does
go into more detail there I got here
right here do you go to I ETFs well we'd
love your feedback sure does that answer
the search go anything else any other
online cool well thank you guys oh and
I'll leave this up here as well if you
guys want to see that draft this here's
the URL whoa that was weird if you want
to see that draft here's the the URL for
the the that resolves out to the IETF
drive</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>