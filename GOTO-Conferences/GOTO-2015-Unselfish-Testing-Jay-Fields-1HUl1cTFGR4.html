<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Unselfish Testing • Jay Fields | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Unselfish Testing • Jay Fields - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Unselfish Testing • Jay Fields</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1HUl1cTFGR4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right can you guys hear me in the
back everything good cool so as somebody
already said the like the presentation
will be Fight Club themed if you've
never seen fight club that's okay it's
not really that important I tried to
phrase everything in there and kind of a
way that made it a little bit funny but
also I expect probably half the room
maybe has never seen it so it's not a
prerequisite you still feel feel free to
leave if you hate fight club right now
but it's not a prerequisite I'm going to
skip the credentials slide I assume you
guys can look me up if you want to I
assume nobody really cares where I've
worked or what I've done what you really
want to know is how you can create some
better tests so when do we run our tests
I don't know maybe some people run them
all the time with auto test maybe some
people run them only in the build as and
never run them but a place that we often
run them is after we've just made some
changes and it's about time to check in
so that's what we're about to do we're
about to check in some code and we see
that our tests are running and then we
see this and that's not great but
what we actually see is this and
the problem with all of this is that
with failing tests you only speak using
profanity so what the changes that I
made here were I have a movie domain
object and then I have a movie test and
I've changed my movie domain object and
then I changed my movie test and I ran
everything and everything was great
customers should be happy I have new
feature ready to put it in production
but then I ran the test and something
failed and had what I thought was
nothing to do with what I was working on
so now I'm pissed off because I have no
choices this one has erodes I want to
check in but I have to look at a test
that i didn't write that i didn't run
that may or may not help me but i have
no choice but to go work with it so this
is bob and bob has bad tests
unfortunately bob is also your teammate
Bob wants to do well Bob wants to help
you write good code Bob wants to write
tests that will allow you to refactor
your code base and maintain your code
better but Bob doesn't know how to do
that because bob is actually a pretty
good programmer that's why he passed
your programming test to join your
organization Bob knows how to write good
code but he doesn't how to write good
tests and unfortunately Bob thinks
they're the same thing Bob left you this
test test is not that complicated but
it's significantly more complicated than
I would want to be left with
test is currently failing it's not very
long but before we can really even get
into it we have to already look at a
loop who wants to look at a loop and a
test Bob decided that he was going to
dry our code out with the lupinus test
so that's what we have and before we can
even really look at the meat of the test
we need to figure out what we're looping
through so we have customers length it's
not that complicated you know we know
what that is or do we at this point we
don't we have no idea we have a failing
test and we know that we have customers
we have no ability to look at the
failing tests and figure out what's
going on we have to rely on our IDE
which gives us easy enough go to
definition and cool we have customers
also not really that complicated there's
nothing here that's absolutely terrible
but we've already relied on the IDE to
take us somewhere to help us understand
what's going on and now we have to rely
on the IDE again take us somewhere else
because we don't know what a customer's
is actually initialized to you it's
initialized in this magic method given
to us by our test framework if we're
comfortable with this magic method then
that's great but what if we're not what
if we're pairing with someone and we're
mentoring them and they say why is this
magic method get run why don't I don't
know because because this is the way
we've been writing tests forever and
nobody stopped to say why so here we
have a setup method and we're
initializing the David customer and the
John customer and the Pat customer and
the Steve customer and then we're
putting them all and the customers array
which you already know that's what we're
going to use in order to loop through so
we're not going to look at the object
mother because let's not dig that far
down even though that's kind of the
point of this why do we have to dig that
far down but we only have 50 minutes so
back to the failing test looping through
customer instances we can finally get to
our expected value so we have a failing
test we've already had to navigate to a
Java field and to some special helper
method just to get through the loop and
now we're at our expected value and we
of course can't tell what I expected
value is either because it's using
another helper method so if we're going
to go to a helper method we have to
first initialize the args step one is
just figuring out what that argument is
again we have to use another go to
definition we can't work with in this
test I mean I hope this is painful for
you guys looking looking at as it is for
me presenting it these
tester terrible I i rehearse this
presentation in front of my wife she's
like can you maybe not give this
presentation so angry and I was like a
kid's assess make me angry so sorry I'm
probably going to be angry for a little
while we have another helper method that
we have to go into this helper method
doesn't even do anything that
interesting it's doing a little
formatting it's taking some strings and
rental objects and it's just putting
everything together and we don't even
have time to talk about the law of
Demeter violation because these tests
are so bad so we just I mean imagine
we're working with these tests we just
want to check in our movie change and
we're down inside to helper methods
looking at a law of Demeter violation
basically thinking like all right I
might need to look for a new job I can't
work like this that's what I would be
thinking anyways so we'll just ignore
that for now and will understand that
rental info loops over rentals returns a
string describing a rental it's not that
bad I guess back to the statement what's
next well we have a customer object that
we're looping through okay that's not
that bad I mean ignoring the fact that
we have no idea for Dave patter Steve
but at least we know what this object
type is even if we don't know what
instance it is and finally we can get to
a concatenated string that's not bad ish
so we go into the expect statement what
does it do it takes the customer takes a
few strings and in formats everything
together that's it all it took was all
of this code for us to understand what's
going on in that test we had a failing
test specifically the movie class
changed the movie test also changed
everything worked we knew that our code
was working but instead of being able to
check in we had to look through all of
this code that's for a customer class
does anyone in here think that's a
reasonable thing we shouldn't have to do
all that and there's a better way but
before we get into the better way we
have to say we'll all right so Bob wants
to help us Bob wants us to write better
test Bob Bob wants to write better test
for us he wants to help us write
maintainable code what can we say about
what Bob's done well he's set up it's
commonly approved in our industry sadly
but you can't really blame Bob for that
he
that he should dry his coat out with
setup and Bob dried his coat out and he
used object mother so he kind of hid
away his object creation somewhere again
just applying dry maybe that's good
maybe it's not i'm not here to actually
tell you that it is good or it's not I'm
here to ask you why are you doing this
so you just blindly applying it or is
there a better way so I'd say where it
fails is I would like to quickly
understand this test so I'm checking in
i want to quickly understand what's
going on with this failing test maybe
that failure was actually helpful but
going through all of the steps was not
helpful specifically so i had to find
the statement test to start with then i
had to find the definition of customers
that were iterating through then find
the assignment to customers then had to
digest the setup that i had to look at
an object mother which i didn't even
bother to take you guys through then I
had to digest each different customer
instance creation within the object
mother I do all of that before I
understood the first line of the failing
test that is entirely too much
complexity for you to have to look
through to understand the first line of
a failing test then you have to digest
the expected value being created by
calling a method with a string a
customer the result of calling rental
info to string instances and blah blah
blah find the rental info method
determine what its value is digest the
rental info method it's creating a
string and returning data and now you've
mentally resolved the Argus to expect
statement you had to do all of that ten
steps ten steps to simply understand
what's going on in this test and zero
characters that you have read so far
help you in production that's zero value
to your customers 0 value to your
business you have done nothing but
resolve the expected value of a test if
this were flight club this would be the
point in which he says I want you to hit
me as hard as you can no one character
that you've digested will run in
production not one we spent all this
time were eight minutes into the
presentation not looking at one
character that would ever be run and
helped the business in any way aside
from regression it's also practically
impossible to fix this test without some
more code more programming how do you
how do you know what's failing and
what's passing which is also helpful
without looking at the loop
and either putting a debug statement in
there to know where things break or
without putting some console.writeline
in there you have to write more code or
rely on the editor to give you a break
point or something you can't even use
this test to figure out what's gone
wrong so why why do we do this why do we
put ourselves through this we we used to
write code without tests and then
somebody said hey do you know you can
write these tests and we'll give you
confidence and you started going home at
night not thinking like everything is
going to fall apart and they're going to
fire me started going home with some
confidence that was great but we just
apply the traditional programming
patterns to our tests and we never step
back and say is this code different
what's different about the code is a
test really the same thing as production
should we dry it in the same way what's
our motivation for doing all of these
things we write tests we don't need with
time we don't have to satisfy people we
don't like what if we took a step back
this is the happy place from a fight
club what if we took a step back to our
happy place where we had no code and
that's all of our happy place when we
have no code to worry about take a step
back and we say all right what can we
write here to actually help the business
every line of code has an roi a return
on investment we only really want to
care about the stuff that's valuable the
stuff that actually brings the business
some type of value brings the team some
type of value so what if we took a step
back and we said you know maybe drying
everything in the exact same way is not
the appropriate solution maybe I need to
look at my tests in a completely
different way so again it comes down to
why what motivates us so let's say for
the sake of the talk that what motivates
Bob is he wants to enable refactoring
wants immediate feedback and he wants to
break the problem up into smaller pieces
i would say Bob succeeded in enabling
refactoring Bob gave us some tests that
cover the domain and I can change things
around and verify that everything works
I get the immediate feedback of the
tests fantastic Bob failed absolutely
terribly at breaking up the problem into
smaller pieces we have so many things
tied together in this test that it took
us 10 steps to even figure out the
expected value that's a ridiculous
amount of coupling josh graham you may
know that's
is twitter handle I once send a hit up I
once said to him why are you writing
tests why do you even bother write tests
and he said I like he said I to create a
tiny universe where software exists to
do one thing and do it well I think
that's my favorite explanation for why
you write tests you want a tiny tiny
universe to work within and you want
confidence that whatever you're testing
works as you would expect I mean
software systems are large they're
complex there's no way that we can
really get confidence around the whole
thing with a couple different tests we
need to break things down and test them
individually so we're going to keep that
in mind we're going to think about how
we can still have a tiny universe but
also we can apply dry it's not like we
should just throw dry out the window
it's valuable but how does it apply to
testing it's maybe not the same as
production code so these tests / dry of
course we use the helper method and we
repeated as few characters as possible
thank God because characters weren't on
sale so we had to save as many as we
could did you feel that the ah does
anyone here feel that the application of
dry helped you quickly understand the
failing test I keep waiting for someone
to say yes whenever I ask that question
I mean there must be someone and it's
okay that's actually part of this there
are three levels that that you can apply
dry and some people want to apply it at
all three and that's great if you ask
yourself why you're writing a test and
why you're drying it the way that you
are and if you come up with good reasons
for all of it maybe you're a two-person
team maybe both of you like tests
written in that way maybe you don't mind
looking through all of that code before
you understand what's going on a test
that's fine as long as you consciously
make that decision go for it I think
there's a better way personally I
strongly suggest you change your
approach I recommend applying dry at the
suite level so globally let's say that
you want a customer use the test builder
pattern and create your customers with
test builders let's say you want to move
you use the test builder pattern okay
great now in my customer tests I can I
can follow this builder pattern it's a
global reuse to dried up fantastic i
want a movie same thing so i have this
common understanding of code that's
going to be used across the test suite
instead of just at the fixture level the
problem with Bob's tests were all of his
application of
was at the fixture level that rental
info method is never going to help him
elsewhere the expect statement is
definitely never going to help them
elsewhere so we have all of these helper
methods that aren't really helper
methods they're just kind of like hiding
your in the closet I'm just going
to put these characters over here and
pretend like everything's fine but it's
not fine you've made things worse for
your team obviously I don't think I
really even need to get into drying cuz
of the test level that just makes sense
you want to dry things within an
individual test and you want to dry them
throughout the whole suite but maybe
don't try to group your tests together I
mean so Pat's a customer Steve's a
customer John's a customer and yet none
of those tests collaborated in any way
but all of those tests carried the
conceptual overhead of creating all
three customers so you've created all
three never use them in any way
whatsoever but you've required maintain
errs to try to understand that to verify
that there never used its waste it's a
better way in my opinion I would
approach same tests I would say don't
test diverse customers at the same time
if you're not going to test diverse
customers then don't create them at the
same time don't extract single methods
for a single string return value do
create data where it's needed not part
of some special framework method there's
no rule that says you have to use set up
just in my opinion to stop using
completely if you enjoy acronyms and
what programmer doesn't I think you
should write tests that are dry at the
suite level and dry within the test but
focus on the test itself being damp a
descriptive and maintainable phrase or a
descriptive and maintainable procedure
whatever you're looking for you want
something that you can go to this test
is failing okay ideally everything you
need is right there within that test we
don't have to rely on an IDE we don't
have to jump around and go anywhere else
everything that's failing is right there
the next best scenario is everything
that's failing is here except there's a
couple global patterns in here that go
in this maybe factory that creates all
of our objects whatever there's some
type of global pattern that you use but
it's something that when you go to it's
not completely unfamiliar to you it's
not foreign it's something that you've
seen before it's a pattern that you
already understand within the test suite
so how do we go about doing this for Bob
the first thing we do is we replace the
loop with the individual test I mean
this is as obvious as it gets so we
break the loop break all
these customers out of the loop and we
have more characters here it's fine each
individual test is now become simplified
now when things fail we actually have
results we can use instead of one loop
with one failure we have three failures
and we have one passing test which also
gives us some information on where
things have gone wrong so we know which
which customers cause problems we know
which customers are not causing problems
creating all of this is what some would
call duplication I expect there are many
people in the room that probably feel
uncomfortable with all of this that's
what people would consider duplication
but this is just step one it's only
after we've duplicated everything that
we're free to dry anything so the next
thing you want to do is expect literals
your site s look now and you have to ask
yourself why the hell we're calling a
helper method to create a string I don't
understand why anyone would ever want to
call a parameterised method once that
does nothing more than return a string
you know what the best representation of
a string is string literal that's it
there's no better representation of a
string then a string literal so
obviously sorry obviously this is what
you're looking for you don't need to
call a helper method it's okay you can
spend more characters I'm here to tell
you it's absolutely okay to spend more
characters if it makes your tests more
readable next thing you want to do as I
said is in line a setup so here the test
again and they're fine we've saved some
characters by shoving everything in
start-up and setup but they still
require us to go to definition and
that's kind of a pain I mean what did we
really save here we have a shorter test
but it requires us to go somewhere else
to figure out what's going on that's not
a good trade so these are the same tests
but everything's in line creating
instances of David John Pat and Stephen
setup moves characters out of the
individual test methods but it also
could also increases our conceptual
overhead there's really no valuable
reason to do that so here we take out
that in direction and we put everything
where it belongs this also gives us the
ability to completely delete both the
setup and all of the customer fields so
deleting code always a good thing less
to man let's to maintain and manage
so setup is clever Bob's tests are very
clever about applying dry and i'm here
asking how is clever working out for you
do you feel like the aggressive
application of dry is making the tests
easier to understand or is it making it
more complicated I mean we would maybe
apply this exact same approach to dry to
our production code but it that doesn't
mean that it just should be blindly
applied to our tests and the interesting
thing is that despite replacing the dry
tests with the damp tests the overall
number of the lines is exactly the same
exactly the same number of lines did not
go up once we took dry out of one area
and moved it to another area and we made
our code more clear we got to delete a
bunch of helper methods it didn't change
the number of lines is the same so we
can create more clear tests without even
increasing our character count or the
number of lines we have to read it's
obviously a good thing so we spoke
previously about motivators there are
several motivators not all of them good
so we want to validate the system this
is probably a good thing we want to get
feedback from the system we want to
prevent regression these are all kind of
synonyms maybe we want code coverage
some people want a hundred percent I
would say that's probably not a great
idea but it could be the motivation on
your team maybe you want to enable riya
refactoring obviously a good good reason
to write tests documenting the system I
personally have never written a test of
documented system but some people love
this and that's great if it makes you
more effective it's a fantastic
motivator go for it as I said not all of
them are good reasons but I mean I'm
sure somebody in the audience doesn't
even really believe in unit testing or
has had a lot of pain with unit testing
and they have that manager that will not
let them get away from it they want to
know why dhh and other people are
telling them that unit tests are dead
and tests should go away and they have
so much pain they don't know what to do
and their manager will won't let them
let it go this is not a great situation
to be in obviously but that doesn't mean
that you should just suddenly say like
well I'm going to kind of ignore unit
tests or I'm going to do something
different round unit tests so i'm going
to write bad unit tests understand what
your motivation is and then how that can
impact your unit tests and then write
them in a better way I mean
realistically if you don't believe in
unit tests but your manager requires you
to first of all if he's never checking
your code he
he's never checking your code then you
can probably not even ever write an
assertion and then everything else just
pass and everything's fine right and if
they are checking it then it's in your
best interest to write the most
maintainable unit test you possibly can
right if they're checking the code and
you don't believe in it and you never
want to look at it again right the most
maintainable test you can so that it
never fails and then you never really
have to worry about it tdd is probably
the most common reason for writing unit
tests you want to break up a problem or
improve your design I think those are
pretty much synonyms customer acceptance
I would never advise anyone to do this
but I once worked on a project and we
had to have a green test suite before
the customer would sign off on a feature
so we would go to the customer and say
we would like you to sign off on this
and she would say okay manually test it
perfect looks good okay show me the
green screen you just open or you just
go to the web page and say here screen
okay check it off it doesn't make any
sense to me but it's it's a motivator
it's going to happen to you possibly at
some point in your career so it's worth
understanding all right in that case so
now if these things ever go red for any
silly reason we don't get sign off and
we have to talk about it we want to
approach our testing differently in that
case I suggest talking to the team
everybody coming to a shared vision of
why you're writing the tests tests can
be written for many different reasons
assuming that test is necessary is not
necessarily the right thing either right
tdd is a fantastic technique I don't use
it all the time I probably use it twenty
percent of the time right now to be
honest more of a fan of using tools kind
of for where I think they're going to be
the most helpful so I do a lot of
experimentation with repli driven
development these days and much less TDD
if I were still working in Java all the
time then I would probably do more TD
but apply these things in ways that help
you but also ask yourself why again so
let's say I'm working in Java and I want
to get all of the benefits of doing TDD
in Java and so doing my TDD right got a
bunch of tests don't just commit that
and walk away you're not asking yourself
why at that point I mean why did you
write them because you wanted to do TDD
and it helped you improve your design it
helps you write better code and that's
great you had it you had
reason why but because it helped you
write the domain code doesn't mean it
will help you maintain the domain code
so take a step back and look at every
test and say why do we have this test if
it helped me design code that is now
designed and you have no other motivator
than the only correct choice is to
delete that code any fool can write
assess that helps and today good
programmers write tests that help the
entire team in the future if you
remember nothing else from this
presentation this is what I would like
you to take away it's so easy to write a
test that helps you in the moment for
your current problem it's one step
harder to think about helping yourself
in the future you come back in three
weeks three months you look at that test
again is it written in a way that's
going to help you maintain the code and
if the answer is yes great now go on to
step two don't stop go on to step two
and say if I've never seen this code
before and I come to this you know put
yourself in your teammates shoes if I
come to this test is it helpful don't
stop until you can also say yes you know
and that means looking at the failure
not just the pass look at the failure
what is the failure message say if it
just says you know expected something
was false that's not really helpful that
doesn't tell anybody what's going on
maybe the string describing the test if
you have a test name maybe that's
helpful if it's not helpful enough again
if if you come to that completely blank
as weekend to these tests at the
beginning the presentation if it's not
helpful change it think about your team
so what can we do some specific concrete
examples it's pretty much what this
presentation is about is concrete
examples of all of this this is your
career and it's ending one test suite
run at a time how fast is your test
suite who in here has a test suite that
runs in under a second come on really
okay I won't ask about ten seconds how
long's your test we take care yeah so
that's where it should be if your test
suite takes longer than that people
aren't going to run it people aren't
going to run the test suite before they
check in because their career is ending
one test suite run at a time nobody
wants to sit there I mean what what do
you call that time while your test suite
running I call it waste cuz i'm on
twitter or i'm on email or somewhere
probably worse be honest i mean we're
not working we're wasting our time
looking at who knows what on the
internet so make your test run faster
the easiest way that I know how to do
this is to create solitary unit tests so
some people just call this a unit test
but other people call many other things
unit tests so when I was writing a book
on all this stuff Martin Fowler said
just stop trying to steal the phrase
unit test they're never going to let you
steal the name unit test come up with
something new and thus solitary unit
test it's pretty simple never cross a
boundary so your test suites are slow
because you're hitting the database
you're going over the network you're
going to the file system that's really
what's slowing everything down it's not
like the internal computing is slowing
everything down in most cases so stop
doing that right solitary unit tests
that never crossed boundaries but a
thing that's also very annoying as
cascading failures you change the movie
clap the customer test fails that's
annoying that that's not that's not
going to help me get through my day
faster that's not going to motivate me
to be excited about being on this team
cascading failures take away my
motivation to be a software engineer so
the class under test should be the only
concrete class found in a test that's it
this is the full definition of solitary
unit tests and I actually have no
examples of stopping something from
going to the file system or stopping
something going for the database because
I think that's pretty self-explanatory
you can write solitary unit tests that
don't cost any type of boundaries yeah
um by concrete here I mean mock or stub
yeah we'll have some I have some
concrete examples so we need some type
of other phrase right we have solitary
unit tests we need something to say what
the other tests are because those are
valuable also and those are sociable
unit tests it's it's that
straightforward so as of now we have
vastly vastly improved sociable unit
tests but we have multiple what I was
calling concrete classes we have the
customer test talking to the rental
which talks to the movie any change to
movie is going to cascade to all of
those other classes so what we have is
better but we're still entirely sociable
we have no solitary unit tests at this
point and I believe a good mix of both
is really what we're looking for we're
looking for some some type of actually
as much coverage as we can get from our
solitary unit tests because they're fast
because they don't go over the network
because they're not flaky because they
focus with one concrete unit test or 11
class under test and some mocks or stubs
so this is what we have right now in my
opinion this test is already a pretty
solid test this is a great test this
test fails before I check in and I know
that I have a customer with a rental
with a movie that is a new release and I
can read an expected value without
navigating anywhere I mean it's almost
heaven compared to what we looked at in
the beginning so this is great but the
problem is again if a movie changes then
this test could fail we don't want this
test to fail because this is doesn't say
customer test class but this is in the
customer test class so we we don't want
our movie changes to break things so
this is it this is concrete example of
using I would just call this a stub to
be honest but I'm working with mockito
and they call it a mock I don't think
the semantics here are really important
but we're working with not our rental
class we're just working with a mock so
any change at this point to a rental or
to a movie will not cascade back to our
customer tests and you may have noticed
the null and you may have thrown up in
your mouth a little bit to me this is
the same thing as Godfather right
we have a magic string in there that
says Godfather for and then we have a
magic string in there that says no
what's the difference between those
characters within the context of this
string but I just feel like as
programmers we have this gut reaction if
like oh why does he even know oh it must
be a mistake I mean I'm sure there are
people in this room who definitely
looked at that when i put it up and went
a whole he made a mistake he left a null
in there but it's just a magic string
it's a magic string on both sides so
what's the difference between Mel and
Godfather but okay they're still gonna
be people to take exception to that and
that's fine because you have a stub and
you just add some value in their ad
Godfather in there and move on I'm just
putting this up here so people so the
people who feel comfortable with null
will get some validation be like it's
okay so we also have solitary unit tests
that focus exclusively on summing this
old test let's go back real quick this
first test on the left it has string
building it has summing it has a lot of
different things happening this test is
covering many different things and you
don't necessarily need to hear we can
focus exclusively on summing so we have
a mock rental that we're setting the
charge for on the left and we have a
mock rental that we're setting a charge
for the points for on the right and then
we set up our customer and we just
validate the value these are beautiful
tests these are tests that you can come
to with never having seen it before none
of you've ever seen this test before and
if this is failing you know exactly
what's going on it's completely
straightforward you don't have to
navigate anywhere I mean maybe you have
to navigate to the Builder if this is
your first week on the team first day on
the team maybe you've never seen a
builder but we use these builders
globally throughout all the tests so
even if it is your first day you
navigate to the Builder you see what
we're going what we're doing we're
creating some instances no big deal cool
for the life of the project you now know
what we're doing when we're creating
instances and test you know that we're
using builders you can reapply this
value even if you had to spend that time
on this first test you can now apply
that across the whole test suite so we
lost some coverage you know we had a
null in there and we broke out our
summing and we we lost the corner case
tests that we were doing on the movies
now we get it back well it's nice about
this so now we have confidence in our
fine grain customer tests and we have
confidence in our movie tests and we
have all of the coverage that you had
previously seemed summing of points is
tested summing of charges is tested
string building is tested but also all
of the the domain cases for the movie
class all tested so with complete
confidence in our system but we also
gained isolation something that we did
not have in any way whatsoever we no
longer have cascading failures
specifically any change to movie will no
longer fail that customer test extremely
valuable when we run our tests we know
anything that's failing is actually
failing because of a change in that
domain class as long as we're talking
about a solitary test this should be
great it should make our lives better
but we're missing integration right
that's the one thing that we don't have
we have great isolation astic we have
speed fantastic but we don't have
integration and that's why you should
never choose one of these approaches
exclusively choose the tools that make
you effective that means a little sum
over here and a little sum over here
that means for me twenty percent TDD
these days i'm still using it i don't
have to make an exclusive choice to TDD
everything or nothing the same thing
applies here this is a sociable unit
test that brings everything together so
now we have our tests that don't that
don't cascade fail every test that don't
take a long time to run and then we have
this brings everything together it's got
a customer named pat with a rental with
a movie that's a new release and another
rental that's scarface you get the idea
we have multiple we have one customer
with multiple rentals multiple movies we
can tie the whole thing together and
there's no nulls to make anyone
uncomfortable so I else can you approve
the test suite one assertion for test I
know there will be people that take
issue with this I'm here to make my case
but then ultimately it's up to you on
what you think's more appropriate so
this is again the movie test that we
already saw let's say the second
assertion fails this is what you're
going to see I mean I was going to say
what do you think but you know everybody
knows this is what you're going to see
one failure five assertions one failure
what's the value of the third fourth and
fifth assertion at this point it's zero
it's worthless maybe it's passing maybe
it's failing we have no idea code didn't
execute so you know of one failure and
you have zero automatically generated
feedback from the other test from the
other assertions given a test with
multiple assertions when they're all a
path when they are all passing they all
provide value I mean obviously they're
all passing fantastic life is good you
wrote that test they all passed and you
thought moving on but then that first
assertion fails and it has completely
avoided the value of every other
assertion they're just worthless they
might as well not even be there there
may be worse because they're noise
providing you know value they're sitting
there and they're giving you nothing so
in effect their noise it's negative
value when you're faced with a failing
test that has multiple assertions your
force between two shitty situations the
first situation is reading all of the
tests and then reading all of the domain
and deciding that everything's fine you
know assertion two failed all right i
mean figure out what's wrong fix it cool
all right now three four and five are
there what are my choices read
everything and make sure it's all right
of course not because we're all lazy we
just click run again and then for fails
and five is worthless and we go fix that
and then we run it again and maybe five
fails we just go through this sad loop
of running fixing running fixing and
doesn't have to be that way what if we
got all of the data that we needed at
the same time what if everything failed
when it was supposed to and passed when
it was supposed to at the same time
would not be more effective well the way
that you have to do is just break these
assertions apart just don't use multiple
assertions it's not really that
complicated but part of this is
obviously well I don't want to I don't
want to repeat too much code okay cool
use builders use some type of global I
application that allows you to quickly
create your tests if you can't quickly
create your tests like this break things
apart into a single responsibility
there's another problem it's it's not
multiple assertions versus a single
assertion there's some type of other
problem you can't create your domain
classes easily enough or something you
have some other problem don't hide that
problem by using multiple assertions
instead
do this so once we have this now we
actually see this so this is much better
now we have some type of some we have
additional info the exact same
assertions but now we have additional
info we can see that the first failure
is 43 day the second failures 44 day the
third failure is 45 day we can also see
by looking at the expected values that
everything every single expected is one
and a half less than the actual so just
having all of that data at the same time
would be better but now we also have a
pattern that we can work with one
assertion per test allows us to get the
expected values and the actual values
for every single test which is clearly
better having all of that date at the
same time but now we have a pattern what
do we recognize from those failing tests
anything above two days was failing
everything that was failing was by off
by one and a half so the sum of those
values those those failures had more
value than the parts so break your test
up into multiple assertions wrapping all
this up the test you own end up owning
you it's another cute little quote from
from fight club but it couldn't be more
true every line of code you write has
some type of return on investment it's
either positive or negative maybe it's
flat but more than likely it's positive
or negative you have to own every single
line of code in production but also in
your tests so get your tests from an roi
perspective let's say for example you
wrote some code TD deed some code and
it's going to change the color of a
background on a website this is not
crucial to your business but utd deed it
fantastic it helped you create the good
design to change this color fantastic
you've done everything right but then
let's say the test is a little flaky it
fails now and then maybe there's a race
condition because of the framework that
you're using something like that delete
that test get rid of that test
immediately if that background color
doesn't change correctly your business
will go on someone will complain at some
point and you'll fix the background
color and the user experience will be a
little off for a little while it'll be a
little bit disappointing but business
goes on but all of the time you waste on
that flaky test that's just making the
user experience that much better is a
complete waste to to you to your team to
teammates to the business look at your
test in term of terms of ROI another
another example that I like to go back
to is you have an insurance company and
the insurance company needs to look up
all of its customers by social security
number you should probably have a
validation on that social security
number you want to get that SSN right
you need to be able to look someone up
but that person has a first name and you
know maybe you put a little test in
there to make sure that it's all alpha
that comes through because it's nice you
know be nice to get the customers name
right but you don't need the customers
name to be perfect to build them you
don't need the customers name to be
perfect to contact them you know you can
look them up someone calls the call
center if I get your name wrong and you
call the call center everything's going
to be okay if there's an extra one in
there or something like that so if you
can write this test easily and maintain
it easily then do it but if this is
again a flaky test or a problematic test
what's the real value to the business I
mean really keeping that one out of
someone's first name what's the real
value to the business it's not very high
stop thinking about your test from the
individual point of view stop thinking
about them from okay I like TDD i'm
going to write this test and that's it
that's the that's the end of what needs
to be done commit that's not good enough
start thinking about it from your team's
point of view you know you wrote that
test and it helped you get good looking
code and that's great but that's not a
good enough reason for it to live on
what you need to do is look at it and
say okay I came to this with a fresh
mind I understand exactly what's going
on here it's going to help me maintain
this code that's a good test worth
keeping your tests are not special
they're not beautiful or unique
snowflakes the same decaying text as
every other test fight club again think
about the team that's that's what I want
you to leave here with I guess more than
anything else think about the team don't
think about what you're doing in the
moment think about the long-term value
of that code think about maintaining
that code a year from now so that's
really kind of the bringing all the talk
together I also clearly passionate if
not angry as you can tell about bad
tests so I did write a book on it
welcome to check it out and i also tried
to finish up early so we could all get
to
surely beat everybody else but we have
at least 10 minutes for questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>