<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Without Resilience, Nothing Else Matters • Jonas Bonér | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Without Resilience, Nothing Else Matters • Jonas Bonér - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Without Resilience, Nothing Else Matters • Jonas Bonér</b></h2><h5 class="post__date">2015-10-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/beC49rexj7I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm a Jonas paneer I'm the CTO of
type-safe being involved in the open
source community for quite some time and
I'm here to talk about resilience so
let's get right to it we have a lot of
ground to cover so how how many of you
would like to go to production this
should be sound anyway I just turn this
up then how many of you would like to go
to production with an application that
is beautiful responsive scalable highly
concurrent resource-efficient loosely
coupled well yada yada yada well we all
do right and guess what none of that
matters unless your application is
actually up if it's actually available
so I mean really with without read
without resilience nothing else matters
really that's it starts and ends with
resilience so most of you probably
recognize this song I at least some of
you i hope i mean it's from one of my
old time favorite movies from since i
was a kid rocky the first movie and this
is like is it's it's a theme is that the
theme song and it's if you don't know
right the rocky movies it's it's about
this underdog media calls him the
Italian stallion and he's he's he gets a
shot at the title at the title and and
some of you might remember this quote
just what is it's one of the most
memorable ones but it ain't how hard to
get hit but it's how hard you can get
hit and keep moving forward how much you
can take and keep moving forward that's
how winning is done this is fault
tolerance right you get hit you
hopefully survive you limp along for a
while and hopefully eventually you will
win well often you don't like rocky
actuality didn't didn't do this in this
movie the problem is that fault
tolerance in my opinion is not a
sustainable strategy still we talk a lot
about it actually what we need and what
I'm going to talk about this talk is
resilience
and resilience is beyond fault tolerance
so we're going to cover what what
resilience is why it's needed how how
other industries and like in sciences
are more sciences probably industries
are dealing with it and what we can
learn from that and apply that in in in
the context of software development so
that's sort of the story for today so
what what is resilience it according to
merriam-webster it's the ability of a
substance rahbek to spring back into
shape the capacity to recover quickly
from difficulties it's not just a limp
along like rock your actin and so on is
actually to be able to fully restore
original funky funky functionality and
ending like in in order to take yet
another beating and yet another beating
right not just to survive some of you
have might might have heard about anti
fragility so it's it was popularized by
this the writer in sm Nicholas Taleb or
tell em and it's it's it's defined as
and anti fragilities beyond resilience
and robustness the resilient get resist
sharks and stays the same while anti
fragile gets better it really defines
systems that increase the resilience or
there or the capacity to to deal with
failure when it's getting hit it gets
harder and harder just like you like
human bones you know they get harder and
harder and harder and can take more and
more hit right but I really believe that
we have a long way to go in computer
science and I mean this all leads into
like adaptive system system to
introspect themselves and so on we're
not we're not really there yet so I'm
going to focus on resilience in this
talk even though I find this concept
extremely interesting and exciting and
intriguing hopefully we will get here as
an industry but we are we are a very
young industry compared to a lot of
other sciences so we need to have a
little patience right Sydney Decker said
that we can model and understand in
isolation but when released into
competitive nominally regulated
societies there
connections proliferate their
interactions an Indian interdependencies
multiply and their complexities mushroom
and we are caught short they did this is
from Sydney deck is great book drift
into failure its a really good read it's
not tied to computer science at all but
there's a lot to learn here but at the
essence of this code that the way the
way i read in it is like modeling the
world is extremely hard and and insist
and software systems at least most of
the ones we write to see out here are
incredibly complex and I think if to
really understand resilience in computer
systems we need to understand what it
means to do to build written to create
resilient complex system but what is
complex in and in how is it different
from complicated this is a complicated
system complicated systems are usually
have many different parts I mean they
are actually all different and each one
has a precise role in the machinery
somehow and it's possible usually very
hard but it's actually possible to fully
comprehend a comp a complicated system a
complex system though instead is amiss
me sorry it's made of many similar
interacting parts we are simple
individual rules that sort of leads to
emergent properties and it's the
interactions that actually produces a
globally coherent an interesting
behavior and it's by definition
impossible to understand this is Game of
Life you know this has extremely simple
rules but anyone can I a kid can
understand them well but once you start
putting them together they can create an
incredibly complex behavior that's
impossible to understand and even more
impossible to predict okay and and it's
a complicated it's not the same thing as
complex that's very important to
understand and and don't don't hella
meadows I don't know if you know she's
written a lot of she she's written a lot
of good books about and done a lot of
research on on thinking in systems and
systems thinking she she she wrote about
points for human intervention in complex
systems I mean we're humans I should go
in and try to learn
in the knobs she writes and I quote
counterintuitive that's Jay foresters
word to describe complex systems
leverage points are not intuitive or if
they are we as humans and intuitively
use them backwards systematically
worsening whatever problems we are
trying to solve usually humans just
makes it worse because we can't
comprehend systems like this it's
impossible by definition impossible okay
so instead we need good models to learn
how to think and understand failure in
complex systems why it happens and what
we can do about it and and we really are
always operating at the edge of failure
this is actually the title over a really
good talk by Richard cook he wrote about
in this paper as well I have all the by
the way everything I'm talking about
here I'm referencing you the long list
at the end if you're interested we're
going to share the slides afterwards if
you want to dive into this as well and
this is a great talk and he Richard does
a lot better job talking about this a
night and I'm doing but i'm gonna i
found this model of understanding why
was failure happens extremely
enlightening to me so i'm just going to
share it with you okay Richard good bye
bye bye and by the way he's in he's an
MD doctor researches that be studying
resilience in medical systems for for 20
years or more so in in this modalities
days colleague Rasmussen came up with in
97 we have three different boundaries
first we have the economic failure
failure boundary we as a businessman we
need to stay within this boundary if you
if you cross this boundary and go
outside then you go out of business
money runs out okay then we have the
unacceptable workload boundary this
means that if you cross this you can't
produce any useful work you most likely
fall asleep or like your full exhaust it
burned out or and hands and so on this
actually happens you know startups
shipping wanted over like battlefield
situations or like catastrophes or stuff
like that and then you have the accident
boundary if you cross this boundary then
then you fail for some definition or
failure it can be you know
no money is lost nuh Noah I know out no
outages see if its medical system the
patient doesn't die and things like that
and then and then we have an operating
point and this operating point moves we
need these within these boundaries it
constantly moose is moving because
business changes right the different
pressure is changing and if we cross
this boundary again we get it we have
failure okay so now what can we do with
this yeah we have three different
pressures and the first pressure is is
like management is always you know
trying to minimize the risk of going out
of business pushing for more economic
efficiency and then we have the gradient
towards least effort you mean we assume
is we don't want to do more than
absolutely necessary we want to go home
to our families and and and and and and
just get things done right and then and
not do more we're lazy by by definition
and and then we have the soap sorry so
and these two then naturally like tend
to push the operating point towards the
accident boundary just naturally okay
and and then when we cross this boundary
and we have both in some sort of outage
then everyone's panics right we say oh
yeah we we we need it was / blame the
software blame the architecture blame
the processes so we start to equipment
change the bundle stuff you know shame
and I don't know that the processes of
the rules or something like that and the
end and that pushes the operating point
like closer to the middle again but then
in the time passes and we forget about
it and then we end the operating point
starts to to to drift again towards
their dad the accident boundary so
history repeats itself and and and so
you might wonder then why don't we have
sir failures all the time you should
expect this drifting and crossing this
operating as the accident boundary all
the time it's actually because we add
it's normally just intuitively what we
call the marginal boundary here so we
have an error margin and this margin is
usually defined by our son some swear
rules keep the speed limits on the road
it can be you know we don't know we
don't gonna accept more users than this
at simultaneously way and answer
on and and and and you know and when we
start moving to close towards this this
virtual boundary then we realize okay we
need to do something and and it means
that we are likely not to actually cross
the error margin yeah so then the
question if we have that if we have this
marginal boundary this there is Error
how come we still have failures outages
and things like that it's actually
because because we you know we know we
usually know very we know a lot about
the marginal boundary because we have
defined it that's tangible even those
virtual is actually tangible because we
are defined you know the numbers and
stuff that defines this but we knew very
very little about this accident boundary
it's not until we actually cross it that
we know oh here is what the accident
boundaries i didn't know that we make a
note to that but then that II select
phase away and so instead you know and
and and and and the economic you know
the push towards economic efficiency
means that we all we always like try to
children's you know try to cross this
boundary I mean Richard cookie he makes
his great example of you know a little
little kid that you say I'm you're
standing at the stove and you have a
three-year-old I say don't come close
here and the kid you know he's like you
can't cross this you know you know that
line here and he like walk straight up
to the line right there you know and
then when they don't look it like takes
one step and then once they're back and
the next time one step and one step back
you know and like soon as you I mean
within a few minutes is standing right
next to you in the kitchen and it didn't
this is exactly how we how we do it
right we try to cross the boundary and
then take a step back and try to cross
the boundary ave and after a while we've
been doing a so many time so so it feels
natural I mean we're doing it for two
months knows nothing happened and then
we move the boundary know so this is
called normalization of deviance diane
von wrote about this in the Challenger
launched decision sir yeah when when
they when they sort of examined what
actually caused the them to you know to
push the error margin so far that
the Challenger you know the rocketship
actually exploded it's also called
flirting with them with the margin and
we get closer and closer and closer and
after a while we'll cross the accident
boundary and we're back to zero and need
to start over again okay and I think
since we're always operating at the edge
of failure we need to learn to fully
embrace failure I believe we need to
design for failure from the start need
to have a way of managing failure
instead of trying to prevent it okay so
let's look at how some other sciences
manage failure so starting with
resilience in in in social systems a
friend a friend of mine that the let us
research in social ecological systems
and energy efficiency and stuff like
that sent me this this great paper it's
it's it's a very interesting one in my
invite in my opinion is called d dealing
is seasons insecurity understanding
vital services and how they keep us safe
and it defines you know you have we as
individuals we have six ways to die
three sets of essential services and
service and seven layers or layers or
protection and the six ways to die is
that we can die from being too hot to
cold hunger thirst illness or injury and
then we have three is a core set of
services essential services around us as
humans to help us prevent from dying and
that is shelter shelter can pretend
implicant can help us against being too
hot and too cold we have supply you can
see here are the different light ones
like the slices of the pie by the way
sorry or are there or this or the the
waste you can die and then we have a
supplies is against hunger and thirst
and safety prevents us from illness and
injury and and these services are then
laid out the cross in different layers
to prevent us from dying so we have
seven layers of infrastructure there
might be more right but but this paper
defines seven layers of interim via of
infrastructure that prevents us from
dying so going from from the top where
we have the world for example let's lock
can be like Mark it's like food markets
energy markets fuel markets is only in
the way the country they can be like the
police no the military i mean the
regional can be the police city we have
hospitals and in water plants and stuff
like that the neighborhood we have like
food shops you can go and buy stuff food
you know our home yet we have our house
we have heating refrigerator cooling all
these things and and and then all the
way down to the individual so we are
like protected by these layers of
infrastructure that we don't even think
about to prevent us from from from from
the worst outcome be dying and we I
think this model is very interesting
like I'll come back to that later in the
in this talk and not enter and we'll try
to apply it to to software engineering
rinette Biggs defines seven principles
for building resilience in general in
social systems and the first one is
maintained diversity and redundancy you
know you know systems with many
components are usually a lot more
resilient assistance with few components
because because that if you're many
components that means that some
components can compensate for the
failure in in in others this gives us
our insurance policy not you know the
same don't put all eggs in the same
basket hey manage connectivity is
another one you know connectivity can be
both good and bad it means like that the
connection they recover more quickly and
learn about failures but it also means
that disturbance is spread more rapidly
in the system so it's not it's not all
good but it's a court rate for
resiliency social systems and the other
one is is serving manage slow variables
and feedbacks the feedbacks can serve
both help us look in the reinforce and
appen so it's also important to note to
note in the war to know what you deal
with here in general foster complex
adaptive systems thinking this this this
system they introspect and they adapt
and learn as well as I said we're
probably not there in general when it
comes to to software systems but I think
hopefully we're getting there I'm doing
a lot of been doing a lot of reading
like Google but when you know classic
control theory and stuff like that
trying to apply that it to distributed
systems but we have as I said a lot of
work to do without going through the
rest I'm just going to dive into
resilience in violin bow
logical systems I I learned I learned a
really interesting story about meerkats
when I was when I was did some research
on this and I it was from this from his
TED talk by Nicholas peroni on
complexity theory and this is it's a
story about about America's you know I
personally really love miracast there I
think they're really cute and funny and
they lyrics I've got carried away a
little bit this indeed a lot of studying
America's and they are extremely they
are extremely social social animals they
have extremely complex behaviors and
then like it and then and it's I won't
go go alpha off it off too much of a
battalion here but you know you know
they have it's only the dominant couple
in the in the in the in in his work in
the colony in the family or the group
that are allowed to have babies all the
other ones are supposed to be servants
and you know babysitters and and and I
think that's really that's one of the
really interesting things and then in
this experiment GPS trackers were added
to to to everyone either in the meerkat
colony and they were absurd going from
one feeding place to the next and it was
the dominant female that that led the
whole group to erode that they had to
cross to get to the next feeding place
but then when when she got to the road
she stopped and she gave like way for
all the South all the subordinates to to
cross the road and to like ensure that
that was safe like if they like didn't
come back min or like she could see them
being hit by the Rose you know okay I
mean I should probably shouldn't cross
this road so she was lucky way of
ensuring that she was safe by delegating
to others okay and and is actually
nature that has sir evolved this
practice for thousands of years because
the dominant female she's the only one
that can they be babies she's extremely
important to the group so these patterns
have evolved like as a way of improving
resilience and I think this is a very
interesting behavior that i will come
back as well too when i talk about so
resilience in software systems so what
can we learn from resilience in
biological systems you get yeah i mean
the first top once as actually
I mean I have said I have all the quotes
it's no nothing just something I'm just
making up the top one is yet again
feature diversity and redundancy and and
then the second one having again again
it's it yet again like make sure that
your system is really well-connected in
the sort of network structure where you
have wide distribution across all scales
and have the capacity to sell feel to
adapt and self-organized so very similar
to to the to the top 40 Brazilians in
social systems and Nicholas produce some
sums it up pretty pretty well with this
animals show extraordinary social
complexity this allows them to adapt to
respond to changes in their environment
in three words in the animal kingdom
simplicity leads to complexity that
leads to resilience and I think we have
a lot to learn here when it comes to
resilience in computer systems or start
or software systems as well so I covered
like took up like half of the time up
till now to see what we can learn and I
will try to apply some of these
techniques now an idea seen into
computer systems and see where we land
okay unfortunately we often react
something like this you know first night
at all and then we complete panic and
and and and this is actually a great
paper that i really encourage you all to
eat how complex systems fail by Richard
cook I think this is the probably the
most important wisdom in this talks if
you remember one thing remember this
that complex systems were always run in
degraded mode complex systems meanings
almost any software systems almost any
run all this run as broken systems okay
they are always failing somewhere that's
a fact we can't just we shouldn't even
try to prevent that from happening
because it's a fact I believe instead we
should make sure that we build systems
that are resilient by design so the the
most fundamental lesson that I learned
on my journey towards building resilient
systems is that resilience is nothing
you can bolt on afterwards even though
we've been historically trying to do
that for way too long sometimes buying
expensive tools you know a maternal cost
ring or logic or whatever hope for the
best you know it
never ever works just cost you a bunch
of money this is actually this picture
is from a home in gill Christ Texas is
it's this home was designed to resist
flood waters and it was one of the few
houses that survived the hurricane ike
in 2008 just because it was designed for
a silly ins from ground up okay so now
let's look at some patterns and
strategies for how to manage failure I
really think that we fundamental have to
change the way we think about failure
fated failures in is inevitable it's
actually something natural you know
failures are called exceptions in Java
and Scala and C++ it's a terrible name
it's nothing exceptional about failures
something natural it will happen always
happen in complex software system some
somewhere and since it since it is
completely natural we just look at this
as a natural state in the applications
lifecycle you start it up you stop it
you might resume it you upgrade it and
the end and it fails and if it's part of
the regular life cycle of the
application when you end up in the
failure state in your state machine it's
nothing to be upset about you know
exactly how to get you actually expected
that to happen okay so we need to think
we need to start designing for failure
and fully embrace it and find a way to
manage it ritika calls in this paper
says that post-accident attributes into
root cause is fundamentally wrong
because a verte failure requires
multiple false there is no isolated
course to an accident what is saying
that is there's really no root cause not
in a complex system don't spend time
looking for it you might find something
I mean that comes up you might find a
credible story but it won't help you
much I think you most often will be
wrong and it will often even make
misleading actually instead I think you
should spend your time thinking about
strategies how to manage failure instead
and get out of the failure state and
learn from that one core philosophy is
to embrace crash on this software this
is the field in the name of a paper by
bike and AI on Fox and and it's a very
simple model where were you if you
distill that down the paper to just one
sentence it's essential
stop is crash safely just crash when you
want to stop it up case to start is
recover fast essentially and this can
help us recover from latent
deterministic bugs called caused by ink
ink inconsistent state and it's really
it's really like having a sledgehammer
to the problem I agree at least if you
apply that to coarse grain level but
it's a very useful one and and also I
just want to since i'm on this paper now
just when I want to really read up a
quote that I think was was really
important they were tie into protocols
that I will talk about later and I quote
jamaica system of interconnected
components crash only must be designed
so the components can tolerate the
crashes and temporary unavailability of
their peers this means that one we need
strong modularity with relatively
impermeable component boundaries with
two we need timeout based communication
and lease based resource allocation and
three we need self-describing requests
the carrot time to live and information
whether they're idempotent or not I
really think this is something we should
bring take with us when we design
protocols and and you might have heard
about this like let it crash idea
popularized by joe armstrong and our
alliance or it's really fully embracing
the crashing only way approach to fail
to fail to failure management but these
authors can they invoke they didn't stop
there they in an upcoming for our paper
that call recursive restart ability
turning this crachiolla sledge-hammering
just in an interest in just into scalpel
they argue for that you that you should
apply this crashing on the patent to any
level of granularity recursively if
needed and it's off it often if is
needed and i really believe this way of
looking at it it's a very powerful model
it allows us to to to right systems
that's regretfully taller it restarts a
ten at any level usually from inwards
and up it's also a pattern that i will
come back to later another great great
great quote from this paper recursive
wrist wrist wrist or ability paper is
that software components should be
designed such they can deny service for
any request recall then if underlying
components can say
no then apps using that must be designed
to take no for an answer how to decide
to proceed give up wait retry reduce
fidelity etc I think what they're saying
here is that services they first they
must be allowed to say no I can't keep
up any longer and this also means that
that the components using that might
might might be might need need to be
able to cope with being told no and know
how to proceed and almost all failure is
what I talked about here I mean the
reason drive this crash only with view
of the world is that almost all failures
relate to some sort of state data we
have inconsistent state like partial
state wrong wrong state wrong data lost
data duplication of data and so on and
let's try to classify what we mean by
state okay first this is one this is our
my classification I didn't make up make
this up is something I learned and found
useful except first we have static data
let's other data that you can read from
conflict files in like we read from like
a stable storage somewhere that it
doesn't change is always available you
can always read it in and so on then
we're scratch data this data that you
use in computations like do it like
temporary data that you use to get your
result if you lose that that's fine and
then your dynamic data and dynamic data
can be can be defined in can block
divided into two sort of categories you
have recompute able ones that sort of
this rebase those stones on static data
sort of variation of static data but
then you are the not recompute abul and
this is your critical state if you lose
this then then your host right this can
be even user input data for example it's
hard to go out to ask the user can you
like fill in the form again for me
please or something so stuff like this
sure no but no one probably dies right
but it's still it's not an ideal word to
lose not recompute able data because you
can't provide the level of service that
you that that you hope to do okay so now
let's took it take a look at traditional
state management that we've all been
sort of used to used to use
and how to have learned to use so the
let the legend here is that this blue
Bob ball here is is an object of some
sort the the white one is a client in
this red box is critical state that is
that you can't lose I mean if you lose
that Union and then you can provide the
level of service you like and this
dotted line here is a is a thread
boundary okay so so you often often in a
regular aerobic system you look
something like like this you have you
have a whole bunch of connect connected
objects with the critical state limit
little bit everywhere I mean somewhere
around this orbit graph and now if a
client makes a request it leads to some
activity down the line you know and and
and and and any in traditional systems
at least the way I wrote them in like 10
years ago or 20 years ago or so on when
I started this career was was that they
all I mean do synchronous request so you
have leased this cold chain you know
stack frame after stack frames and
another object to another rabbit to turn
to another object now what if something
fails you know down down down here for
example down at the bottom here the
problem then is that the whole stack is
blown right why not a big fail is need
to cascading failure to the next
components the whole stack frame like
this is blown all the way up like the
problem is that if you don't do much
about it then it all you get is like
that's thrown right in the clients face
and if there's really no client all you
see probably is a log you know how to
the oil select with it with it with
exceptional you know print it out all
the way up to the to the new thread or
the executor service or something worse
or something like then it's complete
silence and and and the problem is that
this is the failure management the way
that we've grown up with but I really
believe that is that is really
completely utterly broken because if a
thread blows up you know that's the only
context you have so if your thread blows
up then you lose complete knowledge
about what happened why something went
wrong you can you have to go ask the
client than or something like that and
and and and and and since this count
text is the only context you have you
need to like sort of you need to like
hold on to that as much as you know that
my bag went down there anyway hold on to
that like as much as you just can we
just simply Cana cannot cannot lose this
because exception don't propagate
between contexts between threads between
other components with unless you
actually ask it to do so what you have
to do then you need to like it since
failures can happen anywhere you need to
be prepared to have the failure anywhere
in the application you to go around and
it's like sprinkler on try-catch
statements almost anywhere and be ready
to deal with failure anywhere in the
application you know and then that's
where you get the system stuck where you
we're often your business logic
completely tangled with with error
handling and often more error handling
than nationally business logic and it's
also scatter across the whole
application it's a cross-cutting concern
I used to do aspect-oriented programming
actually try to deliver that you know
extracting that audiences like the word
told the third dimension and stuff like
that very cool stuff but it didn't work
much because dell is delegating the
problem you know still is still based on
try-catch statement just as you just
weave into the code so so i believe we
need a better way of dealing with it and
don't code defensively like this failure
is naturally shouldn't try to protect
ourselves constantly from it to happen I
think structure can bring silent sanity
back and as I see as Sydney Decker said
that accident they come from
relationships not broken parts it's the
relationships that takes down your
system okay so i think the requirements
in my book for saying failure management
is a failure first need to be contained
so you can't get to lease which you
can't get these cascading failures where
we're favored air is just spread
completely without control the errors
need to be able to reify you know sort
of the computer terms will be turn into
something tangible something that you
can touch they need to be turned into
messages and if they are messages that
the means that they can be signaled in
an asynchronous fashion you know to
anyone that's interested there might be
others than the client being interested
declined them actually my
not even be interested he doesn't care
if the service and you can't use another
service out there why should he care
right he might care if you put in the
wrong password and so I'll come back to
this later but but you know failure
should be signal to a 22 to anyone that
that's interested in it and these should
be able to observe it and if they can
observe it from the context outside the
failing context a safe context another
component running another thread or
another machine or somewhere else just
not in the failed context then they can
do something about it then it can manage
failure okay and and so first we need a
way to contain failure the bulkhead
pattern is a very good pattern here it's
a voiced failures from leaking and
called cascading failures it's actually
the way the ship industry have
constructed ships for hundreds of years
and the key here is compartmentalization
where you have you divide your your ship
between two discrete and fully contained
compartments here so if if one or two or
three of them serve starting to feeling
water the whole ship doesn't sink and
when I when talking about that everyone
brings up yeah but what about Titanic
isn't that a counterexample actually not
you know because what the Titanic did it
didn't have these walls go all the way
up so when it went through and when
three or four I don't remember what it
was but enough what got filled up you
started tilt water started to spill over
to the next one to the next on to the
next month so Titanic it's actually
great example of cascading failure and
happening when isolation is not fully
happening okay so so but I really will
believe it this way of dealing with with
with with failure is yet again back to
fall tolerance no because you get hurt
and you can limp along but I think still
yet yet another time EEGs or yet again I
think we can we can do better i think we
are actually already a position to heal
these compartments and can actually come
back to fully resilient resilient
systems and to do that we need to enter
what i call super
vision this is the supervisor is the guy
that listens to the failures in a safe
outside context right to nae a sable to
risk fully respond to that so so so that
this the supervisor is can learn about
the failure and can choose to restore
resume Maurice restart the failed
component to restore full full service
again there might be temporary hiccup
but after a while the system can restore
full functionality and really self heal
and let me explain I think our 15
minutes left I should be able to go
through this let me explain how this
worked through through through through a
practical example that I used that I
sometimes tell and it is it's about how
I vending machine works so you have this
programmer he's really eager for coffee
is visiting hacking all day and he walks
up to this coffee machine any in
like one quarter for example in one crew
load in Swedish or dance or Danish and
let's say it costs to write what's
happening that the coffee machine will
display an error message right in the
programmers face say please Admiral
coins or something like that then the
program adds the min as all the coins
meaning he fulfills his his contract of
the service and he gets his coffee the
cop and the program is happy now the
next day he walks in in in serves two
coins and now he gets like an outer
coffee beans there or thrown his face so
like out of out of water or like bean
Jam exception or something like that
what should he do with that and where is
where is you know the key to the machine
where is the the beans right or where I
work how can i fix the grinder that's
not the program is responsibility is
that's usually not the way it works
either I think that's just completely
wrong instead what's happening in an
ideal world I don't know if this is real
of the way it's happening but is that
there's this service guy rounds around
the floors you know in the office and he
s or a beeper perhaps something like
that and he gets it gets notified that
something's wrong with his coffee
machine actually might be you know pair
periodically in the injury in real life
so he comes the next day and discovers
it but let's say that he has a way of
getting signal
he is the guy that responsible for this
coffee machine so he's the guy that
should fix it add more beans for example
and the programmer gets his coffee and
he's happy I mean the important thing
here is that we need to distinguish
between errors that the program was
responsible for and failures of the
service that the program it shouldn't
have anything to do with you shouldn't
even be aware that this is happening
sure I mean if it's a long delay there
might be nice to notify him that
something that's going to be fixed in
this in the short time but it shouldn't
it's not not his responsibility to fix
this and I really think that this is the
way which we should build systems we
request response validation errors cly's
not fulfilling their contract should be
thrown right in the clients face but not
everything like we like like like you
know this synchronous try-catch model
encourages that we throw everything
right at the clients face because what
should what should he do with all of
these things they should go to
supervisor that should deal with the
error and and and as I program in love
with actors for example in enacting the
inning in the actor model it is a
supervisor that creates his workers and
naturally he says he created the workers
he should know how to deal with errors
in them she should know these these my
workers here they used it a third party
saw service here for example if that's
going down I have some clue what's going
on at least and I should be able to deal
to deal with that since it's so I think
in the mall the word the guy that
creates the service is responsible for
it and the failure of it it's a good
model so I I really like what I call
them so the error Colonel pile or on
Iran on in later state failure failure
failure management this is also
something that I think I learned about
in Erlang the first time where their
full gun fold what's all in on this on
this way of working and then we have in
Anaka the product that i started some
time ago we have also fully embraced
this this this this model and the model
is that instead of having our quick or
critical stateless scattered across the
whole application
we still contain it in what we call the
error kernel is a minimal source source
or a minimum would say sir place where
we put everything in that sort of in the
innermost of this of this onion here is
where we put our or our critical state
and then we have the layers you know of
defense protecting us here so this means
that that whenever some things going on
can't we can hardly see here right but
just go back here when there was
something somes whenever this component
are supposed to do something dangerous
he never does it himself instead he
delegates you know to this layer here
that might also delegate to this layer
that might also delegate right so you
had this layers of Defense so whenever a
request is hit hits the air current they
can always assume correctness then it's
been fully validated I mean they're all
this dependencies have been fully
checked nothing can go wrong here in an
ideal world i miss you can still might
give up the bugs you know it can get out
of memory exceptions or whatever someone
might just pull the plug of the machine
right so but in theory when it's when
the request hits here everything is fine
so let's take a look at an example here
instead of what a colonial layers state
management is still a traditional state
state management we're here you have all
the critical state in what it called the
error kernel and then you have layers of
Defense you might say layers of services
protecting each it's Easter service
higher up and and now and the
interesting thing is that each one of
these service runs in its own thread and
the reason for that it's just not yeah
you get concurrency and you can scale
things out and that's my I might be nice
but the thing is here's the Keith here
is that this this this gives you safe
boundary it means that if this thing
fail it doesn't affect the rest is fully
contained okay think think about these
is like machines like running physical
like physical machines recommending you
can pull the plug on one no big deal
nothing happens doesn't cascade
so now if the client hits one of these
and something then goes wrong then a
notification if will send up you know
the whole connection a little app to
supervisor will burn they could so it
will be notified and the supervisor can
take action but restarting this
component and the client can continue
using him retry he has to do and I'm
sound like Yoda but but the next time he
will actually that will be healthy
component and the interesting thing is
that if if if his parent can't deal with
it then he can just delegate or escalate
sorry so it might be that there is an
error that none of these layers can
actually deal with then that will hit
there a colonel at least we did as best
as we could like for example and out of
memory or it's really hard to do a
little deal with that in Java that will
hit the era colonel but that is okay
I'll come back to that so so as you
probably seem like this way of working
is very similar to how the meerkats is
actually dealing with resilience with it
with it with a female with the dominant
female you know stops at the road this
is risky business and start delegating
to his poor subordinate like let them
run out of the world to row to die to
check if thumbs if something is is
working this is exactly the same thing
by one of these things doesn't perform
go ahead dangerous work delegate and
watches watch what's really happening
here you know is something going wrong
or not and I didn't everything's fine
and i think i can continue to process
the request and and this way working
this overall in layers state management
is very similar to how the world
actually works around us where we have
these layers of infrastructure
protecting us individuals without really
thinking about it separately liebler
really really believe that it's a
natural mall to deal with their with
resilience there's really natural to a
lot of us and and but this is not
sufficient actually because because we
need to maintain diversity and
redundancy this means that you know you
can't just bet on that you're
sheen will just be be always up the
machine might actually fail you know you
can have around a wrestling system with
just a single machine like the cleaning
lady like my my colleague role and he
actually told me I don't have that much
time but this is a funny anecdote he
actually he actually told me that that
he you know he is a physicist and they
and they were they were doing this
overnight experiment like calculations
and they had like full redundancy two
different machines you know hope all
plugged in but the cleaning lady but but
what they didn't expect was that the
night the cleaning lady came up and I
should pull both blogs and it's starting
like swiping the floor and then pull
them back put a little plug them back in
r IC so I mean you can never expect all
failure scenarios in a way right but
having more than one machine actually it
usually helps a lot and and susp and as
we all know I mean if you start writing
things on multiple machines then you
have a distributed system like most
systems today are even if we don't want
it or not they are distributed systems
and as soon as you have the network
where things start to happen you know
the way the network is actually not
reliable we have UNEP you know you have
to deal with partial failures madman
messages which actually is is the
underlying line communication between
knows over the network means that the
messages can be delayed lost like or
reordered duplicated there's a lot of
things that can go wrong and failure
detection it just turns into guessing
game you just cannot simply know if your
note is down or if it's just doing GC or
is having like being overloaded or
something like that you have to guess
take educated guesses of how do if your
services are up or down so it's a very
different world in in this different
world I actually did a whole talk about
this because I won't go into too much
detail they called life beyond the
illusion of present very liberally the
strong consistency is the wrong default
we might need this in the rare
circumstances but which is not the way
we should fully embrace and do and and
design software because I really believe
the systems they need to be decoupled in
time meaning that the sender receiver
are the couple in time this means that
you have is asynchronous boundary this
safe haven be
all of these are running in like safe
boxes safe havens you can say and this
give you concurrency and a sonic message
passing it gives you this loose coupling
so and serve a share nothing design and
they need to be we also decoupled in
space that means that you that that you
get distribution not just concurrency a
three-inch through interleaving which is
actually decoupling in time but actually
actually able to run things in multiple
sir contexts you know decoupled in space
and here we react to principles lately
lead the way I also think that in order
to for it to really conquer this deserve
this this distributed world we need to
have resilient protocols and in my
experience resilient protocols depend on
to things that asynchronous
communication and and eventual
consistency because protocols like this
or they are tolerant to message los
meses reordering and messaged
application and there's been one of
these terms that will come up sort of
leave a funky term classy 20 I don't
know if you heard about that most people
know what a sedition the atomic
consistent isolated durable asset to
dodo sort of changes the serve the the
meaning of this acronym into a standing
for associative meaning that that it's
batch instant insensitive you can you
can bash in group as you as you want C
stands for commutative meaning that it
is ordering sensitive ordering doesn't
matter and I stands for idempotent
meaning that duplication doesn't matter
so it's written fully embracing this
wave of designing protocols especially
can can lead to lock lot more resilient
protocols and we should not strand like
strive for transaction with semantics
then going back to testing all sorts or
ending with with suddenly with some
words on testing I really think that
that that we have a lot to learn from
our graphing we should just learn to
like just blow things up we shouldn't we
should we really shouldn't be worried
worried worried about that like shoot
down your application I understand when
it breaks where it breaks how it breaks
I think just simply pull the plug I mean
the the ethernet cables or or they're a
great software actually
that that helps you with this like and
like see what happened take notes
because often the result will complete
the surprise you things will not break
where you expected them to to especially
not in a like in the complex dish and
distributed systems as I said there's a
lot of great tools here is just for some
of the netflix that is this is in the
simulator simian army acha has this has
multi JVM tests they're all of these key
like simulate network outages and and
and and and like a duo has a crazy stuff
you know messing around with a with a
with a network dropping messages
delaying messages slowing messages down
etc and you know and you have lucky like
tools which try to shoot down your
application like gattling here and stuff
like that and and and yet again i think
you should decide for failure and you
should like test it as any other code
that you test and sometimes might
rationally worth you go like to do like
netflix go all in and even test in
production like like they do because
nothing beats production it's a
completely different world as soon as
you go to production so I've covered a
lot I just want to sum things up as I
said one of the biggest thing remain
things I want you to remember is that
complex system always run as broken
systems it's always something failing
somewhere and the only way out of that
oh sorry is is to fully it is to fully
embrace resilience as something that you
design for and design with right the
resilience is really buy it by design
it's nothing you can bolt on afterwards
you need to think about it from day one
and a seed as a natural state in the
applications lifecycle yeah that's
everything I have thank
and I</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>