<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • In Browser Code Editing • Marijn Haverbeke | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • In Browser Code Editing • Marijn Haverbeke - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • In Browser Code Editing • Marijn Haverbeke</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4UlNIb8i9j8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this will actually just be a library
talk I hope that's okay with everyone so
the problem is you often need to edit
something serious in web components
interfaces of web pages and web
applications are getting more and more
complicated than the common things are
you want templates or you want to query
or something to be written by users
people are using building whole
integrated development environments
inside of the browser and HTML has a
text editor built in it's the text area
element but it's about on par with note
that if you're talking about serious
code editing and to make things worse it
has a very very minimalistic programming
interface you can get its value out you
can give it a new value you can even if
you are willing to put up with some pain
on it and that explore gets the
selection and that's pretty much where
it stops so for typical things where you
just want to go in and adjust some code
query what the user is actually doing it
doesn't scale also because if you have a
few thousand lines of code and you want
to get and set the value of a text area
that's still on modern browsers
seriously slow they used to be in the
midst 2000 zeros a project called edit
area which builds a relatively workable
code editor on top of the text area but
it's since been superseded by better
things these are the three main projects
currently in existence they're all open
source developed in the open with active
communities open repositories and bug
tracker section i'm not sure about
Orion's bug tracker but I think out
mirror on github um a stands for the
Aged x.org code editor where age
dark is the old name of the company that
now does the cloud nine integrated
development environment which is a
really really slick online integrated
development environment is focused on
JavaScript mostly doing both client and
server side stuff would note its hooks
into the burger that it runs on some
amazon server for you you have direct
access to get commands and it's it's
it's very well done so they built their
own editor for this around 2010 2010 I
think it was first released code mirror
is my baby is my project the few of you
who've seen my name before I probably
know it from a book called eloquent
JavaScript which I published in 2007
online it's a book about JavaScript
which has an integrated environment for
trying out code snippets editing them
running them and I needed the good code
editor for death and none was
forthcoming so that's when I implemented
the first version of code mirror around
2011 when ace had come along ace kind of
outgunned code mirror on most of the
coolness factor and the speed and the
features so I rewrote it from scratch
using some of the techniques that I
stole from ace and now it's pretty much
on par with that then the third one is a
bit the odd one out this is called Orion
it's developed by the eclipse foundation
for their they're also working on an
online code editor environments which is
as a whole cult Orion but the editor
component can be run separately from the
rest from the back end they're not
getting quite as much president moments
but they're hard at work and I think
they're building a great stuff it uses a
different implementation technique than
the other two I'll come back to that at
the end of the talk but most of the
things I'll be illustre
eating in my talk applied to coat mirror
directly and ace because it has a very
similar implementation Orion is
different I will briefly come back to it
later so why would I even reimplement
code mirror to use the same techniques
that ace has this largely a matter of
pride I had this project which was
dominant for a while in the code editor
space and then these upstarts came along
and it was something that was better and
of course I couldn't let that happen but
it's not the only difference ace is very
opinionated all bells and whistles
included kind of editor you just drop it
into your page and you have all the
features running and going and code
mirror on the other hand is minimal
super configurable a kind of thing where
if you really want something specific it
can do it it kind of just do basically
almost everything you'd want to do it's
also trade times smaller then a sand I'm
biased but I feel that it has a plan
more pleasant interface but actually I
should not compare them because it's
like I don't know asking the pulp about
independent comparing of the various
world religions let's see what we can
actually do this these slides are just
running an HTML day yeah this what you
see here is a real text area so it's a
little narrow but here if i press enter
it indents all the way back to the side
because it doesn't know anything about
code editing let's replace it with goat
mirror you don't see the difference
because I styled them to be the same but
this is actually code mirror and I press
ENTER and its nose this will probably
want to indent to the same depth as a
line before it but that's all it knows
and this is of course configurable you
can make it do anything you want when
enter is pressed
things would probably be better if we
told it's the language that we're using
this is JavaScript this is actually the
code that powers these slides it's
pretty horrible Code you shouldn't
actually read it but it's colored now it
knows what a string is what a comment is
it's recognizes keywords and it also
knows about blocks so if i press enter
here it'll see how you open the block so
I should probably indent that if I first
enter in the middle of list disparities
that'll also nicely align it it's gotten
slightly more clever because there's a
program written called the JavaScript
mode and there's Mouse for lots of
languages or come back to that later
which are basically like little parsers
that can tell the editor about
highlighting and give some contextual
information that it can use for example
for annotation that was not what I
wanted to do the styling can be
completely adjusted using style sheets
this is the theme one of the few teams
that were contributed that were not
programmer art style of super simple
minimal stuff but done by someone who's
actually somewhat proficient in graphics
we can just tell it to add a line number
bar to the sides to make it look
somewhat more professional all these set
option calls you don't actually have to
do that you can usually just initialize
it with all the options you want with
your I'm like going step by step to see
where it starts and what you can add
let's say we want to add couch folding
first we make some space for an extra
gutter here we tell is that we want
together one for the line numbers and
one for our fault markers the fault
market string is a CSS class that will
specify the width of this next we'll rig
is there an event handler if someone
clicks on the gutter it will call this
function which here is called maybe
fault code this is not part of the core
the course is very minimal
the distribution includes a bunch of
add-ons which for example let you fold
code other things that are extensions or
add-ons are a search replace if I do
search it'll just search through my
documents if I do replace I can replace
all the instances of window and save
like 16 bytes on my javascript file with
the word top I another thing I wanted to
show was here are rigged something to
show a simple autocompletion if you
press ctrl space it also does some
clever things where it inspects the
current environment and well these gonna
look right I probably screwed up some
style sheet it looks in your current
environment to give you hints you can
actually it's pretty primitive you could
write how much more clever out the
completer and because it's pluggable you
can basically go crazy with cleverness
hi here I added another external program
which whenever the content of the editor
changes it will call this run linter
function which is based on j as hints
which is a linter aesthetic lender for
javascript and whenever it finds a
problem it'll in line show it as a
little exclamation boom mark which it if
we compare with ace it looks extremely
similar like eerily similar it's just
the theme is different you can probably
style them to look exactly the same if
you really want it to but it has all
this this is like I I just dropped it in
with three lines of code and it already
has the folding running and I think it
also does
linting yeah here we are it says missing
semicolon so it's a more opinionated all
everything included kind of library I
didn't actually set up an instance of
Orion here but it looks very similar
because Scott editors have converged to
a kind of look I'm actually coming from
an emacs background so I had to make
some things non-weird in the process of
getting feedback from users who were not
quite familiar with the MX bastes
features that I was building but yeah
I've converged on a standard component
which can be configured you can even add
key binding maps for you just redefine
every key to the point that the browser
allows unfortunately the browser should
capture some things like control w
control p at least chrome does capture
them unconditionally you can't overwrite
them so full emacs bindings are only
possible in Firefox which lets you
redefine every single key on the planet
so as I said browsers don't really do
code editing yet we just saw two code
editors some magic was required the rest
of my talk will be spent looking under
the hood of these editors and seeing how
they actually do their thing first of
all you saw a cursor there its moves
when I types is blinks its behave
exactly like cursor it's not actually a
cursor or at least the browser and the
operating system do not think this is a
girder it's actually just the
development that I absolutely positioned
over the text and blink with a set time
out to make it look cursor like but of
course this is possible you can draw
quite a low it's usually kardemir
doesn't use any kind of campus it's all
Dom nodes don't know is are faster and
practice then canvas because the browser
knows more about them and can
display them more cleverly but you can
imagine how this works you just keep
your own model of the document keep your
own selection draw things in a way that
is expected from an editor listen to key
events and respond to them in the
appropriate way if someone presses left
you move your internal cursor position a
bit you update your cursor and it just
looks like you have a real additive
component you think it's with key events
you actually you could just listen
globally which there's one a very cool
project called wimax which is an image
clone which does just that it just
listens to key events on the global
window object and fakes everything from
there the problem is that then you're
not really being a good citizen anymore
the rest of the page will be unable to
get focused because you're grabbing all
events from the top level and you can't
type into anything else or do anything
else with the keyboard so that's not a
good solution what we want to actually
respect the tabbing regime the focus
regime of the browser where you can tap
through and actually end up in your code
editor and then when you press stop
again if you didn't tap to something
else in your editor moves to the next
field and so on so to do that there's a
text area actually being created by the
code editor and then hidden which acts
as our input shim the thing is we can't
just do a display none or visibility
hidden on the thing because in the
browser will refuse to focus it what
we're doing instead is wrapping it in an
overflow hidden div and making that hate
zero you still don't see it but the
browser doesn't realize that it's
invisible so it will happily focus it
for you and at that point we know a
focus event fires on this thing so we
know we're focused we register our key
event handlers on this actual text area
so we can capture them locally instead
of globally and this works very well
another advantage is that the input is
already in this text area so when Texas
typed it'll appear there we don't have
to mango key events to get regularly
types text we can just wait for it to
appear in the text area move it into our
own representation of the document there
are some some advanced input things like
there's I a me and put method editor is
used by a lot of east asian languages to
compose characters by multiple
keystrokes the key events there will be
almost meaningless what you want is the
actual input that the operating system
makes of it and this actual input will
end up in the text area so this helps us
support that same for paste you don't
have access to the clipboard from
JavaScript but if the usual place his
text will end up in the currently
focused control so we get the text we
want there's a for cuts and copy you
also wants whenever this happens the the
selection in the text here to match the
actual selected text in the editor so
that you actually get the stuff on your
clipboard that you were hoping for one
solution is just to always put a
selection in text area with if someone
presses control a in a huge document
that will be a lot of data and as I said
setting the value on a text area is this
amazingly slow which is probably
understandable because it has to
populate this editable control which is
non-trivial and it doesn't know if only
a small sing change that has to just
rebuild its whole representation so we
want to avoid that to do that we can
just wait for a cut or copy sent to fire
a fire like browser events this fire
before the actual cut or copy takes
place so when this happens we quickly
switch in the documents the current
selection into the text area and
everything works well the last heck
doesn't work on Opera which doesn't do
cut copy and paste events but there
we just put in the whole doc you the
whole selection and if it's too slow
that should use another browser or
something that's not the whole story of
making something behave like a
convincing editable component there's
also for example drag and drop you want
drag and drop to work there's a good ipi
for that which is supported by all
modern browsers sure that was relatively
trivial to hook up then there's context
menu if you right click on your editable
component you expect cut copy paste and
select all to be present in a menu but
people are just clicking some random div
which is not an editable component so we
have to trick the browser and it's
actually possible though weird this
event fires before the menu is opened so
when code mirror notices context menu
events or on Firefox a right click event
because firefox's context menu is on
fire too late what we do is we make this
text area almost transparent so that it
doesn't draw attention to itself we make
it small and we shove it under the mouse
cursor it actually works it's a horrible
horrible heck but it is a trick the
context menu will actually be associated
with the text area at this point which
we can hide immediately afterwards so
you don't really see it unless you're
looking for it and if you paste from
there it'll end up in the end of text
area same we can do the same trick again
where we put the selection in there so
that if you copy or cut you also get
what you want select all requires
another step of hackery where we add an
extra character that's not selected and
then after the context menu opens we
pull for a while whether the character
got selected and if it did then they
probably click select also we should
like the whole document yeah it's a
shame and a real API would have been
great but this works and this is not so
bad another area where we're definitely
cheating is the scrolling because
supporting huge documents is important
in any code editor we don't want to
render everything to the Dom what we do
is when you're looking at a scrollable
editor actually only the part is
currently visible is rendered to the Dom
the rest is not there can we illustrate
it with a little animation here we're
scrolling across this huge document
everything is missing except for the
part that we could currently see and a
small margin around death and the rest
of the scroll bar is produced by a big
statically sized div which is set to the
heads of the actual content with the
result that the scroll bar is correct
and whenever a scroll event fires
because the user Scrolls we quickly
repaint whatever he's looking at now
with a small margin so that we don't
have to repaint on every tiny scroll
event it works almost perfectly except
that if you scroll very fast scroll
events happen after the actual scrolling
was done so you'll see briefly an empty
space and then the coach flips in again
and this was very disturbing especially
on slower machines so we fake the
scrollbar the scroll bar that you see in
the editor is just a div overlaid on the
actual scroll bar which also a note put
into it which has the actual haze of the
document so it'll be exactly the same
scroll bar as the one that's the actual
scrollable dave has but if you scroll it
you're not actually causing the
scrollable diff to move so this gives us
time when you scroll event fires to
first redraw and then update the scroll
top position of of our scrollable diff
as you see once you start lying to the
user you often need more lies and more
lies to cover them up recently a OS mac
OS 10 mountain lion came out which has a
very nice innovation transparent scroll
bars so now the trick of overlaying the
real scroll bar with a fake scroll bar
is obviously
it's showing you see both of the scroll
bars and are slightly out of sync and
it's it looks horrible so enter another
heck the actual scrollable diff which
has this this scroll bar that we want to
hide is made a bit bigger than the
actual editor editor wrapper is given
overflow hidden so you don't actually
see this stuff that sticks out that
makes the scrollbar that the one that
you see in grey here completely
invisible and everything works happily
and fine until the next bug is found and
I have to come up with even more
complicated model as i mentioned big
files are important miguel actually
mentioned in his talk that the chrome
crumbs internal editor has problems with
big files it just gets slow and
unresponsive there's actually a an
experiment under way to integrate code
mirror and chrome instead of this
built-in editor for this very reason
that it scales better one obvious
problem is of course representation of
your documents you can't really cheat
there you need to put the whole document
in memory if you want yeah at least I
don't want to deal with any other model
where you're getting your documents from
the server as a user Scrolls you could
do it but that's not what code mirror
does but fortunately modern JavaScript
engines are very efficient in the amount
of overhead they put on on objects and
strings and even if you have a million
line document it'll be a few megabytes
of string data and add a few megabytes
of rapid atta to actually put these
strings in a data structure that we can
access it's still not that bad everyone
is four gigabytes of RAM and if they
don't they shouldn't be editing such
huge files is my current position an
interesting question is how do we
represent then this document with all
these strings in it the first version of
cod mayor just use the flat array
that worked relatively well because in
the first version of code mirror the
environment was enforced that all lines
had exactly the same eight so one thing
that this data structure must support is
if you click on the document or you do
something else where you want to find
out which character is under a given X y
coordinate on the screen you have to
somehow convert from a vertical offset
to line position these all lines are the
same you just divide by the line height
thing you're there and it's easy but
then I added features like line wrapping
and couch folding which makes some lines
finish and I will feature where you can
add in line which 'it's which was what
is what this linting feature used before
where you just put another dumb men out
in the middle of your editor which also
screws up the heads of lines so
something more advanced was needed the
the operations that this data structure
should support is converting between
three representations of lines about
three ways to address them first byline
handle which is basically the if you
have a line handle that's refers to a
specific line and someone presses enter
before that the line number we know it
will increase but you still have the
same text and often you need that the
API exposes that where for example if
you add a widget to some line you later
want to be able to remove it so you need
to track this line somehow these must be
convertible to line numbers and line
vertical offsets very quickly and the
same the other way around go from a line
number or a vertical offset to an actual
line handle internally also the editor
does this all the time so this has to be
fast another consideration is updates
have to be fast its own place a thousand
lines there should not be a noticeable
pause because all these lines are
inserted in some expensive data
structure similarly if someone is typing
very quickly these tiny micro updates
should be very very fast because
an irresponsible code editor which
doesn't immediately respond when you do
something is just one recipe for a
headache when you're trying to do
something so did the the format that I
came up with was a tree of usually you
want to index by some some properties so
a tree really is an obvious candidate
but what I ended up with was not some
kind of regular binary tree but B 3
which is a data format used by databases
mostly another on this file formats
which is quite a far cry from a code
editor but it fit extremely well what it
does what a b-tree does for those who
are not familiar with the data structure
is that it's it's a tree structure each
note has a very high branching factor so
lots of children under one a parent node
and all the data is stored in the leaves
which are themselves bigger than a
single value they store a whole range of
values and they can grow and shrink like
there's a minimum and maximum size for
this child nodes so that if you just
remove one line you can just remove it
from the child where it's in and be done
you don't have to rebalance anything
unless the child is empty then you kill
the child and similarly if you insert
the balancing algorithm for b3 is simple
and cheap you just what color does
insert everything in the child node that
happens to refer to the current position
whereas inserting and then if that
overflows this child node it starts
splitting it into reasonably sized leave
notes if there's too many of them in a
parent now that's split in turn and it's
propagates upwards in a very cheap way
which is friendly to bulk updates if you
have a classic black 3 or something you
want to insert a thousand notes even if
they're all adjacent you have to insert
them one by one because the algorithm is
defined in single insertions and single
deletions be trees are much more
flexible and very simple to implement so
this was a great fit i guess it's best
demonstrated with a visual demo
here you see a gardener instance on the
left and a visual representation of the
document three on the right so here this
is documents with 155 lines haith of
five and a half thousand pixels about
it's only the tree has only a depth of 1
so the root note contains a bunch of
leaves under each leaf I display the
lines that this leaf contains SS little
colored blocks where the color is the
hash of the content of the line and the
width is the hate of the line so I
turned on line wrapping in this demo
show you can see that some lines are
wider than others and if I felt
something you'll see that some lines
become very low and the eighth changes
they propagate to the parents so the
root note always has an up-to-date view
of a the amount of lines in the document
and be the total height of those and
allows for a quick indexing say we want
to find a line 50 now 60 we go we
started the route we see that the first
leaf has only a size of 30 so that's not
the one we take we track that there's 30
remaining so the second leaf has 25
still not the one there's only five
remaining we go to the third leaf and
it's a match so we just take the fifth
line of the third leaf and because these
trees are extremely shallow because of
the high branching factor these kind of
look ups are blazingly fast the same is
for a faith because faith and line
number both increase in the same order
and both monotonically we can use two
quantities to index a single tree
basically which is great and cheap and
very pleasant to work with I'll try to
demonstrate the splitting algorithm the
balancing so here you see little orange
notes appearing because i'm adding empty
lines then when the top leaf hits 50
bang it's split in two and half of the
it just becomes two leaves which is a
trivial operation for the editor to
perform if I start to just paste lots of
luck here you have a very simple tree if
I start to just base lots of junk here
we have 25 pound line documents you can
see that it's still pretty responsive
and the tree is now four notes five five
layers deep so it's still very fast to
look something up you have to jump
through a few more notes to get
somewhere but not a lot and since you're
usually editing in a relatively small
range of the documents the cash will
also be used pretty well because these
are ya arrays and notes and it's only
touching a bunch of them all the time I
mean the memory processor cash and
deletion is as I said it's actually
insertion is clever enough to always
produce a balanced tree here but
deletion is a bit more simple little
just when you oh yeah I need more than
one leaf sorry bout that and when a leaf
becomes when leaf becomes empty it just
vanishes if a branch node falls under a
certain size threshold it just merge
itself into a single leaf so all of this
whole implementation is maybe another 50
lines of code and because code size is
also an important consideration in the
lid JavaScript library where the client
will always be compiling it and
downloading it and yeah you don't want
to use techniques that require megabytes
of code because then it's just not
usable anymore
mouths are what are the word that code
more uses for language specializations
these are the distribution comes with
about 50 modes at the moment which are
small JavaScript programs that act like
a tokenizer or optionally even a full
parser depending on how clever you want
your mout to be for a given language
these are the major ones they range from
25 lines for the diff mode to 800 lines
for the Pearl mode which I didn't write
them which I never even dare to look at
and the way they work is that the editor
uses them to run over the documents one
token at a time one syntactic element at
a time they basically move a stream
forward pass the syntactic element that
they parse and then return a style for
this so a style could be string for a
quoted string or comments for something
that looks like a comment to do this
this is their basic interface often you
need some kind of memory of what came
before if you want to assign a style to
something for example in a multi-line
comment you don't know from your current
text that you're in a multi-line
comments but you saw a for example /
star in JavaScript earlier so most keep
estate sometimes don't you to state
because the language is trivial enough
to port without any contextual knowledge
motu notes do they define methods start
state which is something that returns
the state object for the start of the
document and every token day every time
a token is sparse they get access to
this state and they may update it for
example setting a flag we are now in a
comment and then there's a bunch of
optional extra methods that these modes
can expose to do more clever things for
example
indentation which given a context state
and a string which is the line after
after the current point is being
indented returns an integer saying the
amount of space to which this should be
indented so that the context that's
already being tracked by the state can
be put to good use when you're pressing
enter and wanting out indent or
selecting a block of text and
reinventing it one problem there is you
if line 2501 changes you don't want to
report the whole document because that
would be a humongous waste of everyone's
cpu cycles so what code mirror does it's
it occasionally copies this state they
are defined in a way that they are
copyable and if the mode needs them to
be copyable in a specific way and also
to find a method for that and stores
these state instances along the document
and then when for example actually when
you start it only parses the currently
visible viewport then as you scroll down
it'll pause more and more of the
document and store these state instances
everywhere then if you sit here for
example and make a change on the little
red line it only passes from the change
reparse is from the change down to the
end of the current viewport so this is
also a very bounded amount of work that
needs to be done if we assume that the
viewport is no more than a few hundred
lines must modes can parse about fifty
thousand lines per second some of the
more advanced ones which keep a lot of
states they're more like twenty thousand
lines but still a few milliseconds
should be all it takes to to report a
screen full of code and make sure
everything is consistent again at least
everything that you can see it of course
also the situation where you're scrolled
down here and somehow managed to change
third line of the document then it has
to parse more in the common case parsing
and re highlighting happens
synchronously if it's can see that
there's only a given maximum number of
lines between the start of its range and
end it just does it then you don't even
notice it because it's very very fast
there are also situations like this or
when you scroll down your documents
really fast where there's just too much
work to be done or it does then is it
makes up the states somewhere in some
line it has a heuristic where it takes a
nearby line that is the least indented
which in most languages gives you at
least some context because the least in
n lines usually start the blocks and
uses that made up States to re highlight
synchronously and then kicks off judo
background threads using set timeout to
actually do the full highlighting work
which is like it works for a given time
time slice which is configurable if it
runs over that it stops and sets a
timeout for itself to continue again and
in that way it doesn't actually hamper
responsiveness as soon as you're typing
it stops background highlighting again
so that you don't get a noticeable slow
down from this work actually that might
be overkill because it's so fast to
highlight but in older browsers and all
the versions of code Meredith was slow
enough to justify such an approach and
it's probably still if you have this
25,000 line document it still helps
so what can you do if you have an
arbitrarily clever real program as a
highlighter that actually is run over
your document you can do actually some
analysis more clever than just
highlighting here we have an XML
document the parser keeps the current
tag context in its state and when when
it encounters closing tag that doesn't
match this thing that happened to open
the current context it can tell you that
you probably made a mistake because you
have a Mitch matching deck and similarly
if I that was not what I intended to do
if I make a mistake here at the top the
highlighting will cascade down because
it rehi lights stuff unchanged and it'll
tell me that yes I have a mismatch tag
again cooler is the java trip mode which
knows the difference between local and
global variables and gives them a
different color the definition of a
variable is made dark blue here and use
of a local is made light blue and you
can see for example that console we can
even make them both to make me jump out
even more the console is a global
whereas the others are locals which is
especially useful if you make some typos
somewhere it'll kind of jump out at you
that you're not using a variable that's
currently in scope and since the most
coat the Global's our way outnumbered by
locals this creates a nice visual
pattern to warn yourself when you're
doing something global the auto
completion actually hooks into this
knowledge about local so if i say array
here it knows that yes i may want to
complete to this local whereas if i do
the same here I get no completions
because the local doesn't exist so it's
a very very primitive form of
context-aware a completion
this approach to writing mouths where
they're basically a function that your
feed stream makes them extremely
composable which allows things like this
mixed-mode HTML which is a kind of
wrapper multiplexing mode between
several other modes it starts using the
XML parser whether the HTML
configuration of the XML parser and when
it encounters a style tag it switches to
the CSS parser so this one here knows
how that should be indented even though
it looks like it's inside in HTML
documents it has the context-sensitive
it gets the context of the CSS file and
similar if you find scripts it'll switch
to the JavaScript mode and at the end of
this cryptic it'll switch out again and
that allows these mouths to compose
which is also used for a lot of
templating languages and PHP and other
settings um just last week I brought out
the first beta version 3 of code mirror
which adds some new features like
bi-directional text support like a
rabbit or Hebrew text which is a huge
headache to get right in an editor
because you can mix Hebrew and let in
text in a single line and the Hebrew
text will kind of flip around because
it's written right to left so if the
cursor is moving through this it has to
know a whole bunch about obscure Unicode
properties of characters to properly
move to the in the correct position
movie correct way if you press left and
similarly selection drawing becomes
quite a bit more complicated because
it's no longer a single continuous block
it's may jump all around because the
code is basically no longer continuous
from left to right I one thing that is
on the radar but currently pretty sad
both in code mirror on ace is mobile
support so mobile violates a whole bunch
of assumptions that we rely on to do
this heck the biggest problem is that
you get these nice selection helper
carrots thing is if you select something
since it's not a real selection that
we're creating we don't get those so a
lot of features are locked basically you
can't get at them because you don't have
this selection interface I haven't
looked deeply into how hard it would be
to fake this something will have to be
done because mobile is getting huge and
we should support it's at least
relatively decently currently the editor
works you can edit you can on most
mobile browsers even scroll but that's
about the extent of it it's it doesn't
feel native and it's not a pleasant
experience to use so since this is all
open source it's
slow going I don't have I'm not sensed
independently wealthy I don't have the
time to spend months on this just out of
my own time I had a successful
crowdfunding round two months ago where
I spent one month working on a bunch of
new features like bi-directional text
and so that that made it into version 3
who knows i'll probably try something
similar again this is actually working
relatively well for me the the
profitable open source model it's I
spent the first five years working on
this project is completely out of hobby
ISM but recently some big companies are
buying support for this and it's
becoming sustainable for me to to
maintain this but yeah mobile brings me
to the other editor I mentioned before
Orion they use a completely different
approach to do this they use the browser
search content editable functionality
which allows you to build Lee creates a
kind of rich text HTML editor inside the
browser you can say this element is
editable and it will just become
editable you can click on it to get the
cursor type something and then the
browser will do whatever it feels is
proper to let you edit this this this
code which has the advantage that you're
talking about a real editable components
so mobile for example becomes a lot more
a lot less intimidating they claim to
work on mobile haven't actually tried it
but I can imagine the day they've gotten
that's to work because they get a lot of
the features automatically code mirror
one actually the first version of code
mirror before the big rewrites that I
did in 2011 work like this it used
content editable so I have some
experience with it and it's it's has its
own set of problems as i said the
browser can do whatever at once when you
edit this code there's no specification
of how content edible or design mode
which is a similar feature that
all the browsers have instead of it how
it's supposed to work what it's supposed
to do is you press enter for example
some routers insert BR break note some
of them at paragraph notes it's a
surprise and then the editor has to go
back in there and somehow renormalize
what you're looking at to something
that's displaying its own view of your
documents another problem is that
selection AP is in arbitrary dumb
structures are varying between bar
browsers Bergy Bergy and code mere one
at about seven hundred lines of
selection handling code I'm not anxious
to go back to this situation but yeah as
I said it does have it found that is one
of the main problems with Governor one
was there were slow on huge documents
because it put everything in the Dom the
editable Dom no less which is even
slower than normal dumb oh ryan gets
around this by using a similar trick
where it's only putting the visible part
of the documents in the actual Dom so
i'm very curious how will develop
further and what's going to happen there
that was my talk that's where the
project lives my project yeah and that's
me on twitter i would be very happy to
take questions or remarks or whatever
else you might have to add a V I'm out
was a question is there a V I'm out this
is one of the areas where I've been
getting lots of contributions because
lots of people apparently want to see
I'm out and there's there is something
that simulates a lot of VI functionality
but I can't tell you how good it is to
an actual VI user um so I've been one of
the the motivations in the rewrites from
code mera 12 version 2 was to cut mirror
one was drowning in hex and it was there
all interacting and it was getting
horrible so a 2 takes a conscious effort
to keep them to a minimum and isolate
them as good as it can
so users feature detection and wrapping
lots of things and in functions as long
as it's possible and it's constantly
looking for ways like sometimes the
obvious way is buggy and some router the
obvious way to do something and I've
learned to look for another way that's
straightforward and that actually works
cross browser to get around writing if
abroad and this if I eat in this but
there is unfortunately still such code
it's relatively minor in first thing to
which is how I keep this project sign
because it is that these hex tend to
interact in unexpected ways but it's
there and it's just deal with it I keep
a lot in my head unfortunately that's
part of the development process it's
been growing like I have only recently
learned to like now I like testing i
have used testing a lot for a long time
but only in things that were test
friendly a UI component is about the
most unfriendly thing you can think of
especially if a lot of the problematic
behavior is related to browser berks
that you only see when you run it in
that specific browser we currently have
a relatively big test suit which is run
in phantom JS which is a fake web kids
on a note on every commit and I have
this death suit is this runnable if you
just go to a web page and I run it
before I release in every supported
browser but it's not perfect some things
I just haven't found a way to test the
mechanically like without in putting my
own offense there's this framework for
this called I forgot there is a
framework that lets you spawn a browser
process and then communicates to a nice
TP socket to fire events on that browser
process exactly selenium um that kind of
work but I still couldn't fire all the
events that I really wanted to fire like
a input method method editing text is
one very flaky very fragile area that's
not supported by selenium and it's quite
a pain to set up so I it's not actually
there is a stub that there's a few tests
through selenium but I'm not developing
there because it's just very painful
then thank you for listening have a good
day</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>