<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Functional Programming from First Principles • Erik Meijer | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Functional Programming from First Principles • Erik Meijer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Functional Programming from First Principles • Erik Meijer</b></h2><h5 class="post__date">2012-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a-RAltgH8tw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks very much for coming out I hope
you have a great night and you get an
idea this is a taste of yow just imagine
there's like 40 speakers like these guys
and you're sort of feel what it's like
so thanks very much for coming Eric and
now when I was when Dave asked me to
talk I said you know I the most fun talk
I've ever done this this store called
you know fundamentalist functional
programming because a lot of people talk
about functional programming but they're
not really doing functional programming
functional programming is really easy
what is it it is you know let me say
first well this object-oriented
programming that's programming with
objects but what is an object I don't
know it's like you know something that
represents a real-world entity love
about now we're already kind of getting
fake but if you ask what this functional
programming well this program with
functions well my son just finished high
school and guess what Ronnie did the SAT
test there is on page 35 of the book
there is a definition what is a function
so every high school student knows what
what is a function okay but then when we
start programming we forget what the
function is and then we're kind of
programming and we say we're doing
functional programming like say where
are the functions you know they're not
functions and so on but since the word a
functional programming was already taken
you know I had to call it fundamentalist
functional programming and now something
happened in the meantime some side
effect happened and one of the examples
that I gave in that talk is about mixing
side-effects and enclosures and and the
example that I used you know has now
been fixed in c-sharp so there has been
a breaking change in c-sharp v oh and
now my example doesn't work anymore so I
had to give it a completely new talk so
let me kind of explain to you what
what's going on here so Eric Lippert a
very interesting guy if you don't read
this blog again this blog is kind of
super interesting for any programmer not
just a Microsoft programmer
he has a kind of you know this is from
2009 you know closing over loop
variables considered harmful you know
one of the 1500 kind of papers called
something considered harmful and then
there's a little update there saying you
know we have a breaking change and poof
there went my talk because my talk was
about yeah about this so let's look at
this example and see what's going on
here
okay so there's a kind of the simplest
program and that you can imagine it's a
loop for each variable in this you know
in this array and I assumed that you
know everybody can read this even if
you're a Java programmer or a JavaScript
programmer so it just iterate over the
values 0 to 4 and then I print them now
the thing is that there's a variable
being declared there okay and if you
have taken a compiler course you know
that declaring a variable is not just
declaring a variable you know you have
to allocate some space you know
somewhere on the stack and you know the
after then you know after you exit the
scope you have to remove the thing so
there is that variable there but where
is it really declared where is it
allocated okay so let's run some tests
so let's first see you know is it
declared outside the loop so and I
cannot change the the loop so I can't
you I declare the variable outside and
then I assign it's kind of your inside
here to simulate you know that the
variables declared outside or the other
thing is it declared inside so for every
iteration is a new variable allocated so
now what do you think is it outside or
inside and or does it matter you say
Eric you're such a theorist who cares
you know if it's outside or inside it
just works okay so and if you don't have
closures it really doesn't matter you
cannot tell the difference okay you if
you run these programs they give you
exactly the same answer who cares you
can
not observe the difference maybe if you
put the debugger you look you can see it
but normally you cannot observe the
difference where the variable is
allocated before the loop or after the
loop now the thing is that it's this is
an interesting thing it looks like a
trivial thing but if you look at
JavaScript for example in JavaScript if
you write if you declare variable
somewhere really that means nothing
because all the variables are declared
at the beginning of the function so even
in JavaScript if you write this it's
still kind of you know behaves like that
and so every language is slightly
different in this respect and you can
always kind of find you know once you
have closures it becomes easier you can
find kind of subtle differences so you
know you pull your hair out because you
have a book and then it turns out that
there's some side effect that you can
observe because a variable can do gets
allocated every time in the loop or not
okay but in this case and if I run these
three programs I get the expected output
I guess that this is the expected output
I just want to iterate over the array
and get four values okay
now this code looks already a little bit
fishy so let's look at it in more detail
so the first loop there is just the same
as I did before except what I'm going to
do is instead of printing that value
directly I'm capturing that loop
variable enclosure putting that closure
in the list and then I'm just running
through the list and called that
function okay so I'm just deferring
printing the variable the value of the
variable and by putting it in this list
of functions and again in in JavaScript
you know you would just write function
open paren it should be gonna be a very
similar in Java I'm sorry you have to
wait until Java I don't know when they
will have closures at 20:20 maybe and
anyway so that's the first thing so now
um and I've rewritten the the outer and
the inner one in a similar way so don't
get oops this is a suicide here and
don't get to kind of you know confused
here because the code is exactly the
same so I created the list of functions
here I do that for each loop and then
what I do is I copy the loop variable
into this local variable and that's the
one that I capture and in this case I
declare the variable before the loop and
then I capture and I've used some kind
of you know suggestive notation so the
the underscore and the outside mean it's
bound on the outer and here means it's
about bound on the inner okay good
so now you're all kind of you're way
smarter than me so you probably already
know what this will print right so which
one will print four four four I did this
once with nine nine nine or whatever but
yeah that would take too long so in
Steve sharp furrow this one would print
four and so really the semantics was
that the variables declared outside the
loop okay and then if you wanted to get
like it or the expected behavior you
would have to kind of your declare
variable in here and I must say I must
admit I had this book several times I
can still remember that I was this it
was like a marathon programming session
with one of my devs and it just didn't
work and so my dev started to kind of go
and D compile into il and kind of look
at the machine code and I said hohoho
ridzik let's let's look here what did we
do and and then it turned out that we
kind of you know captured a variable
like that in a closure and instead of
getting you know zero one two four we
got four four four so in c-sharp and
this was my example in my previous talk
to show that when you have mutable
variables and closures you get eight
SiC brew this is really really dangerous
but then in c-sharp five and we dis was
changed and now it behaves like this so
and now the problem is so this is great
I think this like you can see like every
day on the forum and I'm not sure every
day but like this is the most asked
questions on the forum it's like what's
going on there why doesn't this work or
you know people kind of bang their head
against the wall and so I think this is
a good fix and now of course and if this
is the behavior that you want so if for
some reason you you do want to kind of
you know four for four
you can still kind of you change your
code to allocate the variable kind of
outside the loop so nothing has lost two
you can still express what you want and
but you know the default is now that it
behaves as if a new variable is
allocated inside the loop now this is
not as natural as you might think
because and there's also the for loop
and the for loop is unchanged so if you
if you do the for loop and that's still
here as if the variable was allocated
outside and the reasoning is that people
expect when they write a for loop since
there is some side effect on the
variable there anyway so they expect
that there's only a single variable that
you side-effect so and that's again a
little bit of a disadvantage because now
you have to sometimes you switch between
for loops and for each loops and now you
get a little bit of a headache
fortunately we have ibuprofen or
whatever so or beer and that will take
care of that okay
so this is a some really kind of tiny I
love these things like tiny tiny
programs that do things that you don't
expect or let go cause some interesting
behavior now the question is who gets
the blame
okay
a because some people may say the the
fundament when I was a young Eric when I
was a fundamentalist functional
programmer I would say of course you
know you're using mutable state you
should not do that use ESCO or a real
language and this won't happen and but
on the other hand now that I kind of you
know write code for living I kind of
like imperative programming you can get
stuff done yeah
so I'm not sure anymore how would you
blame so let's look at this let's look
at this here I think the world is
imperative okay the real world is
imperative and why do I say that well um
you know if you have two programs here
that are executing and that program here
on the right you look to the state of
the program on the left and you know
it's something like you know the
Microsoft logo and then you look again
and it's something different and then
this morning you wake up and you look
and the logo is changed again okay so
the real world is imperative this logo
doesn't yeah it really changes and and
so I think we need to embrace
side-effects I think side effects are
good side effects are what makes the
world tick
okay so let's not do kind of crazy
things with you know pure functions and
so on that's great format books that's
good for SAT books that's good to forget
about once you leave high school forget
about functions once you go to
university or the real work
let's do imperative programming because
the real world is imperative now you
don't believe me right you think Oh Eric
is just joking so I need three
volunteers to prove that the real world
is imperative
one volunteer there you come to
volunteers and and then here you're kind
of you're like every volunteer Scout
looking away hoping that it doesn't get
character so let's come here and you
pull on this leg you pull on that Lac
you pull on that leg and now we're going
to kind of you know rip this thing apart
yes yes for
okay okay look so we have now we first
had a kind of cute toy you can sit down
thank you very much this is exactly the
effect that I wanted we had a cute toy
and now we performed a destructive
update on this toy
there's no transaction there's no way I
could ever put this back and even if I
would sue it up again it would not be
the same toy okay so if you don't
believe that the world is imperative
think of this poor little you know
goodly toy the world is super imperative
there's destructive updates that cannot
be undone I could not copy this thing
and then you know mutate the copy this
thing is mutated and this thing is dead
okay so then if you know you can forget
everything I say today if you just
remember the world is imperative the
world takes on side effects good all
right and now we can all go and drink
beer but just the same thing you open
the beer you drink it it's empty no side
of all side effects okay so now if we if
we now say that all that mutation is how
the world should be okay then who is
guilty it's definitely not the the loop
there that's kind of your updates the
variable it's not this guy here that's
always doing also kind of nasty things
it had a list and it kind of you added
elements to the list that capture that
variable also in a sense so but we still
have to assign blame so the only thing
that we can blame is the protocol
between the two the interaction between
the producer and the consumer that must
be wrong because the imperative actions
are perfect so it must be the thing that
glues these different imperative actions
together so let's look at that okay so
but this is the main thing that I'm
going to do there's quite a lot of kind
of blood here on the floor from
little animal anyway and so what we have
to do is we have to acknowledge the
presence of effect okay we should not
try to find it or whatever we should
deal with it and we should think about
it and make it explicit so there are
several things that we can do if we look
at this producer consumer here so this
was the thing to look and this was the
list of actions where you know I just
accumulated the variable so there's
several things I can do okay first of
all I notice that what's really going on
is that there's a sequence of values
that are communicated between the
producer and the consumer every time I
go around the loop there was some
mutation happening and something
happened so that's the first clue is
that there's a stream of things
happening okay and I can deal with that
by every time reading that value but
then something goes wrong that was what
we saw is like if I if I read it again
well depending on how I read it I might
get only the last value or I might store
previous value so this was definitely
the most dangerous thing so let's make
it more explicit one thing that I could
do instead of just looking at this
variable I could say if the producer
would give me a function and now I have
to say Eric this is not a function this
can never be you know this is kind of
the weirdest thing if you look at
something that takes void and returns a
value
there's not many interesting
mathematical functions that can have
that thing right because a function is
something where you give it the same
argument that gives the same result so
this thing is really isomorphic to just
T so if you but like every like there's
so many functions in Haskell or not not
in Haskell it in c-sharp or Java that
take void and they do useful things okay
so but they're not functions but that's
why they called funks you know they're a
little bit amputated function and but
anyway so what I can do is I can say you
know the producer can hand me the
consumer a funk and
time I want to see a value I will call
that funk and it will give me the value
so now I've encoded that side-effect in
this you know function this little thunk
that you know that I share and I can now
make explicit the fact that I want to
read that thing now if you look at in
c-sharp at least how properties work
properties have getters and setters and
poor Java programmers you have to say
you know get foo and set foo and c-sharp
you just say foo foo equals five but
really what happens is that you call or
when I say x equals get foo or foo that
really means that you call get food so
you call the getter so that's this guy
okay that's one way to do it
the other one is inversion of control
where I as a consumer can give a
function or you know one of those other
rear things because this is also weird
right something that takes it T and
returns void if you look at it from a
purely mathematical point of view that
is complete nonsense because the only
thing it can do is return unit it just
throws away its argument always returns
unit super super useful function right
but there's many functions that return
void to do great things
gonzo the right line yeah should not do
anything because there's void but still
you know my most used function all right
but here the trick here is that I as a
consumer give the producer a function
that it can call to notify me whenever
new value is available ok so there's
these two ways to kind of communicate so
either the producer gives me a function
or I as the consumer give the producer a
function and there you see that they go
and opposite directions and guess what
signatures here also go in opposite
directions whoo something beautiful
starting there and ok so let's look a
little bit more into this ah
there there's an arrow missing here oh
that may be that the PowerPoint ran out
of arrows or what is it that you know to
run out of arrows
um but the thing is that you know and
this is what I'm trying to say here's
like there's beautiful mathematical
theory but when you write code you have
to think about the operational details
and the same here so I kind of already
waved my hand so then I pass a function
to you and you pass a function to me bla
bla bla bla but there's more to it right
first of all there must be some initial
handshake where you're the producer and
the consumer and establish the fact that
you know they want to communicate values
between each other then maybe the
consumer can say you know what I've seen
0 1 2 3 I'm a physicist I know that it
will be 4 5 6 and so on so don't even
tell me any more values so the consumer
wants to tell the producer that's enough
I'm not going to I'm not interested
anymore values and on the other hand the
producer just like here might run out of
value so it has to tell the consumer
sorry guy or girl or whatever program
there will be no more values ok so there
there's there's more to it than just
simple functions so let's sum and go
this and for the Java programmers they
will recognize here the iterable
interface c-sharp programmers call that
enumerable and and the closure
programmers will say oh yeah of course
this disclosure this is the semantic
domain of closure right that this is
sequences and and so sequences yes they
are everywhere there's in Haskell the
only type you use our lists other types
you never even you know I I don't I only
write listed lists or even come here
they're right in the in the syntax
everywhere but anyway so this is the
initial handshake the consumer asks the
producer give me this thing that I can
call if I want the next value and now in
order to get the next
tell you I can get the value or the
producer can say I'm done or Depew
something can go wrong with the producer
either you can throw an exception so
really that function that I showed you
should be something like this so it's
something that takes unit and readers
either a value or nothing
that means termination or an exception
throws an exception something went wrong
well this is the clumsy way you know if
you don't have union types you have to
encode that in a clumsy way I'm sorry
and are there f-sharp programmers here
no F sharp programmers okay good then
this is beautiful if this is this is
such an elegant encoding of union types
and then the other thing here is that
when the consumer asks for the
enumerator the producer gives it an
enumerator but that enumerator is also
disposable which means that the consumer
can say I disposed of this I don't need
anymore values so so this is how it
works good I don't have my glasses on
Dave so this is not going to help and
but I'm okay good so where do is she
where should I stand for them here oh
that's oh I thought I should watch
understood then I have to go look at
Charles and look at second Oh too many
side effects on me all right
good so now let's turn this thing around
so we said like you know one way was
that the the producer could give me as
the consumer dysfunction that I could
call to get the next values but let's
turn it around I want to be in control
if I'm the consumer I'm going to tell to
the producer here's a function and you
can call me back
here's my phone number just call me back
when you have something interesting to
say I'm not going to go I'm in control
so that is this one so what you do here
is you subscribe the producer subscribes
to the consumer by giving it a function
or interface and in this case we encode
again the union type by having three
different functions here and again
there's this way to say I'm done so when
you give the producer your observer you
get back a disposable you then you can
say I'm not interested anymore okay
so here you see that there's two ways to
to communicate sequences of values in
the first case it was the producer that
was in charge because the producer would
kind of you know and you know have this
function and in this case it's the
consumer that's in charge because the
consumer just hands over this function
to the producer and it will kind of you
know notify whenever a value is ready um
but the interesting thing here and let
me see if I can yep look at this okay
this thing here so I had to encode that
weird Union type here but look it looks
exactly the opposite and that reflects
the difference in the protocol where you
know that the protocols work in a
different direction all right so this is
the two ways you can communicate
sequences of values and so the real
trick is that when you look at a program
you should not say oh you know
mutability is bad you should really look
at what are the effects that are going
on and how do you want to communicate
these effects between you know the
different parts of your program and in
this case you have to choose you know
whether you want that sequence of values
whether you want to kind of you know
expose that as an enumerable so as a
pool based sequence or as an observable
as a push based sequence now the
interesting thing I won't go back on all
the slides but you can ask yourself Eric
that code that you wrote that was like
horrible you're iterating over an array
putting all these values in you know
inside the closure inside the list and
then your
renting it out why didn't you just
capture that array directly well that
that would be this case right so it was
kind of weird to what I was doing there
but anyway maybe I want to do kind of do
it in this other way okay so the thing
is that side effects are good side
effects are good you know I don't know
if if he or she agrees but you have to
kind of you think about how you um how
you design the protocol now I talked
here about multiple values now you can
say oh but Eric I'm not doing kind of
mutation I only deal with constants
there's only one value but even then you
can have side effects if you're a
Haskell guy you're saying well you know
I'm never computing anything until you
ask for it because maybe you never asked
for it and then I'll have done something
you know that was not necessary I'm a
lazy person and so that is you know in
some sense a way that the consumer and
the producer communicate right the
producer is lazy it won't do anything
unless the consumer explicitly asked for
it and then you only get one value and
if you ask a second time you you're
guaranteed to get the same value but the
thing is lazy so that's another thing
that you have to be careful about and if
I have a function that returns an int
well that's different than a function
that returns something that when I ask
for it will return the end right so
there's this subtle difference there so
again you have to be super careful about
what what the effects are of your
computation so in this case if there's
even one we can use the type lazy of T
and the lazy of T has one operation
namely give me the value which at that
point will compute the value have
returned it and the next time you ask
for it it will return exactly the same
value that's at least you know the
guarantee there's nothing you know again
since we're here in the imperative
language there
nothing here that if you ask for value
again that will give you another one
right and which is the beauty as well
actually so and now you've asked five
times for this value and now I'm going
to give you something else let's see how
good you four go there you are and
that's the kind of what I usually do in
my code and and then here's my other
favorite type task of T not because I'm
such a task oriented person a more
creative chaotic person but this one has
such a beautiful signature look at this
so what is a task a task is something
that has a continued width method and
look at that that takes a function that
takes a task every there's some value
and then returns a task
Wow it is C this thing seems to be in
the wrong place because why if I have a
task you know why would you you know
give this function why would it you give
me the task now fortunately it also has
this guy here where can that I can use
to grab the result and by the way this
one is a como net okay so um if you if
you're if you're bored now
and you say what's going on here this
type here this is the bind of a como net
so c-sharp actually now has support for
both monads and como nets in the
language I think that's pretty kind of
you know pretty not nice for for a weird
imperative language that it has that now
note and this really makes me sad makes
me more sad than killing that little
animal there is that lazy of T and task
of T are not interface so the enumerable
and observable or interfaces but
certainly these things here are concrete
types and and that is why is that I mean
if you're a programmer I think the
reason is that languages like Java and
c-sharp are too confusing with classes
and interfaces and abstract based types
and whatever's like ah and so there's
too much choice and then well it's just
like the
pigeonhole principle right if you have
too much choice at some point you will
make the wrong choice and so I think
this is a wrong choice here but let's
look at it from the bright side what we
have seen is that we started with one
type so this is the producer that add a
mutable variable of type int and let's
generalize it to type T and then we saw
that really there were four more choices
that were hidden behind that simple
program right so it looked like a
trivial program that just you know was
communicating integers between producer
and consumer but really you know we
could say well you know if this thing's
produces many values I can interact with
it you know in a pool based or push
based way or if it produces only one I
can either do it lazy or in an
asynchronous way okay so there's five
things here and now I like Chinese food
and guess what if you you cannot make
Chinese food without five-spice powder
you cannot make coat without five
effects okay
so these five effects are the things
that make your coat kind of tasty and
beautiful okay and then the other thing
and which I really believe in that these
spices or these effects create a balance
so this is the thing it's when you write
your coat
you have to have this balance you have
to think about the balance you know it's
your codes only push-based or is the
only pool based is it blocking all the
time or so this is all about like you
know you are like the chef and you have
to cook your program and you can cook
other things maybe you know you can make
more money using that but I think you
know cooking code it's kind of more fun
all right
so let's put this kind of young young
thing up here and I'm hippie I don't
know what happens you know here I had
like highlighted this thing here you
know opposites forces a drag this and
that and does this look like young young
all right but
if you look back at the examples I gave
there was this yin-yang right there was
this thing I give you a function that
you can call me back with or you give me
a function that I can show there's this
there were these opposites so there's
something deep in there that you know
when you're coding that you think about
these kind of opposites you know can I
do it in this way or can I do it in a
completely opposite way and since this
is Chicago and there's many people from
financial industry another way to say it
is like every coin has two sides and you
know it you know you always have to look
at both sides but the other thing is
also you have to find where it's the
real value I can flip a coin but you
know I need to make some money right I
need to need to make more coins oh and
where's the value let's look into that
well I think the real value is in making
a distinction
oh now poor guys in Australia I was kind
of jumping around okay I'm still here
haven't disappeared so the thing is that
you that you have to kind of view that's
another thing that I think is super
essential in functional programming is
that you separate the concepts of
interface from implementations in this
case when I gave you this interface for
boo based communication that was an
interface and there's many concrete
types that implement that interface okay
but if you compose your programs if you
glue your code together you do that in
terms of the interface and I think if
anything you know I think functional
programming has more to do with this
concept and with side effects
functional programming is all about
being aware of hidden assumptions and
then making them action making them
explicit or ignoring them
but you know in knowing them knowingly
whenever they don't really matter okay
so let's look a little bit more into
this and as I said
in oo programming I think this
distinction is often blurred because
there's too many ways to kind of do it
half if you have an abstract base class
well it's that an interface or said a
class well it's it's going to be or some
zombie kind of halfway through okay so
and I think if you look at go or old
fashioned call more modern come there
the the difference between interface and
implementation was super super crisp and
clear and in functional programming that
separation is also crisp and clear if I
give you a function the only thing you
can assume is its signature okay that's
the interface and then I can give you
any implementation of that function but
there's nothing more you can do about it
the only thing you can that you know is
its interface so I think that's one of
the strong points about functional
programming is that it kind of forces
this strict separation between interface
and implementation whereas you know I
don't even know here's a protected
virtual partial Bligh's again my head is
starting to spin I always have to admit
this every time I have to use all these
you know quantifiers I have to go and
look in the manual what does this mean
Oh protect it oh is that something
different than kind of you again
JavaScript everything is public so why
do it so can anybody tell me why Java
and c-sharp have this kind of crazy
stuff where it's like the language that
everybody uses has only kind of public
things I don't know so I make everything
public I don't like private all right so
let's let's look at some Haskell now
okay and again I'm not trying to teach
you ask oh I'm trying to teach you the
thinking
that I think is the value behind
functional programming so let's look at
this thing here fold our that's
something that takes a list and let me
go make sure to extend here something
that takes a list and folds it down to a
value of type B so take a list of a and
it folded down to a value of type B and
what it does it says when you have the
empty list that's the first parameter
there that's B and then when you have a
stich composed out of you know an
element a and then the result of folding
the less then you just got to apply the
first operation so this is kind of a
higher function everybody's usually as
fold are um
you already see here that this thing
takes two functions or in a long
function and a B and in that sense it's
good because it's it strictly separates
the interface from the implementation it
says if you give me B and this function
I can now reduce this list down to a
value but if you're a real Haskell
programmer you see that there's still a
concrete type there's still that list
these angle brackets first of all this
is a kind of one of the only types that
use this kind of dist fixed notations
like us ice or I don't want to see that
and but also me why couldn't I fold
anything else why can I fold only lists
so in Haskell you can say well as long
as there are certain operations on here
and I will show you in the next slide
what they are I can fold something of
type T of a to a B if you give me these
two functions this is quite remarkable
so well if you're if you're using
closure there's no types at all so this
this probably all doesn't make sense to
you in the first place if your
JavaScript programmer you know you don't
use types at all you don't know what
this means either and but if you're an
f-sharp programmer or a Java programmer
or a c-sharp programmer or a VB
programmer we all love VB of course this
is really weird because this is a
generic function where the type
parameter is a type constructor and that
is the thing that I miss most in C sharp
and F sharp and and whatever functional
languages that they don't have these
kind of you know higher kind of types
I think Scala has them by now and but
this is super powerful because I don't
want to have something that only works
for lists I want to make it work for
arbitrary data structures okay and
that's what this thing kind of
allows you to do and then you can write
functions like this saying you know I
can find something in a container of A's
if you give me a predicate and then this
thing must be foldable and you can see
that's probably implemented in terms of
fault so now this type gives you a lot
of information because it kind of tells
you exactly what are the assumptions on
the types that you need in order to make
this implementation work but it says
nothing more and nothing less so that is
I think the important thing of types why
I like the types is because it it gives
you this kind of specification of this
problem in a very abstract way that it
just tells me as a developer this is
what you need to supply then I will I
can kind of you know find this element
for you now in Haskell there's these
things called type classes have nothing
to do with glasses in in c-sharp or Java
and but the type class is really you
know just a collection of functions and
so here's like a monoid something that
you might you know if you go to a
cocktail party or you know maybe
afterwards anyway the beer yeah today I
kind of defines three Menards yeah whoo
but I defined five monads open I didn't
go monads here so it's like yeah but
what is a mano it it's just something
you know that has a binary operator that
can kind of glue to two of them together
and then there's a neutral element
that's all moloids are not kind of your
dead special so when this Haskell people
love to have these kind of things for
Manos whatever they try to impress you
don't believe them
all right but here's the thing okay and
this is where I want to kind of get at
is that if you're using these type
classes and really if you have a
signature like that it says you know
fault you know assumes that M is amyloid
and then you know U of M to M really
that's a shorthand for passing three
functions as an argument to that
function except that the compiler will
inject that stuff for you so I want to
make a remark that you know dependency
injection is for people that don't know
Matt and I still believe that because
what this is really doing this is kind
of you know dependency injection is
controlled dependency injection but your
explicit about it I don't want to have
something in some XML files a glue XML
and they kind of dent changes how my
program behaves okay so the whole point
about functional programming is that you
make everything explicit you're super
explicit about it and then when you know
what you're doing okay now you're a
little bit competent then you can let
the compiler take care of it
okay but never ever pretend that you're
smarter than whoever's like oh well I'm
just doing your XML file here on the
side and now that's really kind of you
mess around with my code no no no you
have to be able to express everything in
terms of this super explicit thing with
you know look what that means is this
and so you know whenever the compiler
can figure out that there's only one
choice for that monoid yes then it can
eject it but not because you know you
wrote that in an XML file okay now if
you would have looked at this type and
you know listen carefully to me you said
Eric but are you talking about there's
still a concrete type I still see that
arrow you have not abstracted to the
extreme and you're such an extreme
person and now you're coming look at
that
one two three four five arrows in here
how can you do that
I mean it's staring in your face that
okay so if you go all the way all the
way even this arrow is something that's
not a concrete type that should be an
interface then you get category theory
okay so again category theory a lot of
people are scared about it it's nothing
it's just mathematicians doing interface
based programming okay that's it
so now you know category theory and and
so what they're saying is that well all
I need is I need to have some function
from A to B what do what are the
operations on the function and they
don't call it function they call it
morphism that sounds better
morpheus yeah a direct bill okay so I
have to go from A to B or there should
be like some arrow here and if I can go
from B to C there was an arrow here from
A to C so that's the composition that
arrow disappeared I think this is when
you go from PowerPoint to keynote and
the arrows disappear and and then you
have to go kind of you know this is what
mathematicians like they kind of like
things to be kind of you know that if
you have a that you can go to a and that
you know if you can post it that kind of
falls out yeah sure
so really this is like a Malloy - it's
gonna be a semicolon as the kind of your
composition operator but forget about
that okay
but now the trick is that you should not
fall in love with category theory I see
so many people and I was wrong
myself Oh category theory you go into a
black hole you go into a rabbit hole and
you know what's down in the rabbit hole
okay what the rabbit droppings right you
know you don't want to come out of the
rabbit hole all kind of your emergency
on so don't go into the rabbit hole of
category theory okay show that you're
proficient and just step back and say
okay I understand what they want
just kind of for mathematicians that
also try to be like programmers okay I
see it
good move on with your life and but of
course mathematicians are much smarter
than us okay
I'm like look you're if you're in the
kind of financial industry you're
writing code or everybody you know your
mathematician friends or your kind of
your physic physicist friends those are
the clones those are now they are kind
of eating caviar somewhere you know
across the street okay so we should
learn from mathematicians we should
steal from their ideas so if you look at
category theory they also know young
young only they call it duality and they
don't make kind of a big deal like warm
and hot and sharp and soft but now they
just say you you reverse the arrows and
then you get something useful oh great
so if I kind of reverse the arrows I get
something useful so that's how I kind of
invented this thing you know these two
protocols I just looked at one and I
said okay I'm doing the young young
thing and I can reverse the arrows and
there must be something useful there too
great but then of course I don't say
that now I'm teaching all my tricks to
you and but that's all you do okay
don't go into that rabbit hole just look
at that say okay that's some idea I can
steal and um yeah monads don't it's like
if you ever hear yourself say the word
monette go contact a shrink okay
something is deeply wrong with you okay
let's go back it's my last slide nearly
because if you looked at what I was
trying to do I was trying to solve a
practical problem does it really matter
that these guys are dual I don't know
it's kind of used it as a trick to go
from one to the other but does it really
matter I don't know does it matter that
both are mow nets and como nets that
they're self-dual does it matter that
your brain is now in this kind of knot
where you know it's kind of all tied up
and you I don't know it solved my
problem I got
paycheck so I'm happy okay so the world
is imperative never forget that okay
never forget that if somebody wants to
prove me wrong I'm happy
okay functional programming is a great
tool for thought but imperative
programming is the tool for hackers
thank you very much I completely lost
track of time so I don't know all right
that's great everybody's scared that
they were there they will end up yeah
okay rich
ah what I mean by value is nothing
special okay so and I know that what we
will see from you that you did you kind
of you know for you a value is something
that's kind of you has kind of magic
powers
for me if value is anything that I can
assign to a variable in c-sharp or Java
that I can smack and mutate and whatever
it's just something that I can stick in
that you know in that position and so
there's nothing special with that and
again because the value news if it
matters that this thing is a value in
kind of you know in your sense I don't
know I haven't seen your talk yet but in
that case you what I would say is you
have to make that effect explicit and so
if you have an enumerable of tea but
that tea itself you know you want to
consider that as a value you might want
to do it as an enumerable of lazy of tea
and so you kind of push that that you
make the effects kind of explicit until
the value the mutation of it doesn't
matter anymore so this is about like
whether you do you know it's like the
essence right you push it as far out as
necessary but not for it farther and
sometimes you say I'll just mutate it as
is so that's yeah the quick answer here
so I'm a super pragmatic guy I mean I
just want to get my work done and I'm
happy to still left that right but
sometimes you just have to kind of you
know kill the baby
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>