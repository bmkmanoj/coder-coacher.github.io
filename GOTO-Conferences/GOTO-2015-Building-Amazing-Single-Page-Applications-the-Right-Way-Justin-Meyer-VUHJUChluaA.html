<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Building Amazing Single Page Applications the Right Way • Justin Meyer | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Building Amazing Single Page Applications the Right Way • Justin Meyer - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Building Amazing Single Page Applications the Right Way • Justin Meyer</b></h2><h5 class="post__date">2015-07-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VUHJUChluaA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello and welcome to building single
page applications the right way as Brian
said my name is Justin Meyer I'm the CEO
of bateau B and for the last eight years
all I've been doing is building big
JavaScript applications for in every
kind of situation you can imagine and
this talk there was about 30 in that
slide this talk is about is about the
top techniques or the most unique
techniques we use to build
high-performance maintainable and a
little bit fun JavaScript applications
I've structured this talk into ten five
minute lightning talks so I'm gonna have
to go extremely fast it will get a
little technical if you if you don't
understand some of the code or the
slides just try to listen to the sound
of my voice because it'll be explaining
in principle what I'm doing just ignore
what you see on the screen so uh with
that in mind oh wait one first thing I
got to talk about I created a place my
order application that is a simple app
that encompasses all of the techniques
thank you whoever just turn up the mic
you could find it at the Tobii slash
place my order and I'm gonna you be
using it for all the examples and
techniques I talked about today so I'm
just gonna go real quick and show it's
in the app so that when we talk about
these techniques you can see how it
applies very simple app has a home page
when you server-side rendered when you
choose a restaurant it's gonna make a
push state that allows you to pick a
state and pick a city and get
information about a restaurant and place
an order so you go to Chicago and three
one two of course and I'll place my
order and once you place an order you
can see an order history where you can
walk through
each order through different states so
it's preparing out for delivery
delivered and this is a real-time
application if someone else was on it
making changes you would see those
changes so this app if you do check it
out on github has everything that I'm
talking about so you can go back and
learn these things in detail so despite
how technical I said this talk was gonna
be the first thing that I think we do
unique epitope II is make use of check
lists check lists have a long history of
making everything better from helping
pilots fly to helping doctors save lives
we have a checklist project that you can
see here bateau v github io checklist
that is a really simple checklist that
has just a bunch of management UX and
development questions things like are
there social events are there what is
the vision for the project in the
roadmap do you do user experience
testing do you that's another good one
do you do source code reviews
I think checklists have worked really
well for us because let me get back to
presenter view because I think everybody
knows what needs to be done on a project
it's just hard sometimes prioritizing it
we all know we should be doing code
reviews we all know we should be writing
tests sometimes we don't do it mostly
because you know we have other
priorities other things we're thinking
about a checklist makes it easy to make
sure everybody's doing the right thing
at all times because we've done so many
projects over probably like 34 projects
now we have some interesting data -
regarding what impacts what strongest
what correlates strongest with success
so these are the highest management
related things that correlate to success
obviously the the number one thing that
correlates to success is can you release
a project within six months right that
that's an obvious one
things like yearly trainings and
companies that actually have social
events for their team outside of work
those also strongly correlate to success
the design things that correlate
strongly to success doing user testing
getting design documentation now here's
the really interesting thing these are
the highest development related factors
that correlate to success and they're
far they correlate to sex success far
less than most of the management and
most of the UX questions so this having
checklist at least for us as a company
has guided us and kind of humbled us
because we realize that management and
user experience decisions often matter
much more than technology decisions but
as technologists we're constantly
getting hung up in framework battles and
things like that or if you really care
about the success of your project you
might look into some of the more the
management user experience items that
your team should be doing so that's the
only non-technical one so let's get into
the technical stuff so I found this
awesome quote on goop JavaScript guru
chrome team engineer addy Osmani x'
website and it says the secret to
building large apps is to never build
large applications break your
applications into small pieces then
assemble those testable bite-sized
pieces into your big application it's
extremely well said that that's that's
me that's good joke but I think it's too
small so you guys can't read it realize
how hilarious I am so one of our
earliest most important development
strategies was the introduction of the
mod lit workflow which treats every
module as its own application what this
means in practice is that instead of
organizing your projects like this where
every module is grouped by type you have
a folder for all your JavaScript files a
folder for all your CSS files we always
group everything
every module in its own folder every
module had some folder has its own tests
its own documentation any other files
like CSS or templates that are
associated with it go in that folder and
there's two other things that we include
we always include a test page that runs
just that modules tests and for visual
widgets visual modules we include a demo
page that shows off just that that
modules functionality so the benefits to
this are it's easier to identify when
someone's missing tests right because
you can look in the folder and say hey
there's no test file also I think
developers are much more likely to
update a test when the when they're
working in a module and the test is
staring them in the face because it's in
the same folder and of course levy
making tests and making demo page leads
to good API design and finally I think
the biggest one is that it you can
develop in isolation you can work on
your module and it's tests just within
one folder completely ignoring the rest
of the application
so I have a quick example of this in my
so I have my app order page which you
can see here I can I can edit that I can
this is the just the order widget and I
can also run its tests pretty pretty
basic and this looks like in the code
here's my order and I have my demo page
that loads imports my my order component
and uses it in the page and that's as
simple it is to get a demo page and a
test page I'm just loading the order
test tests highly encourage people to
use this pattern okay
number three so we've taken lately we've
taken the idea of every module is its
own application to the furthest extreme
that I know by putting a lot of our
modules in their own projects and then
publishing them to NPM and then
importing them into our big project so
for example the place my order app has a
tabs widget instead of you know hiding
it away inside you place my orders code
we created a standalone put it put tabs
in its own repository with its own tests
and to import it into our project it's
as simple as just NPM installing bit
tabs which will add it to the node
modules folder and then to import it
into that order that order a module all
I do is import bit tabs it is a custom
element and I'm using es6 syntax if
people don't recognize that and because
it's a custom element all I have to do
is add bit tabs to my page and I'm going
to create a panel for the lunch menu and
I'll eventually create a panel for the
dinner menu as well and to make it I
just loop through each menu lunch item
add a checkbox for if the if the if the
lunch menu item is selected and at its
name and price and then I'll just copy
this code to make the dinner menu
so hopefully you can see how one side of
the putting things internal repository
pulling it from NPM can be made
extremely easy right on any other
project that we have we want bit tabs we
can just npm install it and use it as
quickly as I just showed now if you're
using common Jas and browserify you're
like this is old hat I've seen this
before but if you're using common Jas
and browserify you only you're limiting
who can use your code and what code you
can use because one of the biggest
problems with client-side JavaScript
development is the fragmentation of all
the different module loading syntaxes
right there's upcoming es es6 syntax
which is the import bit tabs there is
common JSON browserify
there's the timer
there's the AMD and people still stuck
in 2005 we're using script tags and and
link tags to load their well they load
their JavaScript code so we use a
project to build our applications called
steel Jas and that allows us to here's
the tabs code no matter what bid tabs is
loading if it's CSS templates other
common J's modules or AMD modules we can
export this project so that it can be
used by anybody who's using AMD common
Jas es6 so this will run a script we I
run my grunt build script and you'll see
it'll create a dist folder with all of
these exports so--but tabs can be used
by anybody you'll even see that the tabs
less file was transpiled to CSS and we
inserted the CSS plugin for requirejs so
if you're using AMD you can actually
require this tabs and the styles it
depends on so my hope for all of this is
obviously we use it for reuse a lot we
can create widgets use them in all their
different projects really easily also
when you pull something out and you
publish it to NPM it adds that very
useful bit of
data for the semantic version of your
package because when everything's tucked
away in application and someone makes a
changes a module that your code might
depend on you don't know if they've
added a new feature or they've broken
the API or they fixed a bug when you
publish something to NPM people are
putting that version number and
typically it gives you a good idea also
it's made release management easier for
us we'll actually put our pages in
different repositories for a big site
and then if we want to assemble the full
site we just point a specific versions
of different pages and if one page
version is breaking well we just roll
back to an older version and redeploy
the site which is really nice and
finally my hope is for projects like
Steel Jas that it can improve
client-side open source there's a big
problem in JavaScript open source
community right now comparative you look
at nodes where there's few projects that
depend on other projects it's very hard
to build like a rich hierarchy of
advanced functionality in JavaScript
because of all the different module
loading syntaxes but if we can make it
so that you can use any module syntax
you want and export it to every other
module syntax well then my hope is that
we can start getting this rich topology
of open source JavaScript projects so
this is this what I just showed it
enables that number for custom HTML
composition custom elements are
everywhere I'm gonna talk about why
they're awesome and I'm going to talk
about what I think we do special with
custom elements so first why it's
awesome
some of you in this room might be old
enough to remember the old days whenever
you wanted to add functionality to a
site you would have to put add some HTML
to your page and then you'd have to in
your JavaScript find that element and
invoke some behavior on it that's all
gone now because every modern framework
lets you define custom elements and a
custom element when it's inserted into
the page
you know instantiates itself so this is
what it looks like in react this is what
it looks like an angular
this is what it looks like in kangjae s
which is what I'm using for this
presentation when we design our
applications or char when we design our
custom elements we design them with this
guy in mind this is the Toby's UX
director right he doesn't know
JavaScript but he knows HTML and CSS we
have two goals we want to make our
templates so that he can understand them
but we also want to make those l custom
elements powerful enough so that he can
express behaviors without Bob bothering
the engineers all right so you can
change and add a lot of richness to the
page without himself just by
understanding these elements and
rearranging them so we have once we have
two strategies for that the first one is
a tag team of two different types of
custom elements the first are custom
elements that can actually load data
into the page into the template and the
second are custom elements that are
composable themselves here's a eggs for
example I have a bit graph component
where as I add different series
it'll add you know new lines on the
graph given some data so I'm gonna show
a quick example of this in action let me
refresh the page okay so here I have a
page that showing a single restaurants
order history the amount spent on per
each order and this looks like this this
looks like this I used my order model to
find all orders for cheese curd City
that's the name of a restaurant it
sounds like it's from Wisconsin and then
I putting that data into the template
and then I'm using that data for this
bit series now let's say the designer
wants to add another cook do a
comparison comparison between cheese
curd City and some other restaurant
who
tene palace I'm not gonna type it out
instead I'm going to steal the code they
can add another order model so this is
going to load poutine palaces data into
the page and then all they would have to
do is add another bit series for that
data and then save the page refresh it
and they have created their own new
behavior right they've loaded data
themselves they've added a new line to
the graph so that's the first thing we
do the second thing that we do is and
you might have noticed it we actually
allow people to declare dependencies in
the template themselves so here that can
import from UI bit graph it graph that
is actually doing the importing of that
module into the page this is great for
our designers so if they wanted to add
bit tabs to the page well they just
import bit tabs can import bit tabs and
start using it in the page again they
don't have to bother us as the engineers
so the final thing that we do isn't for
our designer it's for us and I really
love the upcoming web components spec
and that you can kind of define
lightweight components in cost kind of
in in the page directly this is defining
a hello world component that you can see
it's template and a style and its
behavior we have our own version of this
where you could define a can't component
and give it its tag its styles as less
and build things this way so I really
like this four because what happens if
in a big application is you tend to
start actually getting a lot of little
widgets and you don't want to have like
five different files that's less file a
template and a view model for something
that can be quite small
okay the next one is number five is unit
testable view models this is all about
how we design and test and build our
view models and building view models
really like all a lot of times the most
work that you're doing in a big
JavaScript application so I'm gonna use
this example the restaurants ordering or
the sorry that when you pick your
restaurants page and this page loads the
states then you can pick a state then
you can it loads your cities you can
pick a city then you see your list of
restaurants and then if you change your
state it really removes the restaurants
and reloads new cities for that state
but then you have to pick and it clears
the city the city option right this what
they chose for their city so first thing
I always do is course look at the
functionality and then I identify the
values that represent the state right so
the way that I always do this is I have
some kind of JavaScript object that I
keep track of all of the staple
properties of this of this user of this
of the like you the design or the
behavior whatever you want to call it so
first thing you can see is we're loading
States so I'm gonna have States as a
promise that's going to be an array of
all the state data it's going to resolve
to an array with all the state data I'm
gonna say that the state that they pick
I'm gonna save that state as the as a
string for which state they picked
cities is going to be a promise of all
the cities that are loading and the city
that they selected is gonna be the name
of the city and then finally there's
gonna be restaurants was just gonna be a
promise with all of the restaurants
right there's the first thing I do when
I'm coming to a page to design it is I
figure out these properties and the
behavior for these properties the second
thing I do is I write a test for the
view model I'm a big fan of test-driven
development
so this is all gonna be I'm gonna go
through these slides really quick so if
you don't understand it
again listen to the words of my voice
pay no attention to the screen so to
test it I set up my testing
infrastructure load the modules that I
need then I create my fake data for my
test because my my view model is going
to reach out to the model to ask for you
know restaurants and states and cities
then I use this fixture utility to
hijack all Ajax requests intercept them
and instead use the fake data that I'm
providing so instead of when a when we
try to do an address request to API
states and instead we'll use our fake
data that I'm providing and then finally
I'll create an instance of my view model
that I'm going to create restaurant list
view model and then I'll just verify all
the different steps I'm gonna make sure
that the I'm gonna make sure that my
state's property is a promise and I'm
getting back all my fake States data
then I'm gonna set the state to a state
property to a state and then verify that
I get my city's changes and I get a list
of cities from the same same cities that
match my fake data and then I'm going to
set the city and I'm just gonna keep
walking through this it's gonna change
the restaurants and I'm gonna get the
right restaurant data back and then
finally I'm going to set the state to a
different state and verify that the city
value is removed and that I'm getting a
list of all cities a list of new cities
so that's how I write a test just
testing the behavior of the view model
and those properties so finally I'm
gonna write the view model and this is
again this is with Kas this is what it
looks like it becomes really easy you
just define the behavior for your
different properties the state's initial
value is all states loaded from the
server the state behavior is is side
effectual whenever the state is set I
want to remove whatever city was set
because if you're changing this
the state well then whatever if City
you've picked should not to not count so
remove it then I'm gonna define the
behavior of the cities cities is
dependent on a state so if there is a
state I'm gonna return all cities for
that state and otherwise I'm gonna
return no some of you might be asking
that's that's not valid jobs from syntax
it is I'm using es6 syntax that makes an
object with state : state next and
finally I'm just gonna define the
behavior of the restaurants which is
just like cities if there's a city in a
state return all restaurants for that
city state combination okay and then the
final thing is you just write your
template so here the the template is
just I'm just showing the part of the
template for the state drop-down and you
can see I'm doing things like disabling
the Select until it while states is
pending while it's pending I'm showing
loading as the only option and then if
the person hasn't picked a state I'm
gonna say choose a state and I'm gonna
go through the list of states and list
them right so I think the benefits for
this model are really that if you're
figuring out the stateful properties of
your view model and then testing them
then the implementation becomes easier
to do and then finally your templates
become super straightforward right I do
everything in that order okay the next
one is two-way routing I'm gonna explain
a difference between two-way routing and
one-way routing giving an example use
case and the talk about the benefits of
two-way routing so everybody's familiar
with one-way routing especially if you
come from the server-side world one-way
routing you take in URLs and you get
back typically in the server it'll call
some method somewhere but really one way
routing means you get some URL and you
get some data back out from it it goes
through the routing rules and gets back
out some data
so if you had restaurants cheese city
goes through these routing rules you'll
get restaurants cheese city as data
similarly if you had restaurants cheese
city loader goes through goes through
these routes you're gonna get this
object back to a routing allows you to
go from the data back through the routes
to get your eventual URL and I'll show
why this is really nice a second just
give one more example if I had page
restaurant state Illinois City Chicago
went through these routes I'll get a URL
that looks like that so the benefit the
real benefit which I'm going to get to
for two-way routing is that you can
change if you're using two-way routing
you can write your applications so that
you can change the routes at any time
and you only have to change the routes
and the rest of your application just
keeps working but to do that you have to
change your code slightly so I'm gonna
show the changes in code so a lot of
times people write their apps that look
like this if the route matches some
pattern do this otherwise the route map
which is some other pattern do this to
use two-way routing the first thing you
need to do is change your code to
instead use stateful properties that are
on the route so instead I'm going to
check if the routes page property is
home then I'm going to render the home
custom element otherwise if it's
restaurants I'm going to render the
restaurant list element so that's one
change you need to make is go from this
to this the next change is instead of
writing your urls like this where you're
kind of writing them manually yourself
in the template instead you use a
template I use a helper that is going to
go through the reverse routing algorithm
and this will take page restaurant slug
equals slug and convert it to the same
href we saw before but the magic of
two-way routing is that if you go from
this these routes to these routes well
everything still works because it's all
just checking properties and all your
URLs
are created through the reverse routing
algorithm so the benefits it allows you
to write your route your URLs one way
there
sorry manage all your URLs in one space
and have the rest of your application
just work no matter what your URLs look
like okay the next one is number seven
and this is the one I'm probably
personally most excited about talking
about
I think we've solved in a really good
way how to do real-time connections and
a lot of performance optimizations in
the in the client real-time and
performance optimization this can be
really tricky to get right sometimes
let's say I had two widgets that I
wanted to put in the page and write
independently and these are each gonna
show a one's gonna show completed two
dews the other is gonna show incomplete
to do is just some questions to prompt
you guys thinking how do we make these
two can be combined to make a single
request for all to Do's how would we do
that when a server-side update happens
any new to do is create it how do we
manage which list to put it in how do we
manage when update happens to move it
from one list to another list and then
how could we save this their data in
local storage so we don't have to make
the same request again the answer to all
of these problems is surprisingly simple
it's set logic
yes sets as it as in Venn diagrams they
might be wondering why sets the reason
is because whenever you request data
from a page you're actually providing a
represent a tour you're requesting data
from the server you're providing a
representation of the set that you want
of the data that you want to load all
right if I wanted all to dues for user
five that are completed true I might do
something like this and set a represents
you know a set now if you treat that
like a set
and you can use that to compare to other
sets so I have set B here set B is user
fives completed to do not completed to
Do's who are critical set B represents a
subset of set a so I know if I've
already loaded set a I don't have to
load set B's data so we created a low
level library that allows us to do set
comparisons with objects that look like
these it also lets you create custom set
algebra so that you can compare other
things that are not like just straight
properties so if I wanted ranges or
enumerable enumerable properties or
boolean type properties then I can do
things like this which is compare knows
that the arrange that starts at 0 and
ends at 50 is a subset of a range that
starts at 0 and ends at 100 now with
this set logic I'm gonna start walking
through a lot of the performance
optimizations that you can do so the
first one is you have two different
widgets that are ones loading completed
to dues the others loading incomplete to
do is you don't want them to know about
each other but what you can have them go
through is the same model layer and that
model layer can see incoming requests
wait an instant until a few might have a
chance to come together at least ones
that are coming at the same time and it
can do a union of those sets and instead
make a request for all data let's say I
went to a page showing all completed -
dues and that requested the just the
completed - dues from the server and
then I went to the page showing all -
dues well it's gonna request all - dues
like that but I can do a set difference
and get and know that I just actually
need to because I've already loaded
completed ones I know I only need to
only load the incomplete ones now where
the sets really kick in is real-time
connections so let's say the server
pushed some data for Anu to do complete
false ID five
they do do dishes you can read now I've
got now I know I've got two different
sets in the page that I'm currently
showing I'm showing the complete and
incomplete we can do the same set logic
to see that the new to do set is a
subset of the incomplete set and then
automatically insert that new data into
the list and let lie binding take care
of just actually inserting into the Dom
with like no additional logic right the
super model will take care of this and
I'll explain how in a second so this
place your order app place my order app
has using sets all of these things
automatic live updates it does inline
caching which I'm gonna explain it can
combine requests similar to how we
already saw and it also supports fall
through caching and all of this stuff
you get for free with this underlying
set logic I didn't have to like do
anything special for this just just to
work in my application so let's talk
about how inline caching works so this
is a great technique if you're doing
server-side rendering when the user
comes to the page they're gonna request
the HTML to page and inline in the HTML
of the page you're going to put the data
for whatever that page is gonna then
request in this case we put in inline
cache variable and then the page is
gonna be drawn but then JavaScript is
gonna start running and it's going to
try to make a request for the new
preparing delivery and delivered orders
the super model it's going to go through
the super model a super model is gonna
see hey you're requesting sets of data
that's already in the inline cache I'm
going to send that right back to you and
the page isn't gonna change because it's
just getting the same data that was
already used to render the page but the
page will now be live with the data that
it needed to add rich behavior and then
it'll use that data to update local
storage which is important for the next
thing which is the
fall-through cash so the fall through
cash works by when someone goes to this
page with push date it's going to make a
request for all the data for the page
it's going to hit the super model and
the super model is going to say oh this
is all these different statuses
represent all the order data so I'm
gonna combine that into a single request
and first send that request to local
storage local storage is gonna respond
with that data and it's going to be use
that to satisfy all four of these
requests and draw the page but in the
background it's going to make a request
to the server get the data get the data
from the server it's gonna make one
request to the server and then use that
to update the items in the page and
it'll do any insertions or removals with
the new data in the new list
automatically and let's talk about how
real time works so real time works by
the server's gonna push an updated event
the super model knows about all the
lists that are active on the page
because when you requested the data and
it gave you back a list it knows about
that list it keeps track of it so when
the when update happens let's say it's
changing a new item from new to
preparing it's going to see that the
item no longer belongs in the new list
and it now belongs in preparing make
that change to the to the to the data
model but then live binding will just
take care of moving it in the right
place so you get real-time behavior for
free with sets so I think it's just
because I like it so much I think it's
worth worth showing real quick so if I
have my place my order
so here I can just delete orders and
they'll just disappear on the left right
real-time but I didn't have to do
anything other than just called destroy
on my model because that'll send the
real-time connection out or is they'll
send a request and the real-time
connection will say hey something's been
deleted it will go through all the lists
that the page is currently rendering and
just remove the item automatically I
think that's nuts that you can get
real-time for free hopefully you guys do
too okay
number
okay
number eight live reload so I'm just
gonna start with a demo for this so you
guys if you've ever used requires a s
you know that sometimes in a very big
application it can take a long time to
reload your page so I'm just gonna see
how long it takes to reload this page
okay just taking two point four six
seconds we use a lot of live we use live
reload technology so I can run and
connect this to a live reload server and
now what I can do actually I'm do it in
the order history page I just want to
show the speed difference in which you
can develop with live reload so you can
see that and I save and it's almost
instantaneous how fast I can see the
results of changes in my code and all I
have to do is save it and it just just
works so I'm gonna talk about how this
works but first want to say why it's
awesome if it's not self evident so it's
awesome all it's all about human
attention span really if I have to wait
two seconds for my page to reload that's
when I start thinking about reddit or
checking my emails or something like
that but if I could just make a change
and see the page update right away
within a second then I'm staying focused
on my tasks live reloading how it works
first let's talk about how loading works
without live reload with something like
requirejs
you go to your page it's gonna load your
main module then it's gonna load your
main modules dependencies it's gonna run
any of the dependencies that don't have
dependencies themselves then it's going
to keep loading dependencies after
dependencies until it loads the whole
dependency graph and then it's going to
start executing these things
until it finally executes history module
the main module which will typically
write write out what the page looks like
live reloading what it does and why it
can be so fast is that when I change
history less what it's gonna do is it's
gonna delete that modules code and it's
gonna mark any parent modules as as
needing to be re execute 'add it's gonna
just have to download that one file now
and then re execute it and just only its
parent modules and then it'll update the
page with a different color like I
showed so this saves a tremendous amount
of time you're not having to redownload
jQuery you're not even having to execute
jQuery you just make a change and all
the modules kind of re-execute
themselves that need to just cool that's
all about that's a fun one not about
performance but this one is very much
about performance we like I feel like
we've solved how to do models really
well I think we've solved how to build
your application so it loads as fast as
possible really well and in a very
unique way okay
so I'll go really fast through this oh I
thought I had eight minutes my timer is
off okay cool okay so it's starting at
the wrong slide here so I'm going to
explain I'm gonna try to go through this
really quick because I like this I'm
gonna explain how to optimize a site
that's not progressively loaded because
the same techniques apply to a site that
is just kind of different static pages
here's my static pages and here's the
modules that they load first thing
people do typically when they're
building a site like this they'll just
cram everything that a page needs into
one production file which isn't great
because then if things are used across
all the different sites every time the
user switches pages they're having to
redownload more than they should have to
so the next thing people do is they'll
say oh I'm going
I want to bundle that I want to create
those modules in their own bundle and
then I'm gonna have all my pages open
that bundle right so that I can
experience some benefits of caching
now the problem with this is that it can
be tricky very tricky without a lot of
trial and error to get the optimal
arrangements of bundles what belongs in
what what you know can J s was only used
in three of these modules maybe I should
have another bundle that these three
three of the pages load and then they
all still also load the core bundle you
can make those decisions forever and
never get it right but we have an
algorithm that can so I'm gonna do my
best to explain how the algorithm works
if this is your dependency graph the
first thing it does is pulls out all
modules that are the most shared so
jQuery and title CSS shared by
everything combines them these three
things are used all together so combines
them slider is used by restaurants in
order so I'm like um I'm at and I'm just
gonna keep combining modules until I get
this kind of setup we're basically in
this situation I'm gonna line up the
dependencies homepage would have to load
these bundles restaurants would have to
load these bundles order would have to
load these bundles and history would
have to load these bundles now this is a
dependency graph all of its own where
you have perfect caching but and every
page only loads exactly what it needs so
home pages only loading what it needs
but the problem is restaurants here is
loading five different scripts right and
if you have 20 pages with overlapping
weird dependencies you might have to
start loading a ton of bundles that's
where the second phase of this bundling
algorithm comes in what it can do is it
tries all the different combinations
which is like you know an NP complete
problem but typically hopefully don't
have too many bundles so we can try
every combination and try to combine
bundles and then it checks how much
extra code any one page is gonna have to
when you combine bundles so homepages
you have to load slider it's having to
load two kilobytes order is having to
load 30 kilobytes because they have the
loading can jazz carousel and carped so
it'll try different another combination
in this case it's gonna combine these
two so now restaurants is only loading
four modules still and in this case the
extra waste to any page is only seven
kilobytes so use that combination and
then keep going on to if it has to to
combine other other modules is a way
that you can get perfect caching and the
only cost is your maybe loading a few
extra bytes of code that some other page
is gonna need that is you're likely to
go to that page anyways so that's our
bundling algorithm the the only other
thing I want to say is how cool we can
wire this up our act our main module of
our application is actually a template
and because we can do loading from the
template this is how what it actually
looks like we kind of have our routing
rules and we'll import if someone
navigates to the home page we import the
app home bundle and when it's resolved
we put that element in there and this
way we can show a spinner as the users
JavaScript code needs to load or
anything like that
finally server-side rendering it's all
about getting rid of these kind of
spinners I'm gonna just talk about real
quick how we do it it's good for SEO I
have four minutes so I can okay it's
good you want server-side rendering for
perceived performance so the app loads
and the user can see their their page
even if javascript hasn't fully
initialized yet and it's great for SEO
the technique that we use is to run
everything in a single context virtual
Dom alright there's a lot of different
techniques what this means what single
context means is a lot of times people
well I'll talk about it doesn't mean a
lot of times people when a new request
comes in they will create a headless
that will create a new context in node
and which means that it has its own
set time out it's kind of like your own
window endowed own dot new document and
run all the JavaScript code import all
the JavaScript code and run it in there
we don't do that we always run in the
same context so basically that means all
of our rendering all of our code we only
have to load that once and our rendering
we're not we're not creating like a new
document every time to render and we're
using a very what virtual Dom means is
we're using a very lightweight Dom it
really only has like a penned and insert
before and like remove child it's like
the very few and setattribute very few
methods very lightweight very fast and
then I'll talk about when you do things
this way the cost of it is you have
everything is connected to the render
lifecycle where because you aren't
running in your own context it can be
tricky to know that all Ajax requests
have finished because there might be in
the same context other Ajax requests for
a different page response going on and
you have to work that out and I'll
explain how we work it out but first how
do we set up how does this app set up
the server-side rendering in general we
load our main module which is that stash
module with a special plugin because it
adds node rendering to it and then from
we get a request however you know in
your application you get a request and
response object from node we do that
then we take out just the part of the
path of the URL the requested URL that
we care about and we have a special
render node function that just takes
care of rendering that template with the
with the virtual DOM and it returns a
promise that resolves to as you can see
here the HTML of the rendered main
template and any data that was
associated with that page request so if
we're waiting for States to load that
will include the States data and we
basically passed this all to a layout we
also you can see here we loaded layout
that stash which is
just a template that has a body tag and
HTML tag that we can insert our main
stash into and then we render that and
send the result back to the client the
only other thing that is what I wanted
to mention was that to hook up you know
to prevent the rendering and to send the
data along with the page response for
the inline caching we do this so if we
have our restaurant view model up at the
top where was getting all the states for
the component that it belongs to we wait
till it's inserted we get that promise
and we get our topmost view model and we
say hey this is your wait for this page
data pass that the states promise it'll
get serialized and added to the cache
this is just how I feel about the
different techniques for server-side
rendering you could duplicate all your
code that's terrible for maintainability
but you could probably get great
performance a headless browser is
actually really great if you can cache
all your pages because a headless
browser will almost always certainly run
your clock front-end code correctly but
it's not slow enough it's too too slow
for like dynamic like on-demand
server-side rendering and I think single
context virtual DOM is like the perfect
blend of fast enough for on-demand
server-side rendering and maintainable
enough so you can actually write an
application with it so those are my 10
things I think everybody needs for you
know a modern JavaScript application
I hope those 10 things help you turn
your development up to 11 so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>