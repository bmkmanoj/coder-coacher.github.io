<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2012 • Up And Out Scaling Software With Akka • Jonas Bonér | Coder Coacher - Coaching Coders</title><meta content="GOTO 2012 • Up And Out Scaling Software With Akka • Jonas Bonér - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2012 • Up And Out Scaling Software With Akka • Jonas Bonér</b></h2><h5 class="post__date">2013-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t4KxWDqGfcs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so one of the common thing I wanted to
solve among the most important things
was that I wanted to have have one way
of scaling both up and out they are
essentially both by scaling up I mean
scaling out or Hardware scaling up in a
single machine on a multi-core box right
there's also scaling out it's just an
instead of having multiple machines as
you're having in scaling out like
horizontally and they're in the true
sense you're actually scaling out on
mouth for multiple processors and and I
mean which you do where and when
shouldn't really matter I think there's
something that you should actually
externalize into a deployment decision
this basically how your apology should
be that was one of the key design things
I wanted to do and that I was so I saw
missing the people use different
different tools first for like dealing
with concurrency and different tools for
dealing with the distributed computing
so how how do we achieve this now then
so we use something called actors right
when actors is the sort of the common
theme throughout this talk archives mum
is much more than actors actresses one
as we call it one tool in the toolbox
it's a great tool it has I mean lots of
applications that use cases and you can
so I think 80% of all the problems that
I see out there using actors but the
other 20% are hard to solve with actors
it's not a silver bullet and that's why
we have many other tools that I will
cover but by the end just mention them
briefly but this build cornerstone in
ARCA is its message passing from
currency as it also calls extra-base pro
base extra-base programming so what I
mean well so what is an actor yeah I'm
not talking about actors like John
Goodman even though I mean at our team
we have whoever common Commons for a
reoccurring event where we watch this
movie to be the big lebowski
instead what I mean is that so at the
base level an actor is the code of use
the unit of code in an inside and actor
system and
of course then in akka it has
similarities with with like classic je e
sur les session beans etc is a model for
like organizing your code externalizing
out like things like deployment policies
deployment decisions into configuration
file actor is nothing new it's been
around since like 1973 coined by Carl
Hewitt in a paper to look it up later if
you're interested in in the in the
history it was it was it was catched on
like at the sort of real-world level by
Erlang in the early 80s and had been
used for thirty years
in the telecom industry using the Erlang
programming language and other sort of
more less or more obscure languages
right but this combo the ideas are
extremely sound regardless of
implementation and I think that they
will have a lot to learn there at in the
how we saw a problem in the Java
Enterprise space and or Scala whatever
you use or a c-sharp reverse we mean
we're still stuck using the ideas and
tools and constructs that are like since
since I mean we're starting using in the
60s basically with Fortran and stuff so
I think I think there is even this is
really not new techniques there might be
new to a lot of people but they are old
and proven right and what actors give
you is a way of programming at a higher
level so I won't rant long about like
threat of the problems with threads and
locks even though I could I think I just
I just going to leave it at I think that
the way people do with the way we do
concurrency in Java and c-sharp c-sharp
C++ scope is completely broken I think
it's the absolutely wrong way of
approaching a problem it since we what
we do is that we we work with things are
leaking up all the way from the
operating system right it's the way
they're the most low-level primitives in
the whole application in the whole
hardware stack actually dealing with the
problem that leaks all the way up to the
programming model and it becomes the
default way we deal with with problems
once other in other areas we work at
Muslim
much higher abstractions and I think we
need to raise abstraction level four
four four four four concurrency
parallelism and distributed computing as
well so instead of dealing with this
low-level plumbing that you have sure
have to do when you work with with
threads and locks what you instead do is
that you think in workflow you're
thinking how how are my message is
flowing in the system okay
and that's business logic right
basically more or less at least that's
how I components interact and how the
how the events like flow and request
response and stuff like that and if you
do that if you design our system around
this worry these ideas of workflow then
then you get extremely good resource
utilization you get parallelism
concurrency you get basically deadlock
free code unless you actually deadlock
on a conceptual level sure if you can
you can create a deadlock by by the way
your messages flow the system and then
then it's actually then you thought I
mean do then you dumb your thinking
completely wrong instead of that without
the plumbing dead logs for example in
the deadly embrace they take locks in
the wrong water right and they mmm and
then and the bad thing with that is that
in Java if you get a deadlock in Java
then then you lost two threads excuse me
there's no way back but if you if it's
just the workflow then it can introduce
things like time house and get out of
the problem etc so that is great it's
it's also on top of all this greatness
that I think I mean with with the
concurrency and wind and with the
extremely high throughput that you can
get like the ludmila maxing out on your
hardware it also comes with I think it's
superior model for dealing with failure
failure management and error recovery
that we will look at later ok it's also
distributable by design and in hand here
comes their I mean it's actually the
same tools the same components that
you're using can be used for scaling up
and out regardless there's nothing you
have to think about you you write your
components right and then afterwards you
could figure if they
Ron in in process or if one of the
sisters should rerun in another machine
etc we have what is called location
transparency okay that it really doesn't
matter where your where your components
run there's something that can even
change at runtime the system can detect
that okay this component is not ideally
over here is basically the only using
resource here then a system can actually
move the the instance of the running
instance on the fly to the consumer to
bring him closer to the context is
actually used in or or or the other way
around so you get scale up and out like
free as part of the model if you if you
just think and work in actors and I
think this is the perfect fabric for the
cloud it actually matches a lot with
this with with similar traits that you
have in in cloud computing you have a
system that is like inherit elastic
actors can come and go
same as knows can come and go in cloud
computing a very dynamic world you have
fault-tolerance built in okay so the
systems can actually heal itself how we
will look in later and we've also added
on top of the action model a lot more or
less even high-level concepts like load
balancing routing pooling and all the
stuff you might need okay
so where is our currently used here here
is the source selection of some some
sort of some of the companies that are
currently using ARCA and as you can see
is like it's the big variety of
industries you have like telecom you
have e-commerce you have investment back
in merchant banking data simulation
trading betting gaming all kinds of
stuff right even more than that like
social media and TV and so on and the
common theme though across all these
industries is that they have behind they
have a need for high throughput low
latency with very very with very high as
the lace strictest the lace on on
resilience okay which which is actually
the whole reason for the full for the
existence of vodka so what can you use
actors for if we now men try to take
step back and like take what we already
know and try to map that to an actor
okay so in you can see an actor's a
little bit like sometimes like a thread
for example it's bad it's a very bad
commissar of comparison as we will see
because actors are much lighter than
threads and so on but the conceptual
they can be looked a little bit like a
thread make a little bit machine as an
object instance or a normal reach your
component they can be used as a callback
or listener will use light anonymous
class or closure it can be a singleton
or represent some sort of service it can
be used instead of being just a single
African like a red represent to a router
or lucky be working as a load balance or
a pool it can be very much like your
message driven bean or even though
that's constraining the model quite a
lot and it can represent an outer
process service like marking out
something like that it can be a state
machine as we will see
so actress is really different beast
right can be many of the things that we
know so we really it takes a while to
wrap her head around what's really an
actor or what a really actor is so if we
take even a step back yes further back
and see I mean look at the definitions
well do what is the actor model as at it
as its defined mark by Carl Hewitt the
guy the story we invented the model so
it's a accordant to call you it's it's a
fundamental unit of computation sorry
that embodies three things processing
that's the behavior the thing that runs
the things that execute cycles on the on
the cpu right storage that's the state
that's the stuff on the heap right
communication these are the three things
that the actor model source or embodies
right and we have three different axioms
when a message is sent to an actor and
actually can do one of three things
okay it can create new actors you can
can so I get to get references to the
new afternoon to new actors you can send
messages to the actor it knows and it
can also become something else you can
read if you like try
form its own internals its own behavior
its own interface so it's such like
something so it's actually he's turned
himself to something else for the next
message that that that arrives and this
last thing is sort of the whole thing
that makes the doctor model so extremely
dynamic and flexible if we will look at
later so so if you want to take them
like break this down into these first or
into these like three three different
axioms right creates and become become
it's like you transform yourself I'm
going to add a fourth one that I think
belongs into the actor model even though
it's not it's not part of Carl Hewitt's
or original definition and that is
supervised that's how the fault model
how you can deal with failure a cop
comes into the picture okay so if we're
not going to look at how we can define
an actor first before we start creating
using them the first thing we do is that
we create a message the message is a
greeting class up there okay
so a message is is the actress public
API okay that if that is what you can do
with an actor you can send him these
methods like to think about the messages
that can be seen the block the methods
in an interface right that's what the
actor exposes then it create your actor
and you just think in Java is just a
regular class you see X you're extending
the Nama call the untyped actor in naka
we have two types of actors we run typed
in your typed actors typed actors
actually exposes a statically typed
interface so high so it's it's a more
statically typed sort of component you
lost the law you lose a lot of the
dynamic city in the model with that and
it's not like the traditional type of
actor it's more like the active or a big
pattern but some people like that but
I'm going to now talk about they were
like original the detrusor of actors
that I think are more or more they're
they're more powerful than flexible so
the only thing you need to do when you
create an actor is extend the actually
start act actor and then then you
override their own receive method if
you've seen the message driven beings it
looks very much like that okay
but don't be fooled actors are much more
powerful and they have much richer
semantics than message trivia they're
not just a callback like the basically
most important message driven bean ZAR
like so here we can I can receive the
method the message they are sent to us
so that we need to check what kind of
message it is in in in Java we need to
use like instance table in Scala there
are other API I just have to say this
API looks much much cleaner and Scala
has pattern matching so it actually
allows you to introspect orbit right in
there in the case then statement
direction.i we can actually peek into
the object directly and bind certain
things I don't have an example of that
now since I focus on the Java API but
but it's it's or in Scala light matches
better I think with the true actor model
from a syntax perspective it has more
like syntactic sugar for these kind of
things basically okay so now we have an
actor that's basically it so if we now
create an actor okay
actors are extremely light based as I
said you can't think an actor one-to-one
with a thread an actor on has about 300
bytes and so you can you can create
close to three million actors on one
gigabyte of ram this means means you
need to leave like model things that's
extremely hard to model using threads
you can easily have like for example a
10 million concurrent users running in
your system at the same time that's
really hard to do such do stuff like
that using threads so an actor also has
very strong encapsulation it has much
stronger encapsulation than classes or
instances of classes in Java or C to
c-sharp
there are closer to the original
definition of object orientation than
then the classes or instances so classes
right
so they encapsulate state behavior as a
regular object but they also have a
message queue okay that's what we call
the mailbox so each actor has a mailbox
where all the messages are receiving to
the actor and ends ends up right so how
can we create an actor now so we for the
first thing we need to do is we need to
create the actor system okay so we
create an actor system that's where our
application you can think about it a
little bit like spring beam Factory if
you used to profuse the spring or like I
don't hardly remember remember where's
Cole this egb context or something you
need you be right so and then when you
have a system you can use a system than
to use the factory method actor all
actor or creates actors okay so the in
this but in actor of you're passing two
things first it has to be in the golf
configuration article props you can be a
pretty rich kind of configuration we'll
use that later but here we just tell you
what color what type of actor we want
and the we also then give it a name
names are important in ARCA out here now
comes an actor ref not an we this
doesn't return the instance of greeting
actor up here okay and that's very
important this decoupling enables a lot
of things first it's like is the safety
that you want to add public methods to
the greeting ap greeting actor and call
them from the outside like bypassing the
whole model and being back to evilness
and he'll share stay concurrency right
we don't want that so that's why we
return actor s with a clean API that we
can use now to interact with the actor
the other the other thing is also that
we will see that this code is also all
we need to run this in a distributed
environment we don't need to change one
single line of code
this thing that's returned here the
actor F can just as rissalah cease to
represent a running component on another
machine in another data center or
whatever and was even more nice since i
only have the reference it means that
the running instance can actually move
move
and even all depending on on how the
application is being used and how the
system runtime tries to optimize the
there are the runtime characteristics so
this decoupling is good even though it
must might might look odd
okay so actors form hierarchies usually
remember we said system actor Rob when I
do that I create a top-level actor that
that sits right underneath something an
invisible actor that we call the system
guardian that's inside our actor system
okay so when you say system actor of foo
then you get if a child of our sorcerer
replication system Guardian okay this is
this will this is also this hierarchy
stuff is very important when it comes to
the failure model but for now we just
talk about it in terms of open a or
namer solution okay so now inside this
extra food there is a member field go
context that is what I should use most
of the time okay I shouldn't use system
because if a create system it is
creating a whole bunch of top-level
actors and I'm missing out or all the
goodness right so if I now use context
actor of what I'm doing then is I'm
creating a child here or my actor and if
I continue using context all the time
from within actress actor so I create
I'm creating child and I become the
parent of that okay so then you get to
like an actor hierarchy similar to this
so this is important now when we use
Nathan the neighbor solution because you
used we talked about actors as and there
and their names very much like a file
system this looks very much like a file
system right with the root and then you
have blah blah that that's exactly how I
reference them as well so foo here for
example that's /foo it's the top-level
actor in the inner inner actor system
okay
this a here's four slash from slash a
slash four slash a slash B and so on and
when and we have a where we have an
ethical actor for that you can look up
actors so you can get reference trackers
that you didn't create and then and then
you use these paths okay you also use
this path when it configure the actors
from the outside etc and these are we
and we you can even use things like
you might for accept if I if I'm inside
a here I Hughes actor actor for dot dot
slash star what's gonna happen then I'm
gonna get all my siblings right on the
same level are going up on our hierarchy
and then I'm getting all the ones
including myself right it's gonna be an
active selection that you can use to
work with sets of actors and so on so
you can really navigate it like that
which is I think it's pretty intuitive
if you used to earn by the way I mean we
have we've taken some of the best parts
of our line I think we've also added
some of some some stuff on top of that
and changed a lot of stuff that I didn't
we didn't like that the users found
unintuitive and that didn't fit in the
bigger picture the the second serve
construct is send so we can create
actors we can send actors we can send
message to actors sorry the nice thing
with send is that it's completely
asynchronous and non-blocking okay some
people also call this fire forget so in
everything in akka in the tin the terms
of the dispatching when you send a
message to an actor there's not a single
lock in the whole hot path everything is
completely locked less that gives us
extremely good good for performance and
throughput right but even more
importantly than that from a semantics
perspective everything happens to react
to reactively right so everything is
served by default everything is LaCie
likes it's doing nothing and when an
actress doing nothing it doesn't consume
any resources support from memory he
doesn't sit on a thread right so there's
no isn't there's no reason so you
utilization at all apart from memory so
an actress hits do nothing until a
message is sent to him right then he
wakes up to start doing stuff so in a
way messages like easily it's like the
kinetic energy in an actor system so
actors can have a lot of sort of
potential energy buffered up they keep
like ready to do a lot of important
stuff right taking over the world even
but they won't do anything unless they
actually some things trigger them to
start doing things create new actors
sending messages to their malikul down
in the system and then everything goes
down just like passive again so it's
extremely lace extremely
resource Saurabh I can say it's really
very try to minimize the reason for your
utilization as much as possible so how
do we send a message then then we use
this actor ref the actor ref have a
method call tell that basically does
what it says it tells another actor to
do something okay so we can say greeter
tell and then send in the command and
that's a message now this this returns
immediately this doesn't wait for the
actor to like put it to put the Italians
Millan's mailbox and for they have the
mailbox to be processed to have the
message simply imply to the actor and it
returns immediately after putting the
message on the mailbox okay
then we have a concept of scheduler yes
that's what we have we call the
dispatcher
we're actually many different
dispatchers the default one is usually
best but we have other specialized one
that works great in other in other in
other environments so there is the
concept of this global scheduler that
you said uses different algorithm for
that you get actual attune for fairness
and how much higher and higher how you
want it but it actually takes the
message from the actor and wakes him up
puts him puts in the message there let
him around and then it's back to suspend
it okay it does these all the time so
actress of course need to be tied to
thread to actually execute so we can say
that actors run on a share thread pool
or n the number of share thread post
depend how you want to configure your
system so this is the full example I
show this is all you need to start
create any actor systems right now so
this is all if you if you don't do
anything now if you have no
configuration file whatsoever this just
runs in process it creates an actor in
process in this run city in process
right on the single JVM but let's sound
now we press want to want to say oh this
actor should this actor called reader
here should run on another machine just
want to start creating a cluster okay
that's going to happen then it's in
order to to make that happen we just
have to write a piece
here's a configuration file this is a
COS configuration file it has actually
different sort of skins you can use it
looks like like you straight Jason use
this Jason style and more syntactic
sugar you can use property files and so
on and it's all written in Java by the
way because we use it to bootstrap Scala
so we have the same configuration format
for Scala are can play in the whole
stack so even if the only thing you use
from this talk is this configuration
library I think you you are warned a lot
it's really nice anyway so the first
thing we need to do that we like to make
a remote deployment to this want to
change the topology to run on a cluster
we say I want the remote actor if
provider that's sort of the creator of
the actress it should be remote enabled
then see here in the Diploma section we
use the name here again you remember it
was greener it's out of systems it's a
top-level actor then we use slash
greeter if it's a child to agree there
was a slash creator slash my let's do
the child the name of the child or
whatever so we use these names here when
we want to configure the system so the
only thing we need to do now is say okay
I wanted this to be remote deployed and
they're not tell it where okay are using
the ARCA protocol then I'm defining the
system my system and remember if you I
don't remember if you remember that we
can actually name the system there my
system right so ever all names matters
okay so we have the my system there it
runs on this machine on this port and
that's something that I configure
elsewhere in the configuration all the
ports that should be open for all kinds
of oak all over all the systems right
that's it well now when I create this
this actor this actor what's gonna
happen now is now it's not going to be
created locally it's actually going to
be deploy to another machine and
instantiate it there and the reference I
get points to that guy so if I start
sending message to it it will travel
across the wire over to that guy so this
is what I call by location transparency
and even better the system can actually
optimize things
for example we used that in order to
adapt the routers for example that we
have routers that or sort of adapt
according to the runtime metrics in the
system and then they can they can
actually move actress around the guy
using them doesn't know sweetie he
doesn't care he just wants the most
throughput right the third thing I want
to talk about he's become ok become is
where is were we're things to get too
bit funky in a way and my some people
might want to really why would I ever
want to do this beast it turns out to be
very useful
so what become does is like it like
redefines the more the actor is if you
look at it from a type system
perspective it's like the if the actor
completely changed both interface and
implementation it really becomes
something completely different and why
would I want to do that right one thing
I want to add before I start giving
examples of why and where it's really
really useful is that behaviors as they
are called them or stacked alright so I
can push behaviors on the stack and then
I can go back to my original
implementation but it's popping the
stack that's something that's also very
nice so why would I want to do that yeah
let's say for example that I they're
creating my system all you seem like
lightly like single actors that run okay
it might then later turn turn out that
this actor is extremely highly contended
I didn't expect it to be right might
expected it to be it's just that most of
the year is session or not but over
Chrisman to go straight across the roof
okay the nice kid then I can just
configure my actor too as soon as I'm
getting loaded my mailbox reaches a
certain size or I whatever metrics I
used within the actor to to I mean
understand that I'm overloaded I can
just transform myself to pool okay I
become the pool and then I spawn up like
5 10 100 guys and some other machines
are in process or whatever and and for
the guy using me he doesn't know that I
turned myself into a pool that's just
something I can do internally and when
the load goes down he's popped the stack
and go back to become a singular actor
again and you can previs shut down the
aec to notes that you
- ran just for during this peak for
example right I also use it for
implement state state machines for
example start with it with the behavior
or with this one interface over just one
method one one message called start for
example when I receive that I'm becoming
running then I he might have my full
implementation on the service like five
ten messages one of them might be resume
or suspend around for a while and then I
wanted something must suspend me um it
run suspend and I'm becoming suspended
that is one single interface at the one
single method call resume when I get to
resume my popping the stack going back
to to running again and then I might
have something that I can go back to
like to stop and that's the end of that
right so you can actually implement
state machines because not only behavior
begin has to pass in the current state
into the behaviors will keep lock pick
keep behavior and state across these
different stages this is very intuitive
very nice way of dealing with visible
state machines and actor are often state
machines this actor should have state
completely stateless actors are really
useful the right but but but where the
really shine is really decouple state
and behavior because what I didn't say
is that if you have mutable state inside
an actor that's completely fine nothing
bad can happen it's it's an it's an it's
like enforced by the model to have that
completely thread-safe okay you can have
you can have mutable state and hash from
iPod or whatever and you never need to
guard yourself right which is very which
is very nice you can also implement
things like graceful degradation instead
of transform yourself to Ralph tree mice
instead start throwing accept exceptions
like saying oh I'm overloaded or it
might take me want to start dropping
messages la piping them to some log file
or whatever to see is these are actually
worried she or you can send them to
jackass dead letter Q we have to have a
dead letter act or F that they did
everyone has to handle you because you
because you can send them to that and
then you can add they then they go out
and act as event bus that we also have
implemented for you so you can just
listen to this dead letter man messages
pick them up somewhere else or whatever
right okay you can do things like
spawning up a whole bunch of of empty
completely empty workers with no
behavior estate at all and and then you
can spawn up a master that just first
starts standing out the implementation
to all of these actors right and then it
starts using them by sending out
messages scenario gating the result then
when it's done it just shuts everything
down and make sure that the actor pops
their behaviors they're all amped again
a new server can come in start setting
up his behavior right it's complete
company you can create this completely
dynamic world so it's really really
fascinating use your imagination but
there are many more use cases than this
but these are some of the most obvious
ones right and how do you do this then
yeah in Java we don't have closures yet
right so he's a little bit ugly you need
to create an anonymous class with one
method but in Java 8 this will be nice
there will be scrap all this boilerplate
but for now we need to create an
instance of this procedure with the
method with the method apply and here is
where you add your new your new behavior
ok and we also have procedure that I
feel can takes it can take state in so
you can pass state to long and between
our stages as well
so load-balancing well I just want to
talk a little bit just a low balancing
so now for example if you have this
actor F and you Mon and now create it as
you want to mourn eternity so into your
likely route or immediately then then
you can just using on the prop so--but
you see with router and you're passing
in the router the number of Rockies for
example you can also do this all from
the configuration file or you can do
this at runtime
depending on how you want to do it you
can also add for example pool to a
router say I want to have lower bound
and upper bound just pass that into the
round-robin route through here and then
you get a route you're backed by a pool
and so on and we have many different
router implementations like okay random
consistent hashing broadcast you name me
very load of adaptive once it looks into
the like released memory released CPU
least number of messages in the mailbox
so it's nice in the cluster so now I'm
going to talk live but for a job of Java
7 concurrency and just show you how
using Java 7 concurrency there was a lot
of nice stuff that was added and that
really enabled us to like to get their
performance numbers and throughput
numbers across the roof so first like
some of the new utilities that you have
in Java 7 or one of the key things were
the fork/join framework that is
something that we now rely heavily on in
ARCA we didn't before in other words
it's thread-local around them and face
and so on we want to focus now on the
fork/join framework ok so the algorithm
is pretty simple you have fork and
you've joined ok fork means that you
really recursively fork off things like
basically like you see here you have a
task that here the Forks off one other
task here in wrong and one other task
there and that happens all recursively
down like a tree and then it awaits the
computation and when the computation
it's done it joins it back to its its
parents like trickles all the way up
until you get the final result it's
great for like dividing Kong your style
algorithms ok
it also use in eternal sea uses
something called work-stealing
right so each of these work these are
these workers have their own work queue
and when one of the workers run out of
these messages it tries to steal from
the other workers so this and it
actually turns out this has had a little
bit better performance and throughput
than the classic stat like standard
thread executor service that you have
another another way I think think that's
an example of a way to to use the word
the the fork/join pool is to this this
parallel array other other examples of
fork/join for this is like scores
parallel collections relies heavily on
them that means that you can take any
collection in the Scala library map list
store or set or tree map or whatever you
want and you can just say dot par we're
gonna create a parallel projection and
then means that all transformation
methods if that you're passing like for
each or whatever you do will now be run
in in parallel right there they are
talking about if Java should add that
she'd in Java scope things never ever
all the good stuff in Scala
so this is really this was sort of
expected so we talked about if they
should add that to Java eight or
something like that we also used it as I
said in ARCA so how does it we use it it
all started out with the benchmark on
our 48 for box down in Lausanne we
bought this beefy box to really I mean
see I mean how could can perform on very
very good very very good hardware and we
ran our benchmark it worth we weren't
really pleased it doesn't say you match
this but I will give you something more
so you can see a bar see I think in
context but for for this tip is typical
by benchmark you can see like completely
flattens out after about seven eight
actors or so we couldn't get it then
anything any further so so then we
switch to the full joint pool and that
give it that this actually didn't give
us much more either so let me start
sinking thinking okay what's the problem
it turns out that dog Leah he's the guy
he's he's the guy that wrote this he
wrote most of java.util concurrent he's
on or an advisory board a type safe so
we have pretty good good connections
with him okay first I mean we just just
to show you what in details what it was
what the problem was then we when we ran
it because I don't know if you can see
here but this is all read here this is
trying to highlight that the context
which is where just across the roof more
than 70-thousand context switches per
second which is like way way more than
it should be something was really
bottlenecking the question was what so
so so so what we actually did was that
we we send we went to dog and said
what's up with this I mean you're but
you were bottle lacking in your for
joint pool framework and he said yeah I
sort of expected this to happen I was
just basically waiting for someone to
run into this great now I've test case
let's fix it and it'll actually turned
out that no one had ran into this
because no one had actually optimized
the actually the whole code I like to
like to exercise the hell out of for
showing us that much like we did in our
casino where I should hit this but what
what what dog who did instead of the or
gold for joint subpool had had they had
to decide it that it's a single single
global queue then it had about
in each worker had his own queue okay
since then ran like randomly sort of
each each each of the workers or took
jobs from the global but every time you
use dispatch do you dispatch in your job
it goes to the global queue then you
also have this thing of the
work-stealing that's the first to the
first you have the problem you have the
bottleneck in the single global queue
and secondly you have this little sort
of a decision shootout for the week's
work you should I try to steal job from
jobs from some other one or should I
take from the global queue when I when I
ran run when I run out of jobs
so what dog was basically just
completely get rid of the of the global
queue stripe it's the only so easy
worker only had his own one and use the
thread local random so like Brandon Lee
assigned to these and what and what and
what and what that made it happen see
here's the old benchmark so it's like
tops out after like 15 million a 1.5
million message a second with this
change that's actually not yet shipped
in Java one Java 7 we have so embedded
our own fork/join
version inside our that has this fixed
you see it just goes all the way up to
20 million 20 million messages a second
then after some even more benchmarking
as you can see over here up so the the
context switch is now down to like 1000
per per second which is where it really
should be and with if some even more
tweaking buh-buh-buh on both internally
in the for joint pool as well it's in
our car we were able to push more than
plug 50 million a message mean fifty
million messages a second and that this
was all like s the nice thing is that
this wouldn't have happened if we
wouldn't have been able to use the fork
yarn tool and ran into this bug so weak
it could be fixed and that's something
like every one story came back can
benefit now this fix will of course come
in in Java 7 so see how much time I have
you start story five minutes late so 10
minutes or so okay I just wanna talk
about the the final thing and that is
how how you how you deal with error
recovery failure recovery in in in in
akka so first I mean if you if you look
at failure recovery from a Java
perspective okay I think it's completely
I have to say that at least working out
with with the different I think superior
way of dealing with with with failure
the problem is that in Java C C++ and so
on everything that using like threads as
the as the core construct unit of
computation you can say is that you're
giving a single thread of control okay
this means that if something blows up in
your thread what's happening if you if
you haven't guarded yourself you will
get there like basically the only thing
you get is a stack trace all the way up
to your thread new thread or a Java
executor service then it's dead silence
it's impossible to find out right no
other threads will ever find out that
this the disturb thread blew up because
exceptions do not propagate across
threads that means that in order to play
safe you need to do all your recover in
this single thread the same thread as
you do your computation you need to do
your error recovery okay the bad thing
is that this leads to extremely
defensive programming you basically have
to add your try caches all over the
place to just feel safe okay so it's so
your business logic becomes very tangled
with with your error handling logic and
it's also everywhere right since
something bad can basically happen
everywhere in the class in Java program
you need to have it you have this try
catch it error handling all over the
place completely pollutes your whole
software architecture okay I really
think we can do better we can do better
than this and that is the sort of the
modest attempt of the actor mold to
solve and I think it really does deliver
people call about let it crash ask the
horrible solution to the problem and
that's where they like the fourth sort
of construct comes in supervised so with
supervision you remember the actor had
it like a tree or created as trees each
parent supervises it's its children well
what this means is basically that
whenever something bad happens the for
the guy that actually running the code
he doesn't care he just dies then a
notification will be sent up to his
parent and he can take action upon that
so the business logic is completely free
from error handling code secondly it's
configured rather than coded it's all
declaratively configured in in the
inside each of each of the parent right
so one way of looking at it is that you
create systems like an onion okay so
you're your most important state the
state that you just can't lose then it's
like game over for application that you
put inside in the inner most of this
onion that's we put there okay and then
you layer levels of defense around that
state right so the idea is that if I'm
holding on to something precious and and
now and I want to do some computation or
ask some guy that might like yell and
scream at me or something I never do
that myself instead I'm creating a new
actor I'm delegating that to him if he
runs out on this minefield and blows
himself up that's just okay at least in
my perspective right because I can just
create a new guy trying or try it again
over here and if that doesn't work it
might be better spawning up on another
machine might be something funky with I
don't know with it with in with Nick
here if we're talking for throwing an
external service or something like that
right so you can you layer these levels
of defense you never do anything
yourself you delegate okay so instead
you create your key texture system
similar to this we talked about
something called error kernel if you
google for it you will find it's like
that's sort of the way of talking about
this this center of the onion that's my
Eric Carles this stuff they just can't
lose and then in there and then I just
create levels of defense so even so now
if the request comes in here example
something terribly happens blows up
what's gonna happen a notification will
be sent up to his parent it running in
another thread now so exceptions
propagate across threads nicely they're
likely she should he can take action
upon that and just restart the guy it
might be
that some group of actors together
implement some sort of services they are
like implicitly coupled it might be that
I just can't just kill one then okay
then you can group them and say if you
with one then all it's called all for
one strategy like in the three
musketeers it might actually be that
this guy is his his parent he's he can't
deal with it with error it might be
above his pay grade to actually do
something about it what's going to
happen then that he will have killed his
whole subtree and escalate hopefully
someone higher up will have the
knowledge power or whatever to deal with
the problem okay it might be that this
around is like our dome area are out of
memory error then it will hit the error
colonel it's not really any chance to
recover from that but that is very is
that it's like an exception it's very
unusual normally and most errors are
able to recover from and you were to get
here then it's a system that can heal
itself you can actually deal with this
buddha's failure by itself but if it
hits the air occurring on then if you
run more than one box then you're still
fine because you can actually link
across machines so you can actually take
your actor tree and put them out on
different boxes you can link them and
and they will be to get notified even
though they rot or even though they're
running on different machines and by
default each actor actually halves and
default like supervisor strategy that
you if you don't do anything you're
usually fine with the defaults but it
can be overrated and the way you do it
is like this it's a bit ugly from Java's
will have to say in being used to scar
but basically the dsl here the the gist
of it is here right in the supply arrest
is just boilerplate basically so you can
see if an if the exception comes the
interior is or is an art met exception
the necessities to resume that's the
sort of the directive was how should
deal with the actor that failed if it's
now pointer here it should restart else
it should escalate being propagated the
exception up and apart from that is just
a regular it's a regular actor and the
guy actually this applies then to the
guy that that's created out of this
context and to his children okay and
from from from the actress guys
perspective this is a scholar by the way
i didn't have time to rewrite
I apologize but basically it looks very
similar basically you have chances of
hooking interest to callbacks you can do
something when I'm started but after I'm
started after I'm restarted before I'm
restarted after I'm healed before I'm
healed and so on so there you can hook
in like in do things like cleaning up
resources before and reinitializing
yourself after the restart and so on so
this was akka 2x at least when it comes
to the actors perspective we're there
there's much much more to it
I don't have time to go through all of
that today seen since running a little
bit behind but it has a lot it has the
completely brand-new cluster module for
example that's coming out in two into
one that gives you the elasticity the
unreal in those can come and go just
cluster membership so you can subscribe
on events it has all this adaptive
routers that will automatically if a
fire knows come along but just
automatically spawn up your new new
stuff on those who if no sleeve they
should they can be moved over and stuff
like that just an event bus you test
like great integration with a bunch of
framers like Apache Campbell for sample
if you use our cast actors it as
Campbell endpoints to just talk through
them over to a camel and receive
messages through camel or you Cirie I'm
a key for example and we have many
different ways to deal with concurrency
also we're actors it's not a good fit so
for transsexual memories one we have
something called dataflow concurrency we
have a great futures library that's
nothing close to the extremely crippled
version there's in Java util concurrent
or encourage you to take a look at so
this was basically I have some slides on
the clustering as well but I won't have
time to go through those so basically if
you want to learn more go to a code or I
oh we have about 400 pages reference
documentation so pretty much everything
should be there join the mailing list
ask questions all those stupid questions
are very welcome we would love to have
you part of it there's a whole bunch of
great blogs out there we had to think
well think all akka summer a blog we
encourage the community during the
summer to write blogs for the ARCA team
blog and we came there was more like
eight or nine different great blogs
about how to use akka in the real world
how people actually use it
the world and so on if you want to look
for more like to support the training we
have our training and stuff if you want
this for pay of course everything else
up to now is free I said by the way
that's the only thing that you can find
stuff do we actually have to pay like
support like training and stuff I might
be useful as well levels everything I
try I was planning on sharing yeah I'm
here rest of the day we don't think type
of questions now but please come up to
me outside here or would you grab me
over the party tonight or so I'll
explain more if you want thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>