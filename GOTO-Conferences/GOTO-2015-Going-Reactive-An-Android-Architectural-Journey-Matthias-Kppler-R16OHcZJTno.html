<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2015 • Going Reactive, An Android Architectural Journey • Matthias Käppler | Coder Coacher - Coaching Coders</title><meta content="GOTO 2015 • Going Reactive, An Android Architectural Journey • Matthias Käppler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2015 • Going Reactive, An Android Architectural Journey • Matthias Käppler</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R16OHcZJTno" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">(instrumental keyboard music)
- I wanted to talk about, kind of,
it's a bit of a
retrospective that I want to take
about using reactive programming
and specifically RxJava on Android
for a number of years now in
our production application.
I've talked about RxJava before,
and there's plenty of
material now on the web as well
that you can look at if you are
unfamiliar with the library.
I kind of want to, well,
this is about RxJava,
I want to focus a little bit
less on the library itself
and what gaps it closes on
the Android framework for us
and focus a bit more about how
we use it in our application,
and how it has impacted
the way we write software
for Android applications,
and the patterns that emerge, as well,
the problems that we ran into,
and hopefully give you some insight into
how we solved these problems.
It's going to be a bit opinionated of course,
but I hope it's going to still be valuable,
even if you haven't used RxJava before,
just as kind of a motivation.
So, that said, I actually
had to remind myself
how long we had been using RxJava for,
so, I dug a little bit
through the archives
and I found this commit
which is from 2013,
March.
So, we've been using it for
about two and a half years now,
and as you can see we started using
a pre-released version of RxJava.
So it has been a bit of
a wild ride since then,
and you know, it was before API stability,
and before the main release was out,
long before the main release was out.
So, of course we bumped into a few issues
in the beginning with RxJava,
but in hindsight it has been,
it has a massive impact on our application
and I think everyone was super happy
with the choice.
So, that said, what I want
to present going forward,
is a little bit like
walking down the stack
in our application and
highlight a few things
that I thought were interesting,
talking about in terms
of how we split up our code, for instance.
Let's start with looking a little bit
how we compose our application,
so in terms of layers, for instance,
and what constitutes
to a particular layer.
This is, looking again at 2013,
so about two years ago,
two and a half years ago,
we were following a pretty
standard, run-of-the-mill,
layered approach to our
application architecture.
So you would have, at the very top,
you would have your
presentation objects like views,
and you know, your Android
fragments and whatnot.
You would have your business objects
somewhere in the middle
acting as mediators
into kind of delivering
data from the data layer
up into the presentation layer.
And at the very bottom we would have
our data objects which would
talk to the service API,
talk to local storage, and so forth.
Nothing terribly interesting there.
What did happen later that year though,
was that, and this mostly happened
in the back end at SoundCloud,
was that we came to realize this kind of
platform-driven approach
that we were taking
didn't work very well anymore.
We were pretty much all
focused around technology.
We had Android teams.
We had an Android team,
we had an iOS team,
we had a web team looking after
the platform as well,
and this didn't align
well with the emphasis
we wanted to put on particular features
that drive business value.
We actually moved to
a model where we would
split up our organization around features
rather than around technology.
This is really to then
drive the technology
and our software that we
write into a direction
that would more accurately
resemble what we want
to deliver in terms of value.
We had started doing this
in the back end already.
It is a transition, so it took
awhile for us to go through this.
Mobile was last in this transition,
so we were still a platform
team until a few months ago.
But we did see this coming.
What we realized what we
would have to do going forward
was to work more towards a model
that looks a little more like this.
It's kind of a matrix organization,
where you still want
to have the separation
between your layers, you want to still have
your presentation objects
separate from data, of course.
But also we wanted to have a little bit
cleaner vertical lines in the application,
which means if you would
think about such things as
our discovery features,
like exploring new content,
or a search,
in contrast to things
like our timeline features
which are more like on
Twitter if you're unfamiliar
with our product,
where you discover new
content by following people
and it kind of is this
endless stream of tracks
and playlists that you can look at.
We wanted to separate our code
along those lines as well.
And then an interesting
question that comes up is,
how do you communicate?
A, between the layers,
in this vertical direction?
How do you transport
data from the data layer
through your business logic into the UI
at the end of the day?
And also now that we have this other axis
that we've introduced,
how do you communicate between features?
Right? So without
compromising on things like,
you want a particular
piece, a particular element
of the feature matrix you
want it to be still cohesive
and kind of decoupled from
the rest of the system,
so that you don't end up
with a &quot;big ball of mud&quot;
as it's sometimes called,
where everything knows
about everything else.
I mention this because I
think this is where RxJava
really helped us a lot.
Android kind of leaves
you alone a little bit.
There are a number of mechanisms in Android
to have components communicate
in your application.
Think of intents, for instance,
intents are a very
common way to communicate
or handler message for instance,
often it's just like callbacks between
objects that you have,
but it's a bit of a mess and
it's difficult to get right,
especially if you think
about that these edges,
like where we transition between features,
or where we transition between layers,
they often involve concurrency, right?
So we have to jump off the main UI thread
to do something expensive like fetching
a JSON response for instance.
Then the question comes up,
what is a good approach
to handle with these
without solving the same
problem over and over again?
What I want to do going
forward is I want to take
one of these vertical slices as
kind of like a guide for
most of the presentation
and show you for a particular
feature how we've done this,
particularly using RxJava.
The feature I picked is the Sound Stream.
I already mentioned it.
Why did I do this?
Well, because A, right now
it's our landing screen
so it's one of the most prominent screens
in the application.
You see it when you first open it,
and I think it's like, for me,
this is such a typical screen to implement
because at the end of the day,
it's just a list of stuff
and if you have been
writing mobile applications,
I'm pretty sure you've
written screens like this before,
which are lists of stuff, right?
Whether it's cards or
grids of things, whatever,
you're going to, it's the same problem.
Another interesting thing about this is,
it looks simple, right?
It's just a list of things,
but there's actually a fair
amount of complexity in here
if you think about things such as,
this is an endless stream of items, right?
If you follow people,
there will be new content
on a minute basis, or hourly basis,
so it's like a stream of items.
This could grow very long,
so you need to start thinking
about lazy data deliveries,
such as paging, right?
So you scroll to the bottom of the page
and then you want to
lazily fetch new content in.
There are things such as pull-to-refresh,
you might be looking at an
outdated version of the screen
and pull-to-refresh is
a very common paradigm
for a user to refresh content,
so you have pull-to-refresh.
There are things such as error states,
so what if it goes wrong?
If you fail loading the next page,
you have to think about
all these error views
that you need to manage now.
There might be retry logic,
if you want to retry fetching a page
because maybe it failed loading,
you have to deal with this as well.
What I'm saying is that
while it looks simple
there's actually a fair
amount of complexity
and I'm pretty sure I'm not the only one
who has written pretty
nasty code in the past
making all this stuff come together.
I just think that RxJava
was really helpful
in making this a little shinier.
If we take a closer
look at what constitutes
this vertical slice,
there are certain types
of objects that we found
at each level, of course.
At the very top, which is,
and by the way you might
have already noticed
that I'm using this color scheme,
where a green is presentation,
orange is our business logic,
and purple at the bottom
of the stack is data.
So whenever I show code
samples going forward
maybe keep that in mind,
so it's trying to guide
you guys a little bit
through these layers.
So at the very top we have
our presentation objects
and well, the first thing
to mention there
are Android views and fragments.
We use MVP in our application
so our view is actually very lightweight.
I'm going to show some code in a minute.
So most prominently what we do
is we have a screen
presenter at the very top
which is responsible for
steering the presentation logic
and talking to our business logic as well.
And it will do such things
as listening for Android
`LifeCycle` events for
instance and just fetch them
further down the stack as well.
Next we have what we call
our feature operations.
If you're familiar with a
clean architecture model,
these are our use case classes,
sometimes they're called interactors,
and they contain all the business logic.
They are basically
responsible for wiring up
multiple data sources,
and looking after things
such as scheduling as well.
I mentioned already like
typically you want to jump off
the main UI thread if you
want to do anything expensive,
so I don't think the presentation
layer should be concerned
with such things so we
do this on this layer,
and whatever business rules you might have
for validation of models, or some such.
And so the link between this
we establish through RxJava
and to some degree also RxAndroid,
although I have to say that we use
very little of the RxAndroid library.
Mostly we use the handler thread scheduler
which allows us to
actually dispatch callbacks
on the Android main thread.
So we mostly use it downstream
where data propagates from the server,
or the data source in general
to the presentation layer.
Underneath would be our data layer,
which contains all the
data that's relevant
for a particular feature.
This could be, for
Sound Stream in particular,
this would be like a
local database into which
we sync content regularly,
and of course the service API
from which we originally fetch this data.
So, pretty straight forward.
Yeah, so there can be multiple of those
involved to backup a certain feature.
I think one thing I want
to highlight here is
there is a single edge
from the business logic
into the UI.
I think this is really
important because what we want
is the UI should be really dumb, right?
It should not really have
to juggle a lot of different
objects to pull for some
data from over here,
pull for some data over there,
and then maybe execute a logic in between.
This makes our views very complicated
and views are difficult to test,
most of you probably already know that.
I think this dumb view
approach is a healthy one,
because you can push the
logic further down the stack
where it's easier to test.
So if we look at how a view looks like,
I picked out, we treat
fragments as views by the way,
so they don't really have
a controller aspect to it.
I know some people prefer, like, MVC
and so they would look at
activities or fragments
as controllers but for us they
are just basically vehicles
to kind of like, the glue
between the framework
and the pieces of code
that make up our app,
so we try to separate everything out so
this is of course like a
distilled fragment of code
but actually for this
particular screen I was showing
the fragment is about 50 lines of code,
so this is how lean our fragments are.
There's almost nothing in
there, it's just wiring.
One thing I want to highlight
here is this piece here.
When we inject a presenter
who's responsible
for steering these views and
talking to the business logic
what we do is use a
library called LightCycle,
which is something we build in-house,
and basically what it does is,
it's actually not built on RxJava,
like it's one of those
places where we used
a different technology
to address a problem,
but what it does is it
basically dispatches
`LifeCycle` events that we get from Android
to any number of
collaborators in the fragment.
So this could be a presenter,
it could be multiple presenters,
you can also nest LightCycles,
it could do things like view tracking
if you want to do something like this.
It could really be anything.
We use, we retain our fragments so
they maintain a state that we inject,
which is a cheap way to make sure
that you don't lose out
on any data that you
might be fetching in the
background while the screen
goes through a rotation
change or something like that.
So if we look at a LightCycle
a little bit closer,
the way it works is you
would have a companion object
called a dispatcher in your fragment.
The fragment can be the
dispatcher itself as well
if you choose to do it that way.
And what would happen is
if the fragment receives
a callback from the
system such as onCreate,
it would simply listen for
this event and automatically
forward it to any other
LightCycles that you inject.
So the nice thing about
this is if you have,
like in this example you
have three LightCycles
injected into a fragment,
they don't know each
other so it's very nice
to have a cohesive bit of functionality,
put it in a single class,
but it will expose the same
API as a fragment, right?
It works for activities
as well, by the way.
And so it's quite nice so we
can test them in isolation
so any of these things can
have their own unit tests
and we just rely on LightCycle
as kind of the mediator
between the framework and our classes
to do the wiring and we
just assume it works.
So we don't write unit
tests for fragments at all.
We only write unit tests for LightCycles
and any of the logic underneath.
Let's look a little bit
closer at presenters.
This is the screen presenter that we use
to render the Sound Stream.
I think in total it's about
like 200 lines of code,
so it's not tiny but
it's also not massive.
Essentially what all these screens do
if they render a list of things,
is we go through a binding step.
This is not quite your
data binding what you've,
from MVVM and you know,
Android has the data
binding library now as well.
This is something we did well before then.
Binding is essentially
the step that connects
observable sequence that
we build with RxJava
to the UI and it's kind of like
reusable infrastructure code.
We do this on many
screens, not just this one.
The thing that sticks out out here is
this CollectionBinding that if we create,
and the way it works is
LightCycle would dispatch
a callback to our presenter such as,
&quot;Oh, this view has just been created,
&quot;please go and fetch data for this view.&quot;
It does so by talking
to the stream operations
which is the use case
class for this presenter
which exposes an observable sequence
which in this case is
our Sound Stream items.
And then we can tell it, 
&quot;Load this into this adapter
using this builder syntax,&quot; and
we can also do such things as
here is also paging function
which is an Rx function
and I'm going to talk
about this in more detail
on the next slide actually,
to perform paging logic.
So that's really all they do.
Of course, the other
direction works as well.
So the presenter would listen for things
such as click events.
So if we have a button
in your views it could
attach itself or an internal
subscriber to a click event
and then talk to the business logic to do
whatever it's supposed to do.
So, paging. I already mentioned--
Who here has built this before,
maybe a quick show of hands?
Yeah, I mean it's such
a common thing to do.
Everyone has to deal with this problem.
I went through a few implementations
of this in the past
and I thought they were a
bit difficult, a struggle,
because if you think about this,
it's very much like one of these problems
that sits between the layers,
I would say.
There's a lot of view-specific
logic involved of course,
because it has to do with scroll events,
updating the UI,
but there's also logic involved that needs
to make a decision from how,
given a particular page,
how do I arrive at the next page, right?
So this could be something like traversing
an HTTP link to the next page
of JSON elements that you fetch
from the network, for instance.
It could go to the database, as well,
you know, who knows?
We actually do both in our application.
So these are things you don't want
to have in your views, right?
You don't want your views
know about how to construct
queries to fetch to move a database cursor
around to the next page
of items or something.
So we were really keen on having something
that was, well, A,
does not create information leaks
into the views about
how we obtain this data,
and also that it's reusable,
because clearly the Sound Stream is not
the only screen that we want to page.
The way it works is,
we've built it with Rx of course,
we created a pager class,
which is like a slight abstraction
over an Rx published subject,
which is basically, you can just think of
as like a channel, like an event channel
so you can stick events in one end
and you can subscribe other
listeners at the other end,
and so, yeah, so that you can communicate
in a decoupled way.
The way it works is the
fragment would subscribe itself
to the pager, and if there
is already a page available,
it would emit right away,
and just deliver this page
back into the subscriber
through an Rx `onNext` call.
The second piece of
logic that comes in here
is if you scroll to the bottom
of the page it will detect,
&quot;Oh, it's time to load the next page.&quot;
So it will issue we have
a reusable scroll listener
which will issue a signal
to the pager called `next`,
which will instruct it
to emit the next page.
So now the question is,
how does it know to load the next page?
Here comes the interesting
piece into place,
which is an operator in
Rx called `switchOnNext`.
What `switchOnNext`
basically does is it can,
given an existing stream of items,
you can switch over multiple streams.
So basically what we do is,
given an initial stream of items,
using `switchOnNext` we can switch
to the next page,
but from the perspective of the caller
that actually listens to the sequence,
it looks like a single stream of items.
If you want to think about this
in more procedural ways or terms,
it's basically moving
around pointers I would say,
moving around pointers to lists, right?
So that's kind of internally what happens.
The pager would have a reference
to what is the current stream of items,
and a reference to what the
next stream of items is,
and using `switchOnNext` we can make sure,
we have a very easy
without having to juggle
any of the state ourselves,
RxJava does all the heavy
lifting for us here,
to emit pages of items into a subscriber.
And in order to determine how
to obtain the next page,
it will ask a paging function.
If you remember from the example,
the code sample of the presenter,
where it asks for this paging function,
it asks the business logic,
give me a paging function that tells me,
given a certain page of items,
how do I arrive at the next one?
And in the case of the Sound Stream
it would be a database call,
because we sync in the
data in the background.
Yeah, so this is totally reusable.
Basically the only piece
of information we need
to provide to the pager
is the paging function,
then we can just plug in this object
in every single screen
we need paging on then,
and it just works.
Moving down the stacks a little bit,
this is an orange-colored slice of code,
so this would be in our use case classes.
Particularly this is the
class that is responsible
for making sure, yeah, the
data delivery into the UI.
So what we wanted to do is,
we needed a page like I already mentioned,
which is just a list basically, right,
a list of streamed items.
I think maybe what stands out here,
what is interesting to see is,
it's the point where things
come together, right?
So if you remember the
vertical and horizontal
communication here,
so first we have vertical communication,
as you can see we return an
observable sequence again,
so it's really just
like a lazy description
for the UI to subscribe to and
eventually get data delivered
but it's also horizontal communication
because, as you can see, we use
this `zipWith` operator here
to reach out to a
totally unrelated feature
that we compose into this screen,
which is a `facebookInvites` element.
This is basically something
that we load on top,
if you're a new user of the application,
which invites you, which
is a call-to-action
to invite your friends to the platform.
And the nice thing here about this is
this particular class does
not have to know anything
about how this works,
like where this data comes from,
or maybe what the conditions might be
for when this is supposed to show up,
because this call-to-action
actually only shows up
I believe only the fifth time
you enter the screen, not always,
and then never again.
But none of this information
is here, which is good,
because this is the Sound Stream,
it shouldn't know about this,
it's like a separate feature.
This is just I think very symptomatic
for a clean Rx architecture where,
you have a single stream that you compose
into somewhere else and all the complexity
is hidden beneath it.
And scheduling, of course,
we call `subscribeOn` here,
which basically means
that we have a scheduler
that we inject which tells the sequence
where it should execute.
So, of course, this is still
not the end of the story,
because we need to
obtain our data somehow.
So again, this use case
class needs to reach out
to some collaborator and ask it for data.
I already mentioned we
use, we heavily sync data
for the user that is locked
into the application,
so that we can make
functionality available
to the user as quickly
as possible so they don't
have to look at spinners all the time.
For the Sound Stream then this means then
that in order to load a page of items,
we go to the database.
What we've done here is,
we would have a collaborator
which we just refer to as a storage class,
which abstracts away the way we talk
to the database basically.
Again, it's just an observable sequence.
From the perspective of the caller,
they have no idea
actually where it goes to,
and also we do not expose
cursor objects or anything,
so no database information
leaks into a layer above.
What we employ here internally is we have
a library called Propeller
which is basically,
it's a light abstraction
on top of an Android
SQLite database,
and which lends itself a bit
better to reactive programming
because it basically looks at tables as,
basically collections and iterables,
so it exposes iterable
cursors basically so that
you can use things like Guava
or like any kind of standard
Java collection mechanisms
to deal with your data from local storage,
and because of the
duality principle between
RxJava and iterators,
or observables and iterators,
it's very easy to turn them
into Rx observable sequences.
So we have this Rx companion objects
in Propeller which can
take a query that we write
and it turns it into
a observable sequence.
In this case it would emit
a cursor and then we map
this cursor or this row, basically,
of the table to a particular
item that we want to emit.
Okay, so this basically
concludes the vertical
way of how we do things,
that covers all the layers,
but we still quite haven't answered
what we do horizontally, right?
If we want to truly talk between
features that maybe should not
even know of each other at all.
This is, again, like a really common case
I'm pretty sure most of
you in the audience
have had to deal with,
which is this example.
So we are in the Sound Stream again,
it's the mixed list of
tracks and playlists
that other people post or repost.
What I can do is I can
interact with these, right?
So if I click on a playlist
here on the middle of the screen
it launches me into a
totally different experience
and I can do stuff there,
I can engage with it.
So I click the Like button
that increments the counter,
and then I press the Back button
and I go back to the previous screen.
So then the question that comes up is,
you might have noticed that there's these
little stats what we keep around,
and so the little heart
symbol in the counter
has increased like immediately, right?
So it picked up the fact that I engaged
with this object on a different screen.
I think the important
takeaway here is that
the Sound Stream is built
by a different team,
this is not just a
technological issue, right?
If you move to a feature team organization
the Sound Stream is built
by a different team
than the screen that renders a playlist
and we interact with a playlist.
So then it's very important
that you need to make sure
that you do not couple
these things too closely to each other.
The problem basically becomes
if we look at these two
screens side-by-side
how do we establish a
communication channel
between them?
Without these screens actually
knowing about each other,
we can pass around data
in an easy and efficient way.
Again, Android sort of
has ways to do that,
you know, intents are clearly
one way of doing this,
but I always thought that
intents are terrible to work with
because they force a couple of very odd
complications on you as a developer
such as parcelables, right?
So if you put, the only way you can pass
around data in an intent is
by putting things in a bundle,
which again needs to, is
restricted by this parcelable API
so you need to be able
to marshall this data
even if no inter-process
communication is involved.
So it's super weird because
more often than not,
you do not have
inter-process communication,
you just go from one screen to another,
but you use the same
vehicle which is intents
to communicate this
fact which I think is a
very awkward design decision in Android.
I guess they made it
because they want to have
a single concept to model
this kind of messaging,
but it makes things very complicated
or unnecessarily complicated.
The way we solve it is
by using Rx subjects.
And of course we still send an
intent to open the activity,
there's no way around this,
but we do not actually
communicate via intents
in terms of data passing
on, message passing.
I already briefly mentioned
what a subject is,
it's basically, if you
know what an `EventBus` is,
you know the `EventBus`, a
pattern, it's basically that,
so it's just like a single event queue
and you can post things on the queue
and either there are subscribers
or there are no subscribers.
If there are subscribers
they will get the message,
if there are no subscribers
they won't get the message.
This is what we did, basically.
Here's the use case class
for this particular screen
or specifically the engagement bar
that we have there for to trigger a Like.
In order to target a
Like what we need to do
is persist the stack to the database,
so we use commands, command classes,
that know how to persist
a certain change set
to the database.
And again, we turn this
into an Rx observable sequence,
and what we then do is,
if this is successful,
is we use the `map` operator
to turn this into something
that we can publish
throughout the application.
So we can say, &quot;Oh hey,
this worked, okay, good.&quot;
So now we want other screens who might
be interested in this
fact to know about it.
So we use the map operator to turn this
into a change set and then
we publish this change set
to the application.
Well, how does publishing work?
It's basically simply an Rx action
that gets the data passed in,
and you can see here,
we use this `eventBus` to publish called,
it's really just an Rx
subject in disguise,
it's nothing fancy so if
you remove all the fluff
you would have an Rx subject
but we found it a bit easier
to work with, instead of working with,
like a dozen different
subjects that we inject
in all these different screens,
we found it a bit easier
to have a light abstraction
around it and that we called
by a common name, `EventBus`,
and that we inject as a singleton
throughout the application
and we have a testable for this as well,
so it's actually really
easy to write unit tests
for these things, because
we can fake events
on the `EventBus` and make
sure that other components
in the application
receive the right events,
or subscribe themselves
or unsubscribe themselves
from the event bus.
Don't worry too much
about `PropertySet` here,
it's kind of like a common
data format that we use
to pass around change
sets in the application.
It's basically just a data bag.
It's similar to a map, but
it's typesafe over its keys
so it's a nice way for us
to stuff all sorts of data in there,
turn it into a value object that we can
create events on, for instance,
and move it through the application
using Rx observables.
On the receiving side,
that was the sending side,
on the receiving side, so here we are
in the view layer again.
We need to pick this up, right?
We need to make sure we
receive this event and then
so that the views can update
themselves accordingly.
Here we receive, uh,
we simply subscribe to
the same event queue,
and simply update the adapter.
So if we get this change
set, it's simple as
updating the specific item in the list
and rendering the list.
So that's all we need
to do and we're done.
Yeah, this concludes
kind of my walkthrough
how we implement a particular feature,
but of course there were
certain things that came up
over and over again that
we wanted to look at again.
I think it's just like,
maybe general advice
about how we do certain
things in our application.
So one thing that comes
up over and over again is
how do you deal with connecting
observable sequences to views,
specifically of fragments and activities?
We chose the most simple way,
which is to just bind subscriptions
to `LifeCycle` callbacks
we get from Android.
So we would have something
like subscriptions
that follow the `viewLifeCycle`
by subscribing sequences
in a call to `onViewCreated` and
unsubscribing when we get
the `onDestroyView` callback.
This leads to a bit more
boilerplate than other solutions.
There's more clever solutions out there
that go all-in in terms
of Rx and then they model,
they basically emit every
callback you get from Android
as a separate Rx event to an observable.
I found this gets very complicated,
a bit difficult to understand.
I think this is a very
straight-forward way of doing it.
So this is something you would find
a lot of in our code base.
Another thing that comes
up over and over again
is what I call Fast Path or Lazy Update,
which is concat first.
So what you often want
to do is something like,
oh, if I have a value cached already,
I want to emit it as quickly
as possible, right,
to the UI, so that my UI is
responsive and everything,
but maybe I don't.
So maybe I need to go
to the network after all
and fetch it, because
maybe it isn't cached.
This is, here you can use
the concat first approach,
which is basically using
the concatenate operator in RX
which just, yeah, appends
two sequences to each other.
The way it works is, either
the first one completes
right away and doesn't emit anything
and it proceeds to the next sequence,
which would be fetching it
from the API for instance,
or because of `first`
that we add at the end
if it does emit, so it did
emit a value from the cache,
then first we'll simply
take this singular item
and unsubscribe so it would never even get
to the remote call.
So this is a really common
pattern that you can use
to implement this kind of, like,
cache event fetch approach.
You can also emit first,
then you have kind of like a lazy update,
which means you emit
something from your cache
so the views immediately get the item,
but it will then also fetch
an updated version of it
and emit it again so then
you would see a number pop in,
maybe with a second delay
or so which updates itself,
so it's very simple and a very nice way.
It's kind of the reactive
version of `getOrElse`, right?
Observable transformers are
a super nice thing as well.
They use the `compose`
operator and basically what
they allow you to do is take any number
of composition steps in
a sequence and turn them
into a single one.
To make this more concrete,
what you could do is
instead of always saying
`subscribeOn` this background thread
and `observeOn` the Android main thread,
you could take these two calls
and declare a transformer that
always performs them for you.
And then you can compose
instances of this transformer
for instance, like a
high-priority UI task,
whatever, if that's
the thing you want to do,
compose into your observables.
A nice thing about this
is it's great for testing
because if you unit test
this scheduled model
sequence there that you expose,
you can just swap this out in a unit test
and you can run it synchronously
on the current thread.
So you remove all
concurrency in your unit test
which makes it super easy to
deal with threading concerns.
We also have deferred execution
that we use quite a bit,
especially in Propeller,
like the data layer.
Something you would maybe want to do,
it's just like an imaginary
sequence of integers,
it's just like an example
to explain the point.
Let's say you have a
function that computes
a list of integers and it's expensive,
so you want to put it on
a background thread.
So, essentially you want to delay this call
until someone actually
subscribes to look at this data.
And it's an iterable because it's a list,
so commonly what you would do is you would
create your observable and
then walk over the results
of this computation and emit the results
into your subscriber.
However, there's a number
of problems with this code.
First of all, it doesn't
handle errors very well,
so you know it might throw,
the computation might throw,
so you might want to catch errors
and forward them to the subscriber.
It also doesn't deal with backpressure,
and I'm going to talk about
backpressure briefly.
So what I recommend doing
instead is just reuse
RxJava operators to do all
this heavy lifting for you.
There's an operator called `defer`,
which basically allows
you to pass a lambda
which is an observable factory,
so it's only executed
when someone subscribes
to the sequence, not before.
So if someone comes and subscribes,
you can actually pass this result
of your computation directly
into a factory method
called `from` which turns
any Java collection
into a observable sequence.
So it's a single line,
and it's more resilient because you reuse
all the infrastructure
that RxJava gives you
to deal with things like backpressure.
A few common pitfalls I
wanted to talk about as well
that kind of struck us a few times
and yeah, if you use
RxJava, maybe this might
be interesting for you as well.
First of all there's a
really tempting overload
of the `subscribe` call on our sequence
which takes no arguments.
I do not use this because
it has following the problem
that you might not be aware of.
It relies on the fact that you,
basically that you would
never receive an error,
because since you do not provide this call
with an error handler, what it
will do if you get an error
it will re-throw a fatal
exception basically
and crash your application.
So even if you want to do like
a fire-and-forget style call
and you're not actually
interested in a result,
make sure you always
subscribe to sequences
and have error handling logic present.
Otherwise this might
bite you in production
and suddenly crash the application.
Another thing that is specific
to the `observeOn` operator
to receive notifications
on a different thread,
is this particular interesting case.
So, we have a subscriber
here, or an observable,
and we immediately emit the value,
it doesn't matter what it is,
and we fail. So we call
`onError` with an exception,
so what you would suspect
is that the subscriber
on the main thread would
get the value first
and then the error, but this
is actually not what happens.
The reason is that `onNext`
gets actually gets dropped,
because `onError` always
cuts ahead of `onNext`,
so if `observeOn` recognizes
that your sequence has failed
it doesn't even bother emitting
any other items anymore
because it wants subscribers
to know as soon as possible
that something went wrong, so that
they can detach themselves, for instance.
So, yeah, so this can lead
to surprising behavior
if you debug something and
don't get your values emitted,
so something to be aware of.
Backpressure is a big topic
so I'm not going to get
into too much detail, but,
so maybe I'll just mention it here,
that it can cause problems.
Basically, and this might be surprising,
this is some code I took,
you don't have to read or understand it,
this is code from the
`observeOn` operator as well,
and the one thing I want to highlight here
is this `request` call,
because basically RxJava
internally isn't actually
based on a push model.
It's based on what they
call reactive pull,
which basically tries to address the case
where a subscriber is too slow to process
all of the notifications
that a very fast observable
emits into the subscriber.
And so basically what happens
instead is internally,
and you don't see this from the outside,
it requests a specific amount of items,
but if the observer,
the consumer basically,
doesn't process them fast enough,
and doesn't ask for the next
batch of items fast enough,
what happens is that it will
fail at putting the new items
that are produced into the queue.
And the surprising thing
maybe is on Android,
heads up, this is 16.
So this is the internal buffer size,
and clearly you can quickly run out
of 16 items that are cached internally
for a subscriber is a bit slow.
And basically it will throw
a missing backpressure
exception that will
crash your application.
So, yeah, something to be aware of.
To deal with this, a pretty obvious way is
you can simply take load
off your target thread
and make sure that you don't overload,
especially the Main Looper on Android.
All the draw calls on Android go through
the Main Looper, so we
did the mistake that we
were a bit defensive
and all of our callbacks
we would schedule whatever
it was on the main thread.
You know, it's very easy,
`observeOn` main thread,
and then you're done,
because you don't have
to deal with concurrency anymore.
But of course this comes at a cost, because
then if you overload the main
thread and the Main Looper
too much, then at some point
your sources will emit faster than Android
is able to catch up
processing all these messages
and then you run into these issues.
Of course you can also
buffer your sequences
using things like `toList`,
or the `buffer` operator
so they can catch them
and emit them in bigger chunks.
There's built in backpressure operators,
which I'm not going to get into,
but you can just look at
the documentation, they're there.
And there's also system property,
which is a bit the hackier approach
that you can actually
override this value of 16
if this is something you want to do,
if you think maybe 64
or whatever magic number
is a better choice for your application,
you can bump up those
internal buffer size.
Okay, I'm almost done.
I want to super briefly cover
the topic of debugging.
I suppose there's
something to be said about,
you know, what does all this mean,
is it super difficult to
understand if something goes wrong?
The good news is there's only
like a certain class of issues
that I've found that I
usually end up debugging,
which is something like,
messages not arriving in
subscribers or something.
Our servers are like,
it's very, very solid,
so it was a while until I
really found a bug in RxJava.
If we take this little
example sequence where we just
emit a bunch of numbers
and turn them into strings,
so there's a mapping step involved,
and then there's `observeOn`,
you know, how can we debug this?
How can we possibly log this?
Well, you can use the debugger, of course.
That might be, you know
with all this backpressure
stuff internally if you look
at `observeOn`, it gets a bit
difficult to understand,
so we wanted to make this
a bit easier to work with.
So what we ended up doing is we wrote
a small library called Gandalf,
which is basically an annotation
drived byte code injector.
So it's based actually on
a project by Jake Wharton
called &quot;Hugo&quot; which initially was meant
to only inject logging
into your application,
but I think we just took it
to its logical conclusions
and added all sorts of annotations for it,
debugging and tracing,
so we don't only use it for logging,
but we use it as well to inject all sorts
of other instrumentation
into the application.
It does this with AspectJ if
you're familiar with this.
It is a byte code injector,
for cross-cutting concerns,
so it can generate byte code
for you and inject it
into all kind of different
points in your application.
Then we would have two
annotations that we can use
to output logging.
It looks a little like this.
I have an observable factory,
this is the example I was showing earlier.
The only thing we have to do is apply
the Gandalf plug-in to
our gradeable scripts
and then add this annotation,
`@RxLogObservable`.
We can do the same
thing with a subscriber,
but I'm just going to show
it to you for the observable.
What you will get it this.
It will simply print
the sequence it observed
to the command line.
So here you can see, in
this particular class,
which is `MainActivity`
(this is not from our application,
it's just a dummy application),
and this particular method
called `createObservable`
we subscribed on the main thread
and then first we received the value one,
then two, then three, and so forth,
then we completed and terminated
and it took such and such amount of time,
and then you can see
there's an `unsubscribe` call
at the end as well.
This can be useful, as
I mentioned earlier,
when you want to debug a sequence
where somewhere along the
line it dropped the message
and you're not really
sure where it happened,
it's kind of nice to see,
&quot;Oh, it unsubscribed
after this and this step,&quot;
and it's kind of a lead into where
you can start looking for problems.
Maybe I should briefly mention there is
an &quot;official&quot; component as
well, called RxJava Debug,
written by Netflix for the
pre-release version of RxJava.
It doesn't look to be maintained though,
and it's actually based
on a pre-release version
of RxJava-core, so I
don't know what happened
to that project, but it
works in a different way.
It uses the plug-in API of RxJava.
It has very noisy output.
So we decided to write our own thing,
yeah, going forward.
This pretty much concludes my talk,
so if you want to stay in touch, this is
my Twitter handle.
Before we go into the questions,
just a reminder again,
please rate the session,
and slip in any last-minute
questions, I guess.
Thank you.
(applause)
- Okay, yep, now it's unmuted.
Thank you very much, Matthias.
There's a couple of questions for you.
One is about the Rx Propeller,
- Oh, yeah.
- Could you compare that
to the SQL Brite by Square?
- Yes, great question.
I should say,
we're working on open-sourcing
this project by the way,
but it fell a little bit behind schedule.
We've been using it in production
for about two years now,
so it's actually not a new project,
and it started out as a
simple abstraction layer
on top of Android SQLite,
but we added, as our
application grew with RxJava
as well we added this
reactive functionality to it.
It differs from SQL
Brite in the sense that
I actually think it's a bit more,
it's a bit more powerful
and a bit more complete
as fully-functional query builder,
so I think we covered pretty much
all the cases that there are.
What we do not do that
SQL Brite does is
SQL Brite basically you
can register a query
with an observable
and it's basically like
a table observable,
so whenever then the table changes,
it will re-execute this query
and communicate the result back to you.
This is something that
we don't actually support
right now but we're
building, working on this.
But, yeah, other than that,
it's a really like
totally unrelated effort
we started working on awhile ago.
If you're familiar with,
Yahoo! actually put out,
and I actually forgot what it's called,
but Yahoo! put out a library as well
for dealing with SQLite
databases on Android.
I think Propeller
compares a little bit more
to Yahoo!'s library. Just Google it.
I don't know what the name was, but, yeah.
- [Voicover] Thank you,
and one final question.
You probably saw this coming: LightCycle?
- Yeah
- [Voiceover] Open-sourcing, yeah?
- Yes, we're working on it. (laughter)
It's like, it's a very
simple library as well.
It's an annotation
processor that basically
through a single binding step,
allows you to hook in all
these different classes.
It's really not much.
It works similar to Dagger in the sense that
it generates source code,
which is the binding companion basically
to LightCycle,
which is then instrumented
through this binding step.
Yeah, again,
we definitely want to open source this.
It's just right now
it's a question of time
and priorities and stuff.
But I hope we get to this,
like maybe this year still.
- [Voiceover] Okay, so--
- Otherwise, you can also come to me
and I can show you a
little bit how it works.
- [Voiceover] Okay, but
thank you very much,
and please give him a hand.
(applause)</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>