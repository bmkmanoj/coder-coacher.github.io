<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Back to the Future - Java 8 is here! • Georges Saab &amp; Paul Sandoz | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Back to the Future - Java 8 is here! • Georges Saab &amp; Paul Sandoz - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Back to the Future - Java 8 is here! • Georges Saab &amp; Paul Sandoz</b></h2><h5 class="post__date">2015-04-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v0kweffwvHQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Paul my colleague and I are from Oracle
and in fact if you go to the next slide
you'll see that this is this is actually
true okay now that we've done that let's
let's go on I was I was actually a
little bit worried yesterday I was on my
way here from San Francisco and as
sometimes happens when you're traveling
I had a little bit of a problem and and
so I was kind of worried how this would
go but then I was able to just you know
kind of take a deep breath and look at
the title of the talk today and of
course then we found the solution okay
so so so what are we here to talk about
today as yarn said you know I have a
predilection for talking about Java so
so I thought I'd do that a little bit of
a surprise I'm sure for many of you but
the the idea here is is not only to talk
about Java but to sort of try to give
you some insight into what goes into
creating a programming language and
evolving a programming language over
time and of course what we're talking
about today is is not just any
programming language it is one that
according to many measures and surveys
and so on out there is is one of the if
not the most popular programming
platform in the world today I mean there
are a lot of people out there using it
there are a lot of developers there are
a lot of enterprises and there are a lot
of end-users so the evolution that we go
through is can't be one where we just
sort of jump on you know whatever the
latest trend is and I don't think anyone
would accuse us of doing that on the
other hand it can't be something that is
too slow and falls too far behind so I
wanted to talk you know first of all a
little bit about if we sort of go back
to the history and kind of the roots of
Java and where we started out
so 1995 this is what yarn was
- with with james gosling and a small
team in what was then a subsidiary of
sun called java soft had some technology
they were looking at a bunch of
different things to use it for you can
you can read more about it in some
places but as you can see that the aim
was was fairly modest a simple
object-oriented distributed interpreted
robust secure architecture neutral
portable high performance multi-threaded
dynamic language alright well since the
bar was set so low of course it was easy
to turn this around quickly in fact of
course it took a while for java to get
you know to kind of the size and shape
that we're used to seeing today but i
think that that what was kind of nice to
see there was that many of these things
many of the aspects that are things that
people tend to find valuable in java
today were actually things that were
thought of from the beginning right
these were not things that were sort of
afterthought sand and this is something
that you can see you know when you look
at languages out there and you kind of
look at you know what was the focus of
the people who created it when they
created it you know often those
questions are addressed and then if
there are ones that you kind of come
along and deal with afterwards those are
really you know can be kind of a
challenge to do so when we look at sort
of some of some of the benefits of java
that that that we see well you know one
is that it's relatively simple you know
there's not a huge amount of syntax it's
it's fairly simple to get started with
and kind of learn the way that it works
and then once you've understood that you
know there's a lot of a lot of learning
to do in terms of you know the api's and
so on but basically that's all fitting
into a framework that's kind of easy for
you to understand stable
this is is something that we see today
you know once again part of the idea
here was and remember you know if you
look back to 1995 you know people were
using lots of technologies then but some
that were most prevalent were people
writing their own native code you know
writing see applications at the time C
and C++ and one of the big challenges
that people had was exactly this that
you know they would write something it
would all be great they would deploy it
and then they would get some cycle
somewhere there were some memory errors
and you know those kinds of things
tended to be very very difficult to
debug java by by doing its own memory
management you know took a lot of that
out and of course there was still some
issues especially in the beginning but
there's those by and large got shaken
out fairly quickly
all right fast well as as yarn said you
know there were some some questions
first off and you know when Java got
started as something that was
interpreted there were a lot of
questions about this and and that's
actually a sort of reputation that hung
with Java quite a while even when the
truth had changed and the truth did
change fairly rapidly in in part because
we went beyond having everything be
interpreted to actually having some some
pretty good JIT compilers and in fact
those have continued to improve over the
years and we'll get back to that in a
minute
but I think that basically the state of
where things are right now is that the
the JIT compilers for Java are really
really really good if you look at the
machine code that they end up generating
it's it's actually in many cases far far
better than what you would come up with
yourself and you know there's some good
reasons for this right one is that it's
been tuned a lot over the years another
is that we work very very closely with
people creating the hardware in order to
make sure that as new generations of
hardware come out the JIT already knows
about them so you're not having to go
back and rewrite and sort of hand polish
a lot of very low-level code what's
happening instead is that as new
hardware with new features is coming out
people have already been
working for quite a while behind the
scenes to make sure that your Java
program can take advantage of that
without your Java program having to
change at all
so scalable scalability here once again
this you know turned out you know yarn
and I spend a lot of time trying to to
implement Java things for the client
of course what history has shown us now
is that one of the places where Java
became most popular was really on the
server and this was in part because of
the scalability aspects that we saw and
and that I think was kind of a balance
of inherently worrying about things like
threading it was in part by having some
layers on top with things like Java EE
and spring later on and then I I think
it was also in in part because this was
kind of an industry that grew up around
dealing with a scalability problem and
you know if you were really really
focused on native code in one area
dealing with a lot of these issues
turned out to be very hard whereas Java
turned out to be a nice kind of level to
describe things and and have you know
some support from the platform for
worrying about scalability easy to read
and maintain there's actually you know
arguably this should have been one of
the the first bullets on here and and I
think this is something that I can't
stress enough you know Brian gets the
the lambda architect usually likes to
say that you know you you you write your
code once you'll need to it will need to
be read you know if it's good probably
hundreds or thousands of time over its
lifetime and so it's great to make
things easier to write but it's
extremely extremely important to make
them easy to read because you know as
you're maintaining as the code is going
on if somebody's trying to understand
the design and add to it if they can't
read it then it's hard for them to do
that okay so choice of compatible
implementations this is is something
that I think has been a unique strength
of Java throughout the years and and I
think you know to Suns credit in the
very beginning this was something that
was thought of that basically you know
it was not going to be a small
set of you know 35 people who were going
to worry about taking this thing that
had the ambition of being platform
neutral and porting it to all of the
different environments that were out
there I mean one way is you can try to
do that yourself and you would probably
get a little bit of the way down the
road but eventually you're gonna get to
the point where if you want this to be
truly a Vic with us you want it to be
out there on lots and lots of hardware
and operating systems you really need
help and so what's the best way to help
will to enlist the people who are
experts in those areas and they need to
have you know kind of an incentive to do
it and they also need to be able to do
it and you need to be they need to be
able to make sure that when they've done
it that it actually is really going to
be compatible so son put a lot of focus
on this in the beginning they originally
had something called a licensee program
this fairly quickly evolved into
something called the JCP and and not
actually something that I think
yesterday had an anniversary I think it
was a 15 year anniversary that they
celebrated yesterday and so this is
basically a group in which standards for
Java are created right and and so you
know even the Java platform is something
that you know it's not just you know my
group sitting down and saying this is
how it will be it's a collaborative
effort with a lot of people a lot of
input from from different individuals
and different organizations and
different companies trying to make sure
that the specification for this will be
good and then the specification comes
with a compatibility test kit so that
you know if if you're IBM or if you're
HP or if you're a university you can
take this you can make changes to it you
can do your own implementation you can
make sure that what you've done is
actually something that's going to be
compatible ok great software ecosystem I
mean the evidence is is here all around
you when you look at all of the
companies that are out there all of the
packages that have been written all of
the libraries you know this I think is
one of the things that made Java
strongest over the years is the fact
that it was pretty easy for people to
put things together and put them out
there and in fact Java programmers have
a very unique mindset in terms of you
other things who is there somebody who's
telling me just the other day he was
like you know one of the things that I
find when I look at very low level
languages is that the first thing that
anyone does is you know they create a
new project and then they go in they
implement hashmap because that's what
you do and of course in Java this is the
kind of thing that nobody would think of
doing because you know that there's a
great implementation of hashmap there
you know that there's one that's there
that's getting better in fact you know
that there there's a complete set of
collections and that you know the
smartest thing for you to do as a
programmer is not necessarily just sit
down and implement your own it's to
figure out is there a good one out there
that I can use how can I use that so
that I can spend my time worrying about
the thing that I'm doing that's unique
and different and then this is back to
what I mentioned before future-proofing
right so what I mean by future-proofing
is not only that the underlying
implementation continues to get better
so that you know your Java program
becomes better without your having to do
anything it's also that the rest of the
implementation of Java continues to get
better so as we go along as we have new
versions you know what what you found by
and large and and you know there are
always some some kind of problems with
this but the backwards compatibility
story for Java or the sort of forwards
compatibility story has actually been
very very strong and and so I you know
I'm always amazed you know I go and talk
with people and you know I've had people
who tell me hey you know we had this
application we were running it on 1.2
for years we never touched it because it
was just working and then yeah and we
thought maybe we should have something a
little bit more recent and so we
downloaded Java 7 and we ran it on there
and it ran the first time so so I think
it's great to see that kind of thing of
course you know what they then went back
and said was by the way not only did it
run the first time it also ran far far
far far far better and faster than than
it had when we were running on the
earlier version
so speaking of versions let's let's go
back and kind of rewind here and look a
little bit at what sort of happened over
the years so as yarn mentioned he was
talking about 1995 and so you in that
case we were very early
on there were beta versions and so on
but of course the the first version that
came out was in 96 and then as as we
went on fairly quickly afterwards a 1.1
version they're not you know fix some of
the sins of the 1.0 version 1.2 took
quite a bit longer and this was actually
something that really extended the
platform quite a bit there were a lot of
you know the api's that were used to now
we're actually not even things that were
introduced until 1.1 1.2 1.3 there was a
lot of focus in in this one on kind of
slimming things down we did a bunch of
work on making startup faster by finding
ways of you know delaying class loading
and other things like that we did a lot
of overall work on on performance and
and size 1.4 of course came and came
along a couple of years after that and
you can see here the the time between
releases is getting a little bit longer
with five we had generics and and other
things and and that was also similarly
long and then finally JDK six and after
that things kind of ground a little bit
to a halt right so JDK 6 was actually
the prevailing version for quite a
number of years I think was four and a
half years and all and part of the
reason for that was a big event that
happened there in the middle
okay go on and and of course you know I
say this with a little bit of a twinkle
in the eye but something like in
acquisition it actually does cause you
know quite a bit of turn and on the
other hand it's also an opportunity to
look at things look at the direction and
see where things were going and one of
the things that we did there was we
looked at it and said okay this was in
you know by the time that was done
basically all in you know sort of late
in 2010 and so it had been four years
since JDK six had come out now there
were a lot of reasons why you know there
weren't new versions coming out not all
of them were technical there was a lot
of you know engineering work that
continued to go on but things were sort
of at a part where a point where it
seemed to be very very difficult to
continue to make progress and I think
this is one of the things that you see
as a computing platform becomes more
mature right one of the the nice and
exciting things early on is there's a
lot of churn there's a lot of excitement
there's a lot of things happening but as
things become more mature it can become
you know there's a risk that it becomes
harder and harder to continue to improve
it and and part of that can actually be
ironically enough the success of the
platform you know the more people that
you have out there who are using it and
depending on it the harder it is
sometimes to make changes to it and and
the more resistant people can be to that
now on the other hand you know they're
sort of you don't want to change too
much you don't want to change in a way
that breaks things but it's also not an
option to standstill right because the
world is not standing still the problems
that we need to solve and that we want
to use this technology to solve are
continually evolving and so we need to
find a way to deal with that so one of
the things that we did then as we put
these these groups together and in fact
there are actually three groups there
was the the large Java group from Sun
including the hotspot JVM group and then
there was also a group that came from B
EA that created a JVM called J rocket
and in fact the the technologies that
have been developed there turned out to
be quite
implementor ii and so basically we put
we took a look at like how could we
combine these and try to get kind of the
best of both with the JDK 7 release we
took some some of that combination work
and we took a bunch of the work that had
been done post JDK 6 and we said look
let's kind of blow out the cobwebs and
you know kind of get a major release
happening again we did also a bunch of
work in the community so you know one of
the issues that had sort of tended to
arise was there was some friction and
you know differences of opinion and and
so in fact it became kind of an
important step to try to resolve some of
those things as an example you know IBM
came and decided that they wanted to
join the open JDK community and become a
part of that Apple similarly went and
took the work that they had done porting
Java to the Mac and donated that to the
community so that there were things that
could be done there so that was quite
nice but really that was just a first
step you know there were a lot of people
who sort of criticized seven saying well
there's not that much that's exciting
there there's some nice stuff but you
know there's nothing that's
revolutionary and and so of course you
know that actually was the intent right
there wasn't an intent to sort of spend
a long time and do something
revolutionary it really was about you
know trying to get the machinery of
getting releases going again eight on
the other hand is actually a release
that we think is quite revolutionary and
really moves the ball for it a lot there
we go there's Java eight somewhere
someone from Australia is gonna start
throwing things at me
alright let's go so so this this was
quite nice this is a headline on sort of
what we think the state of affairs is
now I this one is somewhat
tongue-in-cheek I think it's it's kind
of funny that you know we have a Clinton
era relic it just sounds like it's you
know falling apart and morally decrepit
but of course I think it's right because
we might see the same thing happening in
politics soon so anyway this idea of it
ruling the web of course is kind of a
joke right I mean
things that we know is that you know
Java has been strong has continued to be
strong over the last 20 years but what I
think this really kind of points to is
something different right it is that you
know Java got to a point where the lack
of continued momentum and forward
evolution meant that it was no longer
viewed as hip right if you were a young
programmer coming out of school and you
were going to start at a cool startup in
the center of some European town Java
might not be the first thing you would
look at in fact it probably wasn't and
at the same time what this article did
was they went and interviewed a bunch of
startups that had turned out to be
successful and they had started out
going oh yeah Java you know that's my
that's my granddad's language and so
instead they used something else because
they needed to develop very quickly and
do a lot of prototyping and then what
they found was that as they started to
get traction they needed better
performance they needed better
scalability and they were not going to
get there with the technology they were
using and so what they did in a number
of these cases was they went back and
they said hey you know we like some of
those aspects of this technology we've
been using but we need something else
here and so they moved parts of what
they were doing in fact large parts and
very very central parts of what they
were doing to Java okay
okay so where does this get us then on
the roadmap principles I talked about
you know the sort of need to consciously
think about evolution right and how
quickly you want to go well for Java it
turns out that because as I was telling
you there's sort of work on
specifications so that you can have lots
of implementations there's also work on
the implementation itself these two
things can be done
somewhat independently typically you
know if you if you read the spec you
need implementation of that but you can
Rev the implementation separate from the
spec and so this is kind of where we are
now we talked with a bunch of people the
general feedback that we get is we want
you to evolve but not too quickly so
you've got one set of people who are
like hey yeah you could have a new
version every month
give me more features that's awesome and
then you have you know some enterprise
developers who are like oh my god
whatever you do just don't do it too
often
because you know every time you do this
we have to recertify and it's a big pain
so where we ended up on on this scale
was we think that about two years
between major releases is is a fairly
good cadence we think it's fairly
appropriate came for technology that's
this mature but keeping in mind that in
between you can Reb the implementation
and continue to make that better and
better so major releases every couple of
years minor releases on about a
six-month tick in between and if you
think back this is is exactly what we've
seen with seven we leave fairly late on
came into this model with eight this is
exactly where we are so it came out in
March there's an eight you twenty which
is in about August sometime any forty
next February roughly and then any new
sixty sometime after that if anyone buys
me a beer afterwards out I will tell you
about why they're called new twenty year
forty and you sixty it's not necessarily
obvious and and then basically looking
at nine you know about two years after
eight okay all right so so what's cool
about eight you're on mentioned that
there was a lot of neat stuff there I'm
gonna go through this quickly and then
Paul is going to show us some some real
examples so one of the things here is is
lamda which brings closures to to Java
and the streams API is this is basically
adding some things in order to help you
use lambdas within collections in a way
that doesn't require a complete new set
of collections okay date and time API is
this is something that apparently it's
very easy to get wrong we've managed to
do it at least twice and so this is an
attempt to rectify that compact profiles
this is really uh you can think of it as
kind of a step towards modularization
you know how many people are using korba
today yeah but it's there
anyway that's what compact profiles is
about this becomes increasingly
important as people are looking at
smaller environments things like
Internet of Things embedded devices and
nós horn so this is is basically a rev
on and kind of a new version replacing
rhino which is was an implementation of
JavaScript in Java that's been in the
JDK for many years that implementation
was you know getting a bit a bit old and
so nas horn is a new one which actually
takes advantage of the invokedynamic
bytecode the first new bytecode that was
added to Java
after the initial days this was added in
Java 7 and now we've used it in innate
flight recorder admission control this
is a evening of this is like a black box
for your JVM so this is the thing that
helps you figure out what the heck
happened when your server crashed at
3:00 in the morning
and you didn't have full instrumentation
turned on okay no more perm gen and Paul
will talk about that and of course
there's a host of standards that we
support from you know accessibility to
internationalization to security things
like TLS and and so on and then finally
developed in open JDK Amanda mentioned
some more about that after we look at
some code okay I'm gonna say some stuff
in the IDE I'm gonna sit down because I
can't code and stand up at the same time
wise I can't do it so George talked
about some features so how many how many
people use maven how many people use
maven the Sun Wow loads how many people
had to modify the navin options because
of they're running out of perm gem yep
we all done it so if I do
maven - version here in there so in Java
8 what you'll get now is ignoring option
perm size max permit size in there so
you've all set the the maven ops here
you've probably all set these up we've
got your hands up now you don't need to
set those for Java right now you can get
you can get rid of them you probably set
them about 4 years ago then forgot about
them that's what I did and now that
they're hassling you now so you can
actually remove those actually when you
go to Java 9 you'll actually get an
error and you
be able to execute anymore it'll ject
them but now you just get nice warning
so you can remove them which is good so
that's my perm gen demo okay let's talk
about date time so how many people have
used the date time classes in Java now
have you used them server side or client
side server side using server side are
they are they a mutable or immutable
immutable so what happens when you get
to Fred's working on the same simple
date format do you get 1/2 of a date
from one thread and another half of the
date from another thread coming in I
don't know you quickly find out this is
a pain in the backside to do server-side
if you're writing HTTP service so what
people usually do as they they do this
humongous thing here how many people
have stuck their simple date format in a
thread local you know I've done this
just like and in fact this is sort of
extract this out from the the Jersey
Jack's arrest implementation I wrote and
in fact there's you usually have to have
about three date formats in when you're
parsing HTTP headers here so you have to
stick this in a thread local and you
have to set it up like that and it's
pretty pretty yucky we can actually
before I get onto the the the date time
thing we can actually improve that in
Java eight if we really want to so we
can we've added a new method called Fred
local with initial and this is actually
something we added to eight and we can
actually take a lambda expression rather
than doing this anonymous in a class
here and extending from Fred local we
can actually take a lambda expression
like so and I can copy this code here
and stuff it in here put a semicolon
there because Java like semicolons and
comment out that so we can actually
improve it a little bit like so and
stick it in a lambda expression and this
essentially target types this expression
to something called a supplier like so
and you call a supplier get and you get
your simple date format out like so we
can improve it a little bit more or more
likely if you have existing methods
around that supply stuff what you can do
instead is I just for demonstration
purpose
as creator a method with exactly that
same code inside so say you have an
existing method like this lying around
instead of doing the the the lambda form
like here you can just copy your let out
scrub that and use a method reference
instead and then it gets a lot nicer so
we sprinkled a bunch of these methods
around jdk 8 which will leverage these
lambda expressions and a bunch of new
interfaces we've added i'm not saying
you should transform it like this in
this particular case but if you've got
methods lying around already this is a
really nice idiom to use so a little
digression there so what would you do
with a new date/time class whether you
just do that instead so which do you
prefer
I think this no competition so the date
new date time place already hasn't won
for the the the one one two three RFC
out there already you can use and it's
immutable you don't have to worry about
threads if I would date time API is a
really nice API to use it's designed all
consistently immutable and I think given
the complexity of date and time it does
a nice job of not exploding out into a
huge massive API it's really nice design
I encourage people to use it I'll put
this stuff on github I'm not going to go
through this but there's some examples
here to show you how to use it in this
particular case if you're interested in
learning more okay so let's move on a
bit so I want to talk a little bit about
raising abstractions in Java 8 so for
Java 7 and before you might use a for
loop like so say I want to iterate over
this list of integers here and I want to
say print out all even numbers it's not
very difficult or complicated like so
and we can just run that so I'm
iterating through my list using ass for
loop and we can get the Nanak
not very exciting numbers out there so
what we've done in Java 8 is we've added
some new methods
so on the list now we have a for each
method but list is an interface
collection is an interface Apryl ism to
face but yet we can call for each on the
list so this is another feature we've
added a language feature we've added to
Java 8 we can now add methods to
interfaces so we've added a for each
method to iterable an iterable takes an
instance of consumer and it will iterate
over the iterator of the iterable and
call action that except on that consumer
with each element of the case whether
that's a default method there so we can
do we can essentially copy this piece of
code here and stuff it like so now we
can run it again it won't get any very
exciting up of things we've just raised
the abstraction or that you can use an
anonymous in a class if you want to but
it starts to get ugly pretty quickly
especially want to go on to the next
example like that the important thing
here is now we've raised the abstraction
we can actually optimize underneath the
covers because we're not doing it
externally so this for each
implementation could be optimized to the
specific list implementation here
question is is it so let's just have a
look at our arrays list in the Java code
here so we're looking in a JDK code here
and this is our method as list and it's
got an implementation called arrays list
here now if we want to optimize we
should expect an implementation
overriding the default method of
iterable and in Java a code we missed it
we forgot about it but we have 8u 20
coming along so we can actually let's
see I'm going to just open up my 8u 20
source code here and let's see if we
have it in here so yes we do so I added
I fix this bug in 8u 20 so it should be
coming on we have a for each method
specifically on the list and instead of
iterating over the iterable we just
iterate over the array instead and that
will actually be more efficient upping a
level of abstraction allows us to monkey
around of the covers and optimize a
little bit so let's raise it a little
bit more instead and rather than for
each we can
call stream and this allows you to get a
view over your list as a stream instead
and we can do before each here like so
and copy that same code in now that's
not particularly interesting it's
virtually no different to before but
what we can do instead notice what this
is doing it's essentially filtering out
all even filtering out all the odd
numbers so we can call filter there and
have a little Lander expression like so
and we can whoops we can get rid of that
and now we can compress this down to
let's just copy this piece of code out
and remove compress this down and change
it to once I get it right we can change
it to a method references set with we're
compressing things down shuffling things
around moving levels of abstraction up
that's not particularly very exciting
why don't we instead sort of do
something else like map integer - binary
strings say and then rather than
printing it out we can collect and let's
let's join it all up with a comma
separated list and I'm just going to do
a little helper and send the IDE
so rather than we could all stuff that
into the for each method if we wanted to
but we can use the stream API instead
and up the level of abstraction I just
printed out just to show you that it
actually does work like so and we should
get our binary results of one two four
eight and so forth like that so hope
that's given you a little bit of flavor
of a stream API I'm going to be talking
about it more tomorrow when you have
that you can also go parallel I'm not
going to get much into detail of exact
under the covers today that leads on to
our next example which is a bit more fun
so
I came across this article how
mathematicians use the pump-action
shotgun to estimate pi and the
motivation to do this was if there's a
zombie apocalypse we would lose the
technology to calculate pi but he'll
always be shotguns around to shoot the
zombies so what they did was they got a
square in tin foil and they shot the
shotgun at about 200 times and they they
counted the number of pellets that hit
the tin foil and they counted the total
number and the number of it hits inside
a circle and the ratio of those two
numbers you can obtain PI hat but we can
also do this argue be less fun using the
stream API - it's an embarrassingly
parallel problem as well so here's how
we can do Monte Carlo PI using streams
so I'm going to say I'm going to shoot
32 million shotgun pellets at my square
I'm going to do this by using an int
stream I'm going to range over all the
pellets I'm shooting one by one by one
and then I want to set up a filter
operation in this operation I want to
get a a random number generator and I
want to get the XY position of each
pellet so I'm going to create a random
number X a random number Y and that's my
pellet and firing all the way all 32
million of them and then I say well is
this is this pellet within the circle or
outside the circle and I'm going to turn
true if it is and false if not and then
I'm simply going to count them all up
and then pi is the ratio of those two
numbers M over N times four it's that
simple much simpler than firing shotgun
but less fun perhaps let's just run it
so we do get PI it's not very accurate
PI 3.1415
and it's embarrassingly parallel I can
actually go parallel here let me just
time this this run here so I'm just
going to run this and time it now this
is not how to micro benchmark your
applications I'm being really naughty
here well you really want to use is
something called jmh which is there in
the open JDK tools project to get proper
measurements of your x but I'm just
using it for explanation purposes so get
out look
five eight seconds to calculate pi here
but it's embarrassingly parallel so I
can stick a parallel here get the same
code compile it and run it again and we
get faster 2x so like that notice the
real time has got lower but the user
time has got higher us because
parallelism always takes more work I'm
using all the cores on my system to try
and get the result faster but the result
should be deterministic in this case I
should get the same result in a sense
going parallel or going sequential okay
so that's PI here's a link to the jmh
stuff if you want to look at that that's
how to benchmark properly and Lexi ship
lab is probably probably swearing at me
right now using you next time but that's
for right okay so am i okay for the time
here one of you you have one more I
don't do the Nash one one I think no we
do that go ahead okay so we also have
Nash horn that George mentioned and I'm
showing exactly the same code I
shouldn't Java using Nashville for
calculating PI so Nashville has really
really good Java interoperation
I think that's one of its sweet spots is
excellent here we calling Java code for
streams in JavaScript we're passing in
Javas vert javascript version of
closures to the java and then later on
Java is calling back in JavaScript is
quite an entangled relationship but it
all works really well and that's that's
quite neat it's very easy to run there's
a new command line utility called JDS
which will run the JavaScript so let's
just run that and see if it it goes and
copy that
okay well whoops it's taking its time
it's not as performant innate but
there's a heck of a lot of work going on
now to make natural and extremely good
in performance they're doing a lot of
work and it's all going into Java 9 and
they can run it in Java 9 and most of
these things will get put into an 8 you
release 8 you 40 later on so the
performance of mash 1 is going to get
better and I can run my Java 9 version I
run it again because it's got a warm-up
because I'm running a new VM and it gets
better it's better than it was before so
performance is going to improve in
Nashville and the interoperability is
great you can use streams in JavaScript
or Java if you want to and you can go
parallel to ok shall we switch well so
so I hope you know one of the things
that's hopefully a take away from this
right aside from the fact that oh yeah
that looks very nice it looks you know
pretty easy to deal with you know as
Paul said but what we've aimed at is
something that you know makes it easier
for you to write things makes it simpler
and makes the resulting code far easier
for you to kind of understand and come
back to and kind of get what this is is
doing far more far more declarative and
so I think there are a lot of nice
aspects of functional programming that
you now can take advantage of directly
and in Java so I mentioned earlier open
JDK I talked about the JCP right and and
so I often get a question about well you
know what are these two things and and
you know how are they similar or
different open JDK is a community for
developing the source code for the
reference implementation of Java SE so
this was kind of the next step in the
evolution of making it possible for for
people to get involved in the direction
of Java and so this has been around
since I believe around
well between 2006 2007 the code the
original code from the Sun
implementation of Java was was
contributed to open JDK this is where
our development happens
so and I think a very very nice thing
about it is this is not an open-source
model which is we do a bunch of work
behind closed doors and then we throw
stuff over the wall and you can see it
but you don't see how it got there
this is actually something where you can
go and you can you can go to the
mercurial servers and you can look at
what's going on you can look at the
state of projects you can see check-ins
as they're happening you can subscribe
to the mailing lists and MC feedback
that is happening on reviews of
individual check-ins and you know I
think that this is a tremendous thing I
think it's a wonderful learning
opportunity and it gives a lot of
transparency you know not only in terms
of seeing the resulting source code but
also seeing what were some of the
thoughts that went into getting it to
the place that it is you know what are
the kinds of things people think about
as they're reviewing code in particular
areas and and so this is something if
you haven't looked at it I'd encourage
you to you know transparency is one of
the big things here it's also this idea
of collaboration in the Java community
I'm really pleased at the number of
contributors that we have from from
different places I should mention that
you know in addition to to my position
at Oracle I'm also the chairman of the
open JDK governing board so I'm always
happy to see that moving forward going
on you know we we see you know at this
point top individual contributors folks
like like Doug Lee and and others but
also you know lots and lots of
enterprises involved this started out
being mostly the kinds of people you
would think of that have an interest in
implementing Java what we've seen now is
that more and more
there's engagement by people who are
kind of expert users of Java right and
so if you consider yourself an expert
user of Java or even if you don't you
know this is a great resource for you
is anyone familiar with ole oh you heard
of that so there's a great site out
there called ole oh I think it's Oh H
LOH this is a a place that collects kind
of statistics on open source projects
and communities so you can actually go
there and you can look up openjdk and
you can see there this sort of
independent you know body that's kind of
gathered statistics on contributors and
contributions to lots and lots of
different open-source projects and if
you go there you will see that you know
the numbers of contributors the number
of contributions that have occurred and
openjdk has just grown and grown and
grown over the years it's quite dramatic
we're continually working on the
infrastructure for OpenJDK this is both
in terms of things like thinking about
the process of how we doing things but
also in terms of of making the the
actual infrastructure that we use to run
the site and so on smoother so how many
people are used to or have looked at the
java bug system not a whole lot of
people this is something that you know
existed for many years but we about a
year ago moved to Alaska and JIRA and so
if you're used to JIRA you can go there
and look at this you can look at bugs
get an idea of what bugs are open you
can see when bugs are fixed and so on
and so forth so so that's also I think a
great place to look at and what I
finally mentioned here is something
called open adopt open JDK this is a
program or a group of programs that were
done by some of the larger java user
groups around the world i'd mentioned in
particular the london java community and
sue java in brazil these these are quite
large and vibrant organizations I think
I think sue Java has something like
40,000 members and these are all Java
developers who are interested in kind of
learning about things that are going on
they've done a bunch of work in order to
make it easier to sort of approach open
JDK and understand what it's about and
ways that you can potentially get
involved or or learn more about it and
then I think the final thing to mention
here right this is back to what I was
saying before with Java 7 Oracle chose
to designate open JDK as the reference
implementation for Java so basically
what that means is that this is a level
playing field there's no you know it
isn't in fact the Oracle JDK has to live
up to the standards set by open JDK not
not the other way around so anyone out
there who's implementing Java if there
are questions about compatibility open
JDK is where you go to see what's right
okay we're going to talk very briefly I
know we're getting to the end of the
time but we wanted to talk a little bit
about things that are coming in the
future here again I'm gonna down here at
the bottom just mention that we've
recently revved the process for
proposing new ideas for things that
could be done in Java in the future
these are now in in the Java bug system
in in the JIRA so you can actually go
and look at you know proposals that have
been made by open JDK members about you
know new things that we could do you
know these are in general sort of
described as kind of an idea without any
necessarily any context on exactly what
kind of time frame it it might come in
some of these may be wild ideas that
never get implemented but a great many
of them will and in fact all of the
features that were in Java 8 came in
through this process in a slightly
earlier version so they weren't in the
bug system but but it was essentially
the same same kind of open process so in
nine things I'd mentioned in particular
jigsaw Paul is working hard on that when
he's not off having fun at conferences
and so as soon as he's done I'm shipping
him back and and we also have some work
on enterprise deployment and what I mean
by this is I quite often have companies
that come and say hey we've got like you
know 50,000 desktops in our company that
are using a java application
we really don't feel like we have that
good a handle on which versions are
being used and we want to stay on the
latest secure version but we don't want
everyone to administrate your own
desktop and how do we do this
so we've been doing a bunch of work on
this both in order to let you leverage
you know tools that are out there like
Microsoft installers and things like
that but also in order to be able to get
a better idea of tracking what things
are being used in order to take you know
particular applications and tie them to
particular versions and the other way
around as well so that if you know that
a you know there's a compatibility issue
with a particular applet or application
you can say it's alright for you know
for this old version of Java to run that
but I don't want it to run anything else
so some good stuff going on there
continual improvement to the JVM this is
both in terms of allowing you to have
you know better isolation but at the
same time increase the amount of sharing
this is something that that I think
becomes even more relevant in in the
cloud as people want to be able to share
resources and and get some kind of
efficiency improvements there are
additional improvements to
serviceability so as you're doing that
you also want to have an idea of what's
going on in there have better
transparency and understand what's
happening in the VM one other resource I
would mention in this context is there's
a small conference that is I think now
in its seventh year called the JVM
language summit this happens at the end
of July and it's quite small it's it's
invitation only but all of the talks
that are given there are made available
on on the web and so this is quite a
neat thing if you want to see you know
people involved in implementation of you
know languages like Scala and Clojure
and and JavaScript Naz horn you know
meeting and talking with people who are
implementing the JVM in order to you
know help us understand what things we
can do in order to make the JVM a great
runtime platform not only for Java but
for other languages it's it's a pretty
neat thing
- - with us alright and then this is
some things that are going out even sort
of further into the future Paul do you
want to want to say something about
someone if I want to get across all of
this I think that in Java eight was a
Renaissance and this is the industrial
revolution happening in Java there's
some really key things around improving
the performance of Java like what you
might get with value types which you can
think of the strokes to enable you to
lay out stuff in memory far more
efficiently so you can iterate it
without blowing your caches and stuff
like this so this is really exciting
stuff a stuff would like project pan or
and FFI is to get the VM to communicate
better with your OS much more
efficiently and much much better
developer wise than you would do with
J&amp;amp;I there's some very key features of
the VM and hotspot that have to come
about to make this as some might trickle
through earlier and percolate up later
on as we progress through nine and ten
and this enhanced volatiles is something
that Doug leaves working on and I've
doing a bit of work on and it's allow us
to replace something called Sun miss gun
safe or usages of that with safe but
performant alternatives so we could
place all the Sun misconceive stuff
going on in Java use of them current
libraries with this public and safe API
and other people like people who write
disrupt there another concurrent
frameworks can do exactly the same so
when we remove some miss gun safe in
jigsaw we have this public API that
people can use instead
so having mentioned that I wanted to
just sort of name a couple of things
that that you can do to help and that
you may not be aware of one one thing
I'd like to point out for those who
don't know about it is the the work that
we do the releases that we're working on
actually have publicly available early
access bills and these are available on
about a weekly basis so basically you
know if you want to go and try these out
in advance you can do that why the heck
would you want to do that well you know
basically you'd like to make sure that
your application is going to be able to
run smoothly on this and if if it isn't
we'd like to make sure that we fix any
issues that keep that from happening and
of course you know we can only do that
if if we're aware of issues and you know
Java is used by so many people in so
many different things that there's no
way
you know as good as great a job as as
people do you know testing you know the
best thing that we can do is to have
everyone out there helping to test and
reporting issues and the earlier you
report an issue the more likely it is to
get fixed
so you know please try these out this is
something I'd especially stress as where
as jigsaw starts to come into 9:00 you
know Paul was mentioning things like Sun
misc unsafe you know no longer being
accessible there are other things like
that where we're doing a bunch of work
to try to figure out you know the things
that are in the sort of in-between zone
right where they're not things that are
a part of the spec and are guaranteed
you know to remain compatible but they
are things that a large number of
applications out there have
traditionally used and have some kind of
reliance upon and these can be both
things that are you know just API or
they can be things that are more subtle
like behavior of API and so you know
we'd really like to make sure that there
is something that provides a smooth
transition and you know you can really
help us by trying things out and telling
us about it and patches and tests and
that's right and you know even more the
bug reports you know patches and
or welcome as well so please check this
out and the final thing you know I'm
actually just interested I like to get
kind of an idea of how many people are
using different versions so how many
people do we have out there who are who
are right now primarily using Java 7
okay how many people are now primarily
using Java 8 okay so some of you have
homework to do
how about Java 6 still a few those and
how about five or earlier shame on you
okay good well you know I I would
actually say that that I think you guys
are a little bit behind and and why I
say this is that you know most places
that I go and ask this question I'm
actually you know kind of amazed you
know there's usually quite a number of
people who are using oh you know what I
didn't ask how many people have
downloaded an early access build of nine
and tried it alright extra star for the
man in the maroon sweater - er good job
ok so so anyway I do think that this
transition is is one that you should pay
attention to please do try it out you
know by and large everyone who's tried
out eight has come away with a very very
positive a positive experience so with
that I'd like to thank you very much and
I hope you have a wonderful conference
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>