<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2014 • Immutability: Putting The Dream Machine To Work • David Nolen | Coder Coacher - Coaching Coders</title><meta content="GOTO 2014 • Immutability: Putting The Dream Machine To Work • David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2014 • Immutability: Putting The Dream Machine To Work • David Nolen</b></h2><h5 class="post__date">2015-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J-bC20aAat8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's get started so my talk is
called
immutability or putting the dream a
machine to work this talk is about
applying immutability to user interfaces
these ideas are not new they've been
applied to disk quite a bit if you use
git git uses immutable data structures
and immutable trees under the hood
systems like ZFS the D duping feature is
about sharing structure
I'm also Dropbox uses this trick let's
the reason Dropbox and scale because
they also have D duping of files in the
cloud so but I don't think anybody's
thought really hard about applying this
to designing user interface programs and
hopefully this talk will convince you
that it's a good idea it's not necessary
to adopt this wholesale but there may be
problems that you encounter in your
applications where you might realize
after this talk that immutability might
be a useful tool so I work at cognate
sect I've been a JavaScript developer
prior to that for about nine years work
for working for startups I was at the
New York Times for four I worked on some
fun stuff like the 2012 election so a
lot of JavaScript I recently left to
join forces with cognate echt cognate
tech is a company that does quite a bit
of consulting with Fortune 500 companies
using their particular stack it happens
to be closure closure as an open source
programming language it's a lisp it
emphasizes immutability we also maintain
closure script when I'm the lead
developer I've been working on it for 3
years now which is a dialect of closure
that compiles to JavaScript we also have
a product called the atomic which a plow
applies the same sort of ideas to
databases so it's a relational database
and I'm sort of optimized for the cloud
that uses immutable data structures on
disk but I'm not going to talk about too
much about closure closure script or des
Tomic today I kind of want to talk about
the broader idea because I think it has
much wider implications than anything
language specific if you haven't read
this book and you're involved in UI
programming I think you should probably
run to the book store and try to find it
out of print copy sadly it's not in
print anymore but you can get one cheap
paper back on Amazon this is a fantastic
book I encountered it because Alan came
mentioned it on his mailing lists the
foundations of new computing he
suggested it because people were asking
how did the sort of current state of
object-oriented programming as well as
user interfaces come to be and this is a
very good sort of history of that time
it's sort of centers around this
interesting man JCR Licklider he was not
a computer programmer he was actually a
psychologist on and who believed that
human factors in psychology would play a
huge role he wrote two very famous texts
one was called the man computer
symbiosis so back when computers were
primarily primarily used only by large
corporations and by governments for
doing you know weapons simulations he
envisioned a future where people would
have their own computer and all the
computers would be networked and it was
his vision and his sort of funneling of
government money US government money to
the right places that allowed the sort
of computer revolution to happen so if
you've ever heard of Douglas Engelbart
mother of all demos where he demoed the
first word processor the first video
conference the mouse all this was
because JCR Licklider believed in
Douglas Engelbart and thought that he
had a strong idea of the future so
Lickliter 54 years ago wrote this book
ups or paper papers very short I called
the man computer son biases where he
outlines all the things that he think
that has to happen for the interactive
computing revolution to take place it's
actually quite interesting but I read it
like two or three months ago and
something really surprised me that I
think is really relevant today
he actually sort of predicts my talk 50
years 54 years before I did it
specifically he's talking about how to
structure data in application and he
points out that the tree memory
structure invented by Ed fredkin would
be very useful and basically it's it's
it's a very simple tree data structure
in which the structure is shared and
we'll see that to great effect this is
this talk is going to be actually quite
a bit about data structures and then
we'll see these data structures in
action
towards the end of the talk so he but he
took money and gave money to people like
John McCarthy John McCarthy more or less
invented live coding right the very
first repple Lisp he invented garbage
collection
you know functional programming
programming with recursive functions so
he is very influential to his right is
Ed fredkin who was a sort of a college
dropout became a fighter pilot and then
was a sort of a hardware hacker he was
the guy that could program these very
early computers to do impossible things
so that they could create these first
interactive prototypes but he invented
the tree sometimes you will be you hear
called try just to differentiate between
tree but the the word TR ie M comes from
retrieval and so he says the correct way
to pronounce it is tree so I will
continue to use that so Lickliter also
created the culture in which money could
be funded towards places like Xerox PARC
this is Alan Kay you know sometime in
the 70s a park in front of an alto
that's probably running a small talk the
granddaddy of the modern form of object
programming as we know it at that around
1979 they invented basically you know
dynamic UIs and you know they came with
these ideas model-view-controller
not much has changed you can actually
load up a modern small talk vm and you
can load up the class browser the system
browser which shows all classes that are
running at runtime and you will find the
words Model View controller 35 years ago
longshadow the concept was actually come
up sort of invented by a Norwegian
computer programmer at RIT Varin skog
and and it was sort of amended by Adelle
Goldberg and others and this was passed
around and this more or less has shaped
our idea of UI programming to today
longshadow I mean people are still
writing competing MVC frameworks in
every language so at a very abstract
level I mean I think this is this is
true because I think MVC is very sound
you have some sort of data model that
represents the domain that the user
cares about you need to present the
users can't see data structures right
even programmers can barely see data
structures so you need to have some
visualization and that's the view and
often where things get extremely
complicated is the controller which is
how do you coordinate what the user sees
on the domain that they want to
manipulate which you have represented in
the machine but I would argue
implementations leave much to be desired
so this is the more I would say
controversial part of my talk and that's
because NBC's today are you know
primarily designed around stateful
objects object and programming sort of
you know has this notion that you
encapsulate state and objects but even
in capturing Clapp encapsulating state
and objects has very serious problems if
you've done any multi-threaded
programming you're well aware of this so
this is the data structure part you
might be like really a data structure
talk but hopefully I can make this
interesting not because I doubt many of
you have seen how persistent data
structures work so these slides are not
my own they are from this excellent
person Zach Allen he is a facilitator at
this thing called hacker school which is
a coders retreat like a writer's retreat
for coders in New York so I'm just going
to reuse this slides because they're
excellent so so even if you are of the
object oriented frame of mind it's not
it's even if you want to keep doing that
side of style of programming in order to
understand why persistent data
structures exist you have to at least
step into the shoes of a functional
programmer if only briefly so we're
going to do that so functional
programmers they care about mutable
objects immutable objects not mutable
objects sorry immutable values not
mutable objects and then you don't
really change things right you don't
change things if you want to update a
data structure it's you simply return a
new one leaving the original one
unmodified
so traditionally in people have done
this with copy-on-write I'm going to
demonstrate how you can do it
efficiently and they're called
persistent which is kind of a completion
of turns most of us when we hear
persistent we think you're going to put
it on disk or something but the the only
in this in this context is just saying
that you're not destroying the previous
value and they're fast and this is
extremely new development and within the
past decade and we'll talk about the
background for that but before we get
into that let's let's talk about the
basically the simplest persistent
structure you can write which you guys
already know about it's called the
linked list so you can imagine a list
with four elements and you have some
head and each cell points to the next
one this is something that you learn in
CS 101 and the neat thing about that is
that in oh one time you can you know
cons you know construct a new list by
just you know can you know allocating a
cell and setting the pointer to the next
tail what's cool about this is now you
have two distinct lists they represent
two different values but if you look at
the sort of layout here on the screen
you see that they share more than 50% of
their memory right 50 percent of their
memory is shared you could get the tail
of the X list and then you could cons
another head on to it and now you have
three distinct values you know they
represent three distinct values but
again they're sharing more than 50% of
their memory structural sharing that's
what persistent data structures are
really about that structural storing
gives you a few things it gives you
space efficiency it also gives you a
computational efficiency so if you have
used copy-on-write data structures
you'll see how we can be much better
than copy-on-write copy-on-write works
when your data structure is very small
but if you have for example a very large
array copy-on-write is gonna take you
know it's o n so the ideas that I'm
about to present were first sort of
research though not proven by Phil
Bagwell he invented these data
structures called the array map tree and
the hash array map tree and he and he
did this I believe the last one
maybe both but at EPFL which is the home
of Scala but it was really rich Hickey
who took these very cleverly designed
data structures and then put an
immutable spin on it and then
demonstrated that on modern hardware you
would get much better performance than
you would expect for example you would
think on paper that something like a
finger tree which is another type of
immutable data structure would be faster
but simply because the realities of
modern runtimes of modern hardware it's
just not true
the data source I'm going to show
completely blow that stuff out of the
water so let's talk about the simplest
one the bitmap vector tree and the
reason we're gonna pick this one because
it's not it's not too difficult to
explain and it's a data structure which
gives you the same properties you're
used to from arrays in other languages
kind of like a random access ArrayList
so you're allowed to append efficiently
to the end you can randomly access and
any element and it has good performance
characteristics so it's very much like
an array except it has this new property
in which that you can update it very
efficiently without destroying the
previous whatever value previously
represented unlike immutable arrays so
data lives in the trees
it's a prefixed tree we're not will will
see diagrams that explain this
that's a bitwise tree and we'll we'll
see exactly what that means in a second
so how does this work it's basically a
persistent bitmap vector tree is just a
array of arrays you pick some size in
just it doesn't matter we'll see what
the correct size frame is but for now
we're gonna pick a small one because
it's easier to show the diagrams so
we're gonna pick n equal four and every
element of this array will point to more
arrays of the same dimension each one of
these arrays will point to another level
of arrays of the same dimension and then
finally you hit the leaf nodes that
actually contain the values that are can
that you care about and here we're just
going to use numbers because that's easy
to relate the indices to the contents so
now the question is okay that's
interesting but how do we get anything
out of that so there's this nice
property of integers right so 106 say we
want to find 106 element well we have
we're fortunate because 106 has a binary
representation and you can bitmask this
number to find the thing that you want
for the particular end that we've chosen
here we need to bit mass to bits so if
the first thing we're gonna do is bit
mask off the first two bits and that
tells us we have to look at index one
this is you know zero zero yeah counting
from zero and then the next two bits
tell us we have to look at index two and
the next two bits
say index two and finally we're out of
bits we know where it were no we're at
the end and there we have our value 106
at index two so if you know anything
about modern runtimes this is extremely
fast on the JVM and on JavaScript
engines now and we'll actually see proof
I will show you
v8 doing this so just it's just about a
couple of array access as accesses and a
couple of bit operations so now that we
know how to find something how do we
update something and this is we're going
to see how we can do much better than
copy-on-write
all we have to do is replace the path
that needs to change so if you want to
update the hundreds 106 element and
instead of 106 you want to put the
string foo we have to replace the root
we have to pull it replace the array on
the path of the next level the next
level on the next level and again we
know which ones to replace exactly the
same way as we knew how to find
something because the index that we have
the thing we want to replace well get
gives us the path so what's gonna happen
is we're gonna get a new vector write a
brand new vector and it's gonna share
like what 95% of its contents all these
other arrays that are not colored are
shared with the previous value and in
the last I'll actually show a demo of a
pixel editor that uses this trick to get
really fast undo and diffing so it's
pretty cool so what about this size
length for it sounds a bit arbitrary it
is after a lot of testing people have
figured out that 32 is really good 32
has a good balance between lookup time
and update performance as you increase
the size basically update takes longer
even though the lookup times are better
so we picked 32 just to give you a sense
of how good that is for at least the
current state of computing it won't
always be true and we'll probably have
to modify them but today this number is
a very good number because if you had a
persistent vector that was seven levels
deep that's 32 to the seventh power
that's 34 billion elements even if each
element was like a 64-bit value on a
64-bit OS that's about 256 gigabytes of
RAM
you're finally seeing machines in the
cloud where you could provision a
machine as that much RAM so it's a very
good so that you could actually update
and vector this large with at most seven
array updates you could find any element
in at most seven bit operations and
seven
axises again this is very cheap on
modern hardware you'll often hear the
phrase that no persistent data
structures are not a one to look up but
it's log 32 n which it's it's tiny it's
effectively o 1 ok so let's see a demo
so I said that they were fast well let's
see if they're actually fast so this is
a relatively recent build of v8 and what
I'm going to do here is I'm going to
build up a mutable array on VA and I'm
going to build it with its basic I'm
just and build it it's gonna be a
thousand LM I'm sorry million elements
just integers and then we're do the same
thing with a persistent vector so in
remember in the second case we actually
construct 1 million vectors this is not
the same as pushing on to the array
right and we'll see how does it perform
this is this is an old this is a 2010
laptops this is four years old so it
it's not even that fast so I should be
pretty shocking it's not even 2 times
slower even though the second one is
doing an incredible amount of work over
the first one right pretty cool so even
this would be oh they're usable there
are many applications worth were being
less than 2 X slower because of these
other properties that you get you'd be
like yeah it's not the performance
doesn't make a difference if I was
writing a Jason doing life and I was
using jQuery jQuery find element by CSS
ID is 165 times slower than than adding
an element to a vector it's not going to
be the bottleneck in your application
but functional programmers have been
doing playing this game for a lot longer
than duranium programmers and so we have
lots of optimizations in place so for
example it's very common to it's very
common to want to build something very
quickly so we have a really nice
operation which takes allows you to take
any Tran immutable vector in oh one time
thought it into a mutable thing without
affecting the original you can mutate it
and then at the end when you're done in
one time you can get a persistent
version of it
and this performs great so if there you
find that persistent data structures are
bottleneck and you need a little bit
more perf you can use transients that's
what we call them enclosure and there
are analogs in other languages so how
does it perform now so on this machine
with this particular build you know it's
more than twice as fast to build an
immutable vector and this is you might
be thinking well that's v8 our data
structures are optimized for all
JavaScript engines not v8 in particular
and so you can see JavaScript this is
JavaScript core this is JavaScript
engine in Safari so you can see that
JavaScript core is much better at
building the array but it doesn't really
matter
we still beat the mutable array in this
case by using transient vectors so good
perf so now that we and this is this
stuff is only gonna get better
I am I you know i've been following
javascript for a long time i mean the
amount of optimization that's being
poured into javascript engines is pretty
wild it's probably we've never seen this
much money being going into often
optimizing one language there's a whole
bunch of research that has a is in the
design of JavaScript core SpiderMonkey
and v8 that's really cool and the it's
only gonna get better because you have
this desire to basically get the to the
performance of see in the browser games
games are sort of driving this there's a
whole initiative called as MJS that
firefox did and the other the other
engines don't want to do it they want to
achieve that performance dynamically
without a o team this weird javascript
variant so only our stuff is only gonna
get faster so okay now that you guys
know about persistent data structures or
at least one form of them you can you'll
you'll have some interesting real
realizations as i had about seven months
ago I realized that Facebook's react
which I ignored which was released about
a year ago actually had this amazing
hook where I could attach persistent
data structures and basically make react
faster than it is out of the box if you
attach if you use persist data
structures with react it's just faster
and we'll see why and you can
some other neat things out of that as
well so ohm basically takes
clojurescript
and it takes react and it sort of shows
that we can you can build interesting
responsive efficient user interfaces
that actually make many hard things
easier to do and we'll see that so if
you have if you're not familiar with
react react is sort of up and coming a
lot of people are probably more familiar
with things like angular or backbone or
ank like what amber ember but those
those things are fine those things are
great in fact those probably can be
modified to do some of the things I'm
demonstrating but react is definitely
makes integration of immutable data
structures as simplest so well how does
react work react is sort of designed
around this sort of interesting batch
rendering sort of concept you know they
sort of treats the browser as a sort of
GPU so in a GPU you really don't want to
send individual instructions of GPU
because that's very slow you want to
batch as much as you can and send one
big message and so what react does
because that's really annoying to do by
hand in fact if you ever see highly
optimized Dom code people do this stuff
by hand so react says that's a pattern
we're gonna design our framework using
this thing called a virtual Dom and
we'll do that batching for you basically
react looks like an object-oriented
thing but it really was designed by with
sort of by a functional programmer the
guy that did this the original concept
was by somebody who is a fan of
functional programming but what it lets
you do is let you take your data your
JavaScript data you apply a view
function and then it computes a virtual
Dom if you have new data you apply that
function and it computes a completely
new virtual Dom that's how it works with
a high-level there are many
optimizations in place to prevent
computing the entire tree and it's
irrelevant
conceptually that is how it works it
produces a virtual Dom as your as your
values change that represent the entire
application and how it changes the Dom
as it says we can take the virtual Dom
we calculated at time zero and the
virtual Dom that we calculated at time
one and that will give us the minimal
set of changes to apply to the Dom
what's cool about this is that in this
world unlike what anything you've
probably used before
if
I just flip those two virtual Dom's
react will give me the reverse set of
changes right for free I don't have to
do that I don't do anything react will
simply compute the reverse set of
changes and we'll see a demos that take
take advantage of that okay so I I had
sort of I wrote a I wrote a blog post
like in January and it was very popular
was like I don't know I don't think I
got a hundred and fifty thousand uniques
in like a week and it totally changed
people's perspective of a react react is
quite popular now but I but I I sort of
postulated that doing undo as it was now
trivial which is classically an
object-oriented systems is a big pain in
the butt you don't want to add it later
I mean I said if you organize your
entire application state and run a
mutable data structure undo is free
there's nothing you have to do you can
jump to any point in time in your
application state and react will be able
to render it fairly quickly so this
developer at at Ableton Ableton Live the
musical software a UI developer there
read my blog post has said you know I
want to see if this guy's like serious
it doesn't sound like you could really
do this and so he set out to prove to
himself that it could be done and he
built a really great little application
it's a 64 by 64 pixel editor and what he
did was he put all of the pixels for
that you draw the frame that you draw
into into an immutable vector and he
wanted to show that you know demonstrate
that he basically get infinite undo
infinite redo it would be memory
efficient the application wouldn't slow
down that he could use the precision
data structures to get you know trivial
exporting of animated gifs and so on
and so let me show that right now so
here it is running in them make sure
this is gonna work okay so here it is
makes a little bit bigger so it's it's a
cool little app it's it's it's it's
actually quite a bit of code it's like I
think a two thousand line application
it's not simple he spent quite a bit of
time on it but I can I can pick a color
I can draw a little little halo around
this this funny little character on the
right side of the screen that's the
history I can undo I can radio and
even if I do this right I'm clicking one
pixel these are all getting recorded as
undo steps and you could do this all day
and it's you know it's gonna be
relatively efficient which is pretty
cool so it's very it's very it's very
nice and you also over here you can see
that I can scrub I can scrub the history
and it's also responsive right he's
actually he's actually using the fact
that this is all stored as persistent
data structures so you're probably
wondering well how complicated was this
part right the part that's the hardest
and the part that when people don't do
they just you know you get to undo
they're like I don't we don't care it's
not a big deal so this is his entire
file to implement undo sixty lines of
code this is playback this is undo redo
and the exporting to animated gif that's
awesome right this is really cool
something that's classically hard to do
with persistent data structures pretty
straightforward and then you're probably
if you're a performance minded you're
probably wondering well what about
memory usage so this is why ice for just
for fun I said well I'm going to take a
persistent vector with has 4096 elements
and I'm going to snapshot a thousand of
them basically I'm going to store them
in a root variable so that they get
theirs they're pinned so that I can do a
heap snapshot google chrome dev tools
has an awesome heap snapshot it shows
you exactly how much memory or
JavaScript application is using and so I
I snap chatted a thousand frames and
then I took a an array with 4096
elements and I randomly updated but of
course I had to copy on right at the
copy-on-write every array because if I
wanted the same behavior that's we had
to do to do a thousand snapshots took
two tenths of a megabyte with persistent
vectors on the right you see that it
took about 1.7 megabytes if I used
copy-on-write with arrays so it's nearly
an order of magnitude memory savings so
it's not just speed you know it also is
very efficient in memory so of course
people often misconstrue what I'm saying
is like undo redo well that's that's
great but doesn't apply to all
applications and people often don't
understand that this is not about under
a redo this is about very powerful state
management if you have modal's if you
have a multi-step form where the user
can press the back button you don't want
to lose anything and you don't want to
have to do an extra persist to the
server just so that they can click the
back button and their form fields are
prefilled right persistent data
structures you can you can do it so you
can step through time you can even allow
somebody to go backwards in their form
change your form and then propagate
those those changes forward through
history so if you've ever done any get
magic anything that you think is really
cool like with fancy get tricks you can
do this in memory in your interactive
application so it's much bigger than
under e - it's about powerful state
management tools to the extreme you you
have things like an extreme case of this
is Elm so I'm sure as many of you've
seen Bret Victor's talks so Bret
Victor's talks are really cool but
they're just prototypes they aren't real
and so people at the end of his talks
are all like oh that's what I want but
it doesn't actually work so it's been
interesting to see actually the the
functional social functional JavaScript
and compile to JavaScript people
actually taking trying to do the real
version of this and Elm is a is a sort
of functional programming language the
targa JavaScript then also emphasizes
immutability and so they were also able
to with not too much effort right to
modify their IDE so that they use a
persistent data structures snapshot the
state of the entire application and you
hit a bug and you can basically pause
and it's been recording everything and
you have a slider and you can actually
slide the slider see what values are
wrong change change your values on the
fly change your program on the fly that
will get hot loaded modify the states
that the program is aware of and you
know you can edit and continue so all
this still like he's he's gonna modify I
think the gravity yeah pretty cool so
there are lots of possibilities not just
the ones I've talked about okay so I'm
gonna basically almost getting towards
the end so if you want to play around
with this in your JavaScript developer
and you're interested in this type of
thing I wrote something two years ago
now called Maury
it actually takes
entire clojurescript standard library
and presents it as a normal JavaScript
library you can include it the way you
would include anything else it's pretty
nice it's a fun way to play with it it's
actually quite popular on in the node
community now relatively speaking it
gets basically 8,000 downloads a month
which is not bad so finally people are
warming up to it when I announced this
two years ago like you know for a year I
got zero downloads but I've been doing a
lot of talks in the jazz community about
it and people are starting to see yes
this is valuable sometimes and that's
really cool Facebook now because of I've
been blogging so much about how awesome
immutability is when you pair with your
react they actually are making their own
idiomatic immutable data structure
library so Facebook is doubling down on
immutable data structures because they
they want users of react to pair them
with immutable data structures in fact
if if you could convince all JavaScript
developers to do this I mean react would
just get four times faster right it
would just for free if you get everybody
to use immutable data structures and
then you're probably wondering well if I
use immutable data structures that's
really cool but I have to use JSON so
how do you get immutable data structures
from your server to the client so we've
already solved this problem at cognitive
for you too we have a cool library
called transit which piggy backs on JSON
and I wrote a blog post on actually
changing transit so that you could read
a value off the wire and instead of
getting immutable arrays and mutable
objects you get immutable j/s vectors
and maps so and it's fast it's not slow
immutable J's has the right hooks so
that we can construct these things very
quickly so it's a very small overhead
over JSON and so who's using this so
actually prismatic which is pretty big
now I think they actually have ten
engineers or something working on an
application they really like it I mean
the thing that they like is that ohm
gives us gives them a very good story
for reasoning about the code they're you
know it's not a code base where
typically in JavaScript like you don't
know what's mutating what and in their
application they're it's it's very clear
if they need if they need some sort of
state change where it's happening meteor
j/s which is really popular doesn't
actually export more-- but they you
they've also found a use case
Mauri inside of the dependency
resolution system their package manager
uses a constraint solver and it uses
Maury under the hood so that this to get
like a 50% performance boost circle CI
which is you know a reasonable semi
popular continuous integration service
they all use they use ohm on the front
end and of course there's of all these
other companies that use closure script
that are already sort of sold on
immutable data structures but it's
really exciting to see that again this
is coming to JavaScript and JavaScript
are also excited about it as well so
there's some links these put these
slides will be available I recommend
checking them out and I think that's all
I have I can take questions
so what I was alluding to early on is
that you can pick your strategy right so
actually in in Goya when I'm scrubbing I
mean that's an animation so all he's
doing is he's heat so it's not like
you're gonna stop using mutation right
that's not going to happen so he just
takes each vector and he blitz it onto
the canvas so it's just a you takes its
grab a vector you know go through every
element and in the four loops a four
loop just mutate the canvas you will use
the same techniques for animation okay
so which which what data structures do
we have we have sorted maps we have
sorted sets we have sets we have maps
vectors queues linked lists I think
that's it yeah
we're also very clever I mean so the
thing is that you know we like honestly
some of these things that you use
there's like five data structures
involved because we want to swap out the
right one for the particular particular
users usage pattern so that you don't
have to worry about it other questions
no okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>