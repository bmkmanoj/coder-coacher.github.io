<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GOTO 2017 • WebAssembly: What and What Next? • Ben Titzer &amp; Andreas Rossberg | Coder Coacher - Coaching Coders</title><meta content="GOTO 2017 • WebAssembly: What and What Next? • Ben Titzer &amp; Andreas Rossberg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/GOTO-Conferences/">GOTO Conferences</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>GOTO 2017 • WebAssembly: What and What Next? • Ben Titzer &amp; Andreas Rossberg</b></h2><h5 class="post__date">2018-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R9wn99Xheq4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Ben I work at Google in
Munich on webassembly it's a project I
started three years ago with some
colleagues that actually not colleagues
but some collaborators at Mozilla and
since then many people have been
involved my colleague andreas Rosberg
also works at Google we're gonna give a
half-and-half presentation so we're
gonna switch off in the middle so you
can stand there and be creepy if you
like you can sit but I'll go ahead and
begin yes you can stand up and slap me
if I say something wrong
okay so I'm gonna talk about what
webassembly is why we did webassembly
why it's like that actually the why is
gonna be more Andres as test to describe
and we're gonna talk about where it's
going so what is web assembly what we've
designed is basically a bytecode for the
web is designed to be portable across
machines across platforms so that you
can write a program and get to sort of
run right once run anywhere kind of
promise that java head
it's designed to be compact and to be
compact it's a binary format so you
don't see text unless you disassemble a
binary in order to be universal it has a
low-level execution model in particular
we wanted to support languages like C++
because we observed that many people had
their asou plus plus applications such
as games and we're already compiling
them to the web and running them in
JavaScript so those already used case
that we wanted to support so we had to
make sure that it worked well nowadays
which is really great for me to be able
to say this
it's natively support in all major
browsers that means Chrome Firefox
Safari and edge we developed in under
the auspices of a w3c community group
which basically allows anyone to join
and comment and also we have a working
group which is a more formal body which
sort of they actually approve final
specifications the idea is that we
didn't want to reinvent the web platform
but integrate with the web platform so
any API that you have for example that's
available in JavaScript you can get you
through web assembly so there's a lot of
users already and many potential users
coming so we've shown demos including
Google Earth the unity3d engine which
many many games both on Android and on
the web use but CAD applications
farmville - which makes money for Zynga
audio editing and things like that all
these things are now coming to the web
and web assemblies execution technology
for them I'm going to talk about the
basics of the technology so all code and
web assembly comes in larger groups of
what we call modules a module is
basically a group of related functions
it can be as large as a whole executable
or can be as small as a DLL you can also
make a module as small as a single
function if you like a module always
imports the functionality that it needs
from outside so anything besides running
peer computation and accessing memory
anything that would be i/o anything that
would be networking anything that would
be displaying graphics that has to be
explicitly imported into a module what
that gives us is a separation to say
that web assembly code can be sandboxed
so you add the external functionality it
can also be embedded in other scenarios
besides the web but in particular web
gives us the capabilities to talk to the
Dom for example but always through
JavaScript enforce a module is not an
actual program that's executing it has
no state it instead is like a
declaration you can consider analogous
to the text of your program it's not an
actually running program in order to get
it running
you have to instantiate it that creates
something that does have state and I'll
talk about in detail what the state is
but it's basically a large memory and
also local variables global variables so
an instance is the running program so to
speak so to put that in pictures just
because a slides full of texts are
boring you I'm now using green boxes to
represent modules module basically again
has just functions inside everything
that it needs from outside is explicitly
imported and it can also export
functions so anything which is
functionality such as the main function
or subroutines to decode images or
whatever that modules role is our
exports instantiation produces an
instance an instance has the actual live
data in it
so I'm going to talk about the binary
format for those of you interested in
bytes and bits just to give you some
context you don't have to memorize this
hopefully that you're not actually
writing web assembly using the raw bytes
but it's basically very simple it's just
a series of sections that come in in a
specific order each section has a byte
which tells you what type it is we use a
very variable length encoding that gives
us future proofing so if we have much
larger modules in the future we're
basically limited to 4 gigabyte modules
now but you can imagine all and it's
sort of go away and form this of time
function bodies which are basically the
meat of your program the code is a stack
machine and that code is represented as
byte code so it's very dense so it looks
basically like this we have these codes
which come in order a module first
declares all the signatures of functions
that is going to be using in the first
section because those will be referred
to by later sections imports come next
so you can already within the first two
sections you can tell what functions
signatures will be there what types and
also what a module imports and then we
get two function declarations which are
functions that are inside this module
and defined inside this module the
indirect table is how we do indirect
calls I won't not important to get into
the details of that memory configuration
talks about how big the memory is that
this module expects and other properties
of it Global's are global variables
exports are the functions that will be
exported from this module and therefore
be available outside the module there's
also an initialization function which
you can specify the indirect tables can
be initialized that's as the next
section after that then the main section
after that is the function bodies which
includes byte code and then there's some
initializing initialization data through
memory so you can have some part of your
binary basically gets loaded into memory
at the start so proportionately speaking
most of the most of the binary is going
to be the function bodies it's going to
be code we've observed about 90% of the
modules in the wild are comprised of
code and then of course it depends
you can add custom sections to a binary
those things are ignored by the engine
they execute the engine they execute
your binary and you can add them at the
end or sprinkle them in the middle and
obviously the proportions will change
with how much extra sections that you
add okay so I'm going to talk about the
execution model now so above this sort
of dashed red line in the middle of the
slide that's application state that
state that your program can actually
change by executing instructions things
below the line you cannot directly
change nor address and this is basically
how we accomplish sandboxing so if you
can imagine if you think to x86 if you
think all the way down at the Machine
level you can address the stack and you
can smash the stack and that's a huge
security vulnerability we didn't want
that for the web they'll be terrible so
instead the call stack is something that
you cannot directly address you cannot
no bug in your program can cause to the
call stack to become corrupted similarly
with the indirect function table which
is how we do indirect calls that cannot
be corrupted by your program the
function representations whatever they
look like inside the actual web assembly
engine you cannot get to them and that's
by design
instead the state that we give you to
play with in your program is basically a
large byte array it sounds almost silly
when you put it that way but it's
basically an emulation of a machine web
assembly is a machine so you can
literally put any bits that you want
into the memory but that memory is
separated from all the other memory in
the process of the embedding so you
can't get to the browser state through
the linear memory that's only private to
the program the other state that we have
is global variables and those you cannot
address indirectly you have must always
specify an index so you can't corrupt
the global variables by having an arrant
pointer in your C program for example
I'll talk about the instruction set we
have four basic types they're all simple
primitive types so we have 32-bit
integers 64-bit integers 32-bit
floating-point numbers in 64-bit
floating-point numbers integers do not
have a sign instead we put the sign on
operations this is the same way like a
machine works so x86 does not define
that
a 32-bit register has a sign instead
there are operations that treat the high
order bit as signed or not instructions
are you can group them roughly by the
types of values they manipulate so we
have addition and subtraction and things
like that for each of these primitive
types but we also have instructions
which are polymorphic or there's sort of
parameterize over types so accessing
local variables global variables and the
memory all of those you can load
different types and then to accomplish
function calls we have byte codes for
calling functions directly where you
specify an index calling functions
indirectly that's where this table comes
from this is where you specify computed
index returning from a function and then
local control flow is done with blocks
ifs and loops so instead of having jumps
and branches in your code you actually
have structure control flow constructs
okay so now we get to actually look at
the bytes if you're interested so we
have a text format for web assembly code
you can take any binary and and
disassemble it to that text format you
can also go what the other direction
take the text format and go to the
binary just to be clear this is more
like disassembling x86 machine code this
is not like going back to your programs
original code we don't expect people to
write the text format to write their
programs this way instead they compile
into web assembly but I'll show you kind
of some various highlights about how we
about how the binary format works so on
the Left we have an add function it has
two parameters we declare the types as I
32 we declare this result type as I 32
and then inside the function we have
this in the text format we have this
syntax which looks a bit like Lisp which
is s expressions you can we're adding
the two we're getting the the values of
those two local variables and then just
adding them in returning there there's
an implicit return so if you fall off
the end of the code with a value that
gets returned from the function so in
the binary what we have is a selection
of what shows up in various sections so
in the type section we have to have a
declaration of that function
signature type this is how it looks 6d
and hex actually means hey this is a
function type to is the number of
parameters than 7f is int which you
should probably not memorize but and
then there's one return value and that's
actually the future proof for adding
more return values in the future so
that's how we describe this type and
then in the function declaration section
we just have a series of there types the
only thing that we have to declare what
the function is its type and we use a
index into the type section so we have
one function it's type number zero which
happens to be that and then the function
body we have one function body its
length is seven so that blue number
there is actually a variable length
encoding of the number seven it could
actually be one byte but in this example
it's padded and then the function body
comes next it tells you that we have
zero additional local variables it tells
and then we have the actual byte codes
so the byte codes come in execution
order to 20 and X's get local which you
should also memorize and then the local
variable indices so the actual need of
this program is only the seven byte a
body which is quite a bit shorter than
the text format obviously okay so I'm
going to talk about how we embed web
assembly we had a very clear goal that
we wanted to separate the execution core
of web assembly from how its embedded in
another program in another setting so I
mentioned that I mentioned the x86 a
couple of times is you can think of web
assembly as being an out analogous to an
instruction set architecture x86 doesn't
have I Oh functions that doesn't have a
graphics card that's part of the
instruction set instead that's all
provided by a layer of software above
web assembly is very similar we call all
that layer above the embedding so that
layer provides the ability to load and
instantiate modules link modules so
imports and exports being connected
together and also import host
functionality so again like IO functions
accessing frame buffers whatever you
like that's all in a layer above web
assembly so we've defined a very clear
separation on purpose for doing that
the most important embedding is
definitely JavaScript so web assembly
can be embedded in a JavaScript
execution context and in fact in v8 in
Chrome that's how it's implemented it's
embedded in the JavaScript API and then
that is embedded further in the web so
there's actually more layers above web
assembly so the JavaScript API is allow
us to load in the stanchions and get
access to other api's in javascript to
do all those fun things with the screen
in the dom we can also call web assembly
from JavaScript and the key idea is that
web assembly doesn't add any new API
surface to the web other than the API is
for manipulating web assembly it doesn't
fundamentally change what you can do
with the web so just to make that a
picture because again text is boring
we've got our module here actually an
instance here
it's got his code and data inside the
only way that it can get to the outside
the only way can get to the console or
do IO is through imported functions that
means that the outside world can sort of
interpose and make sure that web
assembly module doesn't escape its
sandbox so to speak okay so we can have
explicitly imported JavaScript functions
you can think of this blackness around
as the void which is JavaScript we can
have explicitly imported JavaScript
functions and we have an API which I'll
show in the next slide or two slides
what that looks like to load and
validate the modules and then when a
function is exported from a web assembly
module
it's just callable from JavaScript like
another JavaScript function we can also
export the the actual data the memory
the linear memory that I mentioned in
the other slide we can actually get to
that from JavaScript that's optional
that's basically a way that you can do
zero copy IO with JavaScript in the web
platform so this is what that JavaScript
API looks like there's a web assembly
object which is in the outermost
JavaScript context and everything hangs
off that we have types which represent
modules so this is an opaque
representation where you take the bytes
and you decode that to a web
module instance and then from JavaScript
you can create the next thing which is a
web assembly instance and actually has
the state the memory is in tables you
can actually create and manipulate from
JavaScript
through the API and that's I won't get
into that but you can accomplish a kind
of dynamic linking that way there's also
an synchronous and asynchronous API is
in JavaScript for doing these things for
example the constructors that take bytes
those are synchronous those will not
complete until that operation is done
for example compiling or parsing the
bytes but the asynchronous API is give
you a promise back so that you can go
back to the main event loop and then the
promise will complete when that
operation is done now I'd like to hand
it over to my colleague andreas for the
rest of ya so at this point we could
give you all sorts of examples of how
you use that web assembly and how you
write code how the code looks in I mean
Ben gave some simple examples but the
the basic idea is you should never be
doing that right you shouldn't be
writing web assembly code by hand so
there isn't much point in actually
showing much of that in the presentation
here rather instead of doing that I want
to give you some more high-level
background about why we did web assembly
and why we did it the way we did it and
where it's heading so okay so obviously
one of the goals of webassembly was to
provide high performance to the web I
mean with JavaScript these days you can
get pretty good they are amazingly fast
if if you hit the the good cases but
it's it all depends on actually hitting
the good cases right so actually more
important than just performance in
general is that this performance is
predictable so that was one of the main
goals of web asunder to write provide
you with predictable performance models
another important goal for us is
actually basically let me call it
breaking the javascript monopoly on the
web right so there are a gazillion
languages that compile through the web
these days but if any of you who is a
compiler writer will probably realize
that javascript is like a horrible
compilation target
and you have to jump through all sorts
of fruits and it's gonna be inefficient
in many cases to compile a random
language to JavaScript
so for web assembly we wanted to have
this universal format that you can
compile any language to in a reasonable
manner and what comes with that also is
the ability to add features and have
languages that compile to the web
support features that JavaScript does
not support and probably won't ever
support so one early example of a
feature that JavaScript currently
doesn't support is like in 64 native
types other things are threats in some
way and cyndi for example we're gonna
add at some point and things like that
tail calls is another interesting
example I could talk about quite a while
so yeah it gives us a new way of adding
features to the web where JavaScript
would get in the way and one other thing
I guess some of you are aware of like
previous technologies that existed like
SMGs was kind of like a predecessor of
web assembly and that was done by
Mozilla and and Google had this
technology called Native Client where
you could actually ship x86 or in in
portable neckla was LLVM bit code to the
web but all these technologies had their
issues and weren't widely adopted and
one one reason to do web assembly is to
unify them into one thing that everybody
supports and it's maybe interesting to
know that all the people who worked on
asm.js and on neckl before all working
on web assembly in these days so we
designed this thing I gave you some
reasons why we want to do it and
obviously that comes with a number of
design goals and also design constraints
so there's a whole list of them I just
give them here I don't want to go
through all of them but obviously some
of these we already mentioned before
like it's supposed to be in language
independence it must be
platform-independent which on the web or
Hardware independent on the web it's an
obvious goal by
at home independent I actually mean it's
not dependent on the web or JavaScript
either and I will get back to that and
then yeah of course you want it to be
fast to execute you want it to be safe
which is also important on the web and
the lower two bits are properties we
wanted to have for this yeah it should
have nice properties it should be
predictable in in various semantic
dimensions so this is all about the the
semantics of web assembly as a language
if you want but there's another
dimension that then also already
mentioned which is the representation
that I mentioned so it's also important
because you transfer this these binaries
these modules over the wire that they
are compact right because that is where
where time is spent and probably you're
on your budget and for your mobile to
contract so it's really important that
it's compact but then also we want to
generate just-in-time compile a t'v code
so it's designed to make that easy so
that we can decode it fast that we can
compile it fast that we can validate it
fast on top of that the whole binary
format is designed in a way that even
makes it possible to start compiling
without having seen the whole thing so
you can actually streaming compiled like
while the bytes are still coming in you
can start compiling some functions and
you can paralyze out compilation of
separate functions to the whole binary
format and the order of sections you saw
on Ben's slide was chosen particular to
make these things possible
so did we achieve these goals well it's
in general it's probably a bit early to
tell but we have some preliminary
numbers so we we wrote a paper that we
submitted to to a scientific conference
earlier this year which is called PL di
where we had a number a couple of of
graphs so this is one of them which is
about performance and there's actually a
lot to see in that graph I'm not going
to explain everything but it shows like
execution time compile time and
validation time and VM start up for
various individual
Tremont's from from a larger benchmark
suit called police
pelleve entity and the blue bar is
probably the most important one that
actually first what what is the
percentage on the left that is the
comparison to execution time for the
same program so these RC programs
essentially when running on in compiled
SC programs to native code offline on on
the same machine and this is like
showing how how performant webassembly
is in comparison when you compile that
to web assembly and then run that on the
same machine so wherever we are at 100%
we have basically reached native code
performance so as you can see we're not
quite there yet everywhere but for most
of these benchmarks at least we're
getting pretty close I mean these are
benchmarks you always have to be careful
with benchmarks in reality it's more
often like that we are 50% or 100% over
so up to 2x is currently more like
realistic to expect for for your
application when you compile to WebP
assembly but this is very early days and
we expect that to still improve so one
other thing you can see there is as well
or actually can't see is one one kind of
bar there is so these are all stacked is
validation so that is the time it takes
to validate the bytecode so what the JVM
calls bytecode verification and you can
actually see that it doesn't show up
there so one of the because it's so tiny
it's so fast that it doesn't actually
matter so that was also an important
design goal to make validation very fast
so that is about performance in terms of
time and then I talked about could being
compacts a code size is another
important dimension so this is another
graph from the same paper and it's a
scatter graph that plots the size of the
same programs in either a asm.js or in
x86 SMS in code throwing machine code
against its size in web assembly and
that diagonal is basically where they
there are equal size so anything that is
below the diagonal
where most of the points lie fortunately
says that the webassembly representation
is smaller than either so yellow would
be the asm.js representation and blue
dots are the native code representation
so wherever they are below the diagonal
that means that webassembly is smaller
so that was important for us to measure
that we actually have achieved this goal
how did we achieve that I don't really
want to go much into implementation here
just a couple of things to say here what
engines do so first thing to to note is
that at least in browsers web assembly
is actually not like a whole new thing
that is in the browser it's actually
just implemented as part of the existing
JavaScript engines so it really reuses
lots of the infrastructure that the
JavaScript engines already have in
particular much of the compilation
pipeline and the memory management and
all that and that also has the advantage
that calling back and forth between web
assembly and JavaScript is like really
fast we can make that really fast so
there's even though you have to go
through javascript to for example
manipulate the Dom or use WebGL or
anything that shouldn't actually be a
significant overhead yeah and there are
so there's this one design we have which
is implemented in various browsers and
one thing to know is also that this
design is kind of general in that it
allows various different implementation
strategies and right now all the
browser's use actually somewhat
different strategies to implement it in
particular one one interesting dimension
is like how many compilation or
optimization tiers you have new pipeline
and so this is something that is like
very important when you compile
JavaScript you usually have several
levels of optimization which means
several compilers so you start with a
simple one that is fast so that you that
startup times are minimized and once
code becomes hot you recompile it with a
more optimizing compiler and these are
strategies that also apply to web
assembly there may be some one less
important because the quote
as much lower level so you can compile
it more directly you don't have to do
all the crazy that you have to do
for JavaScript but still it can make a
difference between like in especially in
terms of startup times it's really
important yeah and then there are
various textbook optimizations that we
apply in these in this just-in-time
compilers in the engines and other
tricks that I won't go into here so this
is the engine side but how do you
actually produce web assembly I mean Ben
mentioned it the the ideas that you
compile to it right you don't write it
manually you compile to it and you can
do that from whatever language you want
as long as you find somebody who were
writing a compiler for you right
so our first big customers are C and C++
of course most of them being prior users
of asm.js already so that is currently
at least done mostly through the
Emscripten pipeline and then there is a
quite a significant effort to have a
rust compiler targeting assembly and
there are various other like projects
going on already forms ranging from some
real toy stuff to something real serious
so we really hope to see like tons of
new languages coming to the web and in
the near future and this is kind of like
the the the obvious thing you just
compile something offline and then run
it but one important goal for
webassembly also is to be even more
versatile so that you can support
platforms like say the JVM or dotnet
that actually use JIT compilation
themselves right so that you can
implement bills on top of what
webassembly does so there are some
implementation efforts already being
started in that direction but we don't
have any real executable experience with
that right now just pointing out that
this was also a design goal to support
that yeah so this all flows into this
overarching goal that this is really
supposed to be a language in you
and formant so yeah producing
webassembly the the other side the
engine briefly getting back to that is
the what we call the consumer web
assembly and right now our main consumer
is are the engines in in web browsers so
yes been mentioned this is part of the
web platform it's and embedded into
JavaScript but this is kind of only the
first wave as far as we see we really we
are really looking forward to other
embeddings and again there are already
people working on things like that so
standalone implementations of WebP
assembly that you could use to I don't
know write your own programming language
in a in a fairly simple way you just
have a runtime they're already like
people who use the JVM for example to
implement other languages and this would
be completely independent of the web or
even JavaScript right you don't need
Java Script flow and then there are also
people working on embedding it in other
environments like so there there's their
efforts to do some blockchain stuff with
that where you can put web assembly code
on the blockchain like aetherium they
are thinking about moving to to
webassembly it's neckhold format i
talked to some guys on docker they might
they consider using it as their send
boxing code format internally and so on
and so forth there's a lot of stuff to
to expect yeah and this is goals into
the goal that it's really platforming
so there are producers consumers and the
contract between the two is the web
assembly specification and I want to
briefly talk about that because it is
somewhat remarkable there are actually
two things that are remarkable about
webassembly the first is that as far as
we know it's the first time that's a
technology like that was really designed
in collaboration between all the major
browser vendors I think that was is
completely nolan hasn't happened before
and it was a very successful
collaboration the other way in which web
assembly is remarkable from our
perspective is
the way the rigger the way it's
rigorously specified so we really wanted
to set a new bar in terms of industrial
language specifications so that means
particularly that webassembly the
official language specification comes
with a complete formalized semantics so
and to explain what that means I have to
do my one minute rant about the poor
state of mainstream programming
languages so I mean probably all of you
know how to read a BNF grammar right so
BNF grammars were invented with Algol 60
so it's like 60 years old way to
formally specify student acts but for
for semantics basically we're still
stuck in the same decade like the way
industrial languages are specified is
still the same way they were specified
60 years ago at least when it comes to
industrial languages and this is pretty
sad because actually at least in in
research and everywhere we know how to
do that right for at least 30 or 4 years
but it has never been adapted and so we
wanted really we really wanted to change
this game and use the state-of-the-art
standard techniques that are really
standard in research everybody used them
there and employ them here and this one
outcome of this is that you when you do
this in lockstep with the whole design
and the formal specification you
actually arrive at a much cleaner and
simpler design it's not just formalized
on paper we actually have a machine
verified version of this formulation and
that we have put into a theory improver
and this theorem and we have proof that
the the whole validation provides us
with a subtype silence result that
there's no undefined behavior and
webassembly
that the sandbox is safe and all these
are results that are machine verified so
just want to flesh this at you very
briefly so this is from the paper again
which I already mentioned
just to make the point how clean and
simple it is so don't worry if you can't
read this and it's small anyway but this
is the entire execution semantics of web
assembly it's one page in normal
notation in a standard notation called
structural operational semantics so
these are reductions don't worry about
what they mean it's just and as a user
you probably never have to read them but
it's to make the point that it can
actually be done and it leads to
something very clean and similarly this
is our the typing rules which specify
completely specified validation for Wepa
so it's not even a full page and you
might be a slightly more impressed by
this if you if you're aware that the
specification of bytecode verification
for the JVM for example takes a hundred
sixty pages just keep that in mind okay
so this was about where web assembly is
where we came from and I want to spend
the rest of my talk how much time do I
have left okay yeah I don't think I need
to say a little bit about where we're
going next with web assembly what's
what's coming down the road and there
are various things we are working on one
obviously is improving performance which
is natural we also want to improve tools
support obviously so right now it's like
very basic right I mean you always start
out with something very basic and the
more people are starting to use it the
more pressure there will be to have
better it's I'm pretty sure and then I
already mentioned that we're looking
forward to seeing more languages and
more more platforms or embeddings and
probably the last last group of things
is more features inside web assembly
itself and the other the other four I
kind of we already went through and I
mentioned in the talk before so I will
focus on the last point here for the
rest my presentation so what are the
future features there are there a couple
of proposal
that are in the making for wepa sembly
at different stages so we have a whole
process of how we do proposals and you
have to write it up as text and then you
have to write up the semantics in more
detail at some point you actually have
to write up the formal semantics and you
have to implement it in our reference
interpreter so we also have a reference
interpreter that is written in you know
camel and you have to write tests that
this interpreter can run and all that so
there's a whole list of things you have
to do for proposal and there are
different stages in this in this process
so one proposal that's already pretty
far along is support for threats and
that actually doesn't for at least for
now doesn't mean that you can spawn
threats within webassembly itself but it
means that a webassembly
instance can be entered from different
threats and can communicate through
shared memory so the main feature that
this is adding here is primitives for
atomic access to the to the linear
memory and that is important in
particular for for people compiling
their C++ code base to web assembly
because that's the only way for them to
Emily @p threats and everybody uses P
threats for games for example to to
provide parallelism so this is really
important and I think this will should
be shipping relatively soon another
feature also important kind of for
compiling C++ at least if you're
compiling C++ with exception handling is
more efficient support for exceptions
right now it's actually the way you
compile this C++ with exceptions to web
assembly is you have to call back into
JavaScript to that do a handler there
and it's like really it's it's horrible
so obviously we don't want that but it's
a bit more tricky to the design and
exception mechanism in web assembly
because it has to remain safe and it has
to mean remain safe even across
different languages that are compiled
into it and that don't understand how
each other is using exceptions right so
there there are some things that you
have to be careful
next one is sim D so Cindy is something
that all modern CPUs provided it stands
for single instruction multiple data so
these are vector instructions basically
that can manipulate a whole vector of
numbers at one time and when you want to
reach like the last 10% of performance
for a computation intensive application
then you want to have access to two
simony capabilities yourself Europe if
your machine so this is just adding a
whole zoo of instructions that are
individually not particularly
interesting but yeah and then one kind
of thing along several things here
together is better support in general
for more high-level languages so the
initial design goal for web assembly we
explicitly cut it down to okay for
version 100 we want to support C++ well
but it was always a goal that after that
we want to broaden the support for more
high level languages and that means
having all sorts of features that maybe
C++ doesn't really need or make much use
of but other languages might for example
tail calls in particular or the ability
to not return multiple values from a
function and so on and so forth and this
is also not just to support certain
languages directly but it also can
support certain compilation techniques
like I mentioned earlier that we want to
support platforms running on top of web
assembly that use for example
themselves or imagine you want to
implement a dynamic language like
JavaScript maybe even met some some
point in the future that uses all sorts
of techniques to dynamically generate
code and stuff and for some of these you
need things like tail bolts for example
to make that efficient so there's also
like a compilation technique and then a
big one which is probably further out is
really
let's phrase it as a support for garbage
collection way
so Ben doesn't like that term so as Ben
showed you right now you only have this
like four data types right this like
super primitive you have to emulate
everything yourself in an in your memory
and so if you wanted to compile a
garbage collect language to to
webassembly you can do that but you have
to ship it with your own runtime system
your own garbage collector and which is
probably not gonna be super fast because
this is kind of the use case where you
pay most for the overhead that
webassembly has and it's kind of crazy
too I mean at least on the web you're
already running in this engine that has
this super tuned highly performant
garbage collector right that has like
100 men years of work that went into it
so you should really be able to just use
that and the idea here is that we had
new ways for defining basically struct
types in web assembly that you can just
create a value of and this value will be
allocated on se but the JavaScript heat
actually and then it will just be
garbage collector when the last
reference to it goes away so this is
still supposed to be a fairly low-level
mechanism so not like a heavyweight
object model like you would have in the
JVM or an ad but really just basically
tuples of values you can allocate it or
raise and then every language that wants
to use it has to map its own object
model into these data structures but
still it provides the convenience and
the performance of built-in garbage
collection yeah another part of that is
that the first item there is the ability
to actually use passed in references
from the host environment like on the
web Dom objects for example into
JavaScript right now you can't do that
right you only have numbers so what you
have to do right now if you want to
interface with the Dom you have to build
some by ejection on the boundary that
map's the objects you want to manipulate
to some numbers that you use internally
to identify them and then you have to
worry about like how do you the the
cross boundary garbage collection all
that so this is pretty yeah it's not
very nice
so with if you have garbage collection
inside webassembly itself it could just
pass in references and the last point
item here is we want to have better
support for host bindings so right now
yeah you have a web assembly function
you can export it well you can only take
numbers as arguments right so if you
want to interface with JavaScript this
type doesn't even tell you whether these
numbers are supposed to be interpreted
as signed or unsigned so what we want to
add is some description and notation
language in the binary format like a new
custom section basically that describes
some binding mechanism to JavaScript in
this case where it says how the values
are converted between JavaScript and
mathiesen and this also gives you a way
to deal with strings for example the
only way to pass in strings right now is
you have to somehow expose the linear
memory of webassembly to JavaScript and
then copy bytes into it because there
are no string objects right and this
could all be taken care of more or less
automatically by by this binding layer
right so that's roughly it brief summary
what's the point of this all this yeah
mention it it's it's supposed to be a
new code format with all the nice
properties we have it already runs in
all the browsers and probably beyond in
the future actually there are even more
browsers it's running in I know that
it's already available in opera as well
because that's just based on chromium
and some other browser process based on
chromium yeah and we made a point of
making this design and its whole
specification and the whole proposal
evolution process really really rigorous
much more rigorous than anything you've
seen so far in industrial languages so
hopefully this opens up a whole new
world of things you can do on the web
including breaking it and yeah so
there's a web page too if you want to
look up more information
okay thank you so I got a few questions
well some of them are around is it
already production ready can I use it in
enterprise development and what about
versions do we have to expect some
issues with different versions of
assembly maybe say something about that
sure yeah we consider this to be we
shipped it in stable Chrome we should
it's been shipped in stable Firefox so
yeah you can use it in enterprise apps
and people are compiling huge engine so
the epic engine which is like something
like 200 megabytes has already been
compiled a web assembly and people are
shipping stuff that makes money with web
assembly and it was what about versions
different versions and finally
compatibility yeah so one design goal
was actually to make the binary format
forward compatible so the idea is we we
have a Persian flag in there but the
idea is that we never have to bump it
and so this is really just an escape
hatch so anything we want to add we add
in the future it should be backwards
compatible so just adding new things
that were just enveloped before and then
you could use some form of feature
detection like you use in JavaScript as
well to find out whether your browser
already supports that so you can one way
you can do that is you just generally
like a tiny little module that uses the
feature you want and then you call in
the JavaScript API there's a validate
function for example you just try to
validate it on the browser and if it
says yes then you can use it and it says
no then you have to fall back to
something else okay then quite a lot of
questions regarding which languages will
be supported are supported and so on I
also see a few questions about whether
Java will be supported do you know any
Java project that tries to compile Java
to vapor sembly currently no we don't
know about anybody that's using Java
with webassembly
so about in general because web assembly
is a machine
it's there's this implicit or explicit
separation between what languages run on
top and what the what the engine is
specified so we've completed the
implementation of the engine so as long
as you can generate bytecode which
conforms to that spec then any language
will run as far as the reality of what
languages runs C and C++ run by using in
script in rust has essentially a beta
back in for that assembly script is more
like a more like a layer on top of web
assembly other languages are coming I
think specifically for Java is probably
gonna require the managed objects
proposal so that's probably a couple
years out but as you saw web assembly is
a low-level machine in order to bring a
high-level language you have to compile
the high-level language away or compile
part of it to JavaScript for example how
does it relate to LLVM you can consider
web assembly to be a portable binary
format so as was mentioned pinnacle was
a I was a Google Google technology that
uses LVM bit code as a transportation
format you can consider web assembly to
be as sort of the delivery of that
promise LVM is a compiler framework but
it also has like it has a bit code
format that you can use for various
purposes okay and one was one question
was there is there already something
like no GS or for Mac assembly said one
of the platform levels and compiling
JavaScript to web simply right or you
mean support in node.js for web assembly
probably yeah so I think the current
node.js version is on what what v8
version as soon as it reaches the right
v8 version it will be there implicitly
all right I mean I think it's already is
I don't know exactly what we agree yeah
I think the latest node has already
shipped the 5.8 which included web
assembly by default so yeah okay so it's
anchors any other questions which are
not on here okay then thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>