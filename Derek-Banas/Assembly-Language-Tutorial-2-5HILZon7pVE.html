<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Assembly Language Tutorial 2 | Coder Coacher - Coaching Coders</title><meta content="Assembly Language Tutorial 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Assembly Language Tutorial 2</b></h2><h5 class="post__date">2016-05-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5HILZon7pVE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
2 of my assembly language video tutorial
in this part of the tutorial we're going
to cover logical operators looping
barrel shifting memory storage and
debugging and unlike the first part of
the tutorial this time we're going to
pretty much only be writing a lot of
code however if you didn't watch part
one you should definitely watch it and I
provide a link here in the video as well
as in the description also in the
description you're going to find a link
to a transcript as well as all of the
codes so what the best way to learn this
stuff is to go and get this transcript
it's free of course and there's a link
in the description and then you can use
this as a cheat sheet to go through and
also to take notes on so you can better
remember all of the stuff's here
and as well write down any questions you
have and leave them in the comments
below so I have a lot to do so let's get
into it ok so here we are in our
raspberry pi once again and we're going
to be using the same exact file assembly
tut s and here we are inside of them
um as this tutorial continues I'm going
to show you a little neat tricks you can
use to do things with them and one of
them is if you wanted to delete
everything that you have inside here
just to escape and then : and then
you're going to hit % d and hit enter
and there you can see everything is gone
and I'm going to undo that by hitting
you and everything's back again so let's
go through here and let's start writing
a little bit of code what I'm going to
do here now is talk about logical
operators so we're going to actually be
writing some real code here that's going
to be more useful and it's going to
start to look more like regular programs
now my logical operators going to follow
a format in which you're going to have
some type of instruction and then after
that you're going to have your
destination where the result is going to
go to and you're in a coma and then
you're going to have an operand inside
of here and then you're going to comma
and then you're going to have another
operand so let's go through and do a
couple examples and all of this will
make a lot of sense so down here inside
of start I'm going to escape out of this
and I'm going to hit capital letter V
and then I'm going to select those lines
by pressing down on the arrow keys and
then I'm going to delete them because
I'm
do some new stuff now I'm in insert mode
again and the first thing I'm going to
do is move into register 1 the value of
5 and I'm going to put a comment inside
of this and this is going to represent
this binary number and you need to see
that so that you understand what's going
on here with this conditional operator
we're first going to cover and and and
just is going to only give you a result
of 1 if both of the values are equal to
1 so and in register 2 I'm going to go
and give this a value of 9 which is
going to be equivalent to 1001 or
whatever you see right there and now
we'll use and so we're going to go and
our 0 this is going to be our
destination our 1 is going to be an
operand or 2 is going to be another
operand let's get rid of this stuff
escape capital V and D and that's all
gone and then we'll hit escape : WQ now
we'll go make and you can see this has
been assembled and then we can echo out
onto the screen the value of 1 now why
did u we get the result that we got
right there let's jump in here and look
you can see right here we have 1 and 1
that's going to give us a value of 1 you
can see 0 + 0 is going to give us a 0 1
and 0 is going to give us a 0 and 0 and
1 are going to give us a 0 and that's
the reason why whenever we use the
conditional operator and we get a value
of 1 so now let's come in here and we're
not going to change that much we'll just
come in and change instead of using and
this time we're going to use or which is
another conditional operator and it's
Orr and as I'm sure you're probably
aware 1 + 1 is going to give us a value
of 1 0 + 0 is going to give us a value
of 0 this is going to give us 1 and this
is going to give us 1 and you're going
to see that that's going to work out to
13 so let's escape out of that make
again and there you can see the value of
13 comes back once again and that's how
the or conditional operator works now
we'll use the exclusive or operator
again just come in here insert rid of
that that's an exclusive or nothing else
is going to change basically here we're
going to get a value of 0 here and we're
going to get a value of 0 here and here
we're going to get a value of 1 and 1
and of course that's going to equal out
to the value of 12 so if it's 1 1 0 0
that comes out to 1/2
going to work for us then we got four
and eight whenever you add four and
eight together you get a value of twelve
do another make and echo and you can see
twelve shows up you clear our scroll
back but I type again clear and there we
are and now I'm going to give you a real
world example I'm going to use what is
called the bit clear conditional
operator or B I see so let's jump over
inside of M once again open that up and
we'll do a quick example and then we'll
do a much more elaborate example just to
make this a little bit more interesting
so bi c stands for bit clear and
basically it's going to return a zero
except when the top bit is a 1 and the
bottom bit is equal to 0 and like I said
I'll show you an example here where that
actually is useful so it's going to
return 0 except when the top bit is 1 so
here we got one right there and the
bottom bit is 0 so this will end up
being a 0 this window being a 1 this
will be a 0 and this will be a 0 and if
we think about what that works out to be
that's 1 2 and 4 and this is going to
give us a value of 4 we don't worry
go and execute this and let's execute it
and you can see indeed that it came back
that way so now let's jump into pham
again and let's write a more elaborate
program basically what we want to do
here is we want to receive a lower case
value and convert it into uppercase so
let's come in and let's delete a whole
bunch of different things first thing I
want to do is to be able to read
information from our keyboard so we're
going to be doing a lot of reviewing
here and to do so we have to set our
system call to read from the keyboard
and we set our 7 to 3 now let's come in
and write some stuff system call
keyboard and then we'll go down and set
the registers 0 to 0 and this is saying
input stream is our keyboard in register
2 we're going to set that to a value of
1 and we're going to say that we want to
read one character after you do this
enough that'll just stick to your head
then we want to read in our address for
our character where we're going to be
storing this information so LDR and I'll
store that in r1 because that's not
being used
we're going to get something called
character and then we will close this
off I'm going s WI and zero bounce down
inside of here and in our data section
we're going to define character and :
and we're going to say this is going to
be an ASCII and we're just going to give
it just nothing between these two quotes
let's back up inside here do a little
bit more stuff find another label this
is going to be called uppercase we're
going to get the address for our
character and then we're going to load
our character into the zero register of
course we're going to put brackets
around this and then basically what we
want to do here is we want to zero out
our sixth bit and I'll explain exactly
why that is so if we have let's put a
comment inside here so if we have a
lowercase a that is going to have a
value of zero one one zero zero zero one
like that on the other hand if we have a
uppercase value for a that is going to
have a value of 0 1 0 0 and 0 0 0 1 so
now if we look at this very closely you
can see right here the only difference
between a lowercase a and an uppercase a
is this bit right here so if we want to
take in a lowercase value and convert it
into an uppercase value all we need to
do is get rid of that guy right there
and so to do so we want to use the bit
clear with a value of 32 so all we going
to do is go 0 0 1 0 and then 0 0 0 0 so
it's going to keep all of our ones
inside of here
it's going to let those all be set and
any bits that we want to get rid of it's
going to get rid of and you can see
there we're only going to get rid of one
of them and to do that operation it's
actually quite easy all we're going to
do is go bi c
and we're our 0 or 0 and the number 32
why 32 1 2 4 8 16 32 that's the one
we're getting rid of ok and after we do
that we can come in here and store the
character with the address stored in r1
inside of our 0 so we'll go string and
r0 and we're going to put the value of R
0 and
the address for our one okay so that's
all well enough let's come in here now
and let's output information to our
screen we'll use right once again we
just have to set our registers properly
so that we will be able to come out here
and output information to the screen so
we're going to have to make our system
call once again store the value of four
and this is just system call output to
screen set our zero register equal to 1
and here define our output as our
monitor once again we'll set register 2
to the value of 1 and this is defining
the number of characters since role
we're doing is converting from lowercase
into uppercase that's just going to be 1
character and then we define the value
that we want to print out which is going
to be character and then we can close
that off then we come out of here and
you can see there's end we set our 7
just like we always do we close that off
of course we have our information that's
going to be stored inside the character
and that's all we need to do so we're
going to escape here we're not going to
be using echo we're just going to be
using assembly tuck because it's
expecting input from us hit enter and
let's just do any character there's D
hit enter and you can see the capital D
comes back come back run it again ok and
you can see the uppercase K comes back
and there is more of a real-world
example of how we can use conditional
operators and of course as the tutorial
continues we're going to find even more
ways we can use them now I'm going to
show you another one and this is called
test bits and what this is going to do
is perform an end on bits and then
update r0 flag which we talked about
previously
once again the CPS R is going to store
or 0 flag inside of here so we're just
going to be able to come in there and
test for a whole bunch of different
things and as the tutorial continues
we're going to be using these registers
a lot more let's come in and let's open
up vim again and show you an example
exactly how that's going to work for us
let's just go in here and copy out of
this and hit % indeed to clear
everything out and let's just start
fresh so global start and then define
start throw some in from
in in register one and once again let's
go and throw inside here the value of
nine and then we'll show an example of
what exactly is going on and in register
two we're going to throw in a value of
eight and then we'll use TST to show you
how this is working so we'll go r1 and
r2 and this is going to compare those
values and set our flags then what we're
going to do is we're going to say if
these values are equal we want to jump
to our label and that label is going to
be called bit set remember what this is
going to do for us is subtract eight
from nine and then set those flags and
we'll be able to check them otherwise
we're going to store the value of one
inside of register zero and then skip
out of this by calling end now we know
those aren't equal so we're not going to
get the bit sets but let's define it
anyway so the value of zero
inside of our zero so we'll be able to
see the results we know we're going to
get one back here of course though and
then close out of our program and open
up the terminal this time we want to
echo information out on the screen and
of course we can expect a value of one
to show up because those two values are
not equal and if we hit enter you can
indeed see that that indeed is true the
thing you can do is there's another
conditional operator called teq and this
is your homework and this is basically
called test equivalence and what it's
going to do is perform a exclusive or on
bits and then update the zero flags
there's your homework figure out how to
use test equivalence or teq to come in
and check if two values inside of
registers are equal or not ok so there's
an overview of some conditional
operators now we're going to get into
some more interesting stuff we're going
to cover looping let's come in vim again
now basically looping in other languages
is going to follow this basic format so
you're going to have let's say you
wanted to loop to the value of 10 you're
going to come in here and you're going
to need to define a first value which is
going to be equal to zero and you're
going to define another one that's going
to start off with a starting value of 1
and then you're going to come in and say
something like while r0 is less than or
equal to 10
well then you want to come in
here and continue to increment the value
of or zero so you're going to go our
zero is equal to or zero plus one and
that's what I'm going to show you how to
do here now with assembler so here we
have Global's start again and we're
going to come down inside of the start
area let's come in here and delete some
of this escape capital V now inside of
start we're going to do basically the
same exact thing we're going to go into
our zero and we're going to give that
the value of zero and then we're going
to do the same exact thing here with r1
and then we're going to come in and
we're going to say that we want to jump
to a label called continue loop then we
need to increment this and we're going
to call this guide loop and I'm just
going to use add of course so I'm going
to go our zero then we need to define
continue loop here we'll do a comparison
which is just a subtraction so we're
going to subtract from our zero the
value of nine then we want to check if
it's less than or equal to meaning if
the value inside of register zero is
less than or equal to nine and if so
we're going to jump back to loop and
then we're going to add or increment the
value inside register zero we're going
to continue doing that over and over
again until we reach a point in which
the value stored in register zero is
greater than the value of nine so we're
doing exactly the same thing there that
we did right here and if you look at it
you can see that both of those are quite
similar the way they look and we have
that value stored inside of there and if
we execute this guy then we should be
able to come out here and then get a
final value of ten and if we come in
make that and then run it you can see
that's indeed what we did so there's a
really simple loop just to get you used
to loops once again go in there
experiment see what other things you can
do of course in the next part of the
tutorial we're going to cover functions
and very very soon we're going to be
making some real-world programs just
wanted to ease you in though into how we
would loop and give you a little bit of
an idea of how we would translate from a
language like Python into assembly code
and how those two things mix up so now
we're going to take a look at
conditional codes now here you can see a
whole list of conditional codes now
basically what this is going to allow
you to do is to define if an instruction
is going to be executed based off of
condition
and these are all the different
conditions you have here don't try to
memorize this there's no point and
what's neat about it is you're going to
be able to do this by just ending at
most any of these instructions with
either of these codes that you have here
what you want to check for so I'm going
to show you here an example of exactly
how these work out what I'm going to do
here now is I'm going to show you in
Python how we would increment what value
that is stored in register 0 until it is
equal to a value that is stored in
register 1 and then we can show you the
assembly language it's going to go along
with that so let's say we come in here
and we want to say for the variable R 0
we want to store a value of 50 inside of
it and in R 1 we want to store a value
of 2 inside of it then we would continue
cycling through this guy as long as R
whatever the value is inside of R 0 is
greater than whatever we have inside of
R 1 and then we would come down inside
of here and instead we would come in and
go R 0 and say that we want to decrement
that over and over again until this
condition is no longer true by a value
of 2 now how exactly would we do that in
assembly I do it in much the same way
come in to start we're going to go
inside of our 0 and we're going to
change this to 50 we're going to change
this to 2 and then we're going to call
function called loop or label called
loop then going to command create and
another one and this is going to
decrement so here what we don't want to
do is we want to do a subtraction but
what we are really saying here is if R 0
or the value stored inside of register 0
is greater than R 1 we want to then
subtract 2 so we built the condition
directly inside of the instruction that
we're giving and there we go now down
inside of the loop structure we can then
do a comparison between those two values
by doing a subtraction or 0 and R 1 then
basically we're going to say if they are
not equal we want to continue
decrementing and to do that is to say
branch if not equal that's what we're
saying right there then we want to call
the decrement label and of course what's
coming and
get rid of the continued loop again
because I would cause a catastrophe and
there you can see it went and
decremented the value of 50 until it got
to the value of 2 for whatever was in
register 0 and once it did that it
exited completely out of there so go in
there and experiment running these other
different instructions that you know by
using these conditional codes and see
what else you can come up with like I
said as the drawer continues I'm going
to continue to add on to this knowledge
but I'm just in the beginning stages
here and a lot of it experimentation is
going to go a long way on your report so
let's take a look at the barrel shifter
basically the barrel shifter is going to
make it very easy for us to move bits
left and right which is going to make it
very easy for us to multiply and divide
values first guy we're going to talk
about here is what's called LS L or the
logical shift left and like I said it's
going to shift all our bits left and
move the highest bit into the carry flag
and with it it's going to be very easy
for us to multiply it times two so let's
come in and let's get to start and
inside of register 1 we're going to give
that a value of 15 which is going to be
equivalent to 1 1 1 1 1 and then inside
of register 0 we'll move the value of r1
but shifted to the left by 1 so what
this is basically saying is we want to
shift the value inside of r1 one bit and
then save it inside register 0 capital V
get rid of all this stuff do a make and
you can pause the video here for a
second to see if you can guess what the
results going to be and there you can
see the result comes back as 30 and why
is that well if you take the value of 1
plus 2 plus 4 plus 8 plus 16 that's
going to give you a value of 31 and then
like I said before whenever it does a
logical shift left it is going to zero
out the rightmost digit in binary and
that's the value of 1 so it comes out to
31 minus 1 which equals 30 hopefully you
got that answer or that little question
right and now let's take a look at the
logical shift right now this is the LSR
command and it's going to shift all our
bits right and then move the lowest bit
into the carry flag and this is going to
make it very easy for us to do divisions
by 2 and it's
going to work in much the same way so
we'll come down here and in register one
we're going to store 15 do exactly the
same stuff here except in this situation
we're going to come in and change this
to LS or 1 and this is going to shift
the value in our 1 1 bit right and then
save that into our 7 and then save that
into register 0 so we're giving it a
value of 15 and we're going to escape
out of this and while I do this you can
take a wild guess at what the answer is
going to be it's a little bit tricky you
might not get it that's ok come in here
hit enter it's going to give you a value
7 so it's going to take 15 and it's
divided by 2 which is going to give us a
value of 7 and a half and then it's
going to get rid of that fraction so
that's a little introduction into
shifting and we're going to get a lot
more into that as the tutorial continues
and now we're going to get into
something a lot more interesting which
is called
memory storage now basically if we have
been storing data and registers for the
most part but now we're going to be able
to store it in memory and we're going to
store data by referring to that that is
address in memory like we have been
doing on and off here but now we're
going to get into the meat of it so
basically we're going to be storing an
address in a register and then use that
register to load as well as store data
and the labels we have used are going to
be addresses that are going to refer to
code but we're also going to be able to
use them to refer to data so let's come
in here and let's open up them once
again and the very first thing we're
going to do is we're going to come in
here and we're going to create two for
byte variables and give them values so
we're going to be putting data in first
so we have to put the data block inside
of here
and we're going to say that we want to
request 4 bytes for our data and be
aligned does just that we are then going
to give it the name of 15 I'm going to
say that this is a word and we want to
start off by giving it the value of 15
so we're assigning 15 to 15 then do
another beeline for 4 and now we're
going to be storing 30 or 30 yeah 30
inside here once again this is going to
be a word and it's going to start off
with a value of 30 now we're getting
into the assembly language part of our
code here so we're going to type in
next global start start we're then going
to have to come down here at the very
end of it and provide labels for the
addresses in our data section and to do
so we'll just call this address it
doesn't matter what you call this is
just what I'm calling it so I'm going to
call it address 15 and this is a word
lined up with 15 and then we're going to
do exactly the same thing with 30 once
again
word and 30 and then come back up inside
of the start area and if we want to load
our address we just go lb rr1 refer to
address 15 if we then want to come in
here and load data using our address we
can go our 1 and get that information
from our 1 LDR again register to load
our address and load the data using the
address or two and then we'll be able to
come in here and add this just to make
sure that it works so in register 0 we
will store the addition of the values
that are in R 1 and R 2 and as always
the way that it was jump out of there do
a make and there you can see as your
result is 45 let's go and do a little
bit more here with storing information
inside of memory we're going to do a lot
more of this actually as the tutorials
continue it's what we're going to do now
is we're actually going to come in and
load values by referring to the
addresses using another instruction
called STR so here we can keep
everything exactly the same we got all
these all set up exactly the same way
we're going to request four bytes for
our address we're going to define
storage 415 except in this situation
what we're going to do is instead of
having the value of 15 inside of there
we're going to have that be 0 and then
likewise we're going to give this the
value of 0 so we're going to use the
address to store values in those
addresses inside of memory and so to do
so everything else here is going to be
exactly the same we're going to come in
here and we're going to load the address
just like we did previously except in
this situation we're going to put 15
inside of our 3 or it inside register 3
so there's 15 and then like I said we're
going to store the value inside of
register 3 inside of the address that is
going to be stored there so this is how
we load and firm a
out of an address and this is how we
load information into it so we're saying
we want to take the value that is inside
of register to 13 or 15 and store it at
the address in memory that is at r1 and
then likewise we don't need to do any of
this stuff come in here get rid of this
and instead we're going to do a copy
once again capital V select all those
different things and copy is why down
here where we want to paste it and
capital P this time we're going to be
using register two though insert two
this time will you point at the address
for 30 we're going to be storing 30
inside of here of course then we'll take
the value and register there and let's
store it in register 2 and now that we
have that done we can come in here and
add once again or zero or one or two
everything else here is exactly the same
and you're going to see that the result
is exactly the same and that came out of
68 let's go in here and see why that
happened that way oh I see exactly what
happened basically what I did was I
loaded that information inside of there
but I did not then come in and take the
information out so let's come in here
like this now what we're going to need
to do is come in here and basically do
exactly what we did in the last part of
the program sort of copy that if I would
have thought about it so up here what we
did was we went and stored the values
inside of those two different registers
or those two addresses inside a memory
now what we want to do is come in and
add those values together LDR r1 again
we're going to return or refer to those
places in memory and we're going to load
those in first we want to load the
address use a LDR again register one
going to get the value outside of there
and store the value inside register one
once again LDR R to store get that
memory address store it inside of our
two LDR or two and then get the value
that is stored at that address by
putting those brackets around it and now
I'll do an ADD and now it'll work I'm
sure you know what the answer is going
to be once again everything else is
exactly the same and we should get a
value of 45 and we did okay so now that
I showed how easy it is to make a dumb
mistake inside of assembly
or I think I should cover debugging
which is what I'm going to cover next so
what I have here is we saw this
previously oh this is going to do is
start off with a value of 0 it's going
to increment by 1 each time it's going
to continue incrementing over and over
again because we're going to compare
what's in register 0 to the value of 9
and at the point in which what is in
register 0 is going to be greater than
or equal to 10 that's when we're going
to exit our program so we're going to do
here is we're going to step through our
program and we're going to watch exactly
how things are going to change so we got
that saved and let's jump out of here
now whenever you're compiling your
program if you want to debug you're
going to add the QI options so we're
going to go AAS and we're going to go G
and 0 and then everything else is going
to be the same which assembly touch dot
o assembly touch dot s and we're going
to make a make file here in a second and
then you're going to go LD - OH assembly
Tut and assembly tut dot o now you're
going to start the debugger by going gdb
and assembly tut and there you can see
it all started out now you can list the
first 10 lines of your program by just
typing in list and there you can see
print it out the first 10 lines on your
screen and then you're going to be able
to disassemble your code and to do that
you just type in this assemble and let's
say we wanted to start at start and
there you can see exactly it's just
showing you what is assigned to the
start label and if you want to know what
this stuff is right here the first
number is going to be the location in
memory for this instruction and then
right here what you're going to see is
the number of bytes from the beginning
of the label or your functions whenever
we get into functions you're going to
get more into that now by using what are
called breakpoints you're going to be
able to step through your code one line
at a time and see how register and flag
values are going to change
so let's come back here now let's do
list again and you can see all these
different guys now let's say that we
wanted to set a breakpoint right here at
this looping part we could do so by just
typing in B and 13 for line 13 we could
all
so delete a breakpoint by typing in
delete 13 but we're not going to do that
right now and then we're going to type
in run and we're going to see exactly
how everything is going to change as we
cycle through this now after typing in
run we're going to go info R and this is
going to return all of our current
register values at that point inside of
our program and you can see exactly how
everything changed
basically r0 starts off at 0 that's the
way we set it so it has a value of 0 and
r1 is going to have a value of 1 you can
see down here at the stack pointer that
this is going to point to the stack
inside of our memory and then you could
also see down here in PC see right there
where it has continued loop this is
going to store the next instruction
we're going to execute so you can sit
literally sit here and just watch all of
these different things move around in
all these different registers which is
really kind of neat now if you want to
see how things are going to change what
you got to do is just type in continue
and it's going to cycle through again
too until it hits the next breakpoint so
you know all these register values so
we'll hit continue and then we'll type
in info R again and now you can see that
the value for register one has
incremented to one you can also notice
here if you look down in the CPS R this
guy right here has a value of 8 and what
that tells us is the negative flag has
been set and the reason that was set is
because compare what was in register 0
to 9 in the top flag in that situation
is going to be equal to 8 and if we
bounce over here you can see that say 1
2 4 8 substance it had a value of 8 and
then will you know indeed that this
negative flag has been set now of course
if you want to quit out of this and you
can continue cycling through it just by
hitting continue over and over again and
info R to watch everything change and
you could set multiple different break
points as well I'm going to quit out of
that by typing in quit but I'm also
going to come in here and change my make
file so it's a little bit easier to
debug and we're going to be debugging
more as the tutorial continues so what
I'm going to do here is I'm going to
come in and say debug and remember we're
going to type in a tab after this then
we'll go a s.g oh and I'm going to do
assembly touch tab in again LD don't
forget that tab and assembly
Tutt and then we could actually run the
debugger also so gdb Assembly Tut and
escape out of that and do that and now
what we'll be able to do is just go make
debug and it's going to automatically
open up the debugger okay like I said
just a brief overview of debugging if
you want to learn more about it just
experiment with it watch the different
register values change for all the code
we've covered in this tutorial in the
previous tutorial and you'll learn a lot
more about how things are moving around
inside of the registers and as the last
part of the tutorial what I want to do
is get back into memory storage and do a
couple more complicated types of
examples here so let's go in to them
once again now of course having a good
understanding on how to use memory to
store information is going to be very
very important because we want to keep
our registers clear so we'll be able to
perform our operations and then store
data outside inside of memory but to be
able to do so we're going to have to be
very careful in regards to how we store
data in memory what I want to do now is
cover a TR and basically the directive a
TR is going to load a 32 bit address by
passing in a label so I'm going to go r0
and info let's go and create that and
basically it's just going to load the
address for the data inside of register
0 then we come down here after end and
let's just type in info and word and
give it a value of 10 and you're going
to see all this is going to do is just
load this value of 10 into register 0
and then output that on the screen but
we're going to use the debugger just
look at this very specifically so we're
going to save that and we're going to
say make debug now we can put a
breakpoint well let's go do a list see
exactly what we got here now let's say
we want to see exactly what's going on
here register wise whenever we get to
line 6 inside of here so we're going to
throw a breakpoint at B 6 and then we're
going to go info R of course we have to
type in run first and then info R and
there you can see right here that we
indeed have the address stored inside of
this guy inside of register 0 but what's
interesting is let's say that we wanted
to come in here and examine for words
worth of data starting at the address
force
we could do that inside of our debugger
and to do so we would just type in X and
then four words and then underscore
start and you can see all these
different guys and also what you can see
is the ten value that we had right there
let's quit out of that back inside of
them and basically what we're going to
do is we're going to read data using LDR
and write it using STR like we saw
earlier in the tutorial and to do so
you're going to hold the address for the
information in memory inside of a
register so let's come in here get rid
of this guy and let's say we want to
load the address for the data into our
are three register we would just type in
LDR are three equal to info and then we
can get the value stored in that address
by going LDR store this in register 0 by
just putting these brackets around it
like that
WQ make and run it and echo and you can
see the 10 comes out there it is however
very important that whenever we're
messing around inside a memory that we
request enough space to allow for
changes in values and if you do not do
that you're going to get what's called a
segmentation fault
so let's come in here and let's create
another one of these guys and we'll
create a data section here at the top
and we're going to say that we want to
request four bytes for our address and
then go info because we're going to be
changing the value here so we got info
this is going to define the storage for
info word and 10 is going to be the
value that we want to assign to this guy
since we have data up there we're going
to have to say text so that we know
where our assembly code is going to
start then we'll come down here into the
start label part once again we're going
to load the address for the data into
our r3 or our third register then after
we do that we want to come in and let's
say throw the value of 100 into register
4 then we can come and move 100 into the
address space inside of memory so we'll
go get the value that's stored in
register 4 and store it in register 3
and then once again load the data that
is stored
register three back into register zero
you know we don't need this guy down
here this would cause confusion actually
if we kept this here and there you can
see that we were able to store 100
inside of there so that's how we were
able to go in and find a location in
memory and then store information inside
of it but make sure that you make sure
you have enough space whenever you were
writing that code otherwise like I said
before you're gonna get a segmentation
fault now another thing is going to be
really interesting is we're going to be
able to retrieve the next piece of data
in a list by adding or subtracting
values from a target address now with
something called pre indexed addressing
you're going to be able to provide the
base address and then the offset to the
next value and I'm going to show you
exactly how that works so let's say we
have data inside of here again and just
get rid of this what we're going to do
here is create a list and it's going to
have Prime's inside of it and I'm going
to go word to word three word five and
word seven text is all fun now we want
to come in through here and cycle
through all this information so what
we're going to do the first time is we
are going to load the address for the
data into r3 but again this is going to
change to primes
because that's the address we're loading
from and now we can do a couple
different things here so let's go rid of
this and I'm going to put this as a
comment you can go through and test
these but basically if I would type in
LDR r0 and load in r3
this is going to get the value that is
assigned at the address we could however
come in here and get the next item
inside of our list by going LDR and load
this in register 0 and then type in that
address followed by a comma and then a 4
because remember we're restoring words
inside of there and then this one will
actually just grab it this situation
we're going to come in and grab the next
item inside of our list just to show you
how that works and to grab the next it's
going to be a multiple of 4 which is
going to give us a value of 8 and
remember these prime numbers here 2 3 5
7
take a guess which one's going to show
up they've been mate and there you can
see 5 showed up let's jump back over
there just to make sure there you can
see 2 3 5 so this guy right here
is going to give us the value of two the
next one's going to give us a value of
three and five and then you can take a
wild guess at what number you're going
to have to put in here to get the next
value so that's how we can work with
lists of different information that's
stored inside of assembly as well and of
course there's going to be other things
and then the next part of the tutorial
I'm going to talk about something called
the stack another thing it's kind of
interesting is we're also going to be
able to come in and read and write bytes
of information using another instruction
called LDR b b 4 bytes so let's go in
here to our data section again and just
change this up a little bit yeah let's
put this at the bottom just to do
something different so I'm going to do
now is go down into our data section and
define numbers and this time we're going
to be working with bytes and this is
just going to be a list of numbers you
can also work with half words by the way
so to work with a half word instead of
typing in byte inside of there you would
type in h wo rd so there's more homework
give that a try now how this would
change is we can go up here to our three
and of course we're going to come in and
change this to numbers because that's
what we're working with now however if
we want to come in here and grab the
next one in the order here we would type
in LDR B this is going to load the first
byte or the very first number whatever
you want to refer to it again B this is
going to load the next one inside of
there except this is going to be changed
into a 1 and then this one here is going
to load in the next one or two so what
we're going to show on a screen take a
while guess which one of these values is
going to show up let's save it and we'll
see if we're right and there's 3 so
that's how we were able to read in
different lists of information kind of
useful kind of neat now you're also
going to be able to come in here and for
our final example I'm gonna show you how
to load multiple words in registers
using block transfer back in vim here
when we use ADR just like we did
previously just cycling all that stuff
delete that out of there
insert to do this properly however we're
going to have to come in and enforce our
two byte alignment so I'm going to go
dot inline to leave this be numbers and
let's change this to words instead so
there's word and we'll just have this be
1 2 3 &amp;amp; 4 and then up inside a start
we're going to go ad R and we want to
get our address by passing numbers
inside of there but then we're going to
do a block transfer what it's going to
do is it's going to take all four of
these values we have right here and then
store them in the registers R 5 the
whole way through
r 8 it's going to do that on one line of
code what you do is go LD m.i.a
R 3 which is going to point at the
address we're going to load the
information from and then we're going to
say we want it in register 5 the whole
way through register 8 and then just to
show that that was able to output a
information properly inside of register
0 we're going to store whatever is in
register 6 which is the value of 2 right
here escape out do another make execute
and there you can see is 2 okay guys so
there is a whole bunch of information
we're slowly but surely getting into
real programs inside of assembly
language so just take a look at the
information I linked to in the
description work your way through it do
the little homework little things that I
talked about and experiment a lot and in
assembly language is going to make a
whole lot more sense to you so like
always please leave your questions and
comments below otherwise until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>