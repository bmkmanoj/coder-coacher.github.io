<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Heaps | Coder Coacher - Coaching Coders</title><meta content="Java Heaps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Heaps</b></h2><h5 class="post__date">2013-04-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eFCn6udv3gQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
17 of my java algorithms and data
structures tutorial as you can see today
we're going to talk a lot about java
heaps if you missed any of the previous
parts of this tutorial I provide a link
to the playlist above so we have a lot
to do
so let's get into it so what exactly is
a heat well heap is kind of like a tree
but it is normally implemented as an
array as you can see over here this
would be an example of a heat but this
also would be an example of a heap which
is what we have down here with the array
structure and you can see exactly how
the indexes match up with the trees just
by looking at this now one of the rules
whenever you're creating a heap is that
every row needs to be complete meaning
there's an item in each one of the nodes
except for in the last row and another
rule with a heap is that parent keys are
always bigger than their children now
unlike a binary tree the left child
isn't always less than the right child
and why would we use heaps you may ask
well they are very quick in regards to
insertion as well as deletion however
they are very slow in regards to
traversal or searching and as you're
gonna see later on they are also
particularly quick in regards to sorting
whenever we take a look at the heap sort
so how exactly does a removal of a node
work inside of a heap well we're just
simply going to pop off the root node up
here move up the last item inside of our
heap into that position as you can see
right here
then we're going to switch 55 with 85
because 85 is larger than 55 and then
we're going to take 55 and switch it
with 65 and that is how removal of a
node inside of a heap works so how does
insertion work well if we're going to
insert an item in like 93 like we have
right here since 93 is greater than 80
it is going to jump up into that
position there you can see 80 is over in
this position then because 93 is greater
than 90 is then going to jump up into
the root spot and 90 is going to jump
down here and that's how insertion works
also based off of the previous two
things you pretty much can see exactly
how an array is thrown into a heap
format which once again just means that
all rows need to be complete except for
the last row and also that all parents
are bigger than children well if we
an item and it is not in position
meaning that it doesn't follow one of
those rules meaning that 71 is greater
than eight we would just swap it and so
forth and so on
with 82 to 68 and then 82 to 72 and now
you can see in this final picture over
here that the heap is properly sorted
because all the parents are greater than
the children which is really the only
rule so now that I showed you all that
let's start writing some code okay so
here is basically the code we left you
with in the last part of the tutorial in
which I showed you how to create or
print out a tree structure in the
console window using Java which is a
very very handy thing to be able to do
I'm going to go over how to insert items
inside of here and this is going to be
quite easy we're just going to have an
index and then data 3 which is our
object we created in the last part of
the tutorial is going to be passed in
there and then we're just going to say
the heap which is an array should go in
the index that was passed over inside of
here and new data needs to be saved in
that index and that is all we're going
to do in regards to insert now we are
actually going to have to increment and
here we go
there's the heap there's items in the
array there's max size this is all the
stuff we went over in the previous parts
of the tutorial and if you watch the
last two parts you'll be totally caught
up if you somehow found your way here
without seeing those now we're actually
going to have to increment the number of
items in the array outside of insert
whenever we're using a heap and the
reason why is later on we're going to be
using insert to throw items inside of
the array whenever we use a heap sort
I'll cover that later on whatever we get
to that so we're gonna say items in
array and we're going to increment it no
big deal so that's just going to insert
items into the array and increment it
now if we want to pop or remove items
out of our array also pretty quick and
pretty simple we're just going to go
data three which is what we're going to
return after the item is removed then
I'm going to check if items in array is
not equal to zero because I wouldn't
want to try to pop something if nothing
exists in the array and then I'm just
going to assign to a root
you the root item from our tree which is
the heap I'm then going to say the heap
zero position should contain the value
for the heap and then we're going to
decrement items in the array and save
the next item inside of our heap in the
root position and then keep the array
which is moving everything that is
greater than in the bottom upwards so
that all the parents have children that
have smaller items inside of them and to
do that you're going to see this method
here in a minute I'm going to pass it
the root position for our array and it's
going to handle everything for me then
after I'm all done with that I'm just
going to return root or in the situation
in which we don't have anything to
return I'm going to return null and we
would get that of course if there are no
items in our array and then we get into
the situation well we're going to
actually create this guy down here below
and this is the method that we're going
to use to print our trees out and a
whole bunch of other different things
like I said all this codes available to
link underneath the video in the
description and all that stuff we
covered in last part of the tutorial now
what we're going to do is actually heap
the guy basically what we're going to do
here is we're going to take any
situations in which a parent has a child
that is larger in it and move that item
that is larger into the parent position
and then the item that is in the parent
position move it down into the child
position that's all we're doing so let's
say we want to find situation where we
have the largest child and we're going
to use this guy to do a whole bunch of
things including the sort part we're
then going to say data three roots is
equal to the heap index that is passed
inside of here and as you're going to
see later on that's often going to be 0
then we're going to say while index is
less than items in array and we can
actually divide that by two we're going
to say int left child is equal to 2
times index plus 1 so what we're doing
is just getting the left child for the
index that is passed inside of here and
then to get the right child because
we're going
comparing the left child the right job
we just need to add one to it so there
we are now we have both the index for
the left and the right child now that we
have those we can say if right child is
less than items in array which would be
a must unless we want to have a whole
bunch of errors now we want to check if
the heap which is just the array with
the left child index and because we
don't have getters and setters in here
we're just going to put key inside of
there is less than the right child key
we want to say largest child is equal to
the right child index else we know that
that's not true so in that situation we
want to say that the left child index
has the largest child and this is how
we're going to compare them to decide
how we want to move them into position
now we're out of here
and we want to say if the root is
greater than the largest child well we
don't want to switch anything so let's
just jump out of the wild loop all
together what we're trying to do is move
all these guys into proper position so
if the root key is greater than or equal
to the heap part that has the largest
child item inside of it well then we
don't want to do anything we just want
to leave no reason to change anything
else the heap index value in that
situation the child needs to be moved up
and that's exactly what that's going to
do so that's how we're able to traverse
this heap and move larger items up and
smaller items down then we're going to
set index equal to the largest child and
then at the very very end we're going to
say the heat index is equal to the value
of root and make sure that's capitalized
there that is all we need to do to move
all the child elements in the proper
position based off of size and depending
upon the value for the parent elements I
actually could come down inside of here
let's just execute this see what we have
here so far there you can see there is
our heap right there there is the
original array we did a lot of that in
the last part of the tutorial and now if
we want to heat the whole entire array
we can just go in J is equal to new heap
and then get our maximum size divided by
two minus one
then we can go J is equal to zero and
cycle through all these guys by going
new heat and calling heap the array and
then doing the heat for each one of
those indexes and then after we heap all
them which is just move them into place
we could do something like print this
out here and say heaped array and then
let's also say that we would want to do
a print the tree afterwards see how that
looks its file save and execute and
there you can see seventy-eights been
moved up here to the top position 58 and
55 or less than it 43 and 3 or less than
58 and 32 and 51 are all less than 55
and that is how that is heaped now the
only thing else we would like to do is
actually take you through how to sort
all these guys now how the heap sort is
going to work is pretty much exactly the
way that you saw how items were inserted
if you have a greater item up here at
the top since we're going to have this
guy right here being 69 and we don't
want it down here in this position but
we want it in the far right position
we're just going to pop that out of
place throw it into the proper position
in the array which you can see it is
right here take 54 and move it up into
the top root position and there's 54 now
that we have that all set up we're then
going to want to pop off 54 and then
move 42 into the proper position and we
know that at all times all the largest
items are going to be up in this upper
three parts because that's what heaping
the whole entire tree did for us then
what we just need to do is move all of
the greater pieces up into position and
so forth and so on over and over again
until we have everything sorted which is
pretty much what you can see right here
so let's take a look and see exactly
what all the code for that looks like
it's actually very simple now the reason
why the code is very simple is because
the heap method that we just created
keep the array this guy right here that
guy did all our work and I hope you
understood exactly what it was doing is
basically just comparing two children
saying which one is bigger then deciding
on which one was bigger then comparing
it to the parent if it was bigger than
the parent they change places that's all
that was going on so here all we need to
do is cycle through the array
and pop off each of the items in the
array so that the items go from smallest
to largest instead of just being in
random order it's actually going to be
quite easy because for the most part
everything is almost enlarges the
smallest order currently so to get this
to work we just need to go for int K is
equal to max size minus 1 which is there
of course because max size is 1 larger
than the actual number of items and keep
doing this while K is greater than or
equal to 0 and we are going to slowly
decrement okay then we're just going to
go have our item here it's going to be
called largest node and we're going to
say pop which is going to release that
top item from our array and then we're
gonna say insert into the K position the
largest node we always know the large
snowed is gonna be the top part of the
tree because that's the way the sorting
works so now to test it we're just gonna
go new heap boink
now we have to sort it with heap sort
little problem then let's say we want to
come in here and actually print out the
array just to double-check that it was
sorted properly if I'll save it and
execute and there you can see 24 24 31
37 39 47 and 51 there you go that's how
heap sort works and if you actually want
to see how all of this is processed in
the code I'm going to set it up so that
a whole bunch of information is printed
out like the original array then you're
going to be able to sit here and
actually watch how the trees are going
to be changed as we cycle through here
basically to really get this and you can
see here keep sorted this is going to be
the process of taking here this array
where it has 8969 51 30 66 31 and 33 and
sorting all that and how that's all
going to be sorted is as you can see 89
was replaced by 69 which is right there
69 is then later going to be replaced as
well as we cycle down through here and
you can see 66 and that situation is
going to replace 69 and so forth and so
on
over and over and over again until we
get to the final part which is our
sorted array and there you can see that
so pretty much provide you every single
thing you could possibly want to do with
the heap sort as well as heaps in
general please leave any questions or
comments below the next
toriel that's going to come up I'm going
to take a break from algorithms and data
structures just for a little bit because
you guys demanded it in the next couple
days I'm going to start my Android
tutorial till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>