<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Quick Sort | Coder Coacher - Coaching Coders</title><meta content="Java Quick Sort - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Quick Sort</b></h2><h5 class="post__date">2013-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mN5ib1XasSA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
8 of my java algorithms tutorial and
this is part 3 of the sorting part of
the algorithms tutorial and today we're
going to talk about the quicksort so
what is the quicksort well in most
situations the quicksort is the fastest
sorting algorithm out there quicksort
works by partitioning arrays so that the
smaller numbers are on the left and the
larger are on the right this is known as
partitioning and you're going to see an
example of that in a second it then
recursively sends small parts of larger
arrays to itself and partitions those
smaller parts until the whole entire
array is in order or sorted so let's
look a little bit closer at what
partitioning is now in partitioning what
you need to do is define a pivot value
then what you are going to do is switch
everything on the left side of the array
that is larger than your pivot value
like the 38 here with a value that is
smaller than the pivot value so 21 would
move over here just as you can see there
and just as you can see 38 there this
then continues until everything has been
shifted from the left side of the array
to the right side of the array and that
is what partitioning is and that's a big
part of the quicksort so let's see how
to put partitioning into code okay so
like I said when we partition data we're
dividing it into two parts and all items
with that above a defined value which is
the pivot will go in one part the rest
will go in the other so what we're going
to do here is we're going to define some
things like an integer array a I'm going
to call it the array and all the code
here is available on a link in the
description underneath the video and I'm
also going to have another integer
that's going to store the array size and
then I'm going to bounce down here into
the constructor for this guy and just
set up everything's and array size is
going to get the value of whatever new
array size was passed in and then we're
just going to go the array is equal to
new int and it's gonna be whatever array
size this value is and then we're just
gonna call generate random array which
I've shown you in past tutorials how
exactly that works you can actually see
it right here generate random array but
because that doesn't have much
with partitioning I'm going to skip that
so now let's jump in here and actually
started partitioning everything okay so
I'm going to create an integer and I'm
going to call it left pointer and I'm
going to assign it to negative one which
is going to be just outside of the array
itself now the way the left pointer is
going to work is it's going to sort
through the array until it finds an item
that is greater than the pivot then it's
going to stop and wait for the right
pointer which we're going to create here
in a second to find a value that is less
than the pivot then those items are
going to be switched so that's all
that's going to happen there so of
course we're going to need to also come
in here and create right pointer and
it's going to get a value of whatever
array size is so the right pointer is
going to start out on the right side and
the left pointer is going to start on
the left side of the array then we're
going to say while true we're going to
break out of this whenever a certain
conditions are met down below and then
we're going to cycle through the array
until the end is reached or an item
bigger than pivot is found and then wait
for right pointer to finish cycling so
we're just going to go left pointer is
less than array size minus 1 and the
array and then this is where we're going
to increment left pointer right here by
putting two pluses in there and that's
going to put it in the zero position
since it starts out the negative one
position less then pivot so it's going
to cycle through this guy until it finds
a value that is greater than or equal to
pivot and in that situation we're just
going to sit so actually what I'm going
to do here is just put a semicolon now
if I want to print information out onto
the screen in regards to what's going on
so we can see this partitioning I'm
going to pass in left pointer and right
pointer into print horizontal all right
then if I want to also pronounced some
information like the value that is in
left pointer you can look at this as a
description of what exactly is going on
here of course you're going to be able
to use this as a tool to watch the
partitioning actually work which is a
great way to learn about this stuff back
in the day that's the way I learned how
to use all this stuff is by actually
creating it and then throwing a whole
bunch of things like this that describe
what's going on and I watched all of it
and I understood it so that's for you
guys that ask me all the time how did I
learn what I learned this is pretty much
how I learned it so
there you go that's going to describe
what's going on with our system as we
were partitioning everything and then
we're going to do pretty much exactly
the same thing with the right pointer
we're going to say right pointer it's
going to cycle through the array until
the beginning is reached or an item
smaller than pivot is found so this is
going to change to greater than and then
here we can just put zero and here this
is going to be decremented and this is
going to get changed to right pointer of
course and we are looking for values in
this situation that are greater than
pivot so this is going to cycle through
until it finds a number that needs
switched with something over here with
which is going to match up in the right
pointer and then they are going to
switch each other that's all that's
going on and then let's say that I want
to print some more information out and
then I'm also going to pretty much do
exactly the same thing here put another
little comment in here bounce that down
there
bounce that down there and in here I'm
going to print out the screen right
pointer in index right pointer is
smaller than the pivot value and then
for the heck of it I'm going to throw
that in there again to print out the
array on the screen now what I need to
do is handle the fact that way up here
I put while true so I'm going to have to
find a way out of that situation so I'm
going to say otherwise I'll have a
continuous loop I'm going to say if left
pointer is greater than or equal to
right pointer well we know we can't do
that so what we're going to do in that
situation is break out of this while
loop so that's what that's there for
then I'm going to say else we need to
handle the swapping of the left and
right pointer and I'm just gonna say
swap values left pointer and right
pointer and they're going to swap and I
also created swap values here at a time
which you've seen this in the past parts
of the tutorial so there's that and then
let's say that I want to go here and put
some more information out on the screen
so I know what's going on so I'm going
to say left pointer and then here I'm
going to say was swapped for and then
here I'm going to put the right pointer
and now we'll be able to track that
going on and that is that that's all
there is to partitioning so I have to
come up here now inside of main and just
set everything up and run it so I'm
going to go partition a partition array
treat this object and then go new
partitioning and create an array with
ten
X's inside of it and then I'm going to
come in here partition array and then I
want to generate a random array and that
will do that for me and then let's say
that I also want to print the array out
on the screen so we can see it change
the stuff is just as important as
anything else that's why I'm spending
time showing you what's going on here so
that's going to print my array out on
the screen and then I'm also going to
print it out on screen after the
partitioning is done and I just tell me
to import this utility and then I have
to actually partition everything so
partition array partition alright and
then I'm going to define my pivot value
is 35 and then execute and there you can
see everything working so this is the
array whenever it first started out we
know that our pivot values 35 so right
away the left pointer finds 59 it says
hey this is greater than 35 we need to
get rid of it and then the right pointer
over here is cycling through looking for
a value that is less than 35 and right
here it finds it but you can see that it
has to cycle through all of these
different values to find that but once
it does it takes the 59 moves it over
here where the 34 is moves the 34 there
59 there and then we continue onwards
and in this situation there is nothing
else less than 35 so the partitioning is
done and that's all that goes on so
let's execute it again here we can see
again this value is greater than 35 this
is less than 35 so you can see right
away we're going to move the 26 down
here to 26 and the 37 right here over
here to 37 and then over and over and
over again until everything that is less
than 35 is on this side of the screen
and everything that is greater than 35 s
on that side of the screen and that is
partitioning so now let's take a look at
how the quicksort uses partitioning to
sort faster than anything else okay so
what you see here is there's a pivot
value of 21 defined and we are in
essence doing exactly the same things
here we're going to look for a value
that is less than or equal to 21 in that
situation we have to move it over to the
right-hand side of the screen again left
pointer right border this is the
quicksort just so I make a hundred
percent surety understand that so our
goal here on the right is to find a
now you that is greater than 21 and here
we're looking for a value that is less
than 21 and then we're gonna switch them
you can see right here 16 is definitely
less than 21 so we have to switch it and
right here is 21 and these guys are
going to switch on the next panel now
you can see 16s they're 20 ones there if
it's still 21 we're going to continue
through here 38 needs switched with 19
and we skipped 55 because it's greater
than our pivot and now you can see 1938
have been switched as well then again 52
needs to be moved
53 and 30 are both greater than a pivot
so we've reached this dead end here and
now you can see that 19 and 52 both
switched however there's nothing more to
partition but of course this thing isn't
sorted so now what happens is whatever
the value of the left pointer was at
that point in time and say if that's the
new pivot and then we start cycling
through to see if we can find a
situation in which we're going to be
able to switch from the left to the
right in this situation no we are not
because 19 is too small and you can see
that the left pointer in the right
pointer almost immediately come together
again not able to do any switching so in
that situation whatever is in the far
right for our array is then changed into
the pivot and that's now 52 then you can
see again we're moving the left pointer
down and the right pointer and we're
doing switching and we're changing the
pivot whenever these two guys are going
to meet and here the pivot is going to
be 38 and you can see it just switches
the pivot goes from whatever the left
pointer is till whatever the right
pointer is and we switch switch lid
switch here changing the pivot to 21
switch would switch finally the pivot
goes to 55 left then the right pointers
meet in the center and then we're going
to hit a condition which you're going to
see here in code in a second in which
the left pointer minus the right is
going to be less than or equal to zero
in that situation we're going to know
everything is sorted and we're also
going to know that we no longer need to
partition so now that you see a rough
overview of how the quicksort lurks
let's go and look at the quicksort in
code okay so we're going to need an
array we're gonna need a race size just
like we had previously so let's just go
and throw that in there got that saved
I didn't describe everything about the
quicksort in the previous little example
that was a
ratha overview I'm going to get into how
recursion works with the quicksort here
in a second I'm just gonna skip over
main for a second come down here into
the quicksort area that's actually going
to be the same constructor as the
partitioning 1 so let's save ourselves
some time let's just go grab that jump
back over here again the codes available
underneath the video if you want and
then we're going to get down into the
actual quicksort so we're going to say
yeah you're gonna see right here
immediately when we are going to stop
sorting if right minus left is less than
or equal to 0 return and that's the end
of the game everything is sorted so
that's exactly what that is there for
then we're gonna say else now we're
going to have to define our pivot now
with this guy the pivot is not going to
matter it doesn't matter where it is in
the iraq but what does matter is the
pivot that we choose has to be an actual
value in the array so here we're going
to come in here and go they all right
and there's another version of the
quicksort that actually tries to find
the middle part of the array meaning the
most central value but I'm not going to
get into that right now because it's
questionable whether it actually
improves speed or not sometimes it does
sometimes it doesn't so I'm going to
just stick with this to try and make
everything understandable all right so
now what we're going to do is say value
in write the array right is made the
pivot that's going to help us here in
second really be able to see exactly
what's going on with a quicksort I'm
also going to pray on some information
on what is left but is right what is the
value for pivot and then I'm going to
put sent to the partitioned you're going
to see what partitions is going to do
here in a second it's going to do what I
just showed you previously pretty much
the quicksort job here is to make arrays
that are smaller and smaller and smaller
to be partitions the partition part does
pretty much exactly what you just saw
previously in the previous cut so then
I'm going to go pivot location is going
to be equal to partition array and to be
able to partition we're going to have a
pass it left right and whatever the
pivot is and that's going to partition
it for us and here I'm just going to
print out some more information value
and left and this is going to be left as
well he's made the pivot just like you
saw the right and left constantly switch
off
in regards to which one is a pivot then
this is the recursion part and this is
going to be a call to quicksort again
and we're going to take whatever is in
left pivot location minus one what this
is going to do is sort our left side and
then we're going to go pivot location
plus one and this is going to sort all
right side and that's it
quicksort is done the part that needs to
be finished now is the partitioning part
which you already saw so here again
we're just going to go in left pointer
because we are going to be changing
where in the array the left pointer is
going to be it's just going to be
whatever left is minus one and then
right pointer is going to be equal to
whatever right is and you're going to
see the same thing here again while true
and then you're going to see exactly the
same thing in regards to how we're going
to search so we're going to say the
array increment left pointer while it is
less than Vivid well we're going to
search through the array until we find a
value that needs switched and then let's
also print out some information on
what's going on here I'm actually going
to bounce over to the partitioning side
here and actually grab some stuff like
this guy
what the heck must we'll just grab it
all because it's all going to be used so
just copy all that paste it in there
okay this is going to print out
information in regards to the fact that
the left pointer in the index whatever
the value left pointer is is bigger than
the pivot value and then we're going to
print the pivot out then we're going to
use exactly the same thing here to find
the right pointer just cycle through as
long as right pointer is greater than
zero and we remember right pointers on
the right side of the array so it's
going to be decremented until we reach
the point in which that value there is
greater than our pivot and then we know
that we need to switch everything else
is going to be exactly the same in
regards to printing out information in
regards to how the quicksort is working
and then what are we going to do well
pretty easy we're going to go the left
pointer is greater than or equal to
right pointer well what do we know
whenever that occurs that means we need
to break out of this guy to handle the
fact that we put while true up there
which is kind of crazy so this is going
to break us out in the situation which
we know that we're going to have to
start all over again then we're going to
put break inside of here because
remember we're
not until we partition the whole thing
we're partitioning until the whole thing
is sorted so that's the one thing that's
kind of different there then we're going
to go else well if we get down here well
we know we need to swap our values and
the value is going to swap is left
corner and right pointer and I'm going
to bounce over here and copy this little
message paste it inside of there then
after we do this whole entire thing
we're about ready to exit well we need
to swap our values again except in this
situation we're going to swap left
pointer and whatever right is and then
after we're done with that we would turn
whatever is in the left pointer and
that's it everything's set on I think I
got everything set up anyway let me look
here real quick look nope I have to go
into Maine first and what's Maine going
to do pretty much the same thing
partitioning dead say if you understand
the partitioning part you understand
everything else so it's just copied I
jump back over here paste all that in
there I think it's going to be different
as class names difference of course we
got to change that and I'm going to
change this to the sword then this is
going to be new quick sort and then this
is going to be the sword again and then
partitioning is going to be changed
quick sort just like that great and then
we're gonna have to go in here and grab
the sword or that there throw that there
and then this is going to be quick sort
and quicksort legacy right here gets a
left and a right well what's our left
and right going to be 0 and 9 and of
course you can calculate that
dynamically and we got everything set up
so let's execute and after executing
everything you can see down here all the
numbers are in order so you didn't take
that many passes through to do it you're
also going to see a value and right is
40 and that is going to be made the
pivot and there's your pivot and then
you see left is 0 right is going to be
equal to 9 the pivot is 40 just like we
said and we are sending it to be
partitioned so that's the first array
that's going to be partitioned 51 and
index 0 is bigger than the pivot value
40
so what does that mean well we're going
to wait for a situation in which the
right pointer is going to find a value
that is less than 40 and in that
situation we're going to switch it just
like we did there 18 s there now 51 s
they're going to come through here
43 and index one's bigger than pivot
value that means it needs shifted over
to the right right here you can see the
right pointer finds a 20 those guys need
to be shifted there you can see they
weren't 20s now they're 40 threes now
they're 45 meter
that again 39s right there so those guys
going to get shifted you can see that
they just did and then you're going to
see that these left in the right pointer
both meet up with each other so whenever
that happens left is now greater than or
equal to right so we need to start
partitioning again and in this situation
we're going to pass this into quicksort
and we're going to pass a smaller
version of the array which is starting
left at 0 and right at 4 and pivot in
this situation is now going to be 39 and
we're going to continue doing that over
and over again please get the code and
watch this this is how you will
completely understand the quicksort by
watching this step-by-step go through
here and it will continue and continue
and continue until it is done so that is
how partitioning and quicksort work
please leave any questions or comments
below otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>