<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Refactoring 18 | Coder Coacher - Coaching Coders</title><meta content="Code Refactoring 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Refactoring 18</b></h2><h5 class="post__date">2013-02-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/riuRTxV01Vo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello Internet welcome to part 18
of my code refactoring tutorial this is
going to be pretty much the end of the
code refactoring tutorial and in it I
wanted to cover the pattern that seems
to be confusing people the most being
the abstract factory pattern in this
tutorial I'm gonna present it in
numerous different ways and by the end I
hope that you completely understand it
because it's not that complicated so
let's get into it
now basically what I'm gonna do here
with my abstract factory tool is I am
going to pop different types of monsters
out of factories and I've talked about
factories previously and basically one
of the potential monsters is going to be
a vampire and it is going to have as a
attack an object assigned to it now the
potential objects that are gonna be
assigned to this are either gonna be
basic attack or medium attack and
they're going to be chosen because they
both are going to implement the same
interface so attack power is going to be
of type monster attack power which is
ultimately going to be a basic attack
object or a medium attack object just
basic stuff then of course there's going
to be an interface that's going to
separate all the different types of
monsters that I can have but the only
difference between all these monsters is
going to be whether they have basic
medium attacks or basic or medium ranges
that is it every monster and everything
about the abstract factory pattern is
right here on your screen so now I'm
gonna dig a little bit deeper okay so
you can see right here we're going to
use an interface Factory and it is going
to assign attack power or attack range
whenever I want to make a vampire a very
specific type of monster I'm just going
to implement the monster factory which
is just gonna force me to use these
methods right here that's all it's doing
and then I'm going to assign quite
simply for every single vampire object
that I create the medium attack and
medium arrange right there there's
basically gonna be a monster abstract
class and the difference between the
monsters is the objects stored in attack
and range and as we saw back here an
interface is used to
present both options available for
attack and range and two classes are
going to implement that attack and range
interface being basic attack and medium
attack and ranges down here this here is
the monster factory interface it's just
going to represent all the monsters with
different attack and range types as
defined right here and here is the
actual vampire class and as you can see
whenever it is going to be created a
monster factory is going to be passed
inside of it and stored in this
attribute and guess which monster
factory that's gonna be gonna be the
vampire monster factory and then once it
is stored inside of there there is going
to be those two attributes for attack
and range and they are going to be given
the values that are going to be stored
inside of the specific monster factory
by calling the method assign attack
power and assign attack range and up
here this is the reason why people use
the abstract factory pattern as you can
see I can create these somewhat complex
objects with just two lines of code
because what we're going to do in this
situation is whenever we call for the
vampire to be printed out we're gonna
call to string and it's gonna print out
all kinds of information and that
basically leaves us with the only thing
that's left which is the Builder again
there's going to be an interface Monster
builder and like you know interface just
tells it what methods it must have the
method it must have is make monster and
what it's going to do is get past a
string and here I cut out the zombie
option just focused on the vampire if
the string is vampire that says we need
to make ourselves a vampire factory that
is going to assign very specific attacks
and ranges pass it over into the vampire
class or object C just as you see here
passed right in there and then here
we're just gonna set the name for our
vampire in the vampire class object just
assigns the attack and range objects as
attributes for attack and range for
every vampire object that is created so
that is a brief overview of what we're
going to create in the code that follows
so now what I'm gonna do is step by step
create everything well the very first
thing we need is the class that defines
the attributes and capabilities for each
of our monsters
this is going to be public abstract
class monster right like that pretty
simple and we're gonna have private
strain for its name and then we're going
to have monster attack power which is
the interfaces type and attack power so
one of the objects that implements the
monster attack power interface is going
to be stored inside of this and then
guess what else we're also going to have
monster attack range and all the code
that is here is available in link
underneath the video in here we're just
going as time attack range then we want
to force them to make our monster for us
and they have to figure out how to
implement that and then here I'm just
going to do some really basic things in
regards to just printing information in
regards to what this monster is doing
out onto the screen and yes it is very
common to create enemies or whatever in
video games exactly like this except
you're not just gonna print out exactly
what they're doing unless it's a text
based game I guess so then we're just
gonna go get name for our monster and
then we're gonna go checks if victim is
and then it is going to call for attack
range or to string for attack range to
print out on the screen and then we're
gonna do pretty much exactly the same
thing don't focus on this this really
doesn't have anything to do with the
abstract factory pattern this is just
going to print information out on the
screen so that you know that you have
struck factory pattern actually works
and then this guy is gonna go attack the
victim and then this is going to say get
name attacks the victim for and then
this is going to be attack power and
then since we're gonna be able to print
out all sorts of things on the screen
using two strings well we need to string
to actually be created and I think this
is the thing that's confusing people is
the use of two strengths just means
whenever I put the objects name inside
of system.out.print line it's gonna
print whatever I put here I think this
is the thing people aren't focusing on
and this is what's confusing people
and now that you can focus on it you can
see two strings
something we use all the time no problem
so now that we got that we're gonna
print a message out on the screen that
says attacks anything attack range again
just print now what is inside of two
string for each one of these objects and
then this is gonna be attack power and
if you get the code and play with it and
make your own abstract Factory the
stuffs gonna be really easy so there we
are all we're doing is print that out
and we're done that is the class except
of course we should come in here and
actually create my setters and magetta
source generate setters and getters and
I'm just gonna do it for name get names
that name blah blah blah blah blah and
I'm gonna put it we're way way at the
bottom just so it doesn't distract you
and there it is okay
so we're done with that and one of you
guys actually requested that I keep all
of this code all in one file so I will
so now what I want to do I need to
define the interface that is going to be
used to define attack powers so
interface monster attack power and all
its gonna do is force to string to be
created and there it is it's done so not
that complicated of an interface then
I'm gonna replace to string with a real
monster attack power so the first one
I'm gonna do is basic attack implements
monster attack power and then inside of
this I'm gonna define the special to
string this is going to be used whenever
that is asked for ten in damage is going
to be returned pretty easy then I'm just
gonna copy this because I'm gonna do
exactly the same thing for medium attack
medium attack except let's change this
to 20 and there we go now I need to do
the same exact thing exact thing for the
range very simple so I'm just gonna copy
it paste monster attack this is gonna be
changed to range there we go all done
and then here I'm going to change this
to monster attack range monster attack
range and then I'm gonna change this to
basic range and medium range and change
this to five away like it would be
spaces or something
turn away and there we are I'm done so
that was how easy it was to implement
those now I need to define the
attributes for each monster and the
methods that will define them so I need
to create the interface for my monster
Factory
and those are gonna be public monster
attack power which is what it's gonna
return and whenever you call a sign
attack power it is going to do just that
then I'm also gonna do the same thing
for range and it's still monster attack
power because it's using that interface
and then what I need to do is just
define I'm gonna copy this my specific
monster factories the first one I'm
gonna do is my zombie factory and
remember it's just a time assigning the
right attack power and attack range
objects that's all it's doing that's all
these factories are doing implements
boom monster factory and then what do I
need to do well I need to implement the
methods needed add-on the implemented
methods and there they are pretty easy
and there's only going to be two of them
for our zombie and that is going to be a
return new basic attack or zombies are
going to be weak and of course whenever
that is called that is just going to
print out information on the screen and
basic range and there you go now I'm
went in to find those and of course
change that to range as well and then
I'm also going to have to change this to
range of course little bugs sorry that's
how it happens whenever I'm working out
of my head
so there we go so that creates a zombie
factories that assign the right objects
to power and range so now I'm going to
create a vampire factory and gonna do
the same exact thing don't need to
change anything except this is gonna be
medium attack and this is going to be
medium range done so that quickly I
created zombie and vampire factories so
now I have to actually create the zombie
and vampire classes and like I mentioned
before a factory is going to be sent
into this class and will then assign the
right objects for attack and range to
said zombie so let's do it
class zombie extends monster and
unimplemented methods
and do it and the only ones gonna be
make monster so inside of this I need to
store a monster factory because a
monster factory assigned specific
attributes that I need to get from it
then public zombie I need to pass in the
monster factory not a problem and then
just go this monster factory is equal to
the monster factory passed in there and
then I have to go in to make monster and
let's say I want to go system.out.print
line making a zombie and print that out
on the screen just to show that yes I
made it in here and I'm making a zombie
right now and then the only thing I need
to do is get the attack power and the
range that is stored inside of my zombie
factory so equals monster factory dot
assign attack power done and then this
one's going to be attack range equal to
launcher factory a sign attack range
done and exactly the same thing is gonna
be done to create my vampires so there's
no reason to sit here and go and worry
about making anything different except
changing my name's cuz that's all I'm
doing and then I just need to copy this
boom and everything else stays the same
except this is gonna be vampire as well
there we are
piece of cake so now I have my monsters
defined with their individual attacks
and rages and I have a factory for
making them now the only thing I need to
do now is make or create a way to order
monsters and the abstract class Monster
builder is gonna do that for me so
protected abstract it's gonna return a
monster make monster and remember I said
it's going to receive a string that's
going to tell if the type of monster to
make yep its abstract and then public
monster order a monster which is gonna
receive a string of monster right like
that we're going to get a monster type
make it equal to make monster which is
gonna call this method right here and
pass to it whatever type of monster is
sorry it's also doing and then I want to
test out all the methods for my monster
to make sure
it's working so and most importantly I
need to make the monster and that is
just gonna be a call to make monster
which is right there say making a
vampire da da da da da and then make
monster here in a minute is gonna define
exactly what type of monster is gonna be
made then I'm gonna go monster and we
could do something like check if victim
is in range and monster attack the
victim there we go and then of course
finally we want to return the monster
back to the calling method that is gonna
call this which is gonna be main as
you're gonna see here in a second now
that I have that all built I need to
extend my monster builder so that people
can actually order monsters easily just
by passing in a string so I'm gonna go
class order a monster and what I mean by
order is to ask for one and then receive
one not put them in order
monster builder had unimplemented
methods there you go and then here we're
just gonna say we want a monster type
call it the monster and give it a null
value and then this is gonna be real
simple if the type of monster passed in
you already saw this we're gonna check
if it equals zombie and if it does equal
zombie we're going to create a zombie
factory I'm just gonna call it monster
factory is equal to new zombie factory
right like that and then I want to
create a zombie monster that's gonna
store the object specific for each
zombie so they can be assigned to this
monster and to do that and just go a
monster is equal to new zombie and pass
in a monster or what is the zombie
factory and again that's just this guy
up here see there's a zombie constructor
and it's being passed a zombie factory
and it's gonna be stored and then we're
going to call for the methods inside of
the zombie factory so that's what's
going on there then I'm just gonna give
the Sambi a name which again really
doesn't have anything to do with
anything I'm just gonna call him zombie
Bob and then I'm going to do the same
thing for my vampire if in this
situation we're just gonna type in
vampire and of course this is gonna be
vampire factory say same exact thing and
then this is going to be new vampire
and then this is gonna be a vampire and
I'm gonna call him Paul and that's it
and then at the end we're gonna go
return the monster and we are pretty
much done now all we got to do is make
all this work inside of Maine so class
monster maker test public static void
main create a way to order our new
monsters well that's gonna be a monster
builder and we're only gonna ever need
to create one of those then we're gonna
go order a monster right like that which
is just the guy that extends the monster
builder say order a monster it's right
here order a monster then to make our
new monster monster and let's say that I
know this is gonna be a zombie I just go
monster builder order a monster call
that method and pass into it
zombie and where's that coming from say
monster builder we know this is an order
a monster and order a monster I'm up
here and we're passing in zombie that's
where it's coming in and this is the
code that's gonna be executed so I've
come back down here and then we're just
going to make a simple call to the to
string method and whatever we call
zombie it's just gonna print out
whatever is stored into string and let's
say I want to put like a new line in
there for some reason and then I just
want to do exactly the same thing for a
vampire see two lines of code prints out
all that stuff that's why it's useful
and everything is treated like a real
world object vampire and if we want to
print out vampire specific thing just
call to string on the vampire monster
save everything and go over to monster
maker test and if I did everything right
this should work run as java application
and there you can see making a zombie
all that information got passed in all
the specific attributes for the zombie
and then all the specific attributes
were passed in for our vampire so there
is another look at the abstract factory
pattern I have a link above to a
previous explanation of how it works
that's more verbose please leave any
questions and comments below the last
the next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>