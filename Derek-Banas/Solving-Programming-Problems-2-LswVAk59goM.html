<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Solving Programming Problems 2 | Coder Coacher - Coaching Coders</title><meta content="Solving Programming Problems 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Solving Programming Problems 2</b></h2><h5 class="post__date">2013-04-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LswVAk59goM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
16 of my java algorithms and data
structures tutorial today we're going to
continue from what we were doing in the
last part of the tutorial in which we
focused on solving programming problems
and if you haven't seen that tutorial
there's a link to it in the upper left
hand corner and a link to all my
algorithms tutorial in the upper right
hand corner now if you don't remember
our original goal was to figure out how
to print out a tree structure pretty
much any type of tree structure on the
screen based off of data that is in an
array and we pretty much did it however
as you're going to see in this tutorial
we're going to fine-tune everything so
that we eliminate all the problems that
came up from our past code so let's get
into it alright so you can see here our
old tree generation code that we made in
the last part of the tutorial and here
I'm going to generate the beginnings of
what is called a heap now don't worry
too much about what a heap is just in
general it's like a tree but it is
implemented as an array but don't focus
too much on that in the next and what
will be the last part of my algorithms
tutorial I will cover heaps in great
detail so what we're going to do here is
we're going to create an array and it's
going to have what are called data three
objects and I just use data 3 as a name
because I use data previously and we
might as well just come down here the
very very end of this and create our
data 3 class now this is going to be
very very simple data 3 and inside of it
it is just going to have a key but that
you saw before you can put anything else
you want in here the key is just going
to help us locate the data and then we
are going to create a constructor inside
of this and it's going to get passed a
key and we are going to assign the key
for the class to whatever the key was
passed in very very simple so now let's
jump back up inside of here and all the
code in this video is available to link
in the description underneath the video
so let's go in and we're also going to
monitor items in the array and that of
course is going to be 0 whenever we
first start off and basically I'm just
modeling an array that's all it is it's
going to have a whole bunch of data 3
objects inside of it I'm also going to
have a maximum size for it
my constructor for this guy and it's
just going to receive a maximum size for
my array myarray is going to be able to
pretty much be any size and can contain
any number of different values and then
like I said before our goal here is to
take that information and dynamically
generate a tree for it
new data 3 and then max size so that's
going to set up our array now what I
need to do is have some way to be able
to insert values into that array and
that's easy enough public void I'm just
going to say insert and keep this very
simple I'm going to say index and data 3
new data is going to be passed into it
and then we're gonna go heap whatever
index they want and save new data inside
of it and then since we have another
item in my array items in array needs to
be incremented so pretty simple stuff
now the only other thing we're going to
need to do is come in here and generate
numbers in our array we're gonna need to
fill our heap with numbers so just to
have this be an automated sort of thing
I'm going to generate filled array and
it's just going to get a random old
number passed into it
data 3 let's just say random data 1 and
then I just need to fill this guy up any
time I need to fill something up I'm
more than likely going to use a for loop
I less than and I'm just going to say
whatever the max size is then increment
that then I'm going to need to generate
some random data based off of the random
number that was passed inside of here so
this is going to allow me to determine
if I want to have say single digits or
double digits or what have you and this
tree structure is going to accommodate
any number of rows any number of items
up to two digits in length and what I'm
going to show you here is easily going
to allow you to generate three-digit
numbers if you should so want to do that
now with this random number generation
I'm going to have to convert it to an
integer and I'm going to generate a
random number here and it's going to be
whatever the random number was passed in
once again I'm going to pass in things
like 9 if I want to be able to just
generate single digits or 90 if I want
to pass in and generate multiple digits
and then insert that I just go insert I
which is gonna be the index and then
whatever the random data is random data
one don't know why I picked that name
just picked it all right so this guy's
going to come in here and make sure I
change this to fill to read just a
little typo up there and also change
this to this little typo little things
that happen when I work out in my head
all right so this guy's going to
generate random arrays for us and we're
gonna actually be able to test our tree
here and see what's right with our tree
and what's wrong with our tree so let's
say just so that I know what is my old
tree and what is going to be the new
tree I'm going to generate I'm going to
just print that out and then we go heap
two and I'm just going to say new heap
is equal to new keep two and let's say I
want to generate 70 digits or I want to
have a maximum size for that array of 70
and then let's say that I want to throw
in multiple digits inside of this so
we're going to not have single digits
like 1 through 9 or 0 through 9 we're
now going to have multiple digits like
80 and 90 and 70 what's going to happen
to our original tree we made before
whenever we decide we want to do that
well first we need to actually generate
them generate filled array and let's
throw 90 in here and as you saw
previously generate filled array that's
what we just called and 90 is going to
go in here and begin that is going to
generate a whole bunch of random numbers
that are between one to two digits and
I'm on purpose doing this just to cause
havoc now what would happen if we go new
heap print tree and let's say 5 I'll
save it and execute you're going to see
here the mangled mess that is our
original tree code that we made in the
last part of the tutorial and why is it
mangled well it's mangled because the
generation of indents and then spaces is
not dynamic and that is going to be
something that we need to fix we need to
be able to print out any number of
different items and always guarantee
that in the last row here there's going
to be at least one space between all of
these digits let's see if there's some
other things that are broken with us
let's throw this up to 6 to print 6 rows
that's what it's going to do and execute
and you can see the problem just gets
worse and worse and worse and worse and
let's take a look back at all of the
different analysis we did in the past
part of the tutorial to see how we might
be able to fix this okay so this is how
we basically figured out how to make a
four row tree at that point we never
thought we would need to make any trees
bigger than that but now we've decided
that that is definitely what we want to
do let's also think about exactly what's
going on here now whenever we were doing
all of our calculations we saw here
indent is going to start with one and
then it is going to generate values
based off of this algorithm that we have
right here spaces was totally reliant
upon indent starts at zero and then it
gets whatever indent has then we get
down here first index per row this is
also going to be based off of this
calculation but it is going to increase
slowly from zero to one to three to
seven so really there's no problem with
that and as we look here we're also
going to see items per row that also is
not a problem for us just a simple
calculation and then max index that
we're going to print on each row also is
going to be dependent upon two other
things that are not going to be a
problem so by analyzing all this I can
see that the major reason why we're
having a problem printing more than four
rows is because indent is not dynamic
enough so I think I can solve this
problem if I can generate my indents
dynamically each time depending upon the
array data that I have rather than being
stuck to trying to generate it based off
of knowing there's even are going to be
one two three or four rows our goal here
in fixing this problem is to make the
calculation for indent more dynamic in
any way that we need to do it
another problem is going to come up is
if we try to print indexes that don't
exist which is definitely something
that's going to happen in situations in
which we have less items in the arrays
then can accommodate all of our rows so
that's another problem we need to think
about and of course the whole issue in
which we wanted to be able to print both
single digits as well as two-digit
numbers so those are the three things we
have to figure out how to fix in our
nutri code so let's get into that so I'm
basically just going to come back inside
of here and I'm
copy my old tree generation code because
it's almost right I just need to fix a
couple little things here and there so
I'm just gonna copy that paste that in
and of course I'm gonna have to train
just to print tree - now remember I'm
doing this pretty much out of my head
and I'm trying to keep things simple and
easy to understand so it's going to work
in the end but it's not going to be
optimized I always worry about
optimizing code after it works because
if I worry too much about optimizing
whenever I'm trying to fix a problem it
just causes more problems and that's
just a personal opinion okay so we know
that our major problem is the indent
nothing else pretty much space is just
going to become whatever indent
previously was so I see no reason to
change spaces at this point in time
we're still going to be iterating
through all these rows so I see no
reason to change the fact that the
iteration is going to start off at one
and then slowly increase this is the Big
Daddy this is a guy that we need to
figure out how to fix and if I think
about it I want to be able to generate a
series of digits which if I bounce over
here again is going to be seven three
one and zero and if we want to take that
up to five rows that means I'm going to
need to calculate what comes after seven
based off of that algorithm so just
think it out of my head I'm thinking why
don't I just generate those numbers
inside an array dynamically and then
base whatever indent is based off of
whatever the array is so I'm going to
create an integer array and it is going
to be called indent and I'm going to
create something called get indent array
and it's going to generate all the
indents that I need for each row based
off of how many rows that I have so that
means I need to get this guy and make it
I'm gonna come down here and think my
way through exactly how we're going to
do this well it is going to return an
integer array of course and rows is
going to be an integer so I'm going to
create an integer array inside of this
guy and I'm gonna call it indent array
new int and I need to calculate the
number of rows because I'm going to need
an indent for every single row and then
I have to pretty much do the same thing
over and over
in which what that means is I need
another for loop so the zero index I
less than the number of rows I increment
I and I need to generate all the values
that are going to go inside of the
indent array which is going to be I now
I know how to calculate indent so I'm
going to come up here and I'm just going
to copy that code now if we bounce over
and actually look at how we are
calculating indent before we are
calculating it 7-3
one and zero so if we want this to be
more dynamic what we're going to
actually have to do is calculate zero
one three and seven and onwards and
onwards and onwards depending upon the
number of rows and then we're going to
need to like I said before throw
everything into an array and then
something else we're going to need to do
is flip the array so that means that
this guy right here isn't going to work
for what we want to do instead we're
going to need to find the algorithm for
0 1 3 7 and onwards and onwards and
onwards so let's jump over in the
Wolfram Alpha and figure out exactly how
to do that so now we need 0 1 3 &amp;amp; 7 we
need that algorithm and here is our new
algorithm we've seen it once before this
guy right here so we're going to take
1/2 times negative 2 plus 2 to the nth
power so let's jump over there and
create that in that in essence is what
we did here with index to print so let's
take this guy copy it jump down here
bounce in here face that in there and in
this situation we don't want to generate
what comes from throwing 0 into that
calculation so we're going to replace
iteration here with plus 1 and like I
mentioned before jump back over here we
want to start with 1 so that's the
reason why we're doing that calculation
and ignoring 0 bounce back out and the
other minor thing I want to do is I'm
going to change this to absolute value
just to make sure that we always get
positive digits from this and now the
other thing that we want to do after we
generate this guy is to make sure that
it is sorted because we want to go from
largest number to smallest number so I'm
going to sort it indent array and then
what I'm going to need to do is flip it
because whenever we call sort and this
guy requires a library import raise
there we go whenever we sort things it
goes from lowest to largest we want to
go from largest to Lois whenever we're
doing this
population so I'm gonna go in down array
is equal to reverse array and I want to
reverse those values of course that
doesn't exist so I'm gonna have to
create that as well and then after
everything's been reversed I can send
back my in down array I guess that I'm
just doing this largely out of my head
so not worrying about optimizing things
all right so we're gonna need to be
returning an integer array reverse array
come in here that's gonna be an integer
array that's passed in here and I'm just
gonna call this a la array because I
might want to use this code at some
point in the future now how am I going
to figure out exactly how to reverse
values in an array well I'm gonna go
integer left index equal to zero so
that's gonna put me in the leftmost
index for my array and then I'm gonna go
right index and I want to go to the
farthest part of my array and to do that
I just go the array and go what's the
length minus one and there we go so now
that I have the leftmost part of the
array in the rightmost part of the array
I just need to flip these guys so I'm
just going to say while left index is
less than right index
I just need now to exchange the left and
right element so I'm going to go in temp
the array left index now I'm going to be
able to take that guy and then store the
value of whatever the right array is
inside of it since I have a copy of it
and then I'm going to take the right
index and store whatever was stored
inside attempt then the only thing I'm
going to need to do at that point is
take right index and decrement it so
that it moves to the left and then left
index and increment it so it moves
towards the right and those guys will
reverse the array and then of course
after it's done reversing the array I
just need to go return the array and
magically I now have a reverse direct
index so pretty cool so let's jump back
up into our tree code we still want to
continue iterating as long as iteration
is less than or equal to the number of
rows that we want to print out we
already have indent so we don't need to
worry about that right now but we need
to figure out what index to print is
which guess what it's exactly the same
as what we previously did
our problem wasn't indexed to print or
any of these other things our problem
was the fact that indent was not
generated dynamically also items per row
this doesn't need to change still good
max index to print still good no problem
there then we get down here where we're
going to actually be printing out our
indents well to print that out it's not
going to be a big deal we just need to
go and change indent here a little bit
because indents now in array and to
figure that out we're going to go
iteration minus 1 everything else here
is perfectly fine down here where we're
generating which keys and which spaces
to print out this has absolutely no
reason to change either however remember
we need to protect in this situation in
which the array isn't full and we try to
print an index that doesn't exist that
would be a bad thing so we're going to
say that we're only going to be allowed
to print keys and spaces and so forth as
long as L is less than the number of
items in our array and that's fine and
also remember that we wanted to be able
to print not only single-digit numbers
and keep everything lined up but also
double digit numbers so let's just come
in here and do that and one easy way to
do that is just to go string and format
and what I'm going to decide to do here
is actually put in leading zeros just
because that's first thing that came in
my head and to do that we're just going
to do this so that's going to guarantee
that there's two digits at all time and
if it's a single digit it's going to put
in a zero and we just take this guy
right here and throw it in right there
and everything else is dandy and the
spaces do not need to change in any way
either however remember indent now is an
array so we're going to go iteration
again minus one and save that two spaces
we're still going to increment iteration
and we're still going to have a new line
in here for a new line to skip to the
next row to print it out and now based
off of all that remember pretty much all
we had to do is fix indent that's it
let's come down here and see if it works
then if we bounce down inside of main
and here I'm just going to throw in new
tree and let's go and see what it looks
like if we try to print six rows even
though it didn't work in the past and
I'm also going to come in here throw
that in there and then change this to
our original print okay let's see what
happens well you can see this is the hot
mess for higher
last tree that we created and here is
our new tree and you can see everything
lines up beautifully for the entire tree
right there on our screen and just to
make this a little bit easier to say
let's change this into a five change
this into a five I'll save it execute
again this is a total mess and this is
nice and neat and beautiful and exactly
what we wanted to do so there it is that
is how to work your way through a pretty
cool problem and at the same time we
were able to generate some really cool
code for analyzing trees for future
projects please leave any questions or
comments below otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>