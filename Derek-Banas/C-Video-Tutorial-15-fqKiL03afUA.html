<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>C Video Tutorial 15 | Coder Coacher - Coaching Coders</title><meta content="C Video Tutorial 15 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>C Video Tutorial 15</b></h2><h5 class="post__date">2013-09-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fqKiL03afUA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
15 of my C video tutorial today I'm
going to cover how we can pass memory
addresses between functions bitwise
operators sign integers shift operators
two's complement bit masking and a whole
bunch of other different things if you
missed any of the previous parts of this
tutorial I provide a link in the upper
right hand corner and have a whole bunch
to do so let's get into it okay so this
is some information that we have left
after our last two parts of our tutorial
and one of you guys asked me how exactly
could we pass this memory location that
we are using back and forth between two
different functions well there's a
couple little things we need to change
here and if you want to consider this a
start of the class quiz you could pause
the video and do it yourself and see if
you get the same results that I got so
basically what we want to do is create a
buffer just like before that's going to
hold 32 bits plus a null character at
the end and so we're going to do it in
much the same way I'm going to say P
converted number right like that and
then I'm going to have to take the P
converted number and allocate some
memory for it which we've covered this
guy before allocate some memory and
basically if I want a 32 bit buffer plus
an all character that means I need 33
and what am I going to be storing inside
of it I'm going to be storing characters
inside of it so there we go and we got
that all set up and what this is going
to allow us to do is now say go print F
and call our string to print it out on
our screen and then what we're going to
do is call convert base just like we did
this guy up here and we're going to pass
inside of it the number to convert and
the base but we're also going to pass in
the memory location that we want this
information stored inside so I'm just
going to say I want to pass in number
six I want it to be converted into
binary and then I'm going to pass in P
converted number inside of there and
what that's going to do for us is print
that information out on the screen now
remember any time we allocate memory we
of course want to free it and that's
exactly what we're going to do when we
are done with the main function now all
we need to do is jump up inside of
convert base and change a couple things
so here we are up inside of convert base
and of course that information
going to be passed inside of here so I
need to catch it and we no longer are
going to need this buffering we're no
longer going to need to define this
information that we want to save here
for our character array we do however
still need this guy to be able to
actually generate the different bases
and so forth that we need we're going to
continue using this guy because we want
to make sure we get usable information
whatever we have absolutely no use for
this because we already have memory set
aside P converted number and we can just
say 32 if we want to save the null
character just like we did before and
then everything else here is going to be
set up exactly the same except in this
situation I don't think it makes sense
to print twice so let's get rid of that
file save that let's check to see if it
works so here is our terminal and if we
execute it you can see the answer 1 1 0
shows up which is the binary
representation of the number 6 alright
so now what I want to do is cover
bitwise operators and they sound way
more complicated than they really are
so let's just get rid of this don't need
that but we still are going to need our
memory location because that's the way
everything has been set off and the very
first bitwise operator I'm going to deal
with here is exactly how and works so
I'm going to create an unsigned int just
like before and I'm going to call this
and solution and to use it I'm just
going to use these two guys number 6 and
number 7 up here paste that in there and
throw an ampersand inside of it and then
number 7 and that's going to be our
result after using the and bitwise
operator and in essence what it's gonna
do is it's taking 1 1 0 which is 6 and
we're gonna go and 1 1 1 which is 7 and
it is going to spit out on the screen a
1 for each situation in which both of
these numbers start with 1 and there
also you see exactly the same thing
happening however in this situation
that's a 0 and that's a 1 so that means
that's going to be a 0 and that's gonna
be our result let's just get rid of that
and let's print it out so if we go prune
off print out our string and go and then
we're going to be printing out convert
base and we're gonna pass in no
number six and we want it to be binary P
converted number and this is just being
done just so that it looks nice and it
presents itself nice on their screen and
I'm going to print this out three times
here I'm going to put an equal sign
replace this with seven everything else
is going to stay exactly the same and
then down here I'm just going to replace
this with two new lines and then pass in
the and solution like that and if we
come in here and execute that you're
going to see 1 1 0 or 6 and 1 1 1 or 7
is equal to 1 1 0 and that is how the an
bitwise operator works now I'm going to
show you the or operator and it is quite
simple we don't even have to change many
I'm just going to call this or solution
and instead of an end I'm going to put
an or inside of there there you go and
basically it's going to return a 1 if
either of these binary numbers contains
1 so just change this to a nor as well
all the rest of this stuff can stay
exactly the same and then change this to
or phosphate and execute and there you
can see exactly what happened 1 1 0 1 1
1 it comes back with 1 1 1 because all
we require is one of these values to be
equal to 1 for us to get 1 as a result
totally makes sense and that brings us
to the exclusive or I'm just going to
call this e X with a capital o inside of
it and it has that little carrot shape
inside of there and basically what it's
going to do is a 1 is going to be
returned only if one of the numbers is
equal to 1 and the other is equal to 0
so really simple just to come in here
and show you exactly what that looks
like don't even need to change anything
change this to exclusive or run the code
and compile and in this situation you
can see only in one situation do we have
a 0 &amp;amp; 1 situation we have a 1 and that's
the reason why one is returned and I
don't have this set up to always force
the zeros to show up so that's the
reason why you only see one digit there
instead of three and that brings us to
the world of how signed integers are
represented inside of C now signed data
can make things just a little bit more
located and if you think about how
exactly we could represent a negative
number say inside of C we might say that
if we want to use the number three and
represent it in memory as negative we
could just put a 1 here and allow this
to be 3 and that is a very logical way
to actually represent negative numbers
inside of memory however that is not the
way that computers represent numbers
inside of memory computers instead take
say the number 2 which is what this
binary number here represents and they
use something that is called the two's
complement to get to the negative 2 what
they are going to do is invert all of
the numbers so if we have a zeros up
inside of here we are going to change
those into ones just as you can see
right here and if we have it one we're
going to change that into a zero and I'm
going to show you here in a second how
easy that is to do then to get to the
final negative 2 value we are simply
going to add 1 to this number right here
to get our final result and what's
really cool about this is if we want to
change from negative 2 back to positive
2 all we do is take our negative 2
representation in binary language which
is this up here we invert the numbers
just like we did before and we add 1
again and there you can see we're back
to 2 so I promised you an easy way to
perform this calculation so now I'm
going to show it to you and that tool
that we're going to use is called the
ones complement operator and all it does
is flips all the bits just like we
showed here before so what I'm going to
do is come in to this guy and I'm going
to call this one's comp solution and if
I want to change number 6
I want to invert it all I do get rid of
that altogether and throw a tilde in
front of it right like that now I can
come down inside of here I'm going to
throw a tilde inside of there just so we
can see exactly what's going on get rid
of this all together throw an equal sign
in there
call convert base number 6 so that we'll
be able to see what's going on here on
our screen get rid of this all together
don't need it leave that the same except
I'm going to take this guy right here
throw that in
out of their file save it and then just
so we can have a little bit more
information on our screen I'm also going
to say negative of D like this is equal
to this and then just so we can have a
little bit more information on our
screen I'm going to say negative of and
this is going to be number six but I'm
going to put a D inside of there it is
equal to and I'm going to get my ones
complement solution and I'm going to add
one to it so that you can see exactly
how this works here and then I'm going
to pass in number six like that and then
I'm going to go ones calm solution plus
one file save it compile and execute you
can see it printed out the whole entire
thing here but you can also see that it
basically just inverted all of those
numbers and then you can also see that
it all worked because I have negative of
six is equal to negative six so that's
how we're going to be able to convert
between signed integers and unsigned
integers now I'll do a little
explanation of exactly how shift
operators work and it basically they
just allow you to shift bits to the left
or to the right and there's positives
and negatives to doing that going to get
rid of this altogether here and this guy
right here I'm going to call shift left
to because that's exactly what it's
going to do and if I want to shift the
bits for number six all I'm going to do
if I want them to go to the left is just
put two of those little signs inside of
there and then put a two now I come in
here get rid of this tilde that two
equal sign
let this be number six just like it was
before here put an equal sign print out
a little bit more information than we
did before come in here say shift left
to come down here and then print out
shift left to on the screen compile and
execute and there you can see if we take
the number six and shift it left two
bytes that's what you're going to get
which is going to be exactly the same as
the number twenty-four so it's a
interesting way to be able to do all
kinds of calculations which we're going
to get into here at a later date and if
there is a way to shift to the left of
course there's a way to shift to the
right so I'm just going to change this
to right and then if I want to shift to
the right instead of shifting to the
left I just go like that change this as
well so it makes sense change that to
right and change that to the right file
say
execute and here you can say if we take
six and shift it to the right by two
spaces you get one which of course is
equal to one okay now let's take a look
at bit masking now basically bit masking
is used to select parts of a series of
bits that you have and it's very easy to
do basically what you need to do is use
a guy like this which is what we call a
mask and let's say I have this number
and I want to find out exactly what just
this bit this bit this bit in this bit
are what I do with my mask is I put a 1
everywhere in regards to the bits that I
want to retrieve and then I perform a
and bitwise operator on it and of course
it's only going to return a 1 if this is
1 and it's going to return a 0 if this
is a 0 and I don't need to of course
just take these on a row I can just get
this bit in this bit if that's what I
wanted to do so let's take a look at
exactly how that would work I'm gonna
get rid of a whole bunch of this
information just to get it out of our
way and we'll create a variable I'm
going to call it analyze my bits and I'm
going to make it equal to 170 which is
going to be exactly the same as 1 0 1 0
1 0 1 0 and then I'm gonna have two more
unsigned int I'm going to create a mask
here and make it equal to 15 and that is
going to have a value of 1 1 1 so what
I'm gonna do is I'm going to come in
here and I'm just gonna grab or find out
exactly what those bits are and
disregard everything else then down with
this guy right here let's say I want to
call it last 4 bits because that's
exactly what it's gonna get and then I
just take the bits that I want to
analyze throw them inside of there use
and on them and then click my mask at
the other end of it and in essence what
this is gonna do for me is take this guy
right here throw that in there take my
mask and then after that it's going to
return 0 for the things I'm not
interested in and then 1 0 1 0 for the
things I am interested in and to print
that information out what I'm gonna do
is go printf and say last 4 bit
and then I'm going to call my convert
base pass in last four bits convert it
into two or base two P converted number
compile and execute and you can see
there it is last four bits one zero one
zero so that's exactly how bit masking
works now for the final thing what I'm
going to cover is how to represent
fractions inside of binary because this
is something that confuses a lot of
people I'm going to keep this nice and
simple let's just say that we want to
represent 0.625 inside of binary numbers
how exactly would you do that or how
would they be saved inside of memory
well just to keep this nice and simple
let's just say that we have four bits
inside of memory and that is where we
want to save this information well what
we're going to do is we are going to
take our fraction and we're going to
multiply it times two and what we're
going to get whenever we do that is 1.25
we're then going to take the one part of
that and throw it over here then we're
going to take the 0.25 move it down
multiply it times two and we're going to
get 0.50 and we're going to take this
zero right here and throw it over into
memory then we're going to take the 0.5
Oh
move it down multiply it times two then
we're going to take this one and throw
it over there and now since we no longer
have anything to multiply times this is
going to be the representation of our
fraction inside of memory now sometimes
things don't work that well of course we
have things in the world called infinite
fractions now we are going to have
things like point one and whenever we
multiply that times two we're going to
get point two and the binary
representation for that would be zero
and then we take point two which is
moved down from here multiply that times
two then we're going to get point four
then we're gonna have zero zero in
memory and we're going to take the point
four multiply it times two and so forth
and so on and you can see right here
eventually we get a 1 well this is one
of the reasons why most programming
languages have trouble in regards to
precision in regards to fractions like
we saw in the last part of the tutorial
everything works out whenever we
have infinite fractions but when we do
have infinite fractions we can run into
trouble and now for your homework take
all the information that I showed you
right here in regards to binary numbers
write a function like that and leave any
questions or comments below otherwise
until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>