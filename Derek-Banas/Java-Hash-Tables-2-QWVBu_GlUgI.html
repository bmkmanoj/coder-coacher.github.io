<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Hash Tables 2 | Coder Coacher - Coaching Coders</title><meta content="Java Hash Tables 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Hash Tables 2</b></h2><h5 class="post__date">2013-03-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QWVBu_GlUgI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
11 of my java algorithms and data
structures tutorial today I'm going to
cover part two of my coverage of hash
tables if you didn't watch part one
definitely watch it otherwise you'll be
confused because I use a lot of code
from that tutorial in this tutorial and
I also provide a link to the entire job
algorithms playlist above so what are we
going to cover in this tutorial well
we're going to cover why we should use
primes when constructing our hash tables
I'm going to cover how to increase hash
tables size even though I said that
should be avoided in the last tutorial
I'm going to show you what is and how to
avoid clustering how double hashing
works and how to find values in a double
hashed hash table so I have a lot to
cover so let's get into it so why should
we use primes well previously to
calculate what index we are going to put
our values in we just arbitrarily use
the value that was stored and that we
wanted to put in our hash table and got
the modulus using an arbitrary array
size you're going to see in this
tutorial why it is better for the array
size to be a prime number the main thing
we want to do is try to avoid collisions
and a collision occurs when if we try to
put an item in an index in our hash
table that already has an item inside of
it and collisions mainly occur when we
are trying to store similar data and in
fact if we have n values that we are
trying to store in our hash table that
are similar this is going to cause n
times as many collisions so instead
we're going to use a prime number for
the array size to help minimize
collisions so let's take a look at that
code so here is code from the previous
tutorial and I'm going to on purpose try
to cause collisions remember our array
size is 30 and I'm going to put
multiples of 30 inside of this data here
that I'm gonna try to stick in a hash
table and I'm just using the previous
code that we had before and I'm just
gonna go the funk and then go into this
guy and go hash function to and then
strings for array I'm gonna stick
elements to add three inside of there
and then the array can be the exactly
the same as it was before and then here
we're going to go the funk dot array and
execute and you can see it went and
built
gigantic array now we're using bigger
arrays in this tutorial but you can see
here it is trying to put the item 30 in
index zero and it's trying to put the
item 60 in index zero as well and you
can see immediately we have a collision
and very often whenever we're just using
random data it is amazing how often we
get into a situation like this where we
just have one collision after another
because very often things in the real
world follow patterns and those patterns
that are followed are normally not prime
so now let's look at what would happen
if we just simply change the array size
to 31 which is a prime number and
execute now we're going to see all of
these guys automatically just go right
into the right place without near a
collision until we get way way down here
near the end of the point where we'll be
putting values inside of our hash table
and this is even whenever we are using
an array that is only 31 spaces in size
and we're trying to put 30 data items
inside of it so you can see right there
immediately just how good of an idea it
is to use prime numbers so that brings
us to how are we going to be able to
increase our hash table size because we
find ourselves in a situation where we
want to put thirty items into a thirty
item hash table we'd like to increase
that to 60 and I'm going to show you
exactly how to do that basically what
we're going to need to do is find a
prime sized array that is going to be
bigger than the array size that is
requested based off of what I just
covered then I'm going to store the
values in the current array and then
eliminate any empty spaces because we
now have a different array size which
means that the calculation this guy
right here which defines in what index
each element is going to go into well if
array size changed that means this
calculation needs to be done again
that's the reason why we want to get rid
of all the empty spaces then we want to
increase the size of our current array
and then use a hash function to fill the
newly sized array with the original
values so let's take a look at that code
alright so we're back inside of here
again and we're just basically going to
do all the things that I just talked
about and all the code in this video
available to link underneath the video
so one thing that I'm definitely going
to want to check is whether a number is
prime so I'm just actually going to come
in here and create myself a function or
an algorithm that is going to tell me
that so it's going to receive a number
have it set as is Prime and then the
first thing I want to do is eliminate
the need to check for even numbers so
that's going to be very easy and that's
going to immediately cut out half of all
the numbers that I'm going to have to
search for just do this and if that
comes up positive then just do a return
false that that's not a prime number
they don't want to check it against all
the odd numbers after 2 so I'm going to
go for int I is equal to 3 I times I
because we're only going to be checking
odd numbers is less than or equal to
number and then I want to increment I by
2 and now after I do that to check it I
just go if number modulus I is equal to
0 in that situation I'm going to return
false because I know that this is not a
prime number otherwise if we get outside
of that for loop I know that I can
return true that it indeed is a prime
number well then what I want to do
because remember I'm increasing the size
of the array and I want to use this guy
up here to define or make sure that I
have a prime number array size so that
means I'm going to need to receive a
number and then return the next prime
that follows that number and to do that
I'm going to go public int and let's say
I want to call this get next prime and
it is going to receive the minimum
number to check which means they're
going to send me the minimum array size
that is needed and I'm going to give
them a prime that is above that and to
do that I'm just going to go int I is
equal to minimum number to check and I'm
gonna cycle through this for as long as
it takes to find a prime number and
because I made the is prime function
this is gonna be very easy I'm just
gonna go is it a prime number meaning I
and if it is I'm gonna return I and if
not I'm going to continue to cycle
forever until I find a prime number
because I know one's coming eventually
so now let's change that remember our
goal here is to increase our array size
and get all the old data
the new one so that means I need to
increase my array size to a prime number
of course and to do that very simply
increase array size is what I'm going to
call this and it's going to I'm just
going to use min array size here and
then I want to come in here and get a
prime number that's bigger than the
array that is requested array size and I
can use my previous functions that I
created and pass over minimum array size
to get that then after that I want to
move the array into a bigger array with
the larger prime size and I'm gonna do
that by creating another function called
move old array and pass in new array
size into it so I'm trying to keep my
methods here as short as humanly
possible so what's that mean that means
I need to create move old array so let's
just keep on going here
public void move old array int I'm gonna
call this new array size I'm gonna need
to create an array that has all of the
values of the array but no empty spaces
so to do that I'm just gonna create
another string array and let's say I
want to call this clean array and I want
to remove empty spaces in array and I'm
gonna create that here in a second and
I'm gonna pass it whatever the array is
currently have it clean everything up
for me then I need to increase the size
for my array so my array is called the
array I'm gonna say new now that I have
a copy of everything that's in the array
new array size I can change the array
size for the array that I'm using here
and then of course I'm going to have to
say the array size and also have it set
for new array size if you can't remember
this is all the stuff that I'm changing
right here so that's what I'm changing
scroll back down well then I want to
fill my array with negative one so I
just go fill array with neg one just
like that and actually created this guy
ahead of time that's just down here it's
very very simple say fill array with
negative one and it's just going to take
the array and stick negative one in
every single one of the spaces that's
all that's doing so come back up here
they don't want to send the values
previously in the array into the my new
larger array and I'm just going to
used my hash function to just like I use
the four pass into it clean array which
is going to hold all the values that the
array previously had and the array is
going to be the guy that's going to get
all those new values hashed in so that
means I need to create this method right
here
remove empty spaces in array so really
simple public string it's going to
return a string array moves faces in
array and it's going to get a string
array passed into it array to clean so
I'm gonna name this guy and then what
I'm gonna do is create an array list
it's gonna hold strings I'm just gonna
call this string list it's just gonna be
a temporary holding cell is equal to new
ArrayList which is a string right like
this so I'm covering a whole bunch of
things I'm cover for importer a list so
that I have that library then what I
need to do is cycle through the array
and if a space doesn't contain negative
one or isn't empty I want to add it to
my ArrayList so I'm just going to go for
string I'm just going to call this the
string this is an enhanced for-loop
array to clean and then inside of it I'm
going to go if remember I want to find
out if it's equal to negative one
because all the spaces that don't have
anything inside of them are going to be
equal to negative one so I'm going to
say equals negative one and not equal to
and then I want to go the string and I
threw this in here just for the heck of
it to delete anything in the array that
didn't have anything in it even though I
know that that really shouldn't you know
happen because I stuck negative ones and
everything and then I'm gonna go string
list add the strength so in essence I'm
getting all of the strings that actually
have values and I'm going to come up
here and put a ray to clean inside of
that and now that I have that all set I
can just go return string list because
the string list is going to have all the
values that I want so I just need to
return a string array and to do that
just go string list two array and then
go new string and then I have to say how
big it is which is just going to go
string list size like that and there you
go and that's going to remove my empty
spaces in my array and then pass it back
to this guy right here now I could back
up inside of main whatever that is
there we are
then with this I can just go the funk
dot and if I decide to increase my array
size I can do that to anything really
but let's say I decide to change it to
61 or actually let's change it to 60
just to show that it will change it into
a prime and we can leave everything in
exactly the same so let's try it and
there you can see it automatically went
and put a 60 item array inside of this
or a hash table whatever we want to call
it and all the same values are inside of
this guy that we're previously inside of
our other array so that is how you
resize an array or a hash table just
keep referring to them as arrays because
I think they're easier to understand so
now let's get into the next part of our
tutorial next thing we want to do is try
to avoid clustering now clustering is
going to occur because if there is a
collision we just based off of what we
did in the past just move to the very
very next index and then put the value
inside of that the only problem with
that is is each time this occurs it
increases the likelihood or the chance
that will later hit one of those big
clusters when we try to put another
value in and that's reason why you start
having arrays where there's literally
nothing in one part of the array and
another part of the array where
everything's all bunched up that is bad
and that is to be avoided so let's jump
over here and figure out how we are
going to eliminate that and one way to
eliminate it let's scroll down through
here in essence we're going to use this
guy right here we're just going to
change a couple things so I'm actually
going to copy the hash function that
we've been using in the past because
almost everything is exactly the same
and then I'm going to bounce up here I'm
going to put in my new version that's
going to avoid clustering what we're
going to be doing here is what it's
called creating a double hash hash table
so I'm going to call it double hash
function and we're basically going to be
staggering it so that it rather than an
item going into the immediately next
index whenever it hits a other item or a
collision occurs what we're going to
instead do is randomize the index that
we try to insert into so like I said not
many things going to change we're still
going to use this for loop we're still
going to store the value that we need to
put inside of there in turay this guy is
also going to stay exactly the same
but the one thing that we're going to
want to do is change the step or the
step distance to get the distance to
skip down in the array after a collision
occurs to a other random index and we're
going to do this of course to avoid
creating clusters just like I said so
I'm just going to go int step distance
and let's say I put 7 sometimes you
might want to put 5 but you're going to
want to put a prime number inside of
there and I'm going to go parse int and
just like before go new element value
you want to get the value and then after
this I'm going to go modulus 7 so it is
basically going to move it either 1 2 3
4 5 6 or 7 steps down in other indexes
rather than just picking the next index
and of course put the equal sign in
there and then now we can just come down
through here let's just copy step
distance this is all going to be exactly
the same the only thing we're going to
change here is the array index and
instead of just simply incrementing it
we're going to instead put the stepped
instance inside of there that is going
to be random and everything else can
stay exactly the same and now we can
scroll up inside of here and try this
guy out and let's actually put it after
this previous guy and here we're just
going to go the funk and then we're
going to get the double hash function
which we just created we're going to use
the same exact thing that we had right
here and throw it in here instead right
like that and then we can display now
because the array is it really really
big like it should be you know get to
see much difference but you're
definitely going to see a difference in
the amount of clustering and another
thing we're going to want to do here is
zero out this array before we try to
fill it again and we're going to do that
by calling that method right there
alright now we can execute it and now
you can see if this is the very first
array that was created without the
double hash you can see there's a
cluster there there is a massive cluster
right there with all this empty space
that's up here and then there's all this
empty space here and all this empty
space here there's a lot a lot a lot of
empty space and then there's another
massive cluster that actually goes over
two rows now we can see our double hash
and you're going to see that the
clusters are
smaller yeah there's still some clusters
here we can help get rid of those by
both either increasing the array size or
by changing the number from seven to
five some of those different things or
work a little bit better but that is the
basic idea behind how we would try to
avoid clustering by using a double
hashed hash table and what I mean by
coming in here and changing the values
from seven is this guy right here like
maybe five would work better for it and
this is the guy that's going to define
our step distance and we could execute
that you can see and we still have some
clustering going on here but that's
something we want to play with and
that's also a good point that our array
should be at the minimum twice whatever
the number of values we're going to put
in and that should never be considered
the maximum or the ideal array size so
now that we change that so dramatically
we're going to have to figure out a
different way to find values inside of
here and oddly enough that's not going
to change that much either
we're going to get our original find
method that we created inside of this
guy and we're just going to change a
couple little things inside of here not
many and I'm just going to call this
find key and let's say double hashed
everything is going to for the most part
stay exactly the same except we're going
to need to calculate step distance of
course so let's just come in here and
copy this because we're going to need it
and we're just going to paste that in
there so that we'll be able to find the
keys that were originally used to
calculate step distance and the only
thing is going to change here is we're
going to take this guy right here and
come down there and replace it with that
which is the key this isn't going to
change right here we're still searching
for negative one this isn't going to
change right here in fact none of those
different things are going to change the
only thing is going to change your step
distance because that is the only thing
that needs to change and we're going to
make that change right here and we're
just going to increment it by step
distance right like that and everything
else can stay exactly the same scroll
back up inside of main and then to test
out this function just goes off func and
then I'm going to say double hash
function and I'm going to come out
here and I'm going to go find key double
hashed right like that then I want to
put a key inside of there so let's try
989 which I know is inside of there
paste it in save it and execute and you
can see 989 was found in index 13 and if
we scroll up here you can see that 989
indeed was found in index 13 so there is
a ton of additional things you can do
with hash tables I'm going to try my
best to finish off everything else you
can do with hash tables in the next part
of the tutorial please leave any
questions or comments below otherwise
till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>