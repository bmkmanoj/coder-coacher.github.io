<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Haskell Tutorial | Coder Coacher - Coaching Coders</title><meta content="Haskell Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Haskell Tutorial</b></h2><h5 class="post__date">2015-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/02_H3LjqMr8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to my
Haskell video tutorial in this one
tutorial I'm going to cover a vast
majority of what you would read in an
average 300 to 400 page book on Haskell
and I'm going to have a special emphasis
on lists and functions and more
importantly those things that confuse
people about Haskell I've talked to a
lot of students I know what confuses
them and this tutorial I'm going to try
to make everything very clear just so I
can go over this quickly Haskell is a
functional programming language and
everything in it is immutable so once a
value is set of course it's going to be
set forever
functions can be passed as a parameter
to other function recursion is used very
often
oddly Haskell has no for while or
technically variables but it does have
constants and even though it doesn't
have those things it still is able to do
quite amazing things Haskell is also
lazy and that it doesn't execute more
than as needed and instead just checks
for errors whenever you compile and the
compiler is very very strict and does
its best to cut out any potential errors
Haskell like Lisp in my opinion is a
great language to learn if you want to
get better at programming just aside
from the fact that it's a great language
so enough talking let's jump over and
I'll show you how to get everything you
need to install it okay to install
Haskell or the compiler we're going to
be using we're just going to go to
haskell dot org /downloads and then
you're going to come over here and
you're going to pick either Windows OSX
or Linux and everything is going to
install for you just have to click on
this install it and windows users you
might need to put a path to the compiler
in your path to get everything to work
in your command line and that is
basically all you need just wanted to
let everybody know there is a great book
online and it's free and it is called
learn you a Haskell for a great good a
lot of what I did here I work with some
students that went through this book and
what I'm trying to do in this tutorial
is both cover everything that's in this
book however I didn't use it as a guide
I instead use the problems people had
with this book to try to make Haskell
more understandable but once you watch
this video this is a great book and
everything should be very clear and you
be able to go through it and of course
this is not a sponsored link so enough
talking let's write some code okay on
the left side of screen I have a basic
text editor this is text Wrangler if
you're on Windows use notepad plus plus
or something like that on the right side
I have terminal or if you're on Windows
use command line everything the ear
regardless of what OS you are using is
going to work exactly the same now what
you're going to want to do first in your
text editor is create a file name
whatever you want but make sure it has
the extension dot H S at the end of it
and then we're going to come over to our
terminal and we're going to load gh CI
which is going to allow us to compile
everything so I'm just going to type in
GHC alright and there we go everything
is loaded and ready to go on the right
side of my screen I'm also going to load
this program over here which doesn't
have anything into it and I'm just going
to type in colon l and I'm going to type
in Haskell - Tut because that's the name
of it and now we'll be able to use
everything inside of it and we're going
to be running everything just by going :
R and that's going to run everything on
the screen you're going to see that a
dot first thing I'm going to do inside
here well if we want to have comments
inside of our Haskell code we just put a
dash - comments like that if we want to
have multi-line comments we put a curly
brace and a dash and then and then close
that off with another dash and a curly
brace so there you go those are the two
ways that you can comment in Haskell
we're going to import some modules and
modules are just a whole bunch of
functions we're going to be able to use
so we're just going to go import data
dot list and import system dot IO so
those are the only two modules we're
going to be importing now I'd like to
talk about datatypes
now haskell uses type inference which
basically just means that it decides on
the data type based off of the value
that you store inside of it however
you're also able to define what type of
data and you're going to see that here
in a minute
Haskell is statically typed which just
means that once you define a type you're
not going to be able to switch it and
I'll just go through a couple of the
different types we have here first off
we have ants which are whole numbers of
course and your minimum number is going
to be negative two two
power 63 and your maximum number is
going to be 2 ^ 63 so there's an int and
you could actually check the maximum
size let's go max int there we defined
or constant here and let's say that I
want to get the maximum size for it and
I'll be able to jump over here now and
run this and then go max int and you're
going to see the maximum size integer
that we have here and you could also do
the same thing by coming in and doing
men bound and changes to men just so
it's not confusing our and men int and
there is the smallest number you'll be
able to use in an INT like that there's
another type of integer as well and it
is just defined as integer and this is
what you're going to use most of the
time and this is actually an unbounded
whole number which means that it can be
as big as your memory can hold so huge
and you're going to see examples later
on on exactly how that's going to work
we also have floats which are single
precision floating point numbers but for
the most part you're going to use
doubles for anything that's going to
have decimals inside of it and this is
going to have precision up to 11 points
and I can demonstrate that all
programming languages come to a fault at
some point in time whenever you're using
floats so this isn't anything specific
to Haskell
so we could go there's 11 and then
always put a 0 in front of any of your
floats that don't have any other whole
numbers inside of them and then we can
go big float and see that everything
adds up perfectly well but if we put in
another point of precision inside of
this guy and you're going to see things
get a little bit wiry there so just an
example of how we're going to be able to
use precision with our floating point
values other data types include bull
which is either going to have a value of
true or false you're also going to have
characters which are going to be single
Unicode characters and they're going to
be denoted with single quotes then
you're also going to have two bulls
which can store lists made up of many
different data types however for the
most part when you're using tuples
they're only ever going to contain two
values and you're going to see more
about why that works
that way later on you can declare a
permanent value of a variable like let's
say we're going to go always 5 just by
going like this and saying that it's
going to be an INT and then we could of
course go always 5 is equal to 5 and of
course that's never going to change and
of course we can come over here and it's
going to print out 5 if we ask it to
print that so that is the basics of
datatypes
at least that we're going to cover here
at this point with Haskell now let's
take a look at some math functions one
thing it's really crazy let's just go
into a little example here some of nums
is equal to we could come in here and
some a whole bunch of different values
so let's say we wanted to sum 1 through
1,000 that is how easy it is to do and
you can see just that quickly and with
that one line of text we were able to do
that you're going to see a lot more in
regard so this is a list right here by
the way and it automatically generates
values from 1 to 1000 we'll get more
into the power of lists here as we
continue we're also going to be able to
perform basic mathematical calculations
here so let's say we wanted to come in
and do 5 plus 4 and of course there is a
cheat sheet in the description as well
as time stamps they will be able to jump
through this tutorial and pretty much
learn whatever you want and the amount
of time that you want to a lot to this
tutorial so take a look at that as well
so we come in here and run this and of
course we'll be able to go a DX and it's
going to pop that out there on our
screen another thing it's important to
know however is that there are prefix
operators so let's say we wanted to get
the modulus of a division which is just
the remainder but we would either go mod
and then 5 4 like that and this is
called a prefix operator because it
comes pre to the actual numbers that
we're going to be passing into it this
is just a function that's all it is you
could however add back ticks to this so
let's say we wanted to go on e^x 2 and
then go 5 and then back ticks this is up
where the tilde symbol is mod + 4 to get
exactly the same results and you can see
right there it returned 1 because that
is the remainder of that division and in
this situation this is called an infix
operator because it's in between these
two numbers pretty easy to remember
another thing that's important to
remember
about Haskell this is one of the weird
things about Haskell is if we wanted to
do an edition with a negative number
we're actually going to have to come in
here and put parentheses around it to
figure that out because it would get
confused if this is the subtraction
operator or not so just one of the
couple different weird things about
Haskell the thing that's interesting is
let's say we want to do a square root
well we could come over here and put
colon and T and take a look at exactly
what's going on with the square root
function just that way and this is very
important to understand right here
basically what this is doing is it's
planning on working with floating-point
numbers very important so that means if
you want to use integers here we're
going to have to do something special
which I'll show you in a second it's
going to then receive a value and then
pop out a value from that point on and
don't let that bother you if that sounds
confusing I'm going to give you examples
tons of examples that all this is going
to make a lot more sense so what we're
going to do here is let's define a
number nine and give it a value of nine
and we could say that this is an INT
just by putting in those Col ones like
that and then int and then go square
root of nine is equal to and then we
could go square root but because this is
planning on working with floats we are
going to have to convert it to a float
easy enough just go from integral like
that and numb nine I'll be able to come
over here and you go to square root of
nine and you can see that it gives us
the square root of nine pretty simple so
if you want to ever need to convert from
integer to a floating point integer this
is or a floating-point data type we're
going to use from integral here are also
a couple of other built-in math
functions there's a ton of them but
these are some of the ones that might be
really important so we can get PI just
by calling for PI like this or exponents
or logs we'll be able to do square or
get the power of different values we'll
be able to truncate values and we can
just come in here and go like this you
can see right there that it converted
nine point nine nine nine nine nine down
to nine you can also come in here and
see how rounding works which is going to
be rounding up of the value and ceiling
is also going to round up as well as
floor is going around up
and here's a whole bunch of other
different functions that are available
inside a Haskell pre-built in we're also
going to have a whole bunch of logical
operators we can go something like true
and false equal to and we're going to
use upper case T or Yui and then we can
go and false to get those values and we
could also go true or false like this
and in that situation this is going to
be the or symbol very much like most
other programming languages and if you
would want to get not equal to you could
just go naught and true inside of it
like that and of course we'll be able to
come over here and say something like
true or false and get the value of true
I'm sure you understand exactly how that
works I'm going to come back again let's
take a closer look at how we're able to
add addition with the addition function
we have here again we're just going to
put colon T and again you can see right
here the way this operator is going to
work is it's going to receive two
parameters right like that and it's
going to return an outside value so
anytime you get confused about how a
function works or the type of data types
that we're going to be using it also
says that we expect nums which are going
to be either doubles floats intz or
integers so that's all that's going to
work with you can see here a lot just on
this one line just by putting in : t and
you'll be able to learn a lot about the
different functions so anytime you get
confused just check that out
you can also say let's say we wanted to
do truncate just to see something a
little bit different you can see right
here that it expects an a value which is
going to be a real fraction which is
going to be a decimal value and it's
going to return an integer and you can
see how the a is match up right like
that and the bees match up with this guy
right there now let's take a look at
lists which are very very important
inside of Haskell
now listen Haskell are singly linked and
you're only going to be able to add to
the front of any other list not going to
be able to just jump around willy-nilly
but that's not really going to cause any
problems so let's say we just go and
create a list this is very easy to do
we'll just come in here and let's say
prime numbers 5 7 and 11 there you go
you just created a list now you're going
to be able to
concatenate these lists and how we're
going to be able to do that is go prime
numbers and then concatenate with two
pluses and then you could just come in
here and throw either a lists name
inside of here or you're going to be
able to type in a list itself and you
can see the entire list printed out on
the screen you're also going to be able
to come in here and use a cons operator
to construct a list this is very
important to understand it's very simple
but it's going to come up a lot later on
what we're going to do is put a colon
between each of the list items that we
want to combine and then we're going to
put an empty little guy there at the
very end which is going to show that
that's the end of the list and there you
can see our list has been created so
remember this guy this is a way to
combine numbers into a list this is one
of the things that confuses people
whenever they forget it so just remember
that guy if you print it out the cheat
sheet you might want to highlight it
just so you can refer to it later of
course we're also going to be able to
put lists inside of Lists 3 5 7 put a
comma between it and there you go and
remember I said you can add values to
the front of a list so let's say more
primes 2 is equal to and what are we
going to use the cons operator we're
going to put 2 in front of more Prime's
right like that we can come in here and
get the length of a list of course put
this on the next line just by going a
length and then whatever lists you want
to work with and you can see I got a
little bit of an error it's just saying
not in scope you're going to see not in
scope a lot that just means that it
can't locate this name and the reason
why is I had it called more prime let's
just call it more Prime's and now it's
going to work and there you can see it
compile and there you can see that we
have 10 values inside of that list don't
worry when you're using Haskell you're
going to get a lot of errors because the
compiler is very very strict and safe
Haskell is considered to be an extremely
safe language we could also come in here
and reverse our list very easy first
prime equal to just by typing in reverse
more Prime's - we could also come in and
check if our list is empty just by going
null or primes 2 is less tempting comes
back as false of course we would be able
to come in and get specific index values
for it so let's say we wanted to get the
second prime inside of our list we
justgo more primes - like this -
exclamation marks like that and then
we'll put one because the first index of
course is going to be zero and then
second prime and you can see three comes
back we're also going to be able and
this might seem unimportant but you're
going to use these functions a lot so
you're going to be referring to this
part of the cheat sheet a lot whenever
you're writing programs so let's say we
wanted to get the first value we just go
ahead and if we want to get the last
value we could just go inside here and
go last and last Prime and you can see
29 comes back from there we're also
going to be able to come in here and get
everything but the last value by going
prime and knit this and you can see it
popped out everything except for the
very last value in our list remember our
last let's just do it last prime is 29
so there you go we're also going to be
able to come in here and get the first
three values or whatever you want just
by going take three first three Prime's
pop that back we're also of course going
to be able to return values left after
removing specified number of values so
we can go removed Prime's is equal to
and drop three move Prime's and you're
going to see it's going to give us
everything except for those first three
values that we asked for we're also very
easily going to be able to come in and
check if a value is in a list so we'll
say is 7 in list is equal to 7 and again
we want to put this in the middle so
we're going to make this in flick so
we're going to put a backslash like that
or a back quote and then we'll go more
times 2 again and we'll be able to say
is 7 in less and you can see true comes
back from that there are tons of
functions like this we're also going to
be able to come in and get the maximum
value so let's say we want the maximum
prime will just go maximum like that and
likewise we're going to be able to do
the same thing with the minimum front
for our list
max Prime's 29 min prime is going to be
2 I already shows you how to get the sum
of all the values you're just going to
put some before it and assign it to some
variable or constant we're also able to
get the product of values in a list and
the product of course if anybody doesn't
know is just the value all can evenly
divide by
so let's go and create a new list here
just to keep this simple and we'll say 2
3 &amp;amp; 5 is our list if we want to get the
product product primes equal to and just
go product new list now you can see it's
30 just to reiterate here we're going to
be able to generate lists so we'd say we
want a list generated from 0 to 10 we
just go 0.10 and there you go it's
automatically going to calculate that
for us what's really cool is we could
even come in here and let's say we
wanted a list that's just made up of
even numbers we could come in here and
define the step between all the
different values by going to and then 4
and then dot dot 20 that's going to
generate an even list let's come in here
and show you exactly how that works
even lists and there you can see
generated that for us automatically
we're going to be able to do all kinds
of cool things with lists we could even
come in here and generate character
lists so let's say we wanted to come in
and do a and it we also let's step
through here let's say we want to just
have every other letter we could do that
dot dot see very powerful list functions
inside of Haskell and there you can see
every other value popped out there for
us another thing it's kind of cool is
we're actually going to be able to
generate an infinite list with Haskell
however it's it's only going to ever
calculate or create the list up to what
you need whenever you need it and that's
what we talk about when we say high
school is lazy so it's basically going
to just define that yes indeed this is
going to be an infinite list and there
you go just don't put a ending value
this indeed is a list that is going to
go on forever however it doesn't have
any need to create it until we need to
let's say we want the 50th item in this
list then it will generate the list up
to that 50th item but it will never go
beyond that cause of course that
obviously can't create a true infinite
list but it does give you the power to
you work with numbers that are extremely
large
we also would be able to come in here
and repeat a value a defined number of
times so let's say I'm going to go many
twos and let's just say we want the
first 10 values and this is just going
to repeat to forever and ever until we
tell it we don't want any
so many tubes like that whoops make sure
you are that many twos and there you can
say generated ten to is for us in that
list all this stuff doesn't seem
important but it will be important
whenever we're trying to work with all
kinds of ridiculously awesome functions
like you're going to see later on
replicate is also going to generate a
value a specified number of times so
let's say we go many threes we could
also go replicate and then ten and three
like that many threes you can see it
generated 10 3's for us also cycle is
going to replicate the value in a list
indefinitely so let's say we want to
take the first 10 values and then we'll
call for cycle fess and 1 2 3 4 5 like
that cycle list you're going to say say
it repeated those items over and over
and over again and of course we're going
to be able to perform different
operations on all values in a list so
let's say we want to multiply a whole
bunch of different items in a list by 2
well we can just say list times 2 just
keep that simple and what we're going to
be able to do is define inside of here x
times 2 this is the operation we want to
be able to perform over and over and
over again put the or symbol inside of
there and then what we're going to say
is we're going to pull a value out of
our list we're going to temporarily
store it inside of the value of X we're
going to multiply it times 2 and then
we're going to create a new list called
list times 2 from that list so let's say
we want to ball and apply every value
from 1 to 10 and then create a brand new
list we can do that
this times 2 and there you can see that
was how easy that was to do we could
also come in and filter these results so
let's say let's change this to 3 just
the 3 now we're going to be multiplying
everything in a list by 3 and then let's
say that we only want multiplications
times 3 that are going to be less than
or equal to 50 we just put that little
column in there and that's going to give
us our results for that so say list
times 3 and there you can see gave us
all the values by those values less than
50 or less than or equal to 50 in this
situation and just to create something a
little bit
call and diluted let's say let's divide
visible by nine and thirteen that's a
really crazy name but we're going to
come in here and we're going to say X
value of X that's going to go into the
new generated list called this
convoluted crazy name and we're going to
be pulling the x value out of our list
and our list is going to be made up of
numbers between 1 and 500 and then let's
say we want to filter these guys so we
only want values in which X modulus of
13 is equal to 0 so we only want values
that are going to be divisible by 13 and
this generated list 1 2 500 right there
and then if we want to put in another
filter we could just go X and let's say
that we only wanted modulus of 9 which
is going to be equal to 0 so we want to
go through a list from 1 to 500 and we
only want values in which they are
divisible by 13 or divisible by 9 and we
want to come in here and automatically
generate that list for us no problem
paste that in and there you can see from
1 to 500 these are the only numbers that
are both divisible by 13 and 9 so we can
do all kinds of crazy filtering inside
of haskell it's really cool and
extremely powerful we could also come in
and create a sorted list so let's go
sorted list is equal to we're just going
to type in sort and then we could type
in whole bunch of things that are out of
order sorted list
and there they go now they're in order
another thing you're going to use a lot
is if let's say we want to combine lists
well we could go sum of lists like this
we could also go zip with very powerful
function and let's say that we want to
add all the values create a new list
based off of the values in these lists
so there you go and there we are some of
lists and there you can see it went and
added all these different values and
then created a brand new list called sum
of lists
zip with is very powerful we're going to
see more about it later on we could also
use filter return a list of items that
match a condition so let's say we want
lists bigger
then five equal to and there's filter
and we want values that are greater than
five and will you just go more primes or
whatever we have here and there you can
see that pop that back and we can also
use a sort of while loop so let's say we
wanted to go and get the evens up to
twenty we're going to use the function
called take while so we want values that
are less than or equal to 20 and then we
can use an infinite list in this
situation so you can see exactly how
these infinite lists work up to 20 like
that and you can see it automatically
generated that and that's one way that
we can use or demonstrate how haskell is
lazy went and created the list up to 20
it created this list right here and even
though this says infinite it didn't go
beyond that so another example of what
lazy means in haskell then the very
final thing i'm going to talk about here
or fold l what fold L is going to do is
it's going to apply an operation on each
item of a list so let's say multiple
lists and you can go equal fold L and
the operation we're going to be
performing is a multiplication and put 1
here and then 2 3 4 and 5 and what it
did what does it went through all these
different list items from left that's
what the L part means here to write and
multiplied them all together and you
could also come in here and change this
to R if you want to go in the opposite
direction so like this and you can say
it came back to exactly the same thing
because it didn't really matter but that
is our fold L which does the operation
from left to right and fold our work
which does the operation from right to
left in some situations things will be
different but those are the way that
those two guys work so there's a lot
about lists I just want to take a second
here and talk a little bit more about
list comprehensions that are very
important which we've seen a little bit
here already now by list comprehension
all I mean is we were going to be
performing certain operations on a list
so let's say that we going to go and get
power of 3 for our list all we're going
to do is put this inside the brackets
and then we can go 3 n where the N part
is going to be the list items so just
want to make sure you really understand
this is very
concept so there we can go 10 close that
off and what we're doing here is we're
generating a list called power three
list it's going to take each of the
values out of our list here one through
ten store them inside of there perform
this calculation storm back inside of
there just going to touch on this in a
second power three lists and there you
can see it calculated those for us and
of course we can apply filters like you
saw previously and just for the heck of
it let's do another example let's say we
wanted to generate a multiplication
table by multiplying different values in
different lists so what we do let's go
multiplication table is equal to
brackets here and we're going to
multiply x times y and then we're going
to define the value of y like this we're
going to be able to stack these up and
use multiple lists in these calculations
so the value of y is going to be one
through ten and then the value of x for
our calculations inside of here is also
going to be one through ten close that
off and it's going to generate a new
list called multiplication table and we
can go to mall table whoops mult table
and you can see it went in there and
created that multiplication table for us
so pretty cool so there's a whole bunch
about lists and believe me we're going
to come back more to it here very soon
but let's talk up second about tuples
which are also very important they're
just basically are going to store a list
of multiple different data types a list
every item has to have the same data
type a tuple that doesn't necessarily
have to be true so we can come in here
and we go random tuple like this and
then throw a one inside of there and
then go random tuple like that and there
you go you just created yourself a tuple
now what we're going to be using a lot
or what are called tuple players so
let's go and create Bob Smith here go
Bob Smith and let's say that Bob Smith
is 52 there you go you just created a
tuple pair for our Bob Smith information
now we're going to be able to get the
first value out of our tuple so let's
say we wanted to get Bob's name by just
going FST and Bob Smith and equally
we'll be able to get Bob's age by going
aesnd like this and Bob Smith and Bob's
name
and Bob's age there we go another thing
it's really cool so we can use zip and
what it's actually going to do is
combine values in two different lists
into two pairs for us so we can go
something like names and then come in
and create addresses and then we could
go names and address and use zip to
combine those into tuples
so we'll go names addresses with zip
names and address and look it created a
whole bunch of tuple pairs just by
combining those two list items very
important zip very very important we're
going to see more about zip in a second
so I've been talking a lot about how
Haskell is a functional programming
language but we haven't really created
any function so that's what we're going
to do right now another thing we can do
is we can use let over here in the GHC
till you could say something like num 7
is equal to 7 and then we could go let
get Triple X and create a function here
and then the value is going to be X
times 3 in this situation and then we go
get triple num 7 and you can see we can
do calculations over in the GHC as well
another thing that's important is if we
compile our program we're actually going
to be able to run it if we define
everything in main so let's go main and
then we're going to go do and what do is
going to do is it's just going to chain
a whole bunch of different commands and
store them inside of main so let's say
we want to do something like print a
string out we could go put string Ln
like that and go something like what's
your name and this is going to put a new
line at the end of it put string with
that Ln at the end of it then we could
go name and then we're going to store
the value that they enter to name with
this arrow symbol right here and get
line so that's going to take information
from the console and then we could go
and print out information again to the
screen and say something like hello and
then if we want to concatenate or
combine these we can do it just like
that
now we can come over here jump out of
this guy and we would just go colon and
a Q and there you can see we just left
and then we go GHC like
this - - make like that and then Haskell
- cut which is the name of my program
you can see that it compiled for us
there and then Haskell Tut Larry like
this what's your name
Derek and you're going to see that it
printed that out in the terminal or if
you're in Windows the command line so
let's get out of that and let's get back
into the GHC I and there we are back
inside of there and let's create a whole
bunch of other different functions so
that's how we input and output
information and compile things now what
we're going to do is we're going to
create a function that I'm going to call
add me now what you're going to do here
is you're going to define the type
declaration for your function just like
we did whenever we were typing in things
like : t so with the square root like
that that's a type declaration so let's
create one for adding me so it's add me
and it's going to be receiving an
integer and guess what another integer
and then it's going to be returning an
integer okay pretty simple in the
function name the way that's going to
work out it's just going to be the
actual creation of the function it's
going to be whatever you name your
function and it's going to be any
parameters that are passed inside of it
and then an equal sign and then you're
going to have all of your operations and
then a return value and that is exactly
how everything let's fill value right
and that is how all your functions are
going to be created inside a Haskell so
let's go and actually create our
function add me so it's just add me
right like that it's going to receive
two values I'm going to call them X and
Y and then it is going to return after
we perform this addition so x and y are
going to be our parameters just like you
can see right there and then after your
equal sign you're going to have your
operation and this is all also going to
be the return value right like that and
the datatype that's going to be passed
in is going to work if it makes sense so
if it follows this guideline
if it's an integer it's very important
to remember that every function must
return something it's also important to
remember that functions cannot begin
with an uppercase letter which we're
going to see why here very soon and a
function that does not receive any
parameters which we're going to see
examples later are going to be call it a
definition or simply a name and of
course remember that
we left our GHC i to go and compile our
program so we're going to have to go and
get it again
so haskell tut with l in front of it
there it loaded it and our and now we're
going to be able to come in here and go
: t and we go add me and it's going to
pop out or type declaration for us and
then of course we're going to be able to
go add me and we could do pretty much
anything we want and you can see that it
automatically went in there and added
those together so simple function now
let's get a little bit more complicated
we'd also be able to come in here and
not use the type declaration and just
have Haskell figure out exactly what's
going on so we can do something like
some me and X &amp;amp; Y is equal to X plus y
could say that that still worked however
now because we didn't define that we're
only working with integers we could
actually come in and work with floats
and you can see that it's automatically
going to work we're also going to be
able to come in here and add tuples
together
so let's still add tuples and we're
going to define a type declaration here
we'll go int it's going to receive a
tuple with instance ID of it and another
tuple with instant side of it and it's
going to return a tuple with instant
side of it don't let that confuse you
it's very simple it's just going to have
your parameters first and then the final
thing is going to be what's returned
afterwards so then we can go add tuples
and we could say we want x and y to be
stored inside of there and then x2 and
y2 so there's the two tuples that we'll
be returning or we'll be receiving and
then we'll be able to create a brand new
tuple which is going to be made up of x
+ x2 + y + y2 add tuples and we'll just
keep that really simple and you can see
that it added those together for us
we're also going to be able to perform
different actions based off the values
we receive so let's say we go what age
again we're going to be receiving an INT
and in this situation we're going to
return a string so we could say what age
16 is equal to if they pass in 16 you
can drive is what's passed back we could
do this for a whole bunch of different
things
so you could say what age 18 you can
vote and 21 you'd say something like
hooray you're an adult and then we could
say what age 18 and it pops back you can
vote or get more into those different
things you could also come in here and
go what age and just throw X inside of
there to cover pretty much anything else
and say something like nothing important
so in that situation they say what age
and you say something like 40 nothing
important pops back likewise you could
just put an underscore right here which
is very important it's used a lot what
age 56 nothing important comes back as
well let's talk a little bit about
recursion because you're going to use
that a lot let's go and create a
factorial and this guy is going to be
receiving an int and it's going to be
returning an int here what we're going
to define is all the different things we
could possibly do so let's say factorial
let's say that they pass in a zero well
we're going to define that we want to
return a one in that situation otherwise
we want to say factorial they pass in
anything else other than zero we're
going to go and get that value and we're
going to multiply that times factorial
which is the function we're going to be
calling the function again and then
we're going to be subtracting one from
the value of n that they pass inside of
it seems really complicated but it's not
let's just save it and we'll go
factorial and just keep this really
simple and set at four three you're
going to see that six pops back so what
exactly is going to happen here well the
first time through our program we're
going to pass in the value of three and
what's that going to do well it's going
to multiply that times whatever the
factorial of 2 is next time through
which is going to be this call four
factorial right here we're going to be
passing in value of two which is going
to be multiplying that times the
factorial of what two minus one is one
and then the last time through we're
going to be passing in a value of one
which is going to be multiplying that
times whatever the factorial of zero is
well what is the factor
of 0 when 0 is passed in this is going
to give us a value of 1 so this is
equivalent to 1 so this is going to be 1
times 1 is equal to 1 okay fine so this
value of 1 is going to be passed up
inside of this guy right here so this
becomes 1 so what's 2 times 1 well
that's going to be equal to 2 of course
so then we're going to take this value
of 2 right here place it with that guy
right there
we're going to get 3 times 2 which is
going to be equal to 6 okay so it's sort
of like a backwards way of moving up
until we get a final answer and that's
just a simple example of how we could
use recursion inside of Haskell which we
use a lot of course we could also come
in here and calculate factorial by just
using the product so let's go product
fact like that pass in a value of n is
equal to and we can go product and then
let's say well we can just go 1 up to
whatever the value of n is there that is
product fact passed in 3 &amp;amp; 6 comes back
so that's a really simple and easy way
to do factorials if you were wondering
we're also going to be able to use
things called guards to provide
different actions based off of different
conditions so let's create type duck
version here and what's call it is odd
it's going to return an integer or it's
going to receive an integer and return a
boolean and then we'll define what's
going to go on here so we'll say is odd
it's going to be receiving and then what
we're going to do is to have that in and
this is the guard part if n and it will
do a modulus on this as well within fix
so we put those back quotes inside of
there 2 is equal to 0 well then we're
going to return a value of false so what
this is saying is if the value of n that
they passed inside of here whenever we
take the modulus using 2 if that comes
out to a value of 0 then we're going to
return a value of false so that means
it's even that's what this is saying
right here we're saying if it's even
return a value of false obviously if
we're checking if it's odd that makes a
lot of sense then we can come in and go
otherwise like this return
true so if we know that it's not even
well obviously true is the answer we
want to use here and otherwise allows us
to basically catch everything it's a
default what's even more interesting is
we could do and do something like is
even n is equal to we could shorten this
a lot mod 2 like that equal to 0 but I
wanted to talk about guards because
guards are important and I definitely
wanted to talk about that so let's come
in here we'll do more guards here in a
second so we say is odd and then we
could say 67 it's going to come back
it's true if you just wanted to check is
even see if it actually works yes it
does indeed work so it's just two
different ways that we can do that then
that's the way the guards work let's go
and use something with guards that maybe
makes a little bit more sense we could
say something like what grade and this
is going to receive an integer like that
and it's going to return a string now
let's define it so we could say
something like what grade and they pass
in an age then we could use a guard here
and we're going to throw in a condition
so if the age is greater than or equal
to 5 and then we could stack this up and
say something like age is less than or
equal to 6 then the string we're going
to return remember we returning a string
is going to be kindergarten and then we
could do this for a couple more of these
guys this and we could say if age is
greater than 6 age is less than or equal
to 10 I'm just making this up as I'm
going along here I know I'm getting the
kindergarten part right but I'm not sure
if I'm kitten the elementary school part
right so whatever bear with me if that's
incorrect and let's just go like this
let's change this to 10 and let's change
this to say 14 I don't know and let's
say that this becomes middle school and
then here we'll say 14 and less than or
equal to 18 and this is high school and
then of course we could come in and put
otherwise and this string we're going to
return is go to college so there's a
maybe a better example of how we can use
guards and it compiled beautiful and we
could say what grade and then we could
say 14 it's going to pop back middle
school and we could say what gray
and we could say 56 and you'd says go to
college so everybody's going to college
alright so there's another example of
how we can use guards inside of high
school another thing it's neat is the
where clause
whenever we use it with guards so let's
do like a little bit of a baseball thing
here what we're is going to do is it's
going to keep us from having to repeat a
calculation over and over again so let's
say we want to go batting average rating
and we want to rate players based off of
what their batting average is well in
this situation this is going to receive
a double and another double and it's
going to return a string so then we can
actually create our function here now
that we defined what it looks like so
batting average rating and it's going to
receive hits and at-bats those are the
two guys we're going to get we're going
to use guards here and we're going to
say average you're saying oh what's
average well we're going to define that
where clause so if average is less than
or equal to and remember we got to put a
zero in front of there 200 well then
we're going to return a string that says
terrible batting average and then we can
go average and say less than or equal to
0.25 Oh and we could say average player
and then average less than or equal to
0.28 oh and we say you're doing pretty
good and then otherwise well that means
the player is doing pretty doggone good
their batting average is above 280
because this is catching everything
underneath of there and you can say you
are a superstar well now comes the where
clause and this is where we're going to
calculate average so we didn't have to
calculate it every single time inside of
there and we're going to say we're
average is equal to hits divided by
at-bats so there we are
now there's the where clause and we go
batting average rating and we could pump
in something like would have to do hits
so let's go do something like 20 and
then at-bats is 100 terrible batting
average and then we can come in and
change this to 30 you're a superstar so
you can see there's not much difference
between a superstar and a terrible pad
average in baseball and more importantly
you can see how gourds and wear work and
now let's take a look at how we can
access the list items in pretty
interesting ways so let's go and create
another function it's called get list
items and it is going to receive a list
made up Vince and it's going to return a
string and then let's define what's
going to happen here well if get list
items is passed an empty list it's going
to pass back your list is empty and then
we can define everything else we wanted
to do two items and in this situation
let's say that we just wanted the first
value outside of this we could say X and
then colon like that and then we could
say something like your list starts with
and then show is going to change
anything into a string so we'll be able
to output that on our screen so that's
one way to access this value right
inside of there and then we go get list
items and let's say we wanted to get the
second item in a list well we would just
put x and y and there's the rest of the
list items is equal to your list
contains and then we could do a whole
bunch of shows show X and then combine
this again and show and if we wanted to
get the second item in the list we could
just go show Y and then another thing we
were to do get list items you can see
this a lot I'm going to get the first
item here out of our list and then the
rest of the items X s is going to
represent the rest of the items in our
list then we can say the first first
like this item is and we can get X like
that and the rest are and then use X s
to get the rest of those items let's
save that everything compile get list
items and then we can pass inside of
this right like that first item is one
and the rest are two three or four and
five and you can say that it went and
got this guy and print it all those out
for us so those are different ways to
access different list items inside of
here using these guys right here and we
would also be able to come in here and
get values with what's called the as
pattern so let's just real quickly go
get first item its name of this and it's
going to receive a string and it's going
to return a string now I need to need to
the
on what it's going to do get first item
and if it doesn't they don't send
anything we'll just go empty string and
if they do pass in something we can go
all at and then X : XS like that and
then go equals and then the first letter
in and we go all which is going to show
everything that was passed inside of it
and then we could say is and if we want
to get an individual item out of there
just go plus plus and X get first item
and then we pass in a string and the
first letter in Hello is H so there's a
heck of a lot of information about
functions now let's take a look at
higher-order functions and it sounds
really complicated but all this entails
is passing functions as if they were
just regular old variables so let's
create a function here called x 4 going
to receive an integer and return an
integer and all times 4 is going to do
is get X and then for the return type
it's going to get x times 4 so there we
go we went and created a function for us
also let's go and put that together
now what map is going to allow us to do
is apply a function to every item in a
list so list times 4 is equal to map and
we can call times 4 and then have it
multiply all that stuff against a list
item or a list list times 4 and there
you can see it did that quite easily we
could actually come in here you want to
see how map works we can go and make map
so let's do x for what it's going to do
is it's going to receive and integer
list and it's going to return an integer
list we could then go mult
by 4 and if they pass us an empty list
we're going to pass back an empty list
and now we could go multi 4 and we're
going to be getting a whole bunch of
different list items we don't know how
many so in those situations you very
often use X and XS if you're going to be
processing a whole bunch of these guys
so like this
and we'll go times four we're going to
be calling this function that we created
right here times four receives a value
and then we're going to be able to go
mult
by four and pass it the rest of the
items on our list so what's going on
here is the first value off the list is
going to be X so there that takes that
and it's going to pass it to the x for
function up here it's going to multiply
times four it's going to store it in the
new list item then what's going to
happen is we're going to call x four
again with the rest remember that this
is the first list item this is the rest
of the list items this is going to be
passed back into malt by four again the
first value off of this new guy is going
to be chopped off and then it's going to
multiply that times four and store it in
the list this is one of the concepts
that I see students get confused about
so okay we're first time we're getting
into this function let's just keep it
nitrous in short first time we come
through here in multi for the value of x
is going to be equal to 1 X s is going
to be all the other stuff so X s is
going to be equal to 2 3 &amp;amp; 4 so the ones
gone so we multiplied 1 times 4 and then
we created a new list item called
multiply for that list let's not worry
about that so what's going on here first
time this list is passed into x for the
X is chopped off the value is 1 and X s
is going to be 2 3 4 well now we can
take 2 3 4 down here copy that out of
there
second time through now we have 2 3 4 so
what's the value of X whenever it's
coming through here this time to be
multiplied times that well it's going to
be equal to 2 and then what's the value
of x s going to be equal to that's going
to be passed back in tumult by 4 it's
going to be 3 &amp;amp; 4 see how it's doing
that chopping those off and it's going
to continue doing that until there are
no list items left when there are no
list items left it is going to stop this
operation so that is how X and XS work
inside of haskell this confuses people
hopefully I cleared that up I think it
very clear if not leave a question below
and I will give another example we're
going to do more with X and s but that
is exactly how those operate and just
want to make that a hundred percent
clear so we're going to be able to come
in here save that and then go mult
by four and we pass in a list item so
they're data and there we are and you
can see that it multiplied all those
different values by four we could also
come through here let's do another
recursion example this is one of the
things that I think makes Haskell great
for being good at other programming
languages because we do a lot with
recursion but I think Haskell does
recursion very well so let's say if we
wanted to check if strings are equal
using recursion going to do a whole
bunch of different examples here so our
strings equal well we're going to first
off define this so we're going to be
receiving a character list which is what
a string is and another character list
and then we're going to say are they
equal which means we're going to be
returning a bowl
well let's define exactly what this is
going to do our strings equal well if
they pass in two empty lists well the
answer is going to be true in this
situation or at least that's what we
want our strings equal here we're going
to be checking a whole bunch of
different values so we're going to be
using X and XS but we also want to be
able to check to lists so we're going to
be using Y and YS so we're going to come
to our answer by just checking if X this
guy the first item in our list is equal
to Y the first item in our second list
and because there's more than one
character inside of here we're also
going to call our our strings equal
again and we're going to pass in the
values of x xs and ys
which are all the remaining unchecked
rest of the values in our list pass that
back in there and it just slowly cuts
down the size of the list until it's
empty there's none left and then finally
we can say our strings equal like this
and for anything that isn't an empty
list or isn't a list item we're going to
cover this by just saying false because
we're angry and they shouldn't have
passed in Gorby
into our function and we compile that
and we can say our strings equal and we
pass in hello and then we can pass in
hello again and you can see that comes
back true and then hello and we can say
you and you can see it comes back false
so I just want you to really understand
this because I think this is the thing
based off of talking to students that
confuses some about Haskell and it
shouldn't because it's easy it's a
little weird but it's not that hard to
figure out I'm sure you guys get it so
now let's say we want to pass a function
into a function because we said we
wanted to do that so let's do
multiplication and here what we're
saying with int + int is that we expect
a function to be passed inside of this
function that is going to receive an
integer and return an integer then after
we do that we're going to return an
integer so this is defining a function
that is going to be passed into our
function so we can go do mult and funk
where func is equal to 3 actually the
function I want to pass inside of here
is x 4 so let's throw that in there
again so the function that's going to be
passed inside of here is going to be x 4
and then it's going to take that
function and pass 3 into x 4 okay so
that's all that's saying right there
and we can actually do this let's go
number 3 times 4 and call 2 malt and
then pass times 4 inside of it and yes
that's legal we can do that
so we're saying this is an essence is
going to store that value for us there
we go
and you can see that 12 pops back so all
we did was we defined a function called
x 4 we pass that into this function
which we have right here pass that
inside of there then this function it's
job is to take the function was passed
in which was x 4 pass 3 inside of it 3
times 4 is going to be equal to 12 and
then it stored that value inside of here
and print it out to the console so
that's how we can receive functions but
we can also return a function so let's
create another one called get add
function it's going to receive an
integer and it's going to return a
function that's going to receive an
integer and return an integer we can
pass the values into the function so we
can go get
add function X Y is equal to X plus y
and then we could go and find a function
that adds three for example so let's say
adds three equal to get our add function
it's going to get three so it's going to
take this three right here is this guy
right here and then what it's going to
do is it's going to return that function
and then store it inside of adds three
now what we could do is four plus three
is equal to adds three and then pass
four into that and if we do that and run
it we could say four plus three it's
going to give us the value of seven so
there's an example of how to return a
function from a function and one weird
way we can use it one thing is neat is
we could of course use this with map as
well so say 3 plus list is equal to and
call map and then go adds 3 and have it
work on a list for us 3 plus list and
there you can see that work for us and
now let's take a look at lambdas real
quick it'll lambda just to keep it very
simple is just a way for us to create
functions that don't have a name and so
for let's say we're going to go double 1
to 10 and we could just create map which
is just going to execute a function on a
list for us how we define a lambda that
doesn't have a name so just put a
backslash like that X X is what it's
going to be receiving what it's going to
be returning in this situation is
whatever the value that was passed into
it times 2 and then in this situation we
can just pass inside of there a list
from 1 to 10 and double 1 to 10 and
there you can see it did that for us
just a real quick example of using
lambdas not that complicated so I don't
see any reason to focus on too much
because I have a whole bunch of other
things to do it's also talked about
conditionals now there's comparison
operators which we've seen already so
there's less than there's greater than
there's less than or equal to greater
than or equal to equal to and then not
equal to which is a little bit weird
it's a forward slash and it equals and
we already saw the logical operators are
going to be and or or not and I already
showed you exactly how those are going
to be used inside of haskell you could
actually use if statements inside a
Haskell
even though they're not used quite so
much we can go double even number for
example and we can pass in y2 this and
we could say something like if Y and
then let's do an infix here with mod 2
not equal to let's just use not equal to
here zero always you have to have an
else if you're going to be using if
inside a Haskell then we're going to say
then why otherwise Y times two and this
is going to do exactly what it says it's
going to double only the even numbers
and it's not going to double the odd
numbers so we could say double even
number passing 100 you can say that that
worked however if we come in here and
change this to 101 it's just going to
pop back on our one so there's an
example using if-then and else could
also use case statements so it's say
something like we're going to use get
class this guy is going to receive an
integer and then return a string and
then we can say good class go n which is
the value it's going to be received and
then we say case and oh and here we're
going to define our conditions if it's 5
that they passed inside of it go to
kindergarten if they passed in a six we
would define go to elementary school and
then if we wanted to catch everything
else we could just put an underscore
inside of there like that go away there
we are
get class and we could say 6 and you
could test everything else so there's an
example of conditionals now we can
briefly go over modules these are
modules up here that we load it of
course I'm just going to do a real quick
example basically a module is just going
to contain a whole bunch of functions
that you're going to be able to use and
your other programs and load them well
you already know how to load them with
import and to create one you're
basically just going to have all of your
functions inside of an another program
another you know file and then at the
very top of the module you're going to
type in module and you can say something
like samp functions like that and then
you're going to list all of your
functions that you're going to have
inside of your module so even numbers
whatever they're going to be and then
you're going to type in where and then
you're going to have all of your
functions listed and then if you wanted
to
port this guy into your program to use
it you're just going to type in import
and sample functions okay so there's
modules pretty simple now let's talk
about numeration types which are
basically going to be used when you want
to define a list of possible types and
to create a numerated type you're going
to type in data and let's say I want to
do baseball player and then define all
the different types of baseball players
I could have well I'm going to have
picture and I could either have this on
one line like this or I could put this
down here like this if I'd want to this
looks a little bit neater
there you go looks a little bit nicer do
you do whatever you want and you could
say infielder and then we could say
outfield and then if you want this to
actually print out like a string you
would type in deriving Show remember
show converts whatever into a string
that we can use well there you go you're
going to see more about deriving show
here in a second it's going to make a
lot more sense then you'd be able to do
things like Barry Bonds to find that and
baseball player and this is going to
pass back a bowl and you could go Barry
Bonds and to find that Barry Bonds being
an outfielder gets the value of true
this would then allow you to say
something like Barry in outfield is
equal to print Barry Bonds outfield like
that Barry in outfield and it comes back
as true there's enumerated types now
let's talk about custom types now with a
custom type you're going to be able to
store multiple values sort of like a
struct to create a custom data type and
to do so you're going to type in data
and let's say we wanted to do something
like customer course put a space between
here then you're gonna type in customer
again then you're going to find all the
different types that you want inside of
it so say we won two strings and a
double once again you're going to say
deriving shell which just means we're
going to be able to use this as a string
you're going to see here in a moment
exactly what that means in a lot of
detail now we'd be able to create a new
type here using our custom data type
which is customer and then to set the
values for it we're going to pass in
customer and then some information about
that customer so let's say that for
name or the whole name the address and a
balance that they know us maybe we could
then come in here and define a function
that's going to work with this like get
balanced what we're going to say here is
we want to find the right customer by
passing in the customers name and to do
that we just say customer and then what
it's going to do of course is pass back
a double which is the customers balance
now to get that balance what we're going
to do is go get balance like this and
then we're going to pass in customer
inside of it we don't care about the
name or the address we're just going to
put two underscores there and have B
represent the balance which we do want
and then pass back balance now what we
could do is just come in here and run
that and we could say get balance for
Tom Smith and it's going to return Tom
Smith's balance for us do something a
little bit more fun here let's go and
create another data type so let's say we
want to play rock-paper-scissors
so RPS is equal to and all the different
types this is just an enumerated type
like we just saw a second ago
so rock-paper-scissors like that that we
did create a custom type and then we
could say something like shoot RPS RPS
and then it's going to return a string
for us depending upon the input that we
provide then we define all of the ways
that we are going to answer so we'll say
if we get paper and rock we're going to
pass back is paper beats rock and then
we could do that for all the other
different things and then if we want to
do a catch-all that's going to catch if
they pass in anything except what we
expect shoot and there we go and then we
could print something like error out on
the screen and now we'll be able to come
in here goes something like shoot paper
rock like that and it's going to say
paper beats Rock and of course if we
said bullet Rock it's going to go and
mess that up because it doesn't have any
idea what bullet is okay there's a quick
example of how to implement Rock Paper
Scissors inside of Haskell
we could also define two versions of a
type so let's say we wanted to create a
shape type that
going to work for both rectangles as
well as circles well we can come in and
go data shape like that and then define
circle and a circle is going to receive
or contain three floats while a
rectangle is going to have four floats
first two and first two and what this is
going to represent for us is the first
two floats for our Center are just going
to be the x and y coordinates and the
last one is going to be the radius and
then for our rectangles we're going to
have upper left-hand corner coordinates
X or Y and the bottom right-hand corner
is x and y now if we want to be able to
print these out we're going to go
deriving show again now what we could do
is define an area function that's going
to receive a shape and return a float
and how it's going to calculate is if it
gets a circle we can just take the
radius for it and then go pi times the
radius squared and then likewise we
could go area if we get a rectangle when
you go X Y X 2 and Y 2 coordinates that
are going to be passed inside of it and
then go get the absolute value of x 2
minus x times the absolute value of y 2
minus y and it's going to perform the
rate calculation depending upon the data
type that's passed in another thing it's
important to remember with Haskell is
you're going to see dollar signs a lot
and what that means is we want to get
rid of these parentheses so if you want
to get rid of those parentheses you
would put a dollar sign aside of that
and then get rid of that or a dollar
sign right here and then get rid of that
so that's all the dollar sign does is it
gets rid of parentheses and that just
means that anything comes after it takes
precedence over anything that comes
before it and of course make sure we
come up here and call that circle spell
that right and I'll let you play around
with that on your own let's also talk a
moment about the dot operator and how
that works basically it's going to allow
us to chain functions to pass output on
the right to the input on the left so
let's say we want to go some value and
put string length which is just going to
print stuff out to the screen we go show
like that 1 plus 2 okay that's one way
to do it another way to do it with a dot
operator is to go some value let's just
call it - so
it doesn't freak out at us the same
thing we could also go foot
string-length like that dot show and
then let's use the dollar sign as well
we could go dollar sign one plus two so
that's just a way for us to be able to
chain those values together then we can
get some value too and of course it's
going to give us an answer of three and
we could also come in here and go and
get the area of our circle just by going
area like that and it's a circle and we
go 50 60 and 20 and then likewise we
could do area of rect is equal to and
then we can call area and what the heck
let's do dollar sign and can just say
you're used to that rectangle 10 10 100
100 area of circle an area of rect so
that's how we can perform some custom
types or create custom types and a whole
bunch of other different funky little
operators that are special to Haskell
now let's take a look at type classes
now type classes are going to be things
like num and equals and Ord and Show
remember I kept saying we're going to
talk about show well now is the time to
talk about it those are type classes and
type classes are going to correspond to
sets of types which have certain
operations defined for them so for
example our additional operator is going
to work with parameters that use num and
you can actually see that if we come
over here and just go T plus there you
go you're going to see that works with
nums that's a type class and that what
this is basically saying here is for any
type a so it could be in store doubles
or whatever as long as it's an instance
of type num or type class num we're
going to be able to add it okay so
that's what that's saying and of course
it also says that it's going to take two
values and return one of course that are
also all going to be of type num so what
we can do is we can come in here and
let's say we want to create a custom
data type of type employee equal to
employee and it's going to receive a
name string a position which is also
going to be a string an ID number which
is going to be an integer and then what
we can say at the bottom of it is
deriving EQ and Show so we're going to
be able to show that these employees
because we're
defining it here there first off going
to be able to be shown as strings but
also they're going to be able to check
for equality between them okay so we
have those defined so we can create two
employees so it's create Sam Smith and
Pam marks and you can see here I define
the names and the position and the ID
numbers for them so we could save those
and we could also come in here and go is
Sam Pam equal to Sam Smith equal to Pam
marks is Sam Pam comes back as false of
course we could also print out all of
this information by going Sam Smith data
equal to and you show for this guy
because we said we wanted to be able to
use show and we also wanted to be able
to check equality and Sam Smith data
pops back all of that information for us
now let's create another data type let's
call this shirt size oh and you may have
noticed I'm now using uppercase letters
for these guys that's the reason why we
can't use uppercase whenever we are
defining functions so we'll just have
small/medium another enumerated type for
us and large now we can actually define
our type instances and how they're going
to work with EQ and she'll to do that we
go instance EQ like that and shirt size
where and now we'll define exactly what
is equal so if s is equal to this or if
we're asked that we're going to return a
value of true medium equal to medium yes
that's going to come back is true and
we're defining or overriding what the EQ
type class does for us or says it's true
large large equal to true and if they
ask us for anything else we're going to
say that it's false we could also define
how shows going to work so we'll go
instance show and we can override it
have it do whatever we want where and in
this situation if they ask us to show s
what we're gonna say is instead of s
being displayed we want small display if
they want us to show em we're gonna say
that we want medium to be displayed now
we can do things like check if small is
in a list so we can say something like
small available we can go s and
um is going to check if something's in a
list for us and of course in this
situation will be we could also come in
and go the size is equal to and call
show s up got a little bit of an error
need to put an equal sign inside of
there and we can say something like the
size and you can see small pops back and
we could also check small available and
you can see that that comes back is true
so that's how we can override or define
those type classes we could also define
a custom type class is going to check
for equality
so let's come in here create another one
of these guys class and we're going to
use my equal and use my custom guy so
we're in a situation I'm going to say
are equal and here a is going to
represent any type that implements the
function are equal so we can say are a
data and in that situation we're going
to return boolean and then we can go
instance for my brand new equals what
what I was going to do is for shirt size
let's just do it that way pop that in
there where then will say are equal and
if we get to two smalls we're going to
pop back true or equal to mediums true
to largest true and otherwise false now
we'll be able to say a new size and call
are equal mm like that and new size
comes back is true that's how we define
our custom type classes now let's take a
look at i/o so let's create a little
function inside of here just to review
member do is allowing us to chain a
whole bunch of different things together
so we can go put string what's your name
like I did before and then going to be
able to get keyboard input putting that
little arrow inside of there and get
line like that going to be able to
output information and get rid of the
parentheses with that and then we'll say
hello cat need these together with name
run that say hello like that what's your
name door hello Derrick their egos talks
to me so just a quick little review of
how we're going to be able to get input
and then output now let's take a look at
file i/o
so let's say we want to write to a file
well we would just go it doesn't have to
be right to file can be whatever we're
going to be chaining a whole bunch of
functions so we'll use do we need to
open a file that we
want to work with and we use open file
to do that and we pass in the name of
the file that we want to open and we
want to write only to it so we're going
to say write mode to put text into that
file we're going to go H put string line
like that pass in the file handle that
we have right here which is this guy
right here and then we'll put inside of
here random line of text there we go
that's what we're going to write to our
file make sure you close that off at the
end and then very importantly make sure
we close our file release that and
that's how we write to a file pretty
simple want to read from a file read
from file is what I'm calling this can
be called anything of course and then of
course we're going to say let's go and
reopen that file that we just created in
wrote - to open a file for read mode we
go open file and we type in the name of
the file we want to work with can work
with any type of file using text files
here just because don't have to worry
about anything funky in regards to
messing with them if we want to get the
contents of the file we just contents
and then we'll just say H get contents
our file handle dot file and then we can
say put string contents and then of
course just like before close our file
there we go
and it compiled and we can say write the
file and it wrote to it and then we
could say read from file and it printed
it back out on the screen so that's how
we both write and read from files inside
a Haskell the final thing I wanted to
cover here was a video actually done on
YouTube that a lot of students have
asked me questions about in the real
world so I thought I would cover it here
now that piece of code actually
generates the Fibonacci sequence and how
it does it is it goes equals 1 it
creates a list follow the Fibonacci
numbers inside of it and of course you
know this is the coins operator which is
going to combine these two values right
here and I'm going to go through this
line by line and explain exactly what's
going on inside of it because I received
a ton of questions about it alright so
you can look at this while I'm typing
this out on the screen and see if you
can figure out exactly what it's doing
and then what
I'm going to do is actually explain what
it's doing Feb 2 5 so what this is doing
is creating a list that is going to be
made up of the Fibonacci sequence and
this is an equal sign sorry about that
okay so what's going on you could pause
the video and work it out yourself
otherwise I'm going to actually go
through and talk about it and explain
exactly what's going on Fibonacci
sequence you don't know is going to be a
whole series of values in which the two
previous values are going to add
together to make the next value so then
this goes to three and this goes to five
and of course this goes to eight and
then this goes on forever and ever and
ever alright so how exactly does this
create an infinite list of Fibonacci
numbers well this is basically creating
a list from left to right it's also
using recursion down here and it's using
zip right here to create pairs using the
contents from two lists and throwing
them into a tuple so what it's doing is
it's starting off by creating our list
and that list is going to start off with
values of 1 and 1 there we go
and it's going to continue generating
numbers but from the very beginning we
have a list that has the value of 1 in
the first index and one in the second
index now we come down to this guy right
here what this is saying is zip let's
take the FIB which is going to be 1 in
this situation and the tale of that fib
which is going to be this value of 1 and
let's pass it over here to this function
so all this is saying is it's going to
receive an a value which is going to be
this right here or this guy right here
and then this is going to receive the
tail part which is the left the rest of
the list which is going to be passed
into there it's going to add those
together and it's going to create the
next item in our list which is going to
be 2 in that situation so just to
reiterate this guy the first time
through fib let's say first time fib is
going to have a value which is going to
be equal to 1 and
Tail fib is going to have a value which
is equal to one so the list is now after
the first time through going to be 1 1 &amp;amp;
2 and the reason why is going to because
a is going to have a value of 1 and B is
going to have a value of 1 which is
going to give us a final value of 2
which is going to be stored in our fib
list remember this list is going to be
created from the left to the right so
you can almost see this slowly expanding
on its own this is generating the rest
of the list second time through fib is
going to have a value of 1 which is
going to come from this guy right here
and tale fib is going to have a value of
2 which is this guy right here so after
we go through that the second time we
have 1 1 2 &amp;amp; 3 and that is how it is
going to expand itself and the reason
why is a in this situation is going to
be equal to 1 that guy right there this
guy right here and B is going to be
equal to 2 that guy right there and
that's how we're going to get our 3 now
by doing it this way what we're going to
do is we're going to need to be able to
come in and do something like fib 300 is
equal to fib and let's say we want the
300 February nachi number we're going to
be able to get it by going fib 300 and
there you can see and you can also see
how giant numbers can be inside a
Haskell which is pretty ridiculously
cool and then of course we could also
come over here and say take the vers
25th to get those okay so hopefully I
explained that pretty awesome example
that's on YouTube but I get asked about
it all the time so I thought I'd cover
it at the end of the video so there you
go guys there's a heck of a lot of
information about Haskell please leave
your questions and comments below
otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>