<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Big O Notations | Coder Coacher - Coaching Coders</title><meta content="Big O Notations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Big O Notations</b></h2><h5 class="post__date">2013-03-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V6mKVRU1evU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
9 of my java algorithms tutorial today
because I had a little bit time so I
decide I decided to cover a question
I've been getting a lot and in this
tutorial I'm going to explain in a
simple way what exactly we mean by Big O
notation just to cut to the chase Big O
notation is a way to measure how well a
computer algorithm scales as the amount
of data involved increases so how well
would it work in say if it was using a
10 element array versus a 10,000 element
array as you're going to see here in a
second it's not always a measure of
speed but instead a measure of how well
an algorithm scales and this is going to
be a rough overview of Big O and I'm not
going to cover topics such as asymptotic
analysis and other things that I have to
do with discrete mathematics I'm going
to instead focus on the simple idea so I
got a lot to do so let's get into it
okay so I'm doing a lot of this out of
my head here so bear with me
but basically what I want to do here is
give like a little example so let's say
we have 45 n cubed plus 20 n squared and
this is going to be our algorithm we're
going to be playing with here plus 19
now if n is equal to 1 in this situation
that's going to come out to 84 and the
reason why this is going to be very
important is I want to define with Big O
notation the part of the algorithm that
has the greatest effect ultimately on
the final answer so now in this
situation if n just goes up to being
equal to 2 you can see very quickly that
your answer is going to go from 84 to
459 and you can also say that it's not
going to be that long until 19 doesn't
matter it doesn't have much of an effect
on the performance of our algorithm so
we might start to question is it
important at all well then what happens
if n goes up to say 10 which we're still
not doing with very large numbers here
you can see the answer to this it goes
up to 47 and 19 which as you can see now
you're starting to question well
definitely 19 doesn't really have that
much bearing in regards to the final
answer and also when you think about it
N squared has very little to do with
this answer if in fact 45 and
tubed is going to be equal to 45,000 in
this situation so if you're going to be
dealing with very very large numbers you
very quickly say that the part of this
algorithm that really has a lot to do
with the final answer as this data set
scales is not even going to be the 45
but it's going to be the n cubed and
hence we would say that this has an
order of n cubed and that is just a very
very basic look at this and something to
think about as things go on and what our
ultimate goal with Big O notation z' are
so let's come in here and I'm going to
write some code and I'm just to show you
I'm going to go over order of 1 and what
that means I'm going to go over order of
N and what that means order of N squared
provide examples what that code looks
like as well as n cubed and all these
other ones also going to get into log N
and order of n log n ok so that's what's
going to be covered in this tutorial so
I got to get a couple pieces here
because we're going to be playing around
with Big John arrays so I'm just going
to create himself an integer array call
it the array let's say that I'm also
going to need a Ray size and I'm going
to be covering a lot of the different
things that I've covered in previous
parts of this tutorial binary search and
all that stuff items in array and I'm
going to set this for 0 to start off
static long start time I'm also going to
show you the difference in how long it
takes for things to execute even though
like I said before Big O notation
doesn't really have that much to do with
speed necessarily and all the code here
is available to link underneath the
videos so the very first one we're going
to do and probably the easiest of these
guys to understand is going to be order
of one and I'm going to put this in here
as a comment and what this algorithm
does or what this notation means is it's
going to be an algorithm that's going to
execute in the same amount of time
regardless of the amount of data or to
put it in other word it's going to be
code that executes in the same amount of
time no matter how big the array is so
what exactly would that look like well
one example of that in the context of
working with
raise would be if we wanted to add an
item to an array and integer was passed
over and we said okay we want a new item
and I went in here and said the array
items in array plus plus is going to be
equal to new item there you go
that is an example of order of one it
doesn't matter if this is a 10,000 item
array or a 5 item array it is going to
perform in exactly the same way so
that's order of one so what would be an
example of order of n well this is going
to be an algorithm that's time to
complete is actually going to grow in
direct proportion to the amount of data
and a perfect example of that would be a
linear search which I'm going to show
you here in a second and the reason why
a linear search is great for this is to
find all values that match what we were
searching for we will have to look in
exactly each item in the array so that
would make a big difference if it was a
10 item array versus a hundred thousand
item array and in the situation in which
we just wanted to find one match Big O
notation is the same because what it's
going to do is describe the worst case
scenario in which the whole array must
be searched so let's say we're looking
for an item that's in a 100,000 item
array and it doesn't exist but we want
to make sure that we handle that example
which would mean that every single item
would have to be searched so let's just
come in here and let's do this with
linear search and a value would be
passed in which would be the value that
we're going to be searching for boolean
value in array and we're going to mark
this as false to start off because we're
pessimists and we don't necessarily
think we're going to find it and then
let's say I'm kind of doing this just to
force the issue so that it searches
through the entire array because the
Java compiler is actually smart enough
if I don't tell it that it needs to find
more than one it will actually stop and
then let's just come in here and do a
system check to see how long it takes
for this guy to execute and let's say I
want to do this in milliseconds again
I'm kind of doing this just because I
want to point out how long things take
to execute and not because Big O
notation is really a monitor of speed
and then we'll give you a perfect
example here in a second to show you why
speed isn't really
the big issue here and then we're just
going to say if the array is equal to
value that we're searching for value in
array is going to be changed to true and
then indexes with value we're going to
add that item to it right like that and
of course put that extra equal sign in
there and if we wanted to say print
something out on the screen we could say
something like value found value in
array and then throw end time into this
to calculate whenever this guy ended
execution and then we could say
something like linear search took n time
- start time then let's bounce back up
into the main function here and do some
tests so we go notation just I'll go let
me just say to Big O notation and let's
say I set this for it I'm going to set
it for a hundred thousand as the size of
my array then I could take this guy here
and generate a random number of elements
inside of that iraq say like that and
i'm gonna have to create a constructor
for Big O notation because I did copy
and paste generate random array into
this but I didn't do it for the
constructor which isn't a big deal I'm
just to say int size of the array race
size is going to be whatever was passed
into it and there we are we just created
our new array - back up into main and
let's create a couple more of these
arrays so that we can compare them based
off of size differences so test I'll go
3 and let's change this to 200,000 and
let's create two more of them just to
experiment with and change this to 4
this to 5 in just the 4 5 and then have
this be 3 and this be 400,000 and now
we're going to be able to come in here
and actually perform these linear
searches and see exactly what's going on
with them which in essence is going to
be to show that they're going to scale
as the number of elements that we're
going to be using here are going to
scale which makes on represent sense
actually I don't even think I need to
use all those and let's file save and as
long as I did it right and you can see
right there with this linear search this
took it roughly 4 milliseconds this took
5 milliseconds and this took 18
milliseconds so you can see as the
number of elements scale get bigger the
number of elements we have to deal with
that is in direct relation to the number
of elements and that is why it is known
as order of n so there's an example of
order event
so now let's take a look at what does
order of N squared mean or cubed or any
of these other different things we can
put inside of here well this just means
that the time to complete will be
proportional to the square of the amount
of data and a perfect example of that
would be the bubble sort and this
normally happens with algorithms just
like the bubble sort that have nested
iterations and you're going to see how
dramatically that hampers performance as
the number of items we have to deal with
increases and the reason why is each
pass through our outer loop is actually
going to require us to go through the
entire list again
so one trip through a loop is going to
work out to order of n but we're going
to then have to go through the loop
again for every single item in the inner
loop and that is why you get into a
situation where it becomes N squared so
let me just show you an example it'll
make Connor percent sense so let's just
take our bubble sort public void level
sort and let's say that we also want to
monitor the time again that it takes for
this to execute paste that in and let's
just based in this as well and here it's
going to be bubble sort and there we are
so now our bubble sort like you saw in
previous parts of the tutorial
is just going to be AI is equal to array
size minus 1 and then we are going to
cycle through this as long as I is
greater than 1 and then we're going to
decrement I then we're going to have
another for loop and we'll have it set
for J going to start at the beginning of
the array and it's going to cycle as
long as J is less than I and then we're
going to increment J and as we're
sorting through this guy we're going to
say if the array item index J is greater
than the array item index J plus 1 on
that situation we want to swap values
the items we're going to swap is J and J
plus 1 just like you saw previously
let's bounce up here and see exactly how
that works so here are our tests and
this is going to be very easy to do
let's just come in here get rid of that
and I'm just going to get rid of the
second one as well and here we're just
going to run bubble sort on it and then
here we're going to run bubble sort on
it as well and previously when we did
the linear search you didn't see much
difference between the first item and a
second one now you're going to see much
more difference and you're going to see
such a difference
that I'm actually going to take this
down to 10,000 and take this down to
20,000 and execute and there you can see
it took 362 milliseconds and it took
1612 milliseconds and you can see that
it just continues going on here and how
dramatically slower the bubble sort gets
depending upon the amount of data and
that is why order of N squared is very
bad and to be avoided so now let's show
you an example of another algorithm that
is much more efficient and that's going
to be our binary search and here we're
going to focus on order of log n as our
Big O notation and this is going to
occur when data being used is decreased
roughly by 50% each time through the
algorithm and the binary search like we
saw before is a perfect example of this
and it's pretty fast because as log n
increases or n specifically increases
the increase in log n in comparison to
just n is going to be dramatically
different and is going to increase at a
dramatically faster rate than log n will
and that is why log n algorithms are
very efficient because increasing the
amount of data has little or no defect
at some point early on because the
amount of data is halved each time as we
previously had seen with the binary
search now the only problem with that is
that the binary search is going to
require R Us to do a bubble sort or to
sort it in one way or another so don't
have to use the inefficient bubble sort
if we don't have to order we don't want
to so here I'm going to go and create
the binary search and I'm just going to
use my search results for my bubble sort
just because it's convenient not because
it's good and you're also going to see
here why timing these guys isn't going
to really matter because of how
efficient this is there's not going to
be a dramatic difference in speed when
the data set for this binary search
increases dramatically even it'll be
almost no effect so what do we need here
well for doing a binary search we need
low index is going to be equal to zero
and high index is going to be equal to
array size minus 1 I'm also going to
monitor the number of times that we go
through this algorithm here
and then we're going to go while low
index is less than or equal to high
index in here get middle index and this
is the part that makes it all efficient
we're constantly cutting the amount of
data in half each time we run through it
then we're going to say if the array
middle index is less than value low
index is going to be equal to middle
index plus 1 and if else if the array
middle index is greater than value then
we're going to do the absolute opposite
and have I index equal to middle index
minus 1 so it's kind of a review of all
the stuff we've been doing else we know
we got to match we'll just say find a
matching the index and whatever the
middle index is then we'll go low index
is equal to my index plus 1 and then
we're going to calculate the number of
times we went through this whole entire
process and we'll print that out on the
screen as well just to show you how
extremely efficient this search is I'm
through nan will bounce up here we're
going to search for a very specific
value and after the bubble sort
just I'll go to binary search for value
and I'm just going to type in 20 in
there test I'll go 3 search for exactly
the same value and execute and there you
can see 162 milliseconds this took 721
milliseconds and now you can start to
see why measuring the time doesn't
really matter with efficient algorithms
and why Big O notation tells you a lot
more about an algorithm than how long or
milliseconds it would take to execute
and you can also see the efficiency it
only went through it nine times to
search 10,000 items and it only went
through it 10 times to search through
20,000 items so this is pretty much the
picture of efficiency and I executed it
again just so you can see that that was
meant to be binary search took zero not
bubble sort so a binary search took zero
so that is the picture of efficiency and
I hope that makes sense because now
we're going to look at the order of n
log n which is going to be a little bit
more complicated and that is going to
look like and log and this is the
notation that we would be looking for
now when we have looked at sorts in the
past they have normally always been at
the very least order of N I mean that is
that
has to be and the reason why is to
properly sort a list of elements an
array we have to look at every single
element in the array at least one time
so that's the absolute minimum however
what we want to try to avoid is
something inefficient like n to the
squared which is what we had with the
bubble sort and we already know that the
quicksort is much more efficient but the
main answer is going to be why is it so
efficient now to figure out the number
of comparisons that we need to make with
the quicksort we first need to remember
that it is comparing and moving values
very efficiently without shifting unlike
some of the other sorting algorithms
we've used in the past and that means
that values are only going to be
compared once
they're not going to be compared to each
other over and over and over again
so in essence each comparison will
reduce the possible final sorted list in
half or to put it in a completely other
way and this is going to be a little bit
of math here the number of comparisons
that you're going to have to do is going
to equal out to log in the factorial of
n and we already went over what
factorials are and to put that in other
terms so that we can look at this and
make more sense of what n log n means
this is going to be equal to log n which
is going to be the greatest value when
we're performing our factorial plus log
n minus 1 plus and it's going to
continue continue continue on until we
finally get to log 1 which is going to
be the end of how we're going to
calculate our factorial with that plus
sign in there just to be neat all right
so now if we look at this and sort it
down we're going to see that in
actuality comparisons is going to also
be equal to n log N and that is where n
log n comes from just simplifying this
great big giant long factorial that we
were calculating right there
so hopefully that made sense if it
doesn't the code should help you out so
I'm going to do a quick sort right here
real quick quick sort and it's going to
get the left side of my array and it's
also going to get the right side of my
right and I'm going to say if right
minus left is
less than or equal to zero return
because I'm done working with this guy
it's all sorted else I want to calculate
my pivot value this doesn't make any
sense because you haven't seen my
quicksort tutorial set it to whatever
value in the array has the index that is
equal to right and then we're going to
go into edit location is equal to
partition array which is a method I'm
going to call below go left right pivot
and then like we talked about before
we're going to do a quick sort so that
we are partitioning smaller and smaller
parts of our array each time we cycle
through here I'm going to do pivot
location plus 1 and here we're going to
do right and that just means we got to
do partition array the method for this
quicksort is pretty tiny in it when it
doesn't have all those comments and all
that extra stuff public int partition
and then these are all going to be
integers of course that are passed in
here and then just review left pointer
and be able to the value of left is
minus 1 because we're going to increment
it here in a second and it's actually
going to start on the outside of the
array right pointers and be whatever the
end of the array is because we're going
to be partitioning partition and
partitioning we're going to cycle
through this as long as we have to until
the whole thing sorted we're going to
say while the array we're going to
increment left pointer so that we're
actually getting a value out of the
array not negative 1 which doesn't exist
in the array yeah I figured what the
heck you might we'll provide a review of
some of this stuff that I've been doing
so I go through the right pointer as
long as it doesn't equal to zero and the
array decrement right pointer is greater
than pivot stick through there find
pieces that need to be partitioned to
the opposite side of the array if left
pointer is ever in a situation where
it's greater than or equal to right
pointer we're going to break out of
there which we have to do because we
have this set as an infinite loop else
swap those values you see how efficient
this is and then swap left pointer with
right and return left pointer and there
we are I think I did all that right
let's come up here and find out so back
inside of main and we no longer need
these guys because we're going to be
using the quicksort throw in these
timing mechanisms here just to show you
how efficient it is I'm going to chuck
this up to a hundred thousand chuck this
up to two hundred thousand tests I'll go
to you're going to do the quicksort
where is that quicksort
there it is set into zero test I'll go
to passing the number of items in the
array and execute and you could say it's
cycled through a hundred thousand items
in 41 milliseconds let's take this up to
four just by changing this to four files
a of executes I know they took forty
four milliseconds to jump up to four
hundred thousand or three hundred
thousand in this situation there's a
rundown of Big O notation and
explanation and a view and look at it
from numerous different angles leave any
questions or comments below otherwise
till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>