<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Binary Search Tree | Coder Coacher - Coaching Coders</title><meta content="Java Binary Search Tree - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Binary Search Tree</b></h2><h5 class="post__date">2013-03-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M6lYob8STMI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well Oh Internet and welcome to part 13
of my Java algorithms tutorial today
we're going to talk about binary trees
more specifically I'm going to tell you
what a tree is what a binary tree is how
to create nodes how to add nodes how to
traverse a tree and how to find specific
nodes in the second part of this
tutorial I will show you what is
considered to be quite complicated which
is how to delete nodes so we have a lot
to do so let's get into it
so whatever you're thinking about trees
I know some of you guys already know
this but I'm going to review it really
quickly basically the top node of a tree
and you can see it looks kind of like a
tree structure is known as the root the
lines that connect all of the nodes
thereafter are known as paths or edges
course this is a node just like all the
other green dots or nodes see in this
situation is going to be the parent of
the children nodes which are F and G a
leaf is a node that does not have any
children a subtree would be anything
like FH and I see F and G B D and E and
of course these are the children so D as
well as E would be children of node B so
what exactly is a binary tree well
pretty much the same as a tree the only
thing is it only will ever have two
children and the keys used to create
binary trees have a middle value as the
parent a lesser value than the parent on
the left and this is known as a left
child and a greater value than the
parent on what is known as the right
child you still have leaves of course
and even though the maximum number of
children is two you do not need to have
both children's in a binary tree so what
is an unbalanced tree well normally
random data isn't going to create what
is known as an unbalanced tree which you
can see it's just basically a tree in
which most of the nodes are found on one
side of route order data however can and
normally does create unbalanced trees
and unbalanced trees are bad because
they are slow so why should use a tree
based off of all the other different
data
lectures we sing well you can search
insert delete items quickly in a tree
and as we've seen in the past ordered
arrays are bad at insertions as well as
deletions and with length lists of
course finding items is quite slow and
the Big O notation for a binary tree
would be order of log n so if you saw
that tutorial you know that that's
pretty quick and on average just to get
down to it a tree is more efficient if
you need to perform all of the different
types of operations quickly so enough
talking let's get into the code okay so
if we're gonna be creating trees here
the very first thing we're going to need
to do is create nodes so I'm gonna
create a class and it's gonna have a key
value and this can contain most anything
but I'm just gonna basically throw names
in here and then of course you're gonna
have left child and another one that's
going to be right child and of course
they can contain null values because I
said that these children do not
necessarily have to exist we just can't
have more than one left child and one
right child and then I'm just going to
create a constructor here and assign
these new values and all of the code is
available in a link in the description
or under the video and then the final
thing that I want to put here isn't
necessarily needed but it would probably
be useful to be able to print out this
information on our screen if we want so
this is just going to return name plus
and half something like has a key and
then we'll print out our key and of
course come up here and change that to
lowercase and that is all we're going to
do in regards to how we're going to set
up our different keys now what we got to
do is go into the binary tree class so
inside of here every single tree no
matter what it is is going to have a
root value and let's just jump right
into it and start adding nodes and I'm
just gonna walk you through the whole
process here string and name because
every one of these is going to have that
and then we're going to come in here and
create a new node and we're also going
to initialize it so just pass over the
key as well as the name and let the
constructor do its work and then we want
to check if this is indeed the root
element for our tree and if it
we're just going to throw a new note in
there and be done with it
however else if it is not we're going to
create ourselves another node and I'm
gonna call this the focus node because
this will be the node that we are
focusing on and I'm going to set root as
this node because of course we're going
to start with root as we traverse
through our tree I'm going to show you a
couple different ways to traverse
through trees and then the future parent
for our new node we're going to need to
just set that up as well and then we're
going to go while true which is going to
create an infinite loop of course which
we're going to have to jump out of at
some point and then of course like I
said before we're gonna set our parent
as the focus node which we already know
is the root because that's where we're
going to start then I'm going to say if
key and check if the new node should go
on the left side or the right side of
our parent so I'm going to say if key is
less than focus node key then what we
want to do is change our focus to the
left child because remember the left
child has to have a key value that is
less than whatever its parent is then if
the left child has no children then we
want to place the new node on the left
of it so we're going to go parent left
child is equal to new node and then we
know that we're all done so we can just
return jump out of this thing else if we
get here then we know that we need to
put our node on the right so we're just
gonna go focus node is equal to focus
node dot right node a right child I mean
then we're gonna say if the right child
has no children which would occur if it
has a null value then we're going to go
parent right child is equal to new node
and then we're going to return out of
that and that is going to be all we need
to do to add new nodes to our binary
tree now that we have a way to add nodes
would be nice to traverse our nodes and
there's basically going to be three
types of traversal the inorder traversal
is going to aim for the smallest value
first what's just to put it simply means
that we're going to start at the left
child from the root which is up here
and what we're going to do is as null is
reached we're then going to move up in
values so in that situation once we get
down to 15 and then we try to find
another left we hit an all we then know
that we're going to jump back up into
the parent and then jump over to the
right child for said parent then after
that we're going to jump up into the
root node and then jump down through all
of the consecutive right nodes as long
as there is no left children to jump
into and that is the inorder traversal
let's take a look at it so like I said
all the nodes are going to be a visited
in ascending order and you're going to
see recursion is going to be used to go
to one node and then go to its children
nodes and so forth and so on
so I'm just going to call this public
void in order traverse tree and it's
going to receive a node which is going
to be our focus node and we're going to
say if focus node is not equal to null
we want to check that there's something
in there then we can copy this guy paste
him in there and we're going to traverse
the left node so we're just going to go
focus node left child then we're going
to visit the currently focused on node
because we know that that will be the
next value that is of the lowest value
and then after that we are going to
traverse the right child and that is all
that is to it so let's jump up into main
wherever main is mains down here and
let's start creating these guys so I'm
gonna go binary tree the tree and then
if I want to add nodes to this guy you
just come in here and go add node like
that and then let's say I want to give a
key value of 50 and then say that our
root is going to be the boss because
it's the very first one we're going to
put in there which means it becomes the
root then let's say that we want to
throw in five additional these guys
let's say 25 is going to be the
vice-president say 15 is going to be
office manager whatever I'm just making
these up 30 is going to be the secretary
75 key is
going to be our sales manager and then
85 is going to be just a simple salesman
let's say salesman one all right so now
that I have that set up I'm going to go
the tree and let's come in here and in
order traversed REE and this is going to
be the tree focus node and this is going
to be the tree root that's where we're
going to start out and if we execute
you're going to see office manager has a
key of 15 vice-president has a key of 25
secretary has a key of 30 and as you can
see here these key values are increasing
as we go so that's what we mean by in
order traversal so now let's take a look
at pre order traversal now with pre
order traversal what we're going to do
is first hit our main focus node which
we are starting off with root so that
means root will go first then what we're
going to do is cycle down through all of
our left's children after we are done
with that we're then going to jump up
one parent which means we hit null down
here so we jump up one parent then we're
gonna go to a right child and then we're
gonna jump back up into root and then go
downwards through all of our children so
let's see what that looks like in code
very simple so we can just jump up here
and to show you how simple this is I'm
just gonna copy this because it's
basically the same and there's a bunch
of different reasons why you would
Traverse in different ways but I'm not
going to get into that at this point
because we have enough to think about so
we're gonna go pre order traversal tree
and like I said before our focus is to
first get our focus node so we're just
going to cut that out of there jump up
here and paste it in there and that's
all you need to do that is going to
provide you with a pre order traversal
and of course the only other thing you
have to do here is bounce in here make
sure you change these I'll save it pre
order traversal and execute and here you
can see we're going to be getting our
routes we're then going to jump over to
25 then we're going to check our left
child our right child and then we're
going to jump over to the right child of
our route which is boss and then follow
downwards on the tree you know the other
type of traversal is known as a post
order traversal you can just coffee
this show you what that looks like post
order traversal and in this situation
this guy up here our route or our parent
node is going to come last and in this
situation we'll just copy this paste
those in there bounce down into main
throw that inner file save and execute
and in this situation what we're going
to do is jump down to the left child
then we're going to check the left child
of that parent node then the right child
of that parent node and then we're going
to bounce down to 75 there is no left
child so we're going to check the right
child and then finally bounce up the
route and if you look at our results
here that's exactly what we did jump
down to our office manager then we
looked at our secretary our
vice-president our salesman sales
manager and then finally route so that
is just a coverage of traversal like I
said it's something that you will use
later on I just wanted to cover all the
different ways to traverse binary trees
and the final thing I'm going to show
you is how to find nodes after you've
created all these trees so let's just
get through all these traversals and
let's just define this and let's say
that a nodes going to be returned after
it is either found or not found and you
are going to pass it a key which is
going to define what node you want to be
looking for of course just like before
we're going to start at the top of the
tree and the focus node and that
situation is going to be root then we're
going to say while we haven't found the
node we're going to keep looking and
that just means while focus node key is
not equal to key that we are searching
for we're going to keep looking first
we're going to check if the key is less
than the current focus node key value in
essence what we're saying here is should
we search down the left children if the
answer to that is yes then we want to
shift the focus node to the left child
of the focus node or the node we're
looking at else since we can only look
left or right that means that we want to
look right and in this situation we're
going to change the focus node to
whatever the right shot is and then if
we get down here if focus node is equal
to null that just means that the focus
node wasn't found and then down here we
go and return to focus node and I made a
little bit of mistake of course we're
going to search as long as the key is
not equal to the key that we're
searching for so make sure you put that
exclamation mark in there and now that
we have that set it's save and let's say
that we want to do a search for 30 and
then from that we want to say the tree
zoom in here find node and then type 30
inside of it and of course it's going to
return the node but we have to string
for node so it's just going to print it
out on the screen and let's execute it
and you can see it returned secretary
has a key of 30 so that is what a tree
is what a binary tree is how to create
notes how to add nodes how to traverse
trees and how to find nodes and like I
said in the next part of the tutorial
I'm going to cover the more complicated
topic of how to delete nodes please
leave any questions or comments below
otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>