<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learn to Program 16 Regular Expression Tutorial 2 | Coder Coacher - Coaching Coders</title><meta content="Learn to Program 16 Regular Expression Tutorial 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learn to Program 16 Regular Expression Tutorial 2</b></h2><h5 class="post__date">2016-08-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a7nuYAk2xK8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
16 in my learn to program series in this
part of the tutorial we're gonna
continue learning about regular
expressions and if you haven't watched
the previous parts of the tutorial I
provide a link here in the video to
watch those otherwise you may be
confused also in the description
underneath the video you will find a
transcript of this video as well as a
cheat sheet
you should definitely refer to that to
help you learn and I have a lot to do so
let's get into it okay so on this page
you'll see every single thing we learned
in the last part of the tutorial right
here we learned how to search to see if
the regular expression we're searching
for is found in our string and this
returns either true or false meaning
search returns true or false
we also found of course you're going to
need to import your regular expression
module and if you do you're gonna be
able to use find all which is going to
return a list of all the matches for
your regular expression you can then use
length to find out how many matches you
got you're gonna be able to use compile
then also to be able to create a pattern
object that's going to provide a whole
bunch of methods such as you see right
here with substitute which is going to
substitute whatever you put here inside
of this string right here and then you
have all of these other guys which we'll
also be reviewing in this part of the
tutorial so you could pause that and
look at it as a cheat sheet or of course
it's in the description now what we're
gonna do is go in and start creating
some new stuff okay to keep everything
simple I'm going to use the same sort of
format here and what I want to cover
here first is how we match 0 or 1 of a
specific thing you're searching for so
let's say that we have a string and it
has cat and cats inside of it and we
want to be able to match for cat as well
as cats so we're going to create our
regular expression here and we can
compile this and then we can put in all
of the letters that we want to be able
to match for so that's going to be ca
and T of course they don't need to be in
that order
we're then going to follow that up with
a plus which means that we want to
for one or more of anything that
proceeds or anything that is inside of
the square brackets and then the new
tool we're going to have is the s
followed by the question mark and the
question mark is going to match for zero
or one of whatever precedes it so that's
gonna allow us to match for cat as well
as cats we can then come in here and
find all of our matches with find all
throw our regular expression and the
string that we want to work with and
then we can output all of our results so
for I in matches and then print those
results out on the screen and if we run
it you're gonna see that it matches for
cat as well as cats and it also is not
grabbing the extra space right here
whenever we are grabbing cat so that's
quite useful so through the use of the
question mark we're able to match for 0
or a 1 of whatever precedes it and now
let's see how we can match for 0 or more
that guy is going to be the asterisks or
the star or the multiplication symbol or
whatever you want so let's say we have
doctor and doctors and doctors and we
want to match for that doctors there we
go so what's the regular expression
gonna be for this I often come in here
and just match for doctor I have two O's
and they're not needed but I just think
it makes it a little bit more readable
and that's why I do that then gonna put
the plus sign in there which is gonna
match for one or more of anything inside
of these square brackets then inside of
it I want to match for the apostrophe as
well as the s and then I'm going to
follow that up with the asterisk symbol
and that's going to match for zero or
more of what's inside of there and we
can run this and we can see right here
that we were able to match for doctor
doctors as well as doctors and it once
again we're not grabbing any extra
spaces which is quite useful and now
based off of everything we learned here
I think we should jump in and do a
problem now I have talked about
previously on Windows how new lines are
sometimes going to be
represented with a backslash n and other
times they are going to be set up to
work with backslash R followed by a
backslash n so what I want to do here is
over what I want you to do here to solve
this problem is for you to create a
regular expression that's gonna grab
each of the lines in a string so let's
go in and define that string just have
it be random string again however this
time I am going to use the multi-line
strings and then inside of it I'm going
to put just some words and by default
the newline meaning this guy is going to
show up at the end of this guy right
here then on the next line I'm going to
say in some more followed with a
backslash R once again the newline is
there because I'm gonna hit a new line
like that and then I'm gonna have more
so what I want you to do is create a
regular expression that's gonna grab
each of those lines in this string and
then on top of that print out the number
of matches on each line as well as
output your results so pause your video
and give that try otherwise I'm gonna
solve it right now okay most the code
here is going to be exactly the same
all I'm gonna change here is the regular
expression I'm searching for and what
I'm going to look here for is I wanted
to be able to match for any of the
letters or numbers that could possibly
be inside of here also I'm going to
search for spaces then after that I'm
gonna put a plus sign inside of here
which is gonna match for one or more of
anything that precedes that I'm then
potentially going to have a backslash R
so in that situation I'm gonna put a
question mark meaning that there is
going to be zero or one of those for my
matches and then I'm gonna follow that
up with a backslash n which I know is
always going to be there so that is the
regular expression you should have typed
in and if we run it you're gonna see
that I got just some words and some more
and more there you go hopefully he got
that right if you didn't don't worry
about it we're
here and that's part of the learning
process so now I want to go in and talk
about something that some people find
very confusing which is the difference
between greedy and lazy matching all
right so we're gonna create another
string inside of here and this guy is
going to have some tags around it XML
tags so let's say we have life on Mars a
TV show that I watched a long time ago
and let's go and say that we have
another one and this one's going to be
Freaks and Geeks
another TV show what I want to do is I
want to grab everything that lies at the
start of the name tag and the end of the
name tag okay so based off of what we
know so far this is probably how you
think you would be able to come in there
and grab these name tags you would type
in name and then you're going to have
your closing name bracket and then in
between it you're going to think well
we're going to get an individual
character and then we're going to put a
star inside of here and that star is
going to match either 0 or more possible
characters you have inside of there so
let's run this and so let's see what our
results are and you can see our results
are not good the reason why is it went
in here and it grabbed both of the tags
and the reason it did that is because
the asterisks character is what we call
greedy meaning it grabs the biggest
match possible versus grabbing the first
match and by biggest match what we're
looking for name and we're looking for
an ending of the closing name bracket so
it grabs this whole entire thing
meanwhile we just want to grab this
thing right here so what do we do well
we go in and we make it lazy and how we
make it lazy is just by simply putting a
question mark inside of it and by doing
so you're saying that you want to grab
the smallest match possible and if we
run it you're gonna see that yes indeed
it
comes out perfectly and even better yet
if you just want to get the names you
could do something with sub-expressions
which we'll talk about here in a moment
which is gonna grab just the names sub
pretty cool stuff and whenever you want
to grab the smallest versus the largest
possible match this is going to work not
only with the asterisks but you're also
going to be able to have this work
whenever you're using the plus sign and
also you're going to be able to use the
curly brackets let's say you did
something like and like that you could
also use the question mark there so
that's something for you to practice
around with and that is the difference
between lazy which means grab the
smallest match possible and greedy
which means grab the largest match
possible okay so hopefully I cleared
that up now let's jump over and talk
about word boundaries now we're gonna
use word boundaries to define where our
matches both start as well as end and a
little guy with a backslash B is going
to match the start as well as the end of
a word so let's come in here and let's
create our string so at the FX ape at
the apex and let's demonstrate this
regular expression here we are going to
use a raw string and we're going to say
that we want to match four eight and
let's run this and let's see what we get
as a result well we get eight and we get
a up here but what we want to do is
we're trying to grab only the eighth
word and not just the beginning of the
word ethics and word boundaries are
going to allow us to do that and to set
the word boundary all we have to do is
come in here and put a backslash B to
define the boundary and a backslash B to
define the end of the boundary and if we
do that we're gonna see that we only
come back with one result which is the
target that we are looking for and why
don't we come in here also and print out
the number of matches that we get just
so that we can have a little bit of
additional information there you can see
that we only had one
and that is quite simply as easy it is
to define the boundaries for the regular
expressions you are looking for so now
let's take a look at string boundaries
now for string boundaries you're going
to have two different tags if you want
to match the beginning of a string you
are just going to use the caret symbol
like we had before so say beginning of
string and then you're also going to
have another string boundary which is
going to be the dollar sign and this is
going to be the end of the string okay
so let's come in here and let's
demonstrate exactly how we can use those
with our little problems that we have
so let's come in and we have a string
and we'll say something like match
everything up to and we'll throw an app
symbol inside of there and basically
what we want to do is to match the whole
way up to the @ symbol starting at the
beginning of the string up to the @
symbol but not including the @ symbol
how would we do that well we'll throw
our carrot inside of here and that is
going to match for the beginning of the
string then we want to have any
character that we can think of and
that's going to be accomplished with the
period symbol and we're going to have
zero or more of those strings so we're
going to put the asterisks inside of
there and then we do not want the @
symbol so we're going to inside square
brackets put a carrot and an add some
and if we run that you're gonna say that
we match everything up to but we did not
get the @ symbol which is exactly what
we did not want to get so that's just
one demonstration of how we can match
the beginning of a string and now let's
go in and match the end of the string so
in this situation we're gonna come in
and we're gonna throw an app symbol and
specifically what we want to get is this
string right here get this string so we
want to ignore the @ symbol as well as
the space and just grab this guy right
here get this string how can we do so
well we're gonna use the dollar sign in
this situation so basically what we want
to ignore is the app symbol and we want
to also ignore the space at the very
beginning right there we then want to
have everything that lies after those
things we want to ignore and then we
want to grab everything up until the end
of the string and that's where the
dollar sign comes in and if we run it
you're gonna see that we get the string
that we wanted to get and we ignored the
at and the space that preceded it
there's also going to be another nice
little tool which is a multi-line code
and let's come in here and I'll do a
little bit more of a complicated example
here so let's go and do a multi-line
string and with this guy what we want to
say is we're gonna put 8 is big and on
the next line we'll say
turtle is slow cheetah is fast and what
we want to do here is we want to grab
the first word of each line and we're
going to need a new little tool that's
called the multi-line code which is
going to allow for the targeting of each
line after a line break with the carrot
symbol that we saw previously and that's
special code we're gonna throw it inside
of here is going to be parentheses
followed by a question mark and an M
once again this is gonna allow us to
target each line in this individual
multi-line string with a caret symbol
okay that's what that guy does for us
and we want to grab the first word of
each line so what we need to do then is
start out at the beginning of the string
we're then wanting to want to grab
everything we do not however want to be
greedy and grab the biggest match
possible so we're gonna put our question
mark inside of there and we're gonna
grab everything up to a space if we run
that you're gonna see we got the results
that we wanted we got three results and
we got ape and turtle and cheetah
alright so there's a demonstration of
the multiline code that's going to allow
us to use the caret symbols on
multi-line strings and now let's jump in
and talk about sub expressions which
we've already looked at briefly now sub
expressions are going to be part of a
larger expression so for example let's
say we wanted to match for a large block
but we only want to return part of it
like I said we showed that previously
what we're going to do
is we are going to surround what we do
want with parentheses so let's say we
have a string that's gonna be my number
is four one two five five five one two
one two and what we want to specifically
grab is this part of the telephone
number and we want to ignore everything
else how do we do that well we jump in
here get rid of that and we're gonna say
specifically what we are looking for is
4 1 2 - and then inside of here we're
gonna define what we want which is
basically everything else that follows
and that's just how simple it is and if
we run it you're gonna see we got one
match and we grab specifically what we
wanted and we ignored the 4 1 2 which
was needed so that we could skip over
all this garbage and not get any of that
so we were able to use it so that we
could find the position where we wanted
to start but then we only need it to
return the part that we want it so
pretty cool stuff so now based off of
that new knowledge that you gained let's
go and let's try a new problem alright
so what I want you to do this time is
I'm gonna throw a whole bunch of
telephone numbers inside of here let's
go throw another one inside of here ok
so we have all of these different
telephone numbers inside of here and
what I want you to do is to just get the
numbers minus the area codes from that
string and you could pause your video
and give it a go otherwise I'm gonna
show you exactly how to solve it or how
to create the regular expression that is
going to match for it ok so basically
what are we targeting well we're
targeting any for 1 to s followed with a
- however we only want to get the
telephone numbers out of there in this
situation what we can do of course we're
gonna use a sub expression we want to
match for anything that follows inside
of there however we do not want to grab
this and then continue grabbing all that
additional information there afterwards
so what we're gonna do is we're gonna
count 1 2 3 4 and then of course that's
gonna go out to 8 in this situation
we're going to throw curly brackets
inside of here and put an 8 for exactly
how many characters we want to
and that is the end of our regular
expression and if we run it you're gonna
see we got precisely exactly what we
wanted and finish off I wanted to cover
what are called multiple sub expressions
and what this is gonna allow us to do is
to grab let's say we have a my number is
and then we'll go our in this example
what I want to grab is this number and
have that be one result and then this
number right here and have that be the
second result so to do so I'm gonna use
two sub expressions so I'm just gonna
type in precisely what I'm looking for
which is four one two dash and then I
want a whole bunch of different stuff
right there followed by another dash and
then followed by a dot and an asterisks
and that is how easy it's gonna be to
grab both of those pieces of data as
individual pieces of data and then I'm
gonna come down here let's go and just
go down get rid of this part and if I
want to print out those individual
results we can just go matches zero and
then throw a zero inside of there to
grab the very first match and then if I
want to grab the second match and of
course we could do this with a for loop
I just do that and run it and you can
see that I was able to jump in there and
grab the 5 5 5 and the 1 2 1 2
individually so there you go guys
that is even more information on regular
expressions and in the next tutorial I'm
going to continue covering them until
you are an expert at using regular
expressions and just like always please
leave your questions and comments below
otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>