<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Assembly Language Tutorial | Coder Coacher - Coaching Coders</title><meta content="Assembly Language Tutorial - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Assembly Language Tutorial</b></h2><h5 class="post__date">2016-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ViNnfoE56V8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to my
assembly language tutorial in this
tutorial we're going to start exploring
assembly language in the world of
Raspberry Pi now there is a lot to learn
about assembly language and I don't want
to overwhelm you so this is going to be
a multi-part tutorial however I'm going
to explain registers vim make bits bytes
words nibbles adding and subtracting
converting binaries hexadecimals and
numerous different instructions and the
best way to watch this tutorial is to
get the code and the transcript that is
linked in the description underneath the
video and then pause your way through
the video as you work your way through
the examples and take notes in your own
language so I have a lot to do so let's
get into it
okay so here is our raspberry pi and
basically assembly language is one step
above the binary that runs your hardware
or this hardware and the assembler is
going to convert your code into binary
and we'll be programming the arm
microprocessor in this tutorial because
that's what is in the raspberry pi and
this code will only work with ARM based
chips but by learning assembly on a
low-cost computer like this you're
basically going to be able to easily use
assembly in general because the only
difference between assembly on different
micro processors are the mnemonics or
the instructions that you're going to be
using now of course the micro processors
are going to manipulate data and you're
going to tell them how to manipulate
that data by giving them certain
instructions like add a DD and sub su b
and most of these instructions are going
to start off as three letters long
however you're going to see that they
get longer depending upon different
capabilities you'd like to add to and
another great reason why learning
assembly on an ARM chip is a good idea
is because the R in arm stands for
reduced instruction set computing and
that means that there is a limited
number of instructions so I thought it
would be great to work with a low cost
computer like this and I thought this
would be the cheapest and easiest way to
dive into the world of assembler so now
I'm going to jump over and show you how
to set up all of our tools now I
personally am using Microsoft Remote
Desktop to go
remotely log into my Raspberry Pi and
you can of course do this on Windows or
Mac or whatever and of course you can
just go into the Raspberry Pi and do
everything here just exactly the same
way now the very first thing I'm going
to do and this is just the term and only
in a Raspberry Pi what I'm going to do
is install them and to do so you're
going to type in sudo apt-get install
them and this is going to be the text
editor that we're going to be using to
run and create all of our Raspberry Pi
applications and of course hit enter
there then I'm going to change into my
make my working directory if I want to
bounce back and forth between the
directories I can just go CD like this
and then I could make the directory that
I have here it's just a SM backslash and
projects that's how you put a space
inside of there but I already have it
created so I'm instead going to change
to that directory so a SM backslash and
projects and there I am inside of it now
if at any time you get an error that
says something like no space on device
or something like that what you're going
to do is go sudo raspy config expands or
expand root FS and run that command of
course you're going to have to type in
your password whenever you do that and
that's going to fix that error in case
you have that and now that we have them
installed what I'm going to do is jump
in here and start writing some code with
it now if I want to create my file that
I want to work with in vim I'm just
going to type in vim and ASM cut and
follow that with an S and here we are
inside of them now this might seem
really hard to work with but it isn't
after you get used to it so basically
there's different modes you're going to
use in different commands you're going
to memorize now if you want to start
typing inside of here you're going to
turn into insert mode and on to do that
all you have to do is hit the letter I
see insert pops up there in the bottom
left hand corner of the screen and if
you want to jump out of insert mode into
command mode you're going to hit the
escape key and then you're going to be
able to type all sorts of different
codes so you can come in here and put a
colon and then put a W and this is going
to save but not exit from your program
you could type in WQ that's going to
save and quit your
program you can type in Q and an
exclamation mark that's going to quit
and discord all of your changes we're
going to jump back into insert mode here
so I'm going to say some random stuff
and just show you some different ways of
course you can use your arrow keys to
bounce back and forth between all of
these you're also going to be able to
move to the front of the next word real
easy by just hitting W whoops you have
to hit escape first and then hit W say
just like that you're going to be able
to hit the B key to jump back to the
beginning of words so W forward B
backwards you're also going to be able
to type in a dollar sign that's going to
jump you to the end of the line and then
if you hit a zero that's going to jump
you back to the beginning of the line
another thing you might want to do is
let's escape out of this again and hit :
and type in set number and this is going
to allow you to see over put lines on
their number lines on your screen so
you'll be able to easily find any type
of errors you have and a whole bunch of
other different things are going to be
covered here as the tutorial continues
I'm going to ease my way into using them
now the very first thing I'm going to do
here just create just a simple little
assembly language program I'm going to
show you how to make a comment so this
is a comment
we're going to put a @ symbol inside of
there you're also going to be able to
put multi-line comments just by coming
like this and then close that off with a
star and delete this and then we'll
start writing some actual code now for a
simple program like this you don't
normally have to put dot text inside of
here what this is doing is it's defining
where your instructions are going to
start but you can put it in there or not
put it in there you're going to have
another part called data which we're
going to get into later it's just going
to allow the assembler to know where the
data part is and where the instructions
are but we'll get more into that here in
a second I'm also going to define a
global here and this is going to find
that start is going to be globally
available to the entire program and then
we're going to say start is going to be
the starting point this is what we call
a label and this is going to be the
starting part for our whole entire
program and we're going to be working
with things called registers so and I'll
get more into that here and
but if I want to move a value into a
register register the very first one is
going to be our zero and let's say that
I want to put a decimal number inside of
there that's how you do that and
likewise we're going to be able to store
multiple different values inside of
multiple different registers so these
are sort of like a raise so let's just
go to our seven register and let's throw
a number one inside of there and then
finally to end your program we're going
to say SWI
and then give it the code of zero and
that is basically telling the program
that you want to exit to the terminal
now SWI stands for a software interrupt
and the r7 in this situation having the
value of one is telling SWI that it
wants to exit to the terminal and the
value that we store in our seven is
called a system call number you're going
to see more of them as the tutorial
continues and depending upon how
different registers are set we're going
to be able to call other raspbian
routines and libraries to execute but
don't worry about all that just ease our
way through here so I'm going to escape
so I'm gonna hit the escape button and
I'm gonna hit WQ and that's going to
escape and save now if I want to compile
this I'm going to show you how to do it
with make here in a second so it'll save
you some time but wanting to show you
exactly what's going on we're going to
type in a s - oh and then assembly
taught and oh and then assembly taught
dot s which is our file and then we want
to make an executable file so I'm going
to LD - OH
assembly tut and then assembly tut dot o
and you can see there's no errors
popping up if I want to then run it just
go assembly tight and then if I want to
output some data which is going to be
the value that was set for our r0
register just going to type in echo and
then follow that up with question mark
whenever I did you can see that 65 shows
up inside of there and then if I want to
jump back into them you can see exactly
where the 65 was set so this is telling
us that we want to quit the program or X
or exit the application and go back to
the terminal and this is going to be the
output that shows on the screen whenever
we execute the
the application let's jump back out of
that again and let's come in here and
I'll show you how to actually create
multiple different applications and then
link them together so this guy right
here is going to be called assembly
touch to dot s I to go into insert mode
and again we're going to come in here
and go global underscore start and start
once again and these label names are
arbitrary you can have them be whatever
you want and then I'm going to go move
and this is going to output 65 and then
what I'm going to say is I want to
branch to another piece of code that I'm
going to create here in a second so go
be al I actually could just type in B
but I'm going to leave that just lay
that it is there's tons of different
ways to do things inside of assembler
and that's where I'm going to leave it
so I'm going to escape out of that WQ
again and I'm going to create the second
part of this application so I'm going to
go assembly type three dot s jump back
in here go into insert mode by hitting I
once again and again we're going to go
global part to define port to our label
move and then here we're going to say
that we want register r7 to have a value
of 1 which means jump back into the
terminal and then I can end it like this
and escape out of this WQ if we hit LS
it's going to show us the different
applications we created inside of here
or source files we create it inside here
and now if I want to come in and
assemble all of these I can just come in
and go to and - and then let's do the
same thing for 3 + 3 and then we can
come in here and actually execute and
merge these two source files by going
load and we'll go assembly Tut for
assembly Tut 2.0 and assembly - 3.0 then
we can come in and execute it and you
can see that the 65 shows up there so
that's just a way to compile multiple
different source files into one
executable application but to save
ourselves a whole ton of time what I'm
going to do here and you type clear in
to clear off your scroll back is I'm
going to create a make file and to do
that we're going to go vim and we're
going to call it make file go into
insert mode by hitting I what we're
going to do here is the make file is
basically just going to make it very
easy for us to compile our application
and what you do is you're going to have
a target inside of here and target is
going to be the name of the file that
you want to generate and then after that
you're going to have a prerequisite so
this is going to be anything that needs
to exist for us to be able to create our
target file and if the prerequisite
doesn't exist we have to create it in
the make file down below so let's go and
create something here so assembly Tut is
going to be the name of the file that I
want to finally be able to create here
and to do that I'm going to have to have
a assembly touch dot o file created for
me now you're going to hit the tab key
very important you have to have that
inside of a make file and then I'm just
going to keep this very simple just go
LD a show assembly Tut and then assembly
Tut dot o now we need the assembly to 0
file to be created it's a prerequisite
for us and this guy right here is called
a recipe by the way so that's something
we want to create so I'm going to have
to come down here and create assembly
Tut dot o and the assembly Tut dot s
file is going to have to exist for us to
be able to create that put that colon
inside of here and then the recipe for
that remember hit tab again get any type
of error it's probably because you
didn't hit tab and then we'll go
assembly tut o and assembly tes which we
know is going to exist then finally we
could also come in here and type in
clean and that is going to allow us to
issue a clean command with our make file
to be able to remove certain things in
this situation we want to remove all dot
o files and then we'll go assembly cut
and we'll escape out of this guy and
quit and then since we went and created
that make file if we want to execute the
make file I just type in make and it's
going to automatically go and compile
that for us and then we'll be able to
come in here and go and call for that
application execute and create output
and you can see 65 is right there also
if we go in and click on LS you're going
to see the o file show up there but if
we go make and clean and n LS you're
going to see the do files were deleted
okay so that's a quick whirlwind way of
compiling as well
as a little bit on using them and
creating your very first assembly
language program now I'm going to dive
in and talk more about registers bits
bytes words and nibbles now as you're no
doubt aware a bit is going to either
have a value of 0 or 1 a nibble is going
to be made up of 4 bits a byte is going
to be made up of 8 bits and a word is
going to be made up of 32 bits now the
arm CPU is a 32 bit CPU it's also
important to know that 4 bytes or 32
bits are going to be called words
because we are going to be referring to
words a lot as this tutorial continues
now the CPU as you saw previously is
going to contain 16 registers and
they're going to be able to hold a word
of data each and registers 0 through 12
are always going to be available to you
however some of these registers are
going to do very special things when
they have very special values inside of
them register 13 however is a pointer to
the active stack which we're going to
get into more here as the tutorial
continues and this is going to be where
you put your data on the stack and then
the stack pointer is going to tell how
high that stack data is like I said more
on that later
then register 14 is going to be the link
register now when an instruction is
going to call for a subroutine the link
register is going to be set to the
subroutine return address once again
more on that later
register 15 is going to be your program
counter and it's going to store the
address of the next instruction to
execute and it basically just keeps
track of where your program is in its
execution of the list of code that you
create and then you're going to see this
guy right here which is called the
current program status register or CPS R
and it's going to basically store a
bunch of information on your program and
the results of different instructions
that you're going to execute and we will
get more into this as the tutorial
continues basically whenever just to
give you a little bit more information
whenever you execute different
instructions these right here are either
going to have a value of 1 or 0 and here
if a negative result came about this is
going to have a value of 1 if a 0 result
came about this is going to have a
one or zero if it didn't come about that
way if a carry issues after an
instruction which we'll get into carries
here in just a second that's going to
have a value of one and then if an
overflow occurred this is going to have
a value of one once again don't try to
memorize all this stuff I'm going to
give you a bunch of examples so that you
can see exactly how this stuff works
now binary numbers are going to contain
once again either a 1 or a 0 and we're
going to be able to combine those to
make base 10 numbers like we're all very
very used to now you can think of base
10 in much the same way basically what
the number in base 10 1 2 3 means is
that we have one one hundred two tens
and three ones
likewise in binary you're going to be
able to say that right here we're going
to have one four with the value of one
one one we're going to have one four
plus 1 2 plus 1 1 and you can see how
all these values increment start off
with 1 2 4 8 16 and they keep doubling
on and on forever now if you want to
convert from decimal to binary and let's
say you want to convert the decimal
number 1 to 6 in the binary what you're
going to do is you're going to subtract
128 from it you're going to get a
negative number so that's going to be a
0 you're going to subtract 64 from the
126 next to get a value of 60 to move
that down there since you're able to
perform that subtraction you're going to
put a value of 1 there likewise with the
62 that's left over you're going to
subtract 32 from it you can do that put
a 1 there and so forth and so on and as
you can see it's pretty easy to convert
from decimal to binary numbers x'--
decimal numbers which are base 16
numbers are going to work in a similar
sort of fashion and the reason why we're
using hexadecimal numbers at all with
assembler is because it's going to be
easy to represent binary numbers as hex
numbers and hex numbers are going to
contain values from 0 the whole way up
to F and F representing the decimal
number of 15 but just so you know you
can pretty easily go in and a program a
lot of things with assembler without
knowing anything about binary or EXA
decimal numbers however they are quite
convenient as you'll see as the tutorial
continues but the main reason why
hexadecimal numbers are used to
represent binary numbers is you're going
to be able to easily represent four
bits of a binary number with Jonas one
hexadecimal number as you can see right
here we're going to be able to represent
these four bits with the 15 or the F in
hexadecimal and this is just going to be
one two four and eight which of course
whenever you add all those together gets
you the value of 15 now if you'd like to
convert a hexadecimal to decimal numbers
so for example you have a value of 2 a 7
what you're going to do is you're going
to take the 2 multiply that times 16 to
the power of 2 to get 512 10 which is in
hexadecimal and have represented by the
letter A you're going to multiply that
times 16 to the power 1 to get 1 67 is
going to then be multiplied times 1 we
get a value of 7 of course and then
you're going to add all those opposites
and you can see it's pretty easy to
convert from hexadecimal to decimals
likewise you're going to be able to
convert to decimal to hex numbers
through the use of division once again
you're going to start at the largest
value you're going to have in
hexadecimal numbers divide that by the
value you want to convert into
hexadecimal you're going to get a value
of 2 here you're going to throw out that
remainder you're then going to subtract
512 which is 256 times 2 and subtract
that and then get a final value of 167
then move the 167 down once again
divided by 16 get a value of 10 which in
hexadecimal is a again throw off the
remainder and likewise that allows you
to convert pretty easily the decimal
number of 679 into to a 7 which is a
hexadecimal number it's also a good idea
to be able to figure out how we can add
binary numbers so let's say we have 5 &amp;amp;
3 basically what we're going to do here
is 0 plus 0 in binary is going to equal
0 1 plus 0 is going to equal to 1 no
matter how you do it and 1 plus 1 is
going to be equal to 0 and then you're
going to have to carry the 1 so what
we're going to do here is have the
values of 5 &amp;amp; 3 what are we going to do
here we're going to add 1 plus 1 that's
going to give us a value of 0 which
we're going to carry the 1 we're then
going to add 1 plus 1 again which is
going to give us a value of 0 carry the
1 once again we're going to be able to
add 1 plus 1 once again because of that
carry get another value of 0 carry the 1
put the 1 here and that gives you the
final value of 8 once again pause the
screen if you want to look at these but
once again and you don't necessarily
need to know exactly
to add and subtract and do all these
different things with binaries and
hexadecimal numbers just wanted to cover
it just to be complete you can see
another example if you want to pause
your screen in exactly how these all
work out for you and of course it would
be a good idea for you to pause the
screen and go through and actually work
through all this yourself it's really
going to have the positive impact in
regards to helping you better understand
how different values are passed around
inside of the actual hardware of your
computer whenever you're subtracting
you're basically going to borrow one
from the left to make a zero into a
value of 10 in binary or the value of 2
and then you can go about subtracting
one as you are needed so for example we
come here and we try to subtract one
from zero we can't do it so what we're
going to do is borrow the value from the
one that is next to it so this becomes
the value of two inside of binary now we
can go in here and perform this
subtraction however we're going to get a
value of one remember this is two now so
two minus one is going to give us a
value of one and likewise we can work
this all out to find that six minus five
is equal to one in binary and you can
see here a much more complicated example
of how we can subtract binaries once
again go in here pause your screen work
this out on paper and it should make a
lot of sense however another thing we
can do is if we want to subtract binary
numbers is use something called the
two's complement basically to convert a
number to its negative form what we're
going to do instead is flip each bit and
then add one to it so infinite situation
with a seven which is going to start off
at zero zero 1 1 1 we're instead going
to convert all the zeros into ones as
you can see we did right here and then
we're going to add one to it this allows
us to add binary numbers instead of
subtracting them by converting the
binary value of seven into eight
negative seven and many people find it
much easier than then come in here and
add all these different values so that
you don't have to mess around with
moving values like you do whenever
you're subtracting binaries and just so
you know if you come working your way
through here using two complements if
you come to own to a situation in which
you have a carry bet with this one
falling forward you just simply delete
that to get your final correct result
okay so there's a rundown of how we can
use binaries and hexadecimals and how
they interrelate with
values or base-10 values that you might
be very used to so now I'm going to jump
back into the assembly language and for
the rest of the tutorial we're just
going to write a lot of code okay here
we are back in the world of Raspberry Pi
and what we're going to do here is
create a hello world application so I'm
going to go them assembly tut dot s like
I said we can get rid of this guy right
here so let's just go and get rid of it
everything else here is going to be
roughly the same but what I want to do
here now is output to the screen now if
you want to output to the screen you're
going to have to set registers in a
certain way first what I'm going to do
is set my r7 to the system call of four
and this system call is saying that we
want to write information to the screen
then going to come down here and in the
r0 I'm going to set this to the value of
one and this is saying that with the
output stream that we want to use is the
monitor then create another one you
don't need it doesn't matter where you
put these go and create another register
or assign a value to a register in r2
here what I'm going to do is define the
length of the string that I want to put
out on the screen so I'm going to need
12 characters there and then I'm going
to have to come in and load a message
that I want to be displayed into
register 1 and here I'm going to just
refer to a string that's going to have
the value of message and then we'll exit
out of that guy and then we're going to
define the end with this label here and
this is going to say that we want to
jump to the terminal so I can go r7
again number sign 1 and exit and then
here is where we will define our data if
we put the data part up here above the
instructions in those situations we
would have to put text inside of it or
just defining that everything that fall
is this is going to be our data I'm
going to define some data and it's going
to have the label of message and we go
ASCII and hello world is going to be the
value inside of that data then we can
escape out of that WQ call our make file
and then we can just call for our
application to run and you can see the
hello world print it out there so
basically what you're doing it's almost
like you're hitting switches and that is
allowing you to say hey I would like to
write
the screen or in the next dish situation
we're going to allow you to input
information from the keyboard let's just
go back into them again now if we want
to allow to get keyboard input we're
going to have our seven system call
that's going to be changed from four to
three we're then going to define in r0
or register 0 that the input stream in
this situation is going to be the
keyboard that's going to be 0 here we're
going to say that we want to be able to
read in 10 characters so there that is
once again we can load a value into the
first register and then we're going to
create another label here and this is
going to write and this is going to
allow the input of information and then
now we want to output that information
once again now we're going to be using
much of the same things up here so what
we're going to do and come up to this
line right here we're going to escape
out and we're going to hit the capital
letter V here and then we're gonna hit
down on our arrow keys this is inside of
them we want to copy those lines we're
going to hit a lowercase Y and then
we're going to come down here and do an
uppercase P and that saves us a little
bit of time in regards to we're able to
go in there and copy and paste those
guys so once again insert mode we want
to be able to issue the system call to
output information to the screen so
we're going to change this from 3 to 4
here we want to designate that our
stream is going to be to the monitor so
this is going to be one number of
characters we're going to want to write
this is going to be 5 and then this will
be the message that we print out on the
screen and then we can come down here to
the ending part that of course is going
to exit out of this application and then
for our starting value for our message
let's just come in here and give it a
space
nothing important escape WQ go make and
then we can go in and actually execute
this guy here it's going to allow us to
input information and remember I said
that I want to be able to read 10
characters and then output 5 characters
I'm just going to type in my name hit
enter and you can see that it went and
not only accepted that input but it also
printed that input out on the screen
so we're baby stepping our way through
here now we're going to take a look at
some other different instructions
regards to how we can add values so
let's go and open up vim once again now
basically the different instructions
that you're going to be using let's come
in and just type some stuff inside here
the instructions you're going to be
using are going to follow this format so
you're going to have whatever the
instructions name is and like I said
most of those are three to four
characters in length then you're going
to have your destination where the
information is going to be stored
whether it's in an a register or
somewhere else and then you're going to
put a comma of course and then you're
going to have an operand and another
operand and in some situations these
operands can be numbers or they can or
they must be registers and as you go
through you'll be able to figure out
exactly how those work but what we're
going to do here is just cover ad so
let's come in here this is going to be
pretty simple here escape out of that
capital V once again because we're going
to be deleting a whole bunch of
different things and hit D there that's
gone insert mode and we're not going to
need any data in this situation so once
again escape capital letter V and let's
get rid of that and delete go back into
insert mode and we'll come up here and
add some values now you're going to be
able to use hexadecimal numbers or
regular decimal numbers or binary so why
don't I just do that first I'm going to
do is I'm going to change this to
register 1 and if I want to put a
hexadecimal number inside of here I'm
going to go 0 that in then I'm going to
put an X and an A I'm down here to the 0
register or actually let's come up here
and let's use add so I'm going to say
add I'm going to that's going to be our
0 is going to be the destination
whatever value is in R 1 is the first
operand that I want to then add and I'm
going to create another hexadecimal and
this is going to be 14 so what I'm
basically saying here is I want to add
10 plus 20 using hexadecimal values and
then I'm going to come over here scape
out of this and delete all this stuff
and just keep out of everything all
together we can type in make and it says
whoops undefined symbol X 14 well it
looks like I forgot to put the 0 inside
of there no problem jump into there and
yes you can do to see that I did
get to put that inside of there insert
mode zero exit WQ now we can do a make
and you can see everything went and
execute it perfectly fun I want to come
in here and execute this guy and I want
to echo the final result out onto the
screen so just go echo dollar sign and
question mark and there you can see I
was able to go in there and add those
hexadecimal numbers but you can also say
that whenever I executed it it didn't
come back as a hexadecimal number or a
result it came back as a decimal value
of 30 so now let's jump in here and
let's subtract some values basically
we're going to do everything in exactly
the same way so let's go down here to
register one and let's give this a value
of fourteen we can then come in and
replace add with subtract and then we'll
come in and we'll change this to a or 10
once again escape out of that WQ make
and if we come in it and execute it you
can see that we get the value of 10 and
we can do a lot more complicated things
with add and subtract but just want to
keep this quite simple so let's clear
our scroll back we can also come in and
multiply values open this back up again
and we got our register 1 let's just
leave the values basically exactly the
same except in this situation we're not
allowed to come in and actually use real
numbers we have to actually create or
store the values inside of registers
whenever we're multiplying them unlike
with add and subtract so we'll just
store a value inside of a register
instead and then we'll change this to
multiply and change this to r2 for the
second operand everything else stays
exactly the same jump out of there make
execute and you can see we got a value
of 200 another thing that we can do is
Soak them again we can use something
called multiplied with accumulate and
basically what that's going to do is
multiply the first two register values
and then add that to the last register
value probably easier to just come in
here and do this so let's just leave
this
b14 leave this b10 let's come in here
and create or store another value in a
register so we'll use register r3 this
time store the value of 5 inside of
there and then instead of multiply we're
going to use MLA once again it's
multiplied with accumulate and you'll
see exactly how that works out
so we're going
to be storing everything in this zero
register and the zero e register is
what's going to output onto our screen
we're then going to take the operands of
r1 and r2 they will be multiplied times
each other and then finally we will add
whatever is stored in register R or
register 3 to the multiplication of r1
plus r2
okay WQ make an echo and you can see the
205 comes back we'll get more into why
multiplied with accumulator is actually
useful another thing I wanted to come in
here to them very often you'll want to
you'll come in here let's just change
this to any language changes to one and
you'll come into a situation in which
you want to undo a previous action just
go into the command line once again and
just hit you and you can see that we
were able to easily come in here and
undo that and ctrl R is going to allow
us to redo an undone action so you can
easily jump back and forth between those
different things but of course I want to
keep that as 0 and now I'm going to jump
over and talk about branching which is
going to allow us to do a lot more
interesting things
now basically branch instructions are
going to allow us to execute different
instructions depending upon different
conditions and register 15 is the
program counter and it's going to store
the address of the next instruction that
we want to execute as we saw previously
in a tutorial and after the instruction
executes the program counter is going to
be incremented by 4 bytes because each
instruction is going to be allocated 4
bytes we can however change how much the
program counter increments and execute
instructions out of order and this
amazing little tool is what is known as
branching so we're going to come in here
and let's just go and create or delete a
whole bunch of these different things so
let's just go ahead and let's change
this to register 0 and we can store or
14 inside of there once again if we'd
like or the decimal number of 20 and in
this situation we're going to come in
here and we are going to branch or we're
going to jump to a label that is called
other and we'll go and store inside of
the zero register value of 11 or B then
we'll come down here and delete all
these different things and find
they're here again I like to use
underscores sometimes sometimes I didn't
but because I didn't put it up there I'm
not going to put it here in this
situation and then for this label here
basically what we're going to prove is
the value of 11 is never going to be
stored in or 0 because we came down here
we executed start we moved the 14 inside
of register 0 then we said be other or
branch 2 other it's going to jump here
it's going to skip this line it's going
to jump down here and then it's going to
come in and end our program without
actually ever executing this line of
code and if that indeed is true whenever
we execute this it's going to output the
value of 20 instead of outputting the
value of 11 so let's come in here and
let's see if it's right make and execute
and you can see the 20 shows up
so basically branching just allows us to
skip around inside of our application
which is extremely useful now previously
I mentioned the current program status
register and what's going to be useful
with it is it's going to store
information about the program such as
operation results and like I said before
it's going to set a bit to the value of
1 if conditions occurred so we have here
are negative flag or zero flag or carry
flag and our overflow flag now the
negative flag is going to be set any
time a result of a calculation is going
to give a negative result here this is
going to give a value of 1 if the result
is 0 this will have a positive or a true
result if a carry actually existed and
we talked about how carries work with
binary addition previously and this or
the overflow flag is going to be set if
the result overflowed into the 31st bit
which is going to be used to signify the
sign of a value and we're going to use B
followed by two codes basically to see
if these values are either set or they
are not set as you'll see in the example
here in a second let's get back inside
of them and basically how we're going to
check if those different Flags going to
be set or not is through the use of the
compare instruction and the compare
instruction just as CMP and so for
example would say we want to compare the
value that is set for register
one virtues the value that is set for
register two values are basically going
to be compared by subtracting r2 from r1
or the values that are stored in those
registers and whenever this instruction
is executed we can then check our CPS
our flags and then conditionally execute
using branching like we saw before so
basically what we're going to do here is
if r2 is greater than r1 then in that
situation the negative flag would be
enabled because the result of this
subtraction is going to be a negative
value on the other hand if r2 is less
than R 1 then the negative flag wouldn't
be set in that situation and then if we
come into a situation in which these two
values are equal then whenever we
perform that subtraction with those two
values the zero flag is going to be
enabled so that provides us with a way
to come in here and basically form
conditional logic so let's just keep
everything else here exactly the same
and we'll go and we'll work this example
out so we're going to go to register 1
and I'm going to stop using hexadecimal
numbers here because that might be
confusing and I'm gonna set and store a
value of 5 inside of there and in the
second register I'm going to store a
value of 10 and then we'll perform our
comparison so I'll go compare r1 to r2
which you know that's a subtraction and
then I come in and bow BEQ and what this
is doing is it's going to say branch if
these values are equal if they are equal
I want to jump to the label called
values equal then I can throw in another
branch and this is going to be that I
want to branch
let's do bgt I want a branch if register
1 is greater and let's go and jump to a
label called r1 GT just for the heck of
it so now let's come in and find these
different guys let's just go and replace
this one and go R 1 less than to handle
the other situation that we might come
about and here I'm going to store
remember whatever the value for register
0 is that's what's going to output on
the screen so I'm going to change this
to 2 so basically if R 1 is less than R
2 we're going to output on the screen
the value of 2 and here
I'm going to branch to the end of our
application and then I'll just work out
all the other results so we'll go the
greater in the end situation and in that
situation will change us to the move and
in that situation we'll put a value of 3
inside of there and jump again to the
end of our application and if the values
are equal likewise we can go move and we
will put the value of 1 inside of there
we of course know that our 1 is going to
be less than 10 so we also know that we
can expect the value of 2 to actually
show up on the screen after this execute
don't need to put a branch to end here
because we're at the end of that so
we're just going to create end and move
into our 7 saying that we want to jump
out to the terminal that we are done and
there we go let's get out of that make
it and then execute it and you can see
the value of 2 shows up so there you go
guys
that is a rough overview of a whole
bunch of things we're going to be
covering with assembly language using
Raspberry Pi we're going to get into a
lot more cool things whenever we get
into the next part of the tutorial just
didn't want to overwhelm you here just
start off and just like always please
leave your questions and comments below
otherwise until next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>