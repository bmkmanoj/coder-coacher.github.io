<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Assembly Language Tutorial 4 Floats &amp; Switch | Coder Coacher - Coaching Coders</title><meta content="Assembly Language Tutorial 4 Floats &amp; Switch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Assembly Language Tutorial 4 Floats &amp; Switch</b></h2><h5 class="post__date">2016-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zj-cGdNpYZ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well internet and welcome to part 4 of
my assembly language video tutorial in
this tutorial we're going to talk about
floats and I'm gonna answer a question I
received which is how to implement a
switch statement inside of assembly
language and I'm talk--i that I'm going
to show you how to convert floats into
binary which is sure to make people
think you are very smart so I have a lot
to do so let's get into it
okay so the use of floating point
numbers is provided by the vector
floating point Co processor or VF P
which is what I'm going to call it from
now on
and the V FP is basically going to
provide single precision or a 32-bit or
double precision or 64-bit
floating-point numbers or it's going to
allow you to store them now every float
when it's stored as a binary number is
going to start off with a single number
which is going to tell you what sign it
is it's going to be 0 if it's positive
or 1 if it's negative and then bits 30
through 23 are going to represent the
exponent
while bits 22 through 0 are going to
represent the exact fraction so now what
I'm going to do and the exact fraction
is also known as the mantissa so now
what I'm going to do is I'm going to
jump over and show you how to convert a
fraction into what is known as the ie ie
format binary okay so let's say we have
this number here 0.40 6 2 5 when we want
to convert that into binary what we're
gonna do is we're gonna multiply it
times 2 and then if you get a 0 here
with a decimal number following it
you're gonna put a 0 there to represent
the fraction you're then going to take
this result move it down here multiply
it times 2 if you get a 1 here you're
going to then put a 1 to represent the
fraction you're gonna knock that one off
of there move the 6.25 in this situation
down multiply that times 2 and so forth
and so on until you multiply and you get
a result of 1 at that point you have
created your fraction or converted your
fraction into binary and you stop
so in essence 406 to 5 is going to be
equal to 0.01 1 0 1 but we want to
convert this into OEE
e binary which is going to be this giant
number over here and to do that what we
have to do is figure out how many
decimal places we need to move
one over so it'll be in the one position
here and then we're gonna take that
number which is two in this situation
we're gonna subtract it from 127 to get
125 that's gonna give you this binary
number right here and you can see down
here it's is a positive numbers this is
the sign bit that's something to be a
zero you're going to move the exponent
down here which is gonna be this guy
right here and then you're gonna follow
that up with the binary number which is
this giant thing right there and that is
how easy it is to convert a floating
point decimal number into a binary float
now we're not going to be able to store
floats in register 0 through 15 like we
did previously so we're instead going to
use the vfp or the vector floating-point
coprocessor registers that are provided
to us and those are going to be provided
to us in registers s 0 through s 31 for
single precision and D 0 and D 15 for
double precision and each D register is
gonna be mapped to whatever 2's
registers that you are currently not
using if you want double precision it's
not what I'm gonna do is I'm going to
jump over and start working with these
guys and show you some code ok so here
we are in raspberry pi we're gonna jump
into vim and start writing some code out
here now of course right here we're just
like always going to be telling the
compiler where main is gonna be located
and then we're gonna jump down inside of
main and create some code here all right
so first thing we're going to do is get
the address that is going to be
associated with pi well what I'm gonna
do is I'm gonna jump down in the data
section create that first at all I'm
gonna do here is just simply print PI
out on the screen so we're going to do
use a float here and I'm gonna type in
3.141592 and then we're going to provide
some output for print line to be able to
use and that's just going to be the
value of pi is and here we're going to
put a % @ F for float and then on top of
that we want to come in here and define
that we want to use printf and then
let's come in here and create there our
address for this address PI and of
course a link in the description is
available it's gonna have all this code
to help you along and it's gonna be
heavily documented and I'm going to
transcribe this video there so you will
be able to read it okay so all the stuff
that we've covered previously asides
from this guy down here being a float
now that's the first time we've ever
done that has been covered so the very
first thing I need to do is get the
address that is going to be associated
with our PI value so is address and PI
I'm then going to use a new command
called V LDR and what this is going to
do is store it inside of one of our rest
RS registers s0 in this situation the
value that I have associated with pi
which I have down here right there and
to do that I'm just gonna point at r1
I'm gonna use another command that's
gonna look a little bit complicated but
it's really not V CVT is gonna be used
to convert between floats and integers
so what this guy is going to do is
convert to binary 64 so what you're
gonna do is go F 64 and then we're going
to be converting from binary 32 so
that's what that does right there and
then we are going to be putting this
inside of D 1 which is another register
this is going to be for double precision
and the reason why we're doing that is
printf expects a double precision float
to be used and then after that we're
going to point at the register that
we're currently using which is s0 now
what we can do is load our output so the
print line is going to be able to print
out our little message along with the
value of pi so load into r0 our output
information and then we're gonna have to
insert our floating-point value in this
situation into registers R 2 and R 3 to
hold that double precision value and
printf knows if we are going to be using
a double precision float that the value
is going to be stored inside of there so
we're going to go in
and put that where it needs to be and d1
is where we're getting that from and
then finally we are going to call printf
and there we go so we just need to save
that and then come in here and compile
that this is we have an undefined
reference to output let's see what my
little error is I made here oh I came in
here I just put out what was I thinking
so there's output going to escape out of
that save it come in here and compile
everything compiled perfectly fine and
then come in here and run it and you can
see right there the value of pi is
3.14159 - and we were successfully able
to print out a float value on our screen
so it was all well and good to be able
to come in there and be able to print
out that information now let's go and
perform some arithmetic on that
information so what we're gonna do is
we're gonna come in here and change a
couple different things and basically
you are going to be able to perform two
different types of arithmetic modes if
you remember back here whenever we have
the registers of s 0 and s 7 and the
registers of d 0 through teeth ree what
this is going to be used for is the
scalar mode now how that is going to
differ is basically the scalar is just
going to store this information of these
float values inside of there in their
designated spaces
however these guys over here these other
registers are available to us are what
are called the vector mode and if you
choose to use those the operation is
going to operate with registers wrapping
values from the first place where you
decide to put a value on to all the
other additional registers that you have
available but just to keep everything
nice and simple here I'm just going to
stick with the scalar mode and perform
some basic arithmetic so that we don't
have to worry about how that information
is going to be passed back and forth
between all the other different
registers what I'm gonna do is I'm gonna
come down inside of my data section here
and I'm just gonna get rid of well let's
just come out here fee and let's just
lead all that and then let's throw some
new numbers inside of here so I'm just
gonna keep it simple have number 1 and
of course this is still going to be a
float and I'm gonna have this
one point two three four five and then
I'm gonna have another number inside of
here and you're gonna be able to perform
different arithmetic asides from just
regular addition I'm gonna do addition
now because everything else works
exactly the same and we're still going
to output our different information here
and here I'll just say one point two
three or four five plus one point 1 1 1
is equal to once again we're going to
throw a float inside of here along with
a new line and then we need to come up
here and create our addresses that we're
going to be using so this is gonna be
number one and change this to address
number one and then we're going to do
exactly the same thing for this place
that side of there
change this to number two and then
change this to number two and then we
can move up inside of here and actually
operate with these and show you how this
arithmetic all works out so once again
we're going to come in here and we're
going to be loading these values inside
of here so this is gonna be number one
and we're going to store that float
inside of register as a zero except
we're working with two values now so
much just coffee with us and come in
here and paste that inside of there and
then we just need to change this to
register to change this to number two
this is gonna be two as well and then
we'll change this to s1 and now we'll be
able to come in here and add these
values and how we add values is we use a
instruction called V add and we're gonna
put F 32 inside of here
and what we're saying here is that we
want to add single precision floating
point values if we wanted to use double
precision we wanted to use the d
registers for example we would put F 64
there instead and then we're going to
say that we want to store this in s 2
and then 2 values we're going to be
adding to each other are in s 1 and s 0
remember once again that we are going to
need to convert these to double
precision so that they will be able to
be used for you know for the printf
function because that's required so
we're going to change this to s 2 right
there and we can just leave this set for
D 1
we can then come down here leave this
exactly the same where we're getting our
output we then want to come down here
and make sure that we move our values
and the proper registers for printf to
be able to print them we're going to
need to put them in registers too as
well as registers 3 since their
floating-point values then finally we
want to print just like we did before
just everything's saved let's quit out
of that let's go and compile it and run
it and you can see right there that we
were able to add two floating point
values we would also and you can do this
for homework you'd also be able to
perform different other arithmetic
functions so on your own time you can
check out how you can subtract floating
point values as well as how you can
multiply floating point values as well
as divide floating point values and
there's a whole bunch of other different
functions you can use get it the
absolute value and you can even do
things like square root and I just leave
it to you to be able to go in there and
figure out all those other different
functions that are available to you and
now I'm going to show you how we can go
in and actually compare floating point
values let's jump back over into the
family n now basically the vfp has its
own version of CPS R which is what we
use to normally do comparisons between
values whenever we were not using
floating point values and it is called
the FP SCR instead of the CP sr and it's
going to provide the same flags and ZC
and V and we're gonna be able to use
conditional execution depending upon
what values we have stored inside of
floats
so let's come down here inside of our
data section once again I'm just going
to change these values up a little bit
we have address for number one let's see
what do we want to store in number one
well it's just one two three four five
that's perfectly fine yeah let's change
it to four doesn't matter what it is and
then for this guy down here let's just
go in and give it a value of five point
six seven eight just to be a little bit
different and then our output for this
guy is also gonna be a little bit
different change this to D and I'm gonna
put out a 0 for false and it positive
for true and all I'm going to do here is
convert and figure out if the values are
to each other or not so I'm going to say
our numbers equal and I'm gonna use
printf here once again and we can leave
these addresses exactly the same as we
had them before because nothing else
there has changed and will jump up
inside of the main area and once again
we're going to be loading in these
different values these floating-point
values into registers s 0 as well as s 1
just like we previously did when it come
in here and delete some of this other
stuff though just all of this so those
are loaded inside of there if you want
to compare values and set the flags so
that we'll be able to perform the proper
operations just gonna go in there and go
VC MP and we're going to be operating on
32-bit values once again if you want to
use the D registers you're gonna put F
64 in there instead and you're going to
provide the two registers that you want
to compare the values for you then want
to come in here and copy the flag set by
F PSCR over to your arm status registers
so VM RS is how you do that and ApS R
which it was a little bit easier to tell
you what's going on here but that's
literally what's going on and C V and FP
SCR and then what we're going to do is
we're going to conditionally assign
different values depending upon if these
are equal to or not equal to so I'm
going to just say move if they are equal
to I want to move into r1 the value of
one which is going to represent true
otherwise I'm going to if they are not
equal to each other I'm inside of r1 I'm
going to put a value of zero
and you could also go and put em o V and
check if they are less than or if they
are greater than
or if they are less than or equal to or
if they are greater than or equal to and
I leave that to you for your homework to
check out how those work then once again
we can now have our results set to the
register and inside of our zero we're
going to assign our output which is what
we assigned down below and it's going to
automatically put in either a 1 or a 0
depending upon if they were equal to
each other or not and this is going to
print and this is going to end the
program and now we can jump out of here
and we can go in and compile Oh have a
little error let's jump in there I typed
in and NZ CV silly air and then we come
down here and over here and let's change
that to that and let's jump out again
and off we go and make and compile this
guy you can see are the numbers equal
and the result comes back as 0 and if we
jump in them just to make sure that our
program is working the right way we can
go in and give this the exact same value
so let's just change this to one point
two three four escape out of it again
and we can recompile it and whenever we
run it you can see it comes back as one
so there's ways that we can both store
floating-point values and perform
arithmetic on floating point values and
then do comparisons against those
floating point values and now I'm gonna
jump over and I'm gonna answer the
question I got which is how can we
implement a switch inside of assembler
ok so here I am inside of them once
again and basically what I'm gonna do is
I'm going to check a different values
inside of a register to see if there are
either equal to zero one or if I don't
know I'm going to pop out a default
answer so I'm going to put out different
output depending upon the results so I'm
gonna go output 0
yes ciz and if it's equal to zero I'm
gonna say it's zero and if the value
that we are checking is equal to 1 I'm
gonna say it's 1 and the default like
most switch statements have it's going
to be like this yes ciz and in this
situation I'm gonna say I don't know
what it is and in this situation I don't
have any reason to use printf I just
want to print out a simple message so
since I can use all sorts of different C
functions this time I'm going to use
puts instead of print F jump up inside
of main once again and right here is
going to be the register I'm gonna be
checking I'm gonna say register 2 is
what I want to know and it has a value
of 1 I then want to do a comparison for
R 2 as well to check that if it is equal
to 0 and if it is equal
that's what BQ is gonna do for us I'm
gonna say that I want to jump to the
label called case 0 which I'm gonna
create here in a second and then I'm
gonna do the same thing here for our
other result let's just copy that paste
that inside of there and here I'm gonna
go or - I can use that again I can then
check if the value is equal to 1 and in
that situation I'm going to jump to
another label called case 1 and
otherwise I'm going to jump to a label
called case default and then I just have
to create the labels for them and this
is in essence a switch statement so we
can say case 0 and in here we can go
load into R 0 which is what I'm going to
use to print my special output which is
output 0 and then after that I can go B
end I'm gonna do exactly the same thing
here for case 1 just coffee that there
paste that inside of there and then I'm
going to change this to case 1 and I'll
change the output here to output 1 and
then I can come in and also create our
default case and for default I'll just
go output 0 and put that output there
I'm not going to need the end here in
this situation I'm not going to need
this additional case right here and then
down inside of the end statement I will
then print out our a result by calling
in BL and puts I just wanted to check
did I put global foot's downer yes I did
and everything else should be fine and
we can jump out of there
we can come in and we can compile it and
then we can run it and you can see right
there it's one pops back there we go
guys
there is a whole bunch of different ways
we can use floating-point values as well
as how we can convert a decimal floating
point value into binary as well as how
to implement switch inside of assembly
language and like always please leave
your questions and comments below
otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>