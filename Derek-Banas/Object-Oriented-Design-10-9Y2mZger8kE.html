<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Object Oriented Design 10 | Coder Coacher - Coaching Coders</title><meta content="Object Oriented Design 10 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Object Oriented Design 10</b></h2><h5 class="post__date">2012-12-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9Y2mZger8kE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well internet and welcome to part 10 of
my object oriented design tutorial today
I'm going to talk about grasp or the
general responsibility assignment
software patterns you can just think of
this as some tricks or rules to assign
proper responsibility to the objects you
create so let's get into it
now what exactly is graphs going to do
it's going to help you create good
object-oriented designs and there are
nine grasp patterns or rules just think
of these as simple rules
there's the Creator the expert low
coupling controller high cohesion
polymorphism pure fabrication
indirection and protected variations I'm
going to cover the first five in this
tutorial and then to end the whole
object or in a design tutorial I'm going
to cover the last four so what is the
Creator rule well basically when
defining or figuring out what will be an
object that will create another object
which is our goal here you should know
that object a should create object B if
object a contains object B or object a
saves object B to a file or database or
object a uses object B in some way or
object a has all the data needed to
instantiate object B and in most
situations more than one of these four
rules is going to be true so let's use a
real world example here and I'm going to
start writing some code to explain this
stuff let's say you need to create a
bike object now there's different ways
where you could do this you could create
a wheel class and a frame class and then
have those objects passed in the bike
and then create bike that way but as you
can see bike is not creating the wheel
really it is just assigning it and
storing it inside of here while the
wheel constructor is actually getting
the width of the wheel and creating the
wheel object and the frame is also
getting the length of the frame and
creating the frame object and then that
is being passed over to create the bike
it's much better to create the wheel
objects or instantiate them directly
inside of bike and I'm going to show you
why here in a second so here we are
we're going
right ourselves some code and I'm going
to present this in two different ways
one in which the wheel and frame objects
are actually created outside of bike and
then whenever they are actually created
or instantiated inside a bike so we're
just going to go private and frame the
frame and then we're going to create our
constructor for bike which is going to
be passed wheel this is the not so right
way of creating a creator or following
the Creator rule and then we're going to
just simply come in here and say the
wheel which is up above is equal to new
wheel object that's passed inside and
the frame is equal to new frame that is
passed inside and then just to keep this
brief I'm going to put main inside of
here
even though I normally wouldn't do this
and then we would go wheel is equal to
new wheel and then when we did find its
width
that's 24 and then we go frame ram is
equal to new frame and let's say it's 52
inches long I don't know I'm just
guessing about this stuff and then we
would create our bike is equal to new
bike and then pass in the wheel and
frame objects that we just created and
then of course we need to go inside of
wheel and create that private in width
and then create our wheel constructor
with is equal to new width and then we
could save that and then we're in
essence going to do exactly the same
thing inside of frame blink and then go
frame and one of you guys told me to
always type this information out because
you don't like it when I copy and paste
so from now on I'm gonna try not to copy
and paste so much and there we go so we
created both wheel and bike now however
let's say I want to create or
instantiate wheel and bike inside of
here I'm going to show you how much
easier it is going to be to create and
it's also going to make a lot more sense
to instantiate wheel and frame inside of
bike all I'm going to do here is I'm
going to create a different constructor
and instead I'm going to actually build
the bike totally inside of here by
passing in the length of the frame and
the width of each wheel so bike is
actually being built directly inside of
bike and we're going to go the wheel is
equal to new
wiill by passing it wheel with and then
we're doing the same thing for frame new
frame and frame length and now instead
of creating wheel and then creating
frame which are all the things your user
would have to do now to create a bike
they could just simply go bike bike 2 is
equal to new bike and then define how
big the wheel is how wide it is and how
long the frame is so this makes a lot
more sense we just created a bike pretty
simply instead of typing all of this out
so that is an example of what you should
shoot for when you are following the
Creator pattern this makes more sense
this one line in comparison to this 3
and the only thing that's different is
we instantiated wheel and frame inside
of here and that is exactly what we have
here this is going to allow the user to
provide parameters instead of forcing
them to create parts of the bike and
that's what you want to shoot for and
that is basically the Creator pattern
now there are other ways to improve the
Creator pattern of course if classes are
very similar you want to extend them
from either a class or an abstract class
or an interface and of course you want
to always implement getters and setters
for all of your classes and if you need
to save or load class information from
files or databases that should all be
done inside of a class and now we move
on to the expert pattern inside of grasp
now if an object a is going to
instantiate object B it must have all
the information it needs to create it as
we saw previously if we're going to be
building wheels and frames inside of the
bike class we need to get the wheel
width and the length of the frame in
other words object a or bike must be an
expert on how to create object B or the
objects wheel and frame and really that
is all you need to know if you're going
to create a creator object it must have
all the pieces to be able to create all
the pieces that make up the final object
real simple and now we get to something
extremely important which is low
coupling now a class with high coupling
relies on many other classes for it to
work properly
and a class that has high coupling is
not going to be reusable it's going to
be hard to understand in isolation and
it's going to be very easy to break if
other classes that it relies on change
so let's take a look at a code example
make this make a lot of sense all right
so what I'm going to do here is I'm
going to build the wrong way to do it
and then I'm going to show you the right
way to do it so we're going to come in
here and we're going to create a monkey
class inside here monkey Java I'm going
to make all the code available in a link
underneath the video so what are we
going to do this is going to be pretty
simple but I'm just going to go string
name and remember this is the wrong way
to do it this is going to be a high
coupling situation and then I'm going to
show you a low coupling situation and
this whole program basically is just
going to store different animal names
inside of it and to a certain extent
this is also going to show you the
strength of polymorphism and one way to
use it which is going to be covered in
the next part of the tutorial and then
I'm just going to put two string inside
of here so that if the object is called
it is going to export if it object name
being monkey is going to be inside of
system.out.print line for example it's
going to print out this line or this
string and there we go so there that is
and that is our monkey and then we're
going to do pretty much exactly the same
thing with the lion
so just need to come in here private
string name same exact thing that we did
before create the constructor which is
going to be passed a string which is a
new name and then we're just going to
assign named or whatever new name was
passed over and then public and return a
string to string and return lion named
and then returned the name of it so then
we'll jump back over into list animals
and show you a high coupling situation
so here what we're going to do is go
private monkey is going to be stored
inside here a monkey object and we're
also going to store a lion object the
lion then we're going to go list animals
which is going to be the constructor
which going to be passed a monkey it's
also going to be passed a lion object
and I'm just going to go the monkey is
equal to the monkey that was passed into
it and the lion is equal to the lion
that was passed into it and then public
boy
I'm going to display the animals in the
zoo for example and you're going to see
how limited this is here in a second and
then this is just going to go
system.out.print line and because I have
to string inside of there whenever I
call this this is going to print out the
string that I created in the to string
function and the same is going to be
true here for whenever I called lion and
then down in public in the main function
args I'm going to create a monkey object
new monkey and let's say I want to name
him Max and I'm going to create a lion
new lion and I'm going to name him Tom
and then I'm gonna go list animals
create this object here is equal to new
animals and then go monkey and pass it
in the lion and then go list animals and
if I want to display my animals that I
have inside of here I would do that and
that low looks well and good and it's
all coded properly and if I go and
execute it you're gonna see that it
prints out monkey named Max and lion
named Tom the only problem is what
happens if I get a new member of the zoo
that is a reptile oh now I'm gonna have
to come in here and it's going to have
to print out the reptile and I'm have to
change code here and then I'm also going
to have to come down here and change the
code inside of here and then I'm also
going to have to come up to the
constructor and change the code there
this is what we call a high coupling
situation this is bad we do not want to
do this because list animals is highly
coupled to monkey and lion and then on
top of that I'm going to have to change
so much code it's just overwhelming so
now I'm going to go in and show you how
to do this the proper way using low
coupling and we're going to do that
using polymorphism so I'm going to come
in here and create an animal class and
animal is going to have private string
name like that and then I'm going to
create a constructor for it animal going
to have a string new name and it's going
to do sort of the same sort of thing
you're going to see just this little
tiny bit of code here that's in essence
the same sort of thing if done right is
going to provide an unbelievable level
of structure it's going to be very very
flexible and I'm just going to go return
and I'm going to put in animal and
you're probably thinking well it's not
going to put the type of animal yes it
is just give me a second here
and there we go
so two-string got all that set up and
now we're going to go into monkey 2 and
we're going to extend animal and make
this work and do a ton of other
different things we're going to do
similar sorts of things and make a
private string name actually forgive me
here for a second because I'm looking at
waste my time of that because they
Nessun Saul this is exactly the same so
I'm just going to copy that
so if you went and you've typed out what
was in monkey originally you don't have
to retype it it's all right there it's
same sort of thing the only thing I'm
going to do is I'm going to change this
to monkey 2 and then on top of that I'm
going to come in here and type in super
which is going to be a call to the class
that we're going to extend which is
animal and that's it that's all I needed
to change there so that's it pretty
simple and I'm going to do the same sort
of thing with Lion so I'm just going to
copy this because it's exactly the same
jump over into Lion and we're going to
paste this right here see same sort of
thing same exact thing the only thing
that's different here is I'm extending
the animal class that's all and then of
course I got to make a call new name
like that and there we are that's all
set and now let's get into list animals
too and let me show you how much more
functional this is under a low coupling
situation which it's not heavily tied
into monkey in line so this time I'm
gonna go private ArrayList and I'm gonna
hold an array list of animal all of a
sudden now I have so many different
types of animals an unlimited number of
animals that I'm going to be able to
throw into this guy so that's great new
and then this is going to be a ray list
animal just like that base that there
throw that in there and there we are so
we got an ArrayList that's going to hold
all this and it is giving me an error
because I don't have the ArrayList
library inside here so there we go now I
got what else do I need to do not much
I'm gonna go public void add I'm also
going to make this feel more real
because if you're putting a new animal
inside of your zoo well it definitely
makes sense to have a method that would
allow you to do that and it does it in a
very understandable way we're just gonna
go add new animal and now all of a
sudden we're gonna have all of our
different animals added in in a very
logical way everything should feel like
it's a real world sort of scenario
animals don't just appear in zoos they
are put there so display animals
using knives exactly the same except in
this situation I'm going to use an
enhanced for-loop
I'm going to go animal animal saw
animals like that and then
system.out.print line I'm going to print
out my animals see now I can put out as
many animals as I want not tied or
restricted in any way no the number of
animals I have in my zoo and I also can
have any type of animal as long as it
extends the animal class I'm going to go
public static void main just like we did
before all the time and now we're going
to go animal monkey is equal to new
monkey to remember and then this guy's
going to be named max and then we can
create a whole bunch of these guys and
go lion for example we can have anything
as long as I have another type of class
for another type of animal type that
extends animal I can just keep putting
these guys in here say I'll just go
animal lion - just to show you see I did
something limited lion - and then let's
just say his name is Carl there we are
and there's Carl and now list animals -
list animal is equal to new list animals
see I don't even have to do anything
with a constructor don't need one and
now if I go listing animals I can just
go in here and type add animal to list
and throw in my monkey that I created
add another animal and throw in my lion
and there's lion - just to show you that
it's unlimited I can do as many things
as I want tons of flexibility and then
just go list animals display animals and
call that method and execute it and boom
monkey named max line named Tom line
named Carl and there is an example of
low coupling we're going to get the same
results but now we aren't tied to
specific classes and we can add
additional classes without needing to
change anything it's awesome there's
different levels of coupling first you
have dependence which just simply means
a class depends on another class but
that class isn't a member inside of my
class so that just means that a class
uses another class and normally this is
a situation in which an attribute or a
variable or a value is passed over this
is an example of very low coupling then
we have Association this is a class
contains a reference to an
other class or situation where a class
has a other class and then you get into
composition or aggregation very very
similar if you've seen parts passports
this tutorial you've seen that this is a
situation where class holds an instance
of another this is a owns a or a class
is part of another class and then you
have the highest level of coupling which
is inheritance and this is where we
either implement or extend another class
but here I showed you how to use
inheritance in a situation in which
those classes are going to have lower
coupling than what they previously had
it really comes down to you need to
design classes that are independent so
that changes in other classes have no or
very little effect you want to avoid
creating subclasses and if you do
subclass make sure that you subclass
interfaces or abstract classes and of
course you want to add flexibility and
encapsulation to classes to avoid major
problems from high coupling if you have
to use it make sure your classes are
flexible encapsulated and in that
situation coupling normally won't be an
issue then we come to another pattern
inside of this called high cohesion this
is a measure of how focused the
responsibilities of an object are it's
very important to keep classes very easy
to comprehend maintain and they also
need to be reusable you want to create
classes that handle very few
responsibilities for just one part of
your system that's the goal have many
classes that handle all the little
pieces of your system and those classes
should have very few methods and should
work with other classes to fulfill any
needs that would be considered more
complicated and if you are ever in doubt
whether you have one individual class
handling too many responsibilities of
course delegate and here from my past
examples you can see an example of
cohesion and we have high cohesion we
have bank computer which does so many
different things and yet look at this
it's nice and tight and compact the same
thing can be true for ATM which we're
going to see here in a second which is
going to use the controller pattern it
is also very tight and neat and compact
and does only what it needs to do
so let's take a look at controller this
is the final part I'm going to cover in
this tutorial and whenever you're
creating a controller the question
you're going to be asking is what object
is going to stand between the UI and is
going to coordinate all of the system
operations that guy is going to be
called the controller and in most
situations the controller is going to
represent the device that the software
runs it in my ATM software example the
ATM object was the controller and the
controller is going to be used to handle
and connect most other objects and to
easily figure out which object inside of
your system is the controller just look
for the object that connects most of the
other objects in your sequence diagram
so let's look at that here is the
sequence diagram that we created
previously in the passports of this
tutorial and if you look at all these
guys you can see what is being called
what has most of the nodes that are
being run over and over again you can
see this guy's pass information back and
forth and constantly get new information
and what is that guy
ATM all these other little pieces have a
couple nodes here and there but ATM is
overwhelmed it has a ton of different
nodes so what does that tell you if you
see this in a sequence diagram ATM is
your controller and you can see an
example here of ATM here's all the
different things it's going to
coordinate it is going to first create
itself by connecting itself to a network
of banks it's then going to check if my
ATM cards readable check if the ATM
cards bank is in the network it's going
to handle insertion of the pin it's
going to pick the account to access the
amount of withdraw and then print out
the final information for the
transaction ATM in this situation is my
controller and whenever you're creating
systems using object-oriented design you
want to make sure you have a singular
controller and the main job of the
controller is it's going to receive
messages from the UI or the user
interface and it's going to forward
those requests to the proper system
objects and this is going to lower
coupling of the UI to those system
objects it's going to allow the UI to
change dramatically or in any way
without in any way affecting your
overall system it's very important to
remember the UI
never handle logic or act as the
controller because if it does that is
going to dramatically limit the reuse of
your system UI also shouldn't handle
system events those should be handled by
other objects inside of your system and
if you ever find or think that your
controller is bloated all you need to do
is create many controllers and have each
of those controllers represent different
parts of your user interface so that is
the first part of grasp in the next part
I'm going to cover all the rest of the
parts of grass and that will be the end
of the object or in a design tutorial
leave any questions or comments below
otherwise till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>