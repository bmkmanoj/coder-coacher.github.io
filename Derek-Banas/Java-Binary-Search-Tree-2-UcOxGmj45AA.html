<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java Binary Search Tree 2 | Coder Coacher - Coaching Coders</title><meta content="Java Binary Search Tree 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java Binary Search Tree 2</b></h2><h5 class="post__date">2013-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UcOxGmj45AA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
14 of my java algorithms and data
structure tutorial today I'm going to
finish off binary trees if you didn't
watch part 1 I provide a link in the
upper left hand corner to part 1 of this
specific part of the tutorial and also a
link to all my java algorithms tutorial
in the right side of the screen today
we're going to focus in completely on
how to delete nodes and binary trees
because this seems to be something that
hangs people up now and then don't worry
all of it will be quite understandable
by the end of the tutorial so let's get
into it
ok so I'm going to do a basic
walkthrough on exactly how we are going
to delete nodes and we're going to start
off with the root node this is a binary
tree and what exactly we're going to do
in our code in a second whenever we want
to delete the root first our questions
going to be is this the root if it is
which it is we are then going to say ok
what is the right child of the root and
we're going to designate that that is
going to be the replacement and then to
move it into place all we need to do is
take whatever the left child was
previously for root and assign the left
child 275 boom that's all we need to do
so what are we going to do if we want to
delete 25 like we have in this situation
well first we're going to ask is 25 less
than 50 depending upon that answer which
is yes that is going to determine if we
go to the left or to the right whatever
we get down here we're going to say
what's the right node for 25 well that's
30 so that means that we have to set the
root up here left child to 30 which is
going to move it into place and then set
30s new left child to 15 which will make
25 disappear then how would we go about
the leading 15 well pretty much the same
thing we're gonna first ask is 15 less
than 50 yes it is
okay we're gonna move down here we're
gonna cycle through all these left
values till we get down here
I'm going to say okay what's 15 s right
child well that's 18 well we know we
want to move that into place we then
assign the 25 s left child to 18 and
then we take whatever the previous left
child for 15 was and assign that day 18
which will move it into place just to
look and see what would happen if we
tried to move something that is on the
right side of our binary tree we would
come in ask is 75 greater than
Oh 250 yes it is okay fine we're going
to come down here what is the right
child for 75 well that's 85 well that
means we need to move 85 into the 75
position and to do so we just need to
assign 85 s left child to 70 and then
also forgot to put it here but we're
going to have to make 50 or the route
part of our binary trees right child
equal to 85 problem solved so that is
all we're gonna do in our code so let's
get into it okay so in making these
tutorials you may or may not know that I
like to make trees using a composite
design pattern but in this tutorial I
decided just to stick with the normal
way these algorithms are taught and so
that is what I'm going to do all right
so the very first thing we're going to
do is we're going to create ourselves a
method named remove that's going to pass
back either true or false depending upon
whether a key was indeed able to be
removed from our code and the very first
thing we're going to do is to find a
couple nodes inside of this guy there's
going to be the focus node which is the
node we're going to be focusing on and
making a lot of decisions depending upon
what we can get from the focus node and
we're also going to set parent also two
roots so that we are in essence starting
at the top of our binary tree when we're
analyzing to figure out how to remove
different keys then it's going to be
very important like you saw previously
that when we're searching for this node
to delete that we know whether we should
be looking to the left or to the right
when searching through a binary tree so
I'm going to create a boolean it's going
to be called is it a left child and
that's enough information I'm going to
set that for true then I'm going to say
with a while loop Wow the focus node the
node we're looking at is not equal to
the key that we are looking for we want
to keep searching and we're going to set
parents equal to the focus node as we
cycle through this guy then we're going
to decide if we should search to the
left and we'll know that depending upon
if the key is less than the focus nodes
key and that was the very first thing we
did and there's a little picture
diagrams I showed you in the
presentation was check that then so I
don't have to type this out again and we
come
in here and we know that it is a left
child and we should set it to true even
though it's set for true because indeed
it is a left child then we want to shift
the focus node to our left child because
we know that it is indeed a left child
and we do that by going focus node left
child right like that and there we go
else in a situation where it's not a
left child we come in here and set this
guy to false because it's not a left
child and then we're going to set the
focus node to whatever the focus nodes
right child was which is going to move
us to the right that's all pretty simple
and then if we get down here that means
that the node was never found and in
that situation we're just going to go
focus node equal to null which it has to
be and in that situation we're going to
say return false and there we are
so weren't able to find it so too bad
and we're going to end your using the
remove method now if the node doesn't
have children now we're into the
situation we're going to try to delete
these guys we're going to say focus
nodes left child is equal to null and
focus nodes right child just copy that
change this to right so if it doesn't
have any children
and if focus node is equal to root well
that's pretty simple we just set root to
null because there's nothing else we
need to change and of course come up
here and set that to null as well so
here we're basically saying if it
doesn't have a left child or a right
child and it's equal to root then just
set root the null and we're done and now
we're going to say if it was marked as a
left child of the parent delete it in
its parent and how we're going to do
that is go else if now we're gonna check
if it was a left or right child as to
just get this guy right here paste that
in there and that's what we're gonna do
is just go parent left child is equal to
null which in essence is like pretty
much deleting it and then after the Hat
we're gonna say else we know it's a
right child now so we can just go parent
right child is equal to null so that's
how easy it is to get rid of these guys
whenever they are in leaf format or they
do not have any children
now bounce down out of here and we'll
handle the situation and
which there is no right child here we'll
just go focus node we're in essence just
asking it right child is it equal to
null and if the answer to that is yes
we're gonna say if focus node is equal
to root then root is going to be equal
to focus nodes left child and move that
into place else if it is a left child
see if I save that yes I did good when
that situation we're going to go the
parents left child is equal to the focus
nodes left child and move that into
place and then finally else we're going
to need to set the parents right child
equal to the focus nodes left child
right like that and that is just setting
the left child and the right child and
so forth and so on so that in essence
the nodes disappear then we have to
handle the situation in which there is
no left child so here we're going to say
else if focus nodes left child is equal
to null then we're going to do pretty
much the same sort of thing but rather
than cutting and paste and then I'm
going to go through and explain
everything here then we have to handle
if the focus node is actually equal to
root actually I don't need those braces
if it is root is going to be equal to
the focus nodes right child else if it
is a left child in that situation the
parent dot left child is equal to the
focus is right child so just moving the
children together all we're doing here
and then in essence vice versa we will
do the opposite which is set the parents
right child equal to the focus nodes
left child and there we are then we get
into a little bit more of a touchy
situation in which two children are
involved and in this situation I'm going
to actually have to figure out what the
replacement should be so the node that
is going to replace the other node and I
need to create on
their method and I'm gonna call it kit
replacement
node and to do so I'm going to pass it
the focus node and then just store
whatever it sends back into the node
named replacement and I'm going to
create that in a second but I'm almost
done here so I might as well just keep
going well then I'm going to say if the
focus node is root then I need to
replace root with the replacement that
the sent back which you know from
watching previously is going to be
whatever roots right child is and to do
that is equal to replacement pretty
simple else if it's a left child we're
going to say that the parents left child
needs to be equal to whatever the
replacement is that this guy right here
is going to send back to us and then
else finally parent right child will be
equal to replacement then after we're
done with all that we need to say the
replacement has a left child and that
left child needs to be set to whatever
the focus nodes left child is so that
everything makes sense and we don't
break our tree and then if we get down
here we know that everything's
hunky-dory and it worked so we need to
return true
because indeed this method is a boolean
type or it returns a boolean type just
as you see right there so that is in
essence the rooh' move part so now we
need to come in here and actually handle
get replacement node and how that's
going to work pretty simple I'm just
gonna say public and it's going to
return a node and its name is get
replacement node obviously and you're
going to send in a node which is going
to be the node that needs replaced or
I'm going to call it the replace node
technically not replace node because it
hasn't been replaced yet but I think you
get the idea then we need to define our
replacement parent as well as the
replacement itself so replacement parent
and that's going to start off with
whatever the replaced nodes value is and
then replace Munt which is the guy
that's going to replace the replace node
it's also going to be equal to replace
node in the beginning
then we're gonna create another node and
this is going to be called the focus
node you've seen it before and we're
going to get that by getting whatever
the replaced nodes right child is
remember we were always replacing with
the right child that is the specific
code that's going to handle that and
then while there are no more left
children we're going to keep going
through this so we just go while focus
nodes not equal to null and then we're
going to be going replacement parent is
equal to whatever the replacement is and
then replacement is going to be equal to
whatever the focus node is and then the
focus node is finally going to get the
focus nodes left child assigned to it
and that's just the same thing that's
just moving the left child remember we
were moving left child up here we were
moving the right child up and then here
we're moving the left child up let's
look at that remember whenever we're
getting rid of 75 we first moved the
right child up right here well then we
need to design the left child which is
this guy to the 85 to get it to move
into place
hopefully that makes a little bit more
sense okay so now that we're done with
our while loop if the replacement isn't
the right child what we need to do is
move the replacement into the parents
left child slot and then move the
replaced nodes right child in the
replacements right child just refer back
to those pictures if that didn't quite
make sense since all we're doing we're
moving around the other nodes by
changing the value of left child and
right child that's pretty much all we're
doing it becomes confusing only because
the codes long that's the reason why I
took me a while to figure out if I
wanted to refactor this whole thing or
not but I figured if I did refactor it
that that would make any academics out
there mad so I just left it as it is so
we're gonna say here left child in that
situation is going to be equal to the
replacements right child and then
finally replacement it's right child is
going to be equal to the replace nodes
right child like that and then after
we've done all of those different things
we now know that we can return
replacement and know that the
replacement is known and
everything's going to work so let's take
a look now in Maine and let's actually
go and execute some of this so let's say
that we want to come in here and just
put a message like remove key 25 and you
should probably get this code and play
around with it to really get this then
to remove things we're just going to say
remove and pass it in a key so let's say
we want to get rid of 25 no problem and
if we file save it and execute you're
going to see when all the nodes are
printed out that you do not see the key
25 so there is a rough-and-tumble sort
of walkthrough on how to remove nodes
inside of binary trees please leave any
questions or comments below otherwise
till next time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>