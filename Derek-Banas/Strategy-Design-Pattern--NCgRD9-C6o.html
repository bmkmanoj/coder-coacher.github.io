<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Strategy Design Pattern | Coder Coacher - Coaching Coders</title><meta content="Strategy Design Pattern - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Derek-Banas/">Derek Banas</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Strategy Design Pattern</b></h2><h5 class="post__date">2012-08-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-NCgRD9-C6o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well hello internet and welcome to part
3 of my design patterns video tutorial
today I'm going to do something a little
bit different for this tutorial this
should be self-contained 100% just on
the strategy pattern unless you do not
understand basic olp concepts if that's
true refer to part 1 and 2 of these
tutorials but from this point on all of
these tutorials will be 100%
self-contained and to teach you the
strategy pattern I'm going to write bad
code so you can see in which situations
you would need the strategy pattern I'm
also going to demonstrate it in code
format just like always and then I'm
also going to explain it using a
presentation as well as a UML diagram
and like always all of the code is
heavily commented and this is another
great way to learn this concept download
the code and read the comments it's free
so why not so let's get into it okay so
we don't mo over here we have a couple
classes to find we have animal dot Java
and then we have two subclasses
underneath of it dog Java and bird Java
and what we're trying to try to do here
is figure out how we can give bird Java
and other animals that are subclasses of
animal dot Java the capability to fly
now this is where the bad code part
comes in because I'm going to come in
here and just think about how we could
accomplish this using techniques that
we've already learned well one thing I
could do is just come in here and go
public void fly and create a method
inside of animal dot Java and then have
it do something like I am flying print
that out on the screen and there you go
why is this bad well you never want to
add any methods to a superclass like
animal Java if they do not pertain to
any subclasses you need to separate what
is different between subclasses and
their superclass what your answer to
that might be like oh you're being silly
because inside of dog I can just simply
come in here and override just like
we've always done in the past and just
create my own fly method and everything
is going to be dandy and you could do
that but again we're learning rules here
on how to write good code we need to
continue to abstract out what is
different and put just those things that
are different
inside of the classes however that would
not make sense to come in there and just
put it in the bird dot java class
because in that situation because we
would be creating a lot of duplicate
code if we expect a lot of our animals
to be able to fly so we would go in
there and continuously every time we
created a new animal and it just so
happened to fly we would go in and add
in the method fly over and over and over
again so we also want to avoid that
issue let's go back over here and let's
delete this because that's just wrong
don't want it that and you're also going
to find if you would come in here and
create an interface let's say called
flies that would then force all animals
to figure out exactly how they're going
to use the fly method that is also going
to create a massive amount of duplicate
code to basic principles that you really
have to get into your head is you want
to always eliminate duplicate code and
you also want to eliminate any
techniques that cause one class to
affect others a superclass change
shouldn't break code in a subclass and
vice versa if there is a situation on
which that seems to be happening you
definitely want to rectify that however
using the strategy pattern we are going
to use an interface but we're going to
use it in a completely different way in
this situation I'm going to create this
interface flies just like we did before
except in this situation it's going to
return a string that's not really
important so don't really focus on that
what is important is we are going to
create separate classes it flies which
is going to implement the Flies
interface and then in this situation
because it's going to implement that
we're going to go add on implemented
methods and get rid of all this extra
nonsense we don't need and then in this
situation we're going to go into return
and I'm going to type something like
flying high and then I'm going to create
another class so I'm just going to copy
this and it is also going to implement
the Flies interface except it's going to
be cold can't fly yes I know that's
spelled incorrectly and then here we're
just going to change this to return I
can't fly and there you go so now what
we did was we created an interface and
we're then going to use this interface
inside of animal as an instance variable
and then
we're going to dynamically change that
instance variable to be either of type
class it flies or class can't fly and
why this is a great idea is the
interface is implemented by many other
different subclasses and what this is
going to allow us to do is create many
different types of flying without
affecting animal or any of the
subclasses and then from that point on
classes that implement this new fly
interface are going to allow those
classes to use that code while also
eliminating code duplication and this is
known this is a technical term as
decoupling which means that we are
encapsulating the concept or the
behavior that varies and that behavior
or concept is the capability to fly
you're not quite getting everything
don't worry about it I'm going to show
that to you in multiple different ways
so let's jump over into animal and
implement this and it's going to be
quite easy to implement remember we're
just going to create a new instance
variable I'm going to make it public I'm
going to call it flies and it's going to
be of type flies and I'm just going to
go flying type like that so instead of
using an interface in a traditional way
we use instance variable that is a
subclass of the Flies interface an
animal doesn't care what Flying type
does it just knows the behavior is
available to all of its subclasses and
this is also known as composition
instead of inheriting an ability through
inheritance the class is composed with
objects with the right ability built-in
and another great thing about
composition is allows you to change the
capabilities of objects at runtime so if
you create an object an animal object
and it starts off as a non flying object
but then it grows a set of wings and all
of a sudden can fly dynamically you can
go in and say okay I know this object
didn't fly before but now it does so it
gives you a never-ending supply of
different capabilities so now that we've
created this guy we're going to be able
to just zoom down inside of animal
jojoba and type in public string try to
fly like this and then it's going to
return flying tight and it's going to
call the fly method right like that and
then another thing we're going to make
this all dynamic which of course we want
to if possible we're going to go public
void set
flying ability it's going to be passed a
flies object which is going to be new
fly type and then we can set Flying type
dynamically new fly type by setting it
to that object so let's save that so now
what are we going to have to do with dog
Java and bird dot Java to make those
work actually very little I'm just going
to go into the constructor area whenever
our dog object is built and we're going
to say flying type is equal to new and
in this situation we're going to call
can't fly this is going to set the fly
interface polymorphically and this is
also of course going to set it as a non
flying animal and by polymorphically of
course I just mean we're going to refer
to the flies interface but we're going
to set it to use can't fly they can't
fly class underneath of interface that's
it that's all we need to do with dog to
give it the capability to not fly and
you might say to yourself well the bird
must be really hard to get it to fly of
course nope just going to go in and go
flying type is equal to new it flies so
we're using polymorphism we're doing all
kinds of crazy stuff and that's it
you're done so now you try this
tricked-out program let's just file save
that and we're gonna jump into animal
play dot Java we're just going to create
some things so I'm going to create an
animal called Sparky and he's going to
be a dog and then I'm going to create
another animal called Tweety and she's
going to be a bird and then go
system.out.print line and let's say we
go dog and then have Sparky figure out
if he can fly or not and see what Brits
print out on the screen and then we're
gonna do the same exact thing with
Tweety but we're just gonna say bird
here Tweety I'll save it execute it see
what happens there you can say dog I
can't fly bird flying high just the way
we want it and I'm gonna come over here
remember animal dot Java created this
method here that's going to allow me to
dynamically set my flying ability let's
say our dog here all of a sudden gets
this amazing ability to fly flying
ability I'm just going to create new
object inside of the dog object by going
in and set in the instance variable for
animal Java so on
no one's passing it I knew one of these
flying types inside of here and to do so
just go it flies just create it all safe
and now after doing that boom I'll say
oops seed and there you see now the dog
flies so that's the code for it now I'm
going to jump over and show you a UML
diagram to sort of make sure that I
completely cement this in your head okay
so here is our UML diagram basically we
have our animal in the plus here means
that this is a public instance variable
or a field and its name is Flying type
and it is of type flies and flies is the
interface over here and the actual
strategy involved in the strategy
pattern is to define a family of
algorithms these are the algorithms it
flies or it can't fly though they are
just those to encapsulate each one and
make them interchangeable so we're going
to encapsulate them inside of this
interface called flies and then we're
going to allow the animal over here as
well as all of its subclasses to
dynamically switch between either you
being a it flies or a can't fly what's
great about the strategy pattern is it
lets the algorithm vary independently
from clients that use it so it's really
cool all this different stuff is all
inside of there so let's review you are
going to use the strategy pattern when
you want to define a class that will
have one behavior that is similar to all
the other behaviors in a list so we have
animals that fly and animals that don't
fly the similarity is that flying is
involved whether it is they can't fly or
they can fly or to explain it another
way you want a class object to be able
to choose from not flying fly with wings
fly super fast by adding in the strategy
pattern you're going to be able to
dynamically create whole new different
types of flying typed animals so to get
right down to it you're going to use the
strategy pattern when you need to use
one of several behaviors dynamically
other good reasons use the strategy
pattern it often reduces long lists of
conditionals so if you start seeing that
using many many different types of
conditionals chances are strategy
patterns going to help you out of course
like we said a hundred times it avoids
duplicate code it keeps class change
from forcing other class changes it also
allows you to hide complicated or secret
code from the user and pretty much there
is only one negative you're going to
have an increased number of objects and
classes if you use the strategy pattern
so there is a strategy pattern leave any
questions or comments below chances are
though the code is going to explain it
all to you
so go and get it otherwise till next
time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>