<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building A Non-Deterministic Ram - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Building A Non-Deterministic Ram - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building A Non-Deterministic Ram - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JXBeenjw1Ok" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as you have seen non-determinism is
pretty powerful so the question is of
course could we actually build a
non-deterministic Ram and as I told you
before I have no idea how you would do
that so if somebody asked me to build a
non-deterministic Ram I will turn them
down although if you could build one of
these you would certainly become quite
rich and famous the next best thing we
can do to building a non-deterministic
Ram though is simulating one and of
course you will be asking yourself well
if he doesn't know how to build a
non-deterministic Ram how is he going to
simulate one well the answer is actually
not that difficult but i'll have to warn
you because the simulation will not be
very satisfying or at least we'll have
to pay quite a steep price for the
simulation so the first thing we should
probably talk about when we want to
simulate a non-deterministic Ram on a
deterministic Ram is how we would
simulate a deterministic Ram on a
deterministic Ram so basically a picture
like this you have a deterministic Ram
and of course it's branded as a
deterministic Ram and on that machine
you do a simulation of another
deterministic Ram and this might look a
little bit more complicated than it
actually is so all it means is that if
you had a program code that you run on a
deterministic Ram instead of running
this code directly you have another
program and this program is basically
going through your code and simulating
what your code is doing and this program
here which would be the simulator is
basically looking at the code and
simulating what this code would actually
do without running it directly on the
machine so it's running indirectly on
this machine here another way you can
look at this simulation is this diagram
here so you start out with a certain
program that you want to simulate and of
course you also start out not only with
a program but also with a memory of that
ram and if you remember in the last unit
we said that the RAM had actually
different kinds of memories some memory
for the inputs and for the output and so
on but we'll just draw this as a single
memory here so we start out at the first
line of code and then because it's a
deterministic
that line of code specifies exactly
what's going to happen next so it
specifies certain modifications that we
make to the memory so we might change
this variable here or even change two
variables although this is not often
going to happen in one single line of
code but we make some modifications to
the memory and we're still in the first
line of code here then we're going to
check if that line here actually is a
statement that tells us that we are done
if that is the case then the simulation
would also be done but let's say that
this is not the case we can then go to
the next line of code in our simulation
and again that line will also specify
some other things that were to do so
most of the time it's going to be again
changing variables may be it's reading a
variable but let's say it's also
changing additional variables so we
check again if we're done we go to the
next line of code and so on until we're
done and the reason why this simulation
works and it actually works rather
efficiently I would say is that
determinism means that each line of code
specifies exactly what's going to happen
next now for our next quiz I would like
you to think a little bit about the cost
of this simulation or the properties of
this simulation so I would like you to
tell me if instead of executing a
program directly or running it directly
on a machine we do a simulation of that
code what are the properties of that
simulation in other words what does it
cost us to do such a simulation
obviously it will take longer because we
are wrapping some other code around the
original program but how much longer
does it take does it take longer by a
polynomial time factor and by a
polynomial time factor i mean if for
example the original algorithm would run
an o of n square time then the
simulation would run in or 0 0 of n to
the power of 4 times something like that
does it take longer exponentially maybe
so if the original program ran in Oh of
N squared time we would now run and say
2 to the power of n time or two to the
power of n times n square time and
finally is this sort of simulation
robust so will it always give us the
same result that the original program
would have given us or is there a
possibility that such a simulation can
make a mistake</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>