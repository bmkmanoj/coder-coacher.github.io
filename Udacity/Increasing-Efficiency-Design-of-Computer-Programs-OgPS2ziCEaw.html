<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Increasing Efficiency - Design of Computer Programs | Coder Coacher - Coaching Coders</title><meta content="Increasing Efficiency - Design of Computer Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Increasing Efficiency - Design of Computer Programs</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OgPS2ziCEaw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">however here's something that bothers me
in the definition of roe plays we're
calling fine prefixes of hand inside
this loop where we renew Maury ting over
the row so it's going to happen multiple
times going to happen one time for every
anchor and eventually when we have
multiple rows it's going to happen for
every anchor on every row but notice
that fine prefixes only depends on the
hand it's not dependent on the row at
all so it seems wasteful to be
recomputing find prefixes of hand
multiple times if you're just dealing
with row plays that would be easy enough
up here we could say you know found
prefixes equals fine prefixes of Han
assign it to a variable and then just
reference the variable down here so we'd
be computing it once outside of the loop
rather than many times inside the loop
but eventually we're going to have a
bigger function that calls row plays
once for each row and we wouldn't want
to have to compute that each time within
row plays we want to compute it just
once we could pass into Rho plays the
set of prefixes but that's just
complicating the interface so I'd like
to cut down on the computation without
complicating the interface in other
words I want fine prefixes when you pass
it a hand if it hasn't seen the hand
before go ahead and compute all the
prefixes if it has seed in the hand
before then I don't have to recompute it
I'll just look it up and return it
immediately so what I want you to do is
take fine prefixes and make it more
efficient we could just slap a memo
decorator on the front of fine prefixes
that's probably not exactly what we want
because note that fine prefixes is
recursive oh it's going to call itself
on each sub component of the hand really
we want to say I only want to remember
the top-level hand if I've seen that
exact hand before then give me the
answer don't give me the answer for all
the sub parts of the hand you could
write a different decorator that work
just on those parts so that might be
hard given that it's recursive where you
could modify the function itself or you
could have two levels of functions one
top level function fine prefixes that
calls another function recursively your
choice as to how you want to handle it
however you handle it the idea is that
if you call find prefixes with a certain
hand and you get back this result then
if you make the same top love
call again it should immediately return
the same result that it saved away
rather than trying to recompute it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>