<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transmission Control Protocol | Coder Coacher - Coaching Coders</title><meta content="Transmission Control Protocol - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transmission Control Protocol</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/d9MB0J1DRMY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ports are an important addition to
network communication but if that were
all the transport layer did the
application layer would be left to cope
with some common problems given the
terrific complexity and scale of the
Internet it's no surprise that packets
occasionally get lost or delivered out
of order it sure would be nice to have
some kind of acknowledgement that the
packet got through that way we could
resend a packet if necessary and achieve
more reliable communication and for
larger messages that need to be broken
up into lots of smaller packets it would
be nice to have some kind of numbering
system so that if they arrived out of
order they could be reassembled moreover
we would like to know if we are
overwhelming the recipient with too many
packets too fast or if we are causing
congestion on some link in the route so
that we can be a good citizen and slow
down all of this functionality is
provided by the transmission control
protocol or TCP inside the transport
layer TCP doesn't just start off firing
packets towards some destination without
warning the conversation begins and ends
with a polite handshake to mark the
beginning and end of an exchange once
the connection is established data can
go both ways from initiator to recipient
and vice-versa let's take a look at an
example I'll use some unrealistic a
small numbers to keep things simple and
I'll rename the initiator GT and the
recipient Udacity at this point the
connection is pretty much symmetric so
the vocabulary for the handshake becomes
confusing GT issues a request and sets a
push flag meaning send me your data then
Udacity begins transmission back great
but what if the pep one of the packets
is dropped that is to say they don't
make it across the internet in our
example let's suppose that the first
packet doesn't make it
we would like a way to detect the
situation here is TCP solution after the
initial handshake packet or segments as
they are called in TCP parlance indicate
how much data the other side should have
received already and also how much data
the sender has received the former is
called the sequence number and the
latter the acknowledgement number during
the handshake both these numbers get
incremented by 1 in this scenario
TCP will be able to detect the drop
packet because the next message
thinks that 9 bytes is the amount that
should have been received but in reality
GT has only received the
initial acknowledgement you might think
that GT would send a packet saying could
you resend that please but actually the
system works by positive acknowledgments
instead of requests for retransmission
if the packet had gone through the
traffic should have looks like this so
even though GT doesn't really have
anything to say to you daddy he should
have been sending empty acknowledgement
packets to Udacity indicating that the
packets were received to make an analogy
to human conversation this is like
saying ah huh periodically to let the
other person know you are listening
going back to the case where the first
packet is dropped we now see that upon
receiving the second packet GT would see
that a packet has been dropped and
simply won't acknowledge the first one
or the latter one after enough time has
passed
Udacity will notice that it hasn't
received an acknowledgement for that
first packet and will retransmit it when
GT receives the retransmitted package he
can now send an acknowledgement for both
packets saying that he has received 17
bytes worth of data together this system
of acknowledgments and sequence numbers
helps achieve the first two goals I have
to refer you to a networking class for
more complete discussion of the third
goal but I do want to briefly discuss
the idea of window size in this example
Udacity has sometimes sent out a packet
before it received an acknowledgment of
the previous one this is typical for TCP
and how much one side is allowed to get
ahead of himself in the conversation is
controlled by a window size parameter a
good way to visualize this is by drawing
the data that needs to be sent as a long
bar and then dividing it into the
packets that actually gets sent we have
the packets that have been sent and
acknowledged the ones that have been
sent but haven't been acknowledged yet
and the unsent packets this middle part
representing the packets sent out but
not acknowledged represent the window
and as the during transmission the
window will slide across to the right
the windows size
puts a limit on how wide this window can
get if the window is too small then it
can slow the connection down as the
sender has to stop and wait for an
acknowledgment for every packet if the
window size is too big then there's a
risk that it will overflow the buffer
of the recipient or of one of the hops
along the way resulting in packet loss
so it's important to get the window size
right you can explore other aspects of
TCPS flow in congestion control by
following the links in the instructor
notes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>