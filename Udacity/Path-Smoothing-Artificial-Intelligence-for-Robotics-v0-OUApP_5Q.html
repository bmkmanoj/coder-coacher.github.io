<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Path Smoothing - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Path Smoothing - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Path Smoothing - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2012-05-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v0-OUApP_5Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how can we optimize these two terms
over here the idea is to use gradient
descent that is every time step we take
a small step in the direction of
minimizing the error over here so here's
the expression for the first objective
when we iterate we assigned to why I
recursively the old why I buy we
subtract a term that's proportional to
the deviation of Y I to X I waded by a
weighting function alpha that's not
exactly the same alpha as before and we
said this alpha over here to 0.5 for the
second term we could implement this as
follows where we retain the old Y
variable but we move a little bit into
the direction of y plus one of Y I plus
one and away from my I but even by the
implementation looks as follows
this is combining the step on the left
and the step on the right realizing that
each Y i occurs twice in this
optimization term one here and once here
we can now go and implement this in a
single update rule where we wish by I to
be as close to Y I minus one and
simultaneously be as close as Y I plus
one by optimizing this combined term
think about this a little bit but that's
what I want you to implement and we're
gonna set better to zero point one so
now let's go and implement this and is
the last hint I don't want you to apply
this optimization for the first or the
last node in the sequence I want those
to be unchanged as we'll see in a second
so here's the code I'll be giving you
there's a path in a five by five grid
starting in zero zero two four four and
if you look very carefully goes to the
right at first then straight down then
to the right again this is exactly the
path we discussed so far it looks like
this graphically
I now want you to implement the function
smooth which takes as an input the path
our two weighting factors and in small
tolerance variable which I explained you
in a second and it creates the new paths
which are the Y's in our equations so
far from the old path this is a deep
copy over here and then below the line I
want you to implement the smoother what
the smoother does it iteratively applies
the two equation just gave you two all
nodes except for the first and the last
and it does so until the total change
observed in the update step becomes
smaller than tolerance at which point we
consider the smoother to have converged
so here's my command I compute a new
path as a result of function smooth and
in your test you should uncomment the
new path smooth routine and the print a
routine that outputs my result
thanks for intere a student who posted a
but better way to output matrices on a
discussion forum I'm going to use his
coat or her coat thank you so much and
here's the result after hitting run I
have the original path over here zeros
all the way to four for the two initial
and the end position should be the same
as before so please don't modify them
but in between we get these
interpolation positions over here if you
look at this my original path didn't
vary the X's at all for the first three
steps whereas this one goes from zero
zero the zero point 1 7 so it got closer
so I went down a little bit and also
went less to the right side than my
original path they've been all the way
to 2 over here to one point eight over
here what this means is that our new
points lie a little bit like this and as
he go through the list over here you'll
find there are new points really smooth
out the path to something more like that
hi I'm Andy the assistant instructor for
this class and I just wanted to provide
some clarification about how you're
going to use gradient descent to
minimize these functions first I'd like
to point out that there is a slight
error in the path used in Sebastian's
code that for four that he was using
should actually be replaced with a for
two also those minus signs that you saw
here should actually be replaced with
plus signs if we want this gradient
descent implementation to converge
finally even though these Y eyes and
Excise are two-dimensional vectors when
you implement your code it may be easier
to just iterate over each individual
entry so for example these X eyes would
be these values here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>