<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Turning Back Time Solution - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Turning Back Time Solution - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Turning Back Time Solution - Programming Languages</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PWe56GNZZAY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this final exam problem we are given
a regular language in the form of a
non-deterministic finite state machine
and we want to construct another non
deterministic finite state machine that
accepts exactly the same strings but
backwards so let's say we have this
regular expression that accepts strings
that begin with an a and end with the
sea and in between have one or more
occurrences of BX + B Y an example
string that that regular expression
matches looks like this a bx bx be y and
c so we do a B X dy and then see so here
I have a finite state machine
representation of that regular
expression we start with an A we require
at least one bx or B Y and then we can
repeat the bx + b y afterwards many
times as we want and we finish with a
see remember the finite state machine we
want to generate we have to accept
strings like this when we begin with the
sea we then have y b XB XB and then a
our strategy for doing that is going to
be basically reversing all of the edges
in this finite state machine to go the
other direction and finishing it off by
changing the start state with the
accepting state ok so the first thing
I'm going to do is change the start
state and the accepting state so now we
start at six and finish at one and now
I'm going to change all of the arrows
and we're done if you look closely
you'll see that this finite state
machine matches exactly the same set as
the original one Steyn a state machine
but backwards so what's apply that same
methodology to coding our solution so
I've started coding the solution and the
first thing I do is create a dictionary
to contain the reversed edges and I
switch the start and accepting states
now I'm going to go through each of the
original edges and right here on these
three lines I'm just extracting the data
from the original edge and the original
finite state machine to make it easier
to manipulate later so for this edge in
the original finite state machine i'm
looking at i'm going to go through each
of its destinations so that i'm going to
create an edge that goes the other
direction and because the way we
structure our data structure i'm gonna
have to do it in kind of a continuing
fashion I can't just finish the edge I
have to look at every edge in the
original
one before I can be certain that i
finished the edge in the new finite
state machine so this line of code sees
if we've already created the beginning
of this edge and that's going to
overwrite the empty list we have before
and either way we're going to set the
new state of this edge in the new finite
state machine to be the concatenation of
the before list with the added state
that we got from this iteration and once
we're done going through the original
finite state machine we just return the
result</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>