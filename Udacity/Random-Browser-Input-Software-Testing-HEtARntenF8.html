<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Random Browser Input - Software Testing | Coder Coacher - Coaching Coders</title><meta content="Random Browser Input - Software Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Random Browser Input - Software Testing</b></h2><h5 class="post__date">2012-07-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HEtARntenF8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's take a little bit different
view of this same problem so don't want
to do is draw a graph here so in the
level of code coverage but our random
test cases are inducing on the system
under test again we're testing a web
browser and on the x-axis this is going
to be a little bit fuzzy unfortunately
but what I want to show is how far into
the web browser we execute which is just
checking for example if the incoming
data is even valid HTTP once we get
valid HTTP the browser is going to scan
and make sure it got valid HTML it's
going to be doing lexical analysis and
checking of HTML if the input fails to
be rejected by this kind of code it's
going to go onto the rendering engine
and finally we might have sort of some
more advanced processing that's dealing
with things like forms cookies scripting
and such okay so okay so we have this
graph so now let's see what happens when
we fuzz the web browser using totally
random bits well what's going to most
likely happen is most of those bits that
come in are not even going to be valid
HTTP responses so we're not going to get
so we're going to get coverage that
rapidly drops off and what's left is
almost always going to fail somewhere
else so we're going to see is we're
going to spend the bulk of our testing
effort rejecting random sequences of
bits very early on and very little of
our testing effort testing code here and
so again as I said if that's what we're
trying to do if we really want to be
stressing the early parts of the web
browser code then that's great and
random testing is perfectly good at that
but on the other hand if what we're
interested in is sort of broad coverage
of the software under test then we're
going to fail so the red color indicates
random bits the next thing we could sort
of the next thing we could do is we
could rig our random input generator so
that respects the constraints of the
HTTP protocol furthermore we could adapt
it so the text that it generates
contains valid lexical elements of HTML
that is to say it's composed of things
like braces with tags in them other
kinds of texts other sorts of directives
this isn't too hard to do so if we do
something like that and what I'm going
to call that is use green to represent
protocol correct code i'm using sort of
fuzzy terms of my own devising here not
trying to use any kind of standard terms
so now what's going to happen is
hopefully we'll get pretty good coverage
of the protocol code still should get
quite good coverage of the lexical HTML
processing and we're going to fall off a
cliff again because as soon as we get
into the renderer it's gonna become
apparent that we didn't try hard enough
to generate valid HTML we're gonna get
some through the render very often so
now what if we accomplished here well
we've pushed to the
coverage that we're getting on the
software under test farther into the
system that is farther into the HTML
processing chain but still haven't
processed pushed it very far so the next
thing that we can do is use some sort of
a grammar or some sort of a structural
definition of HTML to generate random
but valid HTML so the next thing is
valid HTML and so what's going to happen
now is our coverage of the protocol code
and the lexer it may decrease but on the
other hand we're going to be able to
push into the HTML processing code quite
deeply before falling off a cliff so
what have we done we've traded off
coverage in the early parts of the web
browser which may well be so simple that
we don't care that much about them for
coverage farther in and so finally what
we could do is generate code that
generate code the ink generate random
code that includes elements of scripting
forms whatever else it was that we're
interested in testing and we can run
that through now we now and now we can
start randomly testing our browser with
this so it's going to happen now is our
coverage might decrease even a little
bit more in the early parts because
we're spending more time doing other
things but we're probably not going to
fall off of a cliff at all and so you
can see that in most cases when we do
random testing what we're looking for is
something like this kind of flat line
and what this flat line indicates is
that we're covering all parts of the
software under test roughly equally
we're going to see is as we look through
more random testing examples is it
getting sort of a coverage curve like
this often requires quite a lot of work
quite a lot of sensitivity to the
structure of the input domain but that
on the other hand we get paid back for
that work with random tests that can
exercise the entire software under test
and that's going to be a valuable thing
in many cases</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>