<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Category Partition Demo - Georgia Tech - Software Development Process | Coder Coacher - Coaching Coders</title><meta content="Category Partition Demo - Georgia Tech - Software Development Process - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Category Partition Demo - Georgia Tech - Software Development Process</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zico2p-Ws2Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this demo we're going to do exactly
what we did
just now in the lesson we're going to
use the category partition method to go
from a high-level description of the
piece of software or the program to a
set of test cases for that program to do
that we're going to use a simple tool so
I'm going to show you here the - all
that is called that TSL generator right
here this tool is available to you so
you can look in the class notes to see
information on how to download it and
together with the tool we're also going
to provide a manual for the tool and the
set of files that I'm going to use in
this demo so that you'll be able to do
exactly what I'm doing so again all of
those are available from the class notes
so specifically today we're going to
write test cases for the grep program so
in case you're familiar with the grab
utility this is a simplified version of
that utility so basically the grep
utility allows you to search a file for
the occurrences of a given pattern so
you can invoke it as it's shown here in
the synopsis by executing grep the
pattern that you're looking for and the
file name in which you want to look for
the pattern and let me read the
description of the grep utility the grep
utility searches files for a pattern and
prints all lines that contain that
pattern on the standard output a line
that contains multiple occurrences of
the pattern is printed only once the
pattern is any sequence of characters to
include a blank in the pattern the
entire pattern must be enclosed in
single quotes to include a code sign in
the pattern the code sign must be
escaped which means that we have to put
a slash in front of the code sign and in
general it is safest to enclose the
entire pattern in single quotes so this
is our high-level description for the
program for the software system that we
need to test so now let me show you what
a possible set of categories and
partitions could be for this program so
what I have here is a file a textual
file which contains all the categories
and partitions for the elements that are
relevant for my program in particular
when we look at the file we can see that
the file can be characterized by its
size and in this case I got two choices
the file can be empty or not empty
cinco incorrect eristic of the fact that
i'm considering is the number of
occurrences of the pattern in the file
and i'm considering that the pattern
might not occur in the file or they
might occur once or multiple times i'm
not going to go through the rest of the
file because we already covered how to
apply the category partition method in
the lesson so if you doubts about that
about the method and how to apply it you
might want to go back and watch again
the lesson what I want to show you here
is how you can go from this information
that you have here that we have derived
by applying the first steps of the
method to a set of test frames and then
a set of test packs so to do that we're
going to use the tool that I just
mentioned so let me bring back my
terminal so first of all let's see how
we can run the tool so you have a manual
that will explain all the details on how
to build a file that we're going to feed
the tool so what is the format and so on
here I'm just going to see how I can run
the tool so first of all let me point
out that this was developed together by
professors from the University of
California Irvine and Oregon State
University and as you can see we can run
TSL generator and specify that we want
to see the main page so in this case if
we run it that's this way
you have some basic information on how
to run the tool and from the main page
you can see that you can specify the - C
flag and in this case the TSL generator
will report the number of test frames
generated without writing them to output
so for example you may want to use this
as we will do to see how many tests that
you will generate with the current set
of categories partitions and choices the
minus s option will print the result of
the TSL generator on the standard output
and finally you can use - or to specify
an output file where to put the output
of the program
so let's that first run our TSL
generator by specifying the - e option a
by bypassing our current set of category
partitions and choices okay so let me
remind you that what the the tool will
do is what we will do manually otherwise
which is to combine all these choices so
as to have one test case for each
combination so if we do that you can see
that the tool tells us that we will
generate
1776 test frames in this case and this
seems to be a little too much for a
program as well as the one that we are
testing and assume for instance that we
don't have the resources to run these
many test cases for for the grad program
in addition consider that in this case
we are computing all possible
combinations of choices and there's
going to be some combinations that do
not make sense as we discussed in the
lesson so what we might want to do in
this case is to go back to our spec and
start adding constraints to eliminate
this meaningless combinations so I'm
going to show you the result of doing
that and I'm going to show you a few
examples for example here when the file
is empty I'm going to define this
property empty file and how am I going
to use this property well for example
here it doesn't make sense to consider
the case in which we have one or many
occurrences of the pattern in the file
if the file is empty therefore I'm going
to tell the tool that it should consider
this specific choice only if the file is
not empty only if empty file is not
defined and that will skip for example
all the combinations in which the file
is empty and I'm trying to generate the
test case it has one occurrence of the
pattern in the file which is simply not
possible so for another example in case
I have an empty pattern I define the
property empty pattern and then I avoid
the choices that involve the pattern in
case the pattern is empty because for
example I cannot have a quotes in a
pattern that is empty for example it
doesn't make sense to have blanks so one
or more blanks if the pattern is empty
so I'm going to specify again that this
choice should be considered only if we
don't have an empty pattern and so on
and so forth
so now after I added this constraint I
can go back and compute again the number
of test frames and therefore test cases
they will be generated with these
constraints so let me go again to my
terminal ok so now I'm going to run my
TSL generator again and I'm going to run
it on the second version of this file
and you can see that I reduced the
number of test frames from about 7800
to about 1700 so it's quite quite a big
reduction by eliminating all these
combinations that do not make sense but
let's assume again that we want to
reduce this further so that we don't
want to generate those many test frames
and therefore test cases so what can we
do we go back to our spec and in this
case we start adding error constraints
so if you remember what we said in the
lesson error constraints are constraints
that indicate a choice that has to do
with an erroneous behavior for example
an erroneous input provided to the
program so here for instance were
indicating the presence of incorrectly
and closing quotes as an error choice
same thing if there's no file
corresponding to the name that we
provide to the tool we say that this
corresponds to an error so how is the
tool gonna use this information it's
using this information by producing only
one combination that involves error
choices instead of combining them with
other choices so let's see what happens
after we added this error constraints so
we go back to our console once more and
in this case we want to run the TSL
generator with the version of the of my
file that contains the error constraints
and again I reduce quite a bit the
number of test frames so now I have only
562 test frames that will be generated
by using the file that I provided so for
the last time let's assume that we
really want to cut down the number of
test frames so the number of test cases
so once more we go back to our file and
at this point what we can add is the
final type of constraints that we have
which are single constraints and single
constraints are basically indicated
choices that we don't want to combine
with other choices so they have the same
effect of the error constraints but have
a different meaning so they do not
indicate choices that corresponds to an
error in other words I can use the
single constraints to identify choices
that I want to test only once so for
example in this case I might decide that
I want to have only one test frame that
tests my program with a file being empty
and I can do the same for other choices
so basically I can continue adding this
single constraint until I get down to
the number of test frames and therefore
the number of test cases that I want so
now let's go back once more
to our console and so now if we run
using this file as input you can see
that we have 35 test frames generated so
this is a fairly low number of disk
cases so we might decided we want to go
ahead and write these test frames to a
file so now let's open this file that we
just generated and as you can see here I
have exactly 35 test frames as expected
some of those could respond to the
single and error cases so in this case
the only choice that I have indicated is
the one that corresponds to the single
or error constraint what is for the
other ones I actually have the whole
test spec so let's pick one just to give
you an example in this case test frame
number 15 that will correspond to test
case number 15 and here you can see that
we have all of the information so this
is a test specification all the
information that we need to generate a
corresponding test we know that we need
a file that is not empty that we need to
have one occurrence of the pattern in
the file one occurrence of the pattern
in one line the position of the pattern
in the file can be any position the
length of the pattern must be more than
one character the pattern should not be
enclosed in quotes
there should be one whitespace one quote
within the pattern and finally the file
that we pass through the program should
exist so the file should be present so I
can easily transform all of this into an
actual test case and notice that even
though we know we're not going to do it
here in cases like this it might even be
possible to automatically generate the
test cases from the test specifications
because here for example here it should
be relatively straightforward to parse
these test specifications and generate
test cases accordingly so just to
summarize what we have done is to go
from one high-level description of a
program to a set of categories
partitions and choices for that program
then we have combined them in different
ways adding more and more constraints to
reduce the number of combinations until
we ended up with the right number of
this cases so the number of
cases that we were fine generating we
generated the corresponding test
specifications and at that point we
could just go ahead generate the test
case and test our application so and you
can see how this can result in a much
more thorough testing of your
application because instead of reading
this description and just trying to come
up with test cases for it
we can break down the process in steps
that are easy to perform individually
that can be automated as much as
possible and they will end up with the
set of test cases that will test all the
interest in aspects of your application</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>