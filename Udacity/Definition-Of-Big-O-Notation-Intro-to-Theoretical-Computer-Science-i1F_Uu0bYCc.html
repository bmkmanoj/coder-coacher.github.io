<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Definition Of Big O Notation - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Definition Of Big O Notation - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Definition Of Big O Notation - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/i1F_Uu0bYCc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what did we just do when we
determined that the running time of
algorithm B grows much faster than the
running time of algorithm a well first
of all we said that there was some value
of n so some value for the size of the
input where this running time function
is always larger than this running time
function so the running time of
algorithm a is some function f of n and
the running time of algorithm B is some
function G of n so if G of n grows
faster than F of n then there must be
some value of n for which G of n is
larger than F of n and for any value
larger than that this must also be true
and we're going to call that value n
Prime and for that value n Prime we must
have that G of n prime is larger than F
of n prime because we're saying that G
of n grows faster than F of n and of
course this must hold true for all
values larger than n Prime so we have a
second condition here that for any value
larger than n Prime we must also satisfy
this condition here now we also said
that we do not want to care about
constants so we don't not want to care
about if this here says 3 n squared or 5
n squared we would just say that this
function basically grows depending on N
squared so in order to do that we need
another number in here and that number
is a constant that will allow us to
scale the function G of n and I'm soon
going to give you a few example to show
what that means exactly but in general
it means that if we can multiply this
function here with some number let's
call that constant C so that it outgrows
f of n then we would still be satisfied
then we would still say that G of n
grows at least as fast as F of n and
this is all you need to know to
understand Big O notation because if
those two conditions here are satisfied
so there are some numbers M Prime and C
so that C times G of n prime is larger
than F of n Prime so there's some point
where this function gets at least as
large as this function and from any
point onwards this function continues to
be at least at large then we would say
that F of n is contained in Big O of G
of n so the Big O means that G of n is a
function that grows at least as fast as
F of N and this is the O that gives Big
O notation its name</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>