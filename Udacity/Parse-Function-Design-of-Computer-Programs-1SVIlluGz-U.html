<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Parse Function - Design of Computer Programs | Coder Coacher - Coaching Coders</title><meta content="Parse Function - Design of Computer Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Parse Function - Design of Computer Programs</b></h2><h5 class="post__date">2012-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1SVIlluGz-U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here we go here's the function parse
it takes a start symbol like expression
and takes a text like 3x plus B and it
takes a grammar defined with our grammar
function the first thing we do is define
the tokenizer the tokenizer has two jobs
first it has to handle whitespace that
occurs before the token and it does that
by looking up in grammar under the key
consisting of just a space and the
definition of grammar we arrange to
store the whitespace parameter under
that key so this says build up a regular
expression that will parse off the
appropriate amount of whitespace some
all none whatever is appropriate for
your grammar and then parse off whatever
was defined but the atom that we're
looking at next and we'll see when
tokenizer is used how we go ahead and do
that then power sequence says we're just
going to go through a sequence this is
the sequence of atoms we're going to
initialize our result to be the empty
list then we're going to go through try
to parse an atom one at a time if we get
back nothing for a remainder then fail
otherwise append to the result the tree
that we built up by doing that parse and
continue on in the loop notice that
we're updating the text variable so
we're taking the remainder each time and
parsing the next Adam from the remainder
of the previous Adam now parse Adam
handles two cases if the atom is
something that's in the grammar like the
XP expression we map it into this tuple
of alternatives by looking it up in the
grammar getting that list of
alternatives and for each alternative we
try to parse and if we have a successful
match that is if the remainder is not
none indicating failure if there's some
sort of remainder left over then we want
to return the result we return the
remainder we got and we build up a tree
structure consisting of the atom that
we're trying to parse plus the tree of
whatever we got back and if we exhaust
all the alternatives and we can't come
up with anything then we return fail
which says no tree and no remainder
otherwise if the atoms not in the
grammar then it must be a regular
expression we take the tokenizer that we
built up before we insert the atom which
is a regular expression into that
tokenizer and match it against the text
if there's not a match then we fail if
there is a match
pull out the matching part that's going
to be the tree that's the token that we
matched we go ahead and we take the rest
of the text after the match and return
that as a remainder so this is the only
place where the text actually advances
in this one spot where we're matching
tokens against the input text these two
routines are internal routines inside
the definition of parse and here's the
body of parse that just says parse this
atom the start symbol against the text</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>