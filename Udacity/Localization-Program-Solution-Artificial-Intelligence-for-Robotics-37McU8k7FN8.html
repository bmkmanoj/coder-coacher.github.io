<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Localization Program Solution - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Localization Program Solution - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Localization Program Solution - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2012-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/37McU8k7FN8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here's my solution to the foaming
assignment and it's quite
straightforward given the class but I
really proud if you got it correct
because enabled you to program your own
localization algorithm very similar to
the way we do at the Google self-driving
car first I did two simple bookkeeping
assignments assigned a value to send the
wrong as 1 minus probability of sins are
right and a probability of staying that
is a motion fare as 1 minus the
probability P move let me scroll down
very slowly let me first go to my main
routine I actually put a little check
where the length of the measurements
vector is the same as the motions vector
and it will give me an error message if
not of course this wasn't necessary for
you I just did it because I want my
software to look nice then here is my
initialization of my probability table I
compute my initial uniform distribution
by calculating the size of the array the
number of rows times the number of
columns and then dividing one over the
product of those two be my initial
distribution value and this thing over
here just build up an array of the size
of my colors array but initialize it
with the value of P in it these two
lines over here give me an initial
uniform distribution and then I iterate
I go through the number of measurements
which the same as number of motions I
move first using the Move command but
which I provide my current distribution
and my motions command to obtain a new
distribution and then do the same with
the sensing command I take my current
distribution the world itself in the
measurement vector to obtain a new
probability distribution we had done
this as many times as I have
measurements and motions I output the
final distribution so much for the main
routine I now have to specify what
movies
and what senses let me start with sense
this is my sense routine it goes from
here to down here as an input I have a
private distribution and my world map
they're both of the same size and a
specific measurement which is either red
or green
I construct in sight my new posterior
distribution I initialize this with
zeros and it's at the same size as my
vector of P in the inner loop I now
iterate over all elements in my grid
cell I compute whether the measurement
matches the color in the cell in which
case a call of the hit now my
non-normalized posterior is the prior
times this big sum over here it uses
sensor right if the measurement was
correct
and sends a wrong if the measurement was
incorrect finally I add up all the
values and Alex I do this with the
variable s so down here I can normalize
Alex to have a total probability of one
and then I return it the move command
takes as an imported distribution and a
motion vector it constructs the next
distribution just like before as Alex
variable and sets to zero and now I go
through each grid cell and for each cell
I collect possible cells that devoured
might have come from with probability P
move would actually moved in which cases
prior coordinate would have been I minus
the motion command that's because we go
backwards in time and this is the
truncation indicate we have a cyclic
array and we do the same with J let me
scroll very carefully it's J minus the
motion command again in a cyclic fashion
but it might have been we didn't move in
which case you just use the probability
of that specific cell multiplied by the
probability of staying now this
lying together gives me the correct
probability for the variable I and J I
don't have to normalize because it's not
based rule so I just return the
corresponding posterior distribution I
also have a little routine called show
that goes through the entire probability
field and computed all these probability
vectors of P that makes it slightly
better formatted then just printing P in
a single command so if I run my software
with a specific word over here it
initializes P as 1 over 20
because as 20 quit cells then runs 5
times through the motion command the
measurement command updates those and
then shows me the final result which
already explained which is the array
over here if you got this correct then
you've done something quite amazing
you've programmed the core of Google
self-driving car localization methods in
Google's case the world isn't as simple
as just red and green in Google's case
is a carefully assembled 2d surface
models of the Vote servers but that
doesn't affect what we've programmed
here
it makes the measurement function
slightly more involved the fact is that
the thing we programmed here captures
the key of the probabilistic inference
necessary to localize the Google car so
if you program this you just have to
replace the simple matching of a
measurement of green with an image
matching of an entire image you record
with an image in your map I leave this
as an exercise because I can't do this
in this Python environment here but I
congratulate you that you've really
managed to something quite amazing which
is built an amazing piece of
localization software</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>