<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>hsdafadsg | Coder Coacher - Coaching Coders</title><meta content="hsdafadsg - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>hsdafadsg</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XdvU4e4RO9o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">to understand the constraints or
potential witnesses of hash functions
that are two concepts we need to discuss
the first is the pigeonhole principle
and the second is the birthday paradox
first let's take a look at the
pigeonhole principle imagine we have
nine pigeonholes if we have nigerians
then one pigeon can be placed in each
hole that is supposed with n number of
pigeons &amp;amp; M number of holes if n equal
to M that means this exactly one pigeon
per hole now if we add another pigeon
then there will be one hole with two
pigeons that is if n the number of
pigeons is square than M the number of
holes then there's at least one hole
that must have more than one pigeon now
let's apply the pigeonhole principle to
another problem how many people do we
need to have in a room such that there's
a good chance that to love them we have
the same birthday there are 365
birthdays and we can think of these
birthdays as the pigeon holes how do we
calculate the probability that two
people in the room have the same
birthday obviously if you want to pop
ability to be one hundred percent we
need 366 people and that's the
pigeonhole principle because we have 365
birthdays or 365 pigeon holes so we need
366 pigeons or people in order to make
sure that two of them we have the same
birthday now suppose we only need a good
chance say only fifty percent chance
that two people in the room would have
the same birthday how do we calculate
how many people do we need in a room we
can solve this problem using a following
procedure we can model this problem of
having em people choosing from k days as
their birthdays of course k is 365 if we
allow everybody to choose any of the k
days then they are likely to the n there
many scenarios because for each of the m
people they can choose any of the k days
so they like a to the N there are many
possible scenarios on the other hand if
we insist that no two people should have
the same birthday
then the number of scenarios is choosing
n out of K without replacement and that
is K times K minus 1 times K minus two
so and so forth n times K minus n plus 1
because for the first person he can
choose any of the K days and once he
makes his choice then the next person
can only have K minus 1 choices because
we don't want this second person to have
the same birthday as the first person
and once the first two people had chosen
their birthdays then the third person
can only have K minus 2 choices and so
on so forth so this is the number of
possible scenarios when we insist that
no two people share the same birthday
then we can use this formula to compute
the probability that there's a scenario
where two people share the same birthday
and this can be approximated to n times
n minus 1 divided by 2 K therefore if
you want this probability to be point 5
meaning that there's fifty percent
chance that two people will share the
same birthday then and should be the
square root of K again this is just an
approximation if K is 265 then the
square root of K is 19 that means as an
approximation if we have 19 people in a
room there's a good chance that to love
them share the same birthday I have
tried this in my class every year with
the students in my classroom and it
always works out as the math tells us
once we understand the picture hope
principal and birthday paradox we may
realize that some of the properties of
hash function seem to contradict each
other in particular a hash function can
take as input data of any size and the
output is always a fixed size since the
size of hash value is fixed that means
that there are fixed number of possible
hash values on the other hand since the
input to hash functions can be of any
size that would mean that there are many
many more possible inputs to the number
of possible outputs in other words there
are many more pigeons then the
pigeonholes then applying the pigeonhole
principal many inputs we met to the same
output hash value in other words many
different input messages will have the
same hash value but this violates the
property of collision resistant however
if we take a closer look at the hash
function properties in particular the
collision resistant properties they only
say that it should be completely
infeasible to find two different
messages they have the same hash value
it did not say that it should be
mathematically impossible to find such
collision in other words although it is
mathematically possible to find a
collision the hash function property
says that we want to make it infeasible
or impractical to find such collision so
how do we accomplish this obviously the
larger the number of possible output
hash values the harder it is to find a
collision in other words the longer the
length of the output hash value the
better in short to avoid collision which
you use longer hash values</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>