<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Control Transfer (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Control Transfer (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Control Transfer (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cQTmqz5Nxgo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the result comes back and when the
result comes back the client box is
executing some process see to the
colonel has to switch to this client so
that it can receive the results and
continue with its execution so this
context which is again in the critical
path of RPC latency so if you look at
the RPC call the two context switches
that are in the critical path of RPC
latency is a context switch that happens
here and the context which that happens
here so only two conflicts witches are
in the critical path of the latency the
conflicts which that happens on the
server machine when the call comes in
and similarly the context which that
happens on the client machine when the
results come in so this context which
that happens on the client machine to
keep the client machine utilized can be
overlapped with a network communication
to send the call out so in other words
this context which is not in the
critical path of RPC latency and
therefore lose this context which while
the RPC call is in transmission on the
wire so will be overlapping this
conflicts which that happens on the
client box after the call has been sent
out with the communication time on the
wire for the RPC call similarly on the
server side once the server is completed
execution and it is ready to send the
results out send it out on the wire and
in parallel with sending it out on the
wire you can overlap the context which
that happens here in order to keep the
server box busy doing useful stuff s2 s2
that can be overlapped with this network
communication so only this context which
and this conflicts which are in the
critical path of latency so we can
reduce the number of context switches
down to two originally we started with
four we can reduce it down to two by
observing that the context which is that
happen on the client box and the server
box to keep them utilized can be overlap
with the network communication for
sending the arguments over to the server
or sending the results over to the
client of course we are greedy can we
reduce it to one can we actually reduce
a number of conflicts witches down to
one let's think about this
we said that when this RPC call was made
the operating system on the client side
said well this is a blocking semantic
and therefore this guy is not going to
do any useful work so I'm going to block
him and wait for the results to come in
so this context switch that the the
operating system did on the client side
was essentially to keep this client box
from being underutilized but do we
really need to do the switch well it
really depends if the server procedure
is going to execute for a long time then
you know this client box is going to be
underutilized for a long time and in
that case it might be a good thing to
context which in order to make sure that
we are utilizing the resources that we
have but on the other hand if suppose
this RPC call we know that this RPC call
is going to come back fairly soon and if
it is on a local area network and the
server procedure that is going to be
executed as not going to take a long
time then perhaps this RPC call will
come back very quickly if that is the
case we can get rid of this context
switch that we talked about here in
order to keep the client box busy we did
this conflicts which don't do that we
can spin instead of switching on the
client side and if you do that then the
client is reading but it has not been
conflict switched out it is just that
this box is underutilized so the only
context which that we incur is the
conflicts which on the server because
you never know when an RPC call is going
to come in so when an RPC call comes in
you obviously have two conflicts which
into the server context in order to
execute the call that's the necessary
evil will incur that but on the client
side what we're going to do is we're
going to spin instead of switching so
that even though the box is
underutilized you're not doing anything
on the client side just sending the call
out and waiting and in that case we've
gotten rid of the second conflicts which
that you need to incur because you never
conflicts restored and therefore this
context which which we said is
inevitable because it has to be done in
order to receive the results for the
client well we can get rid of it
if we never switched in the first place
and that's the trick here to reduce the
number of contexts which is down to one
we can spin on the client side instead
of switching so that we can be ready to
receive the results of the RPC call
execution when the server is done again
the intent here is that we want to
reduce the latency that is incurred in
the RPC call and since these two
contexts which is where in the critical
path of the latency we would really like
to see how we can eliminate at least one
of them and this context which is
inevitable and this context which we can
eliminate it by spinning on the client
side instead of switching in the first
place</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>