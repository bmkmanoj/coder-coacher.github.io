<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tuning Probabilities In Practice - Software Testing | Coder Coacher - Coaching Coders</title><meta content="Tuning Probabilities In Practice - Software Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tuning Probabilities In Practice - Software Testing</b></h2><h5 class="post__date">2012-07-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qBBr9OXqy5I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so now let's look at a very similar
case we're again going to visualize the
execution of the queue is a finite state
machine but now we're gonna have a much
larger q we're going to cue the stores a
thousand elements instead of two so
we're gonna have exactly the same kind
of state machine but its shape has
changed instead of containing three
nodes it contains a thousand and one and
so I've left out a vast array of states
in the middle and so when we randomly
test this queue we're still going to
start at the empty state let's look at
what the dynamics are this time so here
i have a queue with n equals 1000 and
nothing else has changed i'm going to
run the random tester this time we've
done around fifty fifty thousand adds to
a non full q and we haven't done any ads
to a full q we've done almost 50,000
removes from a non-empty queue and ten
removes from an empty queue and so let's
try to understand what happened here so
what happened is and I'm going to come
up with another view of that state
machine so here we have the empty queue
and here we have the full queue and here
we have the number of times we visit a
particular state and what's happening is
with fifty percent probability we
randomly walking back or forward and
we're going to be getting a situation
where the probability of visiting q
states farther away from where we
started drops off exponentially and
actually they're good close form
equations for being the probability of
getting to any particular point but as
we saw using a hundred thousand tests I
believe we never actually managed to
make it to a thousand although we did
perfectly easily make it to it to a
queue size of two and so a thousand is
when a particularly large size for a
data structure we could easily have some
sort of a cue that held 10,000 or
100,000 elements and the chances of
random we were walking all the way out
to the end become even more negligible
and so the question we're going to ask
ourselves is what do we have to do
differently to a random tester to make
sure to test this situation as
thoroughly as a test of this situation
and so there's no cut-and-dried answer
to this kind of question these kind of
questions definitely are hard in
practice and when something changes
about the software under test we might
have to adjust the probabilities to
compensate so let's just look at one
possible solution one possible solution
would be to bias the probabilities
towards add towards n queuing so if the
random number generator returns a number
less than 0.6 instead of 0.5 we're going
to NQ and the other forty percent of the
time we're going to DQ so let's see what
effect that has so this time we
attempted to add almost to a full q a
large number of times but this time we
seem to have not particularly well
tested the case of removing from an
empty queue and let's run it a couple
more times and see what happens ya see
this time we didn't remove from an empty
queue any time so we bias the
probabilities too far towards adding and
what's going to happen isn't any kind of
a random walk is as long as the
probabilities are respected
balance it's going to take a long time
to get somewhere unless we unbalance the
probabilities significantly like we did
with his 6040 distribution but probably
doing this case is bias the product is
is make a configurable bias to the
probability and now add a completely new
random testing loop now we're going to
set that bias variable to be something
sort of large unless X is odd if X is
odd we're going to set the bias variable
to be something less okay so let's look
what we did we took our random testing
loop and we enclosed it in a larger
random testing loop and in that larger
to random testing loop we sort of made a
qualitative change to one of the
probabilities that is to say we biased
execution towards one of our API calls
in favor of the other and on
even-numbered calls we biased it the
other way so what we're hoping to do now
is create a situation where we start off
in the empty state we migrate with
pretty high probability towards full and
bounce around there and then at the end
of that particular configuration of the
testing run we're going to walk back
really do that I believe 20 times and so
what we hope is that this will test even
for the fairly large queue a lot of its
possibilities so let's see if that
actually happens so of course it's going
to take longer to run this time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>