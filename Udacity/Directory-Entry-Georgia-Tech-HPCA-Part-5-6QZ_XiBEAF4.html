<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Directory Entry - Georgia Tech - HPCA: Part 5 | Coder Coacher - Coaching Coders</title><meta content="Directory Entry - Georgia Tech - HPCA: Part 5 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Directory Entry - Georgia Tech - HPCA: Part 5</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6QZ_XiBEAF4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the directory entry has one dirty bit
that indicates that the block is dirty
in some cash in the system and for every
cash in the system the directory entry
has one bit that indicates whether the
block is present in that cache if the
presence bit is one for a particular
cache that means that we think that
cache has a copy of the block if the
presence bit is zero that means that we
know for sure that that cache does not
have the block in a state that is not I
so let's say we have one block caches at
core zero and one and let's say this is
the directory entry for Block B where
this is the dirty bit and these are the
presence bits for cores 0 1 2 3 4 5 6
and 7 so this is an 8 core system so we
need 8 bits to represent presence of the
Block in the caches initially the block
is not dirty and is not present in any
of the caches let's say that core 0
reads from the Block B the block is not
in its cache so it's treated like it's
in the invalid State we put the read
request out normally this read request
will be put out on the bus and because
no other cache has this the memory would
respond but now we don't have snooping
anymore so all requests for a block
would be sent first to the Home Slice
of the block and we determine what is
the Home Slice by looking at the address
of the block different blocks are
distributed among different slices so
that we get an even load between the
slices so let's say we determined that
for Block B this is the slice where we
go and once the request gets there we'll
look at the directory entry for it the
directory entry says that the block is
not anywhere in the system so now we can
get the data from memory and send the
data back to the cache 0 and we need to
tell the cache 0 everything that the bus
would normally tell it so we tell it
that it has exclusive access because
there are no other
and we give it the data that response
gets back to cache zero and now if it
has the exclusive state it can put the
block in that state and put the data for
be here when the directory sends the
data to cache zero
it changes the presence bit for that
cache to one also we sent the data with
exclusive access
if cache zero modifies the data it
doesn't have to notify the directory
back so we also set the dirty bit the
dirty bit here will not cause a write
back it will cause us to find if a cache
needs to do a write back so now why does
this work better than a bus well because
while cache 0 was doing this with this
directory slice cache one could have
done something like that for another
block with another directory slice
completely independently
however if cache one tried to write to B
at about the same time when read B was
occurring we would send a write request
to the same directory entry and now
between these two messages the directory
controller needs to select one in this
case it shows read request first so
officially this read happened before
this right so the core here gets to read
the Block B and only then the write gets
processed by the directory so when this
write request arrives here again this
write request would be placed on the bus
scene by this cache as a result this
cache would invalidate and we will get
the block in the modified State
with the directory we sent a request to
the directory controller it sees that
the block is present at possibly dirty
and in this case cache 0 so what now
happens is the directory forwards the
write request for B to the caches that
are present in this case it forwards it
to cache 0 cache 0 now sees this request
just as if it was snooped from the bus
and because it has the data in the
exclusive state it can choose to respond
with the data or it may just keep quiet
and confirm the invalidation
what happens here is once the right
request has been given to this cache we
need to send the acknowledgement at
least if not the data to the back to the
directory controller that says that we
are done invalidating or copy so at this
point we have invalidated our copy when
the acknowledgement arrives here the
directory controller can change this to
zero if the data didn't arrive then we
can erase the dirty bit and now because
we don't have the data still we will
read the memory and send the data to
cache one and because we are
acknowledging a write request we again
set the dirty bit and now the presence
vector gets a one for the bit that
corresponds to cache one and now we get
to set M here and write to the B here so
as you can see this is how the caches
can do their normal coherence but now
instead of everybody seeing everything
that we need to send request to the
directory which then sends out the
messages that need to be sent only to
those caches that actually might have
the block so if a block is shared by
only two cores then we will be only
sending a very few messages in contrast
the bus would force us to basically
broadcast to all of the cores so this
also saves a lot of bandwidth because we
are using point-to-point network links
to send just this meanwhile other cores
could be doing something like this with
another directory entry completely
independently over a network</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>