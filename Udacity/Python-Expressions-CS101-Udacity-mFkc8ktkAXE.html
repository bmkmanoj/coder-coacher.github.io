<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Expressions - CS101 - Udacity | Coder Coacher - Coaching Coders</title><meta content="Python Expressions - CS101 - Udacity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Expressions - CS101 - Udacity</b></h2><h5 class="post__date">2012-02-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mFkc8ktkAXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[D. Evans] The Python grammar is much stricter than the English grammar
or most natural language grammars.
In English if we say something non-grammatical, like &quot;Me go to the store,&quot;
another English speaker might laugh at us,
but they can probably understand what we meant.
In Python the code must match the language grammar exactly.
Here we saw when we tried to do a value at 2 + without the extra operand
we got a syntax error. That means it's not grammatical.
If we said 2 + to someone in English,
they might be able to figure out that that means the same thing as 2.
In Python it needs to match the grammar exactly.
Now we're going to look at the Python grammar for arithmetic expressions.
We won't see the entire Python grammar here
but enough to get an idea of why the expressions we've seen were valid
and why the 2 + is not.
First of all, an expression is something that has a value.
We're going to start our grammar with a non-terminal expression,
and we can make an expression by combining 2 expressions with an operator.
This is sort of like the sentence rule we had for English
where we could make a sentence by combining a subject, a verb, and an object.
This is a lot more interesting, though, because we have expression
both on the left side and the right side.
This looks kind of circular.
Because we have other rules, it's not completely circular.
This is what's called a recursive definition.
We'll talk a lot more about that in a later class--in Unit 6 we will.
But for now we're going to see how we can use that to make the Python grammar.
And to make a good recursive definition we need at least 2 rules.
We need 1 where we can keep going using the same thing on the right side as the left side,
and we need 1 where we can stop.
Another thing that an expression can be is a number.
This is why we can make expressions like 1 + 1.
This expression will become a number, which will become 1,
the operator will become +, and the other expression will become 1.
So let's write a few more rules to see how that works.
We can replace the operator with +.
We can also replace operator with &amp;lt;i&amp;gt;.&amp;lt;/i&amp;gt;
There are several more operators in Python. Those are enough for now.
We just need those 2.
We can also make numbers.
The complete rule for making numbers is sort of complicated,
but let's assume we know what numbers are.
We can make numbers any number of digits.
There are different rules to make all those numbers, but we know what they are.
This looks like a very simple grammar.
It's quite small, but it can express infinitely many things.
And the reason for that is because we have expression on both sides here.
We can replace an expression with a bigger expression and keep going.
Here's an example of derivation.
We can start with expression, we can follow the rule,
replacing that with expression, operator, expression,
and then we can follow the rules again.
We can replace the first expression with a number
and replace that number with the actual number 1.
Notice the actual numbers are terminals,
so once we get to the number 1, we're done.
There's no more replacements to do.
We can replace the operator with +. Plus is also a terminal.
And we can replace this expression with a number
and replace that number with the number 1.
So this is how we got the expression 1 + 1 in the Python grammar,
and that's why that was valid.
We can do a lot more than this, though.
Instead of replacing this expression with a number
we could replace this expression with another expression, operator, expression.
So we're going to use the first rule, replacing expression
with expression, operator, expression here.
I'm going to start abbreviating,
so expr is an abbreviation for expression,
op for operator, and expr, but we're just using this rule.
Now we could do the same thing again, replacing this expression with a number
and replacing that number, let's say, with the number 2.
We could replace this operator with the multiplication operator,
and we could replace this expression with a number,
or we could replace it with an expression, operator, expression--let's do that--
and build increasingly complicated expressions this way.
We can keep doing this.
We're not done until everything is a terminal, so let's say--we skipped a few steps here--
but this could be 3 + 3.
This is how we can build up complicated expressions from very simple rules.
I'm going to add 1 more rule to our Python grammar.
That will be enough to produce all the expressions that we've used so far.
The rule that we need is for parentheses, and this is actually quite a simple rule.
It just says we can make an expression by taking any expression we have
and putting parentheses around it.
This is a pretty small grammar, but this is actually a grammar
that's powerful enough to produce all the Python expressions that we've seen so far
as well as infinitely many different expressions.
We're not going to cover the entire Python grammar this way,
but this should give you an idea of the power of writing a grammar this way.
We're going to have a quiz to see that everyone understands the grammar.
The question is, Which of the following are valid Python expressions
that can be produced starting from expression using the grammar rules?
Here are the choices. There are 5 possibilities.
Check all the ones that are valid expressions that can be produced from this grammar
starting from expression.
You can try your answers in the Python interpreter if you want,
but first see if you can figure out for yourself which ones are valid.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>