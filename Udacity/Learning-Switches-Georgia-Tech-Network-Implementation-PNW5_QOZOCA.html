<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning Switches - Georgia Tech - Network Implementation | Coder Coacher - Coaching Coders</title><meta content="Learning Switches - Georgia Tech - Network Implementation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning Switches - Georgia Tech - Network Implementation</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PNW5_QOZOCA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's take a quick look at how learning
switches work a learning switch
maintains a table between destination
addresses and output ports on the switch
so that when it receives a frame
destined for a particular place it knows
what output port to Ford the frame
initially the forwarding table is empty
so if there's no entry in the forwarding
table the switch will simply flood let's
look at a quick example if host a sends
a frame destined for host C then
initially the switch has nothing in its
table to determine where that frame
should be sent so it will flood the
frame on all of its outgoing ports on
the other hand because the frame has a
source address of a and arrived on input
port 1 the switch can now make an
association between address a and port 1
in other words it knows that the host
with address a is attached to port 1 so
that in future when it sees frames
destined for host a it no longer needs
to flood but can instead send the frames
directly to port 1 so for example when C
replies with the frame destined for a
the switch now has an entry that tells
it that it doesn't need to flood that
packet but instead can simply send the
packet directly to the output port note
also that when C replies the switch
learns another association between
address C and port 3 so future frames
destined for host C no longer need to be
flooded either they can simply be
forwarded to output port 3 so in summary
if a learning switch has no entry in the
forwarding table it must flood the frame
on all outgoing ports but otherwise it
can simply send that frame to the
corresponding output port in the table
note that learning switches do not
eliminate all forms of flooding the
learning switch must still flood in
cases where there's no corresponding
entry in the forwarding table and also
these switches must forward broadcast
frames such as ARP queries now because
learning switches still sometimes need
to flood we still have to take care
and the network topology has loops now
most underlying physical topologies have
loops for reasons of redundancy if any
particular link fails you'd still like
posts on the LAN to remain connected but
let's see what happens when the
underlying physical topology has a loop
let's suppose a host on the upper LAN
broadcasts a frame each learning switch
will hear that frame and broadcast it on
all of its outgoing ports when that
broadcast occurs the other learning
switches that are in the topology that
contains a loop will hear the
rebroadcasts they in turn will not know
that they shouldn't rebroadcast the
packet that they just heard so each of
those switches will in turn rebroadcast
the packet on their outgoing ports and
of course this process will continue
creating both packet loops and what are
known as broadcast storms so cycles in
the underlying physical topology can
create the potential for learning
switches to introduced forwarding loops
and broadcast storms so we need some
kind of solution to ensure that even if
the underlying physical topology has
cycles which it often needs for
redundancy that the switches themselves
don't always flood all packets on all
outgoing ports in other words we need
some kind of protocol to create a
logical forwarding tree on top of the
underlying physical topology</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>