<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lower Bound on Complexity - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Lower Bound on Complexity - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lower Bound on Complexity - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PNPKUcX940o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so computational complexity is the
problem of actually finding the hardness
of problems and from the perspective of
a pure theoretician who studies
complexity theory the stuff that we've
been doing so far are talking about
devising algorithms and improving their
their running times that's just part of
the story that's just upper bound
determination there's a whole other set
of work that has to go into finding
lower Browns on the hardness of problems
and that requires very different
techniques from the kinds that we've
been talking about up to this point so
it's worth pointing out that what
theoreticians often really like to do is
if they find an upper bound for the
hardness of a problem and they can find
a lower bound that matches it then you
know exactly the complexity of the
problem it has to lie between those and
they match so therefore it's it's
exactly that so as I said we're not
going to get very involved in proving
lower bounds for different problems but
this argument is actually not too hard
and it'll give you a little flavor for
how this can be done in some cases
imagine that we're trying to compute the
max of a list of length n now we know an
upper bound on this problem is big data
n because we can just loop through all
the elements in the list and find the
maximum but how do we argue about a
lower bound for this problem
well one argument might be well a
constant time is a lower bound on this
problem because at the very least you
have to give the answer it takes at
least constant time to do that it's
possible you can even do that well if
you're trying to compute the max of a
list and you guess the number it may
very well be the max so that gives us a
lower bound here's another one big theta
of n might be a lower bound why because
you have to at least look at all the n
items otherwise there could be one item
in the list that is the max that you
didn't look at and so you can't possibly
return the right answer all right
another argument might be something like
this we need we have a lower bound of
log n for the problem because it's you
know finding the max is sort of like
finding the winner of a tournament you
have to compare values against other
values and we might be able to actually
eliminate half each time and if we could
do that then the number of rounds that
it would take before we have a
in a tournament of n individuals in a
single elimination tournament it's like
it's login so which of these do you
think is the best argument in terms of a
lower bound for finding the max</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>