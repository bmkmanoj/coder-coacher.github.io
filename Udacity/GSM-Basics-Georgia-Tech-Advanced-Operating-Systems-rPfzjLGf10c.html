<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GSM Basics - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="GSM Basics - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GSM Basics - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rPfzjLGf10c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's introduce some basic
terminologies in GSM when we talk about
cash what we mean is physical memory
we're not talking about the processor
caches we're talking about physical
memory that is the dynamic random access
memory or DRAM for short which is the
physical memory that's what we mean when
we use the term cache and there is a
sense of community to handle page faults
at a particular node so we'll get to
that in a minute
and I mentioned that we're going to use
peer memories as a supplement for the
disk in other words we can imagine the
physical memory at every node to be
split into two parts one part is what
we'll call local and local contains the
working set of the currently executing
processes at this node so this is the
stuff that this node needs in order to
keep all the processes running on this
node happy now the global is similar to
a disk this global part is where
community service comes in that is I'm
saying that out of my total physical
memory this is the part that I need to
keep all the processes happy in my node
and this is the part that I'm willing to
use a space for holding pages that are
swapped out from my fellow-citizens on
the local area network and this split of
local and global is dynamic in response
to memory pressure as I mentioned
earlier the memory pressure is not
something that stays constant right so
over time depending on what's going on
in a particular node you may have more
need for holding the working set of all
your processes in which case the local
part may keep increasing on the other
hand if I go off a lunch my workstation
is not in use and in that case my local
part is going to shrink and I can house
more of my peers
swapped out pages in my global part of
the physical memory so the global part
is a spare memory that I'm making
available for my peers and local part is
the part that I need for holding the
working set of the currently active
process at my node and this boundary
keeps shifting depending on what's going
on at my node pretty simple normally if
all the processes
executing in the entire local area
network are independent of one another
all the pages are private you know I'm
running a process my process my pages
and the contents of that pages are
private to my process on the other hand
you could also be using the cluster for
running an application that spans
multiple nodes of the cluster in which
case it is possible that a particular
page is shared and in that case that
page will be in the local part of
multiple peers because multiple peers
are actively using a page so we have two
states for a particular page it could be
private or it could be shared if a page
is in the global part of my physical
memory then it is guaranteed to be
private because the global part is
nothing different from a disk so when I
swap out something I throw it onto the
disk similarly when I swap out something
in GMS I throw it into my peer memories
global cache and therefore what is in
the global cache is always going to be
private copies of pages whether the word
is in the local part can be private or
can be shared depending on whether that
particular page is being actively shared
by more than one node at a time now one
important point the whole idea of GSM is
to serve as a paging facility in other
words if you think about even a unit
processor if I have multiple processes
sharing a page the virtual memory
manager is no concern about the
coherence of the pages that are being
shared by multiple processes that's the
same semantics that is used in GSM also
and that is coherence for shared pages
is outside gsm it's an application
problem if there are multiple copies of
the pages residing in the local parts of
multiple peers maintaining their
coherence is the concern of the
application that is not that is not gsm
problem only thing that the gsm is
providing is a service for remote paging
that's important distinction that one
has to keep in mind in any virtual
memory management system what you do is
when you have to throw out a physical
page when you have to throw out a page
from physical memory you
you use an algorithm a page replacement
algorithm and the page replacement
algorithm that has typically employed in
computer systems is some variant of an
LRU or least recently used algorithm GSM
also does exactly the same thing except
it integrates cluster memory management
at the lowest level across the entire
cluster so the goal in picking a
replacement candidate in GSM is to pick
the globally oldest page for replacement
if let's say that the memory pressure in
the system is such that I have to throw
out some page from the cluster memory
onto the disk the candidate page that I
choose is the one that is oldest in the
entire cluster so managing age
information is one of the key technical
contributions of GSM how to manage the
age information so that we pick a
globally oldest page for replacement in
the community service for handling page
faults</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>