<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficiency of Bubble Sort | Coder Coacher - Coaching Coders</title><meta content="Efficiency of Bubble Sort - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficiency of Bubble Sort</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KddkHygi7is" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great so what's the efficiency of this
algorithm well we had to go through
pretty much the whole array a lot of
times
here's roughly what we did overall we
had to do four or n minus one iterations
and at each step we did n minus 1
comparisons so n minus 1 comparisons for
n minus 1 iterations gives us something
like this we can use a little algebra to
figure out what this simplifies to and
we get something that looks like this
again don't worry too much if you can't
do the algebra the minus one isn't
changing much for us so you could always
just do n times n equals N squared thus
we really don't need this minus 2 n plus
1 bit we can get rid of it and that
leaves us with this is the efficiency
Big O of N squared actually there's a
way we could have saved ourselves some
time with this algorithm if you noticed
each time we went through the array we
compared the last few values even though
we really didn't need to after a while
it made sense to compare 7 &amp;amp; 8 when we
were bubbling up 7 but when we were
bubbling up some of the lower numbers
this comparison didn't really change
anything the most common version of
bubble sort actually leaves out this
step every time of comparing the last
few when you really don't need to do
that it assumes that after the first
iteration you know that 8 is in the
right place so you don't need to check
it against anything else later again
this will save us some time but it's not
going to change our overall runtime of
Big O of N squared I have a couple quick
notes for you ok so we understand by the
worst case and the average case are
going to be Big O of N squared however
the best case is actually going to be
Big O of n the best case would either be
that the array was already sorted in
which we can just go through at once see
that it's sorted and not have to do
anything else or if there's only one
number that needs to be bubbled up to a
new place in the array and one last
thing we didn't have to use anything
extra to do our sort we had no extra
arrays no extra data structures nothing
like that bubbles
ort is a great example of an in-place
sorting algorithm so the space
complexity is constant meaning we didn't
need any extra arrays or data structures
in the whole process</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>