<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pros and Cons of Approaches - Georgia Tech - Software Development Process | Coder Coacher - Coaching Coders</title><meta content="Pros and Cons of Approaches - Georgia Tech - Software Development Process - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pros and Cons of Approaches - Georgia Tech - Software Development Process</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tWaTGCfoQNc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the four different techniques that we
just discussed have a number of pros and
cons so next we're going to discuss the
main pros and cons for these techniques
so as to be able to compare them when
testing is concerned the main positive
about this technique is that it does not
generate false alarms in other words it
doesn't generate false positives what
that means is that when testing
generates a failure that means that
there is an actual problem in the code
the main limitation of testing however
is that it is highly incomplete consider
again the picture that we draw a little
earlier the one representing the input
domain of the program being tested even
in the best scenario testing can
consider only a tiny fraction of the
program domain and therefore a tiny
fraction of the program's behavior and
we say a lot more about that in the
following lessons static verification
unlike testing has the main advantage
that it considers all program behaviors
if we look back at our diagram whereas
testing will select only a few of those
inputs static verification we'll
consider them all unfortunately however
this comes at the price due to
limitation of this kind of analysis and
due to infeasibility issues static
verification considers not only all the
possible behaviors but also some
impossible behaviors and what that means
is that static verification can generate
false positives
and this is in fact the main issue with
static verification techniques as we
will further discuss later in the class
static verification can generate results
that are not true for example it might
report a possible null pointer
dereference that cannot actually occur
in practice the strongest point about
inspections is that when they are done
in a rigorous way their systematic and
they result in a thorough analysis of
the code they are nevertheless a manual
process a human process so they're not
formal and their effectiveness may
depend on the specific people performing
the inspections so its results can be
subjective finally the main Pro about
formal proofs of correctness is that
they provide strong guarantees so they
can guarantee that the program is
correct
which is not something that any of the
other approaches can do including static
verification but the main limitation of
formal proofs is that they need a formal
specification a complete mathematic
description of the expected behavior of
the whole program and unfortunately such
a specification is rarely available and
it is very complex to build one in
addition it is also very complex and
possibly expensive to prove that the
program corresponds to a specification
that is a process that requires strong
mathematical skills and therefore very
specialized personal</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>