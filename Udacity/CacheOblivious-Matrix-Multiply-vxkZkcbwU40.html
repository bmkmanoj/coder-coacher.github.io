<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache-Oblivious Matrix Multiply | Coder Coacher - Coaching Coders</title><meta content="Cache-Oblivious Matrix Multiply - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache-Oblivious Matrix Multiply</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vxkZkcbwU40" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">an efficient cache aware matrix-multiply
performs a sequence of sub matrix or
block-by-block multiplies you choose the
block size so that nominally three
blocks fit in cache the corresponding
algorithm looks like this
and notice that the block size denoted
by little B appears directly in the
algorithm now you can show that the
number of cache misses is asymptotically
n cubed divided by L times B and since B
is proportional to square root of Z
that's just n cubed over L root Z as it
happens for any non Strawson matrix
multiplied no algorithm can do
asymptotically better than this now
since B is a function of the cache size
and it appears in the algorithm we say
this algorithm is cache aware here's a
question for you is there a different
algorithm that does not refer to L or Z
yet somehow still attains below or bound
the answer is yes it's based on the idea
of divide and conquer let's assume for
simplicity that the matrices are n by n
where n is an integer power of two the
algorithm first partitions the matrices
into two by two sub matrices then
performs eight recursive matrix
multiplies to update the 2 by 2 C block
to be more precise here's the pseudocode
algorithm the base case occurs when a B
and C are scalars the algorithm just
performs a scalar update otherwise the
input matrices are logically partitioned
into quadrants as shown in the figure
the algorithm performs 8 recursive
matrix multiplies to update the four
quadrants of C now as the pseudocode
reveals this algorithm is cache
oblivious unlike the blocked algorithm
it makes no reference to the size of the
cache or of the line size and we need to
analyze this algorithm let's forget
about cache misses for the moment and
suppose you just wanted to count the
number of ads and multiplies how would
you do it well the algorithm is
recursive so you'd write down a
recurrence relation maybe like this one
the first case counts the eight
recursive calls on half the problem size
the base case counts the multiplies and
adds or flops namely there are two if
you solve this recurrence exactly you'll
get two n cubed flops which is what you
expect now what about cache misses
imagine the recursion tree
each node is a function call there's
eight way branching at each node and the
leaves correspond to the base case
of course the problem size shrinks
progressively from end down to one at
some point in this recursion all the
operands of a subtree fit in cache let's
say that level is little L and call that
size n sub L at that point it must be
that three blocks fit in cache if the
matrix is stored in row or column major
layout then you'd also need to assume
tall caches then you can conclude that n
sub L will be less than or equal to some
constant fraction of Z I'll denote that
fraction by the fudge constant F for the
moment so a recurrence for the cache
misses will have two cases the first is
when the operands fit in cache the
number of cache misses is just
proportional to n sub L squared divided
by L that's the base case otherwise
there's the recursive case you pay for
misses at each of the eight branches
plus let's assume a constant number
within the function call itself if you
solve this recurrence you should get the
following n cubed over L root Z this
matches the cache aware algorithm as
well as the lower bound yet remember
that the algorithm itself never refers
to Z or L that's oblivious baby</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>