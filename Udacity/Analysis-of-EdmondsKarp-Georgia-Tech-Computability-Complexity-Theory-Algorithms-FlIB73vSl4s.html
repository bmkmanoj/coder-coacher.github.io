<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Analysis of Edmonds-Karp - Georgia Tech - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Analysis of Edmonds-Karp - Georgia Tech - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Analysis of Edmonds-Karp - Georgia Tech - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FlIB73vSl4s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now for the analysis mostly I'll just
try to share the intuition we want to
show that order e times V augmentations
are used to see this we defined
something called a level graph the level
of a vertex is defined to be the
shortest path distance from the source
vertex s the level graph then is a sub
graph of the original that includes only
those edges from one level to a level
that's one higher for example if this
were my directed graph here then the
level graph would be this sub graph down
here here these edges here have been
deleted because they go between vertices
within the same level and this one has
been deleted because it went backwards
or up a level in the graph we first
observed that augmenting along a
shortest path only creates paths that
are longer ones say that we push flow
along this path here then we've
introduced back edges along this path
note however that these edges are
useless for creating a path of the same
length in fact because they go back up a
level any path that uses one of them
must use two more edges than the
augmenting path that we just used the
one that was a shortest path next we
observe that the shortest path distance
must increase every e iterations every
time that we use an augmenting path we
delete an edge from the level graph the
edge that got saturated maybe this one
here got saturated in an augmentation
along this path so we would delete that
and then maybe we push another flow
along this path and end up deleting this
edge these edges won't come back into
the level graph until the minimum path
length is increased as we've already
argued the reverse edges are useless
until we are allowed to use longer paths
so if each augmentation deletes one edge
from the level graph then certainly
after e iterations the level graph will
be empty and then clearly there are no s
T paths in this level graph and so we
need to build a bigger one that includes
longer paths in order to be able to
augment any further and lastly there are
only V possible shortest path lengths so
that completes the theorem for each
possible path length we might have up to
Eve iterations
going back to the theorem note that
we've eliminated the dependence of the
running time on the capacities this
means that the algorithm is now strongly
polynomial and actually we can eliminate
the requirement that the capacities be
integers entire</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>