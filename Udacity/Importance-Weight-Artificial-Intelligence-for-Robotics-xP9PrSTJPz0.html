<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Importance Weight - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Importance Weight - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Importance Weight - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2012-05-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xP9PrSTJPz0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me explain how the second half works
suppose our actual robot sits over here
and it made us these exact distances to
the landmarks over here obviously
there's some measurement noise deputies
model as an added Gaussian with zero
mean meaning that we have a certain
chance of being too short or too long
and that probability is governed by a
Gaussian so this process gives us a
measurement vector of four values of
those four distances to the landmarks
11:12 for now let's consider a particle
it Apophis Isis devoured coordinates are
over here and not over here and also
your path Assizes a different heading
direction we can then take the
measurement vector and apply it to this
particle obviously this would be a very
poor measurement vector for this
specific particle over here in
particular the measurement vector we
would have expected looks more like this
that just makes this specific location
really unlikely in fact the closer our
particle to the correct position
the more likely will be the set of
measurements given that position and oh
here comes the big trick in particle
filters the mismatch of the actual
measurement and the predicted
measurement leads to a so-called
importance weight that tells us how
important that specific particle is to
larger the weight the more important it
is when we now have many many different
particles in a specific measurement each
of these particles will have a different
weight some look very plausible others
might look very implausible as indicated
by the size of the circles over here we
now let these particles survive somewhat
advantage of survival will be
proportional to their weights something
has a very big weight like this guy over
here will survive at a higher proportion
and someone with a really small weight
over here which means after what's
called resampling which is just a
technical term for randomly drawing and
new particles from these old ones with
replacement in proportion to the
importance weight after that we sampling
face those guys over here
very like to live on in fact many many
times we're so screwed over here likely
have died out that's exactly what
happened in our movie in the beginning
we looked at localization in this
corridor environment the particles are
very very consistent with the sensor
measurement survived with a higher
probability and the ones with lower
importance weight tended to die out so
we get the fact that the particles
cluster around regions of high a
posterior probability that is really
cool and all we have to do is we have to
implement a method for setting
importance weights and that is of course
related to the likelihood of a
measurement as we will find out and we
have to implement a method for V
sampling that it grabs particles in
proportion to those weights so let's
just do this so let me add back the
robot code we build a robot and we make
the robot move and we now get a sensor
measurement for that specific robot
using the sense function let's just
print this out these are the ranges or
distances to the four landmarks and by
adding a print my robot statement you
can also figure out where the robot is
is as 3348 0.5 obviously this is a
random output because you randomly
initialized the position of the robot
what I want you to program now is a way
to assign importance weights to each of
the particles in here I want you to make
a list of 1,000 elements by each element
the list contains a number so this
number is proportional to how important
that particle is and to make things
easier I coded for you a function in the
class robot called measurement
probability this function accepts a
single parameter the measurement vector
the Z I just defined and it calculates
as an output how likely this measurement
is and it uses effectively a Gaussian
that measures how far away the predicted
measurements would be from the external
measurements you can dive with this code
understand what's going on there's one
last change we have to do for me
this code run we have to actually assume
that there's measurement noise if
there's your measurement noise then this
function will end up dividing by zero so
let's put in a clause that specifies
what we believe the extra measurement
noise is and I'm gonna do this not for
the robot but I do this for the
particles in this line of code over here
where we create the particles for the
first time I not just initialize these
positions with n numbers but also assume
a certain amount of noise that goes with
each particle 0.05 for the translational
noise 0.05 for the rotational noise and
5.0 for the measurement noise in those
ranges so this is the crucial number
over here so coming back to what I want
you to do I wish you to construct a list
of a thousand elements in W so that each
number in this vector reflects the
output of the function measurement probe
applied to the measurement Z that we
receive from the real robot such that
when a hint print W I actually get list
of a thousand importance weights</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>