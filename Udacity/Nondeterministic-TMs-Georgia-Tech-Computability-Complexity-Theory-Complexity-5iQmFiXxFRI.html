<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nondeterministic TMs - Georgia Tech - Computability, Complexity, Theory: Complexity | Coder Coacher - Coaching Coders</title><meta content="Nondeterministic TMs - Georgia Tech - Computability, Complexity, Theory: Complexity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Nondeterministic TMs - Georgia Tech - Computability, Complexity, Theory: Complexity</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5iQmFiXxFRI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">from the class P we now turn to the
class NP at the beginning of the lesson
I said that NP is the class of problems
verifiable in polynomial time this is
true but it's not how we typically
define it instead we define NP as the
class of problems solvable in polynomial
time on a non-deterministic turing
machine a variant that we haven't
encountered before non determinism in
computer science is often misunderstood
so put aside whatever associations you
might have had with the word perhaps the
best way to understand non-deterministic
Turing machines is by contrasting a
non-deterministic computation with a
deterministic one a deterministic
computation starts in some initial state
and then the next state is exactly and
uniquely determined by the transition
function there's only one possible
successor configuration and to that
configuration there's only one possible
successor and so on and so forth until
an accepting or rejecting configuration
is reached if one is reached at all on
the other hand in a non-deterministic
computation we start in a single initial
configuration but it's possible for
there to be multiple successor
configurations in effect the machine is
able to explore multiple possibilities
at once this potential splitting
continues at every step sometimes there
might just be one possible successor
state sometimes there might be three or
more for each branch we have all the
same possibilities as for a
deterministic machine the machine can
reject it can loop forever or it can
accept if the machine ever accepts in
any of these branches then the whole
machine accepts the only change to the
seven tuple definition of the
deterministic machine that we need to
make is to modify the transition
function the range is no longer a single
state tape symbol being read Direction
tuple but a whole collection of such
possibilities the set of all subsets is
often called a power set the only other
change we need to make is when the
machine accepts it accepts if there is
any valid sequence of configuration that
results in an accepting state naturally
it also
only when every branch reaches every
Czech state if there's a branch that
hasn't rejected yet then we need to keep
computing in case it accepts therefore a
non-deterministic machine that never
accepts and that loops on at least one
branch will loop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>