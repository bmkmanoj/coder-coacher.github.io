<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Asynchronous Computation | Coder Coacher - Coaching Coders</title><meta content="Asynchronous Computation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Asynchronous Computation</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4kvX0awOSBU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">even if you know that your application
will only run on a single core single
CPU it can still be useful to express
parallelism in your programs in fact
almost every time you load a webpage
your browser is making something called
an asynchronous request back to the
server for more information that
exploits a certain kind of parallelism
you see a web server rarely sends all
the information for a web page in
response to your initial request instead
it sends a kind of outline for the page
that includes other URLs where your
browser can find the details to get
these details your browser then sends
other HTTP requests back to the server
for example we might need a stylesheet
and also an image to help fill out the
website now if we were to implement this
in a naive synchronous way our program
might run for a while but then when it
discovers that it needs a CSS file from
the server it would make the HTTP
request and then pause while it waited
to get the response back after receiving
the response it could then process the
CSS file and then continue its work
until it discovers that it needs an
image file make that request wait till
receives it and then process that image
file clearly this is inefficient there
is no sense in making the browser and
hence the user wait for a response from
the server while there was more work to
be done in reading and rendering the
original request this is why I request
back to the server are made
asynchronously and this is really just a
fancy word meaning that we get to
continue our program without having to
wait for web requests or sometimes a
system call to complete so in the
asynchronous approach we would begin by
processing the HTML file just as we did
in the naive approach but when we find
that we need to request a CSS page we do
so in a new thread this allows our
original thread to continue processing
the HTML file and discover that he also
needs to request a PNG file again he
will do this in a new thread when he
gets the CSS file back from the server
the requesting thread can process it
then when he gets back the PNG file the
requesting thread can also process that
and the end result is that we've
finished loading the page much faster
now remember we're still assuming that
we only have one cpu this means that the
computation that the naive approach did
say this red portion here can't run in
parallel with the other parts of the
processing they still have to take
nevertheless because we weren't idle
while we waited for the web server as we
were in the naive approach we've made
our page load faster by always giving
the CPU something to do and it's a
programming abstraction of threads that
makes it possible to achieve both this
behavior as well as the true parallel
processing that we discussed earlier</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>