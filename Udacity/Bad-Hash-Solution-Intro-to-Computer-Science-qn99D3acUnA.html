<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bad Hash Solution - Intro to Computer Science | Coder Coacher - Coaching Coders</title><meta content="Bad Hash Solution - Intro to Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bad Hash Solution - Intro to Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qn99D3acUnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the answer is all choices are true
except for the first one the reason the
first one is not true is this really
doesn't take long to compute we only
need to look at one letter and do a
simple modulo computation that's very
efficient but the other three reasons
are true and we'll go through each of
these showing what happens looking at
how things evaluate in the Python
interpreter so the first correct reason
is that it produces an error for one
input keyboard when we write code we
should think about whether it works for
all possible inputs and the one that's
usually the tricky is to think about is
the boundary case for a string that's
often the empty string so if we pass in
a string with no characters in it which
is a perfectly valid string well then
when we try to index element zero that
would be an error so let's see what
happens when we try that in the Python
shell so we'll try to evaluate bad hash
string passing in the keyword the empty
string which is a perfectly valid string
and let's say there are 100 buckets and
we do get an error we get the error that
the string index is out of range because
we tried to access the character at
position 0 but there is no character at
position 0 in the empty string so to
understand the other two reasons I've
defined a procedure called test hash
function it takes three inputs the first
input is a function so we can pass
functions around just like any other
value so what we're going to pass in for
this is the bad hash string function
that we've defined but we can also use
that to test other hash functions which
we'll see later we're going to pass in a
list of keys those are the key words for
the hash table and we're going to pass
in the size this is the number of
buckets what we do in test hash function
is we're going to keep results as a list
of the number of times each bucket is
used so initially they're all zeros and
we initialize it with zero times the
size we're going to use key is used as a
list of the keys that have already been
used we don't want to count a duplicate
key more than once so now we're going to
loop through the keys we're going to
check if the key was used already and if
the key was not used then we're going to
figure out by calling the hash function
where that key would hash two so if we
passed in bad hash string that would be
the function here and we're calling that
passing in the key word and the number
of buckets we're storing the result
the variable hv and then we're
increasing the value of the element at
results position hv x 1 and this is a
shorthand syntax means the same thing as
doing a new assignment where we're
assigning to results hv the value
currently in results hv plus 1 and then
we're adding the word that we just used
to the list of key used so we don't use
it again this is similar to what we did
in the web crawler to avoid crawling the
same page more than once and a 10 will
return the results so what will have as
the result of test hash function is a
list where the values in that list our
numbers giving the number of times a key
hashes to that bucket so let's try this
with an example using the bad hash
string function so to test our hash
function we need some content we need
content that represents the kind of
words that we think we're going to be
using the hash table on i've picked this
one which perhaps is represented perhaps
not and what's there at that link is
good in verse text of the adventures of
sherlock holmes and you can see from the
scroll bar it's quite long so this is
all the texts there is and so on so
we're going to get all the words on this
page using get page we're going to split
them into words like we were doing in
the crawler and we'll store that in the
variable awards and the length of that
is over a hundred thousand words now
they're not all unique so the number of
entries in our hash table will be
smaller than that but let's see how the
distribution is for those words so we'll
use the test hash function that we
defined passing in bad hash string the
words that we got from Sherlock Holmes
and we'll pick for now we'll use size 12
definitely too small but that'll give us
a good sense of how the distribution
goes for a small number of buckets so
now we have the result let's look at
what the counts are and you can see
we've got 12 entries which corresponds
to the number of buckets and they vary
quite a bit the smallest one has only
750 4 elements
the largest one has over 2,000 so the
gap between the smallest and largest is
nearly a factor of three if our hash
function was good we would want these to
be about the same size here's what that
looks like graphically we have our 12
buckets the ones that are red are too
full the ones that are blue are not full
enough we would like this to be a fairly
flat graph distributing all the words
evenly between the buckets</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>