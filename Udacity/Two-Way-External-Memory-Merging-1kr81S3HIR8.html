<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Two Way External Memory Merging | Coder Coacher - Coaching Coders</title><meta content="Two Way External Memory Merging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Two Way External Memory Merging</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1kr81S3HIR8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">suppose you have em sorted runs in slow
memory where each run is of size s items
the total number of items by the way is
n equals M times s your task is to merge
all of these sorted runs into a single
sorted run that would complete the merge
sort algorithm an easy scheme based on
the classical merge sort idea is to
merge pairs of runs and then pairs of
pairs and so on until you get a final
single run now observe what happens at
each level at each level K starting at 0
the size of the run is 2 to the K times
s now it's probably not too hard to sort
out the details but just to be clear
let's quickly walk through the steps
start by considering a pair of runs each
of size 2 to the K minus 1 times s let's
call these a and B initially a and B
live in slow memory your goal is to
produce a merged run C which will hold 2
to the K times s items let's call the
output buffer C to execute this merge
let's maintain 3 buffers in fast memory
each fast memory buffer will hold L
elements corresponding to the
transaction size let's use two of these
buffers for storing elements from a and
B and the third one for storing elements
of the output I'll refer to the fast
memory buffers as a hat B hat and C hat
to perform the merge start by reading 1l
sized block from each of a and B sitting
in slow memory and move them to fast
memory then carry out the following
steps you'll iterate until you've either
read all of a or all of B you'll locally
merge elements from a hat and B hat into
C hat do that until you run out of
elements from a hat or P hat or until
you fill the output buffer C hat if you
empty a hat or B hat and just read more
elements from slow memory if you fill C
hat then just flush the result to slow
memory and empty C hat finally if you
exhaust a or you exhaust B you just need
to copy the remaining elements from B or
a so when all is said and done what does
it cost to merge the pair of runs a B
this scheme only ever loads elements
from A or B from slow memory once and it
only
right so given output block once so
that's a total of 2 to the K plus 1
times s over L transfers regarding
comparisons there are also just a linear
number of them now this is all just to
merge one pair a and B so let's go back
to the original merge tree the analysis
you did was just for one pair now at
each level you can count the number of
pairs that will be n divided by 2 to the
K times s what about the total number of
levels
that's just log base 2 of n divided by S
combining these costs over all levels
here then are the total costs the number
of transfers is 2 times n over L log n
over s the comparisons are n log n over
s a good question to ask yourself now is
self is this good or bad</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>