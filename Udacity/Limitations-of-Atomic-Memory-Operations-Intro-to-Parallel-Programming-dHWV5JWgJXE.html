<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Limitations of Atomic Memory Operations - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Limitations of Atomic Memory Operations - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Limitations of Atomic Memory Operations - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dHWV5JWgJXE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so atomic memory operations have a
number of limitations that you need to
know about first of all only certain
operations and data types are supported
ok so there's things like add and
subtract and Men and XOR and so forth
but you can't do every operation there's
no mod for example there's no
exponentiate you can't do every
operation and only certain data types
are are supported in particular
mostly integer types so atomic add an
atomic exchange are the only types that
actually support floating-point
operations there's a workaround for this
it turns out that you can implement any
atomic operation by using the atomic
compare-and-swap operation and I'm not
going to go into the details this gets
into mutexes and critical sections
there's a there's a short example in the
programming guide that that gives you an
example of how to implement for example
64-bit operations using atomic CAS you
need to be aware that there's still no
ordering constraints right so the the
different threads in a thread block and
the different thread blocks themselves
will be running in some unspecified
order it'll be different every time and
so the operations that you're performing
on on memory using Atomics are are still
going to happen in an unspecified order
this is important because floating-point
arithmetic is actually non-associative
in other words the quantity of a plus b
plus c is not the same as a plus the
quantity of b plus c it's really easy to
convince yourself if you look at numbers
like say a equal 1 b equal 10 to the
99th and C equal negative 10 to the 99th
you can just plug this into your C
compiler annual or your calculator for
that matter and you'll discover that you
don't get the same number depending on
what order you do these operations in
and the final thing to be really aware
of with Atomics is that there's no magic
happening under the hood the GPU is
still forcing each thread to take turns
getting access to that memory it's
serializing the access to memory among
the different threads and this can make
atomic operations very slow if you're
not careful let's look into that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>