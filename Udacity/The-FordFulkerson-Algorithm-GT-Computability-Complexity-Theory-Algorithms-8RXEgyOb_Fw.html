<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Ford-Fulkerson Algorithm - GT - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="The Ford-Fulkerson Algorithm - GT - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Ford-Fulkerson Algorithm - GT - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8RXEgyOb_Fw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now with all this notation and
background behind us we're ready for the
ford-fulkerson method as we'll see it's
not really specific enough to merit
being called an algorithm though
sometimes we'll call it that anyway
we begin by initializing the flow to 0
then father's a path from the source to
the sink in the residual graph we're
going to calculate the minimum capacity
along this path we'll call that B and
then we're going to augment our flow
where the augmenting flow has B along
this path and 0 everywhere else once
there are no more paths in the residual
graph we just returned the current flow
that we found in this variable F let's
see how this works on a toy example we
start with zero flow and the capacity is
shown here we find a path in the
residual graph that looks like this the
minimum capacity is 1 so we'll add that
value to every edge along the path in
our original flow the result is a new
flow and a new residual graph here
there's only one st path so we'll go
ahead and choose that adding it to the
old flow will cause this flow across the
middle to cancel out leaving us with
this flow and this residual network at
this point there are no st paths in the
residual graph so we're done great and
it's easy to confirm that the algorithm
worked in this case but how about in
general first it's easy to verify that f
is indeed a flow 0 is a flow at the
beginning and at each iteration we
augment the current flow by a flow in
the residual graph and as argued earlier
this is indeed a flow does the algorithm
terminate well remember that the
capacities are all integral so each
augmenting flow F prime has to have a
value of at least one otherwise the path
wouldn't be in the graph therefore we
can't have more iterations than the
maximum value for a flow so yes it
terminates how much time does it spend
per iteration finding a path can be done
with breadth-first search or depth-first
search in time proportional to the
number of edge
constructing the residual graph itself
takes time proportional to the number of
edges and the number of edges in the
residual graph is at most twice the
number of edges in the original graph
since we only possibly created those
reverse edges and of course updating the
flow requires a constant amount of
arithmetic per edge so all in all then
we just have order e time for each
iteration that is time proportional to
the number of edges this is a good start
for the analysis but it leaves us with
some unanswered questions most important
perhaps is whether the return flow is a
maximum flow sure its maximal in the
sense that we can't augment it any
further but how do we know that with a
different set of augmenting paths or
perhaps with an entirely different
strategy altogether we wouldn't have
ended up with a greater flow also this
bound on the number of iterations is
potentially exponential in the size the
input leaving us with an exponential
algorithm perhaps there's some way to
improve either the analysis or the
algorithm to get a better running time
these two questions will occupy the
remainder of the lesson we'll start by
showing that ford-fulkerson
does indeed produce a maximum flow and
then we'll see about improving its
running time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>