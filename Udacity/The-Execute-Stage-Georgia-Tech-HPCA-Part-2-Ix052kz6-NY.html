<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Execute Stage - Georgia Tech - HPCA: Part 2 | Coder Coacher - Coaching Coders</title><meta content="The Execute Stage - Georgia Tech - HPCA: Part 2 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Execute Stage - Georgia Tech - HPCA: Part 2</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ix052kz6-NY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so we have seen that there is a
problem when multiple instructions
execute in the same cycle and the
problem occurs because we need to read
registers before the previous
instructions have written them because
those previous instructions now execute
at the same time as our instruction and
we have seen that the problem really
occurs in the execute stage because we
are just operating on wrong values so
let's see in the execute stage if
forwarding can help us with this if you
remember your pipelining what forwarding
does is it feeds the value from the
previous instruction to the subsequent
instructions before those values have
actually been written to registers so
let's see if that helps if you remember
we had our instructions and now we are
just gonna look at the execute stage and
we're gonna have our instruction just be
I 1 I 2 I 3 I 4 I 5 and remember that
there was a dependence from i1 to i2 so
now what would happen is we execute i1
at some point and in the same cycle we
execute I 2 so the problem with
forwarding is that it will be able to
feed this value to the instruction in
the next cycle but not to an instruction
in the same cycle cause basically if you
look at a time line for the cycle this
is the kind of beginning of the execute
stage this is the end of the execute
stage in here somewhere we are kind of
taking two values operating on them
producing a result this result is
available kind of here at the end of the
cycle meanwhile the other instruction is
taking its values doing a subtraction
producing a result and this is where
forwarding can provide this value if
forwarding worked it would have to
provide the value here and any arrow
that goes back what here means basically
time travels so pretty much it would
produce a result in you know one cycle
send it back in time one nanosecond
earlier so that it can be used here
which is of course impossible so we
cannot do that what we will do is not
execute this instruction here we will
have to stall meaning this instruction
has to be delayed it just cannot execute
in this cycle it will execute in the
next cycle if I 3 I 4 and I 5 don't have
any dependencies with
one they can still execute in you know
they have read the right register values
they're gonna be able to execute so now
what we have is really we spent two
cycles executing five instructions okay
so if we ignore the filling of the
pipeline and so on basically what we
have now is the CPI is equal to two over
five in this case which is approximately
0.4 actually it is 0.4 so what we have
is a CP of you know instead of it being
0.2 for these five instructions it would
be 0.4 if we have a lot of instructions
there will be a lot of these
dependencies so we will actually have to
spend you know we will have a CPI that
is not zero even if we had an infinite
number of execution units</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>