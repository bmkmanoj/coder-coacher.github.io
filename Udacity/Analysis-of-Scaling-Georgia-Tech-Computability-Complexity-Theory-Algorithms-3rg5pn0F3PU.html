<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Analysis of Scaling - Georgia Tech - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Analysis of Scaling - Georgia Tech - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Analysis of Scaling - Georgia Tech - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3rg5pn0F3PU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the key claim in the analysis of the
scaling algorithm is that the maximum
number of iterations for a scaling phase
is at most twice the number of edges by
scaling phase I mean an iteration of the
outer loop here where we have a fixed
value of Delta we start with the
following lemma if the residual graph
with threshold Delta has no st paths
then there exists an ST cut a B such
that the capacity of the cut is at most
the value of the flow plus the number of
edges times Delta minus one the proof
will feel a lot like the max-flow
min-cut proof we let a be the set of
vertices reachable from s in our
residual graph and we let B be the
complement of those set of vertices
edges from A to B in this graph must
have residual capacity at most Delta
minus one otherwise the vertex in B
would be reachable from the source s and
hence a part of a and edges from B to a
can't have flow more than Delta minus
one or the reverse edge would appear in
the residual graph the value of the flow
then is the flow out of a minus the flow
back into a and using these bounds here
we can bound this by the capacity minus
Delta minus one and similarly for these
back edges we can do that with the Delta
minus one bound this then is just the
capacity of the cut and combining the
Delta minus one terms or that can only
appear in a number of terms here so that
gives us the remaining part of the bound
with this lemma complete we now return
to the main claim that we want to prove
the base case where Delta is equal to C
is trivial since each augmenting flow
here saturates one of the edges out of
the source for subsequent iterations we
let F be the flow after the scaling
phase Delta and we'll let G be the flow
before that is the flow after the
previous scaling which would be either
to Delta or to Delta plus 1 depending on
how the integer division rounding work
the value of the flow F is
most the maximum flow but this is at
most the capacity of the esti cut
induced by the flow G in the previous
iteration where the threshold was to
Delta our lemma then says that this is
at most the flow of G plus the number of
edges times 2 Delta now we let K be the
number of iterations that we use to go
between the flow G and the flow F well
then K times Delta is our lower bound on
the difference between the value of the
flow F and the value of the flow G each
iteration increased the flow by at least
Delta but from this bound here we have
that this is at most twice the number of
edges times Delta and so from this then
we conclude that the number of
iterations is at most twice the number
of edges this then completes the
analysis of the scaling algorithm we
have at most log see iterations of the
outer loop order e iterations of the
inner loop and each one of these
iterations takes order e time for a
total of e squared log C as we state in
this theorem the scaling algorithm
returns a maximum flow in time order e
squared log C where C is the maximum
capacity of an edge coming out of the
source</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>