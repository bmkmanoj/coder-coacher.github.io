<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Summary Part 2 - Georgia Tech HPCA Part 3 | Coder Coacher - Coaching Coders</title><meta content="Cache Summary Part 2 - Georgia Tech HPCA Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Summary Part 2 - Georgia Tech HPCA Part 3</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DhxAIKaCEBY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's see how for the same cache we
use this address to access the cache to
make things easier to represent we will
draw the lines in the same set
horizontally so these are the lines that
belong to set 0 then we will have
additional lines and there will be lines
that belong to set 15 there are 16 sets
if you remember so the way we access
this cache is we take the index bits and
they tell us which set we have let's say
we have set 0 we then read the tag and
valid bits for all of the blocks in that
set the tag bits that we read are
compared to the tag the valid bit needs
to be also 1 in order to have a hit and
we do this for each of these blocks in
the set simultaneously so the tag is
distributed to all of them to compare as
you can see there is 4 separate
activities in order to determine for
each of these whether it's a hit and
then there is an or circuit that checks
if any one of these is one if that or
returns a one that means that we have a
hit in that case what we do is we find
which one had a hit and go back and read
out the data for that block once the
data is read out let's say this is our
64 bytes of data we use the offset to
tell us where our actual data to return
to the processor is if this was a right
then this offset tells us where to write
and if this is a right we will also set
the dirty bit here note that we don't
actually check the dirty bit if it's 0
and set it if it is 0 we just set it to
1 regardless of what it was it's faster
to just set it than to check it and then
set it so if we have a hit this is how
we find the data what if we have a miss
what if all of these have returned 0 in
that case we will check the LRU counters
in these to find the one that is 0 check
the dirty bit of that block if it is 1
we will first take this data and write
it to memory and
then put the new block here if it is
zero then we simply bring in the new
block we update the tag and everything
here we set the LRU counters accordingly
and we then supply the data to the
processor so as you can see all of the
stuff that we have been talking about in
the cache really happens kind of
simultaneously on every axis all of this
needs to happen if it's a hit up to here
if it's a miss all the way to writing
back to memory fetching another block
from memory and updating the tagging
valid bits</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>