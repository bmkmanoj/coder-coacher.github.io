<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Parallel Merge - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Parallel Merge - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Parallel Merge - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GvtgV2NkdVg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how do we do this well we find the
smallest element and we know that it
must move to the smallest output
location so in that case that's going to
be a zero here this is the smallest
element out of all of these it's going
to be scattered to output location zero
the next smallest element is here and
then here and then here and then here
here here and here so the key here is
how do we get these numbers that's the
important part of the merge algorithm
here so we're going to put ourselves in
the mental position of one of these
elements in the first list so we're
going to pick this particular element
right here and we're going to say hey
what position am I in my own list well
I'm a position two because there are two
elements in front of me in my list so he
would be a position zero he would be a
position one and I am at position two
now here's the cool part this guy has to
ask where would I be in the other list
well if I look at this list I would need
to be right here so if I was in that
list I would also be at position number
two because there would be two elements
in front of me this guy would be at
position zero this guy would be a
position one and I would be a position
two so in the overall list I know I'm
behind two elements here and I know I'm
behind two elements here so I can add
those things together and discover that
in the final sorted list I would be at
position number four and that is the
scatter address that I need to put him
in the right position in the output list
so how do we know our position in our
own list well that's very simple we've
launched these threads as a contiguous
block with one element per thread so I'm
going to be exactly at my thread ID
these thread ID zero he's thread ID one
and he's thread ID 2 so how do we know
our position in the other list that's a
little bit more complex what we need to
do to make this work is to do a binary
search in the other list so this element
will look in the other list move down as
a binary search until it finds out where
it's going to belong in the other list
every thread does an independent binary
search in parallel in the other list so
for a sorted list of
then that will take log n steps per
element and all of those elements will
do the search in parallel and that's a
very fast operation if we're doing it
out of shared memory now for sorting
more elements that can fit in shared
memory then what we generally do is read
in only a chunk of each sorted list
compute the first part of the output
write it back into main memory refill
the input arrays with more elements and
repeat until done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>