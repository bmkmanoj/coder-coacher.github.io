<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Final Unit - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Final Unit - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Final Unit - Programming Languages</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/87SnJ7-9jT0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back we're about to start the
final unit in this course this time
we're mostly going to focus on review
and some practice problems to get you
ready for the exam or at least to get
you in the mood for the exam but there
may also be just a little bit of fun you
may get the chance to hear someone who
is not Wes weimer talking I know I know
someone with real voice inflection is
still your beating heart but before we
get going with practice problems let us
make the list a high level summary of
everything you've learned thus far we
started off by introducing the concept
of a language as a set of strings
regular expressions finite state
machines formal grammars these all
denote or accept or correspond to sets
of strings in fact the set of all valid
JavaScript programs is just a set of
really big strings one of the first
tools we introduced was regular
expressions which are just a concise
notation for specifying some sets of
strings those sets of strings are called
regular languages and incredible
surprise move regular expressions to
note regular languages and we learned a
bunch of regular expressions plus star
disjunctive choice ranges of letters 0
or 1 copies and we ended up using these
to specify tokens more on that in just a
bit then we learned about finite state
machines which are a cool way to draw
regular expressions and also it turns
out a way that we implement them under
the hood that's how Python actually does
it and here I've shown a finite state
machine for a beast are possible to have
ambiguity or epsilon transitions in a
finite state machine that makes a finite
state machine non-deterministic because
if you're trying to simulate it you
don't know exactly where to go at any
given point it turns out however that is
not a problem at all we can convert
non-deterministic finite state machines
down into deterministic finite state
machines they make it a little bit
bigger but it'll totally work then we
moved on to the more powerful
context-free grammars which are a
concise notation for specifying some
sets of strings wait I thought that's
what regular expressions were actually
they're both just concise notations for
specifying possibly infinite sets of
strings and your typical context-free
grammar is just a set of rewrite rules
with a non-terminal symbol on the left
an arrow and then some terminals and non
terminals on the right
terminals are the same thing as tokens
they're the actual input that we're
trying to match and there are some cool
things that we can do with context-free
grammars like matching balanced
parentheses that we could not do we're
certain we cannot do it it is impossible
to do correctly with regular expressions
we often want to check and see if a
string is in the language of a
context-free grammar or matches that
context free grammar can be derived or
generated by that context free grammar
these are all the same question and one
way to do that was memoization which for
many years I always wanted to call
memorization but it's just not it's also
called dynamic programming which sounds
really exciting but in practice
basically builds charts where we write
down previously computed results so that
we don't have to compute them again this
is called being lazy and it's a
phenomenal virtue when you're writing
programs we can combine context-free
grammars and potentially memoization
together to get parsing which is the
process of determining if a list of
tokens is in the language of a
context-free grammar if so we produce a
parse tree where did we get that list of
tokens you ask the process of lexing
breaks a big string like a web page up
into a list of tokens or important words
the tokens are specified using regular
expressions which means that a lexer is
implemented using finite state machines
we do lexing first and then parsing I
have written them out of order to shake
things up once we have our parse tree
we're getting closer and closer to the
meaning of a program one aspect of
program semantics or program meanings is
the notion of types that we can classify
objects or values like 1 2 &amp;amp; 3 into
groups and say those are all numbers so
a type is just a set of values and some
associated operations that you can apply
so the values might be things like all
numbers all strings are all lists and
the operations might be things like plus
minus divided or length I can apply
length to a string or a list but not a
number i can add number strings and
lists but it means something different
every time i can divide numbers but i
can't really divide strings or lists at
least not using this division operator
types are our first step along the road
to meaning and in computer science we
formally
call that semantics by the way if you've
been wondering the whole time semantics
is a tricky word that essentially always
ends in an S even when we're using it in
sort of a singular fashion semantics of
a program its meaning what is it compute
a program may have type errors like if
you try to divide a string by an integer
or it may have any number of other
exceptions but in the general case it
produces a value this means that we have
computed something that was the result
that's the meaning of our program just
like a sentence in English or French or
Cantonese might have a meaning once we
have a grip on semantics we can
introduce optimization where we replace
one program with another or conceptually
one part of a program with another as
long as the whole thing has the same
semantics this is the critical rule of
optimization you can't change the
meaning of the program if you can't
change the meaning what can you change
well typically the new code you've
brought in uses fewer resources less
time less memory consumes less power and
we've seen a bunch of examples of these
x times 1 could be replaced with just X
but X divided by X cannot be replaced
with one because in the single case
where x is 0 this changes the meaning of
the program after optimizing or not you
never have to optimize we can move on to
interpretation this is the fun part we
recursively walk over the parse tree and
the meaning of a program the final
result the picture we should display for
a web page the result of a computation
in a financial program is computed from
the meanings of its sub expressions so
if I'm in a state or environment where a
Maps 25 I can compute the meaning of
this abstract syntax tree expression
well plus if x and plus I'll go down
here and figure out what a is a is 5 3
is 3 i multiply them together I get 15
over here 1 and 2 to I'd them together
and I get 3 the whole thing I get 18
walk down the tree on both sides and
only as I'm coming back up do i compute
the values typically to perform
interpretation we have to track state
like the values of variables with me
which may change in environments and
environments are often chained together
especially as you make function calls
finally we put all of that together to
build our web browser
we followed a particular architecture
you could imagine doing another one but
this is the one we used for this class
we start by lexing and parsing HTML
treating any embedded JavaScript as a
special token our HTML interpreter walks
over the HTML parse tree and whenever it
gets to this special JavaScript token it
calls the JavaScript interpreter which
just returns a string we got the string
from a bunch of calls to document right
the HTML interpreter gathers up all the
words words in HTML or words computed by
JavaScript and just calls the graphics
library to display them Wow and then
we're done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>