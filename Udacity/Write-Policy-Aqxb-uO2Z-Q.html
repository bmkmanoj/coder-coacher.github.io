<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Write Policy | Coder Coacher - Coaching Coders</title><meta content="Write Policy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Write Policy</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Aqxb-uO2Z-Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so far we have focused mainly on reading
data but what happens when we want to
write to memory here we'll consider a
single core system I'll refer you to an
architecture class for shared memory
systems we're keeping the cache is
consistent becomes a challenge we need
to consider both what happens on a hit
when the block we want to write to is
already in the cache and what happens on
a Miss when it isn't on a hit the most
obvious thing to do is to write through
to memory that is we'll write to the
cache and then also write to the main
memory to copy the data and keep the
cache and main memory consistent as long
as I don't have to worry about some
other entity needing an updated version
for memory however there's actually no
need to write everything this instant
this is the insight behind the write
back policy which only writes to the
cache after all that's where we will
look first if the same processor tries
to read the data or write to it later
only when the cache block gets evicted
sometime later does the data really need
to be written to main memory and then
it'll be the whole cache block this lazy
approach can be beneficial when the same
cache block is written too many times
before eviction for cache misses we also
have two strategies the first is write
allocate which first reads the current
value in memory into the cache then it
behaves as though it were hit using
either of the two hit strategies lastly
we have the know write allocate policy
where we just write the data to memory
and don't bother with the cache at all
the interactions among these policies
can be subtle particularly when there
are multiple cache levels it is worth
pointing out however that some of these
policies share certain assumptions and
are therefore often paired together the
write back policy is betting that there
will be subsequent writes to the same
cache block that's why he is bundling up
all the changes he is making for one
trip to memory when the block gets
evicted write allocate is also betting
on subsequent writes to the same block
that's why he loads the data up into the
cache on the other hand right through is
betting on the cache block being evicted
sooner rather than later
he does his writes to memory up front so
that he can quickly evict the cat block
from the cache later if he has to not
having to worry about any rights to the
disk
similarly the no write allocate policy
is also betting on that same cache block
not being used again soon it doesn't
even bring the data into the cache</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>