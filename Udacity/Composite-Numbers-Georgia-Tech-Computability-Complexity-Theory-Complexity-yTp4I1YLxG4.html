<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Composite Numbers - Georgia Tech - Computability, Complexity, Theory: Complexity | Coder Coacher - Coaching Coders</title><meta content="Composite Numbers - Georgia Tech - Computability, Complexity, Theory: Complexity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Composite Numbers - Georgia Tech - Computability, Complexity, Theory: Complexity</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yTp4I1YLxG4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">To get more intuition for
the power of nondeterminism,
let's see how much more efficient
it makes deciding the language of
composite numbers that is
numbers that are not prime.
The task is to decide the set
of string representations of
numbers that are the product of two
positive numbers greater than one.
One deterministic
solution looks like this.
Think of the flow diagram as capturing
various modules within the deterministic
Turing machine.
We start by initializing
some number p to 1,
then we increment it and
test whether P square is greater than x.
If it is, then trying larger values
of p won't help us and we can reject.
If p squared is no larger than x,
however, then we test
to see if p divides x.
If it does, then we accept.
If not, then we go back and
try the next value for p.
Each iteration of this loop requires
a number of steps that is polynomial in
the number of bits used to represent x,
not so bad.
The trouble is that we might end up
needing square root of x iterations of
this outer loop here in
order to find the right p or
to confirm that one doesn't exist.
This is what makes
the deterministic algorithm slow.
Since the value of x is exponential
in its input size, remember that it's
represented in binary, the deterministic
algorithm is exponential.
On the other hand, with nondeterminism,
we can do much better.
We initialize p, so
that's it's represented on its own tape
as the number one written in binary.
We then nondeterministically modify p
by having two possible transitions for
the same state symbol pair.
We can nondeterministically
append a bit to p.
By the way,
I'll mark all the nondeterministic
transitions in orange here.
Next, we check to see if
we've made p too large.
If we did, then there's no point
in continuing, so we reject.
On the other hand, if p is not too big,
then we nondeterministically decide
either to append a zero to p,
append a one to p or to leave p as
it is and go see if it divides x.
If there's some p that divides x,
then some branch of computation
will set p accordingly.
That branch will accept and
so the whole machine will.
On the other hand,
if no such p exists, then no branch will
accept and the machine won't either.
In fact, the machine will always reject,
because every branch of computation will
be rejected in one of these two places.
This nondeterministic
strategy is faster,
because it only requires log x
iterations of this outer loop.
The divisor p is set one bit at a time
and can't use more bits that x,
the number it's supposed to divide.
Thus, while the deterministic algorithm
we came up with exponential in its
input length,
it was fairly easy to come up with a
nondeterministic one that was polynomial</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>