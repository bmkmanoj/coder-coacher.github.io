<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Strategy Solution - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Strategy Solution - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Strategy Solution - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8JQYBvYE8ps" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and the correct answers here in my
opinion are the first to the first one
is even if the algorithm makes an error
with ninety percent probability running
it only a few times does guarantee a
correct solution and that is of course
as you've seen before these
probabilities here have to be multiplied
with each other if we run the algorithm
a couple of times so if you run it the
first time of course we have a ninety
percent error chance but if you ran it a
second time we only have ninety percent
squared error chance if we run three
times we have ninety percent to the
power of three and once we have run this
algorithm 50 times we have an error
error probability of ninety percent to
the power of 50 which is about 0.5% and
running it a couple of times more of
course we can even get this figure much
much lower so since we only have to run
it a constant number of times to get the
error very very low it would mean that
we're staying still in polynomial time
but we're almost guaranteed a perfect
solution now I'm not saying that this is
impossible because the laws of
np-completeness indeed to do not account
for randomness but of course it's very
very unlikely it's almost the same as
with the approximation algorithms well
you wouldn't expect an approximation
algorithm with an approximation factor
of 1.01 even though for some problems it
has not been not been proven that that
is impossible but you still wouldn't
expect it now the second choice here I
think is also correct and that is
basically my reasoning why I say you
shouldn't expect this the number of
potential solutions for an np-complete
problem is exponential since the
algorithm only runs in polynomial time
it can only afford to check a small part
of that solution that is basically the
image that we just had where you're only
able to explore small areas of the whole
solution space and of course you have to
employ the strategy I just think that
with this strategy it's highly unlikely
to get an algorithm with this
performance up here it just doesn't make
sense because you're still poking around
a lot so why would you get a fixed error
probability in an exponentially large
space if you can only afford to check a
polynomial size part of it and finally
as i said i mean the laws of
np-completeness indeed do not account
for randomness but the thing is this
just because that is so doesn't mean we
should expect anything to happen again
and I think this is the same thing as
with the approximation algorithms of
course for some problems it would
theoretically be possible to have a 1.01
approximation algorithm but it just
seems too unlikely to be true</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>