<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why Do We Care About Parallel Scan - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Why Do We Care About Parallel Scan - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why Do We Care About Parallel Scan - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HfXkXUDlBqI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's analyze this algorithm what we
want to know is how much work is it
going to take for us to complete this
algorithm how many operations are we
going to do and how many steps is that
going to take so the analysis is
straightforward for either flavor
inclusive or exclusive for each of the N
iterations of the loop we take one step
and we do one operation thus we require
n operations to complete the algorithm
and we also require n steps but the
parallelization of this algorithm is
more complex than with reduce with
reduce it was really clear that the
different pieces of the computation tree
could be computed in parallel with scan
this is much less clear so the questions
you should be asking yourself now are a
how do we compute scan in parallel at
all and be how can we reduce the work
and step complexity of a parallel
implementation as much as possible but
even before we get to those two
questions let's answer a larger question
why do I care about the parallelization
of scan in the first place so here's a
high-level intuitive explanation many
computations have the following form we
want to process a list of inputs which
I'm showing here with blue circles and
create a list of outputs which I'm
showing here with red circles and we
begin by computing this first output
from this first input then we use that
first output and the second input to
compute the second output use that
second output and the third input to
create the third output and so on for
instance in our checkbook example we use
the previous balance and the next check
amount to compute the current balance
this creates a dependency structure that
looks like what I've drawn in green when
we structure our computation like this
we see that it has no apparent
concurrency we're only doing one
operation at a time first we compute the
first output and then we use the first
output as an input to get the second
output we use this output to get the
third output and so on now this is a
very serial structure and if we
implement it in this way it would be a
poor fit for a GPU indeed computations
like this can often be expressed as a
scan and if we can characterize our
computation in terms of scan that
great because let me tell you a little
secret we can paralyze scan and make it
run fast on a parallel processor like a
GPU now not all computations with this
sort of dependency structure will fit
into the scan model but many will and
for those computations leveraging and
efficient parallel scan implementation
turns the problem from something that
would be a poor fit for a GPU into
something that is now a much better fit
so how do we paralyze a scan computation</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>