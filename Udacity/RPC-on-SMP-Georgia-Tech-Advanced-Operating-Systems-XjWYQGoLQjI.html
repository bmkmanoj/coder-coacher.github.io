<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RPC on SMP - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="RPC on SMP - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RPC on SMP - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XjWYQGoLQjI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is where multiprocessor comes in if
you're implementing this RPC package on
a shared memory multiprocessor then we
can exploit multiple processors that are
available in the SMP what we can do is
we can preload the server domains in a
particular processor and what we mean by
that is if we preload a server domain
and a processor and and don't let
anything else run on this processor
there this particular server is loaded
on CPU - we're not gonna let any other
thing disturb what's going on in the CPU
what what that would mean is that the
caches associated with the CPU will be
warm with the stuff that this particular
domain needs so in other words the
server's address space is pre-loaded in
a particular processor if you have
multiple processors and you can exploit
the fact that you have multiple
processors in the SP so if a client
comes along and wants to make an RPC
call then what we want to do is use the
server that has been preloaded in a
particular CPU as a recipient of this
particular RPC call so when this client
makes that call that call is going to be
directed to the server that has been
preloaded in a particular CPU and since
it's been preloaded in the CPU the
caches will be warm and therefore we can
avoid or reduce or mitigate the impact
on loss of locality that I mentioned to
you that goes on when you go from one
protection domain to another protection
domain so this is the happy state of the
world where what we have done is we
first of all eliminated kernel
intervention in making the actual call
and return between the client and the
server by providing an argument stack in
shared memory that is shared in the
address space of the client and the
address space of the server and this way
the client can pass the actual arguments
of the call to the a stack and the
server can retrieve it from the a stack
without kernel in the intervention and
when the server is ready to return the
results back to the client once again it
can do the same thing put it in the a
stack so that it is available for the
fly
so without any kernel intervention you
can actually do the call and return and
of course the mediation happens only in
the fact that the kernel has to validate
the call every time the client makes a
call it has to validate that call but
the loss of locality you can avoid by
making sure that the server domain is
preloaded in one of the CPUs and the
other thing that the kernel can do is
look at the popularity of a particular
server if a server is serving lots of
different clients then in a
multiprocessor then it can potentially
based on as monitoring decides that we
may want to have multiple CPUs dedicated
to the service and that way you have
several different domains of the same
server pre-loaded in several CPUs to to
cater to the needs of several
simultaneous requests that may be coming
in for a particular service</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>