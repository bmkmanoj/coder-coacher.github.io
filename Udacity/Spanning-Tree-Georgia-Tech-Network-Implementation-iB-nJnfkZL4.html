<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spanning Tree - Georgia Tech - Network Implementation | Coder Coacher - Coaching Coders</title><meta content="Spanning Tree - Georgia Tech - Network Implementation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spanning Tree - Georgia Tech - Network Implementation</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iB-nJnfkZL4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the solution to this problem is to
construct what's called a spanning tree
which is a loop free topology that
covers every node in the graph the set
of edges shown in blue constitute what's
known as a spanning tree the collection
of edges in the blue topology covers
every node in the underlying physical
topology and yet there are no loops in
the blue topology now instead of
flooding a frame a switch in this
topology would simply forward packets
along the spanning tree so for example
this switch would only send a frame
along the port corresponding to the blue
edge and would not forward the frame out
any edges that were not part of the
spanning tree other switches that
receive the frame would flood in the
same fashion along all edges that were
part of the spanning tree while omitting
edges that were not members of the
spanning tree let's take a look at how
to construct a spanning tree first the
collection of switches must select a
route since every tree must have a route
typically this is the switch with the
smallest ID in this case the switch at
the top of the topology is the route
then each switch must decide which of
its links to include in the spanning
tree and it excludes any link if that
link is determined to be not on the
shortest path to the root for example
let's consider the switch in the lower
right it has three links this link takes
it on a path that's three hops from the
root this link takes it on a path that's
two hops to the root and this link takes
it on a path that's one hop to the root
any link that's not on a shortest path
to the root is excluded and any link
that's on a shortest path to the root is
included similarly here this edge is on
a path that's one hop away from the root
in this edge is on a path that's 2 hops
away so this node will exclude this link
from the spanning tree now each switch
repeats this process to exclude links
from the underlying topology and
ultimately this yields a forwarding
topology that looks like the blue graph
and of course there's an issue which is
how do we do
in the root in the first place well
initially every node thinks it's the
root and the switches run an election
process to determine which switch has
the smallest ID and if they learn of a
switch with a smaller ID they update
their view of the root in the compute
the distance to the new root whenever a
switch updates its view of the root it
also determines how far it is from that
root so that when other neighboring
nodes receive those updates they can
determine their distance to the new root
simply by adding one to any message that
they receive</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>