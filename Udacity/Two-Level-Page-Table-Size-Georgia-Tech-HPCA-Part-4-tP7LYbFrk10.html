<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Two Level Page Table Size - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="Two Level Page Table Size - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Two Level Page Table Size - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tP7LYbFrk10" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now let's talk about how big the tool
level page table gets say we have a
32-bit address space and a four kilobyte
page let's say we're using a thousand 24
entry outer page table and a thousand 24
entry inner tables there can be many of
them up to 1024 of them and let's say
that a page table entries 8 bytes
assuming that our page table entry is 8
bytes and that we have a program that
uses virtual memory at the beginning of
memory from address is 0 through this
and at the top of the memory from
address this to the end let's look at
what the flat page table size will be
and what our tool level page table size
will be with this split between the
inner and outer page tables the flat
page table size will have one entry for
each possible page so we have 2 to the
32nd pages 2 to the 12 bytes in each
page so we have 2 to the 20th entries
and the total size will be 8 times this
which ends up being 8 megabytes for the
2 level page table we need to figure out
how many inner page tables do we have
here and here our address is now
composed of a 12 bit offset to index
into the 4 kilobyte page a 10 bit outer
page number and the 10 bit inner page
number they need to add up to 32 which
they do so we know that we need to have
the outer page table and its size will
be 2 to the 10th entries times 8 bytes
per entry here which ends up being 8
kilobytes for the outer page table now
the question is which of these entries
need to point to actual inner page
tables and which ones can simply say
that there is no inner page table to
figure that out we need to see which of
the inner page table entries do we need
to actually point to pages of memory and
which ones can simply be empty thus we
will decompose these addresses this part
of the address is the page
offset the upper part is the page number
and we need to split this 20 bit page
number into 10 bit groups so let's just
write it out we have 0 0 0 0 these are
the two zeros another hex digit for 0
the 1 and the 0 this is the outer page
number this is the inner page number as
you can see all of the addresses in this
range have the same outer page number we
start at 0 we end at 0 so only the entry
number is 0 here needs to point to an
actual inner page table for this address
range the page number goes from ffffff 0
to ffffff these page numbers also have
the same outer page number it's all ones
so only the last outer page table entry
needs to point to an actual inner page
table note that there are a thousand
twenty-four entries here only two of
which point to inner page tables so
there is a thousand 22 entries that
simply say nothing so we have two inner
page table times what's the size of one
of them well the size is a thousand
twenty-four entries times eight bytes
per entry which gives us a total of 16
kilobytes adding the size of the outer
page table we get only 24 kilobytes so
the size of a two level page table for
this application is only 24 kilobytes
compared to eight megabytes for the flat
page table and this is why multi-level
page tables are almost exclusively used
in today's processors especially when we
have a 64-bit address space because for
a 64 address space the flat page table
size would be too large to fit in memory
but a multi-level table will fit mostly
because the outermost page table will
have many empty entries so we will need
very few of these inner page tables</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>