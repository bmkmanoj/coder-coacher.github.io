<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Block Start Addr - Georgia Tech - HPCA: Part 3 | Coder Coacher - Coaching Coders</title><meta content="Cache Block Start Addr - Georgia Tech - HPCA: Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Block Start Addr - Georgia Tech - HPCA: Part 3</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XPgT3arcoTg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now that we know that when we have a
cache miss we fetch an entire block
worth of stuff from memory let's talk
about where can these blocks begin in
memory one option is a block can begin
anywhere so let's say we have 64 byte
blocks that means that a block for
example might go from address 0 through
63 bytes or it can be from 1 through 64
or it can go from 2 to 65 and so on so
pretty much if the starting address of
the block can be anywhere then these are
the possible blocks that we might fetch
in our cache this complicates things a
lot first our cache is a table we want
to index into the table using some bits
of the address that we are accessing but
let's say that what we're accessing is
the address 27 the problem is the block
can actually be found wherever the
beginning of address of the block maps
so block 0 to 63 might map here in the
cache block 1 through 64 might map
somewhere else in the cache and so on so
basically there are many possible places
where the address 27 might be simply
because each of these blocks might map
somewhere else depending on what its
beginning address is second there is
another complication which is these
blocks overlap so the block 0 to 63
contains stuff that overlaps with most
of what 1 through 64 contains so this
other than this is the same stuff now
the problem is when we are reading it's
easy we just need to read one of these
copies for 27 but when we are writing we
need to determine which of the copies
exist and write to all of them so that
reading any of them will still be ok so
pretty much we don't want this to happen
we don't want to have multiple places
where the same byte address might be so
in order to both reduce the complexity
of accessing the cache and eliminate the
problem of this repetition of stuff in
the cache we will only have caches where
the blocks start at block aligned
addresses so for a 64 byte block we will
have a block
that contains data from 0 to 63 bytes
the next block begins at byte 64 and
goes to 127 and so on so pretty much any
byte address can be found in only one of
the possible blocks that also allows us
to simply use some bits of the address
that tell us which of these blocks are
we talking about an index into the cache
and find it there so there is only one
place in the cache where each of these
will fit and so on so for all reasonable
caches we will really only consider
aligned blocks meaning you cannot fetch
any 64 bytes or 32 bytes or whatever
block sizes from memory into the cache
we need to fetch the 64 byte block that
contains the data and is block aligned</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>