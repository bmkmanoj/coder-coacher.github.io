<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Parallel Scans | Coder Coacher - Coaching Coders</title><meta content="Parallel Scans - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Parallel Scans</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OO3o14cINbo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how do we parallel eyes scan let's
first start with the prefix sum problem
once we understand that we'll have a
pattern for parallelizing any scan by
analogy to reducing an array to a single
value if we assume associativity then we
can rearrange partial sums so somehow we
want to use this idea for parallelizing
scan as well so assume associativity and
consider a scan of this input array
you could try by doing the same thing
you did in a reduction for example let's
take every pair of elements and let's
combine them the result will be a new
set of partial consecutive sums for
example this node is the sum from 1 to 2
and this node is the sum from 3 to 4 in
fact let me label each intermediate sum
with a notation a colon be the important
point is that these are consecutive
partial sums so with this notation this
is what the final output should look
like so let's go back to the partial
sums suppose you could magically and
recursively do an add scan on the
partial sums that is I take these
partial sum values and I somehow
magically apply a scan to them what
would I get in this case I would get 1
to 2 as the first scan element then for
the second scan element I would get 1 to
2 plus 3 to 4 in other words 1 to 4 and
for the third element I get 1 to 2 plus
3 to 4 plus 5 to 6 in other words 1 to 6
and then finally 1 to 8 notice what that
gives you all of the even results so
voila we've done half the work now what
about the odd results how do we get
those well that should be easy if I want
one two three I just take one two two
and add three you can do the same thing
for one two five and one two seven
voila you're done stop for a second and
make sure that that makes sense
now I claim here's some pseudocode that
implements this scheme we just described
let's do a quick analysis to make sure
we got it right now here I sub o and I
sub E store the odd and even indices
respectively that is
one three five seven and so on and two
four six eight and so on
now this particular algorithm is in
place adding the odd and even elements
over here corresponds to this line and
by in-place I mean we take this result
and we overwrite the even elements this
magic recursive step appears here and
this final combined step appears here
now note that I've used this Python
slicing notation to mean starting at
element two and going to the end of the
array if you can convince yourself that
N equals one produces the correct result
then you can use induction to prove that
the overall algorithm is correct</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>