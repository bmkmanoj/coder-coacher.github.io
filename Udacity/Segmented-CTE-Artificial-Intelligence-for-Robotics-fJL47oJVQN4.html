<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Segmented CTE - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Segmented CTE - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Segmented CTE - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2012-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fJL47oJVQN4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I spent a couple of hours porting all
the code over into this new format and
I'm going to spare you all this editing
work so in the final code that is lilium
complete still you have a grid when a
function called main main then runs a
path planner a star smoothes it and then
runs the controller as in run and in the
controller I even implemented for you
our particle filter that you're familiar
with there's nothing new here inventing
the exact same code from class that you
program to yourself and then I go
through a loop where I compute a
cross-leg error apply my only PD
controller there's no item here and I
run my particle filter as before to
estimate where the robot is whatever
what you like you to do is to implement
the crosstrack error function and I
wanted to use as an input the estimate
not the actual robot position but the
best estimate which we can get by
running filter that get position now
here is the difficulty and I can tell
you confidently it took me more than an
hour to solve this from myself just for
this class our path now is a sequence of
linear pieces when a robot drives along
it has a certain crosstrack error but as
the robot state projects beyond the end
of a line segment as is happening here
we have to change the corresponding line
segments to be the next one so in
addition to calculating the assigned
error relative to an arbitrary line
segment not just the y-axis we also have
to detect when the robot steps beyond
the end of a line segment and switch
over to the next one now suppose this is
our line segment and then the path is
given by the corners of the beginning
point p1 and the end point p2 both of
which are XY coordinates which you get
straight in the path suppose our robots
position is something like this where
has its own XY estimate that comes out
of the particle filter in your case and
it has own orientation theta then both
the crosstrack error as well as how far
it's progress along the line segment
called as you can be calculated using a
dot product specifically let's call this
vector over here Delta X and Delta Y as
defined in x2 minus x1 and the y2 minus
y1 this vector over here and it's called
this vector over here are X which is X
minus x1 and our Y then you the ratio of
how far we've progressed along this
segment is given by the dot product our
x times Delta X plus our Y times theta Y
divide it over the sum of squares Delta
x times Delta X plus Delta Y times Delta
Y y
well this normalizes the vector length
to 1 and this is the dot product of this
vector over here and the green vector
which happens to define the distance so
if this is larger than 1 we know we've
left this segment it's time to move on
to the next one finally the crosstrack
error the red one over here is given by
a similar but not identical dot product
of our Y times Delta X notice we now
multiplying a Y with an X minus instead
of plus our x times Delta Y with the
exact same normalizer as down here so
you can see the normalizer over here so
what I want you to implement if this
piece of math over here when you run
your controller you will find that I set
up for you a very weak on index that's
indexed into your path when you exceeds
one we should increment this index make
sure it never goes beyond what's legal
and path length and the cross check
error should be computed relative to the
current index and is of course assigned
error using the exact same dot for that
I've shown you the last thing I want to
tell you is what the path is and I want
you to use the following path the path
is called s path it's given the run
function is one of the parameters over
here you can see this up here so s path
in
NIC's is the indexed element of this
path and zero stands for X and one
stands for y so please fill in the
missing code over here and I should tell
you when you run more controller with
the missing code included you get
actually a valid nice path that mostly
doesn't collide occasionally does
because of randomness in the system but
it should be mostly collision free and
for this example look for about a
hundred thirty or so robot steps and
just so that you see a typical answer
here is a random run which means and you
read this as follows
true means robot actually found the goal
zero means zero collisions and it took
137 steps let me run it again and here's
another outcome robot didn't collide it
reached the goal in 145 steps I should
warn you sometimes that do get
collisions here and it's because our
obstacle circles are relatively large
the noise in the system makes it hard to
navigate but most of the time it should
be able to get it to go off without
difficulties if you implement this piece
of code correctly and just to warn you
it took me quite a while to work this
out</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>