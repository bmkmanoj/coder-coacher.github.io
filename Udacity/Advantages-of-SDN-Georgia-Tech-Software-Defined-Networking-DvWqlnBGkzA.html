<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advantages of SDN - Georgia Tech - Software Defined Networking | Coder Coacher - Coaching Coders</title><meta content="Advantages of SDN - Georgia Tech - Software Defined Networking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advantages of SDN - Georgia Tech - Software Defined Networking</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DvWqlnBGkzA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there are many reasons that a controller
might want to write policy to change the
state in the network switches including
maintenance unexpected failure and
traffic engineering any of these network
tasks involve or require updating state
in the network switches and when that
state transition happens we want to make
sure that forwarding remains correct and
consistent in particular we would like
to maintain the following invariance
there shouldn't be any forwarding loops
and there shouldn't be any black holes
whereby a router or switch receives a
packet and doesn't know what to do with
it
there also shouldn't be cases where
traffic is going where it shouldn't be
allowed to go because of the network
being in an inconsistent state let's now
consider an example of what might happen
when policies are written to the network
if they're written in an inconsistent
fashion let's consider a case where we
have a network that is performing
shortest paths routing to some
destination and the link weights are as
I've shown here in the figure traffic in
the network would flow along the paths
shown in green let's suppose now that an
operator wants to change the network
state to shift traffic off of this link
he could do so by updating the link wait
in doing so the new shortest path from
this top router would be as follows but
what if the state in the top switch
occurred before the state in the bottom
switch could be updated in this case we
would have a potential forwarding loop
traffic would proceed to the bottom
switch but the bottom switch would still
have the old Network State and would
continue to forward traffic to the top
switch resulting in a forwarding loop if
rules are installed along a path out of
order packets may reach a switch before
the new rules do so in this type of
model we would have to think about all
possible packet and event orderings to
ensure that consistent behavior resulted
so we need atomic updates of the entire
configuration the solution to this
problem is to use a two-phase commit
so that packets are either subjected to
the old configuration on all switches or
to the new configuration on all switches
but packets aren't subjected to the new
policy on some switches and the old
policy on others
the idea is to tag the packet on ingress
so that the switches maintain copies of
both p1 and p2 for some time when all
switches have received rules
corresponding to the new policy then
incoming packets can be tagged with p2
after some time when we're sure that no
more packets with p1 are being forwarded
through the network we can only then
remove the rules corresponding to policy
p1 now the naive version of two phase
commit requires doing this on all
switches at once which essentially
doubles the rule space requirements
since we have to store the rules for
both p1 and p2 we can limit the scope of
the two-phase commit by only applying
this mechanism on switches that involve
the affected portions of the traffic or
the affected portions of the topology</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>