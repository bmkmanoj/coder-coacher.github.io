<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lower Bound | Coder Coacher - Coaching Coders</title><meta content="Lower Bound - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lower Bound</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zvXMPSICQqU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so that's pretty cool so we we have an
upper-bound that says that our algorithm
is not going to take any longer than N
squared K steps to explore a
deterministic MVP and a reasonable
question to ask is is that good or bad
and and so what I want to argue next is
that there's a lower bound saying that
no algorithm can do better than N
squared K and therefore our algorithm is
actually doing very well look well as
well as one can do as well as one could
do right which may help you well enough
know and in fact really and when you're
trying to learn in these kinds of
domains you don't really want to make
worst-case assumptions so this is this
is under the under a worst-case
assumption where there's really no
structure in the MVP how many mistakes
might might we make on route to finding
the optimal policy okay all right so let
me draw a little MDP so here's an MVP
that we can call combination lock so the
basic idea of this is we've got some
kind of n state sequence and two actions
which I drew is purple and blue here and
each state has a purple action and a
blue action and one of them goes back to
this reset state the state number one
while the other one advances us up the
chain one step I think and so we need to
explore this whole thing say because
there's some kind of giant reward over
here and if every every step that we're
not making along this chain and then
looping around here is a mistake so the
question is how many mistakes might we
make on Route two to finding this plus
100 so let's say we start off in this in
this state number one so what would what
would our max do in this case Charles um
it would pick one of them because they
look the same
right so it's oh it's in the state it
doesn't know anything about the outgoing
actions and it knows that there's purple
and blue so it picks one and there's
really no I I tried to be kind of random
about the way that which one would go
forward and which one would go backwards
so there's really not nothing you can do
other than guess if you guess wrong then
you take this blue action and end up
back in state one at which point you'd
say okay well I know what that does let
me try the purple action and now it
advances us to the next state right
alright so what happens from here well
you don't know what's gonna happen next
so you'd pick one of them right and so
if we choose the purple one we get reset
back to the beginning at which point we
can kind of march up the chain and you
know get back to to where that we have
some unknown information and then try
blue but basically each time we're
exploring one of these states it's
taking us well if you think about a
state I to explore state
i we take one action which resets us
back to the beginning and it takes us i
steps to get back to i and then one more
to get to the new state i plus one so
the total number of steps that we're
taking here is going to be like one plus
two plus three plus 4 all the way up to
n right
that looks very in squares to me which
is exactly right which is in squarish
some people say right so this total
number of steps we take it's not
literally N squared but it's some
constant times N squared and and you
can't really do better than that now in
this particular case we really wanted to
prove a lower bound that was going to
relate it to K times N squared where K
is the number of actions here the number
of actions was to do you think the same
example actually kind of scales up for
greater and greater K how would you how
would you change this example so that it
would basically force us to do K actions
times N squared well I could just make
all but one of them sends you back yeah
okay so let's think about what that
would do so if we had K actions one of
them sent us forward and we have no idea
which one and all the other ones send us
back to the beginning then what's gonna
happen is we're gonna have each time we
explore state I we're actually going to
get reset and have to take n steps K
times right right so for each of the N
States essentially we're going to have
to explore all the actions and for all
but one of them it's going to be n steps
to get back to where we are exploring
again and look at that hmm looks like N
squared K or K and squared yeah I just
reordered it so that it looked more like
the thing on the top you know if you
remember from our last machine learning
class everything got us back to K N and
there you go oh nice it's all the same
it's always K nearest neighbors but in
this case it's not it's K farthest
neighbors no no no well yeah I guess
there's some truth to that that each
time we take an action that we don't
know about we're getting unlucky and
we're having to take a very long trail
to get back to where we started but no
I'm just saying K nearest neighbors is a
particular kind of algorithm and here
we're just talking we're not and doesn't
stand for neighbor here right it stands
for a number of states I prefer to think
that n stands for neighbor in this case
great okay then I think we've got this
one under control so that's this that's
the argument that I wanted to make there
is that that we really do have to take K
N squared in the worst case in a
deterministic MVP to figure out what's
going on and and stop making mistakes
yeah and there's no way around it
because this is like well
really is a combination lock the way you
draw it if it's a random binary string
that gets you to the end unless you get
extremely lucky there's no way to figure
out what it is without trying all the
combination sort of well it's not all
the combinations so it's a combination
lock in some ways is actually a not a
great name here so so in particular what
makes it a combination lock is to make
it across this whole chain of N Things
you have to choose the right color in
sequence you have to choose in this case
purple blue purple purple blue blue blue
blue blue blue blue blue right so you
have to kind of crack the lock in a real
combination lock right if you get any of
these wrong at the end of it you don't
get to find out which ones were right
and which ones were wrong you get reset
back to the beginning and you just have
to start again so you really end up
taking like number of actions to the
number of states right different
different combinations here we're lucky
enough to actually know hey the first
eye parts of our combination are correct
and we're just guessing the ithe 1 so
really it's a sequential combinational
yeah which is not very secure from a
from a I don't know security standpoint
well in particular you can solve it in N
squared time instead of KT the end time
right so N squared doesn't sound so bad
if you're comparing it to K to the N
right but anyway but the point the point
is that we can't get around that and so
that's that's really what I wanted to do
so that so the next thing I want to talk
about is combining this idea with the
the bandit idea that we talked about
earlier and get an algorithm for general
MVPs okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>