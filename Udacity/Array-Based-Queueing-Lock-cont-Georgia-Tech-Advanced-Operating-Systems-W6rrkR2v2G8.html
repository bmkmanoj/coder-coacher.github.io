<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Array Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Array Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Array Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W6rrkR2v2G8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">since we've initialized this array with
HL in the first part and MW and all the
others parts of this array to enable the
queueing what we're going to do is
associate with each LOC another variable
which is called a cue last variable and
this cue last variable is initialized to
0 and so these two are the two data
structures associated every lock so
every luck that you have in your program
the operating system is going to assign
two data structures for you one which is
the circular cue represented by the
flags array and the other is the cue
last variable which is saying what is
the spot that is available for you to
cue yourself in this in this particular
array so as you can see since there is
no lock request yet we just initialized
the cue the first guy that comes around
to ask for the lock will get it and and
he will kill himself here and he'll get
the lock as well so let's say some
processor came along and and made a lock
request it's going to get it immediately
because there's no locks request
currently pending and so it's got this
position and he's got the lock and what
will happen is that the cue last
variable will advance to the next part
to indicate that future requesters have
to start queuing up from here and now
this current lock holder has got the
lock and he can go off into the critical
section and do whatever he wants in
terms of managing or messing up with the
data structure that is governed by this
particular lock let's say that at some
point of time I come along and request
the same lock now depending on who else
got ahead of me at the point that I made
that lock request there may be some
number of people that are lined up ahead
of me and wherever queue last is
pointing is my place and and so this is
where I'm going to queue myself waiting
for that lock and of course queue last
will advance to the next open spot for
future requesters that come after me now
the important point I want you to notice
is that since they're the array size is
N and the number of processes is n
nobody will be the nine everybody can
come and queue up waiting for this lock
because
since there are n processors at most n
simultaneous requests can be there for
that lock and everybody will get their
unique spot to wait for if in fact the
lock is currently in use given the
timing of my lock request and the
position of the current lock holder you
can see that I have some waiting to do
because there are quite a few requests
that are ahead of me and so I have some
reading to do before I get my turn in in
acquiring this particular lock so now I
can tell you how the lock algorithm is
gonna look like pretty simple when I
make a lock request what I'm going to do
is mark my place in this Flags array and
the way I do that is by calling fetch
and increment on the cue last variable
and that ensures that I get my unique
spot due to the fetch operation and I
increment the cue last a point to the
next part that's available for the
future requesters and since fetch an
increment is an atomic operation
remember that we have read modify write
operations fetch and increment is one of
those and it's an atomic operation and
therefore even though it's a multi
processor there could be multiple guys
trying to get the same lock at the same
time they're all going to be sequenced
through this fetch and increment atomic
operation and so there is no issue of
any DS condition in that sense so I will
get my spot and I'll increment queue
last and of course if the architecture
does not support this fancy fetch in
increment
read-modify-write operation then you
know you have to simulate that operation
using using test and increment
instructions so once I have marked my
position in this flags array then I'm
going to basically wait for my turn
so what I do in order to wait is I'm
basically waiting for this part that I
have marked myself it is right now must
wait it has to change to HL once it
changed to HL I know that I have the
lock and therefore I'm going to do a
spin on this particular location and and
I'm gonna wait for this this location
changing its value from MW to HL so
that's the spin loop that you see here
so basically once I have
mark my position I'm gonna wait on my
position becoming HL to know that I've
acquired the lock and I will get it
eventually because that's the way this
algorithms supposed to work</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>