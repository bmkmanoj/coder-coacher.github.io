<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kolmogorov Complexity - Applied Cryptography | Coder Coacher - Coaching Coders</title><meta content="Kolmogorov Complexity - Applied Cryptography - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kolmogorov Complexity - Applied Cryptography</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7q270EbX744" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so that question assumes some notion of
randomness but it's a very fuzzy concept
to define what I think is the most
useful definition of of randomness is
the one that and Ray Cole MacGrath
came up with which is based on Cole
MacGrath complexity and this is an idea
that was developed by the Russian Andrey
Kolmogorov as well as by their
Argentinian and Gregory chitlin the
ideas it's a way of measuring the
complexity of some sequence and it's
defined as the length of the shortest
possible description of that sequence
for this to be well-defined we need to
understand more precisely what a
description is one way to do this would
be to say it's a Turing machine and
decide on some formal way for writing
down a Turing machine but we could use
any method of describing algorithms that
we want it could be a Python program
whatever we select as our description
language call Mulder of complexity is
well-defined and as long as that
description language is powerful enough
to describe any algorithm it's a
reasonable way to define complexity and
we can use that to define a notion of
randomness some sequences random if the
shortest way to describe that sequence
is the length of the sequence plus some
constant that means as we make the
sequence longer the description gets
longer at the same rate this matches the
notion of randomness that we used
informally and the quiz that if there's
a short program that can produce the
sequence that means it's not random it
has some structure to it and the program
shows us what that structure is if there
isn't any short program that can
describe that sequence well that's an
indication that the sequence is random
that there's no simpler way to
understand that sequence other than to
see the whole sequence so this seems
like a useful notion for understanding
randomness we're gonna ask a quiz to see
if it seems like a useful notion for
measuring randomness so the question is
for a given sequence s is there a way to
compute they'll call Mulder of
complexity of s the choices are that we
can that is the length of s plus some
constant so the second choices
yes we can it's impractical to do this
but here's an algorithm for doing it we
can start by initializing into one we
can have a loop that keeps going until
we find the correct value of n which is
the comb older of complexity of the
string s and we're going to do that by
looping through all the programs of
length n this is a big set but it's
finite so in theory that would
eventually finish and for each program
we're going to execute that program see
if it produces s as its output if it
does that's the result that we want and
the third choice is no it's
theoretically impossible</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>