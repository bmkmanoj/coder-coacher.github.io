<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Persistant Channel Architecture - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Persistant Channel Architecture - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Persistant Channel Architecture - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2CQhNCJeZvw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">having given you the abstractions and
pts and the simplicity of the
programming model I will now introduce
you to the heavy lifting that needs to
happen under the covers in order to
support this simple programming model
from the point of view of the domain
expert developing a situation awareness
application all the computations in the
application can be considered as either
producers or consumers of data producers
of data are putting things into the
system and consumers of data are getting
stuff from the system and under the
covers
there are worker threads in the runtime
system of pts that react to these get
and put calls coming from the producers
and consumers for instance whenever a
producer puts an item that results in
new item triggers that are going to be
generated by the worker threads to the
rest of the implementation
implementation of the channel
architecture is a three layer
architecture the top layer is the live
channel layer of the architecture and
this is the layer that reacts to the new
item triggers coming from these worker
threads working on behalf of a put call
that is coming from a producer so the
channel abstractions result in these new
item triggers to be sent to the live
channel layer of the channel
architecture and the live channel layer
is the one that is holding a snapshot of
items that have been generated on a
particular channel starting from the
oldest item in the channel to the newest
item that just came in because of this
new item trigger at the time of creation
of a channel the creator of a channel
could specify what the semantics of the
data that are kept in this channel or in
particular a creator of a channel could
say that
what I want the channel to contain are
live data corresponding to a certain
snapshot of real time from oldest to new
for instance I could say keep only the
last 30 seconds of data in the channel a
rest of it
you can throw it away so there is a
garbage collection trigger that is part
of the runtime system that is looking at
information that is in the channel that
says what items in the channel have
become old and therefore can be thrown
away those are the GC triggers and the
GC triggers will move data that have
become ancient so far as this channel is
concerned and move it into this garbage
list meaning that these items are no
longer relevant from the point of view
of this application and therefore they
can be garbage collected so they are put
into this garbage list and there is
another garbage collection thread that
is responsible for periodically cleaning
up all the garbage that has been created
in throwing away stuff that is no longer
relevant for this computation so this is
all the channel bookkeeping that's
happening under the covers in support of
an application that is using the pts
library but there's a lot more to it
than just dealing with live data and
data that is no longer relevant and that
has to be garbage collected or thrown
away as I mentioned one of the features
of the pts architecture is a fact that
an application can choose to keep data
for as long as it wants and that is the
persistence property that is supported
by the pts runtime system so once again
as properties of the channel an
application programmer could specify
that I don't want to throw away stuff
that becomes old to keep in the channel
but I want to archive them I want to
persist them and if those properties
have been associated with the channel
then when items go past the window that
has to be stored in the live channel
layer
the live channel layer results in
generating what are called persistent
triggers to indicate that some items
have become old in this channel and they
have to be persisted the second main
functional layer in the channel
architecture is the persistence layer
the interaction layer is just a go
between the live channel layer and the
persistence layer of the channel
architecture and what the persistence
layer does is based on the persistence
triggers that it gets from the live
channel layer it is going to take items
from the channel and decide how to
persist them now here again the
application can have a say in how items
need to be persisted and they do that by
having a pickling handler that is an
application can specify here is a
function that I want you to use every
time you decide to persist some items
from the channel for example an
application may specify that don't store
all the images as is on archival storage
but condense them in such an so fashion
and that is a function that it can
supply and the runtime system when it
works on persistence will automatically
apply the application specified function
on the items that need to be persisted
to create a digest which will then be
persisted items that need to be
persistent necessarily have to go to
non-volatile storage devices and here
again the pts architecture supports
several different configured backends to
store items that need to be persisted
and the Macan layer is the third layer
in the channel architecture and pts
supports several different backends to
support the persistence activities and
it is an application choice as to which
back-end layer it wants to use for its
specific application the back-end layers
supported by pts include mysql it
can use UNIX file system as a
persistence layer or it can use a file
system from IBM called GPFS so MySQL
UNIX file system and gpfs are the three
different backends that are available
for the persistence layer to store
channel data that needs to be archived
for later retrieval the nice property is
that all of those persistence activities
happen unbeknownst to the user all that
the user has done is at the creation of
a channel specified certain properties
to associate with that channel for
example the property that may be
associated with the channel is that any
items beyond the last 30 seconds
persistent on the storage and when you
persist them on the storage apply this
function those are the things that are
being specified by the user creation
time of the channel once that is done
the heavy lifting that needs to be done
during done time is all handled under
the covers by the runtime system of the
channel architecture that takes items
from the channel pickles them using the
function that has been specified and
uses one of the configured backends to
push those pickled items onto the
persistent storage on the other side
when an application wants to get an item
that item range may span from something
that is there in the live channel part
of the free layer architecture or it
could be on the archival storage now it
is up to the runtime system to retrieve
all the items between a lower bound and
the upper bound specified by a get
primitive so a get primitive that spans
both live and archived items results in
get triggers being passed from the live
channel through the interaction layer to
the back end so that corresponding to
the get interval that is specified the
backing layer
can pull the data from the archive
storage and pass it up so that it
finally gets to the application what I
wanted to illustrate through this
picture is there is a lot of heavy
lifting that needs to happen in order to
support a simple programming model the
programming model is very simple but in
order to support the simplicity all of
the heavy lifting has to be absorbed
under the covers in the runtime system
of the pts programming model</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>