<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fsm Optimization Solution - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Fsm Optimization Solution - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fsm Optimization Solution - Programming Languages</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cInHxDsDwZ8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in this problem we have a bit of a
challenge and I've accordingly labeled
it with two gold stars but what we want
to do here is optimized a finite state
machine so to go through an example
let's say we have this finite state
machine there's one accepting state at
state 1 and then we have these few
others if you quickly look at it and
think about what's going on once you
take a path down the b2 state to you can
never get to the accepting state from
state 2 3 or 4 there's no way to get
this day one so any string that goes
down this path is always going to fail
this state machine is equivalent to the
one that doesn't include any of these
states so we can make it a lot simpler
so why would we want to do this well if
you haven't noticed we've been using a
lot of regular expressions in building
our web browser those regular
expressions are represented as finite
state machines and that's how they're
processed in order to make our web
browser faster turns out we want a small
finite state machines as possible so
what we're going to do is write code
given a definition of finite state
machine like the one that we have here
we're going to identify states that
don't matter towards the execution and
we call those dead states and remove
them from the definition while
maintaining the exact same language
while recognizing the exact same strings
that are finite state machine did before
so how are we going to do this let's
come up with a plan so here we have the
plan step one let's find the live states
and the dead states and we're going to
do this by just finding the live states
and assuming everything else is good so
how are we going to do that well we're
going to find all the states and we can
do that by iterating through our
dictionary and with each state we're
going to run n fsm accepts which is from
homework 1 and it's a procedure that
given a definition for a finite state
machine a starting state and the
accepting states it sees if it's
possible to get from that state to any
accepting state if it's possible to
secede from where r at so if i give this
definition
and state three it's going to tell me
now we can't get to state 1 or any
accepting state for that matter if I
give it one it's going to say yep this
is all good and so that's actually going
to be your definition for live versus
doubt it can actually find a live state
versus a debt state which is awesome
step 2 we're going to create a new
finite state machine that doesn't have
any of the Dead States in order to make
it a really good kind of clean
definition we have to take some care we
don't want to include any transitions
that lead to debt States we want to
remove all the dead States and we also
want to remove states that no longer
point to any live States so here I have
a bunch of little sub parts we're going
to go through each edge state each entry
in our dictionary if the current state
is dead we're not going to copy it into
our new finite state machine otherwise
we're going to go through all the
destinations it had in the original
finite state machine and prepare to copy
over any that are still alive if there
are none that are still alive we're
going to remove that edge completely
we're not going to copy it into the new
one and once we've repeated that process
in every state edge thing in the graph
we're going to update our accepting
state list accordingly with we don't
want to have any accepting states that
are dead so let's go to the solution so
one of the first things I did is I
copied in non deterministic finite state
machine accepts directly from unit 1
homework it hasn't changed a bit now I'm
going to do my trimming of my finite
state machine so like I said in my
outline I want to find all the states
just so I have a record of them and it
doesn't really matter if I duplicates it
might slow down the trimming a bit but
I'm doing this to save time when i'm
running the execution not for the
trimming so much so for each state if
it's live I can tell by running NFS m
accepts and if it is live we want to add
it to a list of live states now I'm
going to create a new dictionary of
edges my new representation and go
through all the old ones to see if
they're still alive and update them
accordingly so for each edge in the old
dictionary if
state is live then I'm going to
calculate the new destinations namely we
want to remove the destinations that are
now dead and so if that destination is
live when appended to the list but I
only want to set this new edge to my new
finite state machine dictionary if the
destinations are not empty there's
really no point in having an edge that
goes to know where that goes to fail we
just kind of always assume that if the
edge doesn't exist then we're going to
fail and lastly I want to update my
accepting states to only those that our
life I'm going to return the tuple of
the new edges and the new accepting
states and that's it look it's true so
much true true means good it means
meaning and greatness</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>