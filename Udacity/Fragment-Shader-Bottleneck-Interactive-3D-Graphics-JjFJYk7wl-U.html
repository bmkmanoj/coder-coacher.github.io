<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fragment Shader Bottleneck - Interactive 3D Graphics | Coder Coacher - Coaching Coders</title><meta content="Fragment Shader Bottleneck - Interactive 3D Graphics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fragment Shader Bottleneck - Interactive 3D Graphics</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JjFJYk7wl-U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">they say in brainstorming sessions there
are no bad ideas fair enough but at some
point you have to call out the ones that
sound counterproductive or incoherent
the first idea here is in that category
since it makes no sense at all the input
to a fragment shader is the point inside
a triangle typically produced by
triangle set up the application doesn't
feed surface points to the GPU it
provides triangles even if it fed such
points to the GPU these points would not
normally be properly placed on the
screen that's something the vertex
shader does transforms the triangle of
screen coordinates so forget idea number
one the second idea is a good one if we
know early on that the fragment is not
visible then we don't have to use the
fragment shader at all GPUs take
advantage of this and so perform the
z-depth test early so saving on
executing the fragment shaders program
this type of speed up is called early as
e after the fragment is computed its
then put into the z-buffer and color
image as usual however there's a little
subtle catch with this idea if the
fragment shader itself actually changes
the z-depth value passed in then you
cannot safely check the z-depth before
running the shader program that said
about ninety nine point forty four
one-hundredths of all fragment shaders
never touch the z-depth in fact in WebGL
it's not currently possible though this
has been proposed as an extension this
third idea of making each core be usable
as either a vertex or fragment shader is
worthwhile this in fact is how modern
GPUs are architected vertex and fragment
shaders are close enough together in
functionality that a single core can be
used as either this is called a unified
shader an advantage for the fragment
shader bottleneck problem is that such
course can be allocated on the fly if
fragments are piling up cores are
assigned to them if vertices are queued
up cores are moved to this area the
force solution doesn't change anything
as far as the fragment shader goes the
same number of pixels will be covered
and generate fragments so that the
fragment shader still has to work as
hard worse yet adding more triangles
means more strain on other parts of the
pipeline such as the vertex shader so
this idea causes more overall work not
less</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>