<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Finding Bridge Edges - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Finding Bridge Edges - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Finding Bridge Edges - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K2rkXGltHXQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so I've redrawn the graph from
the previous example just to make a
little bit more room and what we've got
so far is the original graph and the
tree version of the graph that we built
by search some kind of dealer
depth-first breadth-first any kind of
search actually will do as long as we
now have these green edges pointing
downward and these red non tree edges
connecting nodes that that need to be
connected if if the edge wasn't actually
part of this tree then we post ordered
the nodes and now what do we do next we
now compute the number of descendants
for each node in the graph and the
number of descendants is the number of
nodes that are either the node or
reachable from the node by following
green edges only so these is easiest to
start at the bottom here F has just been
the node itself and no descendants so
it's got a number of descendants of one
same thing with G E has one descendant
one to seven plus itself for three D has
the three descendents of e plus itself
for four C has the four descendants of D
plus itself is five B has just itself
and a has B's descendants C's
descendants plus itself for seven so the
next thing we're going to compute is for
each of the nodes we're going to
consider the set of nodes that are
descendants of the node or reachable
from the descendants of the node by one
hop of a non-tree edge and of all those
nodes that are reachable we're going to
look at the postorder value that is the
smallest we'll call that L so in the
case of F F has itself and it also can
reach G the smallest value there is two
G has no descendants but it can reach by
one red edge F so the smallest of these
values two and three is two
e has F and G in itself that it can
reach and other nodes by non-tree edges
and the smallest of those numbers is 2 D
can reach all of these nodes and itself
but also by a non-tree edge it can reach
this node and a small so those numbers
is 1 C can reach all of these nodes and
through one of those nodes one tree edge
gets it to 1 B is values itself is 1
so that's going to be the smallest and a
includes everything so that's going to
include the one so that'll be the
smallest H is the same idea except of
those that same set that we computed for
L we want to know the largest value for
G between F and G the largest value is 3
for e between EF and G the largest value
is 4 for d d e f g and b reachable by a
red edge the largest value is itself 5 C
same set we're adding in C now and the
largest value becomes 6 and a's set
contains everybody so that's going to
include itself with value of 7 all right
now we've decorated these nodes with
lots of interesting numbers now we can
get to the last step so given all these
nicely decorated nodes we now have a
rule for figuring out which ones are the
bridge edges and this is the rule all
the bridge edges are the ones that are
green they have to be tree edges and the
green number is less than or equal to
black number and the red number is
bigger than the blue number minus the
black number or in words the H value has
to be less than or equal to the
postorder value the lowest value has to
be bigger than the number of descendants
minus the postorder value so apart from
the fact that it's not immediately
obvious why this is the right rule let's
apply it to the tree to see what gets
picked out so what we're doing here is
we're looking at each green edge and
we're checking the numbers on the on the
downward part of the hedge so here's a
green edge and let's look at the numbers
here and see if they fit the pattern we
need the Green number to be less than or
equal to the black number so that
doesn't work all right here's another
green edge we need the Green number to
be less than equal to the black number
oh that works so the red number needs to
be bigger than the difference between
the black and the blue so the black and
the blue the difference is to the red
number is 2 so that what that doesn't
work alright next edge to check is this
one so we need to check is Green less
than or equal to black yes is red bigger
than black - blue 2 is bigger than 1 so
yes so this Edge has been identified as
a tree edge that's the right answer and
none of the other edges are tree edges
but let's just check them just to be
sure for this edge we have we need green
to be less or equal to black which we
have and we need red to be bigger than
the difference between blue and black
but one is not bigger than 1
so this edges out about this guy we need
green less than equal to black yes we
need red bigger than the difference
no green number is five because the D
node is reachable by a non-tree edge
all right so green less or equal to
black no all right well that's it those
are all the edges so in this example
anyway the one edge that the algorithm
finds is exactly the bridge edge can we
get a handle on why this works it seems
kind of magic at this point</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>