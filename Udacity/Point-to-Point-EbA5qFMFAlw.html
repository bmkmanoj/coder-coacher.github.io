<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Point to Point | Coder Coacher - Coaching Coders</title><meta content="Point to Point - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Point to Point</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EbA5qFMFAlw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">beyond the model you need a pseudocode
notation for formalizing algorithms so
let's start with our traditional
sequential pseudocode notation and let's
make the following changes first we'll
write our algorithms assuming a single
program multiple data style HPC nerds
refer to this as SPMD or spin D style
the way spin D works is as follows first
you'll write some pseudocode algorithm
then you'll imagine running that
algorithm on some cluster and you'll
assume that that pseudocode is
replicated on all the nodes will call
every running copy a process each
process runs independently and
asynchronously from the others in the
absence of barriers or any other kind of
explicit synchronization now to
distinguish the copies from one another
will assume that the pseudocode
algorithm has access to two global
variables one called rank and one called
P since the memories are private these
variables are private to each running
process rank will be the ID of the
running process and it'll be unique P
will be the number of processes now for
the moment the concept of a process and
the concept of a node are basically
interchangeable but in practice a
process virtualizes the concept of a
node that means you might have more than
one process assigned to a node if for
example you're running on a multi socket
multi-core system now to see how this
works suppose that the pseudocode
algorithm contains a line of code which
reads as follows so when all the
processes run they'll all print
statements of the following form I am 0
out of 5 I'm 1 out of 5 and so on each
print their own rank and the total
here's a second change to sequential
pseudocode I will give you a primitive
which performs an asynchronous send
think of it as an API call that looks
like this now it has two arguments one
is a buffer of size N and the second is
a destination rank basically the rank of
the process that's supposed to receive
this message now an important and subtle
point about send async is what is it
when it returns when it returns it does
not mean that the buffer has been sent
it just means that a send is registered
with the system so in particular until
you know what's happened you should not
modify buff to find out what happened
send a sync will return a handle and you
can do some testing on the handle now
for this send to eventually complete the
destination rank has to post an
asynchronous receive the signature looks
the same it names buffer of some size
and it names a source rank the source
being the sender just like send a sync
when receive a sync returns it does not
mean the data is available rather
receive a sync will return a handle and
you should do some testing on the handle
this business about handles brings us to
the final primitive which is called wait
in particular wait is a blocking
operation that takes one or more handles
as arguments now wait will pause until
the corresponding operations complete
now there's also a special form of wait
to call the weight all abbreviated here
by weight with an asterisk this is a
shorthand that says wait for all
outstanding sends and receives so that
we don't have to track and check all the
handles all the time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>