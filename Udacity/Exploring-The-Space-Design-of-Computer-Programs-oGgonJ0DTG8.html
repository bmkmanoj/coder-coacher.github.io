<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Exploring The Space - Design of Computer Programs | Coder Coacher - Coaching Coders</title><meta content="Exploring The Space - Design of Computer Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Exploring The Space - Design of Computer Programs</b></h2><h5 class="post__date">2012-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oGgonJ0DTG8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now it's called search traditionally but
I think expiration is a better name for
it so we start out at home and in this
case our home is where we have two
glasses 0 and 0 are the values for how
full the glasses are and then we start
to explore and one way we could explore
is to fill one of the glasses and then
we're at this state say we're at zero
and four but we know that there are
other actions in which we could explore
in other directions and now we could
take one of the other states and explore
from there in other directions we have
lots of choices going forward of this
huge space that we're exploring now
somewhere out in this space and we don't
know which direction it is is this goal
state which has six and then actually
any amount in the other glass and we're
trying to reach that and we're
distinguishing this part of the state
space as a goal and so I drew this as
one but really it's a collection of
states in that every state that has six
on one side and anything on the other
should be considered part of this
collection of goals and we're trying to
search for words towards that and one
reason I'd like to call it an
exploration problem is because we can
think of going forward exploring a new
land and part of that exploration is
that we've got a frontier here's all the
states that are the farthest out that
we've gone and if we want to make
progress towards a goal then we're
probably going to have to step from one
of the frontier nodes farther out we
separated the set of all possible states
into the goal state the frontier states
and the previously explored states and
then you can see that the way to make
progress is to say let's take one of the
frontier states and expand that and we
have the advantage here of being a
computer that an individual Explorer
doesn't have an individual Explorer has
to take one path if they decide they
gone in the wrong direction they have to
go all the way back but a computer can
store lots of states in memory and so
the computer exploration is more like a
collection of Explorer
is all collectively expanding the
frontier and our next move can be to say
we'll take one of these explorers say
the one in this state here and say now
tell me what's next you've got six
actions from there where do they go to
and maybe some of them explore the world
and generate new states that we haven't
seen before maybe some of them go to a
state that we already know is on the
frontier and maybe some of them regress
backwards into previously explore
territory but we can keep on going
expanding out our frontier until
eventually the frontier keeps on
expanding and when it overlaps the goal
then we've got a solution now in
exploration problems like this there's
two problems that we have to worry about
one problem is that there's a no
solution at all that the goals are not
connected to the to the start state so
there's no path from here to there then
what we want to do is do the exploration
we need and report back that it's
impossible we want to find out that it's
impossible and then the other problem is
if there is some path that eventually
makes it to the goal we want to make
sure we find that in a reasonable amount
of time so that means we want to be
efficient about the way we explore the
space and it also means that we don't
want to get stuck in an infinite loop
now if there's a finite number of states
and they are connected then we should be
able to find the path but if we aren't
clever we may miss the solution even
though it's possible to find it and so
for example if we had a strategy that
says well first I'm going to explore in
this direction say this is pouring from
cutbacks into Cup y and then I go in
this direction pouring from Cup why back
into into Cup X and then I pour the
water back again and so I'm continually
just taking water and pouring it between
two different cups back and forth those
are all legal steps to take but I'm
ending up with an infinitely long path
and I'm not making any progress so we'd
like to come up with a strategy for
exploration and the strategy corresponds
to deciding which path to
band next so strategy as always there's
some paths let's say this one and we say
that's the one that we're going to
explore from next so to avoid this type
of infinite loop here's some
possibilities one possibility would be
don't reverse an action if you come from
state a to start to state B don't allow
the action that goes immediately back to
state a another strategy would be to say
always take the shortest path first so
out of all the paths that you've built
so far when we go to choose which one
are we going to expand next always
choose one of the shortest ones and that
way if we're start to build up an
infinitely long path but at least we
won't continue it first we'll do another
one before we do that one and then
another strategy would be don't reoccur
that is if we're on the frontier and
let's say we're here on the frontier and
we have a move that moves us back out of
the frontier into the previously
explored zone then we should not allow
that path and so my question is check
all the strategies that would eventually
lead us to the goal don't worry about
the efficiency of getting to the goal
but which one will eventually get us
there and won't get stuck in an infinite
loop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>