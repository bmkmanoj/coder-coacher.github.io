<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Low Can You Go - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="How Low Can You Go - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Low Can You Go - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t_yR7aA-2qI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we have only so far been able to touch
on the very basic concepts of designing
intelligent search trees and research to
date is much more advanced so you might
be wondering considering the state of
the art how low can you go what are the
best search tree algorithms to date that
we know of and actually I'm not going to
tell you anything about vertex cover for
now because that problem will deserve a
little more attention later in this unit
I will show you the state of the art for
some other problems so for independence
that there are currently two algorithms
that could kind of consider to be the
smallest search trees one has size one
point one eight nine to the power of n
and the other one has size 1.21 1 to the
power of n it's two different algorithms
this year has a bit larger search tree
but the algorithm itself is probably a
little bit faster in the worst case than
this one here because of the polynomial
factors that are involved but this year
is just the search tree size for click
well it's the same as independent set as
always because of the close
connectedness of those two problems and
one of the previous units you also got
to know three set which is a
satisfiability problem where every
clause has exactly three variables and
that can be solved with a search tree of
1.4 96 to the power of n last time I
checked this is a very advanced search
tree it's basically half a book of
proofs required to show this here now
what about shortest tour or more
generally the Traveling Salesman problem
which is shortest tour only that you can
only visit the city exactly once and
this is a very interesting one because
the best well it's not even really a
search tree but the best algorithm has
an exponential factor of 2 to the power
of n so here it's still an open research
problem to find out if you can design
better search algorithms for this
problem by the way in case you're
wondering do the laws of np-completeness
as far as we know them say anything
about how low the exponent can go so
really put a limit on the space here say
for example unless P equals NP there's
no algorithm for independent set with a
running time of or with a search tree
that is smaller than 1.1 to the power of
n or something like that and the answer
here is we don't know so it might be
that you can solve independent set for
example in the algorithm with 1.0 1 to
the power of n as you search for
sighs nothing in the laws of
np-completeness that would speak against
that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>