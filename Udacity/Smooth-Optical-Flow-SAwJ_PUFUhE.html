<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Smooth Optical Flow | Coder Coacher - Coaching Coders</title><meta content="Smooth Optical Flow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Smooth Optical Flow</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SAwJ_PUFUhE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so we have a problem the
brightness constraint equation gives us
more unknowns than equations more
directions to move than we have pixels
how are we going to recover the motion
obviously we need some extra constraints
we need some additional constraints so
we'll talk about sort of a global
approach now and the next time we'll
talk about a more local approach that
actually is used that in fact some of
you may even implement some time long
long ago in a galaxy near by Bertolt
horn and fried chunk did some work on
what was called smooth optical flows and
basically they said let's try to come up
with an optical flow that minimizes some
error okay so the first part of the
error is how much do we violate the
optic the brightness constancy
constraint equation right basically that
middle term right there that's supposed
to be zero right i xu plus I Y V plus I
sub T is equal to zero so violations of
that means that it's not zero
sometimes it's positive sometimes
negative I square it and I sum it up
over the whole image that would be how
bad my flow is with respect to the
constraint equation all right but we
know we can solve that exactly because
we have more unknowns than constraints
so if that's our only constraint we're
not done but we're gonna call this the
constraint error by the way I kept
partially originally I had stolen than I
did in my own I kept the integral signs
instead of summations because back when
this work was done we'd like to think
about images is actually continual
continual functions of course if you
were to implement this you'd actually
have to do summations I will also tell
you the fact that summations are not
integrals matters and if you take a look
at some of the work that was done in
shape from shading doing it as an
integral was actually hard doing it as
summations was in some sense a little
bit easier but for here the difference
doesn't matter so I just wrote it as
being summed up over the image so here
we have our optic flow constraint term
now we need another term well says
smooth optical flow here's the idea
remember when we did stereo the
state-of-the-art solution that I showed
you that the
beautiful recovery used a bunch of terms
some that had to do with the data but it
also had to do with the smoothness of
the disparity field that was the idea
that surfaces don't change a lot all
over the place but they tend to have a
particular depth or very smoothly the
same could be said of motion that is so
if I've got something moving around the
motion vectors from one point to the
next change slowly so let me come up
with a penalty term that says I really
don't like velocity fields where the
velocity changes quickly from one
location to the neighboring location so
that's shown here these u X u Y that's
the derivative of U remember U is the X
component of the motion field the
derivative in the X Direction squared
could be positive negative derivative in
the Y Direction squared same thing as
here which is V sub X V sub y the change
of V as you move in X the change in V as
you move Y again everything is squared
so the idea is we would like this thing
to be like zero or as little as possible
by the way what would it mean for this
to be zero well for this to be zero that
would mean that all the eu's were
constant right they were all the same
value so the derivatives would be zero
and all the V's would be constant so if
all my pixels were moving with the same
UV the whole image was moving the same
direction this value would be zero
any other use in V these will cause this
term to have some value and we want to
try to minimize this thing so now we
have these two terms we have the
constraint equation error term and we
have the smoothness error term called a
sub C e sub s and what we want to do is
we want to find the UV at every pixel
and this could be a different UV at
every pixel that minimizes this total
error which is just the smoothness term
plus some weighting factor times the
constraint term and the weighting factor
is sort of how much you believe your
data so the bigger the weighting factor
is the more important the
satisfying the brightness constancy
constraint is the smaller the weighting
factor the more the smoothness term
dominates and what value it should have
is a function of sort of how much noise
there is and how smooth you believe the
entire thing is so this was part of a
general approach variational approach
where you're gonna solve for UV as a
function of X Y that is you're gonna
find the optic flow U and V for every
pixel that tries to minimize this error
it's somewhat painful to try to
implement systems that can solve for
that not impossible but the idea is that
you have a global constraint the
smoothness constraint to help solve your
problem</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>