<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Barrier Synchronization - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Barrier Synchronization - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Barrier Synchronization - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fCFndi19yNs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the previous lesson we looked at
efficient implementation of mutual
exclusion lock algorithms in this lesson
we're going to look at barrier
synchronization how to implement that
efficiently in the operating system and
just to refresh your memory about the
barrier the barrier synchronization
works like this that you have a bunch of
processors and they all need to know
where they are with respect to each
other where they want to reach a barrier
and they want to wait here until
everybody has arrived at this barrier so
if t1 arrives at the barrier is going to
wait until everybody else has come so
one of the guys maybe a straggler is
going to come a little later and in that
case everybody has to wait until all the
threads that are part of this
application have arrived at the barrier
then they can move on and and I
mentioned to you that this kind of
synchronization is very popular in
scientific applications and they go
through these phases where the execute
code for a while
reach a barrier and then execute code
for a while each another barrier
executes for code for a while reach
another barrier and so on and so forth
and and I mentioned also that real life
this happens quite often when you go to
a dinner with with a bunch of our
friends and some of us show up early and
others come late
the usher is going to hold us all
handsome wait till everyone is here
until until then I cannot teach you so
that same sort of thing that's happening
with a barrier that all of the threads
have to arrive at the barrier only then
they can proceed on so that's the
semantics of the barrier synchronization
and I'm going to describe to you a very
simple implementation of this barrier
the first algorithm I'm going to
describe to you is what is called a
centralized barrier or also sometimes
called a counting barrier so it's
centralized barrier counting barrier
that's a name that that's given to this
the idea is very very simple you have a
counter that's why it's called a
counting barrier you have a counter and
the counter is initialized to n where n
is the number of threads that need to
synchronize at the bet here and what is
going to happen is that when a thread
arrives of the barrier it's going to
atomically decrement the count
key thing is has to be done atomically
so once it is atomically decremented the
count then it's going to wait for the
count to become zero so long as the
count is not zero it's going to wait so
if the count is zero we're going to do
something else but if the count is not
zero that means that I've arrived at the
barrier but I don't know where the
others are yet so I'm going to wait so
that they're going to spin and the spin
is basically saying while count is
greater than zero spin and all the
processors except the last one are going
to be doing this spinning on count
becoming zero now the last processor the
straggler maybe the t2 is scranton
straggler and the straggler arrives
eventually and when he arrives then what
he's going to do is he's going to
decrement also and many decrements the
count he'll see that the count has
become zero and so what he will do is
he'll reset the count back up to N and
that is indication that everybody so so
all of these guys are waiting on count
being greater than zero so as soon as
the count becomes zero then they can
they can be released on the barrier and
and the last processor to arrive is
going to reset the count to n to
indicate that when these guys go off and
before they get come to the next barrier
the count has to be n so that's the idea
behind that so very simple algorithm
decrement the count atomically when you
come to the barrier the count is greater
than zero then you know that everybody
has not arrived spin and everybody
except the last guy will do the spin and
the last guy that comes around
decrements the counter for n and the
counter becomes zero and once the
counter becomes zero all the guys that
are stuck here they're going to be
released and then the last processes
will reset this count to N so that you
know all these guys are now on the way
to the next barrier so it is resetting
it to N so that the barrier can be
executed again when all these guys get
to the next barrier that's the idea
behind the centralized barrier</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>