<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficiency of Merge Sort | Coder Coacher - Coaching Coders</title><meta content="Efficiency of Merge Sort - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficiency of Merge Sort</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HKiK5Y-YSkk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so how many overall comparisons was that
well let's try to find a pattern here it
looks like at each step we did one less
comparison than the array we were
building so when we were building an
array of seven we only did six
comparisons when we were building an
array of three we did two comparisons an
array of two one comparison and an array
of four we did three comparisons I'm
going to go ahead and call the lengths
of each array M just to make it a little
easier for me so if M is the size of the
array that we're building the number of
comparisons is always going to be one
less than that it's going to be hard to
get an exact number of comparisons here
however we have a good friend that we
can count on approximation since we know
that every iteration just cycles through
the same seven elements again and again
we know that the size of our arrays or m
are always going to add up to seven at
the end so again here we have an array
of seven here we have an array of four
and an array of three which adds up to
seven and here one two two and two adds
up to seven since we're just doing
divide-and-conquer splitting up the
array at each step we can say that
approximately we're going to do seven
comparisons at each step again seven is
an upper bound we're never going to do
more than seven comparisons but at many
steps we get close to seven so to get
the runtime of a sorting algorithm you
can normally multiply the number of
overall iterations by the number of
comparisons at each iteration in bubble
sort we were doing n comparisons and n
steps we just proved that we're doing at
most n comparisons at every step but how
many steps overall are we doing okay so
to sort an array of seven we had to do
three steps one two and three also I
should note some of the sub processes
that happened here in order to sort this
array of two we only had to do one step
when we were sorting an array of three
or
for we needed to do two stuffs we can
use an ice table to keep track of all of
that again so when our array size was
seven we had to do three different steps
when our array was three or four of
numbers large we had to do two steps
when our array was too large we had to
do one step and if we just had one
element we don't need to do any
comparisons so no steps I'm gonna go
ahead and fill in a few numbers here
just for the sake of time you can assume
that I did these calculations on my own
and I encourage you to do them as well
okay so this might look a little bit
familiar to you remember in binary
search when we had a similar table and
the number of iterations incremented at
every power of two well we actually have
something pretty similar here instead of
incrementing at the powers of two this
time we're incrementing one after every
power of two so in the binary search
video I proved why the number of
iterations would be equal to log n so if
you need a refresher you can go back
there
again this time is a little different
because it increments after the power of
two instead of at the power of two yet
again we're kind of relying on
approximation here we don't exactly care
where the change happens as long as we
capture the interval at which the change
is happening
so in summary we're doing roughly n
comparisons for log n steps that makes
an overall complexity of n log n this is
definitely better than the N squared we
got in bubble sort in bubble sort we had
n times n or n squared as our efficiency
log n is generally going to be less than
n but it's definitely never going to be
greater than n so we can say that the
efficiency of merge sort is better than
the efficiency of bubble sort however
the space efficiency of merge sort is
actually worse than bubble sort in
bubble sort we were sorting in place so
we didn't need to use any extra arrays
here we frequently copied our values
into new arrays you can say that the
or the extra space we used was linear
this complexity assumes that we got rid
of arrays after we were done using them
at each step we were copying values into
new arrays so we needed new arrays at
some point however we could say that we
were getting rid of the old ones
whenever we were done so we're not using
a ton of new arrays every time we really
only need two different arrays at every
step the array that our numbers were in
and the new array that were copying the
values into</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>