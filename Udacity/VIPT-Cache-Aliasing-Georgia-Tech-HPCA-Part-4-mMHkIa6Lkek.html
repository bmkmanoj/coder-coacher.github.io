<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>VIPT Cache Aliasing - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="VIPT Cache Aliasing - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>VIPT Cache Aliasing - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mMHkIa6Lkek" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's look at the problem of aliasing
in the virtual index physically tagged
caches this is our virtual address and
the way we access the cache is these are
the offices bits this would be our index
bits and this would be the tag if we use
this to access the cache in a virtually
indexed cache we use the index part of
the address from the virtual address the
rest comes from the physical address but
how do we form the physical address well
some lower bits of the virtual address
will be the page offset the rest will be
the page number and now remember that
the page number gets translated to
become the frame number in the physical
address while the page offset just goes
and becomes the least significant bits
of the physical address and in a
virtually indexed physically tagged
cache our tag comes from here but our
index came from here so that we could
begin the acces quickly the thing to
note is that the index bits are
relatively close to the least
significant bit of the virtual address
and that the page offset has a number of
bits so for a small cache it can happen
that the index bits that we use will
come from the page offset which means
they're the same as if we took them from
the physical address so although we are
indexing using the virtual address in
reality we are actually using the same
index that we would be using if we were
using the physical address which means
there would be no aliasing how is there
no aliasing well because the virtual
pages that have different page numbers
that map to the same frame number can
only differ in the page number but they
have to have the same offset for the
same data and because only the offset
matters for the index if the index is
low enough here what happens is pretty
much all of the data that can possibly
be in the same place in the physical
memory has to be in the same set because
the index is determined only from the
part that has to be the same so we have
that there is no aliasing if all of the
index bits that we use came from the
page offset because really those are the
same index bits that will come from the
physical address if we had the face
index cache we like this very much but
the cache has to be small enough to do
this so for example if we have a four
kilobyte page we would have a 12 bit
page offset if our cache has a 32 byte
block it has a 5 bit block offset here
that means that the index which still
needs to fit in the 12 bits of the page
offset can only have 7 bits so we can
only have a hundred 28 sets in this
cache which limits its size if we have
more sets than this then some of the
index bits here come from the page
number and that changes when we have the
frame number so it can easily be that
the different these bits here end up
mapping to the same frame number which
we don't want because that means that
multiple sets in the cache could have
the same actual data which is bad
because we cannot find it then</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>