<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Merrills Linear-Complexity BFS on GPUs Part2 - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Merrills Linear-Complexity BFS on GPUs Part2 - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Merrills Linear-Complexity BFS on GPUs Part2 - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MAEnPtS8ZnA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">way back in unit 1 when we talked about
step and work complexity we said that we
would love to find algorithms that have
the same work complexity as the serial
algorithm but have a smaller step
complexity reduced would be a good
example here or scan but if we said we
can't do that sometimes we would be
willing to accept more work if it gets
us fewer steps and that's what we're
gonna do here but how this is not
intuitive or at least it isn't for most
people and it certainly wasn't for me
when I learn this material hillis and
steele first expressed skepticism they
could improve on quadratic work but then
concluded i'm quoting from their paper
essentially we overlook the power of
having many processors working on the
problem at once so what a high level
here's what we're going to do on every
node we start by knowing the node that's
one hop away that's the next pointer in
blue so on the next iteration we can
visit our next pointers next pointer and
get 2 hops away and then on the next
iteration we can get to 3 hops away and
so on so that's what I'm showing here
when I say straightforward approach as
we increase the number of iterations
we're also increasing the number of hops
away but that's the wrong way to think
about it
if we just did it that way we'd be
repeating a lot of work that the nodes
down the chain are doing and we would
have quadratic complexity work instead
after the first iteration we have each
node knowing the node that is two hops
away so let's say we're interested in
this node and we know that we're
pointing to node X here well normally
what we do is we take the red pointer
here and then ink change our red pointer
to be red pointer plus blue pointer so
we'd be moving from knowing the node two
hops away to the node knowing three hops
away but look X also knows the node that
is two hops away so I know the node
that's 2 hops away X knows the node
that's 2 hops away so on the second
iteration we can leverage the work that
X already did on its first iteration to
get a pointer that is now four hops away
so we can go red then red to set our new
red pointer here to be the Chum of the
chubb now we're gonna have a pointer to
an though that's four hops away which
also has a pointer to a node that's four
away and so the next iteration will have
a pointer that's eight hops away and so
on so now instead of going one two three
four we're now going one two four eight
so for in iterations as a function of n
how many steps is this going to take</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>