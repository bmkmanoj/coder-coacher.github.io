<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Circular Motion Solution - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Circular Motion Solution - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Circular Motion Solution - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tP3FKUG1xxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here's a function move is a class
function of the class robot they
implement where I get my motion vector
and the motion vector is defined to be
steering first then distance I have a
few our checks here to make sure that
the steering angle doesn't exceed the
max steering angle the same is true for
distance I wanted to be non-negative and
as I go down I now implement the motion
modeling so let's just look a little bit
more I make a new robot copy as in my
same recording class I copy all the
generic parameters length bearing noise
chewing noise and distance noise nothing
surprising here here I'll apply the
noise which you don't need it for the
first implementation but later on as we
go on
you needed to actually add noise so I'm
just add Gaussian noise with the
corresponding steering noise and
distance noise parameters if I set the
mean of the Gaussian to be the steering
command and the distance command then
this adds noise I could have equally
written steering + random gauss's zero
comma and then the noise parameter as I
go down further here's my execution of
motion my turning angle
I called turn this is the tangents of
the noisy steering times the distance
moved divided by the robot length and as
in my explanation of this question I'm
gonna branch and see if my turn is
significant enough it's smaller than
tolerance and tolerance was set above to
0.001 then I'll just model a straight
motion I get my new robot coordinates by
the old world coordinates moving in the
orientation of the robot cosine 4x sinus
for Y and I increase my orientation by
turn which is likely essentially zero in
a case I go beyond zero or two pi I drew
the modulo operation here just to make
sure my angles are nicely between 0 and
2pi the more interesting case as we go
down in this program you can see that I
now calculate the radius as distance the
noisy distance divided by turning then I
find the center of the circle around
which I'm turning using the exact same
math I just gave you
I now first change the orientation to be
the new orientation by adding turn to
the old orientation modulo 2 pi and then
I plug the new orientation into the sine
and cosine argument x radios add to the
center of the circle to get my result
so this routine over here gives me
exactly what I wanted</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>