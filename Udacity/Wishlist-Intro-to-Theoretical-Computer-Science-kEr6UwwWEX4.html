<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Wishlist - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Wishlist - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Wishlist - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kEr6UwwWEX4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so in the last quiz you have seen that
it's not very likely that we can find a
randomized algorithm for an np-complete
problem that in polynomial time will
deliver us the right answer with a fixed
probability to be honest we currently
don't know if such an algorithm is
possible or impossible but many believe
that it is highly unlikely and so far no
such algorithm has been discovered it
seems that we can sometimes however if
we either cross this one here of our
list or cross this one here of our list
and you'll soon see that actually it
doesn't really matter what we cross off
our list but if we if we kind of reduce
the number of wishes that we have it
seems that sometimes we can use
randomness to at least improve the
running time of exponential time
algorithms so just as you've seen when
we optimize search trees it's sometimes
also possible to improve the running
time of exponential time algorithms or
the base of the exponent using
randomness now the question of course is
could we use randomness to help Alice
solve vertex cover or how Bob solve this
clique problem or Carol her independent
set problem or Davis for the store
problem at least when we say that we do
not have this requirement here and the
answer unfortunately is we don't know we
don't know if there are good randomized
algorithms to solve vertex cover or
click or independent set or shortest or
at least not if we're demanding
guarantees so of course there are
randomized algorithms that will look
through a random number of solutions and
these are also used in practice but
again they do not offer any guarantees
there's one problem however that is MP
complete where I can give you a
randomized algorithm that at least is
better than the best-known deterministic
algorithm and that problem is three set
as I hope you will remember the three
set problem had as an input a boolean
formula with n variables and the boolean
formula has a special property because
it's three sad namely that each clause
has exactly three variables and the
output I'm looking for is of course an
answer to the question if this boolean
formula with n variables where each
clause has exactly three variables has a
satisfying assignment so how can you use
randomness to solve this problem well
there's a very simple and in my mind
very elegant algorithm
that in 1999 was proposed by
overshooting to solve a three-set
instance with n variables so this is the
algorithm and as you can see it's really
quite simple so you start out by picking
a random 01 assignment for the variables
and then you go into a loop that
iterates 3n times where endless number
of variables and what you do each time
in the loop you take one of the clauses
that is not satisfied and then you
randomly flip one of the variables of
that clause so what does this random a
flipping mean you start out with a
clause and we already know that this
clause will have only three variables
because we're dealing with reset now you
randomly pick one of those variables say
we randomly pick the second one and then
you just flip its value meaning if it
was assigned to true you now assign it
to false or vice versa if it was
assigned to false you now set it to true
and since it's a random process we don't
know which variable we're going to pick
so instead of this one here we might
also have picked this one here and of
course this one here and what happens is
by those flipping you satisfy this
clause but of course other clauses might
then become unsatisfied now if we run
this algorithm here once what are the
chances that it will succeed and find a
satisfying assignment provided that the
initial boolean formula does indeed have
a satisfying assignment if it doesn't
have a satisfying assignment the
algorithm can't find it but let's assume
that it has one then the success of this
algorithm will depend on two things the
first one is how far the initial
assignment is off the satisfying
assignment or in other words picking
this random 01 assignment to the
variables how many of those variables
that we get right and by right I mean
that we set them to the same value that
they would have in a satisfying
assignment and the second one is of
course are these random choices that we
make here by flipping the variables
successful so if we are somewhere near a
satisfying assignment and by chance the
algorithm makes the right choices then
we would find a satisfying assignment
provided of course but we made that
assumption that the boolean formula here
actually has a satisfying assignment but
let's look at those two success factors
a little more closely</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>