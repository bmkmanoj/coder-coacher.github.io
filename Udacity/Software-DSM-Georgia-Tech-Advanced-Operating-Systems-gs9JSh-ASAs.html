<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Software DSM - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Software DSM - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Software DSM - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gs9JSh-ASAs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so far we have seen three different
memory consistency models one is a
sequential consistent memory model the
release consistent memory model and
strictly speaking I would say the eager
version and the lazy version are just
variants of the same memory model namely
the release consistent memory model and
now we're going to transition and talk
about software distributed shared memory
and how these memory models come into
play in building software distributed
shared memory so we are dealing with a
computational cluster that is in the
cluster each node of the cluster has its
own private physical memory but there is
no physically shared memory and
therefore the system meaning the system
software has to implement the
consistency model to the programmer in a
tightly coupled multiprocessor coherence
was maintained at individual memory
access level by the hardware
unfortunately that fine grain of
maintaining coherence at individual
memory access level will lead to too
much overhead in a cluster why because
on every load or store instruction that
is happening on any one of these
processors the system software has to
butt in and implement the coherence
action in software through the entire
cluster and this is simply infeasible so
what do we do to implement software
distributed shared memory so first
thought is to implement this sharing and
coherence maintenance at the level of
pages so the granularity of coherence
maintenance is at the level of a page
now even in a simple processor or in a
true multiprocessor the unit of
coherence maintenance is not simply a
single word that a processor is doing a
load or a store on because in order to
exploit spatial locality the block size
used in cashes in processors tend to be
bigger than the granularity of memory
access that is possible from individual
instructions in the processor so we are
taking this
upper level and saying if we're going to
do it all in software let's keep the
granularity of coherence maintenance to
be an entire page and we're going to
maintain the coherence of the
distributed shared memory in software by
cooperating with the operating system
that is running on every node of the
processor so what we're going to do is
we are providing a global virtual memory
abstraction to the application
programmer running on the cluster so the
application programmer views the entire
cluster as a globally shared virtual
memory under the cover what the DSM
software is doing is it is partitioning
the global address space into chunks
that are managed individually on the
nodes of the different processes of the
cluster from the application point of
view what this global virtual memory
abstraction is giving is address
equivalence and that is if I access a
memory location X in my program that
means exactly the same thing whether I
access the memory location X from
processor 1 a processor 2 and so on and
so forth that's the idea in providing a
global virtual memory abstraction and
the way the DSM software is going to
handle maintenance of coherence is by
having distributed ownership for the
different virtual pages that constitute
this global virtual address space so you
can think of this global virtual address
space as constituted by several pages
and we're going to say some number of
these pages are owned by processor one
some number of these pages are owned by
processor to some number the process of
three and so on so we split the
ownership responsibility into individual
processes now what that means is that
the owner of a particular page is also
responsible for keeping complete
coherence information for that
particular page and taking the coherence
actions commensurate with that page and
the local physical memories available in
each one of these processors is being
used for
Hosting portions of the global virtual
memory space in the individual processes
commensurate with the access pattern
that is being displayed by the
application on the different processes
so for instance if processor one
accesses this portion of the global
virtual memory space then this portion
of the address space is mapped into the
local physical memory of this processor
so that the thread that is running on
this processor can access this portion
of the global address space and it might
be that same page is being shared with
some of the processor and over here in
that case a copy of this page is
existing in both this processor as well
as this processor now it is up to the
processor that is responsible for the
ownership of this particular page to
worry about the consistency of this page
that is now resident in multiple
locations for instance if this node
let's say is the owner for this page
then this node will have metadata that
indicates that this particular page is
currently shared by both p 1 and p n so
that is the directory that is associated
with the portion of the global virtual
memory space that is being owned and
managed by this particular processes so
statically we're making an association
between a portion of the address space
and the owner for that portion of the
address space in terms of coherence
maintenance for that portion of the
global virtual memory space</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>