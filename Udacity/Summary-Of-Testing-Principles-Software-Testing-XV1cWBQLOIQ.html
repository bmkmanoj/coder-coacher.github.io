<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Summary Of Testing Principles - Software Testing | Coder Coacher - Coaching Coders</title><meta content="Summary Of Testing Principles - Software Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Summary Of Testing Principles - Software Testing</b></h2><h5 class="post__date">2012-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XV1cWBQLOIQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right we've come nearly to the end
of our course what I'd like to do now is
summarize what I think are the high
points that is the most important
testing principles that I've tried to
convey in this course and put them all
in one place so let's go through these
first of all justice must want software
to fail second justice like detectives
who are hunting down bugs and as
detectives testers to have to be
observant to all sorts of suspicious
behaviors and anomalies in the software
under test my guess is the number of
really serious bugs that have occurred
over the years are things that had
already been noticed by people and swept
under the rug because the people were
busy they just wanted to ship the
product or maybe they were users who
didn't know what the bugs meant so
regular users have the luxury of
ignoring bugs but testers don't and so
it's really important not to sweep
things under the rug all available tests
or goals should be used as a basis for
testing so you might be tempted to think
from the language that I was using that
is strong work girls versus weak ones
that if we had a couple of good strong
Oracle's available maybe we wouldn't
need them weak grunts maybe we just
wouldn't use them at all
and as I hope I've convinced you by now
that's not the case at all all of the
Oracles should be used because it can
all generally detect different kinds of
faults and even if they detect the same
faults weak Oracle's might be much
cheaper to use test cases should contain
values selected from the entire input
domain and if there's doubt about what
exactly that domain is this is something
it would be good to hash out with the
developers interfaces that crossed a
trust boundary need to be tested with
all representable values not just those
from the extensible input domain so if
we recall some of the examples we've
looked at if we're writing a web server
we might hope that everybody submits
data that's well formatted but it's most
likely the case that they won't and the
reason they won't is they'll be trying
to break into our web server and so we
need to test on that kind of data to
ensure that we can correctly reject it
similarly a piece of software like the
Linux kernel has a trust boundary at the
system call interface that is to say at
the interface between user mode
applications and the Linux kernel Linux
kernel like the web server can't trust
that its clients are gonna make
well-formed requests all the time it
should expect that its clients if not
actually hostile are at least buggy I'm
gonna do all sorts of crazy stuff and it
needs to catch that instead of crashing
or violating its security policy a
little brute force there's a long ways
when we're testing and what I mean in
particular is in certain restricted
circumstances who can do exhaustive
testing and almost anything else can be
randomly tested quality cannot be tested
into bad software we saw the therac-25
example where the control software for
the radiation therapy machine was
probably so broken that almost almost no
amount of testing would have been
sufficient to make it right it needed
be thrown away and they needed to start
over I'm sure we've all seen software
that looked like that so in contrast
with examples like a therac-25 testable
software has a few of the following
qualities no hidden coupling between
modules and side channels where modules
can share information without being
visible to the system developers few
variables that are shared between
threads few global variables shared
between modules and no pointer soup and
that is to say no huge data structures
with pointers going everywhere we can't
possibly keep track of who's changing
what and what's valid and what's not
code should be self checking whenever
possible using the plenty of assertions
however these assertions are never used
for error-checking rather they used to
check for logically impossible
conditions that imply some sort of an
internal consistency violation surgeons
must never be side effecting because if
they are and you turn them off the
system behavior will change and this
leads to madness among developers
finally these assertions should never be
silly or trivial ones because first of
all those serve no purpose
second the clutter up code third if they
make things slower when finally they
fail to communicate useful information
to the next person who looks at the code
when appropriate all three sources of
input to a piece of software under test
should be used as a basis for testing
and those include the obvious API is
provided by the software under test
which can be tested directly API is used
by the software under test can be tested
using fault injection techniques so
recall that these are things like
substituting the library that provides
these api's with a different library
that injects faults or perhaps just
hacking the layer underneath to inject
faults finally on functional inputs such
as thread schedules need to be tested
using whatever method you can get the
will work to actually test these things
and finally the last principle for
testing is the failed code coverage do
not provide a mandate to cover the
failed items no matter how tempting that
might be but rather they give clues to
ways in which the test suite is
inadequate so blindly coding to the
coverage metric is going to destroy
those clues but it's going to do it in
such a way that doesn't improve the
quality of the tests we very much so
taken together the system items that
I've just given you constitutes pretty
much all that I know about testing and
the detailed version of these has been
the content of this course this is
material that I haven't ever taught
before so I hope it came out in sort of
a fairly coherent fashion it's stuff
that's been brewing in my mind for a
long time I've wanted to teach it
because I've noticed for years that we
don't seem to be doing a very good job
teaching steais students to test what
happens instead is they write small test
cases in response to assignments they
bugged them till they passed the test
cases we give them hand the man and
never look at them again and it's hard
to think of anything less like the real
world of software development than the
environment we create in classes what
I've tried to do is structure this
course a little bit differently try to
bring out things that I feel are really
important that we often don't do a very
good job with and this has been really
enjoyable for me it's been great to
actually try to set this material down
in a coherent fashion and I very much
hope that this material has been useful
for you and that the class has been
enjoyable thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>