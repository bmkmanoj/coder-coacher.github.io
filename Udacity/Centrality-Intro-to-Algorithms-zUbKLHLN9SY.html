<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Centrality - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Centrality - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Centrality - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zUbKLHLN9SY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's take a look at one more
path type algorithm that's a simple
variation of what we were just looking
at I'd like you to do is modify the path
finding algorithm that we've been
playing with to find the average of the
shortest path distance to each reachable
node so that will give for some node V 1
that we that we give to the program
it'll give us a measure of the
centrality of v1 okay here's the code
that we left off with let's make some
modifications of this to compute the
centrality measure program path g v1 v2
was returning the distance between v1
and v2 in the graph or false if the two
notes were disconnected we don't really
need that anymore what we really need is
the centrality concept and that really
is done with respect to a single
starting node V and we're going to do
basically the same search as before
we're just not going to terminate when
we hit an ending node because there
isn't an indie node so we start off
distance from the start state v as being
zero we once again we go to our open
list pull the first element off that's
the current node that we're working on
pop it off the list we look at the
neighbors of that node if the if this
neighbor is a new neighbor then we make
a note of its distance which is distance
from the start to the node where we just
were plus 1 to get the distance to the
neighbor and then we put it on the open
list we're going to take out this line
where we stop the the search and what
are we going to return at the end of all
this well once this loop is finished
once the open list is exhausted we
visited all the nodes that were
reachable and put their distances from
the start state into this data structure
distance from start so now what we
really need to do is average all these
values and distance from start there's a
lot of different ways that you can do
this but Python gives you at least one
way that's very succinct so I'm going to
use that you could also do this by
setting up your own loop but what I did
in this case is i take the the all the
values in the distance from start data
structure get them returned as a big
long list sum up all the elements of
that list add 02 it 0.0 to make sure
that it's a floating point number and
then divide by the number of nodes for
which we got a distance
these are all the reachable notes so
ultimately this is going to return the
average of the distances over all the
reachable nodes which is what we're
looking for let's make one little change
here and we should be good to go</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>