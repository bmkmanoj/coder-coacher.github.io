<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Typical Parallel Program - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Typical Parallel Program - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Typical Parallel Program - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yegWAZ3xuNg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's see what happens in a typical
parallel program in a typical parallel
program that you might write you
probably get a lock and you have
mentally an association between that
lock and the data structures that are
governed by the lock or in other words
in writing your parallel program you
decided that access to variables a and B
are governed by this flock so if I
wanted to read or write variables a and
B I'll get a lock and then I will mess
with the variables that are governed by
this lock once i'm done with whatever I
want to do with these shared variables
I'll unlock indicating that I'm done and
this is my critical section so within
the critical section I'm allowed to do
whatever I want on these data structures
that are governed by this particular
lock because that is an association I as
the programmer has made in writing my
parallel program so if another processor
let's say p 2 gets the same lock it's
going to get the lock only after I
release it so only after they release a
lock this guy can get this law because
the semantics of Allah it is a mutually
exclusive lock and therefore only one
person can have the lock at a time and
consequently if you look at the
structure of this critical section for
p2 it gets a lock and it is messing with
the same set of data structures that I
was messing with over here but by design
we know that either p1 or p2 can be
messing with this data structure at any
point of time and that's the guarantee
that I know comes from the fact that i
designed the parallel program and the
lock is associated with these data
structures so in other words p 2 is not
going to access any of the data that
that is inside this critical section
until p1 releases the lock we know this
because we design the program but the SC
memory model does not know about the
association between these data
structures and this lock and in
particular it doesn't even know that
memory accesses emanating from the
processor due to this lock primitive is
different animal compared to the memory
accesses coming from the processor as a
result of accessing normal data
structures so the cache coherence
mechanism that is provided by the system
for implementing the memory consistency
model is going to be doing more work
than it needs to do because it's going
to be taking actions on every one of
these accesses even though the coherence
actions are not warranted for these guys
until I release the lock so what that
means is that there's going to be more
overhead for maintaining the coherence
commensurate with the SC memory model
which means it's going to lead to a
poder scalability of the shared memory
system so in this particular example
since p2 is not going to access any of
these data structures until p1 has
released a lock there is no need for
coherence action for a and B until the
lock is actually released</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>