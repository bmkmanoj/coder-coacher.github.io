<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memory Access Time With V-P Translation - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="Memory Access Time With V-P Translation - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memory Access Time With V-P Translation - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ryvo5uY1DQ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now that we have seen how paging and
virtual to physical translation works
let's talk about the memory access time
when we have this translation sir
program does something like this it says
load r1 from the address computed by
adding 4 to what is in our tool this
when computed will be the virtual
address that we want to access in the
program so to do a load or a store the
processor has to compute the virtual
address this is quick usually just
addition of two numbers that are already
in the processor one is a constant
fetched with the instruction the other
one is the register that is inside the
processor next the processor has to
compute the page number which is
extremely quick because it just means
that we take some bits from the virtual
address and without any address
translation the next thing that the
processor will do is access the cache
and sometimes if there is a cache miss
the actual memory so again these two are
extremely quick most of the time will be
spent accessing the cache and
occasionally we will spend more cycles
because we need to access the memory
with virtual to physical translation
after computing the page number the
processor has to compute the physical
address of the page table entry where
the translation for the page number is
this is done by adding the page number
that we computed to the beginning
address of the page table then we read
the actual page table entry and compute
the physical address by combining the
physical frame number from the page
table entry with the page offset from
the virtual address so how fast is this
well this is fast because it just means
adding the page number to some sort of
address this is fast because it only
means combining two numbers that we
already have but how fast is this and
for that we need to ask ourselves so
where is the page table is it inside the
processor so it can be quickly accessed
or is it in memory we have seen that the
page table can be fairly large yes for a
multi-level page table we can have it be
less than a megabyte for some programs
but in theory it can be extremely large
so we cannot guarantee that the page
table for even one process fits on the
processor chip which means that the page
tables really need to be in memory and
that means that for each load or store
we now need to have a memory axis which
is just as slow as when we have a cache
miss that we were trying to avoid before
we go to page tables things that even
worse because for a multi-level page
table for example a four level page
table we would need to do this multiple
times for example four times compute the
physical address of the outermost page
table read that entry compute the
physical address of the next page table
go ahead and do that four times so we
need four memory accesses to read the
four page table entries until we get the
actual translation after which we can
quickly access the cache so somehow we
have a situation where the virtual to
physical address translation is costing
us more than the memory accesses that we
try to avoid by having the caches</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>