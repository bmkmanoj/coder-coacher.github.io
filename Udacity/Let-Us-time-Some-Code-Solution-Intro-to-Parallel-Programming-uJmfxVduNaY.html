<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let Us time Some Code - Solution - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Let Us time Some Code - Solution - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Let Us time Some Code - Solution - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uJmfxVduNaY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so taking these one at a time a million
threads incrementing a million elements
does give the correct answer because in
this case there's a unique element for
every thread so there's no conflict so
even though we didn't make these atomic
increments we're still safe a million
threads atomically incrementing a
million elements is of course also safe
so you'll also get the correct answer a
million threads incrementing a hundred
elements is the same example we saw
before and as we saw that will give the
wrong answer unless we use Atomics so
the next one is not correct the fourth
one is correct and finally ten million
threads atomically incrementing a
hundred elements will still be the
correct answer so all the one of these
give you the correct answer okay so the
more interesting question is how long
beach of these options take the fastest
perhaps counter-intuitively is going to
be option three a million threads
writing into 100 elements and the next
fastest will be option one a million
threads writing into a million elements
on my laptop these two operations take
around 3.2 milliseconds and 3.4
milliseconds respectively of course it's
not a very useful option since it
doesn't give the correct answer but it's
still interesting to look at what's
going on so the reason why this is
slightly faster is that you have your
million threads all trying to write to
the same 100 elements well those 100
elements occupy very small fraction of
memory and they're all going to fit into
a cache line or two on this system
whereas a million elements is large
enough that it's not going to fit in
cache you're actually going to have to
touch more of the DRAM where global
memory is stored for the same reason a
million threads writing into 100
elements atomically is going to be
slightly faster than a million threads
writing into a million elements so the
next fastest is option for the next
fastest after that is option two and in
my system again these took three point
six and three point eight milliseconds
which means that the slowest of all
options is the one where 10 million
threads write into 100 elements this is
actually 36 millisecond so it takes
approximately ten times as long to
complete not surprisingly there's about
10 times as much going on so you might
play around with this code for a little
bit for example see what happens to the
time as you go to even more threads
writing into even fewer elements the big
lesson here is that is that atomic
memory operations come with a cost</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>