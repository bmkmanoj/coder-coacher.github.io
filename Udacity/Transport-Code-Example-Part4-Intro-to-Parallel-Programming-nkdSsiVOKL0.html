<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Transport Code Example Part4 - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Transport Code Example Part4 - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Transport Code Example Part4 - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nkdSsiVOKL0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay here's my solution to that I
started by adding a constant in K equals
16 like we talked about so now if you
think about this we're going to have
thread blocks each of which is
responsible for a tile in the matrix
let's draw that we'll be processing this
matrix and blocks called tiles each tile
corresponding to a single thread block
here's the new kernel I wrote very
similar to the previous one the
difference is that now I need to compute
I need to compute the inj values not
just the eye value and that computation
involves using the block index as well
as the thread index so the block index
times K times plus thread index plus X
dot X gives me my eye value similarly I
get my J value from the Y and so now the
threads in my grid have a overall index
X and y as well as an index within their
block which is the thread index so I'm
going to compute that x and Y and that's
going to correspond to the I and J of
the output matrix and that's the
calculation that's going on here and
finally I do the same the same final
calculation that I've done all along I
go and grab an element from the input
matrix equal to the coordinates IJ and I
write that into the output matrix the
location in the output matrix
corresponding to element J I and here's
how I'm going to call it now I need to
define the number of blocks in the
number of threads which is simply n over
K and over K I'm being a little lazy
here you can tell I'm assuming that n is
a multiple of K there's K by K threads
in the block and now when I launch it
instead of launching a single thread I
launch blocks threads and over K by n
over K and instead of launching 1024
elements are in elements I'm gonna
launch K by K elements per block let's
go ahead and compile and run this okay
now we're talking so now we're down to
about 0.67 milliseconds let's make a
note and thinking about what we've done
here is we've we've now extracted the
maximum amount of parallelism from the
application right we started with a
single serial code one thread doing all
the work we switched to a code that used
one thread per row of the input matrix
and now we're down to something that
uses one thread for
there's really no more parallelism that
we can extract here and you can see that
increasing the parallelism has really
helped us</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>