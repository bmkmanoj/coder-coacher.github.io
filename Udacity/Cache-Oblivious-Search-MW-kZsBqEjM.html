<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Oblivious Search | Coder Coacher - Coaching Coders</title><meta content="Cache Oblivious Search - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Oblivious Search</b></h2><h5 class="post__date">2015-07-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MW-kZsBqEjM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's think about the binary search
algorithm you're given a sorted array a
containing let's say n unique elements
then given a target value V you want to
find the largest index I such that a sub
I is at most V you can find this index
by binary search to compute the number
of cache misses you would set up a
recurrence like so once the search
interval falls within a cache line there
would be just one cache miss otherwise
you pay for one miss plus any additional
misses to search the remaining half of
the array solving the recurrence you'd
find the following Big O of log and over
L compare this to the lower bound binary
search differs from the lower bound by
about a factor of log L so it's not
optimal but one nice thing about binary
search is that it's already cache
oblivious
it makes no references to the cache size
E or the line size L but it begs the
question how do we get to the lower
bound in fact there's a way to do it
leave the logic of the binary search
algorithm intact but change the data
layout remember that a binary search
tree maintains some ordering of its
elements let's number this tree
according to an inorder traversal if you
interpret these numbers as addresses or
index positions then the layout of the
tree nodes is equivalent to sorted order
but there's nothing sacred about this
layout in fact let's consider a
different ordering which is called the
venom DuBose layout I'll sketch this now
but if you want some details see the
nice tutorial by Erik Demaine the idea
is to use the following recursive layout
suppose you start with a complete binary
search tree if it has about and nodes it
should have log n levels now divide the
levels in half so there would be about
one half log n levels above the cut line
and about one half log n below this also
means the upper sub tree will have about
root n nodes below the cut line there
will be about root n sub trees each of
size root n here's the van m DuBose
layout idea you have a binary search
tree that you'd like to layout linearly
in slow memory after partitioning the
levels layout all of the upper sub tree
elements together and then concatenate
them with the lower sub tree elements
and when I say layout the elements
together
I mean recursively apply the
Bo's layout to each subtree so what is
this by you let's zoom in on the tree
looking at the point where the sub trees
fit within cache lines that is in the
figure the elements in each of the
smallest sub trees shown fit within a
cache line size he'll a binary search in
this tree takes some path from the root
to the leaf
since the sub trees are of size L you
only generate a cache miss when you hit
the root of one of the sub trees now the
maximum height of one of these little
cache line size sub trees is log L so
starting at the root of the tree how
many of these size L sub trees will you
visit well the height of the tree is log
in so on any path from root to leaf
you'll encounter log n over log L sub
trees that's totally awesome because
that is optimal whoot the important
lesson is that data layout matters what
we did here that was so cool is we took
the standard binary search algorithm
reshuffled how we store the data in
order to get an i/o optimal algorithm
and the layout is itself cache oblivious</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>