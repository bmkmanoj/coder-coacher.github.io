<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Loop Unrolling Benefits CPI Part 2 - Georgia Tech - HPCA: Part 3 | Coder Coacher - Coaching Coders</title><meta content="Loop Unrolling Benefits CPI Part 2 - Georgia Tech - HPCA: Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Loop Unrolling Benefits CPI Part 2 - Georgia Tech - HPCA: Part 3</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LTmE21VmzIk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so going back here with our for issue in
order processor with perfect
transmission we have seen that a loop
get the CPI of three over five which is
0.6 without scheduling and it gets a CP
of 2 over 5 which is 0.4 if we do
scheduling on the original loop now
let's see what happens when we unroll
the loop once and try to execute it on
this processor this is the code we
constructed and now what happens in this
loop is we do the load the ad has to
wait for that result the store has to
wait for that this load is going to a
different memory element so it can
proceed in parallel with the store the
ad however has to wait for that load and
then this store has to wait for that ad
and then this decrement of the pointer
can proceed in parallel with the store
but the branch has to wait for our one
however then the load can proceed and
now we are back to where we started so
overall it takes us five cycles to do
these eight instructions which gives us
a CP of 0.62 slightly lower than the
original unscheduled loop but not much
lower so these are very similar in CPI
we still gain significantly from
eliminating some instructions so overall
this loop is going to perform better but
the CPI has not improved but let's see
what scheduling does after enrolling in
the scheduled loop we will have our load
for the first iteration of the two that
we are really doing and now if we put
the ad here it would again have a
dependence so the load and whatever we
already did here would be the only thing
that can be done in this cycle so
instead of doing the ad next we will
look for what else can we do here that
doesn't depend on this load and it turns
out that this load here the load for the
second iteration can be done in parallel
with this load however we cannot store
the value into our two so we will have
to use another register let's say our
ten for that so these two now can
execute in the same cycle and if you
remember so could the branch now that we
have done this we can do the ad for the
first iteration
the loop and also the one for the second
iteration of the loop in the same cycle
and in the same cycle we can do the add
instruction for moving the pointer now
these two will produce the results that
the stores need so next cycle we can do
the stores note however that this is the
store that was supposed to store with
offset 0 from r1 but here we have now
decremented r1 by 8 so now we need to
store to 8 from r1 that's because this
store needs to match the dress of this
load but the r1 has moved in between and
then for the other store we're storing
our 10 now to the address that used to
be minus 4 from r1 but r1 has already
moved by minus 8 so now we need to store
2 4 from r1 to match the address of this
this is basically minus 4 and then we
did minus 8 so now we need to add 4 to
that in order to get minus 4 and now we
can do our branch so now let's see what
can we get on our processor in the first
cycle we will be doing these two loads
that can now proceed in parallel the add
here however cannot proceed in that same
cycle because it needs the result of
this load however this add and the next
one and this one can proceed in the
second cycle then the stores here have
to wait the results of the add so they
cannot proceed in the same cycle however
they can be done in the next cycle and
so can the branch because the r1 has
been produced and so can the load
because r1 has been produced and
unfortunately in this cycle we cannot do
this load because we already executed
four things so unfortunately that load
is done in the next cycle after which we
get the same schedule as here the three
ads and so on so overall it took us now
three cycles to do eight instructions
which gives us a CP of 0.38 slightly
better than the scheduled CPI for the
loop that we didn't unroll so what
really happened is unrolling gives us
more stuff that we can reorder here so
that we can find more things that don't
have dependencies and thus
for example we were able to do these two
loads that were not available prior to
unrolling if we unroll this loop three
times then we will have four loads here
that can all proceed in the same cycle
we will have four ads here that can
proceed in the same cycle four stores
that can proceed in the same cycle and
then the add a and branch equals so the
more we unroll the more parallelism we
can get simply because there is no more
instructions among which we can try to
find independent ones keep in mind that
unrolling already reduced the number of
instructions and with scheduling it
allows us to also reduce the CPI so it
kind of creates a double whammy for
performance improvement our execution
time gets reduced both because we have
fewer instructions eight instructions
per two iterations as opposed to five
instructions originally for one
iteration and also after scheduling it
gives us usually a better CPI</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>