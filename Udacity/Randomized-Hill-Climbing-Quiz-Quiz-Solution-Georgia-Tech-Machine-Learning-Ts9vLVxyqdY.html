<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Randomized Hill Climbing Quiz Quiz Solution - Georgia Tech - Machine Learning | Coder Coacher - Coaching Coders</title><meta content="Randomized Hill Climbing Quiz Quiz Solution - Georgia Tech - Machine Learning - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Randomized Hill Climbing Quiz Quiz Solution - Georgia Tech - Machine Learning</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ts9vLVxyqdY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so there's a there's a bunch
of ways you could imagine doing this and
here's here's how I would suggest
looking at it so for each of these 28
positions there's some number of steps
that it's going to take before it either
resets that is to say you know we choose
at random or has actually reached the
tippy-top so let's let's actually
evaluate these so if you if you happen
to start at one how many steps is it
before you realize that you that you're
at one you have to evaluate one you have
to evaluate two you have to evaluate
three and you have to evaluate for to
see that you're a local optimum so
there's going to be four evaluations if
you start at one start at two then it's
gonna be one you're gonna have to value
one two three and four again if you
start at three then you only need to
evaluate two three and four to know that
you're at a local optimum mm-hmm if you
start at four then you have to evaluate
four and then if you randomly step in
this direction you're also gonna need to
evaluate two two and three all right so
then I finished writing down what all
these different numbers are for each in
each position here I wrote down in red
how many steps it's gonna take before it
hits a local optimum including the ones
here around the actual peak and I wrote
two numbers for the places that were
these cusps where it can go either way
so now we can actually work out what the
expected number of steps to the global
optimum is it turns out for 22 out of 28
of these points the average 5.39
before they discover there they're
actually at a local optimum at which
point we have to start the whole process
over again and so whatever the expected
value of reaching the local optimum is
we have to wait we occur that same cost
again that make sense good okay so for 4
out of 28 these guys here then they're
gonna take 4 steps on average and end up
at the peak then the only other things
that left to figure out or what happens
at these two weird cusps we're just to
flip it's gonna flip a coin and either
get stuck at a local optimum that's not
global or go to the global optimum so in
2 out of 56 of these cases it's going to
have chosen to go to the local optimum
the non global local optimum and it just
so turned
that it's 10 in both of those cases it's
10 steps before you realize you're stuck
again
at which point it's going to start the
whole process over again because it's
stuck
then in 156 of the cases we're gonna be
here and choose to go to the right and
take 6 steps to get to the global and
here 156 of the cases we're gonna take
five steps and get to the global ok so
just to be clear so the way you got 28
is that there were 28 numbers and you
uniformly chose where to start where you
got 56 is you decided that for two of
those numbers 15 and 20 you end up
getting them 128 at the time and then
half the time you do the local optima
and half the time you end up doing the
global Optima and it just turns out that
in the case in the cases where you end
up going through the local optima both
happen to take 10 steps and that's how
you got 2 out of 56 and the last thing
to notice is that for point number 4
where you could go to the left or to the
right since you do each half the time
it's like saying the number of steps
there is just 11 over 2 on average yeah
very good yeah so that was folded into
this 5.39 number you're right thanks for
pointing that out ok sure so this all
makes sense and obviously if you just
add those all up you can solve for V and
the answer is exactly so just
algebraically simplifying this equation
gives us V equals 5 point 3 6 plus point
8 2 V solving for V gets us twenty nine
point seven eight so it only takes
twenty nine point seven eight function
evaluations before we first hit the
maximum tada Michael yes sir so that
seems unfortunate because here's a
really simple algorithm for I equals or
hey let's say X for x equals 1 to 28
compute f of X if it's bigger than my
previous one then hold on to it and then
just return whatever is the biggest
number I see so that's linear and that's
28 evaluations which is less than twenty
nine point seven eight yeah that's good
algorithm in this case but I guess your
point is that
this this whole idea of hill climbing
and using this this local information is
actually costing us a little bit
compared to just enumerated all the
possible inputs and just testing them
all right which I guess makes sense
because the numbers are really small and
then you have a whole bunch of local
optima and so it's gonna take you a long
time to look into the right one but it
seems kind of sad that there's nothing
clever you can do here to do better than
28 just kind of what you want to do well
there's a couple clever things we could
do right so one is we could random
restart faster it turns out maginot so
here's a question what happens if you
randomly restart after each function
evaluation how many function evaluations
do we have to do on average before we
reach the maximum I don't know oh well I
guess it would be less than 28 it would
be exactly 28 good 20 it's less than 28
so that's that's fair it's less than or
equal to it sure yeah and even better
what happens if we actually keep track
of points that we visited in the past
then we don't pay the cost for
re-evaluating them that's right so then
the only question is how long does it
take us to lock up in the getting
between 15 and 20 yes well once we yeah
once we fall into that zone then we're
gonna be done shortly afterwards so how
much of how much of a win is that on
average that's a good question it's a
little bit hard to tell because what's
gonna happen is if we follow this
algorithm with the additional thing
additional attribute that says if you
already know the function evaluation
from some previous iteration we just
reuse it we don't get we don't pay the
cost for that then what's gonna happen
is we're gonna get dropped off in random
places in this space we're gonna help
climb visiting some things along the way
and possibly get dropped someplace where
we've already done the function
evaluation right and therefore don't
have to pay that cost again but it's not
as simple as just saying how many
different hops do we take before we land
in this Basin because if we land and say
this Basin here the second one from the
left if we you know get dropped on to
point 14 it's going to stay in that zone
for a while which is actually kind of
bad because it's taking lots of function
evaluations in that same part of the
space
but look but what you just said is
important right since we're only we're
only gonna pay the cost of doing a
function evaluation once that means in
the worst case we would end up hitting
the three bad basins before we hit the
fourth basin and in fact we would end up
hitting the three bad basins enough
times that we would end up visiting all
of the points in them so we land in
point 14 which will get us all the way
over to the peak and just to the left
and then we would land in five point
five which would get us to the right so
we cover everything in the basin so the
worst case is we cover every single
point in all three of those basins
before we get lucky enough to land in
the good basin great and then but the
moment we land in the good basin we will
get two am i right we will get to avoid
at least one of those numbers no not
necessarily so for example if we start
at fifteen and we randomly moved to the
right to know that we're at the optimum
here we have to check at the point 19 so
we've actually touched everything no we
didn't touch 20 well we we might have
already unluckily hit 20 and because
it's part of the right-hand basin as
well
that's why anyway the point is that
you're right if we keep track of which
points we've already visited then we
can't do worse than 28 like even if
we're really really unlucky we can't do
worse the 28th right maybe maybe on
average it'll be a little bit better
than that
but but only one or two but it'll still
be better I think I think in this case
it's it's just a contrived example with
lots of local optima and a just a linear
space so that there's a the the
attraction basins end up being
relatively small compared to the size of
the space hmm okay that makes sense so
what should I learn from this so I guess
what I learned is randomized
optimization a randomized hill climbing
here may not do better than evaluating
all the space in the worst case but it
won't do any worse and every once in a
while you will get lucky and do much
better at least if your cost is function
evaluations as opposed to steps that's
right yeah and also while I am the thing
that I was hoping that you'd notice is
this idea that randomized hill climbing
depends a lot on the size of the
attraction base
around the global optimum so if we make
that really big then this is a huge win
if we make it really small then it's
less of a win
no and that means a lot right so if the
third one had gone all the way from say
number three to number 26 then you would
fall into it immediately and you would
just you'd get there very quickly right
okay yeah I see that that makes that
makes more sense so so when you asked me
before what the advantages are the
advantages are you know you're in a
place where the attraction Basin for
your global Optima are in fact
relatively big if you can once you look
into that part of the space and there's
lots of ways to look into that part of
the space you can get there very quickly
so it's a big one agreed okay good okay
that makes sense to me I like that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>