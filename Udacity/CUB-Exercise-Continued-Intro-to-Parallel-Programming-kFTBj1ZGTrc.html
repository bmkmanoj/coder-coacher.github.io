<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CUB Exercise Continued - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="CUB Exercise Continued - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CUB Exercise Continued - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kFTBj1ZGTrc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's have a programming exercise
with the cub library here's a simple
example of the cub blocks can primitive
okay and this is doing a prefix um in a
single block and you've seen scan a lot
by now you know a lot of the intricacies
of how it can be implemented and so
here's an example of how easy this is to
implement with high performance in the
IDE and there's a couple different
things about this from some of the
examples you've seen again we're
focusing on a single block because the
whole point of cub is to give you intra
block primitives code for writing your
own thread block level code within CUDA
kernels so we're just going to time a
single block and we're going to measure
something we haven't quite seen before
we're actually going to measure the scan
throughput and we're measuring that in
clocks per element scan these are SM
clocks how many actual clock cycles the
SM took averaged across the total number
of elements that were scanned by this
single thread block you'll see the CUDA
built-in clock in this kernel and the
way it's used is obvious and what I want
you to do is fill out this matrix this
is a performance matrix where we have
the number of threads per block which is
represented in the code with block
threads and the number of items
processed per thread which is
represented in the code with items per
thread and I want you to go ahead and
look at the matrix here and experiment
with different values of block threads
and items per thread and try to figure
out how these two items affect the scan
throughput it would be too much work to
fill out this whole matrix so let me
just guide you to a few sweet spots so
much of the interesting action is going
to happen along this diagonal so for
example 1024 threads each representing a
single item each each in charge of a
scanning a single item per thread is the
kind of thing you might code up
naturally but it might be the first
thing you try it's the simplest to code
up and then try to analyze what happens
when you do 512 by 2 threads 256 by 4
threads 128 by 8 threads and then let's
go ahead and complete the diagonal won't
take long at all all the way down to 32
by 32 threads each responsible for 32
items and 16 threads each responsible
for 64 items and so what I'm going to
have you do is fill up this diagonal and
from the choices along this
agonal check off the option that gives
you the best performance in other words
the highest scan throughput which
corresponds to the fewest clocks per
element scanned</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>