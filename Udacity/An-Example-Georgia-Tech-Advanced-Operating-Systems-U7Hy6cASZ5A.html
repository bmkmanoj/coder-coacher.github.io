<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>An Example - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="An Example - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>An Example - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U7Hy6cASZ5A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's understand how the RC memory
model works with a concrete example so
let's say the program is intent is that
one thread of his program is going to
modify a structure a and there is
another thread that is going to wait for
the modification and then it is going to
use the structure so this is a program
is intent right so p2 is going to wait
for the modification use it and this guy
is the guy that is modifying that
particular structure e and of course
these are running on different
processors and therefore we don't know
who may be getting to their code first
so let's say that P to execute the code
that corresponds to this semantics that
is it wants to wait for the modification
so in order to do that it has a flag and
this flag has a semantic that is 0
indicating the modification is not done
and one when the modification is
actually done and to make sure that we
don't do busy waiting we use a mutual
exclusion lock wheelock a
synchronization variable let's call it L
and if the flag is 0 then it is going to
execute the equivalent of a peach Fred
can't wait you know pthread cond weight
has the semantics that you're waiting on
a condition variable and you're also
releasing the lock that is associated
with this condition variable so you
execute this feature wait call and the
semantics you know is that at this point
threat p 2 is blocked here the lock is
released and he's basically waiting for
a signal on this condition variable see
who is going to do that well of course p
1 is the guy that is modifying the
structure so it's a responsibility of p1
the signal him so let's see what happens
so p1 is executing the code for
modifying the data structure a and once
it is done with all the modification
then it is going to inform p2 so in
order to inform p2 what it does is it
acquires this lock l and it sets this
flag to one and the flag is the one that
I inspected over here to know that oh
the
modification is not yet done here and
I'm waiting on this condition variable
so p1 sets the flag to one and signals
on the condition variable C and you know
that signaling on the condition variable
is going to wake up p 2 and of course it
cannot start executing here until p1 is
released a lock and once the lock has
been released that lock will be acquired
implicitly by the operating system on
behalf of p2 because that is the
semantics of this condition wait here so
when I wake up I'll go back and as a
defensive mechanism I'll recheck the
flag to ensure that the flag is now not
0 indicating that the modification has
been done so I am now ready to get out
of this critical section i unlock L come
out of the critical section now I can
use this modified data structure so
that's the semantics that I wanted and I
got that with this code fragment that
I'm showing you here so the important
thing is if you have an RC memory model
then all the modifications that I'm
making here that is modifying shared
data structures can go on in parallel
with all this waiting that may be going
on here I don't have to block the
processor to do every one of these
modifications the only point at which I
have to make sure that these
modifications have been made globally
visible is when I hit the unlock point
in my code so just before i unlock l i
have to make sure that all the read
write accesses to shared variables that
i made here in my program have all been
taken care of in terms of the coherence
actions being communicated to all my
peers only then i have to unlock it so
in other words this code fragment is
giving you pictorially the opportunity
for exploiting computation in parallel
with communication if the model was an
sc memory model then for every read
write accesses that are being done in
modifying this data structure a there
would have been coherence actions that
would have gone on
and those coherence actions each of them
has to complete before you can do the
next one and so on but with the RC
memory model what it is allowing you to
do is you can do the data structure
modification you want and the coherence
actions inherent in those modifications
may be going on in the background but
you can continue with your computation
until you hit this unlock point at this
point the memory model will ensure that
all the coherence actions are complete
before releasing the lock because once
the lock is released this guy is going
to get it and immediately will start
using the data structure that has been
modified by me so it is important that
all the coherence actions be complete
prior to unlocking so that's the intent
of the RC memory model and that's how
you can exploit computation going on in
parallel with communication if the
memory model is an RC memory model</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>