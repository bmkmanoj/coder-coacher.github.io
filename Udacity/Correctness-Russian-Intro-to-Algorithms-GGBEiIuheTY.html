<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Correctness: Russian - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Correctness: Russian - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Correctness: Russian - Intro to Algorithms</b></h2><h5 class="post__date">2012-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GGBEiIuheTY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">why does this work so we're gonna do
another proof of correctness and it
turns out that the same strategy that we
used for naive is going to work out
really well here in particular what
holds is that the product of a and B is
always equal to the product of x and y
plus Z and again since X is going to be
counting down and eventually reach zero
Z is going to ultimately have to hold
the product of a and B can we prove that
this is the case again we need to do two
things we need to say that it starts off
with that being the case and that's the
same exact argument that we had in the
naive algorithm because X starts out as
a Y starts out as B and Z starts at a
zero so that holds and now we need to
show it if this condition holds at the
beginning at the top of a while loop
then it's going to hold at the end with
the new values of x y&amp;amp;z so let's remind
ourselves how x y&amp;amp;z change in the while
loop so we can see whether the condition
still holds and we're gonna have to
break this into two cases first if X is
odd and second if X is even because two
slightly different things happen so in
the case when X is odd the first thing
we do is add Z and Y together make that
the new value of Z then we do a bit
shift on X which in this case is
equivalent to subtracting one to make it
even and smaller than having it and Y
meanwhile gets doubled so what can we
say about X prime times y prime plus Z
prime so that is at the bottom of the
loop so we can substitute in these
values get X minus 1 over 2 times the
new value of y which is 2y plus the new
value of Z which is Z plus y and we
notice that this 2 and that 2 cancel and
we get X Y minus y plus Z plus y and
again the plus y and the minus y cancel
and we do indeed get XY minus z which we
had assumed holds in advance so that's a
times B what about the case where X is
even so in some ways this case is easier
because the bit shift on X just halves
it Z doesn't change at all and why again
is doubled let's look to see what
happens in this case so what happens now
is the value of Z doesn't change at all
and in some sense x and y just move a 2
around so X gets half then y's get
doubled when we multiply those two
together they cancel and again we get X
y plus Z which we had assumed coming
into this is equal to a times B so then
new values of x y&amp;amp;z in either the case
where X is odd or X is even continued to
satisfy this property so this is kind of
strange what it's doing here is we're
moving a factor of 2 back and forth
between x and y actually generally from
x to y and whenever it's odd and we have
to shift X a little bit more than that
to make it balanced we move some of the
value into Z this is kind of wacky</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>