<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>1 Bit History With 2 Bit Count - Georgia Tech - HPCA: Part 1 | Coder Coacher - Coaching Coders</title><meta content="1 Bit History With 2 Bit Count - Georgia Tech - HPCA: Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>1 Bit History With 2 Bit Count - Georgia Tech - HPCA: Part 1</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zhyEYt2uylQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's look at the example history
base predictor that has a 1-bit history
with two bit counters for each history
so the general approach to this branch
picture stays the same we take some bits
of the PC we index into the branch
history table but instead of having a
one bit counter or a two bit counter in
each entry now we have a single bit
history in each entry a two bit counter
for when the history is 0 and the
separate two bit counter when the
history is 1 so the state of the
predictor is now not just a state of a
single one bit or two bit counter it's a
state of a single bit history and two of
these counters so now let's look at the
behavior of predictors over time like
this we have the predictor state the
prediction the outcome and whether the
prediction was correct let's start a
predictor in a state with the history
bit is zero and the two two bit
predictor are both in the strong not
taken state so again all three of these
together are now the state of the
predictor the prediction in this type of
predictor is formed by using the history
bit to tell us which of the two
predictor to use because the history is
zero we will be using the first of the
two counters it sang strong not taken so
the prediction will be not taken let's
say that this is a branch where the
outcome is taken not taken taken not
taken etc and in this case the
prediction and the outcome differ so we
have an incorrect prediction now we will
update the state depending on the
outcome the way we update the predictor
is to use the history to index into the
two counters meaning we will be using
this counter and modify that counter
according to the outcome in this case
the outcome is taken so the first of the
two counters will be moved to the weak
not taken state from the strong one
so this counter becomes weak not taken
this counter is not affected and then we
shift into the history the actual
outcome which was taken so the history
becomes one when the histories
we're gonna be using the second of the
two counters so pretty much we use a
history to kind of index into this array
of counters that only has two counters
so when it's one we use this one the
prediction will be not taken and we will
be right the state of the predictor is
now updated so that we use the history
to index again into the counter modify
that counter according to the outcome it
stays strong not taken because that's
already as convinced about the
note-taking outcome as it can be the
other counter just stays the same and
the history now shifts in the zero
because of the note-taking outcome so
now we have the state of zero weak not
taken strong not taken to predict the
next outcome our prediction now will
index into the array of counters get the
first one weak not taken means that we
still predict not-taken we are wrong we
update the predictor by finding the
counter that corresponds to the history
in this case zero means we use this one
we updated using the outcome from weak
not taken we go to weak taken the other
counter stays the same the history
shifts in the one four taken and this is
the new state that we used to predict
the next outcome one means we use this
counter that counter says strong not
taken so we predict not-taken we are
correct update the predictor one means
we have the discounter with not taken so
it stays strong not taken this one stays
weak not taken because it's not affected
by this not taken is shifted into the
history so it becomes zero and now we
use this to predict the next outcome
zero means we use this counter this
contest is weak taken so we predict
taken and we predict correctly we update
the predictor by using zero to tell us
which counter to update taken is used to
update the counter so from weak they can
it become strong taken the other counter
stays the same the history shifts in a 1
so we get this one means we use this
counter next it says not taken we
predict not taken and we are right
update the state of the predictor 1
means we update this one we'd not taken
it stays strongly not-taken this one
stays the same
history shifts in a zero so it becomes
zero we use zero to tell us which
counter this one it's strong taken so we
predict taken and we will be right and
as you can see from now on we get
perfect reduction in this product why
well because if the previous outcome was
zero we are now guessing that the next
outcome will be taken if the previous
outcome was one then we are predicting
that the next outcome will be not taken
and now we do this continuously because
both of these counters have learned
strong decisions because every time we
have seen a zero it was followed by
taken every time we have seen a one it
was followed by not taking so this
predictor just learned the pattern of
taken not taken taken not taken etcetera</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>