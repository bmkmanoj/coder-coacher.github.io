<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Faster Algorithm | Coder Coacher - Coaching Coders</title><meta content="A Faster Algorithm - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Faster Algorithm</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/J7S3CHFBZJA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's talk about a smarter approach our
first goal doesn't need to be maximize
the value for the largest weight
possible what if we tried to maximize
the value for the smallest weights
possible then kept adding them together
until we had our maximum weight let's
look at an example we start by creating
an array which we'll use to store the
maximum possible value for every weight
up into our weight limit we assume that
the weights are all positive integers so
the indices in the array represent those
weights we initialize everything to zero
for now these are objects that we're
trying to fit in a knapsack with a
weight limit of six we take out the
object with a weight of two we can
update the value at index two to the
value of the object then we'll update
everything after it as well with the
same value even if our knapsack can hold
six we've only seen one object so far so
we need to base that best value off one
object we look at the next object again
we can't change anything until index
five the value of this object is bigger
than the max and it takes up the whole
weight so we replace the max value for
weights five and six for the last object
the first thing we could possibly change
is index for this value is less than
that one so we leave it alone
we look at index five and compare it to
our value plus the value at index one
since the old value is larger we leave
it as is at index six we add our object
value to the value at index two and end
up with a bigger value so we replace it
and we've solved the problem this may
seem unnecessary with an example this
small but imagine how much time will
save with lots of objects here we're
taking advantage of the table to store
pre computed maximum values so we only
need to do the work once to get those
numbers we go through every object and
check if it can increase the maximum
value of every possible way up to our
maximum weight
thus the runtime is n times W where W is
the weight limit of our knapsack and n
is the number of elements this is a
pseudo polynomial time solution a true
polynomial runtime wouldn't have a
variable besides n I reiterate
polynomial time algorithms are much
faster than exponential time algorithms
for big numbers so the solution here is
generally faster</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>