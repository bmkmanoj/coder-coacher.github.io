<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Squaring Numbers Using CUDA 4 - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Squaring Numbers Using CUDA 4 - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Squaring Numbers Using CUDA 4 - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ByrK61fNVW0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's look at the kernel itself
recall that this will look like a serial
program that will run on one thread and
the CPU is responsible for launching
that program on many parallel threads
this kernel indeed looks exactly like a
serial program so here's our kernel
right here this global void square and
so here's the interesting things about
this short kernel program so first
global this is underscore underscore
global underscore underscore that's a C
language construct called a quote
declaration specifier in quote or for
short deckle spec don't worry about the
name just know that this is the way that
CUDA knows this code is a kernel as
opposed to CPU code next we have void
void just means the kernel doesn't
return a value instead it writes the
output into the pointer specified in its
argument list this kernel takes two
arguments these are pointers to the
output and the input arrays recall that
both these pointers need to be allocated
on the GPU or else your program will
crash spectacularly now note that I
named them with D underscore out and D
underscore n that's certainly not
foolproof but if I called it D
underscore and I'm consistent about the
way I allocate my variables I know that
D underscore variables are allocated on
the GPU let's walk through the body of
the kernel so the first line of the body
here remember how I said that each
thread knows its own index here's how we
get that index cuda has a built-in
variable called thread index thread ID x
and that's going to tell each thread its
index within a block thread it x is
actually a c struct with three members x
y&amp;amp;z the C struct is called a dim three
we're just using dot X in this code but
we'll explain the others a little bit
later
now we'll launch 64 threads so for the
first instance of those threads threated
xx will return 0 for the second instance
1 and so on up to 63 for the last
element everything else in this kernel
just looks like straight forward C it
looks just like a serial program so what
are we actually doing in this kernel
well for each thread we're going to
first read the array element
corresponding to this thread index from
global memory we're going to store it in
this variable F we're then
going to square F and we're going to
write that value back to global memory
in the output array element that
corresponds to our thread index</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>