<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learner With Mistake Bounds - Georgia Tech - Machine Learning | Coder Coacher - Coaching Coders</title><meta content="Learner With Mistake Bounds - Georgia Tech - Machine Learning - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learner With Mistake Bounds - Georgia Tech - Machine Learning</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BtybigAc5kw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so maybe maybe this will make you feel
better Charles so there's we can
actually you know when all else fails
change the problem so let's say that
instead of trying to learn the way we
were describing it before we're gonna
change the rules we're gonna say we're
gonna use a learning formalism that's
sometimes referred to as mistake bounds
so here's how the things work in mistake
bounds
the the learners sitting around and
input arrives and then the learner gets
to guess an answer for that input so the
learner that may be the learner chose
the input or maybe it came from a a
helpful teacher or maybe a malicious
teacher it turns out it's not gonna
matter but the inputs gonna show up the
learners gonna guess the answer so it
doesn't have to now guess the hypothesis
and get that right it just has to get
the the output correct for this input if
the learner is wrong then we're gonna
charge at a point and tell it that it
was wrong and then it goes up to one and
we repeat this and so this is gonna run
forever and what we're gonna do is bound
the total number of mistakes made into
infinity right so that we're gonna keep
playing this game forever and we want to
say it'll never make a total total
number mistakes will never be larger
than a certain amount ah so this is
giving the learner some new powers right
so the learner now is guessing answers
and all we have to guarantee is that if
it guesses wrong it better learn a heck
of a lot from that hmm otherwise if it
even if it doesn't know much if it
guesses right that's fine don't have to
learn okay I see so so in the case
before so long as I had been guessing
false I would have been okay even if I
didn't know what the hypothesis was and
then the moment I got a 1 I got a true I
could actually learn something then I
should learn something and try to do
better guesses from that point on okay
outstanding yes exactly so so let's
let's turn that into an algorithm so
here's an algorithm that's really simple
and actually can learn very effectively
for these kinds of mistakes bound
problems so it works like this it starts
off in this weird state where it
imagines that in the formula every
variable is present and in both its
positive and negated form right which is
kind of weird and so what that would
mean is the formula is X 1 and not X 1 X
2 and not X 2 X 3 and not X 3 X 4 it and
not X 4 X 5 and not X 5 so any input
that
gets it's always gonna produce the same
answer right what is that answer false
false right so it's gonna keep saying
false for a long time until at some
point it actually could be right
it's each time it's right it's actually
not getting charged any mistakes for
that it's just that at some point it's
going to get an input that the correct
answer is true
it's gonna say false and it's gonna have
made a mistake so let's say that this
here's here's that example x1 is true x3
and x4 are true and the other two are
false and the learner said false but the
answer was actually true so if the
answer to this one is true what do we
know we know that 1 0 where we know that
0 1 0 0 1 which is the opposite of what
you're saying could not be a part of the
formula so we can remove that from our
formula ah ok that's one way to think of
it wouldn't quite think of it that way
but am i right yeah if this is what you
meant
so the first very acute the x1 naught
cannot be in the formula cuz if it was
there's no way that this would have been
able to produce true right so we can
erase x1 naught we can erase x2 in the
positive form because of the second bit
we can the third bit says that x3 if
it's in there can't be negated we don't
know if it's in there but we know it
can't be negated x4 is the same and x5
if it's in there why did you give it to
the positive yeah that's what I meant
that's why I wrote down the opposite of
everything that was up there yeah and
that is what we're left with ok it's not
exactly what the algorithm says but it
produced the right answer in this case
all right so now now what is it going to
do now it's going to continue to say no
unless it sees this particular bit
pattern right that's the only thing that
will ever predict true on and it'll
always be right when it does that
because we know that that is the correct
answer for that but let's so it's gonna
guess no everywhere else and so let's
say gets something wrong again let's say
it gets one zero one one one wrong so in
this particular case it's going to guess
no and we said oh I'm sorry the answer
is yes all right so now what is
now from that well I'm just reading your
algorithm now and I'm just going to do
what number three says all right that's
a good idea
it says if we're wrong which we are in
this case set all the positive variables
that were zero to absent all the
positive values that were zero there are
none of those and said all the negative
variables that were one to absent all
right so then that was X 5 X 5 is there
in it's negated form but it's actually 1
in the input so we're going to turn that
away to absent all right mm-hmm so and
that's the same thing that you did when
we were looking at the problem before
you said if you have two answers where
the answer to inputs where the output is
both true any bits that are different in
those two patterns must be not part of
the formula right all right so now we've
definitely the X 5 is not in the formula
and that's actually correct there's no
point in the future will we ever have to
revisit that in these other cases we're
not quite so sure it could be that
they're in there or not in there and so
each time that we get went wrong we're
going to move something from negated to
absent and when we do that that thing is
always going to be correct so at most we
can move K things from the gated or
positive to absent Oh so if I think
about it Oh so even if we may have to
see in fact every even if we may see an
exponential number of examples we will
never make more than k plus 1 mistakes
perfect and so that's exactly what I
wanted to do before right so if I'm a
teacher if I were a good teacher in this
case then I could basically and I knew
that you started out assuming that
everything was false that you know all
variables were there in both their
positive and negative form I could just
give you one example that is true and
that would let you eliminate half of the
formula right away and then I could just
keep giving you examples that are true
but only with one variable difference
each time and then eventually you would
learn it so then the total number of
samples you would need would also be K
plus 1 if I know how you're starting out
as a learner does that make sense if we
charge things by mistakes no but even if
we don't charge things by mistake if I'm
a teacher who's trying to give you the
best examples and I know that as the
learner you're starting out with a
formula that is x1 and
x1 x2 and not x2 like you said before
then I could just give you the first
example that is true that allow you
eliminate half of those literals and
then only give you true examples from
that point on where I only change one of
the variables that are left and you'll
know that you can make them absent to
get rid of it and so just as you can
only make k plus 1 mistakes
I could give you exactly the right k
plus 1 examples if I know how you're
starting out as a learner if I don't
know that then I have to do the k plus 2
that you showed before</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>