<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fault Tolerance Techniques - Georgia Tech - HPCA: Part 5 | Coder Coacher - Coaching Coders</title><meta content="Fault Tolerance Techniques - Georgia Tech - HPCA: Part 5 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fault Tolerance Techniques - Georgia Tech - HPCA: Part 5</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ORrM6FrZpzc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the fault tolerance techniques that
are used often are check pointing where
we can save the state of the system
periodically then we detect errors and
restore the state of the system once we
detect an error this type of technique
works really well for many transient and
also intermittent faults so the idea
here is that we will save the state of
the system when the system is
functioning normally if a fault occurs
we will try to detect errors that result
from that and restore the system into a
state that was not affected by default
so if the fault is transient it will not
happen again and our system goes back to
functioning normally if the fault is
intermittent then this might happen a
few times until we reach the time when
the fault is no longer going to be
activated and then again we will
function normally so the system
continues to function normally if we can
quickly recover from each of the faults
so that it doesn't affect the overall
availability and reliability of the
system if checkpointing takes too long
then this type of recovery has to be
treated as service interruption but if
checkpointing and detection and
restoring of the state are very very
fast it may be that the promised service
is never disrupted so for example if the
system is supposed to answer all the web
queries within let's say one second if
we manage to do all of this in such a
way that we still respond to all of the
things that we got in one second then
there has been no service interruption
we can use two-way redundancy where two
modules do the same work then we compare
their results and we roll back if the
results are different so this is really
an error detection technique and it
needs a recovery techniques such as
checkpointing similarly checkpointing is
a recovery technique it needs something
like two-way redundancy to actually
detect errors and while these techniques
recover and detect things separately we
can also have something like 3-way
redundancy which can both detect and
recover some faults and in this case
three modules
or more will do the same work and then
vote for what the correct result should
be so if one module is malfunctioning
then the two others will still produce
the same result and that result will be
elected by the vote as the overall
correct result so the fault in one
module becomes an error in that module
but doesn't become an error at the
system level because at the output of
these three modules and their voter we
always have an error-free result this
technique is expensive you pretty much
need three times the hardware plus the
voter that you would have without some
fault tolerance techniques but in return
it can tolerate any fault that can occur
in any one of the modules so as long as
the fault that you have is affecting
only one module we can tolerate that
fault even for example if that one
module is purposely designed to be
malicious because the correct two are
still gonna out vote it and we never
really see what ever that module is
trying to produce in our overall results
but what happens if two modules fail in
that case we no longer can tolerate that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>