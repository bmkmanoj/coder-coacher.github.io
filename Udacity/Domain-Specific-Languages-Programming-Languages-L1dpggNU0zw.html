<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Domain Specific Languages - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Domain Specific Languages - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Domain Specific Languages - Programming Languages</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L1dpggNU0zw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">why do you believe the future of
programming language design lies in
domain-specific languages when we can
just do operator overloading and api's
in a general language like C well that's
a tough question then actually there's a
bit of philosophy or opinion here in
class we keep brushing against Turing
completeness and it turns out that
languages like C++ or C sharp or Java or
MATLAB we're all going to allow us to
express the same computations ultimately
that is if it's possible to do it in one
language it's also possible to do it in
the other but that doesn't say anything
about how easy it is how much help the
language will give you about making
mistakes and how quick the final result
will be so in my opinion three important
features that a domain-specific language
gives you over just coding up special
types or operations in a general-purpose
language like C++ or C sharp are the
conciseness of the representation the
ability to do type checking or runtime
checking or otherwise have safety
built-in and the ability of the compiler
or runtime system to do optimization
let's take something like MATLAB which
is very good at doing mathematical
operations or matrices or matrix
multiply in a concise manner and take it
as sort of a running example you could
code up the same sorts of operations
matrix multiply in language like C or
C++ and C sharp and you might start out
by having them be functions that take a
number of arguments in making your own
data types and there it's relatively
clear that language like MATLAB which
just lets you use the star to multiply
two matrices is going to be more concise
however once you start adding operator
overloading a feature of languages like
C++ or C sharp that allows you to change
the meaning of symbols like plus or
stars that they in essence call
functions you define then the
conciseness argument is more of a wash
sort of a tie for both ends however the
other two aspects type safety or type
checking and optimization are still
really critical a language specifically
designed
to handle mathematics or matrices
something like MATLAB is going to be
able to notice potentially more easily
if you make mistakes related to that
particular domain for example in C or
C++ often a two-dimensional matrix array
is really just a single array carefully
embedded there's some sort of stride or
approach where we reuse the elements or
the indices in a very long
one-dimensional array as if it were a
two-dimensional array and it is really
easy to make mistakes to pass in arrays
or matrices that have the wrong
dimensions to matrix matrix multiplied
to confuse row major order in column
major order and language like C or C++
depending on which matrix implementation
you're using won't give you any support
with that will silently let you shoot
yourself in the foot compute the wrong
answer you might not even crash you
might just get something you're not
expecting and that's really problematic
because these days the constraint is
often programmer time rather than CPU
time so I'd rather use a language where
these things are built in as first class
citizens and there's the possibility
that it will alert me to error now many
of you may have a favorite C++ or C
sharp or Java matrix library that would
catch those errors and again ultimately
since these languages have equivalent
expressive power you can add that sort
of error checking to any language or
library but often domain-specific
languages do a better job at it and the
third example is then optimization the
higher-level instructions you give to a
compiler or interpreter the more scope
it has for creativity the more chances
it has to reorder your statements or
implement them another way the closer
you can get to just being declarative I
want to multiply these matrices and I
don't care how you do it the more the
compiler under the hood is able to take
advantage of things like memory
hierarchies caches special multimedia
instructions you might have in order to
get that sort of thing done well under
the hood if you actually write out your
matrix matrix multiply is three nested
for-loops
you're forcing the compiler to generate
code for that particular implementation
often domain-specific languages allow
you to express things like matrix
transposition or multiplication at a
very high level and thus they actually
end up generating better code for new
target architectures than you might do
if you were to code it up yourself you
end up spending less time writing it's
concise you get guarantees and it's
faster and in fact you can view the push
to domain-specific languages as just an
extension of the push from assembly
languages to high-level languages
one of the first arguments made in favor
of higher-level languages were early
studies in computer science that found
that the number of lines of code that
programmers could write per day
essentially over the lifetime of a
project was constant regardless of what
language you are using so you could
either pay your programmers and get ten
lines of assembly or you could pay your
programmers and get ten lines of C or
ten lines of Python or somesuch
and if you have experience with multiple
languages typically you can get
significantly more done in ten lines of
Python than you can in 10 lines of
assembly because of built-in support for
dictionaries or lambda or higher-order
datatypes object-oriented programming
that sort of thing ultimately you could
get everything done with assembly but it
would take longer the same argument here
applies to domain-specific languages if
I have a new more exotic domain-specific
language let's pick macro lab that's a
favorite one of mine for programming
wireless sensor networks for moving data
around and performing distributed
computations let's say for example that
you want to keep track of people passing
through your storefront advertising
window to see if it's actually working
and attracting people you might make up
some sort of wireless sensor network
that keeps tracked you want to write
programs for that you could do them in C
or assembly language or you could use
this sort of domain-specific language
since it has notions of distributed
computation where data live sending
information back and forth built in as
primitives
it's able to check mistakes for you
generate good code for you and in
general improve your productivity could
you get all of that done with a
well-crafted library yes
and in some sense ultimately under the
day maybe there's no difference between
a well-crafted library in a
domain-specific language but I think
we'll see a lot of the initial effort or
improvement
come on the domain-specific language
side and then the libraries will follow
and catch up</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>