<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Heavy Lifting Done by the Runtime - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Heavy Lifting Done by the Runtime - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Heavy Lifting Done by the Runtime - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/F0s_UZYIkHM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's look at all the heavy lifting
that needs to be done by run time in
order to facilitate this MapReduce style
of programming the app developer
righteous map function and reduced
function and instantiate the programming
library by calling MapReduce and the
programming library splits the input
files that is provided by the user that
is a key value space provided by the
user into M splits the number of splits
of the input key value pairs namely m
can be automatic by the programming
system or M can also be specified by the
user in any case once M is specified or
automatically determined by the
programming framework it splits the
input key value space into M splits the
next thing that happens in the
programming environment is to spawn the
master for this particular MapReduce
computation and all the worker threads
that are going to carry out the work
involved in map functions and reduce
functions the master is special because
the master is the one that is sort of
always seeing the whole operation and
keeping tab on which workers are doing
what functions when are they done when
to start new work when to say that the
computation is done all of those chores
are being orchestrated by this master
the next thing that happens is that the
master is going to assign some number of
worker threads as the mapper worker
threads and the number of mapper worker
threads may correspond to the number of
splits that it has done in the beginning
so there are M splits then M worker
threads are going to be assigned to
mapping function so each worker thread
is going to take one portion of the
input file split that has been done and
apply the map function on that
particular input split the next thing
that happens is that the master assigns
reduce task to some number of worker
threads and the number of reduces to be
assigned to the workers or is
thing that is decided by the application
recall in the example that I gave you
about looking for specific names in an
input corpus the number of unique names
is something that the app developer is
specifying that's where the number are
comes from that's the number of splits
that the user is specifying and that
parameter is going to be used by the
master to assign some number of workers
as reducers the next thing that the
master does is to plumb the mapper to
the reduces because now when the mappers
produce that output their output has to
be sent over to the consumers of the
intermediate results of the mapper
namely the reducers and setting up this
communication paths between the
producers of data the mappers and the
consumers of data the reducers is the
plumbing that the master does as the
next thing now it's time to get to work
the map phase what it is going to do is
it is going to read its respective split
so each of these workers is assigned to
the mapping function so each of the
worker is working on a particular split
and what they're going to do is read
from the local disk the split that
they've been assigned parse the input
and then call the user-defined map
function the user-defined map function
is the one that is doing the core of the
work that needs to be done on the input
data set to produce the intermediate
output the rest of it are things that
needs to be done in order to facilitate
the work to be carried out by the domain
expert in the map function and the
intermediate key value pairs that will
be produced by the mapper will be
buffered in memory so each one of these
workers is doing a portion of processing
the input key value pairs and producing
the respective outputs and periodically
the intermediate results are going to be
written to files which are on the local
disk off the worker of the respective
workers for this guy on its local disk
it's going to write intermediate files
corresponding to the output of the map
function similarly this worker is going
to write to its local disk the
intermediate files and so on and because
the application developer has specified
that there are our splits in the
reducers each worker meaning each map
function that is associated with that
worker is going to produce or
intermediate file one for each of the
are workers that are going to be doing
the reduced operation and all of these
intermediate files are stored on the
local disk associated with each of these
computational nodes carrying out the
work of function corresponding to the
map phase and when they are done with
the map operation for the split that
they are handling the worker will inform
the master that I'm done and what the
master is waiting on is waiting on all
of these mappers to get done before
letting the workers to get going on the
input data set so in this sense the
master is like the conductor of an
orchestra he is started this mapping
function waiting for all of these guys
to get done and when they indicate that
they have done their work by notifying
the master and all of the EM mappers
that have been assigned to these workers
have completed at work then the master
says ok now it isn't time to move on to
the reduced phase</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>