<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>High Arithmetic Intensity - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="High Arithmetic Intensity - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>High Arithmetic Intensity - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bHkFV-YMxxY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's recap where we are so we're
talking about strategies to do a fish
and CUDA programming and the first thing
we've talked about is using high
arithmetic intensity trying to get your
ratio of math operations to memory time
spent accessing memory as high as
possible and so far we've been talking
about the denominator the goal has been
to minimize the time spent on memory
part of that is simply moving data to
faster memory if you're gonna access it
a lot keeping in mind that you know the
fastest memory of all is local local
variables followed by shared memory
followed by global memory another thing
you can do is use coalesced global
memory accesses so when you are
accessing global memory try to do it
quickly and the trick there is adjacent
threads are accessing a contiguous chunk
of memory usually they're accessing
adjacent memory locations well what else
do we need to think about when we're
writing efficient CUDA programs in
addition is driving for higher thematic
intensity we also want to avoid thread
divergence let me explain what that
means so in parallel threads like the
threads and our trusty thread block do
something different we say they diverge
so we had some code looked like this in
the kernel you're doing some stuff and
you reach an if statement you say if
condition is true then execute some code
else execute some other code and you
proceed so if you think about a whole
bunch of threads and a kernel executing
this code all these threads are gonna
get down here
so these threads are going they're going
to hit this condition they're all going
to execute this condition and then some
of those threads are going to take the
if branch some of them are gonna take
the else branch so this thread proceeds
hits the condition and then let's see it
takes the if branch maybe this read
proceeds when it hits the condition
maybe it takes the else branch perhaps
this thread takes the else branch as
well and maybe this thread takes the if
branch okay so these threads have
diverged of course in this particular
case afterwards they're going to all
proceed together again so this thread is
gonna keep on going
finish the if code this thread will keep
on going finish the if code these two
threads will each keep proceeding and do
the else code and then they'll all
converge again and you might notice that
I tried to draw them that they kind of
reassemble into the same the same order
they were in fact their thread IDs have
never changed okay this is still thread
zero this is still thread three this is
still thread - I'm sorry thread 1 and
thread to sew the thread indexes don't
change it's just the path that the wreck
getting through the program is different
so that's what divergence means this is
thread divergence threads that do
different things</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>