<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BFS 101 (cont) | Coder Coacher - Coaching Coders</title><meta content="BFS 101 (cont) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BFS 101 (cont)</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fsh3GWl3oWU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's write down some pseudocode for a
sequential BFS algorithm this algorithm
would take as input a graph G
represented by its vertices and edges as
well as a source vertex s what it will
produce is a map of distances D where D
of a vertex X is the distance from s to
X now initially we don't know any of the
distances so we'll initialize d to be
infinity for all vertices except s s is
just zero edges away from itself notice
that according to this initialization
convention if there is no path from s to
X then we'll get an infinity at D of X
now the algorithm will also maintain a
qf of unvisited vertices initially f
just contains the source s now as long
as f is non-empty the algorithm does the
following it first extracts and
unvisited vertex V it then loops over
all of these neighbors let's call a
given neighbor w if W does not have a
distance yet meaning its distance is set
to infinity then we'll update its
distance to be the distance of V plus 1
since W is just one edge away from V in
addition if it didn't have a distance
yet then it wasn't visited therefore we
should throw W into the visited q in
this example I've given this vertex a
label of a and I've thrown it into F now
let's consider the next neighbor of the
current vertex V it's also unvisited so
we'd repeat this process of updating its
distance and adding it to F now would be
a good time for you to pause and
continue to trace the algorithm to see
how it works and convince yourself that
it's correct now what is the cost of
this algorithm since you traced its
execution as I suggested then you
observe that it only inserts a vertex
into F if it has not yet been visited
therefore the number of iterations of
the while loop shouldn't be more than
the number of vertices or the size of V
and since each vertex appears in F and
most once will visit each edge at most
once if the graph is directed or twice
if the graph is undirected that means
that the body of the innermost for loop
will be executed a total number of times
that is at most big o of the number of
edges in other words the total
cost of the algorithm is big-oh of the
size of V plus the size of e again if
you trace through the algorithm yourself
on a sample graph you'll see how this
happens</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>