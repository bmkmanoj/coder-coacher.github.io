<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Polynomial Time Approximation Schemes - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Polynomial Time Approximation Schemes - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Polynomial Time Approximation Schemes - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fasF6zHuolQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in addition to constant factor
approximation algorithms which we will
look at in more detail soon we are also
going to be talking about advanced
algorithms that are known as polynomial
time approximation schemes scary term
and what the idea of a polynomial time
approximation scheme is it's a sort of
more advanced constant factor
approximation so you can think of it as
a sort of scale and the idea behind a
polynomial time approximation scheme is
that the running time actually depends
on the quality that you want to get so
with a constant factor approximation you
always get the same guarantee say a
factor two approximation and in a
polynomial time approximation scheme you
can more or less decide what the quality
is that you want but the better a
guarantee you're demanding with respect
to quality the more running time you'll
have to put into that algorithm so it's
a trade-off here but first of all let's
look at constant factor approximation
we're now going to meet Ellis again
Ellis as you know is working on vertex
cover and so far I guess she has been
the most lucky in this course because
she seems to actually be working on a
very well-behaved and P complete problem
we also learned that this could search
trees there's good pre-processing and
vertex cover was even fixed parameter
tractable so Alice can be quite
optimistic about approximating vertex
cover and actually she has come up with
two different ideas of how you could
approximate vertex cover here are the
two possible ideas that she has come up
with so the first algorithm takes as
input a graph and then looks if some
edges are still not covered in that
graph and if that is the case it takes
the uncovered edge and puts both of the
endpoints of that edge into the vertex
cover and then the algorithm looks again
if there's still some uncovered edges if
there are any of those then it takes
again one and puts both endpoints into
the vertex cover and so on until all
edges are covered and she calls that
algorithm take two because it always
takes two endpoints into the vertex
cover each time you go through that loop
until you're done and here's her second
idea and she calls that idea greedy
because what that algorithm does it's
still the same in the first line here it
looks if some edges are uncovered and
then what it does is it goes through all
of the vertices to determine which
vertex could cover the most edges that
are still uncovered so which vertex is
next to the most edges that have not yet
an endpoint in the
takes cover and then it puts that vertex
into the vertex cover so it kind of
tries to maximize the coverage that it
can achieve in each round that this new
Pierre is run so looking at the
strategies of these two algorithms what
I would like you to think about for a
moment here is which of these two
algorithms should we expect to perform
better in terms of approximation quality
the one that always takes two endpoints
or the one that tries to maximize
coverage</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>