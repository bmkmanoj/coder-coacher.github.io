<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Optimize the Protocol Stack - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="How to Optimize the Protocol Stack - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Optimize the Protocol Stack - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qFZIj9WPPUg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">given a behavior spec for a protocol say
tcp/ip can a stack be synthesized as a
composition of the ensemble micro
protocols given 60 micro protocols in
the ensemble suite there are way too
many combinations for a brute-force
approach instead in the ensemble
approach the user heuristic algorithm
for synthesizing the stack given the
desired behavioral spec and designers
knowledge of the micro protocols the
result is a protocol stack which is
functional but not optimized for
performance of course as operating
system designers we are always worried
about for performance and we naturally
have to think about how to optimize the
protocol stack so that it is not only
functional but also performant in
particular the fact that we've assembled
this protocol stack like Lego blocks
putting together all these micro
protocols leads to layering and layering
leads to inefficiencies now this is
where the analogy to VLSI component
based design breaks down and the reason
is because in VLSI component based
design even though we are building a
complex chip like a CPU by putting
together components the components just
fit together very nicely there is there
is no inefficiency in going between
these components but in software
components unfortunately they have
interfaces and interfaces usually mean
that that there is well-defined
boundaries between these components and
so to cross the component boundary you
may have to copy parameters adhere to
interface specifications of the
components and so on all of those things
leads to inefficiencies and this is
where the VLSI component based design
idea breaks down a little bit when we
just put together the components of
software in order to build the
large-scale system so we have to do the
extra work that is needed in order to
optimize the component based design so
that it can perform well fortunately
there are several sources of
optimization that
possible for instance I mentioned that
oh camel has implicit garbage collection
now it is good that it has implicit
garbage collection as a fallback but
maybe we don't want to use it all the
time and we want to be explicit about
how we manage our own memory that can be
more efficient that is a source of
optimization
I mentioned that oh camel has ability
for doing marshaling and unn marshalling
of arguments to go across layers which
is also a very good thing to do in order
to have a component based design but
when we're going across layers these
things can add overheads and this is
another source of optimization that is
possible but avoiding these are
marshaling and on marshalling across the
layers the collapsing the layers another
opportunity that exists especially in
networking systems is the fact that
there is going to be communication and
computation if you think about the
tcp/ip protocol it has to necessarily
buffer the packets that are sending out
because if the packets are lost for some
reason it may have to be transmitted it
this is again a situation where we can
overlap this buffering which is
computation on the node that is sending
the packet with the actual transmission
so we can overlap that that's another
opportunity for optimization another
opportunity is compressing the header
especially when we have these layering
at every layer it might add a new header
specific to that layer and that may have
common fields for instance size of the
packet or checksum for the packet and so
on those are common things that you can
eliminate when we are going across these
layers so the header compression is
another possibility for optimization
another thing that we always have to
worry about is making sure that the code
that we execute fits in the caches and
this has been something that we've
talked about all along when we talked
about single node systems to parallel
systems that locality enhancement making
sure that the working set of whatever
code that is executing on a processor
fits in the cache is very important so
this again is an opportunity by
identifying common code paths across the
different layers of the protocol stack
and co-locating that common code path
across the layers
in order to make sure that we can
enhance locality for processing is
another source of optimization that is
possible this is all good so there are
lots of opportunities for optimization
but do it by hand manually that's
tedious so how do we automate the
process of optimization so that we don't
have to do it manually</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>