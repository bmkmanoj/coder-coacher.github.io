<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Atomic Operations - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Atomic Operations - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Atomic Operations - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bh-V04jRwpo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's look at a very simple
implementation of a mutual explosion
luck in terms of the instructions that
the processor will execute in order to
get this lock would be to come in and
check if the lock is currently available
and that is done by this check and if it
is available then it is going to set it
to 1 to indicate that I've got the lock
nobody can get it
right that's the idea behind this check
and then setting this to 1 on the other
hand if somebody already has the lock L
is going to be 1 and therefore I'm going
to wait here until some the the lock is
released and once the lock is released
then I can go back and check again to
make sure that the lock is available and
set it to 1 so this is the basic idea
very simple implementation of this lock
and and how will I know that the lock
has been released unlocking this is a
very simple operation again all that you
have to do is reset this L to zero and
that will indicate that the lock has
been released so if I'm waiting here and
somebody else has got the lock they're
going to come and unlock it by setting
it to zero and that way I will know that
it is been released I can go back double
check to make sure it is still zero
because somebody else could have gotten
in the middle if nobody else has gotten
it then I can set it to one so this is
the idea of a simple very simple minded
implementation of a lock algorithm is it
possible to implement the simple-minded
implementation of the lock using atomic
region rights alone let's talk through
this implementation here now if you look
at this set of instructions that the
processor has to execute in order to
acquire the lock it has to first read L
from memory and then check if it is 0
and store that new value which is 1 into
this memory location so it's a group of
3 instructions that the processor has to
execute and the key thing is these 3
instructions have to be executed
atomically in order to make sure that I
got the lock and nobody else is going to
interfere with my getting the lock and
as we know reads and writes instructions
by themselves are atomic
but a group of reads and writes are not
and therefore what we have here is a
group of three instructions and we need
them to be atomic what that means is we
cannot have just reads and writes as the
only atomic operations if we want to
implement this lock algorithm and we
need a new semantics for an atomic
instruction and the semantics is what I
call the read modify write operation
meaning that I'm going to read from
memory modify that value and write it
back to memory so that's the kind of
instruction that is needed in order to
ensure that we can implement a lock
algorithm now several flavors of
read-modify-write instructions have been
proposed and/or have been implemented in
processor architectures and we will look
at a couple of them the first one is
what is called a test and set
instruction the idea here is the test
and set instruction takes on a memory
location as an argument and what it does
is it returns the current value that is
in this particular memory location and
also sets the memory location to one so
these two things that are being done
that is getting the current value from
memory and setting it to one is being
done atomically that's the key thing
that it is testing the old value and
they're setting it to this new value
atomically another atomic
read-modify-write instruction that has
been proposed and/or implemented is what
is called a fetch and increment
instruction and this takes on again a
memory location as an argument and what
it is going to do is it is going to
fetch the old value of what was in the
memory and then increment the current
value that is in the memory by 1 or
whatever value so it could be that this
may take on an extra argument to
indicate how much it is going to change
it by but in the simple version it might
simply imprint increment in the simple
version it may simply increment the
current value that is in the memory
location by 1 as I said before there
have been several flavors of
read-modify-write instructions that have
been proposed in the literature and
often generically
these read modifier instructions are
called fetch and fee instructions
meaning that it is going to fetch an old
value from memory and do some operation
on that fetched value and write it back
to memory so for instance affection
increment is one flavor of that there
are other flavors like fetch and store
fetch and decrement compare and swap and
so on and you can read about that in the
papers that we've identified for you
okay now that we have an atomic
read-modify-write instruction available
from the architecture we can start
looking at how to implement the mutual
exclusion lock algorithms now I gave you
of course a very simple version of it
we'll talk more about that in a minute
and and I'm sure that in the first
project you when you implement it a
mutual exclusion lock you did not care
too much about the scalability of your
lock implementation now if you are
implementing your mutual exclusion lock
algorithm on a large scale shared memory
multiprocessor let's say with thousands
of processors you would be very worried
about making sure that that your
synchronization algorithms scale and
scalability issue is fundamental to the
implementation of synchronization
algorithms</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>