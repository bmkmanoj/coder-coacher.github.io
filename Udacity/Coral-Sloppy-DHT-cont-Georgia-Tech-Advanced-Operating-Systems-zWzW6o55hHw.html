<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Coral Sloppy DHT (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Coral Sloppy DHT (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Coral Sloppy DHT (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zWzW6o55hHw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's say I'm a proxy and I want to
put a key value pair in the coral DHT
I'm going to use the key based routing
algorithm to place the key at an
appropriate node what does that mean
well I'm going to take the key and even
if i have the node ID that is equal to
this key i'm not going to go to him
directly remember that the kollel
key-based routing algorithm reduces the
distance by half so I'm going to go to a
node that is half the distance to the
desired destination so the desired
destination is n I'll go to a a node
that is half the distance say n over 2
and over 4 and so on till I get to the
desired destination and as I'm going
making these calls saying that well I am
progressing towards this desired
destination node using that key based
routing algorithm that uses the XOR
distance between the source and the
destination having the listings at every
step what I'm going to ask is are you
loaded or full these two states that we
talked about and this guy says no I'm
not loaded or full and here is the next
hop you can go to so I keep going
forward and if none of these guys say
that they are loaded or full I would
eventually reach my desired destination
and place the key value over there
however when I do this hop going from
half the distance to one-fourth the
distance and so on somebody along the
way may say that look for this
particular key that you're trying to
place I'm already full all loaded one of
those two conditions is already applying
to me so this node response back to me
and says I am either loaded or full if
that is the response I get back then
what I'm going to infer from that
response is that the rest of the
distance going towards the destination
is all clogged up because of the tree
saturation and therefore
I'm not going to even try to place the
key value pair at the desk at the
desired destination and not even at this
guy because he's also loaded and or fall
for the same key and so I'm going to
retract my step and choose this node as
the node to place the key value pair so
in other words when I do a put operation
there are two phases to it the first
phase is the forward phase in the
forward phase what we are doing is we
are going to the guy that is half the
distance to the desired destination
asking him are you full or loaded he
says no I'm not then you go to the next
guy who is even closer to the desired
destination he says he's not fully
loaded then you go to the next guy who
is even closer using that key based
routing algorithm that I described to
you earlier so I keep going till you hit
a node that is either loaded or full at
that point you know you don't want to go
any further towards the desired
destination because all of these guys
are either loaded or full dealing with
this particular key and therefore the
second phase of the algorithm that I'm
going to use is retract my steps and go
back and ensure that that this guy is
still willing to host my key value pair
why would he change his mind well
between the time that is making this
forward motion it is possible that this
guy got either full or loaded so i
rechecked the condition she says still
I'm good to host your key value pair I
choose this node for the put operation
that's how the coral put operation works
so you can see that we are not storing
the key in the desired destination which
should have been the way a greedy
algorithm glove what but in the sloppy
algorithm of coral we choose an
appropriate node that is neither full
non loaded so that it can entertain
requests for receiving this particular
key value pair so we've avoided the meta
server overload by
doing this key based routing in the
forward path doing the put operation so
the gate operation is going to do
exactly similarly that is given a key
that I'm looking for I'm not going to go
directly to the destination that might
be hosting it as what happen in the
greedy approach but instead what i would
do is go to a node that is half the
distance to the key that I'm looking for
and when I do that my hope is I find the
key somewhere along the way because some
guy may be serving as the metadata
server for that particular key if not I
will go to the destination if nobody has
retrieved that key before it will be
available at the desired destination
I'll get it from there but the hope is
that if a content is popular enough then
multiple people multiple proxies may
have gotten the key value pair and
therefore and they may have gotten the
key value pair and in turn when they
have gotten the content as well they
would have put their own node IDs as a
potential node for the content and so
our metadata server when we are looking
for a particular key may not necessarily
have to be the destination which exactly
matches that key</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>