<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EvCEUWgiv2o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now let's talk about the virtues of
this linkless based queuing lock some of
the virtues are exactly similar to the
Andersons queuing law and that is it is
fair
so Anderson's lock was also fair ticket
lock was also fair the linkless giving
lock is also fair and again the spin
location is unique for every spinner
right every spinner has a unique spin
location to wade on and so that is
similar to the anderson skew lock as
well and that's good because you're not
causing contention on the network when
the lock is released when one guy
releases the lock others if they're
waiting they don't they don't get
bothered by by the by the signal and
exactly one processor gets signaled when
the lock is released that's also good
and usually there's only one atomic
operation per critical section and the
only thing that happens is this corner
case in order to implement this corner
case you have to use a second atomic
operation but if the linked list has
several members in this in those
examples I'm just showing only two
requesters at a time but if the linked
list has a number of requesters then if
I am middle of the gang have using the
lock I simply signal the successor I
don't have to do anything fancy in terms
of compare and swap so this is something
that needs to be done only for the
corner key is not as a routine for doing
the unlock operation and the other good
thing that we already mentioned is that
the space complexity of this data
structure is proportional to the number
of requesters to the lock at any point
of time so it is dynamic it's not
statically defined as in the array based
queuing lock and so that's one of the
biggest virtues of this particular
algorithm that the space complexity is
bound by the number of dynamic requests
to a particular lock and not the size of
the multiprocessor itself now the
downside to this linked list based
queuing lock is of course the fact that
there is linked list maintenance
overhead that is associated with making
a lock request or unlock request and
Anderson's Arabia's queue lock because
it's in a radiator structure can be
slightly faster than this linkless based
algorithm and one
of the things that I should mention it
there is that both Anderson's arabia's Q
lock as well as the MCS linkless based Q
lock may result in poor performance if
the architecture does not support fancy
instructions like this because they have
to be simulated using tests and set so
that can be a little detriment to to
this particular algorithms as well we
have discussed different algorithms for
implementing locks in a shared memory
multiprocessor if the processor has some
form of a fetch and free operation then
the two flavors of queue based locks
both due to Anderson and MCS they are
good bet for scalability if on the other
hand the processor only has tested set
then an exponential back-off algorithm
would be a good bet for scalability</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>