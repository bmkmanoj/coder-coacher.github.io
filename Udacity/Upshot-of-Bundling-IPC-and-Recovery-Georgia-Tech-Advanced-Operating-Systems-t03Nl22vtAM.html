<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Upshot of Bundling IPC and Recovery - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Upshot of Bundling IPC and Recovery - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Upshot of Bundling IPC and Recovery - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/t03Nl22vtAM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the upshot of bundling the IPC and
recovery management is that a service
can safely collect all the breadcrumbs
it left behind in all the places that it
touched through the course of its
service examples of such breadcrumbs
include memory that was allocated but
not reclaimed file handles communication
handles or orphan windows that have been
created on the display all of these are
breadcrumbs that may have been left
behind by failed clients a service and
the fact that you have a transaction
tree that records the trail of all the
nodes that were touched and the
temporary states that were created on
all these nodes allows these breadcrumbs
to be cleanly reclaimed and there is no
extra communication for the recovery
management itself because whatever
communication is needed for the
transaction managers to talk to one
another in participating in the
transaction that is shadowing the IPC
actually rides on the IPC itself and
therefore it comes for free and
Quicksilver only provides the mechanisms
the policy is entirely up to each
service and in fact services can simply
ignore these mechanisms if they don't
need any recovery management or choose a
policy that is commensurate with the
type of service that it is providing
because there's a variety of mechanisms
available in the operating system simple
services may choose to use low overhead
mechanisms whereas a more involved
service such as a file server may use
weighty mechanisms in order to recover
from failures the overhead for recovery
management in Quicksilver is very
similar to what we already saw in lrvm
the transaction managers have to write
log records at every one of these nodes
because they are handling the
interactions between clients or servers
at this node with respect to other sites
the transaction managers have to write
log records for recovering persistent
state similar to lrvm with
silver also uses in-memory logs for the
transaction managers and these
transaction managers flush the in-memory
logs that they create a record
persistent States to disk periodically
how often these in-memory log records
are written out to the disk by the
transaction manager is a performance
factor and it is a window of
vulnerability just as an LR VM ideally
if you want to be absolutely sure that
you can recover from failures whenever
any persistent state is modified and a
log record is written by the transaction
manager that log records should be
committed to the storage but that costs
synchronous i/o and so if you're worried
about that you might want to do that
more opportunistically assuming that are
not going to be too many failures so
there is a performance vulnerability
trade-off in how often the transaction
manager writes log records to the
storage device</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>