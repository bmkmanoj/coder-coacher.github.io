<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Frobenius-Hall Theorem - GT - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="The Frobenius-Hall Theorem - GT - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Frobenius-Hall Theorem - GT - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rkUb2qaHGXo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">before we turn to finding a faster
algorithm for finding a maximum matching
there's a classic theorem related to
matchings that we should talk about this
is the Frobenius hall there for a subset
of vertices say x will use n of x to
indicate the union of the neighbors of
the individual vertices in the X if we
consider this graph here then the
neighbors of the orange vertices will be
the green ones note that the fact that
if we call this X then the size of the
neighborhood of X is larger than X that
this bodes well for the possibility of
finding a matching for all the vertices
on the left hand side here at least
there's a chance that we will be able to
find a match for all these vertices when
this is not the case however as seen for
these three vertices here then it is
hopeless regardless of how we match the
first two there will be no remaining
candidates for the third vertex we can
make this intuition precise with the
Frobenius Hall theorem which follows
from the max matching min vertex cover
argument given a bipartite graph G
partitioned into l and r there exists a
matching of size l if and only if for
every x which is a subset of l the size
of the neighborhood of x is at least the
size of x the forward direction is the
simpler one will let em be a matching of
size l and will let x be a subset of the
left hand side we let y be the vertices
on the right hand side that x got
matched to well then clearly why is the
same size as x but then why is also a
subset of the neighborhood of x and
hence the size the neighborhood of x is
at least the size of x the other
direction is a little more challenging
suppose not we'll let em be a max
matching with cardinality strictly less
than the cardinality of the left hand
side we let H be the set of vertices
reachable from an alternating path from
the unmatched vertices in L this is the
same picture used in the max matching
min vertex cover argument there's at
least one unmatched
checks here by our assumption well then
the neighborhood of the left-hand side
of h is equal to the right-hand side of
H but this left-hand side must be
strictly greater because there's at
least on one unmatched vertex if you
like you can think about the matched
vertices on either side cancelling each
other out and we're left with some
nonzero number of unmatched vertices on
the left-hand side</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>