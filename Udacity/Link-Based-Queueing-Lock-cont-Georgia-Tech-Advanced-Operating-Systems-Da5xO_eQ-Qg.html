<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Da5xO_eQ-Qg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this compare-and-swap instruction is
going to return true if it found that
ellen me that first two arguments were
the same and therefore it set L to the
third argument in that case it's a
success and success is indicated by a
true being returned by this operation
but on the other hand if the comparison
failed it won't do the swap it'll simply
return false so it won't do the swap but
in return false so that's the semantics
of this particular instruction again
this is an atomic instruction and this
atomic instruction may be available in
the architecture but if it isn't then
you have to simulate it using test and
set instruction so in this particular
example that I'm showing you when I try
to do this unlock operation because this
new guy has come in and he's executing
is halfway through executing his lock
algorithm so he's done the fetching
store and and he's gonna set up the list
so that my next pointer will point to
him so that's the process that he is in
right now so at that point I'm coming in
and I'm saying what I want to do the
unlock operation and that's when I found
that my next point is nil and so what I
have to do is do this compare and swap
and at the compare and swap now it's
going to return to me false indicating
that this particular operation failed so
once I know that this operation has
failed then I'm going to spin and so the
semantics of the unlock call is I come
in and remove myself from L and in order
to do that I'm gonna do this compare and
swap on the linked list and if I find
that the compare and swap instruction
fails I'm gonna spend now what am i
spinning on when will it become not nil
so I'm basically what I'm going to do is
I'm going to spin on my next pointer
being not an L so right now it's nil
that's the reason that I think that
there's nobody after me I was going to
set this guy to nel but I know the
compare-and-swap failed and therefore I
know that there's a request in formation
and I'm gonna spend waiting for my next
pointer to become not nil now when will
my next pointer become national remember
that this guy the new guy that is doing
this
operation doing exactly what I did
earlier right and and what he's doing is
he's gotten my coordinates and he's in
the process of setting it up so that my
next point is going to point to him so
eventually he's complete that operation
so my spinning is on this becoming not
nil and it'll become not nil because of
this new guy completing what he needs to
do as part of this lock operation and so
eventually the next pointer in in my
node will point to him and at that point
I can come out of my spin loop now I'm
ready to signal the successor that hey
you got the lock so that's how I can
make sure that when we unlock the corner
case that occurs during unlock and that
is there is no requesters after me I can
take care of that by doing this atomic
operation and ensuring there's there's
no race condition between me the
unlocker and a new requester that is in
the process of forming through this lock
call so once this lock data structure
has been fixed up nicely by this new
requester so far as I'm concerned
everything is good I can the list is
good and therefore I can go ahead and
signal the next guy that he's got a lot
and be done with it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>