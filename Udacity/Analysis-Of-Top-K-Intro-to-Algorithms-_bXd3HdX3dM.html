<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Analysis Of Top K - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Analysis Of Top K - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Analysis Of Top K - Intro to Algorithms</b></h2><h5 class="post__date">2012-07-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_bXd3HdX3dM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's sort of cool that top k via
partitioning has just described works it
gets us the top k values and not sorted
order alright let's do an analysis of
the time it takes for a top k to do its
work via this partitioning approach and
because it's a recursive algorithm is
going to help to set this up in terms of
recurrence relations so here's the
recurrence relation we want to solve the
the time it takes to run top kvo
partitioning on well an element it was
call that one and the time that it takes
to run on n elements is going to be hard
to write down exactly but we can put
down a bound so what does it do first it
does the partitioning operation which
runs through all the elements of the
list that takes time n then what's going
to recurse assuming it hasn't gotten
really lucky and since this is a less
than or equal to let's assume it didn't
get lucky it's going to recurse on
either the left or the right now the
partitioning algorithm is going to split
this list L into a left and a right in
the different cases is going to recurse
on either the left or the right but we
don't know which one is going to recurse
on and we don't know which one is bigger
so what do we know well it's just as
likely for the left to be bigger as it
is for the right to be bigger and vice
versa so there really you can imagine
with justification that with probability
a half the left side is bigger and in
particular bigger than size n over 2 and
in half the cases right is bigger and
again bigger meaning that's going to be
at least size and over 2 so if the
recursive algorithm gets called on the
smaller half then the work that has to
do is whatever the recursive running
time is on a list of size n over 2 or
smaller this is an upper bound and that
happens with probability a half but we
might also get unlucky and have to
recurse on the larger half which could
involve actually something almost the
size of the entire list so that's kind
of a weird recurrence relation because
it has probabilities in it but really we
want a running bound on the running time
how many steps is going to take in this
case on average for top K to finish it
finish it stop and this gives us an
upper bound this recurrence relation
gives us an upper bound all right so to
solve this recurrence relation I'm going
to cheat a little bit because
I know that for n is going to be a good
upper bound on the value of T of n so
all we have to do is actually prove that
that's true we don't actually have to
figure it out so to prove that this is
true we're going to proceed by induction
so our base case is t of 1 equals 1
which is indeed less than or equal to 4
for our inductive step we know from the
structure of the algorithm that the time
it takes to handle a an input of size n
is on average going to be less than or
equal to n plus a half TM n over 2 plus
a half t ever net to your end just like
we argued before and now we're going to
use our inductive hypothesis that T of n
is less than or equal to 4 n to get an
upper bound on this quantity so T of n
over 2 we're assuming is upper bounded
by 4 n over 2 which is to N and this
quantity T of n we're assuming is less
than 4 in now this is a little bit of an
abuse of our mathematical abuse of
induction we really don't want this to
be in here because our inductive step is
going to assume that's true for
everything smaller than n not equal to
an but the reality is is actually a tiny
little bit less than n the worst
possible case that you get in this
algorithm is we pick the partition on
the end and then we recurse on
everything but the end so it's a t of n
minus 1 here but it's yeah with
apologies that you can make these
details all work out but it's a little
irritating so with that caveat we
proceed we have is this is equal to n
plus n plus 2 n which is indeed for hen
so we've now shown that at for each
value of n t of n is always upper
bounded by 4n and that's what we wanted
to show but this is pretty remarkable
because what that means is we actually
find the top K elements in big theta of
n you know for n is big theta of n so
the running time is going to be linear
which is pretty neat</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>