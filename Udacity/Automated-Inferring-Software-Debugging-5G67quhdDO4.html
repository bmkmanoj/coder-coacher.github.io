<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Automated Inferring - Software Debugging | Coder Coacher - Coaching Coders</title><meta content="Automated Inferring - Software Debugging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Automated Inferring - Software Debugging</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5G67quhdDO4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let me show you how this works on an
example here's a square root function
takes X returns the square root let's
assume we invoke this with the values to
4 and 16 when we invoke square root with
the value of 2 we could infer that X has
a value of 2 and eps has a value of 10
to the power of minus 7 however these
patterns would also be instantiated X is
smaller or equal than 2 and X is greater
or equal than 2 because these patterns
also hold for the values that we
observed in the next iteration we invoke
square root with a number of 4 and now
the invariant of X always being too is
eliminated what we get now however is
that X being less or equal than 4 still
holds we can do so by merging the
earlier invariant with the new one and X
great or equivalent to still holds for
the new value when we invoke square root
of sixteen we now retain the invariant
that X is less or equal than 16 and
greater or equal than two and this is
what we get in the end x is between 2
and 16 and EPS is always 10 to the power
of minus seven for the postcondition we
get similar ranges for the return value
the return values between the square
root of two and four which is the square
root of 16 however what we also get is
that the return value squared is equal
to X and we get this because daikon has
an appropriate pattern for that namely a
pattern where the multiplication of any
two variables equals a third variable
and this isn't senshi ated with the
return value again with the return value
and with X and this pattern then holds
for all runs at least for all runs with
integer number if we put in floating
point numbers then eps also comes into
play because of rounding errors and then
this pattern would no longer be
discovered so whatever daikon can
produce is constrained to the pattern
library it has but if you add more
patterns then you'll be able to discover
more properties it will take daikon a
bit longer though to discover them still
even with a perfect set of patterns
approaches like these are dependent on
the actual numbers that are being fed in
there what daikon produces is relevant
for all the runs observed but we all
know that the real precondition for
square root does not have specific range
constraints on ax except that X should
be greater or equal than 0 likewise the
return value of square root is not
necessarily between the square root of
two and the square root of sixteen but
it can actually be anything that's again
greater than zero so tools for dynamic
inference of invariants can work well if
they do have a good test suite in the
beginning how can we get the correct
ranges for X and the return value by
invoking square root with a value of
zero by invoking square root with the
value of one by invoking square root
with the value of Max and we're next end
is the highest available integer or by
invoking square root with a negative
hint you need multiple in vacations
check those which you need to get the
correct ranges over to you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>