<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>LSQ Example - Georgia Tech - HPCA: Part 3 | Coder Coacher - Coaching Coders</title><meta content="LSQ Example - Georgia Tech - HPCA: Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>LSQ Example - Georgia Tech - HPCA: Part 3</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eHVLMgfy-Jc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay to illustrate the operation of the
lsq we will do an example so here I have
a load/store queue where this is the
oldest instruction and this is the
youngest instruction in the queue
note that the queue is storing
instructions in the correct program
order so basically in program order this
was the first low this was the second
instruction and so on this says whether
it's a load or a store this tells us
what address the loader store was
fetched from this is the sequence number
basically just going up and this is the
address to which the load or the store
resolves to and this is the value that
we will get for that loader store and
let's say that this is the content of
the data cache let's say that the
initial content of the data cache is 42
here 1 here 38 here and 1 2 3 4 here
this load goes first
access is address 3 2 9 0 which is this
one and loads the value of 42 let's say
now that this store here computes its
result it basically gets the value it's
gonna store let's say that it gets 25
note that this store doesn't really put
that value yet in the cache that will
happen when it commits so this is only
that we have gotten the value from the
instruction that produces the register
that we will use as our source value to
store in memory let's say that this next
door also gets a value of minus 16 this
time now let's say that this load
executes snacks access is the address 3
4 1 8 and it tries to see whether any of
the previous stores matches that address
they don't so it loads the value from
memory this is the address in the cache
that matches this so we're gonna get 1 2
3 4
next this load tries to load the value
it has the address of 3 2 9 0 it's going
to search upward for the latest store
that still precedes it that matches the
address and it finds one this store is
having the address of 3 2 9 0 so instead
of going to the cache we are directly
going to copy just the value of minus 17
here so now we actually had a load that
never really accesses the cache it just
gets the value from the
store the next load accesses address
three three zero zero it searches the
previous stores and doesn't find any
that match this address so it's gonna go
to the cache and load from address three
three zero zero and it gets one next we
have another store two three two nine
zero let's say that the value store
there is now zero next we have a load
from three four one zero it searches the
previous accesses for a store that
matches this address and it finds one
over here so it just copies the value of
twenty five so again we have a load that
never accesses the cache because it
found what it needed in the load/store
queue next we have a low two three two
nine zero it searches the load/store
queue to find a store that matches this
address and it finds one over here so it
just copies the value of zero here note
that by now there have been several
stores to three two nine zero we always
want to get the value from the most
recent one that still precedes us
because if things were happening in
order one at a time this is exactly what
the value should be in the memory
location note however that the memory
location as far as the cache and the
memory are concerned still contains the
value 42 at this time although there
have been several modifications why well
because the stores haven't sent the
values to the data cache yet and finally
we have another low two three three zero
zero it searches backward to find any
stores to the same address note that
this is a load we don't do that so there
are no stores to the same address so we
actually load the value from the cache
and the value is 1 now let's say that at
some point the loads and stores start
committing so we will have this load
commit a load commits by simply copying
the value to the register file and now
the oldest pointer is here this store
commits by putting the value in the
cache so now we take the value of 25 and
put it in address three four one zero so
the override is 38 with 25 and now the
store can commit and our pointer moves
here we commit another store here so the
value of minus 17 goes to location 3 - 9
0 so we override this 42 with 17
now our store is committed we move the
pointer here if you remember we said
that we need to send the values to the
memory or the data cache at the time the
store commits not at the time it
executes here's why if at this point we
decide that we are taking an exception
we can just flush this from the
load/store queue and the value in the
data cache in memory is exactly the
value that should be there as of this
point in the program execution so just
like we had our architectural register
file and we were copying values on
commit into it for registers so that at
any given time we know exactly what the
committed registers value are similarly
at any given time we have in our data
cache in memory
exactly what is there as of the commit
point this process will now go on the
load commits and deposits this value in
its register another load can commit and
another one when the store commits it
overrides this 17 with a zero and then
the loads commit and the final content
of the cache is this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>