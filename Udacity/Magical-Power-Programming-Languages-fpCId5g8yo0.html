<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Magical Power - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Magical Power - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Magical Power - Programming Languages</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fpCId5g8yo0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so we just remembered that one
of the great powers of grammars is that
they can be recursive just like
procedures you can have a grammar rule
that expands to itself allowing you to
have an infinite number of utterances
from a finite formal grammar that gives
us a huge amount of power almost a
magical amount of power but it does mean
that we'll need one more element of
bookkeeping in order to correctly do
parsing we saw before in one of the
quizzes that we could be in a particular
state after seeing two tokens for tokens
six tokens eight tokens so we'll need to
keep track of one more number to know
which one of those it was we need to
know where we came from or how many
tokens we'd seen thus far so here's a
grammar we've seen before he goes to E
Plus E or e goes to end our input string
is in + int and i'm going to start
filling out that chart that shows us
what parsing states we could be in if
we've only seen a subset of the input so
if we've only seen zero tokens then we
could either be looking for a plus e or
we could be looking for into those are
our two grammar rules we haven't seen
anything yet there's nothing to the past
everything is to the future once we've
seen the single int then we could either
be in the middle of parsing egos to int
and we're totally done with it or if the
input is longer we could be expecting a
plus and Annie in the future here's
where things start getting fun if we've
seen the int and the plus then we could
definitely be in the middle of parsing
egos to e plus e with a dot right here
we've seen two things to the left
there's one thing in our future but now
we could also start looking for another
int in our entire input in Pleasant
we're expecting an int to be the third
token if we saw it it would reduce or it
would be rewritten from egos to int so
our current parsing state is we haven't
seen it yet but we're really expecting
it in the future but here's where the
potential ambiguity comes in this state
is exactly egos to dot int we saw that
same state back here in chart position 0
however they're not exactly the same
this one corresponds to the first in
turn our input this one corresponds to
the second int in
input this is what we're thinking about
when we haven't seen any tokens yet this
is what we're thinking about when we've
seen two tokens but not the third the
parsing rule is similar because the
grammar is recursive it has a small
finite structure but we really need to
remember one extra bit of information
when we're thinking about it this time
we've sort of seen zero tokens so far
over here we've seen two tokens so far
or we decided to add this state based on
reasoning about state to this fact that
we could have to otherwise identical par
States means we'll need to augment our
par States with one more number of
information we're going to call this new
information the starting position or the
from position associated with a par
state one last way to see why we need it
let's say one of our current states is e
goes to dot int and we actually see that
int it's part of the input we need to
know whether we should go on to sort of
chart position one and start looking
around here or whether we should go on
to chart position three which i haven't
filled in and start looking there we
need to know where we came from in order
to know where we're going this is one of
the reasons why context-free grammars
are more powerful than finite state
machines finite state machines did not
really need to know where they were
coming from they were memoryless in some
sense aside from the current state we're
doing all of this because we want to
master parsing we want to see which
strings are in the language of a grammar
to see if HTML or javascript is valid
before we try to throw it to our web
browsers rendering engine another way to
think about this is that parsing is the
inverse of producing strings rather than
producing all the strings in the world I
want to see if this one string could
have been produced by our grammar over
here I've drawn a little diagram of
parsing a simple sentence in + int using
our grammar well one way to view this is
to think about the parse tree which I've
kind of drawn here upside down
conceptually I could apply this egos to
in true Lin reverse and rewrite this int
with an e changing the input string so
that it has a non-terminal in it then I
can do the same thing again over here
and now i have e plus e i can rewrite
that to be just e so as if i'm taking
the rules in the grammar
and changing the direction of the arrow
if I view this story this way we're
parsing magic trick of perspective if I
read from the bottom up we're generating
or producing strings starting with e I
choose to apply e goes to E Plus E I
choose to apply e goes to int choose to
apply e goes to int and I end up with a
string at the end of the day this way
from the bottom to the top is generating
or producing a string this way from the
top to the bottom is parsing a string
applying the reductions in reverse order
until you get back to the start symbol
if you could apply all the reductions in
reverse order then you know that the
string is in the language of the grammar
because you have a script for generating
it just do everything you did backwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>