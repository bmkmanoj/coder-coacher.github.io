<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cuckoo Hashing Part2 - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Cuckoo Hashing Part2 - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cuckoo Hashing Part2 - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0xx9S8fFlzc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">no it definitely will not always succeed
there are some nice probabilistic
guarantees about how often it will
succeed depending on the size and number
of the hash tables but the easy counter
example is to say that well here we have
two hash tables if we had three items
each of which had the same h1 and h2 so
for instance if we had three items where
h1 and h2 are both 0 there's no possible
way that we can fit them into the hash
table because we only have two slots
where any hash function is equal to 0 so
in practice we choose a certain number
of iterations and we continue to iterate
trying to fill up this hash table until
we decide that we've done too many
iterations and so if that's the case
then we just stop we choose new hash
functions and we start over and again
there's very nice probabilistic
guarantees about how often this is going
to finish so in the research that
inspired this work the guarantee that we
tried to use was that we could guarantee
that it was going to fail less than one
out of every million times so once we
construct the hash table the lookup
procedure is really simple we're going
to calculate all the hash functions for
the item that we want to look up so for
instance if I want to look up item B I
know I calculate item B's hash functions
here hash function 1 is equal to 0 and
hash function 2 is equal to 1 so what
I'm going to do is I'm going to look in
all the tables using the particular hash
functions until I find what I'm looking
for so first I'm going to look in table
1 and I know that I'm gonna look in slot
0 here I look in slot 0 and I say wait a
second that's not B so then I have to go
to hash table to look and see that it's
hash value is equal to 1 so I'll look in
slot 1 in table 2 and I'll see uh
there's B I've now found the value that
I'm looking for no we don't find it in
any of those locations it's just not in
the hash table now the nice part here is
that this is a constant time lookup it
just requires T lookups and T is a
constant it might be 2 it might be 3 and
so on
this is different than chaining chaining
has a variable time lookup it depends on
how many items are in the bucket and if
we have many items in the bucket and we
have to look all the way to the end it
can potentially take a very long time
whereas we can guarantee exactly how
much work and it's a constant amount of
work to look up any item in these hash
tables</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>