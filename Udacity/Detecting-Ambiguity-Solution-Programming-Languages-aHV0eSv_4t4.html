<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Detecting Ambiguity Solution - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Detecting Ambiguity Solution - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Detecting Ambiguity Solution - Programming Languages</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aHV0eSv_4t4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this problem we've been asked to
determine when given a grammar and a
string if that string shows that this
grammar is ambiguous so how are you
going to do that the key here is going
to be in writing out derivation of the
string under that grammar let me show
you an example so here ever it not a
grammar for the sake of writing out the
derivations I'm going to label each
rewrite role with a number just an
identifier so I can refer to this rule
as we're one let's say my given string
is the string a and B so what are some
ways I can derive a be given this
grammar starting from s I can take roll
let's do zero that takes me to pee from
key I can go to 80 using roll to from 80
I just need to get be unfortunately
using a row 5 T goes to be so there's
one way to derive to string a be using
this grammar and later on when I do
solve this problem I'm going to refer to
this derivation in the form of a list
where I took roles 0 2 and five to get a
B now to determine whether or not the
grammar is ambiguous with regard to the
string I need to try and find another
derivation so if i take roll one instead
of roll 0 starting from s that gives me
a and Q for make you I can take roll for
rule 4 goes to be giving me a B so the
derivation is 14 so I found two
derivations these are two very different
derivations through the string a be
under this grammar starting from s so
that's kind of a good example but how
does it help us solve the problem so
just like an earlier problem in this
homework assignment we get to make an
important assumption so the important
assumption of making is that whatever
grammars we feed into our function they
have a finite number of derivation this
actually means that there's a finite
number strings in the grammars so they
may not be all that interesting but
nonetheless determining whether or not
they're ambiguous is a very cool problem
so what does that allow us to do well
the grants
the ability to get a very simple
solution for the detecting whether or
not the grammar is ambiguous and what
we're going to do is simply exhaustively
enumerate all the derivations for that
grammar in the way we're going to do
that is take the expand function that we
wrote at the end of the lecture unit
instead of enumerated just the strings
we're going to numerate strings along
with their derivation once we've
enumerated all the derivations we can
check more than one derivation for that
string if we have found one than the
grammar is ambiguous otherwise it's not
so if you're like me your ear to get
right to the code let's do that so as
the hint described the first thing we're
going to do is write our expand function
and this is going to be taken almost
right out of the lecture if you don't
remember or haven't seen the syntax
before this says I'm going to take the
first and second values out of tokens
and derivation and put them in the tuple
tokens comma derivation here I have two
loops that are going to enumerate each
token and tokens and each role in the
grammar I'm going to access them as I
want given their position or index so
this gives me the roll out of the
grammar this says the current token
applies to this role it's on the left
hand side of this rule then I'm going to
do the following I'm going to yield as
part of this generator function a tuple
where the first value in the tuple is
the current state of the string I'm
going to make one substitution that's
what i'm doing here including everything
to the left of the current token making
the one substitution and then I'm
including everything to the right of the
token and then i'm updating the
derivation with the role i used so what
does that look like if i go back to the
example i had here let's say i pass in s
i am going to go through this list and
see every rule that applies to s well
rule 0 and rule one both apply to s so
I'm going to yield two things first one
is going to be p because i'm
substituting s4p and then i'm going to
return the derivation which is using
just roll 0 that's going to be the first
thing I yield
the second thing I yield is going to be
the substitution for the second roll our
real one and so what I'm going to do in
the body of is ambiguous now that I have
the expand so I'm going to go back
around and expand this expression even
more so when I expand this expression
I'm going to get two things the first
one is going to be using roll to to get
80 and the next one is going to be using
a roll three you could just get see so
as you can see i'm starting to build up
all these derivations and so what I'm
going to do and is ambiguous is I'm
going to keep building up all these
derivations until I can't expand anymore
and then I'm going to look at all the
derivations that yields a string I was
originally looking for all the
derivations once fully expanded yield a
B and then check to see if I got there
the same way if I got there in two
different ways then the grammar is
ambiguous under the string I was looking
for otherwise it's not so let's go write
that function so I've declared my
function I taken a grammar a starting
location a starting symbol in the
utterance that I'm looking for
enumerated is going to be all the
possible strings in the grammar I've
built up so far and since I'm just going
to start with start the first value in
the tuples just going to be the string
start are just the symbol start that's
it's a one simple string and an empty
derivation since I haven't done anything
yet so what do I have here I'm going to
take my enumerated list try to enumerate
or more try to expand it using the
expand function and if it changes that
I'm making progress i'm finding new
strings I'm expanding the derivations
and so I should keep going until I've
gone through all the finite number of
derivations if this hasn't been updated
I haven't done anything new the expand
function didn't find anything new and so
I'm just going to break because I'm done
I found all the generations I was
looking for so what i'm doing here is
i'm going through each entry in my
numerated list i'm going to try
expanding that entry if I found
something new then I'm going to add it
to my new enumerated list otherwise I'm
not going to do anything
what is going to do is going to update
new enumerated for every new thing
expand finds and so once I've done all
that i'm going to count how many
derivation i found for my uh pterence
and if i found more than one then i've
shown the grammar to be ambiguous and
i'm doing that by doing a list
comprehension that essentially filters
out everything that's not related to the
utterance and then taking the length of
that list if it's greater than one then
i found two derivation so otherwise i
haven't so that's how you solve this
problem</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>