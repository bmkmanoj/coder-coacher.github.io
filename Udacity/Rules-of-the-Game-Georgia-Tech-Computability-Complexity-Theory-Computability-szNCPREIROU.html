<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rules of the Game - Georgia Tech - Computability, Complexity, Theory: Computability | Coder Coacher - Coaching Coders</title><meta content="Rules of the Game - Georgia Tech - Computability, Complexity, Theory: Computability - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rules of the Game - Georgia Tech - Computability, Complexity, Theory: Computability</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/szNCPREIROU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Before we can make precise
statements about what is and
is not computable, we need to
define what we mean by computation.
We'll start with the notion of
some kind of machine or computer.
And this machine takes in an input and
after some finite amount of time
produces an output, or so we hope.
In this lesson, we'll focus on the input
and output parts of this picture.
And postpone the mathematical
definition of the machine itself.
The input is formed from an alphabet,
which is a finite set of symbols or
characters.
The finite part is important.
So if I wanted to use binary,
my alphabet would consist of
the two symbols, 0 and 1.
For genetic sequences
it's typical to use A, C,
G, T which stand for the four possible
nucleotides in a DNA sequence.
In practical applications, we often
use ASCII or Unicode for our alphabet.
Now creating a new symbol for
every possible input and
output would not be very convenient.
So, instead, we use finite sequences
of symbols which we call strings.
For example,
over the alphabet sigma we might have
the string 1010,
which might represent the number 10.
Or over our alphabet gamma,
we might have the string x = AACAG,
which might represent
part of a DNA sequence.
We notate the empty sequence,
which doesn't have any symbols in it.
With the special character, Epsilon.
Sometimes we will talk about
machines having string outputs,
just like the inputs.
But more often than not the output
will just be binary, an up or
down decision about some
property of the input.
So we might think about the machine
as just turning on one of two lights.
Either one for accept or one for reject.
Once the machine has finished computing.
With these rules, an important type
becomes a collection of strings.
Maybe it's the set of strings that
some particular machine accepts.
Or maybe we're trying
to design a machine so
that it accepts strings in
a certain set and no others.
Or maybe we're asking if it's
even possible to design a machine
that accepts everything in some
particular set of strings and no others.
In all these cases, it's a set of
strings that we're talking about.
So, it makes sense to give
this type its own name.
We call a set of strings a Language.
For example, a Language could be a list
of names, Charles {'Charles', 'Lance'}.
It could be the set of binary
strings that represent even numbers.
Notice that this set is infinite,
or it could be the empty set.
Any set of strings over
an alphabet is a language.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>