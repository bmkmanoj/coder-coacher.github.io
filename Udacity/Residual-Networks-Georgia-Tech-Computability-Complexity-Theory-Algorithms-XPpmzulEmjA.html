<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Residual Networks - Georgia Tech - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Residual Networks - Georgia Tech - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Residual Networks - Georgia Tech - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XPpmzulEmjA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everything we've done so far has been to
set up the rules of the game we define
the network and the notion of a flow
over it and we justified some of the
simplifications that we've made now
we're going to turn to the task of
actually finding a maximum flow the
search will be an incremental one we'll
start with a suboptimal flow and then
we'll look for a way to increase it
suppose that we are given a particular
flow over a network and we want to
explore how we might change it
perhaps we realize that we can increase
the flow by routing it through this link
here instead of through these two and
that would then allow us to add more
flow through this path this is
equivalent to adding a flow that goes
like this
notice that the flows through the middle
cancel out by adding this flow to the
original I get the desired result
alternatively if we just wanted to
reroute the flow through the top link we
could add a circular flow like this
which would then reroute the flow in
fact all possible changes that we might
make to our original flow can be
characterized as another flow but
different rules apply certainly if we've
used up some of the capacity on an edge
we can't use the full capacity in the
flow we're going to add we capture the
rules for the flow that we are allowed
to add with the notion of a residual
flow Network we start by defining the
residual capacity for all pairs of
vertices let's consider a UV edge if UV
is an edge in the original graph then
the residual capacity is the original
capacity minus whatever flow we already
sent across that edge for reverse edges
who are not UV but V U is the edge in
the graph then we have a capacity equal
to the flow that we sent from V to u we
can unsend this much flow everywhere
else the residual capacity is 0 in the
residual graph the edges are those UV
pairs for which the capacity is positive
keeping the network sparse helps in the
analysis in this example here notice how
the direction of this edge is reversed
there's no residual capacity going
forwards anymore that's all been used
off
but there is a residual capacity going
backwards since we can unsend the unit
of flow that we sent up here this edge
here remains the same we can still send
one unit of flow along there this edge
in the middle gets interesting because
we can either send one unit of flow that
would still keep leave us inside of
these capacity constraints here or we
can unsend the unit of flow that we
already sent</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>