<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memory Consistency and Cache Coherence - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Memory Consistency and Cache Coherence - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memory Consistency and Cache Coherence - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IlXs3NF3fE8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now having seen the sequential memory
consistency model what we can do is go
back to our original example and ask the
question what are all the possible
outcomes for this particular set of
memory accesses performed on p1 and p2
now what possible values can D and C get
well obviously you can get the first
choice no problem with that you can get
a second choice you can get the third
choice and as we Illustrated earlier all
of these are just interleaving of these
memory accesses on p1 and p2 but the
fourth one is not possible with
sequential consistency because there's
no interleaving of these memory accesses
and these memory accesses that will
result in this particular outcome that's
comforting that's exactly what we
thought would be a useful thing to have
in a memory consistency model that gives
only intuitive results and and make sure
that non-intuitive results don't happen
memory consistency model is what the
application programmer needs to be aware
of to develop his code and know that it
executes correctly on the shared memory
machine as operating system designers
however we need to help make sure that
his code runs quickly to do that we need
to understand how to implement the model
efficiently and also the relationship
between hardware and software that makes
it possible to achieve this goal so now
we understand that memory consistency
model is what the MA what is the model
that is presented to the programmer
that's what memory consistency model is
on the other hand cache coherence is how
is the system implementing the model in
the presence of private caches so this
is a handshake a partnership between
hardware and software between the
application programmer and the system in
order to make sure that the consistency
model is actually implemented correctly
by the cache coherence mechanism that is
ingrained in the system and the system
implementation of cache coherence is
itself a hardware software trade-off now
for instance one possibility is that the
hardware is only giving
at address space it's not giving you any
way of making sure that the caches are
coherent but it is giving you the shared
address space and it is letting the
software the system software ensure that
this contract is somehow satisfied in
the working of the cache coherence
maintained in software by the system
that's one possibility and that is what
is called a non cache coherence shared
address space multiprocessor meaning
that there is shared address space
that's available for all the processors
there is private caches for holding data
that you bring from memory but if you
modify data it is a problem of the
system software to make sure that the
caches remain coherent so it's non cache
coherent that is called NCC shared
memory multiprocessor the other
possibility of course is that the
hardware does everything it provides the
shared address space but it also
maintains cache coherence in hardware
and that's what is called a cache
coherent multiprocessor or a CC
multiprocessor</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>