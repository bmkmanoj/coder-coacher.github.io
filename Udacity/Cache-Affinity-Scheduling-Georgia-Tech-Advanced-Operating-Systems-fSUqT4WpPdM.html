<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Affinity Scheduling - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Cache Affinity Scheduling - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Affinity Scheduling - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fSUqT4WpPdM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so that brings us to this concept of
cache affinity scheduling basically the
idea is very very simple and and that is
if let's say that in a particular
process of p1 I had this thread t1
running for a while and it got D
scheduled at some point of time because
it made an i/o call it tried to
synchronize as another thread whatever
it is or time quantum expired 41 any of
those situations will result in t1
getting D scheduled and then the
scheduler is gonna use the processor for
perhaps running some other thread but
finally at some point of time if t1 gets
ready to be scheduled again it makes a
lot of sense for t1 to be scheduled on
the same processor why because it used
to run on this processor p1 and
therefore the the memory contents of t1
t1 that it needed to have its execution
were in the cache of p1 and therefore
when t1 gets ready to run again if I
schedule t1 on the same processor it is
likely that t1 will find its working set
in the caches of p1 that's the reason
why it makes sense to say well look
let's look at the affinity of a
particular threat to a processor and
that cache affinity of a particular
thread to a processor so the cache
affinity for this thread is likely to be
higher for p1 because it ran on p1
before god D schedule and every schedule
on when it is time to reschedule it if
we reschedule it on the same processor
good chance that t1 will find its
working set in the memory hierarchy the
caches of processor p1 but can't
something go wrong well what can go
wrong is the following when t1 was D
scheduled the scheduler may have decided
that ok a p1 is now available for doing
business for some other thread so it's
schedule t2 and at schedule t3 and
eventually when t1 gets ready to run
again it's ready to run again but in
between it's running on the processor
here and running on the processor again
here along this timeline to other
intervening threads ran on p1 so watch
out the cache move
looted by the contents of threads t2 and
t3 so far as t1 is concerned so when t1
runs again it's quite possible that may
not find a lot of its memory contents in
the cache because these two guys that
guard in the middle of its running on
the processor p1 may have polluted the
cache and gotten rid of a lot of the
stuff that used to belong to t1 and
therefore even though we made this
choice that well when t1 is ready to run
let's put it on p1 but it used to run
before and that way we can ensure that
t1 s working set is probably in the
cache of processor p1 but unfortunately
these intervening threads may have
polluted the cache so that's something
that you have to watch out for so the
moral of the story is that you want to
exploit cache affinity in scheduling
threads aren't processors but also you
have to be worried about any intervening
threads that may have run on the same
processor and may have polluted the
cache as a result so that's something
that you have to watch out for so now
that I've introduced the idea of cache
affinity for a processor with respect to
a particular thread we're now ready to
discuss different scheduling policies
that an operating system may choose to
employ</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>