<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Infinite Mind Reading Solution - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Infinite Mind Reading Solution - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Infinite Mind Reading Solution - Programming Languages</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AXYU7usad-E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this problem we're tasked with
creating a function that determines
whether or not a context-free grammar is
infinite we say an infinite grammar is
one that accepts an infinite number of
strings so let's come up with an example
here's a grammar that accepts strings
that spell up ba different lengths of a
3 a's and this can be possibly an
infinite number of A's that follow the
beat an example of a finite grammar I
simply took the infinite grammar remove
the a right here and this grammar only
accepts the string B since the number of
strings that this grammar accepts its
finite it's not infinite it's not an
infinite grammar so before I go on with
how we're going to approach this problem
I'm going to go over one of the
assumptions that you were given in the
problem specification and that
assumption is that for every non
terminal in the grammar it derives at
least one non empty that's critical
string if you see s you can assume that
there's at least one non empty string
that s derives so how does that help us
the way we're going to approach this
problem is that we're going to try to
see if we can relight q where q is any
non terminal and our grammar in the form
of some terminal X Q again and some
terminal why we're either X or Y is not
empty that is the length of x and y
together is greater than 0 so they both
can't be empty because that's not a very
helpful role q2 goes the Q is I'm going
to make us any progress the reason this
is important is that if we have this
rule or it can rewrite Q in this form
we're back to the bar rule that we had
originally if we have this rule we can
build up an infinite string by simply
repeating it over and over again adding
X's to the beginning or wise to the end
and so that's how we get an infinite
grammar and the Assumption comes in
again because if we see this role we've
assumed that Q can derive at least one
non empty string we don't have to run
what we wrote earlier in the homework
CFG empty on cue we can just assume it
so I don't actually even have to check
if Q can eventually finish if I find Q I
found that the grammar is infinite as
long
as this property holds so let's go over
the game plan I'm going to go through
each non terminal in the grammar because
it doesn't really matter with where I
start any one of them is a valid way to
generate an infinite grammar and then
I'm going to check for each of those non
terminals if it's possible to form
something in the manner of this rewrite
rule so how do I do this part I'm going
to write a recursive helper function and
want to check if that role is of that
form if it's not I'm going to recurse if
it is I'm going to stop so let's go to
the code so here I've declared my
function CFG infinite where I take in a
Python representation of the grammar I'm
going to go through every rule in the
grammar that's what this list
comprehension does and Q is going to be
the left hand side symbol in that role
so this may be new to you and what I've
done is I've declared a function within
my function the effect of this is that I
can only call the helper function that
I'm creating within the function CFG
infinite one advantage of doing this is
that this function is not useful to any
other code because I wrote it
specifically for CFG infinite so I can
restrict access so that it's not misused
in other places are dependent on in
other places one disadvantage is that it
kind of makes the code hard to read and
it makes it more difficult to understand
where functions can be called and where
they can't regardless i'm using this
helper function to determine whether or
not the symbol Q can be rewritten in our
form of x qy where the length of x and y
together is greater than 0 the three
parameters or the current symbol we're
at the symbols we visited we don't want
to loop around otherwise the helper
function won't finish and the size of x
and y in that case it's this value if
I've looped around and I've already
visited something I'm going to return
whether or not the size of x and y is
greater than 0 if it is we found the
rule that we're looking for and helper
will return true if it's not we're going
to return false because we're not making
the progress towards an infinite number
of strings that we wanted to otherwise
we're gonna have to parse through the
rewrite rules that apply to that symbol
current
update my list of visited symbols and
then I'm going to go through each
rewrite rule so here this for loop
iterates through the right-hand sides of
every rewrite rule that the current
symbol applies to where the current
symbol is equal to the left hand side of
that role it returns the right hand side
just another way to say it I'm going to
go through every symbol on the right
hand side and one recurse on that symbol
where the current of the recursive call
is the symbol Ahmad I'm updated symbols
i visited and updating the size of x and
y that was passed in before with the
length of the right hand side minus 1 we
do the minus one to exclude what we're
recurring on the queue in this case Q is
symbol when I do prove that Q can go
back to Q I can then check the size of
everything else that I've found before I
found that loop if helpers never true
that i'm just going to return false so
now that I've defined my helper function
I need to use it so for each symbol Q
which this list comprehension returns
i'm going to try them a helper function
on that symbol if that's ever true want
to return true if for every symbol I
never find the helper function to be
true I'm going to return false and I'm
done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>