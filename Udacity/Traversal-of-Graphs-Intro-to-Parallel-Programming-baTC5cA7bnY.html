<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Traversal of Graphs - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Traversal of Graphs - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Traversal of Graphs - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/baTC5cA7bnY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now we'll turn to another interesting
problem where the choice of approach is
crucial for good performance this is the
problem of graph traversal specifically
a breadth-first traversal of a graph so
let's define the terms that we're using
here a graph consists of a set of
vertices and edges that connect these
vertices so in this picture vertices are
blue circles edges are green lines some
graphs might be sparse with few edges
per vertex some might be dense and have
lots of edges per vertex large graphs
very large graphs are an interesting
recent topic of study the world wide web
for instance can be considered a graph
with pages as vertices and links between
pages as edges or the social network of
Facebook Google or Twitter is a graph
where people are vertices and
friendships are links these companies
would like to use the social graph to
say so just friends you might know based
on the friends who already have and
making these suggestions depends on
analyzing the graph but traversal
involves visiting all the nodes in the
graph web crawlers must traverse the web
to catalog it for searching how do they
make sure they visit each web page once
and only once a traversal of the web
graph will allow them to do that
now there's two approaches to traversing
a graph called depth-first traversal and
breadth-first traversal and so this
picture is going to help us show the
differences in a depth-first traversal
we begin at a particular node so we're
going to pick this one in the middle and
we're going to label at 0 we're gonna
pick a neighbor we haven't visited yet
let's say this one here and then we're
going to do a depth-first traversal from
that node so we're gonna continue down
the chain label this one and so on
if we run out of unvisited neighbors
such as here we pop back to a previously
visited node and continue well we don't
have any neighbors here either so we
might pop back here and now we're going
to continue with our other unvisited
neighbors so we might come here next we
don't have any more we pop back up they
might come here next four five six pop
all the way back up here now we might
come down to this one here move here pop
back up and then go 9 and 10 eventually
come back up to our original root node
we decide that there are no more
unvisited neighbors and then we complete
in a breadth-first traversal we're going
to begin with a node just as we did is
in a DFS and we're gonna pick the same
starting node but now we're gonna have a
different algorithm
so once we're at a particular node and
we're running a breadth-first traversal
what we're going to do is immediately
visit all the neighbors that are one hop
away before we do any descent at all so
first we're going to visit all the
neighbors that are one hop away only
then will we start to descend farther
past any of these neighbors now we'll
take the first one of these and we'll
visit all of its unvisited numbers that
are one hop away
well now we're complete here so now
we're going to go to number two we're
gonna do a traversal here we're complete
there we come back out to number three
we continue to traverse here so we go
one hop away and then pop back up now we
go to number four what are the ones that
are one hop away from number four
okay now we're at eight and so on one
thing you can notice here is that we
have a structure that we call a frontier
that forms the boundary between all the
nodes that we've already visited in all
the nodes that we haven't visited and we
see that as we continue our traversal
that's just going to expand the frontier
out and out and out again so we'll
complete this by going to number time
and then eventually to number ten now
which one of these is better well it
depends on the problem structure of the
graph what you're looking for if you're
able to make good decisions about which
way to go next
generally people will say that DFS
requires less state less temporary
storage to run but BFS on the other hand
exposes more parallelism during the
traversal and specifically because of
this parallelism quality today we're
going to look at how to do BFS on the
GPU</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>