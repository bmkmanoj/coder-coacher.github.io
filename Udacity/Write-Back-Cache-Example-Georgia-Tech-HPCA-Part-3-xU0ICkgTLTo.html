<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Write Back Cache Example - Georgia Tech HPCA Part 3 | Coder Coacher - Coaching Coders</title><meta content="Write Back Cache Example - Georgia Tech HPCA Part 3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Write Back Cache Example - Georgia Tech HPCA Part 3</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xU0ICkgTLTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's look at an example of how a
write-back cache would work say we have
a small for n 3 cache that this direct
map each line has a valid bit a tag and
a dirty bit we don't need the LRU
counter because in a direct mapped cache
we know exactly what to replace we don't
need a lot of counters to tell us that
let's say that the processor is doing
this sequence of accesses and a B and C
map to different sets in the cache the
first axis is right a so what we do is
we have a Miss all of our valid bits are
0 so it doesn't matter what the rest of
the cache has because none of the lines
are valid when we have the first right
to a we will bring a here we will change
the valid bit to one and we would change
the tag to correspond to a because this
is a right the processor as soon as the
data is brought in we'll write it and
the dirty bit will be set to 1 next we
have a read to a the processor checks
the tag and the valid bits is that the
tag matches a and the valid bit is 1 so
it can just use a the fact that the
dirty bit is 1 doesn't change anything
next let's say we have a read B we don't
find anything that matches being the
cache or maybe if this does the valid
bit is 0 so it doesn't matter so we will
have a miss and bring B into the cache
change the tag to correspond to be
change the valid bit to 1 to indicate
that we do have something here now and
because this is only a read the dirty
bit will be 0 next let's say we read C
it's a Miss bring C in change the tag
and the valid bit it's a read so the
dirty bit starts out at 0 next what we
have is a right to C we check if it's a
hit and it is we write only to the cache
and change the dirty bit to 1 and now as
you can see the dirty bit for every line
indicates simply was the line ever
written since it was last brought into
the cache
let's continue this by an axis to e that
is a read and let's say that a maps
where a is so now what needs to happen
is we're going to check here to see
whether the tag match is e it doesn't so
we have a Miss our replacement policy is
simple for direct map cache is we simply
replace whatever is there so at this
point we cannot just bring in Ephrem
memory first we have to take the data
for a that we have written and not
written to memory yet because the dirty
bit is one this block is sent to memory
is a right after that happens we can
bring e in set the tag and valid bit and
the dirty bit to zero because it's a
read and this continues on let's say
that now we have a read to F which
replaces B when we want to replace B we
check the dirty bit it's zero so B
doesn't get sent to memory it simply
gets overwritten with the data from F we
fetch and because this is a read we get
a zero here and so on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>