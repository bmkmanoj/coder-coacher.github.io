<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NP Equals Verifiability - Georgia Tech - Computability, Complexity, Theory: Complexity | Coder Coacher - Coaching Coders</title><meta content="NP Equals Verifiability - Georgia Tech - Computability, Complexity, Theory: Complexity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NP Equals Verifiability - Georgia Tech - Computability, Complexity, Theory: Complexity</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7E96m-QwQUY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Now for the more formal argument.
A verifier for
language L is a deterministic
Turing machine where L is
the set of strings w for
which there is another string c
such that V accepts the pair w, c.
In other words, for
every w in the language,
there's a certificate c that can be
paired with w, so that V will accept and
for every w not in the language L,
there's no such c.
It's intuitive to think of w as
a statement and of c as a proof.
If the statement is true,
then there should be a proof for
it that the verifier V can check.
On the other hand, if w is false,
then no proof should be able to
convince the verifier that it's true.
A verifier is polynomial,
if its running time is bounded
by a polynomial in
the length of the string w.
Note that this w is the same as
the one in the definition here,
it's the string that's a candidate for
the language.
If we included
the certificate in the bound,
then it becomes meaningless since we
could make c as long as necessary.
So that's a polynomial verifier and
we claim that the set of
languages that have polynomial
time verifiers is the same as NP.
The key to understanding this connection
is once again, this picture of
the tree of computation performed
by the nondeterministic machine.
If a language is in NP,
then there's some nondeterministic
machine that recognizes it.
Meaning that for
every string in the language,
there's an accepting computation path.
Now a verifier can't simulate the whole
tree of the nondeterministic machine
in polynomial time, but
it can simulate a single path.
It just needs to know which
path to simulate, but
this is what the certificate
can tell it.
The certificate can act as directions
for which turns to make in order to find
the accepting computation of
the nondeterministic machine.
Hence, if there's a nondeterministic
machine that can recognize the language,
there's a verifier that can verify it.
Now, argue in the other direction.
Suppose that V verifies a language,
then we can build a nondeterministic
machine whose computation tree
will look a bit like a jellyfish.
At its very top, we'll have a high
degree of branching as the machine
nondeterministically appends
a certificate c to its input,
then it just deterministically
simulates the verifier.
If there's any certificate
that causes V to accept,
the nondeterministic
machine will find it.
If there isn't one,
then the nondeterministic machine won't.</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>