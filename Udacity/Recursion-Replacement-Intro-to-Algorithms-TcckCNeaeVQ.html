<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Recursion Replacement - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Recursion Replacement - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Recursion Replacement - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TcckCNeaeVQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so one of the wonderful things about
depth first search is that it can be
implemented really straightforwardly
with recursion which makes it very easy
to read and pretty easy to reason about
not so with breadth first search
breadth-first search is going to require
a little bit more care to implement it
in a way that keeps track of things in
the right order so as a step towards
being able to do that let's redo
depth-first search just the way it was
done before but this time without
recursion and we're going to do the way
that we're going to actually make that
work is by introducing a new data
structure called the open list and the
open list I'd like to think of it as a
kind of a to-do list because it keeps
track of what it is I need to do next
and essentially I'm a slave to my to-do
list I have actually had students
occasionally add things to my to-do list
because I wouldn't know that I wasn't
supposed to do them and they get to me
to do things that I'm not supposed to do
so I would not encourage you to be quite
so short-sighted but algorithms actually
are going to be that short-sighted and
so this open list is going to help the
algorithm keep track of what needs to
get done so here's how we're going to do
it we're going to start all the nodes is
unmarked so they're all just nice
opening blue circles and we're going to
put P onto the open list and we're going
to follow this procedure here the
procedure says go to the to do list get
the let the the thing at the end of the
list that has to get done and do it the
way we're going to do it is we pull it
off the list then we go to all the
neighbors of the node that we're working
on which is P and any that are unmarked
we do two things to them we mark them
and we add them to the open list so the
neighbors of pee in this case RR s and Q
so we're going to add our s + q to the
open list and mark them all has visited
now we're done that process and we go
back to the beginning and do it again we
take the the ending little piece off the
to-do list and say oh q that's what we
have to do go to the graph find all the
neighbors of Q in this case just tea
market add it to the to-do list okay
we're done no we're not we have to go
back to the beginning and do it again
grab the top thing off the to do this
which is the tea check all its neighbors
Q and you only one of them hasn't been
visited and that's you we mark it add it
to the two lists and we repeat again
grab the last thing off the to-do list
which is you look at all
neighbors of you which are our S&amp;amp;T
they've all been marked nothing to do
yes there is there's still one more
thing on the to do this we have to get
the s take the S off the list check all
the neighbors of s you are p q they've
all been visited so we don't add
anything new to the two to-do list we
finish that iteration go back to the top
one more thing on the to-do list are
check our our has three neighbors PS and
you all of them have been marked we add
nothing to the do list to do to the to
the open list we see that there's
nothing left open and now we're really
done this procedure here performs just
like depth-first search it goes through
and in ads nodes in an order that has to
do with diving deeper and deeper into
the graph but it does it without any
recursion instead of recursion it just
has this open list to keep track of
things alright here's another graph that
we're in a search and this is going to
help us illustrate the difference
between depth-first search and breadth
first search so what we're going to do
is we're going to start a search from V
and let's see how it proceeds so we
start off V we mark v and our
instructions again say that we look at
all the neighbors of V W and Z mark the
unmarked ones Oh after we've removed be
on the list mark the unmarked ones had
the unmarked ones to our open list now
we take the first thing off the open
list which is the Z and repeat V is
already marked why is not add Y to our
open list now we work on why again we're
always working on the most recent thing
why says we have to check X and Z those
are the neighbors he's already been
marked X is not take care of X and then
just as before now that everything's
marked it's going to end up popping
things off the open list and it finishes
but if let's say let's look at the order
in which nodes were or marked this was
marked first then this then this and
this and this mostly the flow is in the
order of deeper and deeper and deeper</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>