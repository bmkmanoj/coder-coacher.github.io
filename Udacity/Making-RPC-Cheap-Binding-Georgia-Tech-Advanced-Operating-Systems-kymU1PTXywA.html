<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Making RPC Cheap (Binding) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Making RPC Cheap (Binding) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Making RPC Cheap (Binding) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kymU1PTXywA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so once the colonel gets all this
information from the server colonel gets
to work first of all it creates this
data structure on behalf of the server
and holds it internally for itself so
there's a native structure that is
entirely in the kernel and nobody else
has to see it it is only for the kernel
to know all the information that is
needed in order to make this up call
into the entry point procedure it also
establishes a buffer and this is what is
called the a stack
and this a stack size of the say stack
was just specified by the server as part
of this grant communication to indicate
how big this a stack has got to be
because the kernel has no idea what the
relationship is between the the client
of the server and so the server is
saying is telling the kernel that look
in order for us to communicate I need a
buffer and the size of the buffer is
this much so the kernel allocates shared
memory and takes the shared memory that
is allocated and maps it into the
address space of both the client and the
server so who the clients address space
is a service address space so in some
part of the client address appears in
the server address space need not be
exactly matching parts of the virtual
memory space of the client in the server
but somewhere in the address space of
the client of the server it maps this a
stack so essentially what we have now is
shared memory for communication directly
between the client and the server
without mediation of the kernel because
once this has been set up a shared
memory and mapped into the address space
of the server and the client
then the client can write into it so we
can write into it client can read from
it so we can read from it no mediation
by the kernel or in other words what we
have accomplished is we are getting the
kernel out of the loop in terms of
copying client in the server can
directly communicate the arguments and
the results back and forth using this a
stack and that's the reason it's called
a stack stands for argument stack that's
available for communication between the
client and the server so now the client
the kernel is done with all the work
that it has to do in order to set up
this remote procedure call mechanism
between the caller and the client and
the colleague which is a server and what
the colonel is going to do is it's going
to authenticate the client that you're
good to go
you can make calls on this procedure
food that has been exported through this
name server by the server so I let you
make calls on this in the future and
what you need to do every time you want
to make a call to s dot foo you have to
give me a descriptor which I'm going to
call the binding object video stands for
the binding object in the Western world
Bo has a different colloquial
connotation I won't go there but here Bo
stands for binding object and it's
basically a capability for the client to
present to the kernel that I am
authenticated in order to make this call
into the service domain is this
particular procedure called s not fool
so that's the idea so all the work that
I have described to you up until now is
the kernel mediation that happens in
terms of entry point set up on the first
call from the client on the first call
from the client all of this magic
happens in order to set up the
communication buffer between the client
and the server and authenticates client
that you can make future calls on this
particular entry point procedure by
providing or presenting to the kernel
this capability which is called the Bo
the binding object and of course the
important point is that the kernel knows
that this binding object and this
procedure descriptor are related or in
other words if the client is going to
present a binding object the colonel
knows from the binding object what is
the procedure descriptor that
corresponds to this binding object so
that it can find the entry point to call
into the server so once again what I
want to stress is the fact that this
kernel mediation happens only one time
on the first call by the client</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>