<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tree Barrier (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Tree Barrier (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tree Barrier (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9HjAVc9QHgA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so once these luxans flags have been
flipped then all of the processors that
have been waiting on these lock senses
our respective nodes they're going to be
released and everybody is now awake so
the tree barrier is a fairly intuitive
algorithm that builds on the simple
centralized sense reversal barrier
except that it breaks up this n
processors into K sized groups so that
they can all do spinning on a less
contentious set of shared variables so
that's good that it is a it's a
recursive algorithm that builds on the
centralized sense reversal algorithm and
allows scaling up to large number of
processors because the amount of sharing
is limited to K and so long as the K is
small like 204 then the amount of
contention for shared variables is
limited to to that number so that's
those are all good things about that but
there are lots of problems as well the
first problem that I want you to notice
is that the spin location is not
statically determined for each processor
so for instance if you take this
particular execution that I've shown you
in this picture
p0 happens to arrive later than p1 so p1
is the first to arrive here and so when
people arrived here a decremented count
and it realized that all the count is
not 0 I'm going to spin here and p0
arrived later and that's why it went up
to the next level and ended up spinning
on this locksense variable over here so
in another execution of the same program
it is possible that p0 arrives first
if p0 arise first then it'll spin on its
locksense variable that is in this data
structure and p1 will be the second guy
to arrive and therefore he'll be the guy
that move up and he'll be the guy
that'll be spinning on this locksense
flag
so the locksense flag that a particular
processor is going to spin on is not
statically determined but it is
dynamically determined depending on the
arrival pattern of all these processors
at our barrier and this arrival pattern
obviously is going to be different for
different
runs of the program since it depends on
the amount of code that is getting
executed and each one of these
processors and and other variables such
as how busy the processor is and so on
and the second source of problem is that
the airiness is a tree determines the
amount of contention for shared
variables I've mentioned that you know
here it is showing that there are two
processors but if you increase the
airiness of the tree to be care to be
something more than two maybe four or
eight or something like that and if you
have a large-scale multiprocessor with
with thousand processors the airiness of
the tree may be much more than two and
in that case the amount of contention
for shared data structures it's going to
be significant and that can result in
more contention on the network as well
the other issue with this tree barrier
is that it depends on whether our
multiprocessor that we are executing
this algorithm on is cache coherent or
not cache coherent if it is cache
coherent multiprocessor then you know
the spin even though it's on a
particular variable it could be encashed
in a private cache and therefore the
cache coherent hardware will indicate
when this spin variable changes value
but if it's a non cache coherent
multiprocessor the fact that the spin
variable that we have to associate with
a particular process is not static but
dynamic means that the spin may actually
be happening for p0 on a remote memory
remember I mentioned to you that one of
the styles of architecture is a
distributed shared memory architecture
sometimes the distributed shared memory
architecture is also called a
non-uniform memory access architecture
or Numa and the reason it is called Numa
architecture is because the access to
local memory for a particular processor
is going to be faster than the
processors access to a remote memory and
if you don't have cache coherence then
the spinning that has to be done has to
be done on a remote memory and that goes
through the network and so static
Association of the spin location of the
processor is very very crucial
if it's a non-cash coherent shared
memory machine so the next algorithm
that I'm going to describe to you is due
to the authors of the papers that we are
reviewing in this lesson which is
Merrick rummy and Scott and for this
reason that algorithm is going to be
called MCS barrier it's also a tree
barrier but you'll see that in the MCS
algorithm the spin location it
statically determined as opposed to the
dynamic situation that you have in the
hierarchical tree barrier here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>