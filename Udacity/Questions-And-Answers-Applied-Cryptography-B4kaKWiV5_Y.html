<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Questions And Answers - Applied Cryptography | Coder Coacher - Coaching Coders</title><meta content="Questions And Answers - Applied Cryptography - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Questions And Answers - Applied Cryptography</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B4kaKWiV5_Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to office hours for week two
what questions do it
Wolfgang Baltar's from the forums writes
asking about random Oracle's and wanted
to know more why about they're not
realistic in practice so this is a good
question we use random Oracle's and ways
to make it easier to reason about
cryptography and the definition of a
random Oracle is typically you've got
this magic black box that you can send
an input to in some range and you get as
output random value in the output domain
and for it to be a random Oracle that
value needs to be completely
unpredictable so we can think about
building something like this you could
have a lookup table where for every
possible input you've produced using
some good physical source of randomness
the output for that input and then you
would do the lookup and get that output
and that would behave like a random
Oracle that those inputs would be
totally random there's no correlation
the problem is if we try to make that
function any smaller so instead of
having a table where for every input we
can look up the corresponding output we
want something smaller and that's what
we want with a hash function that's we
want for any practical use of a mapping
between inputs and outputs and we can't
have a full table that would be just a
huge amount of memory and the random
Oracle it turns out to be a useful
device for reasoning about cryptography
where we assume that this black box
exists and has this perfect ideal
behavior it's not something we can
actually build and we have to be really
careful when we reason about
cryptography using this assumption about
a random Oracle and then we say throw in
a hash function that we think behaves
sort of like one because no hash
function actually behaves like a random
Oracle for our next question syed
Basheer wanders by looking at a
ciphertext is it possible to figure out
the encryption scheme that is used so
for most academic working cryptography
people assume they know everything about
the scheme being used and are trying to
find some mathematical weakness that
allows you to solve it quicker than you
could by doing a brute-force search on
the key space for a lot of real-world
cryptography that's not the case that
the first thing you've got to do is
figure out the scheme being used that's
sort of like the challenge question from
from home r2 where if I told you this
game for the RAM
generation it would be easy to figure
out the next one and that's more of a
better model for most cryptographic work
that academics do is assuming you know
the scheme trying to find mathematical
weaknesses in it for a lot of practical
cryptography certainly going back
further but even today it's not the case
that you know the scheme and if the
scheme is good then even if you know
it's one of a set of known scheme you
shouldn't be able to tell from the
ciphertext the ciphertext should be
purely random it should look like purely
random values so unless there's some
weaknesses in the encryption scheme used
you shouldn't be able to tell what it is
but there are weaknesses and all
encryption schemes used and this is
particularly issue if someone invents
their own encryption scheme they think
oh it's going to be super secure since
I've invented this custom scheme just
for my own use those schemes almost
always have weaknesses in them that even
if the schemes not knowing make it much
easier than breaking a known scheme
where the key is not knowing so it
should be the case that you can't tell
anything about the scheme from the
ciphertext in practice that's probably
not the case unless the scheme is a good
one yeah I guess this kind of goes back
to the importance of keeping your keys
secure
yeah so this this is going back to
Kirchhoff principle is you should be
able to have a cipher that even if the
adversary knows everything about the
scheme you're using as long as they
don't even know your key you have a good
argument why that's secure okay and then
I guess the last question comes from
Pavel has a question about invertibility
it's not obvious why encrypting
different messages with a fixed key
cannot give you the same ciphertext is
this necessary for correctness okay so
the question if you have two messages
that encrypt to the same ciphertext when
you try to decrypt them well you can't
know which one to get right so this is
why in order for a cipher to be
invertible we need to have the property
that each ciphertext corresponds to
exactly one input there are
probabilistic ciphers so there could be
more than one ciphertext that
corresponds to the same input under the
same key but it can't be the case that
the same input under the same key or it
can't be the case that they're multiple
inputs with the same key that mapped to
the same ciphertext because then when
you try to decrypt it even though you've
got the key you don't know which one of
those two
this was a input so we need this
property that each cipher tech can be
decrypted to exactly one message
otherwise decryption doesn't work</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>