<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Return Address Stack (RAS) - Georgia Tech - HPCA: Part 1 | Coder Coacher - Coaching Coders</title><meta content="Return Address Stack (RAS) - Georgia Tech - HPCA: Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Return Address Stack (RAS) - Georgia Tech - HPCA: Part 1</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EV0rFOJ5EGs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's talk about the return address
tag predictor or wrasse we have seen
that there are several types of branches
that we need to predict for conditional
branches we need to predict the
direction is it taken or not and by now
we have seen a number of predictors that
predict direction reasonably well for
these types of things if this branch is
taken we will need to also predict the
target address and for that a simple BTB
that just remembers the previous target
when the branch was taken will do just
fine because we always have the same
target
another type of branches are
unconditional jumps function calls etc
as far as their direction is concerned
it's trivial they are always taken so
even the simplest predictor of the
direction predictor type will do well on
these as far as the target prediction is
concerned most of these either jump to a
label or call a specific function so a
simple BTB that just remembers the
previous target when this instruction
was executed will do just fine so it
looks like we have handled both the
direction and the target for most of the
common branch types however there is a
type of branch specifically the function
returns which is always taken so the
direction prediction will do just fine
but the target is often difficult to
predict if this function is always
called from the same place then the
return will always jump back to the same
location and in that case the BTB will
do fine but usually we create a function
so that it can be called from multiple
places in the program something like
this we have an instruction that can
call this function somewhere else in the
program we have another instruction that
can call the same function this function
has a return instruction and now the
problem is that this return instruction
should either jump here or here
depending on where it was called from
the BTB in this case will not do too
well why well because when we call this
and return here the BTB will remember
that this is the target address then we
reach this point call again return we
should be returning
here but the BTB is predicting this so
we have a misprediction the BTB now
we'll learn that this is the correct
target next we come back to this code
again and again the PTB is predicting
here while we should be returning here
and then again and again so it never
predicts correctly so the question is
how can we predict returns accurately</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>