<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Running Time Using Big O Notation - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Running Time Using Big O Notation - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Running Time Using Big O Notation - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/GIgHVrr4CJE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now you've learned about the basics
of analyzing algorithms and we've
introduced three simplifications that
make our life going forward much easier
the first one was the RAM model so that
we can analyze algorithms without
actually having to implement them the
second one was the concept of worst-case
running time so only having to consider
the worst possible inputs and the best
ones not the average ones but just
really the bad ones and finally we
introduced Big O notation or lambda
notation to be able to ignore all
unnecessary details in algorithm
analysis so let's go back to the example
from before where we try to count the
number of times that the sequence a B
appears in the string of length n using
this algorithm down here and as you'll
remember from the quiz this was actually
quite painful because we had to figure
out what is a worst case input and we
noticed that this is actually not easy
to figure out and even if you have this
figured out there's a lot of detailed
counting that you need to do and there's
details you need to take care of such as
how often is this line here actually
executed and so on so now that we have
Big O notation available our task is
much easier because we can just make two
observations and we'll be able to state
the running time so the first
observation you can make is that the
algorithm will actually go through the
string one by one by one and since it
always just looks at a single character
and the next character the algorithm
will look at each character in the input
string at most twice and the second
thing to notice is that each time the
algorithm does consider a character so
it starts out at 0 1 2 3 and so on it
will perform a constant number of
operations so if it finds an a it will
do either one or two additional
operations and if it does not find an A
it will do 0 additional operations so
for each character in the input string
any constant number of steps is
performed and this is exactly the
advantage here because with Big O
notation we can ignore constants so
overall this means that if you have an
input of length n the algorithm will
perform a number of steps that is some
and times n plus some constant for all
the rest of the operations but using Big
O notation we already know that this is
low of n so we not do not need to care
anymore about the detailed number of
times this year is executed we do not
need to care about the details such as
how often this line here is executed we
can just say that the running time of
this algorithm is o of n which would
also be referred to as a linear
algorithm</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>