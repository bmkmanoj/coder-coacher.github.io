<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Traditional Approach - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Traditional Approach - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Traditional Approach - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/enAoKFrqZBs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the traditional approach which I'll call
the greedy approach and constructing the
severan hash table is when you want to
place a key value you pick a node n
where n is very close to key and now if
you want to retrieve a given key K the
algorithm you know is going to be you
want to go to a node n which is closest
to this key K because that is the
algorithm that is being used for placing
so for retrieval you just do the reverse
when you want a key K you go to a node
which is closest to key K that's how
these routing tables get populated at
different nodes in the distributed
system at the user level so the routing
table at a says that these are the known
peers to me whose node IDs I know and I
know their mapping of the node ID to the
IP addresses now the node space may be
much bigger than the number of entries I
have in my routing table so what do I do
if I want to communicate with a node
whose node ID I know but I don't have a
mapping for that node ID with respect to
the IP address basically the routing
table at every node is just saying these
are the nodes that I know how to
communicate with directly that is all
the nodes that are reachable from node a
because at the user level I have a
mapping between the virtual node ID that
is used in the DHT and the IP address
that corresponds to it
remember that IP address is the only
thing that the operating system is going
to understand and therefore I know how
to communicate with note 60 because I
can give the IP address that corresponds
to node 60 when I want to send a message
to note 60 similarly for 79 over here
node B knows how to communicate with 60
knows how to communicate with 109 and if
these are the only entries that are in
the routing tables of a and B these are
the ones to which node a knows how to
communicate directly what if I want to
go to some other node that is not
rolling table yet for example let's say
that I'm trying to retrieve a key 58 or
59 I know that 58 or 59 in terms of the
DST construction it's most likely stored
in some node whose ID is very close to
this key now in my table I have a node
ID 60 close enough to the key that I'm
looking for so what I'm gonna hope is
that if I'm looking for this particular
key 58 or 59 good chance that the key
value pair that corresponds to 58 or 59
is stored in this node ID 60 so that's
the one that I'm gonna communicate with
it's possible that 58 is actually stored
in a node ID 58 in which case my hope is
the desired destination that I wanted
each to is known to this pier 60 was
close to the node number 58 so in other
words if I want to communicate with low
number 58 my best bet is to communicate
with node number 60 with the hope that
60 may actually know how to communicate
with node number 58 because ultimately
I'm hoping that that's where this
particular key value pair may be
actually stored on the other hand if the
key that I'm looking for is 80 or 81
then I'll say well chances are this key
is stored in node ID 79 for whom I have
a mapping or if I go to him he might
know how to get to node number 80 which
may be actually storing the scheme 80
which may be actually storing this key
80 so in other words in the greedy
approach what we're going to do is in
placing a key value we're going to place
the key value pair at a node n where n
is equal to K ideally or close to K
similarly if I want to retrieve a key K
I'm gonna go to a node n where n is
either equal to
hey if I know how to get to it from my
routing table or get to a node that is
close enough to the desired n in this
case the desired n is 58 or 59 but the
one that I can get to a sixty and my
hope is that when I get to sixty he will
know how to get me to know number 58 or
59 or even better he may be the one that
is storing this particular key value
pair that corresponds to the key that
I'm looking for so in other words in the
greedy approach we are trying to get to
our desired destination as quickly as
possible with the minimum number of hops
to get to the desired destination and
when I say the number of hops it is at
the level of the virtual overlay network
not in terms of the physical network
because of the user level have no idea
how many hops my message may actually
take going from source to destination
all that we are saying is at the user
level we are trying to minimize the
number of hops to get to the desired
destination</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>