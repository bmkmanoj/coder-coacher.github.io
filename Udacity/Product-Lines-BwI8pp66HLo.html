<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Product Lines | Coder Coacher - Coaching Coders</title><meta content="Product Lines - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Product Lines</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BwI8pp66HLo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">like I can see that this might be useful
in the situation where you're dealing
with a potential customer and they have
they want to do some forecasting but
their needs aren't exactly what what
your existing system is if you want to
you want to get some idea of how much
work is going to be to produce a
brilliant for them is that can we use
these specifications to determine that
yeah indeed you can and in fact that's
that's that that's what we that's what
that exact problem is one of the things
that motivated us to to invest in in
this approach so if you look at the
slide you'll see hello world and
gutentag felt that those two assembly
specifications and you can notice a
couple things first off they have a lot
in common so gutentag veltri uses two of
hello world's components the BFC st and
malts components and it also uses both
of its refinements anchor and fcst where
they differ is also very clear to see so
the hello world has this I forecast and
this batch component whereas gutentag
belt has the DI forecast + batch of just
component and gutentag belt has this
mods and overrides component interface
respectively so you can see from this
just by comparing exactly what two
variants have in common and exactly how
they differ okay Kurt can you tell us
something about now that you've had some
experience with using layer box over the
last year or so about the benefits you
you've seen from its use so there are
several benefits that we we get from it
the the most obvious one is you get an
awful lot of code reuse I can try to
quantify that a little bit when we had
multiple different implementations of
these variants and we replace them which
is how we originally brought layer box
into into being we replaced them with
with a layer box based solution we cut
our code footprint by about five times
so it was a substantial amount of code
reduction that we got and this and
really like eighty percent reduction in
code base yeah that's fantastic eight
percent
production code base in addition you
know the virtue of it is it's designed
to do programming by generating variants
rather than writing one-off programs and
so that actually that approach and that
way of doing engineering actually helps
to scale much better to building large
complex software it just adds a
discipline on it now when developers are
working in this code base instead of
thinking about how to go right the new
method or or you know or make this new
tweak they think could I or should I
make this a different implementation of
an existing a different refinement of an
existing interface or different feature
yeah so you get a lot of simplicity in a
design by virtue of that we also you
know the scalability the whole approach
really owes to this idea of feature
refinements being so reusable as you saw
in the examples and there many more the
each of those you know little little
generators gets gets reused quite a bit
so you don't need that many of them and
you can build a pretty interesting and
rich library of of variance in addition
features if you design them by doing a
feature analysis are very very robust
abstractions in a domain and so they
tend to give you the kind of reuse that
that we get so if you couple a good
feature analysis with applying an
approach like this you're going to
you're going to have some good idea that
you're going to be able to get this kind
of reuse in a in a project and then
finally I think maybe the last big
benefit is it's really beneficial for
for understanding and for training so if
a new developer has to come on to a
project and they've never seen a
forecaster before but they have an
assembly spec which is something that's
pretty small you know just a just a few
lines and particular they see two or
three of them for different variants
they can very quickly get an idea of how
to sort of do a top-down stepwise
refinement of a of
of a variant from from as a sequence of
refinements of a very common
easy-to-understand program that turns
out have really nice understanding and
training benefits historically in
software engineering when a cogeneration
technology or a very general solution to
thing is proposed there's often a
performance hit in the generated code
that you have to trade off is that been
your experience here so ironically it's
actually been they up the opposite let
me try to explain why so we are we are
doing a lot of generation you're correct
but in fact because we're generating
variants that contain really only what's
needed they contain only those features
and only those capabilities that are
actually needed for given variant and
they don't have any extra cruft with
them that they have been running more
efficiently in fact when we replaced
these hand-written forecasters with ones
we generated from this library we saw
pretty dramatic performance improvements
just by reducing the amount of business
logic that we had to install into our
database and which of course then had to
always be running and calculating so in
our case it's actually been a we've seen
the opposite so a win win win win yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>