<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Photos | Coder Coacher - Coaching Coders</title><meta content="Cache Photos - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Photos</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nJmk39cD_HY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">some of the posts on Twitter have felt
was along with them we want to catch
those two at the moment were only
caching resources at install time
whereas the thought was appear over the
lifetime of the app with the posts so we
want to cache photos as they appear we
could put these photos in idb along with
the rest of the post data but that means
we'd need to read the pixel data and
convert it into a blob and that's kind
of complicated it also loses streaming
which has a performance impact when we
get an item from a database we have to
take the whole thing out in one lump
then convert it into image data then add
it to the page whereas if we get the
image from a cache it will stream the
data so we don't need to wait for the
whole thing before we display anything
this is more memory efficient and leads
to faster renders even if the data is
coming from the disk for that reason the
cache API is a much better fit but since
we're into the advanced stages of the
course I haven't made this totally
straightforward here's the code for the
image it's a responsive image because
images can appear a variety of different
widths this responsive image lets the
browser decide which image to load based
on the width of the window and also the
network conditions so when the poster
arrives through the web socket which
version do we cash well we wait until
the browser makes the request then we
hear about it in the serviceworker we go
to the network for the image and once we
get a response we put it in the cache
but at the same time we send it on to
the page note that we put the image into
a separate cash to the rest of the
static content we reset the content of
our static cash whenever we update our
JavaScript or CSS but we want these
photos to live between versions of our
appt next time we get a request for an
image that we already have cached we
simply return it but here's the trick
will return the image from the cash even
if the browser requests a different size
of the same image post on Twitter a
short-lived so if the browser requests a
bigger version of the same image
returning a smaller one from the cash
isn't really a problem returning a
bigger image then the one the browser
asked for that's perfectly fine too
we're not wasting bandwidth by doing
that in fact getting a smaller version
of something we already have cashed that
would be a waste of bandwidth
also this resizing windows back and
forth it's only really something web
developers do we've covered most of the
api's you need to be able to cash images
there's only one thing left to cover you
can only use the body of a response once
as in if you read the responses Jason
you cannot then read it as a blob this
is because the original data has gone
keeping it in memory would be a waste
also respond with uses the body of the
response as well so you cannot later
read it again in most cases this is
great because if the response was like a
free gigabyte video going to a video
element on the page the browser doesn't
need to keep the whole free Giga bytes
in memory it only needs to keep the bit
it's currently playing plus a little bit
extra for buffering however this is a
problem for our photos we want to open a
cache fetch from the network and send
the response to both the cash and back
to the browser using the body twice like
this doesn't work but we can fix this by
cloning the response we send to the cash
so now a clone goes to the cash and the
original gets sent back to the page the
browser keeps enough of the original
request around to satisfy all of the
clones</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>