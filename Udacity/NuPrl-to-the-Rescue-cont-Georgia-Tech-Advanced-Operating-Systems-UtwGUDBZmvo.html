<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>NuPrl to the Rescue (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="NuPrl to the Rescue (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>NuPrl to the Rescue (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UtwGUDBZmvo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the trick to this dynamic optimization
is recognizing what the state of the
protocol is at any point of time and how
the protocol has to react to an input
event whether then the event is coming
from the top or from the bottom how the
protocol has to react to that event is
the trick and this is what is called the
common case predicate CCP for short for
example if we receive a packet and the
state of the protocol says that if a
particular sequence number is received
then we are ready to deliver the packet
to the application if that is the state
of the protocol that is what is called a
common case predicate these common case
predicate are predicates that can be
derived from the state of the protocol
by looking at the conditional statement
so from the conditional statements in a
micro protocol that has been implemented
available to you we can actually
synthesize these common case predicate
and once these common case predicate
have been synthesized then we can say
well if that common case predicate is
satisfied then you don't have to go
through all the cruft
indicated by these multiple layers of
the micro protocols assembled on top of
one another
but instead we can do a much simpler
processing and that's what is called a
bypass code so in the dynamic
optimization once these common case
predicate have been identified by
looking at the conditional statements in
the micro protocol
dynamic optimization framework generates
this bypass code and inserts it into
this framework so I'm going to
complicate this picture a little bit now
so what we have is a common case
predicate for instance it says is the
sequence number in the packet what I am
expecting it to be is is this the
particular sequence number and if that
is the sequence number that I am looking
for then I can execute this bypass code
and completely eliminate all these
multiple layers of protocol and go
directly to the upper layer perhaps all
the way up to the application on the
other hand if it is not the common case
predicate that is being satisfied then
you have to do the normal processing of
giving the packet to this micro protocol
and
does its own thing and you can see that
this kind of framework can be applied to
every layer so you can take this is a
single layer and find out what the
common case predicate for this micro
protocol and use that common case
predicate to signify whether we want to
use a bypass code or whether we want to
go through the micro protocol and we can
collapse multiple layers like this and
derive a common case predicate that
collapses all of these layers into a
single predicate and if it is satisfied
then you can eliminate processing the
packet through all of these layers and
simply go through the bypass code to get
to the upper layers that's the beauty of
the dynamic optimization and is
completely automated and it comes from
the power of the theorem proving
framework of Nupur and the optimization
theorems that is in the Newport
framework proves the equivalence of the
bypass code to the layers of protocol
that it is replacing that's the beauty
of the Newport framework that in the
theoretical world of the theorem proving
framework we can actually prove through
optimization theorems that this bypass
code does exactly the same job as all of
these multiple layers of micro protocols
that would have processes message so
once we have done this dynamic
optimization and collapsing the layers
generating the bypass code starting of
course with the common case predicate
derived from the micro protocols then we
are ready to convert the optimized nuprl
code back to oh camel and again I
mentioned that there is a tool that have
that's available straightforward tool
that converts the new Perl code to the
Oh camel code and the final Oh camel
code that we generate through this
conversion process is the optimized
version of the original Oh camel code
and the theorem proving framework can
assert that the original unoptimized Oh
camel core is equivalent to the new
optimized Oh camel code because of the
power of the theorem proving framework
this is where we've sort of put together
theory and practice to get the best of
both worlds a word of caution however
there is a difference between
optimization and verification all that
the new poll framework is doing is
optimization not verifying whether the
Oh camel code is adhering to the
behavioral spec of io automata that's
not what this is being done what we are
doing here is saying that we take an
unarmed eyes oh camel coat and produce
an optimized Oh camel code and through
the theoretical framework we can assert
that the two are functionally equivalent
so this exercise has shown the path to
synthesizing complex system software
starting from specification to
implementation to optimization putting
theory and practice together</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>