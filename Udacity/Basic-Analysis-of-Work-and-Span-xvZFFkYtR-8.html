<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Basic Analysis of Work and Span | Coder Coacher - Coaching Coders</title><meta content="Basic Analysis of Work and Span - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Basic Analysis of Work and Span</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xvZFFkYtR-8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">here's the beauty of the span sync
framework you can analyze the work and
the span of algorithms in almost exactly
the same way that you do for sequential
algorithms so almost everything you
learned in algorithms 101 you get to
reuse here hooray
let me illustrate this by example here's
pseudocode for doing a sequential
reduction using divide and conquer if
this were CS algorithms 101 and we were
analyzing its running time we'd start by
writing down a recurrence relation and
then solving the relation so in this
algorithm we divide the work into two
pieces and do recursive calls and that
translates into a recurrence that looks
like this where we solve two subproblems
each one of half the size and you can
solve this recurrence in any number of
ways for example you can use the master
theorem what you'll find is that the
time is linear in n if you don't
remember what the master theorem is
we'll put a link in the instructors
notes okay so what about the parallel
version remember you want to analyze
work and span now let's assume that each
spawn and sink is a constant time
operation it turns out this is not a bad
assumption in practice now recall that
analyzing the work is just counting
total operations therefore a spawn and
sink are essentially a constant time
then if for the analysis we can
effectively ignore the spawns and syncs
and just do the usual sequential
analysis so the recurrence for work it
looks just like the recurrence for a
sequential execution time and we'll get
linear work okay that's pretty neat it
means algorithm analysis with respect to
work is no harder than it was for
sequential algorithms
okay what about span span is a little
different let me explain this by a
simpler example now remember that a
spawn creates a branch in the dag which
yields two paths the critical path will
be the longer of these two paths
therefore if I knew the length of the
paths going through a and the length of
path going through B then the critical
path would just be the longer of those
two mathematically we say the span is
the maximum of the span going through a
versus the span going through B now for
our divide and conquer reduction the
span only depends on the problem size n
and their cursive calls solve problems
of roughly equal size therefore when we
write down the recurrence for span we'll
get something that looks like this so
the recurrence in this case is just a
constant plus the span of n over 2 and
I'll let you solve this one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>