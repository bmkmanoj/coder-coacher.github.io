<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZEYzxFtN9XA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the absolutely indispensable element of
dynamic programming is what we'll call
an optimal similar substructure by this
I mean that we have some hard problem
that we want to solve and we think to
ourselves oh if I only had the answer to
these two similar smaller subproblems
this would be easy
and because the subproblems are similar
to the original we can keep playing this
game
letting the problems get smaller and
smaller until we've reached a trivial
case well at first this feels like an
ideal case for recursion since the
subproblems are similar perhaps we can
use the same code and just change the
parameters starting from this hard
problem we could recurse back to this
one and then to this one and so forth
using this whole sub graph here to solve
this sub-problem but when we recurse
through this branch we would come to
this node again and do all this
recomputation again which would be
terribly wasteful this is sometimes
called one of the perils of recursion
and it's often illustrated to beginning
programmers with the example of
computing the Fibonacci sequence each
number in the Fibonacci sequence is the
sum of the previous two numbers and the
first two numbers are 1 to get us
started this hard problem of computing
the nth number in the sequence depends
on solving the slightly easier problems
of computing the N minus 1 and the N
minus 2 elements in the sequence
figuring out n minus 1 depends on n
minus 2 as well as n minus 3 n minus 2
depends on knowing the answer to n minus
3 and n minus 4 and so forth thinking
about how the recursion will operate
here notice that we need to compute F
sub n minus 2 once for F sub N and once
also for S sub n minus 1 so there's
going to be some repeated computation
here and it's going to get worse and
worse the further to the left we go how
bad does it get well the top level
problem of computing the nth number will
only be called once and he will call the
F minus 1 sub problem once as well
computing F sub n minus 2 needs to
happen once for each time that the two
computations that depend on it are
called once for n minus 1 and once for n
similarly in mine
three needs to be called once for every
time that the subproblems that depend on
in are called twice for F sub n minus
two and once for F sub n minus one for a
total of three F sub n minus fourth it
gets computed once for each time that F
sub n minus three is called and once for
each time the F sub n minus two is
called for a total of five notice that
each number here is the sum of the two
numbers to the right so this actually is
the Fibonacci sequence and the number of
times that the n minus K the number is
computed will be equal to the K
Fibonacci number which is roughly the
golden ratio raised to the K power so
yikes this recursive strategy is
exponential of course computing the
Fibonacci numbers doesn't need to be
exponential we could just start on the
left here initializing the first two
numbers to 1 and 1 and then compute the
next one as the sum of the previous two
with a simple for loop there are two
ways to cope with this problem of
repeated computation one is to memorize
the answers to the subproblems after we
solve it the first time we write
ourselves a memo with the answer and
before we actually do the work of
solving a subproblem we always check our
wall of memos to see if we have the
answer already so for instance for this
subproblem here I would have memorized
it written myself a memo to remember
that I've already done it and so when I
come this path here I wouldn't redo all
this computation I just look up the
answer alternatively we can solve the
subproblems in the right order so that
anytime we want to solve one of those
problems we're sure that we have the
answer to its subproblems already this
can always be done because the
dependency relationships among the
subproblems must form a directed acyclic
graph if there are a cycle then we would
have a circular dependence and the
recursion one mark either so we just
find an appropriate ordering of the
subproblems so that all the edges go
left to right and then we solve the
subproblems in left-to-right order this
is the approach we'll take for this
lesson it tends to expose more the
underlying nature of the problem and
create faster implementations then using
recursion
and memorizing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>