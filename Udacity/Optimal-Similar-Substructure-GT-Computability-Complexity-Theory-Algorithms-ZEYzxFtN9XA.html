<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Optimal Similar Substructure - GT- Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZEYzxFtN9XA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the absolutely indispensable element of
dynamic programming is what we'll call
an optimal similar substructure by this
I mean that we have some hard problem
that we want to solve and we think to
ourselves oh if I only had the answer to
these two similar smaller subproblems
this would be easy and because the
subproblems are similar to the original
we can keep playing this game letting
the problems get smaller and smaller
until we've reached a trivial case well
at first this feels like an ideal case
for recursion since the subproblems are
similar perhaps we can use the same code
and just change the parameters starting
from this hard problem we could recurse
back to this one and then to this one
and so forth using this whole sub graph
here to solve this subproblem but when
we recurse through this branch we would
come to this node again and do all this
recomputation again which would be
terribly wasteful this is sometimes
called one of the perils of recursion
and it's often illustrated to beginning
programmers with the example of
computing the Fibonacci sequence each
number in the Fibonacci sequence is the
sum of the previous two numbers and the
first two numbers are one to get us
started this hard problem of computing
the enth number in the sequence depends
on solving the slightly easier problems
of computing the N minus 1 and the N
minus tooth elements in the sequence
figuring out n minus 1 depends on n
minus 2 as well as n minus 3n minus 2
depends on knowing the answer to n minus
3 and n minus 4 and so forth thinking
about how the recursion will operate
here notice that we need to compute F
sub n minus 2 once for F sub n and once
also for s sub n minus 1 so there's
going to be some repeated computation
here and it's going to get worse and
worse the further to the left we go how
bad does it get well the top level
problem of computing the enth number
will only be called once and he will
call the f minus 1 sub problem once as
well computing f sub n minus 2 needs to
happen once for each time that the two
computations that depend on it are
called once for n minus 1 and once for n
similarly and my
s3 needs to be called once for every
time that the subproblems that depend on
inter called twice for F sub n minus 2
and once for F sub n minus 1 for a total
of three f sub n minus fourth gets
computed once for each time that F sub n
minus three is called and once for each
time the f sub n minus two is called for
a total of five notice that each number
here is the sum of the two numbers to
the right so this actually is the
Fibonacci sequence and the number of
times that the N minus K the number is
computed will be equal to the Kate
Fibonacci number which is roughly the
golden ratio raised to the keith power
so yes this recursive strategy is
exponential of course computing the
Fibonacci numbers doesn't need to be
exponential we could just start on the
left here initializing the first two
numbers to one and one and then compute
the next one as the sum of the previous
two with a simple for loop there are two
ways to cope with this problem of
repeated computation one is to memorize
the answers to the subproblems after we
solve it the first time we write
ourselves a memo with the answer and
before we actually do the work of
solving a sub-problem we always check
our wall of memos to see if we have the
answer already so for instance for the
sub problem here I would have memorized
it written myself a memo to remember
that I've already done it and so when I
come this path here I wouldn't redo all
this computation I just look up the
answer alternatively we can solve the
subproblems in the right order so that
any time we want to solve one of the
problems we are sure that we have the
answer to its sub problems already this
can always be done because the
dependency relationships among the
subproblems must form a directed acyclic
graph if there are a cycle then we would
have a circular dependence and the
recursion one work either so we just
find an appropriate ordering of the
subproblems so that all the edges go
left to right and then we solve the
subproblems in left to right order this
is the approach will take for this
lesson it tends to expose more the
underlying nature of the problem and
create faster implementations then using
recursion
and memorizing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>