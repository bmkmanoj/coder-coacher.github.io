<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Algorithms To Boolean Formulae Solution - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Algorithms To Boolean Formulae Solution - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Algorithms To Boolean Formulae Solution - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sJC5mBFPKcg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so there's two true answers here and I
know this was a rather challenging
question but just imagine how
challenging it must have been for cook
and Levin when they figured this out for
the first time so first of all each
snapshot has size polynomial and n that
is true so why is that well first of all
we said the size of the input is a
polynomial of N or oftentimes it is n
but sometimes it can also be a
polynomial so for example when we have
when we are given a graph with n
vertices then there can be up to n
squared edges but in any case the input
is some polynomial of n now the size of
the algorithm or program here that is
constant because the algorithm doesn't
change with the input so we can assume
that this here has constant size no
matter what kind of input we are given
and then finally this is an interesting
one how much memory does our algorithm
need well it's an algorithm for a
problem in NP which means it takes only
a polynomial number of time steps and in
each time step it can only modify a
constant amount of variables so the
total memory that it needs is some
constant times the number of time steps
and since the number of time steps is a
polynomial of n the total space required
here for the memory is also a polynomial
of n so you have a polynomial of n plus
some constant plus a polynomial of n so
each single snapshot has size polynomial
and n now the second one I think that
was the easiest one to find out is of
course not true because we said we're
looking at a problem in NP we've even
written it down here on the left side so
we said the number of time steps must be
some polynomial because otherwise the
problem wouldn't be an NP and since
we're running on a non-deterministic Ram
we can assume that the number of time
steps here is bounded by some polynomial
so since there's only a polynomial
number of time steps there can also only
be a polynomial number of snapshots so
there cannot be an exponential number of
snapshots but this if you take it
together is well I don't know if it's
pretty cool but at least it's very
useful for the proof that we're trying
to do because if each snapshot has a
size that's polynomial in n and the
total number of
shots that we have is a polynomial then
you have a situation where you have a
polynomial number of polynomial size
snapshots which means that the size of
it all taken together is a polynomial
times a polynomial which again is a
polynomial so basically a complete
protocol of what this algorithm here is
doing given this input and using this
memory here the complete protocol only
takes up a polynomial amount of space
polynomial in n the size of the input
what I will now show you is how you can
encode a single snapshot so for example
this one here or this one here as a
boolean formula</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>