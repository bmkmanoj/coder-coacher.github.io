<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Digging Deeper From Spec to Implementation - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Digging Deeper From Spec to Implementation - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Digging Deeper From Spec to Implementation - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WF9o7pvNvyM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what I'm showing you here is sort of
a software engineering roadmap
synthesizing a complex system so what
we're going to do is first we're going
to go from specification to
implementation and this figure shows the
workflow in building a complex system in
particular what they focused on is a
tcp/ip network protocol stack using this
methodology of the design cycle that I
presented so we start with what is
called an abstract behavioral spec now
this is where we use this i/o automata
and this abstract behavioral spec is
where we describe the functionality of
the subsystem in terms of requirements
and we are presenting the high-level
logical specification of the components
and the specification is really talking
about the properties that we want the
subsystem to adhere to not how it is
going to be accomplished or how how it
is going to be executed but the
properties that it has to adhere to for
example in the protocol if we desire
that the package should be delivered in
order that's a property that we want for
that subsystem those are the behavioral
properties that you can express using
the i/o at emitter and other behavioral
specification properties that you can
have are things like well on every
packet there should be an acknowledgment
that's another property that you want
the protocol to have you can express
that using the I automata so the
abstract behavioral spec is simple and
lends itself to deriving properties
about the behavior of the system not the
execution but the behavior of the system
such as five phonus and so on it is not
executable code even though I told you
that the syntax of i/o at emitter is
similar to see it's not executable code
but the interesting thing is that once
you have expressed the abstract
behavioral properties you can actually
verify whether the behavioral
specification meets the properties that
you want in the subsystem so proving
that the behavioral spec meets the
properties is facilitated by the eye
automatical framework that's the nice
thing about this behavioral spec once we
know that the behavioral spec is meeting
the properties that we set out for the
subsystem then we are ready to roll our
sleeves and go down the path
implementing the behavioral properties
next step in that process is getting to
a concrete behavioral spec we get to
this concrete behavioral spec from the
abstract behavioral spec through a whole
set of refinements to this abstract
behavioral spec for instance the
refinement could be that if I have a
queue data structure
I want first-come first-serve property
how do I make sure that the abstract
behavioral spec adheres to the
dilutional execution condition that I
want a first-come-first-served those are
the kinds of things that I can do in
refining the abstract behavioral spec to
get a concrete behavior of spec this is
still not code but it is closer to code
than abstract behavioral spec it's
closer to implementation and from the
concrete behavioral spec we get to the
actual implementation using Oh camel as
the programming language and between the
implementation and the concrete
behavioral spec there is not a whole lot
of difference it is really the
scheduling of the operations that we
want in the concrete behavioral spec
that is being detailed when we go from
this step to the step in producing Oh
camel code which is finally an
executable code for the original
abstract behavioral spec that we started
with I already mentioned some of the
reasons why they chose a camel as the
implementation vehicle functional
programming language formal semantics
and it also leads to compact code
high-level operations and data
structures and also it has features like
automatic garbage collection automatic
memory allocation and marshaling a nun
marshalling of arguments this is very
important because I mentioned that we
are going towards building a complex
system from a specification using a
component based design approach which
means that we're going to take these
components and mesh them together just
like you take Lego blocks to build a toy
similar to that we are taking components
and meshing them together to get the
complex implementation and when we do
that we are necessarily going across
different components and when we go
across different components you have to
adhere to the interface specifications
of those components which means you have
marshal the arguments and unwashed
the arguments when you go between these
components and Oh camel has facilities
for doing these kinds of marshaling and
on marshalling built into the language
framework which makes it an ideal
vehicle for component based design and
also the program ability of a camel is
similar to C and the definition of the
primitives in O camel makes it a good
vehicle for developing verifiable code</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>