<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficiency of Binary Search | Coder Coacher - Coaching Coders</title><meta content="Efficiency of Binary Search - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficiency of Binary Search</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7WbRB7dSyvc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's start talking about the efficiency
of this algorithm with a new example
here we have an array with eight
elements and we're going to try and find
the number ten okay
so we'll want to start in the middle
this problem is a little bit weird
because there's an even number of
elements in this array so we could
either start with four or five really
when you're designing your algorithm you
need to decide from the start whether
you're going to err on the lower side or
the higher side when you hit this weird
case of having no real middle I'm gonna
go ahead and err on the lower side and
start with the number four just like
before we'll check whether our number is
bigger or smaller than the one in the
middle and since our number is bigger
now we only need to look at the second
half of the array again we have an even
number of elements in our array so we're
going to pick the number on the left of
the middle and start from there okay
since ten is greater than six yet again
we get to cut our array in half and deal
with just the top yet again we have an
even number of elements so we're gonna
err on the lower side and check there
first since 10 is greater than our
middle element seven we're left with
just the last element now and now that
we've checked the highest element in the
array and our number is still bigger
than it we know that this number doesn't
exist and we can move on since the time
efficiency is really just the number of
steps are going to need keeping track of
each iteration is going to help us
figure it out in the past we had to step
through every single element but here
we're cutting the array in half and only
considering some elements so the
efficiency isn't going to end up being
as big as Big O of n I've created a
table so we can take a good look at the
array size versus the number of
iterations of our algorithm as we just
saw we had to go through our algorithm
four times for an array size of eight
again we're talking about worst-case
here I could have tried to put a number
in between all of these places and on
the outsides to figure out what the
worst-case was just to save your time I
did that before recording this video in
the process I also discovered a trick
here if you want to make sure you're
checking for the worst case you can
an element that's bigger than anything
else in the array and when you hit this
weird middle case always favor the lower
side you should prove this to yourself
so you know that it works but just trust
me on it for now okay so for an array
size of 8 we have worst case four
iterations we can take the results from
the first example to there it took us
three steps to find something in an
array of seven mm let's start thinking
about different area sizes now if you
hadn't array size of one and you were
looking for an element say 30 it would
always only take you one step to see
whether that element was in your array
or not great that means we can add one
to our table let's say we have an array
with two elements in it and we're
looking for this number 23 again I'm
taking advantage of that trick I picked
a number bigger than the ones that were
in the array and when I have that weird
case I'm always gonna favor the lower
side and when my array has an even
number of elements I'm going to pick the
number that's on the left of the middle
since 23 is greater than 18 I can check
21 now in just two steps I have my
answer that 23 doesn't exist in this
array great we can add two to the table
now in the interest of time I'm not
going to go through all of these
examples you should definitely do them
yourself though to prove that these
results are true okay we're starting to
get a picture of our efficiency here I
noticed that four is half of eight so
maybe our efficiency looks something
like this again keep in mind that I'm
approximating here instead of counting
the number of overall steps in the
algorithm I'm just counting the number
of times I'll need to run the algorithm
in this case for when my n is 8 actually
I don't know that this is true since
half of 2 isn't 2 and half of 1 isn't
one that's too bad I really feel like 2
should go in this efficiency somewhere
since I have to cut the array in half
every single time I run the algorithm
let me think about exactly what that
means for a second if I cut the array in
half every time I go through an
iteration that means every time I double
the number of elements I need to do an
extra iteration actually now that I
think of
that actually looks true with the
results in my table every time my array
doubles in size it takes an extra
iteration of the algorithm to get
through it
actually when I represent these as
exponents I noticed that the power on
top of the two is always one more than
the number of iterations it takes
so maybe my efficiency looks more like
this the number of overall iterations is
going to increase every time the
exponent on the power of two increases
and of course it's only off by one how
do I get some number or expression that
represents this the power of two
exponent so this is what I'm starting
with
the number of elements in my array and I
want to end up with this number the
exponent well I remember some weird math
that I used to do a long time ago there
was this thing called a logarithm that
let me express this kind of function in
a different way instead of saying this I
could say log base two of eight equals
three and it means the same thing okay
so this looks a little bit nicer I want
to make a point to note that you don't
need to know a ton about how logarithms
work to understand this if you just
understand the equations I showed you
before you should be fine so we could
actually use another approximation to
make this look even nicer as I mentioned
before adding a constant or adding one
doesn't really change my efficiency very
much
also I don't really need to say that
this is log base two in computer science
it's actually pretty safe to assume that
your logs are in base two we often do
things like cut arrays in half or use
binary so our logs are normally going to
be in base two instead of the typical
base 10 so this is the efficiency that
we end up with a little later on we'll
have some more tools so it'll be easier
for me to show you visually why this
efficiency makes sense there's one thing
I want to make very clear to you all
right now when I was learning about
efficiency it often seemed like people
could just jump to this conclusion they
could just look at the original problem
and say of course this is log N
however after years of being a developer
I learned that that really wasn't the
case I found that there are three main
ways that people can get to this
efficiency one of them is just by
knowing what binary searches having seen
it before and being able to just
memorize the efficiency and spit it out
when you see it again
I highly recommend you just memorize the
efficiency of basic algorithms for your
interviews it'll make you seem really
smart if you can just spit out the
efficiency from the start however if
you're presented with a new problem and
you don't know the efficiency of the
algorithm already you need to be able to
solve it on your own one way you can do
that is with proofs I personally don't
like proofs and have never used them in
an interview or seen other people use
them in interviews if you want to learn
how to make proofs you can look it up
online and go read research papers and
see other people step through that
however my goal is to teach you the
practical approach to this when you
haven't seen the algorithm already and
you don't have time to whip up a proof
out of nowhere making a results table
like this is actually one of the best
things you can do creating a results
table helps you notice patterns it helps
you start thinking about efficiency in
terms of array size versus the number of
iterations of your algorithm when I
first started learning about efficiency
I needed tables like this to see those
patterns however after using tables for
a while I started to be able to see the
patterns on my own without them now when
I interview I know what types of
patterns are common like changes and
then powers of two and now I solve
problems way quicker and there are very
few problems that I can't at least
approach and try to solve the worst
thing you can do in an interview is say
I've never seen this algorithm before or
I don't know how to write a proof for it
if you're down on your luck and you
really don't know what the answer is
please make a results table and try to
figure it out your commitment to solving
the problem is really going to impress
your interviewer</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>