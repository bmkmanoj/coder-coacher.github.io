<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Counting Calls Solution - Intro to Computer Science | Coder Coacher - Coaching Coders</title><meta content="Counting Calls Solution - Intro to Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Counting Calls Solution - Intro to Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bqF8QuYX8YA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the answer is 13 and the reason for
this is quite interesting if you look at
the answers we were getting so far this
is the number of calls for each number
so when we had Thibeaux 36 the number of
calls was 1 when the input was 35 the
number of calls was also 1 when the
input was 34 the number of calls was 2
when the input was 33 the number of
calls with 3 when the input was 32 the
number of cult was 5 we should start to
notice a pattern this is exactly the
Fibonacci series that we're computing
here every time we decrease and by 1 so
to get the number of calls for 32 we
added the number of calls for 1 before
and the number of calls for 2 before and
if you look at the structure of this it
follows from the same rule that we had
thinking about the number of rabbits
reproducing that everyone that we have
on the previous level leads to two more
and that means as we do this addition we
have all the previous calls so we had
one call to 34 at the previous level
we're going to produce two new calls but
the inputs are different but if we look
at the way the inputs are distributed we
have 2 plus 1 here we have 1 plus 1 for
34 we have 2 plus 1 for 33 for 32 we
have 2 plus 3 we have 5 for 31 we're
gonna have eight calls and for 30 we're
gonna have 5 plus 8 which is 13 and this
will keep going these numbers will get
quite big very fast and the number of
calls that we need every time we
evaluate fit both 36 so to evaluate the
number of calls when we started with 36
that's going to be the result of fib of
36 minus n minus 1 so the number of
calls will need to fill go to in
evaluating fib of 36 will be 503 3 call
and we don't know what that number is
yet because when we tried to evaluate
Fibonacci 36 using our recursive
definition our evaluator timed out so
we're in big trouble
if we want to figure out how many calls
there are we need a more efficient way
of computing Fibonacci numbers so let's
see if we can do that and the reason
this was so inefficient is because we're
doing all this redundant work right we
saw that to compute Fibonacci 36 well we
had to compute Fibonacci 35 and we had
to compute Fibonacci 34 all of this work
computing Fibonacci 34 we did the same
exact thing over here right this is
producing the same output there's tons
and tons of redundant computation going
on so if we're going to compute this
more efficiently we don't want to
duplicate all that work we need to do it
in a way where we don't need to keep
recomputing the same thing so the
solution to this is instead of using a
recursive procedure to compute Fibonacci
we're going to compute Fibonacci using a
while loop anything that we can define
recursively we can also define without
using a recursive definition it's often
much easier and cleaner to think about
things with the recursive definition but
it's often not the fastest way to
calculate things and certainly in this
case because of all the redundant
computation it's a very very inefficient
way to calculate Fibonacci so let's try
it to do this with a while loop instead
and we'll make that a quiz</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>