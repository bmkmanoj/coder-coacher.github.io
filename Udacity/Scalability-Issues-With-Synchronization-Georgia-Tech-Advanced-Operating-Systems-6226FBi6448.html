<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalability Issues With Synchronization - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Scalability Issues With Synchronization - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalability Issues With Synchronization - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6226FBi6448" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's discuss some of the issues
with scalability of the synchronization
primitives in a shared memory
multiprocessor now we already saw that
locks both mutual exclusion as well as
shared lock is one type of
synchronization operation and we also
saw that barrier algorithms is another
type of synchronization operations and
when you look at both of these guys both
of these types of synchronization
primitives that a parallel operating
system is going to provide for
application program are developing
multi-threaded applications the sources
of inefficiencies that come about is
first of all latency what do we mean by
that well if this thread wants to
acquire this lock it has to do some
operation as you go to memory get that
lock and make sure that nobody else is
competing with it and so that's the
latency that is inherently what is the
time that is spent by a thread in
acquiring the lock that's what we mean
by latency or be more precise what we
mean is that latency is saying lock is
currently not being used how long does
it take for me to go and get it that's
really the key the question that latency
is is trying to look at the second
source of scalability with
synchronization is the waiting time and
that is if I want to go and get the lock
how long do I wait in order to get that
lock well clearly this is not something
that you and I as the O's do that
designer has complete control over
because it really depends on what these
threads are doing with this lock so for
instance if this thread acquires this
lock and and then it is modifying the
data for a long time before releasing it
and if another thread comes along and
wants that same lock it's going to wait
for a long time so the waiting time is
really in the purview of the application
and there's not much you can do as an OS
designer in reducing the waiting time
the third source of unscalable 'ti of
locks is contention what we mean by that
is if currently some guy is using the
lock and he releases it when the lock is
released it's now up for grabs
maybe there's all I've shown you only
two
one thread here but maybe there's a
bunch of threads waiting here to access
this particular luck if they're all
reading two accesses luck they're all
contending for this lock and how long
does it take in the presence of
contention for one of them to become the
winner of the lock and the others to go
away so that's the contention part of
implementing a synchronization primitive
and all of these things latency waiting
time and contention even though I
mentioned in the context of their mutual
expression lock appears when you're
talking about barrier synchronization
algorithms or shared locks so latency
and contention are two things as always
designers we have to be always worried
about in implementing scalable versions
of synchronization primitives</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>