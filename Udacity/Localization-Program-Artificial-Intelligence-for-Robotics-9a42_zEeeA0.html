<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Localization Program - Artificial Intelligence for Robotics | Coder Coacher - Coaching Coders</title><meta content="Localization Program - Artificial Intelligence for Robotics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Localization Program - Artificial Intelligence for Robotics</b></h2><h5 class="post__date">2012-03-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9a42_zEeeA0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is our first programming assignment
in class we localize the robot in a 1d
world with the number of grid cells
where each grid cell could have a
different color in the measurement
vector was a sequence of observations
our world was cyclic if he fell off one
end we will continue at the other end in
this assignment I want you to do the
same for 2d worlds of arbitrary
dimension just as before begin with the
uniform distribution as you always do in
global localization and then we have a
number of motion commands zero comma
zero is no move zero comma one means you
move to the right zero comma minus one
means move left one comma zero makes you
move down not up and minus one comma
zero makes you move up again the world
shall be cyclic if we fall off one end
like over here we continue at the event
like the one over here so here's a
simple example of the type code I give
to you as a specification of the problem
and then you have to compute what my
code computes but that you can't see
right now the world in this specific
instance is a three by three matrix
three rows three columns it has only two
possible colors green or red and this
specific world has only a single red at
the center location over here we have a
motion vector and a measurement vector
we start with the motion this one says
stay in place and this one says we're
gonna observe red and additionally I
gave you two more variables called
sensor right and P move sensor right is
the probability that this sensor
measurement is correct in this specific
instance I set it to one point zero
which means the sensor value is always
correct P move tells you at what
probability the motion is executed
correctly right now it's one point zero
it's always correct it was a smaller
value then the motion might fail and
when it fails robot won't move at all
so this is execute this here we didn't
move
we observed red and we had a noise free
sensor and as a result you get a matrix
that said zero everywhere except it's
one at the center location that has a
red color let's modify the world let's
make this grid cell over here red as
well and then now let's just rerun the
code and what we get is a matrix just
like the previous one but now we have
two winning grid cells both of which
have a 0.5 probability so that all the
probabilities add up to 1 let's now
model a noisy sensor and set sensor
right to 0.8 your code should now
compute the following is 0.06 for almost
all grid cells except the two winning
ones which come in at point two six and
point two six each so check that your
code does this let's now bring in some
motion after not moving at all I assume
you're gonna move one to the right and
we always have to have as many
measurements as motions so let me add a
second measurement let's say V sends red
again intuitively this lenses are the
square over here why well we didn't move
in the beginning we saw red there's two
possibilities but now we move again to
the right side we see red again that
makes this cell over here the most
likely so let's just check and as
predicted almost all cells have a
probability of 0.03 sum of 0.1 3 but the
one over here has a probability of 0.5 3
3 3 if you set our sensor probability to
1.0 there is there's no sensor noise we
get back this array over here which
assigns all probability to the rightmost
cell finally I want to show you what
happens if we modify the move variable
say our motion succeeds only with 0.5
probability and with the remaining point
5 we remained at the same location this
doesn't affect the first motion command
because success and failure is the same
thing here we don't move but this one
over here there's a 50% chance of moving
in a 50% chance of staying at the same
location let's run the code here's our
posterior probability the cell on the
right still wins but now with a smaller
total probability of just 0.46 if you
now assume perfect centers by setting
sensor right to 1.0 we get this thing
over here we are point six six chance is
associated with the right cell over here
and 0.33 with a possibility that we
moved this specific red here twice by
just not moving in between check your
code to make sure it gives you the exact
same operas all finally I want your code
to execute input as complex as this one
this is a four by five world four rows
five columns over the Reds or greens
there's only two colors there is a
sequence of measurements of five
elements and correspondingly a sequence
of motions of five elements all the
measurements are green the motions are
don't move at all move right move down
move down and move right again and then
there are certain sends the
probabilities and motion probabilities
that I can set it well I set it to point
seven nine point eight over here now if
we look at the sequence Green Green
Green Green Green we first don't move at
all then move right down down right you
find that the most likely match in this
world is we first sends the screen over
here we then moved right to this screen
we move then down to this screen further
down to this green by two the screen
over here so this would be the cell with
the largest posterior probability it is
the third row and the fourth column
let's run it and here's the result it's
somewhat illegible and apologize for the
poor formatting of my Python routine but
if we look for these probabilities zero
point zero one one zero point zero two
four and so on you'll find that indeed
the largest element is the one over here
0.35
five three five and is one two three or
third roll you know a fourth column that
gives me this large probability so I
want your code to produce numbers just
like those and we'll check that you got
the code correctly in summary read your
colors build a probability distribution
of the same dimensions in this case four
by five initialize them with the uniform
distribution execute a motion first and
measurement motion measurement motion
measurement measurement and so on you
can safely assume that the measurement
vector is of the same length as the
motion vector using those measurement
correctness probability and motion the
success probability and then compute an
output just the final distribution if
you've done this you'll succeed</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>