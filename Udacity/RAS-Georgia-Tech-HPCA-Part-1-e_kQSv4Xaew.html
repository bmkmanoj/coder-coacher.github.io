<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RAS - Georgia Tech - HPCA: Part 1 | Coder Coacher - Coaching Coders</title><meta content="RAS - Georgia Tech - HPCA: Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RAS - Georgia Tech - HPCA: Part 1</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/e_kQSv4Xaew" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and the answer is we will use a return
address stack which is a separate
predictor dedicated to predicting
function returns the way it works is
that we have a small stack in hardware
with a pointer as we execute the program
when we have a function call we will
push the return address in this case one
two three zero is the address of the
call so one two three four would be the
return address to the return address
stack have moved the pointer in the
function when we encounter the return
instruction we will pop from this return
address stack and use the one two three
four to return and in that case get the
correct target address now our pointer
is here we don't really have to delete
this entry because the pointer being
here means that it's free next when we
reach the next place where the function
is called from we will save the return
address in this case one two five four
onto the return address stack the
function executes when we see the return
instruction we pop the return address
and we again predict correctly so why is
this a predictor why not just use the
actual stack of the program well because
this predictor needs to be on ship very
close to where the rest of the branch
friction is happening and needs to be
very very small so unlike your
traditional stack where you will push
something onto the stack call another
function from there : a state function
and you can do that many many times
until you run out of memory in this
particular case we can have a very small
Hardware structure so that it can make a
prediction very quickly like in one
cycle thus it can only have a limited
number of entries so what happens when
we exceed the size of their ass let's
say we have only four entries let's say
that we call a function call another one
we call another one we call another one
and now the question is what do we do so
if our ass is full what do we do
there are really two choices one don't
push anything pretty much preserve what
we already have on our rest so that we
don't overwrite anything the other
choice is once we have filled these four
entries just wrap around and keep
filling them if we call more function</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>