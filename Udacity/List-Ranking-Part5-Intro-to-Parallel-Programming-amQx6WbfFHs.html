<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>List Ranking Part5 - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="List Ranking Part5 - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>List Ranking Part5 - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/amQx6WbfFHs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now the second phase of this algorithm
uses this table to construct the output
order what we're looking to generate is
the list of nodes in order and we
computed this before
we see it over here 0 5 2 7 4 9 1 6 3 8
and remember we can get that by using a
serial algorithm just to convince
ourselves that it's correct
we start at nodes ero its successor is 5
the successor to 5 is 2 the successor to
2 is 7 and so on to generate this answer
each node is going to compute its
position in the output list and we're
going to call that position out pause
and then we're done we can use that
position to scatter the node into its
proper location in that output list so
just to understand what out pause is
going to look like we see that node 0
ends up at location 0 in the output list
so out pause better be 0 node 5 ends up
at the first location in the output list
so what's going to get out pause equals
1 node 2 is next and then node 7 and so
on so this is what we're trying to
compute here
we're trying to compute out pause so
when we start this all we know is that
node 0 is in position 0 so we can fill
in that out pause right away now that
node 0 has calculated where it will end
up in the output we're gonna consider it
awake but all the other nodes are asleep
a node is awake if it is filled in its
value 4 out pause otherwise it's asleep
so now we're going to do several
iterations of an algorithm that will
eventually wake up all the nodes and
calculate their output positions so on
each iteration we're gonna launch n
threads one per element here but if a
thread is asleep we immediately return
from that thread only awake threads do
any work at all so for the first
iteration node zero wants to wake up its
successor so how does it find the
successor well it can just look in this
plus one array to find its immediate
successor and so we can immediately see
that's node number five so where will
node number 5 write its output that's
what we need to fill in here for out
pause it knows that it's coming after
node number 0 right here and it knows
that it's coming one hop past node
number zero so we can add these two
values together to see that node number
five will write its output to position
number one in the output array and so
now we have two nodes that are awake
node 0 node 5 so now both awake nodes
are gonna wake up another node and help
those nodes calculate their output
position so now instead of looking at
the immediate
accessories plus one we're gonna look at
the next line plus two and we're gonna
use this to find the nodes to away from
each of our awake nodes so node zero is
going to wake up node number two so node
zero is going to wake up node number two
and so where does know to write its
output
well it'll be the sum of where node zero
is at output location zero and we know
we're two hops away so when we add those
two up we know that node 2 will be
written to position number two
similarly node five is going to wake up
the node that's 2 hops away in this case
node seven where will node 7 write its
output it knows that it will start from
node number five at position number one
and then we'll add two hops to that and
get position number three on the next
iteration we're gonna use the next line
of the array the plus four right and
each of the four awake nodes from output
position zero one two and three will
wake up the node that's four hops away
this will allow us to fill in for more
values into the out pause array node
four will get position number four node
9 gets position five node one gets
position six and node 6 gets position
seven and the final iteration using the
plus eight array lets us fill in node 3
as out applause 8 and node 8 as out
pause 9 so the final step is to use out
pause to scatter the nodes to their
destinations let's see how that works
we're going to start by looking at the
first node and we know that node 0 is
going to end up in output position 0 so
we will scatter this 0 to output
location 0 and write the 0 the next node
node number 1 is going to end up in
output position 6 the next node node 2
will end up directly in output position
2 and so after we do all these scatter
operations we come up with the nodes in
the correct order so as a function of n
how many steps does this take fair root
of n log in N or N squared</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>