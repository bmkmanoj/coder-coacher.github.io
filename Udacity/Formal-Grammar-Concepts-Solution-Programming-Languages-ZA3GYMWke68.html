<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Formal Grammar Concepts Solution - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Formal Grammar Concepts Solution - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Formal Grammar Concepts Solution - Programming Languages</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZA3GYMWke68" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this first question asks us to make a
few statements about formal grammars
let's go over a little bit of vocabulary
a language is simply a set of strings a
regular language is a type of language
in particular it's a set of strings that
can be represented by a finite state
machine or a regular expression a
context-free language is also a set of
strings but can be represented by a
context-free grammar and what these
three questions are asking us in this
problem is to determine the relationship
between a regular language and a
context-free language so let's say this
bubble represents the set of regular
languages it's a set of sets of strings
and let's say this blob is the set of
context-free languages what we wanted to
determine is how we can connect these
two is it the case that no regular
languages are context-free languages and
vice versa or perhaps there are some
regular languages that are not
context-free there are some context-free
languages that are not regular but there
are some languages that are regular in
context-free and the last two
possibilities are that all regular
languages are context-free and vice
versa
this kind of looks like a pacman as it
turns out this diagram is the correct
one all regular languages are
context-free but not all context-free
languages are regular briefly in lecture
wess outline the proof that all regular
language is a context-free the way the
proof works is that you show that given
an arbitrary finite state machine you
can create a context-free grammar that
embodies it that represents the same
functionality namely it generates the
same exact set of strings and to show
that there are some context-free
languages that are not regular we just
have to come up with an example an
example of this is the set of matching
parentheses as it turns out and I'm not
going to prove here you can't represent
this language with a regular expression
that's because you can't count how many
times you see a left parenthesis and
then require that you see that exactly
that many right parenthesis there's just
no form of counting in a regular
expression you can't hold that much
state so given that review let's go over
the actual questions if a language
is regular then that language is also
context-free this is always true because
we have a pacman diagram here and also
because you can take any regular
language and represent it with a
context-free grammar you can take any
finite state machine and represent it
with a context-free grammar if a
language L is context-free then that
language L is also regular this is
sometimes true if for we have a regular
language that language is context-free
and well it's also regular so we have a
case where sometimes a context-free
language is regular the question is is
this always true and the answer is no we
have a context-free language such as the
mastering parenthesis I went over before
this is a language that's context-free
but it's not regular so sometimes the
statements true and sometimes it's not
if two context-free grammars G 1 and G 2
both accept an infinite number of
strings then they accept the same
strings this is sometimes true let's
think of a couple examples well there's
a straightforward example that shows
that this is a statement that can be
true and that is when G 1 and G 2 are
the same grammar let's say we have two
language ba that West likes to use in
many examples we have BA all right so we
have BA let's say we have the grammar G
2 and you know what let's make it the
same exact language I have 2 grammars
both except in different number of
strings they happen to be the same
strings so the statements sometimes true
we didn't say do you want in G to ID to
be unique you could also come up with
examples where G 1 and G 2 are different
but they're same exact strings so you
can do and you also note I used a
regular expression for my grammar but
all regular languages are context-free
so this is perfectly acceptable
so let's come up with a situation where
this isn't true let's change G 2 so that
instead of BA it's far so we got far and
far I don't know
a lot of it these are both infinite
infinite
the regular expressions therefore the
context-free but they don't accept the
same strings so we've come up with a
case where this can be true we come up
with a case where it can be false so
we're going to say it's sometimes true</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>