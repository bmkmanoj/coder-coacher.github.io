<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Object Invocation Across the Network - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Object Invocation Across the Network - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Object Invocation Across the Network - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/blYTia8r3s8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as I mentioned spring is a network
operating system so what I described to
you just now is how object invocation
works within a single node but these
doors are confined to the nucleus on a
single node and we need to be able to do
object invocation across the network the
client domain may be over here and the
server domain may be on a different node
on the local area network object
invocation between client and server
across the network is extended using
network proxies for example on the
client box there is a proxy B and on the
server box there is AZ proxy a and
proxies can be potentially different for
connecting to different servers so this
client may talk to this server using
this proxy and may talk to a different
server which I'm not showing here using
a completely different proxy or in other
words the proxies can potentially employ
different protocols that's where you
have the opportunity to specialize
whether the communication that's
happening between the client and the
server is on the local area network or
on a wide area network and so on
depending on that you can employ the
protocol that is appropriate for use in
the proxy so this is a key property of
building a network operating system and
son where they wanted to make sure that
decisions are not being ingrained in the
operating system of a single node in
terms of the connectivity of that node
to other nodes on the network depending
on where the service for a particular
client is going to be obtained that is
where the location of the server is you
can employ different protocols to talk
between the proxies that are on the
client machine and the server machine
and also the proxies are invisible to
the client in the server
in other words the client in the
server's are unaware whether they are
both on the same machine or in a
different machine and they don't care
let's see how this client-server
relationship is established using these
proxies so when a client server
connection has to be made across the
network the first thing that happens is
you instantiate a proxy
the server node and established a door
for communication between the proxy a
and the server domain through the
nucleus on the server machine and now
what this proxy is gonna do is to export
a network handle embedding this door X
to its peer proxy B that is on the
client domain and see that this
interaction that's going on between
proxy a and proxy B is outside of
anything that isn't the purview of the
nucleus so the network handle that is
being established has nothing to do with
the primitives of the mechanisms that
are available in the nucleus of the
spring system so what proxy a is doing
is to create a network handle embedding
this door X and it is going to export
that to this proxy B and proxy B has a
door that it has established locally our
nucleus B so that the client domain can
communicate with it
and now what proxy B will do is it will
use a network handle that has been
exported by proxy a to establish a
connection between the two nuclei so
this network handle and the
communication that goes on between these
two guys is not through the nucleus
that's important for you to understand
so now how does the client make an
invocation on the server domain
well when the client wants to make an
invocation it thinks that when it is
accessing door why it is accessing the
server's domain but it isn't what it is
what it is accessing is this proxy B and
of course access to this door Y which is
an proxy B is blessed by nucleus B and
when this invocation happens proxy B
then is going to communicate through
those network handle that it has with
its peer proxy a and the peer proxy a
when it gets this client invocation
proxy through this proxy B and arriving
at proxy a will know that oh this is
really intended for the server domain
and I know how to access that through
the door that I have in the server
domain and it uses the door it has in
the server domain
in order to make the actual invocation
so to recap what is really going on the
client wants to open the door X it
doesn't have a direct handle on door X
because server domain is in a different
node of the network and therefore the
way remote invocation is accomplished is
by the server domains door which is the
entry point into the server domain is
passed on by this proxy via a network
handle to its peer proxy on a different
node in this case the client node and
once this network handle is available to
proxy B it can establish the connection
between these nuclei and once this
connection is established then the
client domain it thinks it is making an
invocation call for door X but in fact
it is being passed through door Y to
this proxy and the proxy uses a network
handle to communicate that invocation
over to proxy a which then uses the
actual door that will open the
invocation call on the server domain and
execute the client domains call</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>