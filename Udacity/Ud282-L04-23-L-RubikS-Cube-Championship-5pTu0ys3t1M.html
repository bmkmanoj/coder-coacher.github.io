<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ud282 L04 23 L Rubik'S Cube Championship | Coder Coacher - Coaching Coders</title><meta content="Ud282 L04 23 L Rubik'S Cube Championship - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ud282 L04 23 L Rubik'S Cube Championship</b></h2><h5 class="post__date">2016-08-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5pTu0ys3t1M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">just under one minute but that's far
from impressive compared to how long it
takes for any of the world champions to
solve it speed cubers can actually solve
the rubik's cube in under 10 seconds it
requires a lot of practice and
memorization and really fast fingers
this is an example of some of the
fastest times officially recorded can
you find the fastest person on the table
Lukas at her a 14 year old from Kentucky
US and he has the world's largest record
in 2015 for the fastest time to solve a
Rubik's Cube breaking the five-second
barrier for the first time ever but
let's go back to the leaderboard here
I'd like you to think about how you
found the fastest player I know that
sounds very intuitive for us humans but
what if we wanted to write a function
that finds that smallest number in an
array like this so let's have a look at
how our brains actually work when we're
searching for the smallest number in a
list of numbers like the leader board
for example here I have this array of
doubles called speed that has these
numbers in it index from 0 all the way
to 6 to find the smallest number here I
just have to go through them one by one
and just only remember the smallest
number I've seen so far I'll store the
smallest number I've seen so far in this
variable called min for minimum let's
start from the very beginning the very
first value is seven point eight five
and that's the smallest we've seen so
far so that goes into our minimum
variable and then we move one and the
second value is seven point three two so
I asked this question is speed of one if
there's this cell here smaller than our
minimum yes it is
so I update the minimum to get the new
value in it seven point three two and
then I move on and then I ask myself
this question again is speed of two less
than the minimum speed of two here is
four point nine and the remember seven
point three two yes it is
so I update them in
with that new value here 4.9 moving on
and then I asked the question again is
speed of three less than minimum speed
of three is six point two two and
minimum is four point nine
so obviously it's not less than it
anymore so I don't update minimum I move
on and then I get five point four five
point four is not less than four point
nine so I continue to move on and then
seven point three is not smaller than
four point nine so I continue moving on
five point one nine is also not smaller
than the minimum so I end up going
through the entire array and the minimum
value that I found was four point nine
what we've just done here is called an
algorithm it's basically following a
systematic number of steps until we find
the correct solution we want thinking
that way helps us writing code so let's
see how we can implement this in Java
assume we want to write it in a function
like so a function called search that
accepts the parameter an array of
doubles called speed and returns a
single double that is the fastest or the
smallest value in this array so the
parameters is the speed array which is
an array of doubles and it returns a
double which is the fastest speed found
I'll just leave this here as an example
for us to trace later the first thing we
need to do is get the length of our
array and throw it into our variable
called size any array dot length
calculates how many cells is in that
array and returns an integer number of
that value in this case our size is
actually seven because we have seven
cells in our array the next step is to
create this variable called min which
remembers a smallest number as we go and
we're going to initialize it to the very
first item in our array which is speed
of zero so after this instruction the
variable min would have seven point
eight five in it if there was another
array passed in as a parameter then it
would just grab whatever value is in the
very first
item then we actually need to use a loop
so that we can iterate over this array
our loop counter is initialized to 1 and
our condition is I less than size that
means that our counter would count up
from 1 all the way until just before it
reaches size and the increment is just I
plus plus which means we're adding just
one every time the reason we start from
1 is because we've already assigned
minimum to the very first item so we
need to start comparing from the item
with index 1 all the way till the end
which is size so what do we do inside
the loop we ask ourselves the question
is this value at that particular time in
the loop smaller than our minimum value
we do that with an if condition that we
say if speed of I is less than minimum
speed of I is pointing to a particular
cell in the array depending on the value
of I so it starts by pointing at this
particular cell and then it moves on to
this one and so on and each time we're
comparing it to minimum if it is smaller
than minimum then we update minimum to
get that value inside speed of I once
our loop is complete which means that
we've visited every single cell in the
array we can just return minimum because
at this point of time we're certain that
minimum would have the smallest value in
the array</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>