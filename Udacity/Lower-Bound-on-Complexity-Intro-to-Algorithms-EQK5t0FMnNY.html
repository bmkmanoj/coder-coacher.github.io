<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lower Bound on Complexity - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="Lower Bound on Complexity - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lower Bound on Complexity - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EQK5t0FMnNY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well it turns out all these are sort of
right you really do need to give the
answer but you this isn't quite right
you can't guess the answer if you have
an algorithm that just guesses the
answers that algorithm is going to be
wrong some of the time and we're not
talking about the complexity of
algorithms that are allowed to be wrong
we're talking about the complexity of
algorithms that have to be right so what
about this tournament argument well in a
in a parallel computing scenario you
actually can do something like this
where you have the list of numbers that
you're trying to compute the max of you
can separate this into two lists ask
some group of processors to compute the
answer for this half of the list and
some other processor a group of
processors to compute the answer for
this half of the list and then you only
have to do one comparison to find the
max the number of rounds that this takes
actually really is log n see this
problem is solvable in log n time but
not under the computation model we've
been talking about it's a computation
model where there's kind of an infinite
number of processors that can share
information between them this big theta
of n argument is actually correct and
just to just to kind of spell it out for
you imagine we've got an algorithm that
runs faster than big theta event so that
means it doesn't they can't possibly
look at every element in the list so
whatever that algorithm is done let's
say it's looked at a couple different
elements of the list and it has a guess
as to what the max is we can make sure
that this is always wrong by hiding a
value in one of the one of the spots in
the list that the algorithm didn't check
in and if that number is bigger than
everybody else it you know it can't have
answered the question correctly without
looking at it so that's that's really
cool actually because finding the max of
a list we have an upper bound of data of
N and we have a lower bound of theta of
N and they match each other and another
algorithm that you could get a matching
upper and lower bound without too much
work is for sorting at least under the
model where we're counting the number of
comparisons of elements you have to do
and it turns out that in fact sorting
under a comparison model has matching
upper and lower bounds of n log n so
this n log n that we've have been having
for sorting is essentially the best you
can do</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>