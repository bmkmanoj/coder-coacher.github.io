<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>GIT Workflow - Georgia Tech - Software Development Process | Coder Coacher - Coaching Coders</title><meta content="GIT Workflow - Georgia Tech - Software Development Process - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>GIT Workflow - Georgia Tech - Software Development Process</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3a2x1iJFJWc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">before jumping into the day model I
would like to give a high-level overview
of the get workflow which will help you
better following the demo so let me
start by representing four fundamental
elements in the get workflow which are
this for the workspace which is your
local directory the index also called
the stage and we'll see in a minute what
the index is then we have the local
repository we will also refer to this as
head in the when we explain the
different commands that and the workflow
and finally the remote repository so if
you consider a file in your workspace it
can be in three possible States it can
be committed which means that the data
the latest changes to the file are
safely stored here it could be modified
which is the case of the file being
changed and no none of these changes
being saved to the local repository so
locally modified or it can be staged and
staged means that the file is basically
part of this index and what that means
that it's been tagged to be considered
in the next commit and I know that this
is not all 100% intuitive so let's look
at that again by considering the actual
workflow and let's see what happens when
you issue the different commands that in
gate so the first command that you
normally run in case you're getting
access to a remote repository is the git
clone command and the git clone followed
by the URL for that repository will
create a local copy of the repository in
your workspace and of course you don't
have to do this step if you are creating
the repository yourself the next command
that we already saw is the command ad
and what the command ad does is to add a
file that is in the workspace to this
index and we say that after that the
file is staged
so it's marked to be committed but not
yet committed and here I'm just
mentioning this - you option if you
specify the manuals you option it will
also consider deleted file but let's not
get there for now we will talk about
that we do the demo as I said if you add
the file it just gets added to this
index but it's not actually committed so
what you need to do is to commit the
file so when you execute git commit all
the files that are staged that are
listed here there
changes will be committed to the local
repository so your files as I was saying
they can be in three states they will go
from the modified state to the stage
state when you execute the ad and then
from the stage state to the committed
state when you perform a git commit okay
so at this point your changes are safely
stored in the local repository notice
that you can also perform these two
steps at once
by executing a comet - a so if you have
a set of modified files and all these
files are already part of the repository
so they're already known to the version
control system you can simply execute a
commit - a and what the commit - a
command will do it will stage your file
and then commit them all at once so it's
a convenient shortcut of course as I
said this will not work if the file is a
new file so if a file is a new file you
have to manually add it otherwise commit
- a will just stage and commit at once
as we discussed when we looked at the
difference between centralized and
decentralized version control system we
saw that in the case of the
decentralized there is a local
repository which is this one and then
you have to explicitly push your changes
to a remote repository and this is
exactly what the git push command does
it pushes your changes that are in the
local repository to the remote
repository so at this point all of your
changes will be visible to anyone who
has access to the remote repository now
let's see the opposite flow so how does
it work
when you're actually getting files from
the repository instead of committing
files to the repository so the first
command I want to mention is the git
fetch command and what the git fetch
command does is to get files from the
remote repositories to your local
repository but not yet to your working
directory and we will see what is the
usefulness of doing this operation of
having the files all in the local
repository but not in your local
directory so what that means just to
make sure that we're on the same page is
that you will not see these files when
you work in your local workspace you
will still have your local files here so
this is sort of a physical distinction
in order to get the updated files from
the local repositories to your workspace
you have to issue another command which
is the command git merge get merge will
take the changes interlock a repository
and get them to your local workspace so
at this point your files will be updated
to what is in the remote repository or
at least the wall was on
remote repository at the time of the
fetch similarly to what happened for the
ad and commit there is a shortcut which
is the command get pull so in case you
want to get the changes directly to your
workspace with a single command you can
issue a git pull command and what will
happen is that the changes will be
collected from the remote repository and
will go to your local repository into
your workspace at once so this has the
same effect as performing a git fetch
and a git merge so if we can do
everything in one command why might we
want to fetch and merge as two separate
operations so one of the reasons is
because this allows us to compare files
before we actually get the latest
version of the files in particular I can
run the command get diff head to get the
difference between my local files the
files in my working directory and the
files in my local repository so what I
can do I can fetch the files from the
remote repository and once I fetch these
files I can run it get the header and
check what the differences are and based
on the differences decide whether I want
to merge or not so what we're talking
about git diff there are something else
that you can use with the diff command
so what you can do you can run git diff
without further specify head in this
case we'll the command tell you is the
difference between the files that you
have in your workspace and the ones that
are stage-four commit so basically what
it will be telling you is what you could
still add to the stage for the further
commit and that you haven't already so
what local changes will not make it to
the next commit basically and this you
can use for example as a sanity check
before doing a committed to make sure
that all the local changes that you have
and that you want to commit are actually
staged and therefore will be considered
so now we will cover all of the commands
that we saw here in our practical demo
but please feel free to refer back to
this gift workflow to get a kind of a
high-level vision or maybe you want to
keep it next to you because this really
gives you the overall structure and the
overall view of what happens when you
run the different commands and it also
helps you visualize the different
elements that are relevant when you're
using it so the workspace once more the
index or stage the local repository and
the remote repository</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>