<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Link Based Queueing Lock (cont) - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tbVs1JR0Nf0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now I can describe to you the lock
algorithm basically the lock algorithm
takes two arguments one is this name
dummy node that is associated with this
particular lock and and it has also
taken Mike you know the one that I've
providing to say that this is Mike you
know please in cue me into this into
this lock request queue and when I make
this call it could be that I'm in this
happy state in which case I don't have
any lock requesters ahead of me but if
it turns out that when I come in
there is somebody else using the lock
that I'm going to join this queue and
has to be done atomically and there are
two things going on here in joining this
queue atomically what I do is I set the
last pointer this list is always
pointing to the last requester so it
used to point to this guy he was the
only requester I came along so we had to
fix up this list so that this and
pointer is going to point to me is
elastic question and I also had to fix
up the current requester to point to me
and once I've done that then I can await
the predecessor namely this guy to
signal me by spinning on the guarded
variable that is associated with my data
structure and the other thing that I
would do as part of joining the skew is
to set my next pointer to no because
there's nobody after me I just made the
lock call notice that when I am joining
this queue I'm doing two things
simultaneously one is I'm taking the
pointer that was pointing to him and
making it point to me and I also need
the coordinates of the previous guy so
that I can set his next pointer to point
to me so I have to do this double act so
this has to be done atomically as well
so joining the queue essentially is this
double act of breaking a link that used
to exist here make it point to me and
give the coordinates of this guy so that
I can fix him up and remember that this
is happening simultaneously perhaps with
other guys trying to do the same thing
joining this queue and therefore this
operation of breaking the queue and
getting the coordinate of my predecessor
has to be done atomically and in order
to facilitate
we will propose having a primitive
operation called fetch and store an
atomic operation and the semantics of
this fetch and store operation is that
when you make this call and give it two
arguments l and me what this fetch and
store is going to do is it's going to
return to me what used to be contained
in L so what used to be contained in L
is my predecessor so I'll get that and
I'll get the coordinates of this guy and
at the same time it's also storing into
L a new node that is the pointer to the
new node that is me and so that's what
is being accomplished by this the double
act that I mentioned of getting my
predecessors coordinates and setting
this guy to point to me is accomplished
using this fetch and store operation is
an atomic operation and clearly if the
architecture is not having this fetch in
store instruction you have to simulate
that with a test and set instruction</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>