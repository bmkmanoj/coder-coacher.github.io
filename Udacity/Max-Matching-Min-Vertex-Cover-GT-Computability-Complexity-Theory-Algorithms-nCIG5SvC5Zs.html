<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Max Matching  Min Vertex Cover - GT - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Max Matching  Min Vertex Cover - GT - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Max Matching  Min Vertex Cover - GT - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nCIG5SvC5Zs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now we're ready for the matching
equivalent of the max-flow min-cut
theorem the max matching min vertex
cover theorem consider a bipartite graph
G and a matching M then the following
are equivalent M is a maximum matching M
admits no augmenting paths and there is
a vertex cover that has the same size as
the size of the matching the proof will
be very similar to the max-flow min-cut
there first we'll show that if M is a
max matching then it can't admit any
augmenting paths well suppose not then
there is some augmenting path and if we
are meant M by this path we get a larger
matching meaning that M was not a
maximum as we had supposed
next we argue that if M admits no
augmenting path then there exists a
vertex cover that has the same size as M
this is the most interesting part of the
proof will let H be the set of vertices
reachable via an alternating path from
unmatched vertices in L we can visualize
this definition by starting with some
unmatched vertices in L then following
its outgoing edges to some elements in R
and then following all the matched edges
back to matched elements of L and back
and forth and so forth as many times as
we can note that because the matching
doesn't admit any augmenting paths all
of these paths must terminate in some
matched vertex on the L saw let's draw
the rest of the graph here as well we
have some matched vertices in L the
vertices of R that they're matched to
and possibly some unmatched vertices in
R as well note that H and the compliment
of H correspond to the minimum cut that
we used when discussing the max-flow
min-cut theorem to get a min vertex
cover we select the part of H that is in
R and the part of L that is not and we
call this set s s contains exactly one
vertex of each edge and M if the edge
and M happens to belong to H then we've
got its right side and if it doesn't
belong to H then we got its left side so
the size of
and the size of em must be the same next
we need to convince ourselves that s is
really a vertex cover remember that
there are no edges internal to R or
inter no to L so we don't need to worry
about those the part of s that is in our
covers all the edges internal to our H
set of vertices and these over here in L
they cover all edges in the not H part
of the graph so what we really need to
worry about are just edges that go
across the cut well from here to here
both vertices in the edge are covered so
we only really need to worry about the
part of L that is in H being one vertex
and the part of R that is not in H being
the other but if there were such an edge
crossing here it would have been in H
because we'd be going from a vertex in h
via an unmatched edge to R we conclude
that there are no such edges and hence s
is a vertex cover finally we have to
prove that the existence of a vertex
cover that is the same size as a
matching implies that the matching is a
maximum and this follows immediately
from our discussion that a vertex cover
is an upper bound on the size of a
matching so if it wasn't a maximum
matching then the whole idea of vertex
cover wouldn't be an upper bound as
we've argued already</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>