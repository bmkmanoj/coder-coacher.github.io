<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dijkstra's Algorithm | Coder Coacher - Coaching Coders</title><meta content="Dijkstra's Algorithm - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dijkstra's Algorithm</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SoPMK03cOgk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one solution to the shortest path
problem for weighted undirected graphs
is called Dijkstra's algorithm let's say
we're trying to find the shortest path
from here to here we begin by giving all
vertices a distance value a distance is
the sum of edge weights on a path
between our starting point and whatever
vertex were on at the end of the
algorithm this distance will be the
distance of the shortest path the
distance value we start with is infinity
this is a placeholder value that will
update whenever we discover a node and
have an actual distance to store the
node we're starting with will have a
distance of 0 a common implementation of
Dijkstra's uses a min priority queue
where the element with a minimum
priority or minimum distance in our case
can be removed efficiently we store all
of our nodes in the priority queue and
use extract min to take out the minimum
element the only one with a distance of
0 from our starting node we have several
options we will follow each edge and
update the node on the other side with a
distance value which is just the weight
of the edge now we're faced with a
choice which node should we visit we'll
always pick the node with the smallest
distance value which means we run
extract min on the queue because we
always pick the node with the lowest
distance Dijkstra's is often called a
greedy algorithm the philosophy for this
class of algorithms is pick whatever
option looks best at the moment hence
the name greedy we repeat the process
visiting all adjacent nodes that are
still in the queue and updating their
distance values if we can decrease it at
all we keep going extracting the minimum
from our queue and exploring adjacent
elements until the node we're looking
for has been extracted from the queue or
everything else has a distance of
infinity which means the path we're
looking for doesn't exist the basic
runtime of Dijkstra's is the number of
vertices squared since in the worst case
we visit every
node in the graph once or twice and
every time we visit we need to search
through the queue to find the minimum
element there are a lot of optimizations
for Dijkstra's if the priority queue is
implemented really efficiently the
runtime looks more like this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>