<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spinlocks With Delay - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Spinlocks With Delay - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spinlocks With Delay - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KlRkAdQKjnE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now in order to limit the amount of
contention on the network when a lock is
released we're going to do something
that we often do in real life
procrastination so basically the idea is
the following each processor is going to
delay asking for the lock
even though then observe that the lock
is released they're not going to
immediately go and try to get the lock
they're going to wait for a little bit
of time it's sort of like what happens
at rush hour if you find that the this
traffic is too much you might decide
that I don't want to get on the highway
right now I'm going to delay a little
bit so that I don't have to spend as
much time on the highway so that's sort
of the same thing that is being proposed
here and this is what is called spin
lock with delay let's discuss two
different delay alternatives in the
first one you're here you found that you
did not get the lock and therefore
you're here locally spinning in your
cache waiting for the lock to be
released normally what you would have
done when the lock is released is go
back out break out of this loop and go
back and check if you can get the lock
again but what we're going to do is
instead of doing that when we break out
of this loop meaning that the lock has
been released I'm not really immediately
go and check to see if I can get the
lock I'm gonna delay myself by a certain
amount of time and you noticed that the
delay is conditioned by what processor
ID I have so every processor is waiting
for a different amount of delay in order
to contend for that lock so since the
delay is being chosen differently for
each processor even though all of them
notice that the lock has been released
simultaneously only one of them will go
and check it and so we are sort of
sequential izing the order in which the
processors that are waiting for the lock
are going to check whether the lock is
available so that is one possible scheme
for delaying now the problem with this
is a static delay right so every
processor has been pre assigned a
certain amount of delay which means that
even if the lock is available I'm a
naughty Meade
we go and check because my delay may be
very high compared to some other
processor and that's always an issue
when you have static decision-making
what we can do is instead make the
decision dynamically and what we're
going to do is when we notice that we
don't have the lock we're going to delay
ourselves by a certain amount of time
before we try for the lock again you
notice that if you're going to delay
checking for whether I have the lock or
not it's not super critical that that
you spin locally or go to memory but in
this example I'm making it very simple
by saying that if you don't get the lock
just delay a little bit before you try
for this lock again and the idea here is
this delay is is some small number to
start with but suppose I go and check
and I find it again to be locked then
what I'm going to do is the next time
around I'm going to increase the delay
that's where it's called exponential
back-off so I'm increasing the delay
doubling the amount of delay that I'm
going to do so that the next time if I
don't find the lock to be available I
delay by twice the amount from the
previous time and this is essentially
saying that when the lock is not highly
contended for I'm not going to delay
myself too much I'm gonna immediately go
and get it but on the other hand if I go
back again and again every time I go and
check I find it is locked I'm gonna
increase the amount of delay because
that's saying that a lot of people are
contending for the lock at the same time
and therefore in order to make sure that
we are being sensitive to the contention
that is there for the lock we increase
the amount of delay that we are
experiencing now one nice thing about
this simple algorithm that I shown you
is that I'm not using the caches at all
and if the if the processor happens to
be a non cache coherent multiprocessor
this algorithm will still work because
we're always using testing set and not
using just loading from the memory
because if it is not a
- coherent multiprocessor your private
cash is not going to be coherent with
respect to memory and so you have to
execute test and said but you don't want
to do it all the time and the delay make
sure that you can reduce the amount of
contention on the network generally
speaking if there's a lot of contention
then static assignment of delay may be
better than this dynamic exponential
back-off but in in general any kind of
delay any kind of procrastination will
help a lock algorithm better than the
naive spin lock that we talked about</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>