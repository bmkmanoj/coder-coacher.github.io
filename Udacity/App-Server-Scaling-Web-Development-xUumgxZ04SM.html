<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>App Server Scaling - Web Development | Coder Coacher - Coaching Coders</title><meta content="App Server Scaling - Web Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>App Server Scaling - Web Development</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xUumgxZ04SM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so we've taken a fair amount of
load off our database now if we were to
go through that whole solution we'd only
be doing database writes and we'd very
rarely be doing a database read at all
this is a big improvement over doing a
database read on every page view so
let's go back to what I request us on
every request remember we would process
the request you know this was HTTP URLs
and all that stuff we did the DB query
the database query we collated the
results which for you know ASCII Chan or
the blog is there's not really much
involved in that at all
and then we rendered HTML so we've
improved the database query but what if
we want to improve these other other
pieces you know we can use caching to
render HTML that's definitely technique
there and we can actually use another
technique for it and handling all three
of these parts of the request which is
adding additional app servers and this
looks something like this
today conceptually we've basically had
one program running that handles all of
our requests in your blog and an ASCII
Chan we've got the simple program you
know requests come in responses come
back out but if we have so many requests
that one machine can't handle it what we
can do is we can add multiple machines
to take up some of the load and so all
these extra requests can go to all these
machines and these machines you know may
be interacting with the database they
may not be you know presumably they have
their little caches that we just
implemented that lives in our program
and this helps so how do we get requests
to multiple machines well there's a
piece of technology that sits between
the user and all of your app servers
call the load balancer and this is a
special machine it's a physical machine
just like your app server might be or
just like your database server might be
that's optimized for doing one thing for
spreading requests across multiple
machines so what happens is this load
balancer has a list of all of the app
servers that that are in existence and
requests come in from the outside world
many many many of them and the load
balancer decides which app server to
send the request to send one here then
send one here then send one here and it
can keep going through that process and
the reason those load balancer can
handle is traffic while the app servers
can't is the load balancer isn't doing
anything other than
taking in the requests choosing a server
and forwarding the connection along it
doesn't have to parse HTTP or it may
only parse parse minimal HTTP it doesn't
have to it's not doing database queries
it's not rendering HTML it's not going
to the cache it's it's doing almost
nothing at all other than deciding which
server to send a request to you probably
won't ever have to write one of these
but it's good to know how they work and
when you're using App Engine Google kind
of does all this for you they'll
automatically create new servers running
your program and and scale it you can
actually go into the App Engine admin
page and see how many servers they're
using to host your app which is pretty
cool normally this is a really
challenging thing and not knowing how to
do it the first time this took me a
little while to figure out when we were
scaling reddit that doesn't mean I'm not
going to make you understand these
things a little bit deeper so there are
a couple algorithms a load balancer can
use to determine which server to send
traffic to the simplest one is probably
just to randomly choose a server you
know a request comes in to the load
balancer and the load balancers just
picks a server and sends the request
there which will you know probably work
pretty well you know over over time if
you have enough requests each server
should get about the same amount of load
another approach is round robin and
round robin just means the load
balancers going to choose one server at
a time you know first this guy then this
guy then this guy then this guy you know
just in order that's also a fairly
simple algorithm and then some load
balancers are really smart and they know
what the load is on each server how many
requests are outstanding at each server
and it may use some sort of load based
algorithm to say you know this guy is
already handling like five requests and
this guy's not doing anything so let's
send you know future requests here until
you know things even out there's lots of
approaches to doing this what I'm going
to ask you to do now in the form of a
quiz is implements a basic
round-robin algorithm</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>