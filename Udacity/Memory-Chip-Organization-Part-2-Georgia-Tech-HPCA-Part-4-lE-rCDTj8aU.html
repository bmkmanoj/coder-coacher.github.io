<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memory Chip Organization Part 2 - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="Memory Chip Organization Part 2 - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memory Chip Organization Part 2 - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lE-rCDTj8aU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we just described how to read a row
into the sense amplifier and the row
buffer and then get one bit out of that
row so let's suppose that the bits we
had here were 1 0 1 1 and let's say this
was DRAM so this bits drained into the
bit line the sense amplifier amplifies
them outputs here 1 0 1 1 1 the row
buffer now store this value and starts
outputting it here let's say that the
column address finally selects this bit
4 to be output so we output a 0 remember
that DRAM reads are destructive once we
do that we no longer have our bits here
so what needs to be done is after the
sense amplifier determines what the
correct values of the bits are and the
sells by now have been exhausted we
reverse the direction and raise each of
the bit lines to its proper value so now
the sense amplifier is driving this
correct values back into the cells and
the cells get their values again so
destructive read from theorem means that
really we have to read and then write
each cell so we cannot just wait long
enough to get the value we also have to
wait long enough to put the value back
in the cell this is one of the reasons
why DRAM is slower than SRAM another
reason of course is that the cell does
not as strongly pull the bit line so the
sense amplifier needs more time to
figure out what it has after this read
and then write approach the cells have
the correct values for 1 0 1 1 and have
been refreshed even if they have reduced
to let's say 90% of what they should
have once we read them out and put it
back in we put back in the full value so
now they can again leak for a while
before we need to read and and write
them again so refresh is really make
sure that each of the rows is read every
once in a while if the time for the cell
to lose the value enough so that we
cannot recover it is some sort of time T
then every row needs to be read and
written within the time T a destructive
read
and then a right will refresh the row
but we cannot rely on the processor to
access every row in the memory so that
we don't have to do anything else in
fact when you have caches it often
happens that some rows that are very
popular and accessed by the processor
all the time are actually the ones that
don't get refreshed this way and the
reason is that those become cache hits
and the cash keeps keeping that data
because the processor wants it so often
so we end up actually not accessing the
memory for things that the processor is
accessing the most often so we cannot
even rely on the program to go through
the whole memory so what needs to happen
for refresh is that we have this refresh
row counter it starts at zero we use it
to refresh this row then it moves to 1
we then use it to refresh this row and
so on if a row needs to be refreshed
within some refresh period let's say T
and we have n rows then every T over n
seconds we have to refresh one row so
that by the time we are done we are
ready to refresh again a row which would
only last for a period of T modern
theorems have a lot of rows and the
Refresh period is well under a second so
we are actually seeing a lot of
refreshes happen every second this is
not something that happens occasionally
this actually significantly interferes
with when we can read and write our
memory because while a refresh is going
on we cannot do a useful read because
the row decoder sends amps and the row
buffer are used by the Refresh operation
which is reading a row that we didn't
need and writing it back meanwhile we
have to sit and wait with a real read
until that gets done so that we can move
on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>