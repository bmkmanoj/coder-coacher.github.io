<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graph Coarsening | Coder Coacher - Coaching Coders</title><meta content="Graph Coarsening - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Graph Coarsening</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/o0mhbHdfgTA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so a different kind of partitioning
strategy is known as multi level graph
coarsening it's a form of divide and
conquer
let's start with a conceptual
illustration you start with an input
graph pretend this is an input graph you
then replace it with a smaller version
in the graph sense the course graph
would have fewer nodes and edges but
would somehow look like the original
graph you might repeat this a few times
until you get a version of the graph
that is small enough to partition
quickly you then partition the smallest
graph if you've done a good job
preserving the relationship between the
coarsest graph and its parent graph then
a split in the coarse graph will
correspond to a roughly equivalent split
in the fine graph and you'd repeat this
reverse step until you have a partition
of the original so that's the concept
but how do you actually course in a
graph most schemes have the following
flavor first identify at least one
subset of the vertices to collapse or to
merge for instance here's a subset of
five vertices I'm gonna replace this
subset with a single super vertex now
remember that one of your partitioning
goals is to obtain balanced partitions
so it's probably a good idea to track
the fact that there were five vertices
here that became one vertex an easy way
to do that is to assign a weight of five
to the super vertex you'll also want to
track edge weights so that later on we
can cut edges accurately let's see how
that might work consider two vertices in
a weighted graph remember even if the
original graph is unweighted we
repeatedly Corsan by aggregating nodes
and edges and so will accumulate weights
in this example WI is a function that
map's every vertex to some weight
similarly the function X I will map
edges to weights now let's suppose that
we join just these two vertices into a
super vertex let's call this new vertex
s its weight is the sum of the weights
of U and V now what about the edge
weights the main case to think about is
the following suppose there's a vertex T
that's connected to both U and V then
these two edges will become a single
super edge in the course under graph so
what
it's wait a natural idea is simply to
sum the weights of the original edges so
the weight of the new edge is just the
weight of the two old edges that got
merged the reason we do this is so that
if we partition or cut this edge and the
coarsened graph we'll know that it maps
to two edges in the original graph now
before you move on it's a good idea to
check that this procedure makes sense to
you okay let's go back to the original
sample graph and see what would happen
by applying these rules consider this
first merge group again there are five
vertices which become one super vertex
there are also several cases in which
multiple edges should merge here's the
result now let's suppose someone gives
us a sequence of merge groups and let's
course in the graph accordingly course
and of course and so this is the final
result that's the basic process of
corseting a graph hmm kind of looks like
something wonk do you know about
Atlanta's pink pig ride</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>