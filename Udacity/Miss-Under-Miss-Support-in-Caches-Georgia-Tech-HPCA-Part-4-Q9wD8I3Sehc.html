<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Miss Under Miss Support in Caches - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="Miss Under Miss Support in Caches - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Miss Under Miss Support in Caches - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Q9wD8I3Sehc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what do we have to have in our cash
in order to support a Miss under miss
operation before the cash would simply
block when it has a Miss and not do
anything until the Miss comes so it
doesn't really need much support for
that with Miss under miss we have a Miss
but accesses keep coming to the cash if
they're hits we handle them normally by
just finding those blocks and returning
to the processor if they are mrs. we
have to do more now now we need to have
the so-called miss status handling
registers or ms hrs what they do is they
remember what we request it from memory
so they keep information about the
missus that we currently have in
progress when we have a Miss we have to
check the MS hrs to see if there is any
match basically if you have a Miss we
want to know whether it's a new Miss or
something that we didn't find in the
cash but it has already been ordered
from memory because of a previous access
that was a miss so if it's not a match
that means it's a Miss to a different
block in that case we allocate a new msh
are in the msh are we remember which
instruction the processor to wake up
when the data comes back and that's it
if there is a match that means that we
try to find data from a block and that
block had a previous miss that was
already sent to memory but didn't come
back yet so really if we did things one
at a time this would not be amiss so we
call this a Miss and this is sometimes
called half miss because this is a true
miss that we would have even if we did
blocking caches this is a mess that
would be a hit if we did blocking but
because we allowed the processor to
check the cash before the previous mrs.
came back some of the new accesses are
now not finding the data in the cache
but the data is already on the way back
to the processor now because the request
for this block has already been sent to
memory we shouldn't send it again
instead we simply add that instruction
to the MS HR and that's it when the data
finally comes back from memory we find
the MS a chart that corresponds to that
request and we wake up all the
structions that were added to this msh
are the first one and all of the
subsequent ones that also wanted the
data keep in mind that the Miss and the
half miss to the same block need not
necessarily be to the same word actually
it's quite common that for example you
access the first word and then very soon
reacts is the second word in a block the
first word had a miss the second world
will have a half miss and after waking
up the instructions we release the msh
are so it can be used by another mess so
how many ms hrs do we want to have it
turns out there is a huge benefit even
if you only have two so you can handle
two different blocks in progress at the
same time for is even better and there
are benefits to be gained even if you
have 16 or even 32 ms hrs so we want to
have a few tens of ms hrs if we can this
is because memory latencies are
relatively long so if we can keep
sending requests to memory during that
time we can be achieving the memory
level parallelism of 16 or even 32
cutting down dramatically on what the
overall performance penalty of cache
misses and the being</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>