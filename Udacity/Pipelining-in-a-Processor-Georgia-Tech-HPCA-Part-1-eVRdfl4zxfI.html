<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Pipelining in a Processor - Georgia Tech - HPCA: Part 1 | Coder Coacher - Coaching Coders</title><meta content="Pipelining in a Processor - Georgia Tech - HPCA: Part 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Pipelining in a Processor - Georgia Tech - HPCA: Part 1</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eVRdfl4zxfI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now let's try to apply the idea of
pipelining to a processor in a
traditional processor that is nowadays
too simple so we only use it to teach
students but it still shows how things
work we have a program counter we use
the program counter to access the
instruction memory we get the
instruction from there we look at the
instruction to decode it to figure out
which type of instruction it is
meanwhile we could be reading the
registers
once we have read our registers we can
feed them to the ALU where we are going
to do the add or subtract or an XOR or
whatever the instruction wants us to do
the decoding logic is going to tell the
Lu what to do once we get the result of
the ALU we could be done and just write
the result of the register or we could
have a load or a store instruction in
which case what the Lu computed is
really the address that we use to access
our data memory and what comes out of
data memory is what we end up writing to
our registers and then of course there
is stuff to do with branches and so on
but basically we can do one instruction
per cycle by starting at the PC fetching
the instruction accessing the registers
doing the operation accessing the data
memory and then writing the result back
to registers so you can see the
destruction kind of goes through these
five phases we fetch the instruction we
read registers in the code we use the
ALU we access the memory and finally we
write the registers the time to do this
might be something like 20 nanoseconds
so now we can do one instruction every
20 nanoseconds so how do we apply
pipelining to this well the idea is that
if here we have our fetch decode Lu
memory and right part of this processor
and here we show what happens in cycle 1
we will fetch some instruction i1 in
cycle 2 instruction i1 moves to decode
in cycle C 3 instruction i1 will be
doing the ALU operation in cycle c 4 i1
will move to do memory and then in cycle
C 5 i1 will write the result and now
cycle we can begin the instruction tool
if we do that then we really will finish
one instruction every 20 nanoseconds if
we apply the idea of pipelining here in
cycle 1 we are still fetching
instruction i1 in cycle 2 we will be
decoding instruction i1 but we can begin
fetching the instruction i2 when
instruction i1 move to do the early
operation I too can move to be decoded
and I 3 can be fetched in the fourth
cycle I 1 is the memory stage I 2 will
be doing the early operation I 3 will be
here being decoded and died 4 will be
fetched and then when I 1 is in the last
part of the pipeline I 2 will be right
after it in the memory stage I 3 will be
doing the ALU operation I for will be
decoded and we will be fetching an
instruction I 5 so now the idea is that
once the I 1 leaves the pipeline very
soon after that I too will leave the
pipeline if we divide is 20 nano second
into five equal pieces for these stages
each stage will be 4 nanoseconds and now
the latency to do I 1 is still 20
nanoseconds so it takes 20 nanoseconds
to do an instruction but the throughput
will be 1 instruction will finish every
4 nanoseconds because once I 1 leaves
that's how long it takes for i2 to live
and then we just keep pouring
instructions out so it's similar to the
oil pipeline it takes a while to fill
the pipeline but once we do instructions
keep pouring out at a very high rate</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>