<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Divide and Conquer Inspiration - GT - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Divide and Conquer Inspiration - GT - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Divide and Conquer Inspiration - GT - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-dxkAT7r658" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">at this point we've seen how polynomials
can be represented by their values at a
set of distinct inputs and how
multiplying polynomials is easy when
they're represented in this way the
problem is that we're really interested
in the coefficients recall that the
coefficients of the two polynomials can
represent any two sequences that we want
to involve to exploit the speed of
multiplying in the value representation
therefore we need an efficient way first
to evaluate a polynomial at some
distinct set of input points and an
efficient way to interpolate back the
result to the coefficient representation
will focus on optimizing for quick
evaluation of the polynomials first our
goal is to evaluate a polynomial a of
order n @ n distinct points note that
I've made the order of the polynomial
and the number of points the same here
we can always pad the coefficients with
zeros effectively increase in the order
and we can always add more points so
there's no loss of generality here as
you did the calculation for the exercise
you may have taken advantage of the fact
that the input values were arranged in
positive negative pairs for higher order
polynomials this advantage becomes even
greater all the even terms are the same
for X and negative x and the odd terms
are just negatives of each other with
this in mind let's define a sub E to be
the polynomial whose coefficients are
the even coefficients of the original
polynomial a and we'll define a 0 to be
the polynomial whose coefficients are
the odd coefficients of the original
polynomial a then we can write a as a
sub e of x squared plus X times a sub 0
of x squared and we can get a of minus X
just by changing this one little sign
here and essentially we've found two
values for a for the price of one more
formally let's say that we choose X sub
I such that X sub I is equal to negative
X sub I plus n over 2 then we can
compute the values of the polynomial two
at a time by computing AE in a 0 at X I
squared and then using them in
these two equations overall we've
changed the problem from evaluating a
polynomial of order n at endpoints to
evaluating two polynomials of order and
over to at n over two points plus doing
the work of n more additions and
multiplications this is good but at its
best we've only reduced the running time
by a constant factor we need to be able
to apply this strategy recursively to
change the asymptotic running time a set
of points that would allow us to do this
would be very special indeed</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>