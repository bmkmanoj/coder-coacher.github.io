<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lesson 5 - Udacity HTML5 Game Development Study Group | Coder Coacher - Coaching Coders</title><meta content="Lesson 5 - Udacity HTML5 Game Development Study Group - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lesson 5 - Udacity HTML5 Game Development Study Group</b></h2><h5 class="post__date">2013-03-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/w0-0a9QrFO0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright welcome everybody welcome to
this fifth episode of the Udacity html5
game programming study group or live
here from San Francisco with me I have
Sean Bennett and cold again hello all
right everybody people are you doing
that now yeah that's a good like
everything hello so before we get
started just wanted to thank the
sponsors a moment first of all Google
for the excellent food once again it has
and the the great venue that we've been
enjoying for last five weeks so we're
officially passed the halfway point and
I've been having a blast I think yeah
cold yeah Sean yeah where to so it's
been it's been great really would like
to get your your feedback as well talk
to us after the event if you can if you
think of anything that needs to be
improved we still have a few sessions
another thing that we can do Oh go son
yeah yep another thing really ha that's
to be close to be hello testing testing
ok ok so another thing that we can do
I'm just gonna have both of them right
here oh okay so okay so really I have to
do both okay so one of the things you
can do is send email to feedback at
Udacity calm and that will get back to
all of our community representatives
community managers user researchers and
so they can help you out a lot in
getting some of your feedback to really
the right places they need to be at
Udacity ok thanks so a couple of
underspent sponsors I would like to
quickly acknowledge one is providing all
the live broadcasting that all of you on
the livestream are enjoying is Google
developers live of course also part of
Google but providing this live stream
yeah that's ok yeah
okay so if you're not familiar with
Google developers live they it's
basically our TV channel to the world's
from mostly from mountain view but also
via our live mobile studio that we're
actually basically test driving here in
piloting for this program actually mmm
so we have a variety of programs there
we have the chrome channel we have
Android information we have maps all the
different product areas of Google you
can find there check it out the
developers.google.com/live and find the
interesting information the information
you're interested in by using the the
dropdowns for the different product
areas the calendars you can pretty much
find all the information that we're in
the chrome team we're actually we have
several shows and there are sometimes
weekly bi-weekly or something monthlies
we have shows on mobile shows own
performance and tooling the break point
with Paul Irish and Agnes money
definitely check that one out chrome
apps related stuff mobile related stuff
so we actually put a lot of emphasis on
going there to actually reach a very
wide audience so check that out and
finally I've got that up here is helping
us spread the word locally but it's also
beyond that into Bay Area's San
Francisco html5 user group full
disclaimer I'm also the organizer of
that group but if you're not part of
that yet definitely sign up it's SF
html5 org we have great monthly events
in person in San Francisco we live
stream some of those but we always
record them and our recorded views have
now reached close to a half million so
we have three this is our third this
week is our third anniversary three
years of SF 805 and we're having a great
event this thursday that which is an
absolute must with ely egregore it if
you don't know him his stories are
always incredibly how he works on the
perf squad with him from it Colton
so he's going to have an interesting
talk it will be recorded so if you can't
make it but that's when we check those
those events out and if you're not in
san francisco and the bay area
definitely check it out join it's on
meetup and you'll get all the
information sent to you anyway so smh no
five letter word so without further ado
much much ado about nothing yeah alright
so wanted to start off just this event
once again with a little bit of an
overview from cold on some of the higher
level concepts and called prepared a
small presentation that we're all so
this time streaming to the live stream
so hopefully yeah hopefully take it away
alright that's like I'm gonna stand
because I'm a type of standard guy that
likes the stand while he's doing stuff
Mike she's this one on two testing yeah
hey cool hello Chicago okay so we got
some good feedback last week that
everyone liked my little hand wavy
diatribe at the beginning of the class
we decided to do more of them so this
week was the entities unit yes entities
how many people watch the entities unit
everyone like the chickens sword head
dance we got okay the sort of Antioch
the blue sword of Antioch so I want to
actually point something out because we
actually got a good question this week
from someone who is saying hey you know
you guys really aren't doing anything
smart for storing your units you're just
kind of you know shoving them all in an
array isn't that not really performance
and I said hey you know what this is a
great question probably something we
should talk about in the study group so
a pop quiz how many will start with this
how many of you would say that you know
JavaScript okay good so I'm looking to
you people to answer this question so
let's say we start a we create a
contiguous array here so we create a new
array with 100 contiguous elements and
you know we can assign object into it
what happens when we actually say add
new object to a contiguous array
I am sure but I think it will extend it
that actually creates new copy the array
doesn't exactly right so it'll actually
not create a pointer to it will actually
do returns that you arranged there you
go great answer from the crowd so what
actually happens here is a very similar
memory growth pattern as you see in C++
what will actually happen is with this
little setup up here as soon as you add
one object to this contiguous array what
will actually do is it actually create a
new ray double the size of the current
array copy all the elements from the
previous array into the new array and
return the new array representation so
now this is pretty interesting because
you know you know it's kind of all
handling under the hood for you right so
if you start off with 100 objects that's
fine as soon as you add that extra unit
you now have a 200 unit space array here
right and then you add another one so
let's say you add 201 right so you fill
that up you get 201 well guess what it
duplicates it again and actually have
400 units 401 now you get 800 units and
so you can actually see this this turns
out to be a pretty interesting memory
growth pattern we say that see the
similar growth pattern with standard
memory containers in other languages
like C++ like STD vector in C++ is one
of the most notorious abusers of this
policy is that what happens is over time
as you start adding more and more
objects you'll start seeing that the
performance thunk that you get for
adding these objects gets bigger and
bigger and bigger and you start seeing
that every time you hit this limit where
you allocate the new array you're seeing
more time to allocate the array copy all
the objects over and then delete the
previous array and so this is actually a
large problem that JavaScript has as
well but a lot of people don't
understand this because it's all hidden
under the hood of JavaScript right so
here's another interesting fact so not
so you've got your 800 unit array well
each one of those objects in that array
has to be separately touched by the
garbage collector collector when it's
doing this analysis right so you now
have 800 objects the objects collector
will go through and say are you alive
are you dead what's your reference is
you know what phase are you an are you
an old phase new phase small collection
big collection there's a great book out
there called garbage collected
collection the definitive guide if
you're interested in understanding more
about garbage collection go do it read
it it's awesome
effectively the thing to take away here
is that if you're actually storing lots
of entities in your games and I know
some of you have actually come up to me
and been like hey you know I'm going to
have 1,200 units how do I handle all
this stuff this is actually the wrong
way to do it now the cool thing is in
C++ you can actually override this
default memory growth behavior in an STD
vector by providing a templated
prototype that allows you to describe
how the memory model works in JavaScript
you just have new array so you actually
have to come through back to the table
and actually create a new container
class to get around this growth pattern
so this is something that I love to use
it's actually called a bucket array
representation so what happens is let's
say this is a new type right so instead
of actually just saying new array you
create a new bucket array right so how
new bucket array works is that when you
add that too with that 101 element
instead of doubling the size of array it
creates a new bucket of a static sides
so in this little demo here you can
actually see that we have bucket array
where the first parameter a hundred
actually specifies the size of each
bucket and then the second parameter is
how many were actually pre allocating so
600 units so this actually does is
actually goes through and creates six
buckets each bucket of 100 now what will
happen is as you start adding and adding
and adding and adding and adding each
time you go past the size that it's
already allocated it'll only grow by a
hundred units of time so this actually
allows you to put sort of a different
growth metric on how you're actually
allocating your objects plus here's the
really cool thing is that you're not
getting pinged for that extra copy and
delete phase that your previous memory
allocator was actually going through
right so remember in the original one
you create a new array copy all the
stuff over delete the old array in this
model you actually just create a new
bucket no copying no deleting needed
right so one of the bad parts about this
though is that the garbage collector is
still going through and touching each
single individual unit in each one of
these buckets right so 600 elements is
still 600 live objects that the garbage
collector has to start churning through
so for an object representation so you
have some object with the name equal to
lub step this is actually kind of as
good as you can get right they can't
really make this memory allocation
pattern any more efficient because
you're you're just trying to push
objects into an array so there's a
different rep
entation that we actually use quite
frequently in the games industry again
with C++ code that actually translates
over to JavaScript so those of you who
are actually looking to do lots and lots
of objects and high-performance
calculations this stuff is for you so
what you can actually do is actually
change this to be a typed array right so
let's say instead of actually just doing
a bucket array you actually have an in
32 bucket array where each bucket is
actually using the typed in 32 modifier
that's actually been exposed through the
language definition right so what this
will actually do in javascript is
actually create a contiguous block of
memory inside of the WebKit internal so
basically inside of the C++ code it's
actually a contiguous 32-bit int or read
so the cool thing about this is that
that single object is viewed to the
garbage collector as a single object
right so each elements in that array to
each 100 elements the garbage collector
doesn't even know about it just has one
pointer to the actual C++ code so this
means that you actually get a better
benefit because the garbage collector
does less work so 80 thousand objects at
you know a thousand objects a bucket is
only 80 objects that the garbage
collector cares about this is
interesting because now you're actually
reducing the amount of overhead the
garbage collector is going to take
during its session of evaluation right
you're also reducing the overall
overhead because garbage is actually not
being generated because of the way
you're actually allocating objects so
this is all fine and dandy until you
actually start removing stuff from the
array now you start getting into some
tricky internals so again all of you
fund JavaScript experts in the room who
raise your hands before so what happens
if i have a contiguous 100 element array
and i remove element 50 or better if i
call slice slice 50 comma 1 what happens
anybody
oh don't be shy we're not a shy people
here I come up here and do my song and
dance all week come on make fools of
yourselves it's fun yes goes out of
scope so then because you remove one of
the references so now the garbage
collectors gonna see the whole raid as
being something needs me Congress
collected so very good answer so he
mentions that your array will go out of
scope because you actually removing and
elements in the array so the whole thing
has to then come back into the view of
the garbage collector and so I'm going
to say yes and no yes because if this
were a standard array you'd be right and
no because I wrote this incorrectly and
you just pointed that out so Bravo so if
this were a standard JavaScript array
and you actually call slice what
javascript is actually going to do under
the hood is it's going to remove that
object it actually create a new array
and nope everything down a slot and then
pass you the pointer to the new ray
right so you're adding objects and
you're getting extra duplicated memory
and copies and you're removing objects
and you're getting extra duplicated
memory knob copies so the point you
should be taking away here is the
default array implementation in
javascript is not really a performant
operation if you're going to be adding
removing entities a lot like it just
doesn't work right you're actually going
to be doing churn on entities there's
much better representations as I've
already kind of described with the
bucketed setup now if you're using a
tight bucket array like the in 32 bucket
array you can't actually call remove in
the proper fashion because remember this
is a contiguous array of integer values
so dot remove doesn't really exist in
this concept right so if you called that
remove it'll just kind of go like okay
cool and it'll do the same thing and
remove it copy the data and actually
create another WebKit array that
replaces the array you have right so
this is where you have to start looking
at how you're dealing with your entity
objects what your growth pattern is for
this container and look at something
different so this is a this is a typical
piece of code that you'll see in a lot
of games engines so you're starting
block here is during your initialization
phase you actually go through and you
parse some entity list in a JSON file
you actually go through and create these
entities and push them into your mega
container right somewhere on in your
update loop every single frame you're
going to walk all of the
empties and you're going to look for one
value and that's the is dead value we
talked about that this week right like
how to remove entities after they've
been killed so you have a sort of post
garbage collection removal there so you
call remove rights or that's going to
remove this object from our contiguous
array now that we have so that's going
to cause all this slicing to occur and
then somewhere else after that you've
got in some little internal loop for an
entity a bullet is spawned that's going
to then push it back on the array so
what's cool about this well not really
cool is just something you need to be
aware of it so I'll point of my diatribe
here I'm bald I talk a lot it happens so
what happens here is you've got this
update loop that actually is going to go
through and remove things from the array
and then later on you've got some unit
processing which is going to go through
and create new entities and push them
into the array so what happens is that
every time you call a raid move it's
going to stop copy the array delete the
old array in your new choir stop delete
the old array give you new pointer stop
delete the old ray give you new pointer
then you're going to move into the
microphone area and can start creating
new arrays as you start adding new
elements to this list right because it's
now resized everything down and so
you've just actually taken a huge amount
of time sync for what looks like very
common code because you're using the
standard array container right now if
you use a bucket of array this is a
little bit different but you have to
understand that the bucketed array as
I've described it doesn't really handle
removal very well right for that you
actually have to look at a different
type of data structure now for those of
you who've actually sat through the
diatribes of your data structures 201 or
301 class depending on where you got
your CS degree and how much they love
that sort of things you'll realize that
there's many many millions of different
algorithms out there for actually
containing entities and sorting through
them in different ways one of the
important ones that you should be using
if you are writing JavaScript code I
don't care if you're writing a slow app
or a fast app or any sort of app use
these structures what you should
actually be using is a free list or what
you people in JavaScript call an object
pool right so here's the concept so
rather than actually going through this
this loop set where you actually delete
an object and then add a new object
delete an object on that new object
what's actually occurring is every time
you do that you're going back to the
heap you're hitting the heap asking for
new representation hitting the heap
asking you for new reputation the
garbage collector
they're going crazy it's like sweet I
got stuff to do now awesome it's like if
you given the thing cocaine and a puppy
and said go play in the meta right not
that we advocate puppies and cocaine via
you know let's move on so instead our
opinion is not my opinions out that of
his opinion my opinion is not that of
any representative organization that has
anything to do affiliated with me please
not contain any of my topic says that
you guys have heard it look look at the
other episode so instead the idea is
this what if instead of actually
creating new objects all the time when
an object was deleted instead of
actually throwing it back on the heap
you actually just pushed it into a
separate list and the next time you come
around and someone says please give me a
new object instead of going getting from
a heap you actually grabbed it from this
list of objects that are no longer
you've used again this is called either
a free list if you are in C++ or any
sort of Satan language or an object pool
if you're any in any sort of crazy
managed language because in most managed
languages they refer to everything as an
object including integers so the cool
thing here is that when you call delete
or free you actually push the thing back
into the pool and what starts happening
here is that you'll see the growth
pattern for your entire application
level off so in grits if you actually
get a chance to get on the TAM server at
worst you can only have maybe about 200
to 250 active entities moving in the
environment so this is if you have all
four players all shooting the machine
gun at the same time all the bullets are
live not hitting anything each player
has quad damage on and all of the
objects in the world like the health
pick up canisters and nav Canada's
canisters are all sitting around doing
stuff right at worst you get about 200
of these so what happens is all those
things next frame are going to die maybe
you'll drop down to 160 120 something
like that and when you do you'll with
this setup you'll actually get 40
objects pushed back onto your free list
and then next frame let's say you do it
all again now you've got 40 new objects
in you to grab well you just grab them
from the free list so what happens is
over time your application stops
allocating memory because you actually
hit the profile curve where you actually
stop doing intensive stuff you know we
never go above 400 so what happens is
over time you stop beating on the
garbage collector and you stop letting
it cause madness all of your code
because as we talked about last week
right the garbage collector
can manifest itself and run anytime
JavaScript code is executing even if
you're setting a variable x equals 1 I
guess what that took 37 milliseconds
because the garbage collector decided it
was time to do as little song and dance
so your goal as programmers in java
script writing high performance
applications is to stop the garbage
collector treat it classy right who
reads penny arcade two guys and one guy
was like yeah reap any arcade come on
it's the quintessential gaming arcade
coming there's a fantastic comic by
penny arcade way back in the day with
actually complaining about the language
filters and Gears of War who's played
gears of war try that one no wow okay
yeah we got a course of our game
development no one reads gaming comics
or plays video games this will be
interesting okay anyhow Gears of War is
a very violent very mature game that
uses very violent and immature language
and so the penny arcade guys saw this
little box in the settings that was like
you know censor content they're like
what is how do you even do that like
this is a game about chainsawing people
as they fly through the air like how are
you going to censor this and so the
comic they actually wrote was this dude
chainsawing another dude saying your
mom's a classy lady right like that was
their entire concept of this so the
whole point of it is treat your memory
classy right don't bang on it don't give
it a lot of you know free objects just
roaming around treat it with respect
because that's actually the only way
you're going to get a high performing
JavaScript and here's a great example
did I miss the link can I go back oh oh
dude I broke it huh what did you think
that link right what did you do there it
is okay so here's here's a nice little
Lincoln let's see how the well this
turns out so you people here in the room
you're going to see something very fast
something very moving you people on the
livestream I'm sorry this going to be a
little slideshow II that's my fault not
the geniuses behind the table the bald
guy broke everything so what you're
actually looking at here is about three
thirty thousand yeah you're looking at
three thirty thousand entities running
around kind of updating as my mouse
cursor moves uh now i don't know if any
of you in this room have actually tried
to update 30,000 entities in javascript
but it is not as straightforward as you
would expect if you try to add thirty
thousand objects into your JavaScript
array and then iterate
over them in a position and then draw
them to the canvas you will not get the
60 frames per second performance that
I've seen right now anyone actually try
this before and I'm looking you know
okay maybe so the interesting question
is well how are they actually doing this
how are they getting 30,000 units
running around the world well they're
actually taking into account the fact
that you should not be touching memory
allocate your memory leave it around
don't let the garbage collector do
anything that's the only way to get fast
performance let's take a look at how
they're doing it I go back return to
full screen I like that button it's my
favorite button of all time that's it
there we go next one so what they're
actually doing so so let's take a
concept here top to bottom so typically
when you define a class or a structure
this is how you do it right you've got
some container object that has a parent
a pointer to its parent and then it's
health value and in 32 and then an is
dead pointer which is usually a boolean
or a UN tape right so what will happen
is that you guys generally create a big
array with these structures in it right
so you push these objects in there this
is a data metastructure known as an
array of structs okay this comes back
from the sea in the c++ days where an
object was only either a structure or a
class and this microphone is going to
kill me in stamp away from it mmm what
we call in a ramps drunk so what's going
to happen is when you go through that
little loop and your update code and
you're just checking the is dead flag
what happens is your only actually
checking one element and you're doing
that even though the full data is in
memory so here's another great question
how many of you people have actually
done hardware courses or know what an l2
caches ah I see some of the same hands
and that one guys like a sure I know
what an l2 caches so what actually
happens here so let's hypothetically say
that you've got some hard work ship for
those who don't understand it or who are
not familiar with the term the processor
generally tries to define itself to do
the least amount of fetches from ram as
possible it tries to preload as much
data into it's only local view of the
world and then fetch from that because
that's super fast any time you got to go
back out onto the bus to hit memory it's
actually really really slow this is a
principal cash what the processor will
actually do is when you fetch some
address in CPU memory it'll actually go
fetch that access
that address plus some other data beyond
it and this is what we call a cache line
so on the xbox 360 a cache line was 512
bytes so when you accessed a single
element in array it would grab that
memory position in RAM plus 512 bytes
after it and it would put that in a
cache line and then we can iterate it
through that array you would touch
everything inside of the cache line
rather than having to go back to main
memory every time of course when you
actually accessed elements 600 are the
byte number 600 it would have to
actually flush that cache line load into
cash flow right so what you actually end
up with in a situation right here is
let's say this single structure object
is let's say 128 bits and you've got a
512-bit cache line right so when you
actually grab the sixth object even
though you're only looking for eight
bits worth of data out of each object
you're going to flush that cache line
we're going to keep doing this as you
start ending up with 3000 4000 30
thousand objects now in JavaScript you
guys don't really see this manifest
itself because you've got a lot of data
and a lot of code between you and the
underlying hardware what it still
manifests itself when you get to 30,000
objects moving around now the way to
counteract this is a transposed data
structure no one has a construct of
arrays so rather than doing a single
array full of each one of these
structures you transpose the thing and
actually put all of the flat all of the
members from each one of the your
objects that are live can take you us
against each other so I'm gonna use this
laser pointer now so you can actually
see that this top here is actually an
array of pointers to the M parent this
next one here is an array of all M
health's and this one is all an array of
em is dead so in this set up so let's
say object I just as in it if you
actually want to get the collection of
data for object I you actually have to
sample vertically so you have to say you
know give me em parent I and I actually
give you the parent pointer for this
object as well as the health I and is
dead I now the cool thing about this is
that actually allows you to if you're
just walking through our loop and we're
just looking at is dead we don't have to
load the whole object we only load each
8-bit representation of whether or not
that thing is alive or dead you actually
flush less
lines over time this is actually gonna
create very very performant code do I
have another thing here yes so you can
actually see here that the way we've set
this up is that we actually used typed
arrays set up in this fashion where the
parent is just a single array because
we're just pointing to objects and then
we've got an int 32 array in an int 8
array because these are actually again
allocated in the WebKit layer so you can
actually have 30,000 objects that the GC
doesn't even know about right it's all
in WebKit to it it's just one object
that it kind of scope a cool that's a
thing this is how you get performant
code in JavaScript and I know a lot of
you aren't at this level you're not
dealing with 30,000 objects but you
should keep this in mind as you're doing
things so I want to actually take one
second I know we're okay on time so far
and I actually want to pull up the
source code to this it's kind of fun to
play with and what you can actually see
here is so they've got some interesting
stuff going on for requestanimationframe
and everything oh yeah fantastico so we
can actually see here is this tick
function this tick function is actually
where all the time is being spent right
so now any of us in this room would
naively implement this algorithm as
create 30,000 entities in each and then
go through a loop for each entity and
update its position x and y based upon
some velocity vector and some flocking
heuristic based upon weighted observance
of a graph structure or whatever these
guys aren't doing that instead of what
they're doing is they're using sort of a
struct of arrays or a linear memory
layout and actually updating each one
individually so you can actually see
this is actually an algorithm called
poor man's effect and so what they're
doing is they're actually walking
through each element of the typed array
and updating data properties on it
rather than actually viewing all of this
as single objects right so they've
basically just taking everything I just
talked about and applied it that's how I
getting 30,000 particles actually flying
around the screen you can see they're
actually doing acceleration velocity
collision detection objects in some
cases object avoidance or at least
they're all trying to move towards a
single object in space right they're all
trying to go through to your mouse
pointer and then the real magic here is
actually the single line ctx put image
data so what they're actually doing is
they're actually taking this contiguous
array represented our
well manifesting itself as a 2d image
space and actually just mem copying it
into whatever the canvas is doing so all
of these objects flying around three and
they're not actually doing single draw
calls are actually again batching all
that up the point that I'm trying to get
to here is that any time in one a
history of computer science but I've
ever wanted to actually make code more
efficient there's only four ways to do
it this is again my representation not
that of any individual or instructional
institution which has anything to do
with me you can either back it call it
hash it or thread it that's it batch
call cash threat bc CT there's the only
way to make things more performance and
what these guys are doing our batching
stuff right there doing instead of
actually doing single object
representations are actually doing large
object representations we're also
batching the put into the object into
the canvas instead of doing each
individual pixel being plotted in right
there they're cashing a lot of their
data right because instead of actually
having these objects in in sparse data
arrays they're actually doing lookups
with some of the velocity stuff you'll
see a little bit later and they don't
have to thread it because this is
JavaScript and web workers are a little
bit wonky and they don't necessarily
have to call it because you know they
don't that all their data needs to be
simulated so anyhow the whole point of
this entire drive tribe which is now
taken way too long is that when
representing entities in your in your
class when anything else go back to the
basics computer science is still
computer science data structures are
still data structures it doesn't matter
if it's C++ Java or JavaScript what
makes something fast in C++ pretty much
will work in JavaScript as well you just
got to look at it from the right angle
so if anyone in this class and some of
the people on the GBC who've actually
said this if you're looking to do 20,000
30,000 objects moving around the screen
definitely take a look at some of these
things that we've talked about today
right make sure you understand your
growth pattern for objects make sure
you're taking a look at bucketed growth
make sure you're looking at typed arrays
and most importantly make sure that
you're looking at cashing your objects
using least invasive memory analysis
treat your memory classy and you will be
rewarded with performance the end
now I'm going to sleep ok good suffer
it's more that bread pudding now those
are gonna life sent this was not
accelerated to 2x was I talking that
fast was that bad blazing that's perfect
yeah it's good you heard it here first
all right so we got some questions for
those of you that have questions about
Miss Bates unit or even just anything
else um microphone here at up front okay
yeah go ahead let's go mm-hmm I will not
repeat all of that I have a question
about what you just say where would I
where we look up those kind of patterns
oh great question where would we look up
these kind of pattern oh wow Cole's blog
we yeah so so I have a lot of some of
these data structures are listed on my
blog actually have a couple articles in
flight that I'm going to put on html5
rocks hopefully that talk about some of
these things if you if you just google
for data efficient data structures
you'll get things along these lines
right also really if you guys really
want to scrape the bottom of the barrel
and figure out where the most performant
code on the planet is is go google for
programming interview questions yeah
right because you'll get questions like
this like hey you know find me the first
duplicate e in this string i give you
arbitrarily and don't allocate any extra
memory right and actually starts making
you think about some of these things so
free pools object pools binary trees
bucket ization I don't really have a
single resource that's an asset yeah
there is one website called writing a
performant code performant optimization
just google for writing fast code
writing efficient code i think there's
one great resource on the internet that
i don't have the link to just yet i
apologize i don't i don't have a good
answer for you right there besides just
google for that face sorry
hey I wasn't entirely sure about the
performance reasons for the speed ups
was it because the memory was contiguous
or was it because the things were being
truly treated as native entz and not as
objects to contain tins ah great
question great question and I was like
one yeah okay it's just uh is this work
on all browsers or just WebKit oh yeah
in whatever the type of the type
different yeah great question so uh in
with garbage collection really yeah
really so two questions the the first
one was where does the performance speed
up come from does it come from the fact
that it's a contiguous array or that
it's a typed array inside the WebKit
later that accurate okay so no in fact
the fact that it's a typed array in the
WebKit layer is actually gonna make a
little bit slower in some respects and
faster in others so in a standard
JavaScript array everything is an object
oh here here's another great pop quiz so
let's say you create a new object and
you pass in an int value to it most
browsers will actually have a very
specific representation of that they'll
say oh you've given me an integer i am
going to optimistically assume and give
you the benefit of the doubt that you're
going to continue pushing integers into
this array and so what it'll do on your
behalf is it actually go under the hood
and actually create a typed array for
you okay so let's say you pass int 2 3 4
5 6 7 and then you actually push a
string into the array well now you've
just invalidated that VMS assumption and
what that vm will do is actually stop
right there create a new array back in
the JavaScript layer that can be
heterogeneous and actually delete the
thing in WebKit and so when you push in
that string you're actually going to get
a worse performance hit because of that
right so so the vm is doing weird stuff
under the hood i tell you that story to
to let you this story is that every time
you access one of these typed arrays
what has to happen is you have to have
to actually make a transition from the
managed layer of javascript inside of
the vm to the unmanaged WebKit code
right so you actually move what we call
thunk you're going to perform it stunk
so you're moving from managed code to
unmanaged code which actually has to go
through this nice little vm path to grab
the data and then push it back into the
vm calculation the reason that this is a
performance thumb because because
there's actually like these massive
gears of death in there that try to in
that are not performant at all so access
is into this ray are actually a little
bit slower hypothetically right that
being said accesses to objects inside of
JavaScript are actually slower because
actually getting double penalized for
your accesses so anytime you do push an
object into JavaScript what actually
occurs when you access it later is you
have one look up to actually fetch the
location the array and then another look
up to actually fetch the object itself
and then if it's actually if it has
properties on it you can do another look
up yet to actually get the property so
you actually end of get this daisy chain
effect of references going through so
you're kind of trading one off for the
other and this is where the efficient
caching comes around right so what you
want to make sure and the reason that
you're getting these performance wins
with the typed is that your amortize the
cost of all this over so many elements
and arrays so if you actually just had a
hundred objects and you created as typed
arrays you're not going to see you're
actually going to see worst performing
code then your standard array right
maybe even a thousand maybe 5,000 maybe
7,000 depending on your architecture and
what browser you're using you actually
see that standard array will win out but
once you'll hit a limit we actually see
that the ten thousand objects actually
is a win because the access patterns the
overhead all that stuff actually is in
favor of the typed array rather than
standard array I hope that that's
answering question the right way if I
put something in a type for it is not of
that hi
why cause miracles well that should
throw an exception okay yep the type to
raise are really arrays they're not
checking types they assume your type
yeah yeah so there's a couple min if
it's there so number one is if you if
you push something into a JavaScript
array that's it doesn't matter right but
it but it's extended over the bounds of
the contiguous memory slot it'll access
and it all acade a new one right in the
same way that trying to index out of
bounds will throw an exception right
indexing out of bounds and the type rate
will also throw an exception right so so
there's some nuances there that are
similar but yeah if you have a typed
array and then you push a string to it
everything gets deleted and push back oh
here's another great question um so
here's a funny new ones that actually
blew Sean's my yeah so okay you've got
an array and you've got six objects
fubar and dubstep and those are only
hold integers so you push foo into the
array javascript says cool you're doing
in an integer array then you push bar
and it says cool we're still an integer
array what happens is it doesn't
actually push the object reference it
actually pushes the value so you push to
seven and six and those two seven and
six actually ends up in that typed array
so now let's say you actually push a
string well now we have to convert this
int int array into object object object
array so where did the objects go that
we're holding those integers if you're
lucky they're still sitting around the
garbage collector heap somewhere and you
can actually find the proper references
to put them back into the new array if
they've actually been collected you
actually have to just create new objects
and poke the data values back into them
well javascript will try to do it for
you javascript will try to do it for
obably not well yeah basically what
happens is you end up in this really
weird scenario where JavaScript's going
like oh crap we got to make new objects
we didn't we didn't have an object array
before and so it'll actually do some of
this overhead and try to find the
software so the point of this whole
monologue is that only do homogeneous
arrays it never mix your types all in
San Juan array all strings in one array
all objects in one array you'll notice
that your your free pools and your typed
your free pools and your type lists and
all that stuff will greatly benefit from
this man a model write your code like
it's see
for all of those who hate see that
answered type systems are wonderful obey
them even if they're not there yes all
right any other questions from the
audience here all right we'll take a
couple from the from the moderator so
first question from Flay's flava flav
rendering Dom elements on top of the
canvas kills my gangs frame rate on
slower computers how can dom elements be
made to render faster so access or
change the Dom I'd say yeah yeah so I
think I think we talked about this last
week didn't we where every time you
access or modify the Dom tree that your
real you actually have to reflow the
entire Dom tree so every time you're
doing anything to those Dom elements
yeah so every time you're doing
something to those Dom elements on top
of your canvas that are you know some
kind of game you I or something like
that you are causing a downward flow
every single time so if you're doing a
UI on top in dom elements which probably
really isn't a bad idea it should
probably be mostly static i would say if
you're changing it a lot then maybe you
should think about not accessing the dom
as much any dad i guess the only other
thing would be if you're using lots of
CSS to style those elements that add to
the confusion and bike do you have yeah
anything to share yet them that yeah a
lot of our recent work with a recent
work yes yet another blog post that's
pending that I have total amount of time
to do so everyone in here knows that all
CSS tags are not created equal I hope
right so CSS tags are not free if you
actually add drop shadow with rounded
corners you actually get so it's okay so
so if you add drop shadow to a CSS div
on your screen you run it on mobile
you're actually gonna be running a
little bit slower why because anyone
anyone read how
or browsers actually do their
compositing cool so what happened side
of that sorry Tony there's going to be a
little bit of a drop yeah um so uh we're
going really deep today I apologize to
everybody out there we're going really
deep so how modern browsers actually
work is that they dice up here your your
web page I'll use chrome for example
chrome will actually dice up your web
page and the 256 x 256 tiles any div
elements that intersect those 256 by two
of these new styles will actually get
passed off to a software rasterization
framework called skia sk IA it's an open
source framework i highly recommend you
go check it out this is the backbone of
how this works skia will actually take
your divs and your CSS translations and
your text and your positioning
information and your image is it will
actually create a in memory 256 x 256
bit map so it basically collapses all
this data that 256 x 256 image will
actually get cached in an LRU style cash
and then upload it to your GPU so now
it's actually sitting in your GPU from
then on all these tiles are created the
GPU handles scrolling right so instead
of actually re doing this for every
single pixel that you move vertically
the GPU is actually just moving quads up
and down the screen so any of you
actually running android devices round
of applause oh come on round of applause
fantastic happy crowd tonight so if
you're actually running chrome on
Android which you should be the latest
stable actually has this turned on by
default so you're always using GPU
compositing for this now one of the
interesting things is that the CSS tags
can have massive Rama for amma
performance random ramifications right
so if you have this drop shadow element
right this software rasterizer actually
actually go create a drop shadow so it
actually has to rerender the object with
these gradients with these clipping
rectangles with these splines and then
make it all look good and then it has to
do that for each tile and it has to do
that for each element on each tile right
and then once one of these tiles
actually gets invalidated by the cash it
has to do it again and again again again
again yeah the interesting part about
all this and this is what Peter was
actually alluring to is that we don't
actually as a web community understand
the performance ramifications of this so
I actually wrote
some crazy little code it'll actually it
actually generates a permutation list so
basically i catalogued every CSS element
and i wrote a little python script that
will print out an HTML page that
contains one div with that CS element on
it and so i've got like thirty thousand
HTML pages right then i wrote an
automator well actually no chrome load
that page take a snapshot using the skia
process and the debugger here by the way
will tell you how long it took to render
that element right so I now do a
snapshot on these thirty thousand
objects which then gives me 30 thousand
skia picture files which then are
analyzed they give me thirty thousand
numbers that represent how long click to
render that single div on the screen
collapse all this data put in the night
spreadsheet form we now have a
scientific way to actually know how much
a single CSS property takes oh it gets
better probably all of you who are
already tingling so getting up getting
down deeper we actually find that the
single object don't matter these are
actually pretty cheap to do when you
actually start combining them you get
crazy stuff happening so if you actually
take box-shadow plus border radius and
you put them on the cost to do that is
not the sum it's actually the
multiplication who knows why I'm not a
WebKit guy right but what you actually
end up with is actually like a 2x or 3x
cost when those two elements are
combined anyone load the New York Times
anyone notice their rounded rectangles
with drop shadows on it anyone load the
verge calm birch anybody anyone notice
that the verge is actually using an
inner blur tag for each of their little
piles on their screen that actually
causes the compositor to actually have
to ring composite and recreate like
seven or eight layers each time you
actually have to invalidate that tile
not all CSS is created equal I have a
blog post hopefully coming soon when I
can stop talking that'll talk about this
a little bit more for those hopefully
this answered the question on the that's
great I've too much sugar tonight Tony
yes thank you for waiting there was a
comment just before the show started you
said I'm not gonna talk today but
anyways no no it's very informative the
follow-up to the thing that Sean said
prior to that if I had a canvas and then
I and then I
doing all sorts of game stuff in it but
I have some things around that in the
page you're saying bad okay if you are
modifying it like okay you know and i
would be manos de you worry about it
yeah what if you stuck the canvas into a
frame would you have the same problem
yours you're still changing them okay so
even the inner frame inner frame move
the Dom it's going to reflow it yeah
every single time okay if you had a UI
for instance that was entirely static
that would be fine but if you have say a
health bar that is you know changing
back and forth and going up and down
each time you're modifying that health
bar that is a div for whatever reason
your reef lowing the Dom got it okay
yeah because we do have a game where we
would want to be showing our entities
might be calendar items and we want to
be summarizing them not in the canvas
but elsewhere okay so we're gonna have
to be very clever about this so that the
advice there is batch batch batch
packaging so so there's a there's a
concept in high performance computing
known as frame aware multithreading and
so effectively the concept there's a
great book anyone here who wants to know
multithreading go read a book called the
art of multi-threading it's the only
book you need read that book it'll teach
you everything you need to know about
concurrent programming so if you guys
have read my bio I used to teach at SMU
guildhall one of the classes I taught
was concurrent threading and I required
every single student that ever came
through my doors to read this 600-page
book about how to actually write
concurrent throat anyhow the concept of
frame where multi-threading is that the
transition between two processing frames
will sometimes need to cash the state of
the environment so that the subsequent
frame is actually looking at a stale
state so this is how you actually have
to get around touching your Dom what you
need to do is you need to batch all of
your reads do whatever execution you
want on them and then batch all of your
rights because if you do a read i'm
going to write the next read you do
that's interleaved has to recalculate
the Dom wanna read and then a rights
precalculus dump read right recalculate
the Dom so but if you do read read read
read read reread again batch cull cash
thread batch them together it's the only
way to get the performance out of it you
need
mm-hmm all right next question I have
too much caffeine the problem the
burglary was also is that about puppies
okay so next question from the moderator
is is there any part of game logic that
could realistically be handled in a web
worker such as listening for a user
input or WebSocket traffic if so could
one expect enough performance increase
that justify the added complexity so two
parts it up and I was just trying to
look up a quick demo that they gave and
I'll try to find it later actually it
was from an html5 developer conference
presentation i gave last year and
burkhead this here the audience is good
look it up for those of you that are not
aware the html5 developer conference is
back in town this guy's going to be
speaking there so check it out goodbye
ticket yeah so me April first second or
third here in San Francisco at the
palace hotel is going to be awesome all
right so two parts the first thing I
wanted to pull up is a comparison with
the sort of the old post message versus
the new part which is told to
transferable objects so you can use the
post message but basically just sort of
a you know that you push a message to
another context and it can be relatively
slow i mean post messages used to
communicate with the worker so just to
back up a second to create a worker you
post message to it and you listen for
messages that it sends but in most cases
and I think colt was referring to it
earlier sometimes a little wonky where
you don't get quite that performance now
transferable objects tickle is a huge
boost for performance when it comes to
web workers you can you can I think it's
a straight copy of memory and I'm not
quite sure how it works on their good
but it's a huge difference you can the
demo is going to show is like the number
of milliseconds it would take and it was
just incredible
10 or 20 times performance increase so
that's one thing about the postmessage
calls you make for web workers now not
all browsers support that yet so you
have to be careful the other thing if
using it specifically for web socket
that I've done a lot of work with the
WebSocket stuff I would not well first
of all you can create an XML HTTP
request from a web worker you cannot
call as far as I know you can't call web
socket from there because you need to
window object so I don't think you can
get to that but even if you could the
WebSocket isn't sort of you have an
asynchronous listener for messages
coming in from the web socket hopefully
that's something we're going to cover in
a lot more detailing the future the
second part of the server side of the
grits course that we're already planning
out I keep referring to that no firm
dates on that yes but your it's already
asynchronous so you would get a message
back from a web sockets object then and
you know you don't really need to do
that inside a worker and then pass it
back to the page so that specific use
phasers not so good I think you might be
able to get some benefits of doing
something with the transferable objects
I don't think have you ever played with
that around in games specifically uh not
in games most less the time the overhead
so so anytime you want so batch call
cash thread right so the the only reason
that you should actually thread
something is when you have a large array
of data and you want each worker to kind
of do a subsection on it this is
probably the most productive fork and
join style of multi-threading that you
can take advantage of if you're trying
to do a different sort of threading
model where each one gets different set
of lists you're doing a quarter update
or something along those lines you
actually gonna run into more problems
than you need to so the postmessage
callback and the overhead involved with
that is actually doesn't transfer to
this type of threading model because any
time so basically have to copy your data
with post message to the web worker the
web burger has to do data access on it
and do calculations and then you got to
copy that back and now the transferable
objects is going to make that a lot
because rather than actually doing a
copy it'll actually just do a memory
reference update so that'll be tons
faster so with transferable objects
typed arrays and a fork and joint style
process for web workers you could get
some really nice performance and in fact
I actually wouldn't love to see someone
write a software rasterizer in
JavaScript that takes advantage of this
weight thank ya this is the demo of
talking about so this is a problem that
does support transferable object you'll
find here that post methods round trip
is in the neighborhood of three
milliseconds this will be more in the
neighborhood of like a hundred 160
milliseconds and browsers that don't
support it and if you want to know which
browser supported obviously you go to
can I use com also on web platform that
of work we're working pretty hard to get
the browser compatibility at it so can I
use that com will tell you specifically
which browsers including the mobile
browsers support those things so check
that out but usually this is pretty easy
to backfill right to polyfill you just
fall back to regular old post message
with slower performance okay great
alright so you said that browsers pick
relatively arbitrary time to start and
stop execution of JavaScript callback
functions said ever a time when one such
callback will begin execution before
another one has finished no single
through now No yeah all right from c-bus
from Amsterdam oh wait my game status
update and screen draw functions are
getting bigger and then wonder if
there's a any good approach to
multi-threading in JavaScript to avoid
long cycles waiting for the game to
update and I'm new to the language so
one of the things we want so the
multithreading kind of comes a little
bit back to the workers that that's
often said well JavaScript the single
threaded use web workers and then that
wasn't good enough and then the
transferable objects sort of give you
something close to them first thing to
wonder about is like why is this getting
slower and slower right and one of the
things probably the first 35 minutes if
you slowed it down and regular speed
they might take it five hours to to
watch that but I'm sorry that has a lot
of those pointers in it and one of the
things to look at is the chrome
developer tools you can actually look in
the chrome developer tools and take some
snapshots in the different profiling
tools and see where the garbage
collecting collection is taking place
what's happening on our two hoods in a
little bit finer grain detail
where you going to show the propylene
Pro Bowler to whoever comes ya know if
we can we have five minutes so here hold
it I've got a microphone I will say by
the way this this question is a little
vague to me I can't tell if the author
is talking about complexity size like my
update loop is now above sixteen
thousand lines of code I'm not sure
we're multi-threading to access that so
I'm assuming that the author is somehow
actually profiling their code and
finding that the execution time is
getting too large in which case I would
actually point them to what Peter is
doing here and actually open dev tools
and and I can I can I guess so in the
profile tab here I'll just narrate since
you're clicking in the profile tab here
under chrome dev tools there's actually
this nice little under the profiles tab
collect JavaScript CPU profile so when
Peter hits that little record button
down there what it's going to do is
actually going to record as a sampling
profile profiler methodology what's
actually executing then it's going to
present it to you in this nice little
setup here if you set it to treetop down
and then sort by total time you'll
actually see that it'll break down each
of the function calls in a hierarchical
method so you can see which of your leaf
functions are actually taking most of
the time as you can see with this
particular setup that the tick function
which of the parent most one is actually
in early interleaves with
requestanimationframe call and that's
actually doing all of the work one of
the interesting things you'll see on
this particular setup is it actually if
you go to the Timeline view and actually
start a same capture here and then just
stop go ahead and expand that animation
frame top bar
under under records yeah right there
down to down down down down town video
screen or very happy baby okay yeah so
you expand that bar there basically yeah
so so what you'll notice here is that
make you very the first few things are
garbage collector events and then you
see request animation frame animation
frame garbage GC of NGC event so what's
actually occurring here if peter can
resize that out a little bit when he
mouse is over it'll actually show like
nine Meg's is being freed each frame in
garbage collector events so you can
actually see where your code is doing
bad things because stuff is getting
freed now I showed this same demo
earlier as the quintessential archetype
for what you should be doing it turns
out there's actually a little bug in
this program is that they're actually
trying to get a timestamp to determine
how long the simulation is taking and
the time slight they're using is a unary
plus and then date which will actually
grab the date-time object and then do a
type task to an integer well this
actually forces this path to be d
optimized in the v8 optimizer which
actually dumps everything through the
floor and actually generates a garbage
collection and what's going on so
they're doing everything else amazingly
well except this single unary +
operators actually causing performance
after 10 seconds on mobile devices to
fall through the floor that's actually
the interesting thing whatever your
performance profile you're getting now
times it by six and that's generally
what you're getting on mobile nowadays
high-end mobile so if you're if
something is taking one millisecond it's
probably taking about six milliseconds
on mobile and your browser set up so
just be aware of that as a nice little
ballpark metric that is not a scientific
my representation events or nothing
based upon those people who are so kind
of me right awesome alright so it was
another question
let's see here suppose we want to
display scrolling text status messages
to chat etc negative or a text area
whatever and only have it scroll down
when it takes us at it when the school
handle is at the bottom of the scroll
bar okay how can this be done um reread
is here yeah okay sounds like just the
HTML set up he's yeah look why don't we
since we only have two minutes left
plays we're going to comment on this
question in the moderator and ready
event and quickly take the last question
here if there's anyone in the audience
last chance I have a question just come
on up to the mic cold can you post at
forum old book names that you talked
about in all the study groups the books
about physics game and last about
threading so yeah absolutely so if
you're on a live feed or in the room
follow me on Twitter it's at da roach
duhr Oh ACH also follow me on Google+ is
just + Colt McAnlis I'll put up a blog
post hopefully in the next couple weeks
that will list out all these resources
in a semi sane way and i'll post to
those feeds when the things go live yeah
yeah perfect i can put them on the wiki
of the form yeah right and then we can
yeah post it up so okay excellent so any
questions here before we wrap it up and
doing right on time okay yeah all right
so one in final thing I wanted to
quickly take a check here so it's been
this is our fifth week we're past the
halfway point yes as you know we have
the contest running we have talked about
that yet how is a contest coming along
for you guys I know you guys are working
on a cool game um how's everyone I was
doing thank you right I'm going to write
a particle simulator that moves pink
dots around a screen well you get
started let's start with that right
spray right it's probably not too late
to start but I think it's going to be
too late pretty soon yeah so if you want
to join the contest go to the Udacity
site go to the resources the wiki
there's a study group information page
there's a contest information page we
have some really cool prizes including a
ticket to i/o which if you haven't
gotten one you can't get one anymore
except for well they're probably some
other ways but not too many challenge
accepted they're all sold out they sold
out in I think less than an hour that's
what I heard so yeah so definitely check
it out the cameo appearance on The
Audacity the future Udacity training
course lots of other cool hardware
prizes so definitely worth your while
and a good way to sort of play around
with the constants as well of course all
right so is there no other questions
we're going to wrap it up here and tune
in next week or the same thing well busy
setting up physics leave me yeah this is
nice it it holds jumping on a plane or
jumping off the plane to pay off a clean
how are they for I'll be well
caffeinated next week all right well
thanks for ruining yeah hey thank you
guys
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>