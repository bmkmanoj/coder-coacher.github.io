<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>All Pairs Shortest Path - Georgia Tech - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="All Pairs Shortest Path - Georgia Tech - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>All Pairs Shortest Path - Georgia Tech - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jcj1IahXbcw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now we turn to our last example of
dynamic programming and consider the
problem of finding shortest paths
between all pairs of vertices in a graph
if you're rusty on ideas like paths and
graphs or Dijkstra's algorithm it might
help to review these ideas before
proceeding with this part of the lesson
note that the idea of shortest is given
in terms of weights or costs on the
edges these might be negative so we
don't refer to them as lengths or
distances themselves to avoid confusion
but we retain the word shortest with
regard to the path instead of saying
lightest or cheapest unfortunately the
use of this mixed metaphor standard
we're given a graph G and a weight is
associated with every edge in the graph
and our goal is to find a shortest path
between every pair U and V in the graph
that is to say a path that minimizes the
sum of the weights involved in the path
note that the idea of shortest here is
in terms of these weights these weights
might be negative so we don't refer to
them as lengths or distances to try to
avoid confusion but on the other hand we
still refer to the paths at the shortest
instead of saying lightest or cheapest
unfortunately the use of this mixed
metaphor is standard recall that for the
single source problem where we want to
figure out the shortest path from one
vertex to all others we can use
Dijkstra's algorithm which takes a V
Times log V Plus E time when used with a
Fibonacci Q but this algorithm requires
that the weights all be non-negative an
assumption that we don't want to make
for graphs with negative weights the
standard single source solution is the
bellman-ford algorithm which takes order
of V times E time now we can run these
algorithms multiple times once with each
vertex as the source if we visualize the
problem finding the shortest path
between all pairs as filling out a grid
like this one then dijkstra or
bellman-ford would correspond to filling
out this one row at a time one call to
the algorithm to fill out one row of the
table this strategy involves running
each of these algorithms v times so we
can just add a factor of V to their
running times to get the
all pairs shortest path version where
the weights are non-negative this
strategy of using Dijkstra's algorithm
is quite competitive for the case where
the weights could be negative however
and especially when the graph is dense
we're looking at an algorithm that is on
the order of V to the fourth for a
bellman-ford using dynamic programming
we're going to be able to do better</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>