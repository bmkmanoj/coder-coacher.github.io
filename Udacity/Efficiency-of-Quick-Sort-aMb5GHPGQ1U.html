<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efficiency of Quick Sort | Coder Coacher - Coaching Coders</title><meta content="Efficiency of Quick Sort - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efficiency of Quick Sort</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aMb5GHPGQ1U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as it turns out the efficiency of
quicksort is actually pretty complicated
first let's just focus on the worst case
what would that look like the magic of
this algorithm is that it cuts the
number of comparisons you need to do by
splitting the array in half pretty much
every time so the worst case for us
would be if we couldn't split the array
in half and had to do all of the
comparisons every time you will end up
doing all of the comparisons if the
pivots are actually already in the right
place since 13 is already the biggest
element we'll end up comparing it to
everything else on the first go and
realizing that it doesn't need to move
this is a lot of comparisons to do it
once but the real problem happens when
the next value is also the largest again
we end up comparing to everything
smaller than it and we're not saving any
steps hopefully the number of
comparisons here reminds you of bubble
sort
remember in bubble sort we would have to
compare each element to the one next to
it again and again and again and again
eventually we could leave off the ones
that were at the end because we knew
they were in the right place they the
worst case of quicksort is exactly the
same which means that the worst case of
quicksort is actually Big O of N squared
for something called quicksort that's a
really terrible efficiency however
quicksort is useful for two main reasons
first of all the average and best-case
complexity are actually n log n in a
good case the pivot will move down to
the middle and we'll get to divide the
array in half every time with our pivot
in the middle we can look at the other
halves of the array and move their
pivots to the middle too since these
pivots are sorted we know that
everything else is sorted so we're done
really quickly here because we're
cutting the array in half every time
it'll end up looking a lot like merge
sort so again that's why your efficiency
is n log n the average case is actually
going to look a lot like this we'll pick
a random number it'll move close to the
middle and so on and so on however if we
know we're going to be getting a rays
that are near sorted if we don't want to
use quicksort since that'll end up being
the worst case every time the second
point is that you can do some
optimizations with quicksort that only
get run faster for example when you
split your array you can configure your
program such that it runs both halves at
the same time it'll end up using the
same amount of computing power but it'll
eat up less time also rather than
selecting the last element as a pivot
you could look at the last few elements
and select the median of them as the
pivot selecting the median will give you
a better sense of what's in the middle
of the array overall so you have a
better chance of moving your element in
the middle and having that best case
scenario also this version of quicksort
is in place so we aren't using any extra
space our space complexity is constant</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>