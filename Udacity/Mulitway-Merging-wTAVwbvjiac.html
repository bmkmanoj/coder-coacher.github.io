<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mulitway Merging | Coder Coacher - Coaching Coders</title><meta content="Mulitway Merging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mulitway Merging</b></h2><h5 class="post__date">2016-06-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wTAVwbvjiac" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">recall the basic idea of how a two-way
merge works your initially given a bunch
of input runs each of let's say the same
size and each one's sorted in ascending
order your goal is to produce a single
sorted output a natural scheme based on
classical merge sort idea is to take
pairs of runs and combine them in a
tree-like fashion one problem with 2-way
merging is that it doesn't really use
fast memory to its fullest potential
remember how merging in fast memory
works at any point in time it uses very
little of the available fast memory
space in fact it uses just three L sized
blocks there's one block for each of a
and B and one block for the output C so
can you do better a natural idea is to
merge not two runs at a time but a bunch
of runs let's say K in fact let's start
by considering one of these K Way merges
you're given a set of K input runs each
of size s let's say they start in slow
memory and they're sorted in ascending
order let's also suppose that you've
chosen this value of K so that at least
k plus 1 blocks of size L will fit in
fast memory your choice of K is not
arbitrary let's say you've chosen it so
that k plus 1 L size blocks will fit in
fast memory this way you can reserve one
block for each of the inputs as well as
an additional block for the output
initially you would fill the inputs with
blocks of the input runs now at each
step of the local merge you need to know
which of the K input blocks has the next
smallest item let's say that these
shaded items are the next ones to
consider from each of the K input blocks
of these you need to somehow find the
smallest let's say that's this item
we'll come back to precisely how to find
it in just a moment you can move this
smallest item to the output buffer the
next item from a source buffer now
becomes active you then repeat this
process for instance maybe this first
block has the next smallest item so move
it and make the item that follows it
active as with two-way merge you will at
some point fill the output block when
that happens you just need to flush it
similarly you will at some point exhaust
one of the input buffers again if there
are any unread blocks of the input that
remain you just refill it now let's
return to the question how
you pick the next smallest item from the
input frontier you have several natural
options for instance one simple way is
to do a linear scan this is fine if K is
small otherwise you might consider some
type of priority queue data structure
like say a min-heap let's say we go with
a min heap you would then have the
following operational costs after
loading the first K blocks you would
have to build the heap which would cost
you o of K operations then anytime you
wanted to find the next item to merge
you'd call an extract min which would
cost you log K operations and after you
extract an item you might need to
replace it which would also have a
logarithmic cost now remember these are
all fast memory operations so when we
consider these costs we'll just count
them as comparisons now assuming a heap
based implementation what's the cost of
a single K way merge let's start with
slow fast memory transfers you only ever
read distinct input blocks once and you
only ever write distinct output blocks
once so that's 2 K s over L block reads
and writes what about comparisons first
there's the initial cost to build the
heap then every one of the K times s
items is eventually either inserted or
extracted since each insert or extract
costs you o of log K comparisons then
that's an additional asymptotic costs of
about KS log K comparisons remember
that's for a single K way merge now's a
good time to pause before seeing what
happens in the full K way merge tree</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>