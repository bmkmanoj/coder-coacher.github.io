<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mapping Virtual Physical Memory - Georgia Tech - HPCA: Part 4 | Coder Coacher - Coaching Coders</title><meta content="Mapping Virtual Physical Memory - Georgia Tech - HPCA: Part 4 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mapping Virtual Physical Memory - Georgia Tech - HPCA: Part 4</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/c5TD8QyRJcA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so when a program generates a virtual
address for example does a load or a
store to it the processor needs to
access some physical address the
question is how does the processor map
what the program is trying to access to
what really should be accessed this
mapping would be really hard if every
byte of virtual memory could map to an
arbitrary byte in the physical memory
then we will basically have to have a
huge table of mappings and we don't want
to do that because that table would be
very large and consume a lot of our
memory so instead the program's memory
is divided into equal sized chunks
called pages a typical page size is 4
kilobytes so this will be page 0 in this
program page 1 in this program page 2 3
4 etc so pretty much the first 4
kilobytes will be page 0 the next 4
kilobytes will be page 1 and so on
note that each page is aligned to the
page size so the page for example is 4
kilobytes and it begins at a 4 kilobyte
boundary so this is our virtual memory
our physical memory is divided into
slots that can hold pages and these
slots are called frames so if you
remember your cache is pretty much the
physical memory behaves like a cache for
the virtual memory in that it has a
certain number of places where we can
put pages so a page is kind of like a
memory block and the frame is kind of
like a cache line except that this is
the actual memory we have and this is
the memory that the program just thinks
it has but we never actually have that
memory so now the operating system
creates a mapping where it decides which
pages in the program will map to which
frames we can do something like this for
example so page 0 for example the
operating system decides to put it in
frame 0 page 1 can be in frame 2 page 2
can be in frame 3 if we have another
process it has its own page 0 page 1 etc
and these pages might map
two different frames if we want this
page one and this page want to be the
same because these two processes need to
share memory then we can map them to the
same frame and now when this processor
writes to its memory and this processor
reads to the same address they actually
are accessing the same memory location
so this process reads what this process
wrote but four page zero for example
they have different memory there so this
process sees its own content for page
zero and this process is its own
contents for page zero so who decides
how to do this mapping here and here and
the answer is the operating system
decides and the actual mapping mechanism
is called a page table it's a table that
says for each page in a process where is
that page really mapped in the physical
memory this is the page table for this
process another process with its own
idea of virtual memory will have a
different page table that says for each
page here where does it go here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>