<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced Transparency Methods - Interactive 3D Graphics | Coder Coacher - Coaching Coders</title><meta content="Advanced Transparency Methods - Interactive 3D Graphics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced Transparency Methods - Interactive 3D Graphics</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XAEUr0x8IhI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there are even more problems with simply
sorting objects and drawing them roughly
back-to-front for example notice that
the back faces are not shown for any
transparent objects if you turn back
faces on you'll start to get strange
rendering artifacts some back faces will
be drawn before front faces blend with
them some won't giving this patchy look
for example here's a view of a block
from the side along with an order that
the faces are drawn since face 1 is
drawn first face 2 blends with it
face 3 is drawn filling the z-buffer and
also blends with face 1 face 4 is behind
face 3 so is invisible when rendered of
the two back faces in this case only
face 1 has had an effect on the image
generated even with back face calling on
and a good sort order you can still have
problems with different sized objects
say a ground plane and a red object
resting in it are both transparent the
middle of the ground plane is closer to
the camera so by sort order it will be
drawn after the red object this will
make the ground plane to appear to be
above the red object here's one more
problem with transparency complex
objects can have two or more surfaces
overlapping a single pixel again it
depends on draw order as to what appears
on the screen if the fragment on the
left is drawn first then the fragment on
the right will and properly blend with
it at this pixel there's even research
about the ordering of triangles in the
mesh itself to avoid these problems but
this type of technique can be costly to
apply at this point you might have given
up all hope for transparency always
working right the z-buffer was meant to
store only one object at a time and
unless you can guarantee the order of
objects covering the pixels there's
little else you can do there are some
further tricks you can do by only
reading and not writing to the z-buffer
but there's no perfect solution if you
desperately want to get the right answer
there is one technique that works fairly
well called depth peeling the idea is to
peel away each transparent layer until
all layers are processed by storing an
additional minimum Z depth for each
pixel so for example the first layer is
all the transparent surfaces closest to
the camera
the second layer is all the
second-closest surfaces the third and
fourth layers are processed in turn
until the whole object is rendered
that's conceptually the key idea see the
additional course materials for more
about this algorithm the drawback is
that each peel operation needs to have
all the transparent objects rendered
again many passes may be needed before
all the layers are found and processed
ultimately what would solve the
transparency problem is storing a list
of all the transparent fragments in each
pixel along with their depths this
approach is known as the a buffer once
we have all this information we can then
combine these fragments in the right
order this type of storage is possible
in newer GPUs for the desktop but can
use a considerable amount of memory
what's interesting is that mobile
devices usually use a different
architecture called tile based that can
more easily keep such fragment lists
around yet another approach is called
stochastic transparency which uses
screen-door transparency within the
pixel itself along with some randomness
to get a reasonable average result this
brings us full circle back to the
original transparency algorithm I
presented there's no simple answer on
the GPU</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>