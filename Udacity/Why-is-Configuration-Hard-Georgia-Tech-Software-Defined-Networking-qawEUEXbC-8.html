<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why is Configuration Hard? - Georgia Tech - Software Defined Networking | Coder Coacher - Coaching Coders</title><meta content="Why is Configuration Hard? - Georgia Tech - Software Defined Networking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why is Configuration Hard? - Georgia Tech - Software Defined Networking</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qawEUEXbC-8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's consider a network of SDN switches
such as open flow switches and a
controller that is controlling those
switches and let's assume that we would
like to write a program using this
interface we can think about this
programming as proceeding in three steps
the first is that the controller needs
to read or monitor network state as well
as various events that may be occurring
in the network these events may include
failures topology changes security
events and so forth the second step is
to compute the policy based on the state
that the controller sees from the
network this is effectively what we
talked about last time is the role of
the decision plane in deciding what the
forwarding behavior of the network
should be in response to various states
that it reads from the network switches
the third step is to write policy back
to the switches by installing the
appropriate flow table state into the
switches consistency problems can arise
in two steps first the controller may
read state from the network switches at
different times resulting in an
inconsistent view of the network wide
state and second the controller may be
writing policy as traffic is actively
flowing through the network which can
disrupt packets along an end-to-end path
or packets that should be treated
consistently because they are part of
the same flow both reading and writing
network state can be challenging because
open flow rules are simple match action
predicates so it can be very difficult
to express complex logic with these
rules if we want to read state that
requires multiple rules expressing a
policy that allows us to read such a
state can be complicated without more
sophisticated predicates for example
let's suppose that when we are reading
state we'd like to see all web server
traffic except for source one two three
four simple match action rules do not
allow us to express such exceptions as a
solution to this problem we need a
language primitive that allows us to
xpress predicates here is a simple
statement that has several predicates
such as and and not a runtime system can
then translate these predicates into
low-level open flow rules ensuring that
they are installed atomically and in the
right order another problem that arises
is that switches only have limited space
for rules it's simply not possible to
install all possible rule patterns for
every set of flows that we'd like to
monitor for example if we'd like to
count the number of bytes for every
source IP address and generate a
histogram with the resulting traffic we
would potentially need a flow table
entry for every possible source IP
address it's simply not possible to
install all of these possible rules the
solution is to have the runtime system
dynamically unfold rules as traffic
arrives a programmer would specify
something like a group by source IP
address and the runtime system would
dynamically add open flow rules to the
switch as traffic arrives thereby
guaranteeing that there are only rules
in the switch that correspond to active
traffic</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>