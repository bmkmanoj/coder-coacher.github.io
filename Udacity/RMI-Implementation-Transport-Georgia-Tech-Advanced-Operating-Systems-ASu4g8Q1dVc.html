<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RMI Implementation Transport - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="RMI Implementation Transport - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>RMI Implementation Transport - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ASu4g8Q1dVc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the abstractions that the transport
layer provides our endpoint transport
channel and connection and I'll talk
about each of these things in a little
bit more detail endpoint you can think
of as nothing but a protection domain or
you can say it is a Java Virtual Machine
and it has a table of remote objects
that it can access and so this gives you
a protection domain or a sandbox for
execution of a server code or a client
code can exist within the sandbox that's
what endpoint is it basically a
protection domain connection management
is the interesting piece that what is
about all of the details of connecting
these endpoints together and in
particular the connection management of
the transport layer of the Java Runtime
system is responsible for setting up
connections tearing down connections
listening for incoming connections and
establishing the connection and when a
connection is established between two
endpoints this abstraction that I
mentioned called transport comes into
play so for instance between this end
point and this end point the connection
manager decided to have UDP transport so
a channel is established between this
end point and this end point to do UDP
transport between these two end points
and so this is the functionality of the
UDP transport that is incorporated in
this transport layer and similarly
between this end point and this end
point the connection manager decided to
use a TCP channel so the transport that
is being used here is a TCP connection
both ends we have a TCP connection at
both ends to connecting this end point
with this end point notice that a given
end point can have different transport
for talking to different end points
depending on a variety of parameters
what is the best way for this end point
to talk to this end point may decide
what kind of connection this end point
is going to establish with this end
point that is all part of connection
that is happening in the transport layer
of the Java Runtime and the connection
manager is also responsible for locating
the dispatcher for a remote method that
is being invoked on this endpoint so a
transport is listening on a channel and
when an invocation comes in then this
transport is responsible for identifying
or locating the dispatcher on this
domain which will know how to carry out
that invocation and the connection
manager is also responsible for
monitoring the liveness of the
connection because if an endpoint goes
away it needs to know that and inform
this domain that oh this particular
endpoint is gone
so take the appropriate action so that
kind of liveness monitoring is part of
connection management so the last
abstraction I mentioned is the notion of
connection itself so once a channel has
been established then the transport can
do IO on this channel using connection
so the path for the transport layer is
in connection management it listens for
an incoming request when an incoming
request comes in it then establishes a
channel and the channel that is
established for communication which is a
mutual agreement between these two
endpoints it chooses the transport that
is most appropriate for that and once
the channel has been established a
connection is now made between this end
point and this end point through this
channel and now these two endpoints can
do IO on the channel using the
connection so that's how the transport
mechanism of RMI works as we saw the
transport mechanism sits below the RRL
layer and so it allows all the object
invitations to happen through the
transport layer and the RRL layer is the
one that is deciding what is the right
transport to use depending on the
location of the two endpoints where the
client is and where the server is
depending on that it might decide what
may be the right transport
use whether it should use TCP or UDP and
so on and gives that command to the
connection manager which is part of the
transport layer of the software stack so
that the established channel can be
established and then a connection can be
used for actual transport of the
invocation between the client and the
server so in summary the distributed
object model of Java is a powerful
vehicle for constructing network
services and what we saw in this lesson
is a glimpse of the classes that are
available in the distributed object
model that makes the life of the
developer easy in terms of creating
network objects and making it visible
for clients to use anywhere and the
power of the RRL layer in dynamically
deciding how to make the client-server
relationship similar to the subcontract
mechanism that we saw in spring and we
also saw the flexibility in the
connection management allowing different
kinds of transport to exist between the
client and the server depending on the
location of the client and network
conditions and so on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>