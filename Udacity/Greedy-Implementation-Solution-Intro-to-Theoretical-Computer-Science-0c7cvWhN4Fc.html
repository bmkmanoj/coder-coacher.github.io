<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Greedy Implementation Solution - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Greedy Implementation Solution - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Greedy Implementation Solution - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0c7cvWhN4Fc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's walk through this code so first we
set an equal to the length of the end by
an adjacency matrix that we took as
input and we set assignment to be n nuns
a list of n nuns and we initialize the
cover to be the empty list since we
haven't actually set a cover yet and we
start valid off as false so that we can
start this while loop going well valid
is false we first check to find the
vertex with the most uncovered edges so
we start with the first vertex and set
candidate index to zero and the number
of uncovered neighbors that it has to
zero now for every vertex in the graph
we check if it has already been assigned
because if so then already covers all
adjacent edges if not then we first set
the sum of uncovered edges to be zero
and then again for every vertex in the
graph we check if there is an edge
between the two vertices represented by
I and J and if J has been assigned if it
hasn't been assigned then we increment
the sum of the uncovered edges since
there is now an edge that is not covered
by either I or J and we loop through all
of the other vertices to check if there
is an edge between I and J now if the
sum of the uncovered edges that we've
just counted up is greater than the
maximum uncovered neighbor's then we
have a new candidate index for which
vertex we should next add to the cover
and then we set the max uncovered
neighbors to be some uncovered which we
just calculated and then we keep looping
through this for every vertex until we
find the max uncovered so we figure out
which vertex we should next add to the
cover now if we didn't find any
uncovered diapers
if max uncovered neighbors is zero then
we see that this is a valid vertex cover
we set valid to true and that means that
will fall out of this while loop and
continue on otherwise we append this
index to the current cover and we set
the assignment of this candidate of this
vertex to be one and then we continue on
finding the vertex with the next
smallest number of uncovered adjacent
edges once we eventually fall through
that is once we eventually hit valid
equal true here and fall out of this
while loop we go down here and calculate
the size of the cover and return so size
equals zero and then for every vertex in
the graph we check if
is currently in the assignment and if so
we increment size and then we return
size and cover</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>