<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BFS Code - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="BFS Code - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BFS Code - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/97poC-xlLbA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what we have here is a Python
encoding of the breadth first search
algorithm we've been talking about for
finding shortest paths in these kinds of
graphs in this particular case there's
some infrastructure in the beginning for
reading the data for the comic book
characters from a file the one that
we're using here is tens of thousands of
lines long so it'd be very awkward to
put it directly into Python but a pretty
simple code for just going through
reading it and then making links into a
graph G that graph is stored as Marvel G
that's the graph of the comic book
characters and the comic books then
we've got a subroutine called path G v1
v2 and what that does is it takes a
graph G a start node say a character in
the comic book and an ending node
another character in the comic book and
it tries to find the shortest path
between them in fact it will unless
there isn't one so in this particular
case the code here is only going to tell
us the length of the shortest path turns
out that's a pretty straightforward
thing to do but it's not that hard to
augment this to actually produce the
path itself but let's just start off
with the the length so we create a data
structure distance from start which is
going to map the nodes of the graph to
how far away they are from v1 we have an
open list just like we've been talking
about and it's initialized to just the
very first node and the distance from
start from that node is 0 because it is
the node itself now we're gonna proceed
by checking to see whether the open list
is empty if it's not then we go into our
loop here that says first we're gonna
pull off the very beginning element of
the open list and call that current and
then we're going to delete the very
first element of the open list so that
it's gone we're gonna talk a little bit
later about how to try to make this
operation as efficient as possible but
for now this is this is ok it's gonna be
fast enough so it takes that off of the
open list and now what are we supposed
to do we loop through all the neighbors
so here we have a statement that says
for each neighbor in the list of
neighbors of current what is it going to
do it's going to check to see whether or
not that neighbors been assigned a
distance so far if it if it has not been
assigned a distances because it's not
been visited it's not been marked and if
that's the case then what we're going to
do is we're going to
calculate the distance from the start
for that note well what is it going to
be the neighbor the one the node the new
node that we just discovered is just one
step farther from the start than the
node that we're expanding so we take the
distance from the start to where we are
now add one to it and that's the start
to this neighbor that we're considering
so this is really the key step that is
finding the distance of the shortest
path once that distance has been
assigned we check hey was that neighbor
the one we were actually searching for
if it is we can just be done we can just
return that distance for that node
otherwise we have to proceed and we take
that neighbor and we just stick it on
the end of our open list so that will
catch up with it later and then we're
back into the loop and this is going to
continue pulling things off the open
list assigning them distances until
finally we discover to know that we're
looking for or if the open list
eventually goes completely empty all
this falls all the way through the while
loop is done and it returns false so
instead of actually returning a distance
it's going to return false meaning I
wasn't able to find a path it this could
also be infinity which indicates that
there is no bound on the the length of
the shortest path it's infinitely large
in this particular case I'm running it
with finding the path from a comic book
character called a to one called Z Z Z
the axe I figured that was pretty
comprehensive if we go from A to Z Z Z
axe and it's a three or four step chain
that you get when you do this with the
data that we've gotten all right so
let's go through the changes we need to
make to actually return the path instead
of the distance what I'm going to do is
actually coop this variable distance
from star it's not going to be a
distance anymore it's actually going to
be the path so instead of it starting at
zero it starts as just a list consisting
of v1 by itself and the only other
change that we need to do is when we
extend it because we've discovered a
path from them from the beginning
through current now it goes to neighbor
all we need to do is that that says this
this now being a list when we add
another list to it it actually is just
appending to the to the end of it which
is what we want in this case it might
not be the most efficient way to do it
but the things don't get very large and
it actual
works pretty well</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>