<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Better Tree Solution - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="A Better Tree Solution - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Better Tree Solution - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dgrMaH-U_JU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so let's take a look at how I
decide to do this like I said you set up
a second vertice called you and set it
equal to negative one in other words
it's not set to any actual vertex in the
graph at first so for every single
element in the upper triangular portion
of the adjacency matrix since we're
representing this as an adjacency matrix
we check if there is an edge between
those two vertices between vertices I
and J and if there is then we check if
the assignment for I and J is 0 that is
there not none anymore we have
specifically set them to not be in the
assignment well if both of them are
explicitly out of the assignment and
there's an end between them well then
that's not going to be a valid vertex
cover so we return float infinity now
otherwise if we find that the assignment
for both i and j is equal to none then
that means we haven't actually looked at
this yet so it's a good candidate for
setting being you so then we set u equal
to I and V equal to J and we continue on
now once we go through the entire double
four loop we check if V is still on set
because if he is still on set that means
that first of all we didn't fall out of
this by not having a valid vertex cover
and second of all it means that all the
vertices have been assigned to something
or other because that's the only way
that V could still be set to negative 1
and if V is set to negative 1 then note
that you also is now that's the case
then we set a variable size equal to
zero and we start simply counting up all
of the different vertices in the
assignment if the vertex is set in the
assignment then we increment size if
it's still unset well then we have to do
a little bit of manipulation here we
have to set the vertex I to one if a
neighbor is zero because we want to make
sure that this is still a valid vertex
cover so for every J in range I oh I
just realized a bit of an error here
well fun error necessarily
just a slight inefficiency we can boost
this to i plus 1 since we don't allow
any loops in the graph if we did then we
would have to simply use I but this
doesn't really particularly matter for
this moving on so for every other vertex
in the graph we check if there is an
edge between I&amp;amp;J again and if there is
and if the assignment of j is 0 well
then we have to set I and we say that
the size is an additional element
because we've now had to set I and once
we go through all this we return the
size and that's done now for each of
these for the recursive part that you
didn't have to worry about we try all
the different possible combinations that
aren't 00 since that would not be a
valid vertex cover we try 1001 and 11 we
compute the size for each of these and
then we return the minimum of those and
compute this whole thing recursively so
that was a little tricky if you had
trouble with that totally understandable
this does give you a little bit of an
improvement in the total size of the
search tree we end up searching through
before it was 2 to the N now we've got
about 1.7 3 3 to the N that might not
seem like much but in practice it can be
helpful so okay let's uh go ahead and
look at a different problem now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>