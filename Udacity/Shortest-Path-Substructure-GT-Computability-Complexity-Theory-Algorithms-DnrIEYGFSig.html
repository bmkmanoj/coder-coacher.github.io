<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Shortest Path Substructure - GT - Computability, Complexity, Theory: Algorithms | Coder Coacher - Coaching Coders</title><meta content="Shortest Path Substructure - GT - Computability, Complexity, Theory: Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Shortest Path Substructure - GT - Computability, Complexity, Theory: Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DnrIEYGFSig" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">since we are using dynamic programming
the first thing we look for is some
optimal similar substructure recall that
the key realization in understanding the
single source shortest path algorithms
like Dykstra and bellman-ford was that
sub paths of shortest paths are shortest
paths so if this is a shortest path
between UV and it happens to go between
x and y then this sub path must be a
shortest path between x and y if there
are a shorter one then it could replace
this sub path in the path from u to V
and that would then give us a shorter
path from u to be this type of argument
is called cut and paste for obvious
reasons by the way throughout I'll use
squiggly lines to indicate the path
between two vertices and straight ones
to indicate a single edge unfortunately
by itself this substructure is not
enough sure we might be able to argue
that a shortest path from u to V must
take a shortest path from u to a
neighbor of V first but how do we find
these shortest paths the subproblems end
up having circular dependencies one idea
is to include the notion of path length
defined by the number of edges used if
we knew all shortest paths that only
used k minus 1 edges then by examining
the neighbors of V we could figure out
the shortest paths with K edges to V
will let Delta U V of k be the weight of
the shortest path that uses at most K
edges then the recurrence is that Delta
u VK is the minimum of Delta u VK minus
1 this is where we don't use that
potential k edge or it's the minimum of
the distances from you to one of the
neighbors of V using only K minus 1
edges plus the weight of that last edge
to get us to V this strategy works and
it yields the matrix multiplication
shortest path algorithm that runs in
time V cubed log V see Roman liars and
Ravis stein for details we're going to
take a different approach that will
yield a slightly faster algorithm and
allow us to remove this
log factor we're going to recurse on the
set of potential intermediate vertices
used in the shortest path without loss
of generality we'll assume that the
vertices are 1 through n for the
convenience of notation consider the
last step of the algorithm where we have
allowed vertices 1 through n to be
intermediate vertices and just now we're
considering the effect of allowing end
to be an intermediate vertex clearly our
choice is either using the old paths or
taking the shortest path from u to n and
then from n2v in fact this is the choice
not just for n but for any K between one
and n to get from u to V using only
intermediate vertices one through K we
can either use K by taking the shortest
paths or not use it therefore we define
Delta U V of K to be the minimum weight
of a path from u to V using only one
through K as the intermediate vertices
then the recurrence becomes Delta u v of
K is the minimum of Delta u VK minus one
that is not using K as an intermediate
vertex and using K that is taking the
shortest allowed path to K from you and
then going as quickly as possible from k
to V in the base case where no
intermediate vertices are allowed the
weights and the edges provide all the
needed information</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>