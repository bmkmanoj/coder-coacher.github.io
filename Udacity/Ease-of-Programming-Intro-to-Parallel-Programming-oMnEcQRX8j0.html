<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ease of Programming - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Ease of Programming - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ease of Programming - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oMnEcQRX8j0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so part of the motivation is going to be
ease of programming so how how was it
specifically easier for someone to write
a program that has these irregular or
complex control structures data
structures compared to not having
dynamic parallelism in the past when
that is to say before before before the
dynamic parallelism stuff on on Kepler
which is our new GPU in the past
whenever you needed to make a new batch
of work you had to return to the CPU
which was the master controller to go
and launch that work for you so if ever
in my program I reached a point where I
needed that matrix inversion or that FFT
to be done I had to hold my program
return to the CPU have the CPU then
launch this work for me that would
complete return back to the CPU and the
CPU would then have to restart me in
fact if I had to split my program in to
around this moment where I needed the
this extra parallel work to be done and
suddenly instead of having one smooth
program I have two fragments of program
I have state that I have to save across
the two and then I have my CPU having to
get involved to manage and marshal all
of this work suddenly with the dynamic
parallelism I can just do this all
compactly on the fly if you like the
system does all of that for you will
save off your old program it will run
the new FFT for you will return that
result to you and it will continue where
you left off so from the programmers
perspective I'm no longer programming in
two places at once I'm no longer having
the GPU and the CPU both tightly bound
over my execution and I no longer have
to manage the part of the portions of my
program around where I need to launch
this new work I can just inline it
effectively and it makes for a much
simpler and straight more
straightforward programs now that's
fantastic and what about the performance
implications there's always the
performance overhead - bouncing
backwards and forwards between the CPU
and GPU you've got the latency is of the
PCI bus which is the communication link
you've got the overheads of shutting
down your first portion of your program
starting up the next portion back and
resuming right where you left off so
those overheads get at more times do you
save potentially data transfer across
the buses
and in a way something I feel is
actually more important in this is that
with the GPU you're always trying to get
as much work on that GPU as possible you
can much more easily overlap the new
work that you're doing with other stuff
that's still going on on the GPU I don't
have to shut down completely and fire up
an fft i can inline do all of these
things while something else useful is
going on at the same time and so this
ability to asynchronously do this work
from different threads all at the same
time remember you've got thousands of
threads on the GPU they can all be doing
this
I mean modular resources they can all be
doing this at the same time and so you
can get a much easier overlap between
the different pieces of work you're
doing and it's therefore much easier to
keep the VP you busy and that gives you
a lot of potential for more performance</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>