<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Quiz on Coalescing Memory Access - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="A Quiz on Coalescing Memory Access - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Quiz on Coalescing Memory Access - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MD5w1AGSCHs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay let's look at these so here I've
drawn a chunk of memory and we're gonna
say that G points into this memory so
this is G sub 0 G sub 1 G sub 2 and so
forth and here's a bunch of threads and
we're just going to reason out where
each of these threads is accessing in
memory so in the first case G sub I
equals a well every thread is simply
accessing a location in memory defined
by its thread index this is exactly the
example we've been talking about a given
set of threads we'll be accessing a
bunch of adjacent contiguous locations
in memory so this case is clearly
coalesced in this case every thread is
accessing a location and memory defined
by its index times two and so there's
going to be a strided access here right
threads are going to end up reading
every other location in memory so this
is the access pattern we've called
strided it's not coalesced this next
axis pattern is exactly like the first
time except that we're doing reads
instead of writes so again every thread
is simply reading a location defined by
its own index in memory therefore
adjacent threads will access adjacent
locations in memory and just like the
first example we're gonna have a nice
coalesced access pattern this next
example is coalesced because every
thread is reading from a location
defined by G plus some offset block with
over two plus the threads index so if
this is block width number two then
every thread will be accessing adjacent
locations starting at that at that
offset so this is coalesced and this
example is simply the same pattern we're
going to read from this location which
is defined by an offset plus the thread
index we're gonna multiply it times a
constant and we're going to store the
result back into a contiguous chunk of
memory so this is simply a coalesced
read followed by coalesced right
therefore the statement is coalesced and
finally this example is a little
different here we're going to be
accessing a location an offset in memory
- the thread index so thread 0 will
access block width over to thread 1 will
access block width over to - one thread
to relax this block with over to minus 2
and so forth and as you can see even
though
we're doing the subtraction here instead
of an addition we're still accessing a
contiguous region in memory every thread
is accessing adjacent locations and
contiguous chunk of memory so this is
still coalesced</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>