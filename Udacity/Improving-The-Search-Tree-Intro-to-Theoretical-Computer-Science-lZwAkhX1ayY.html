<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Improving The Search Tree - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Improving The Search Tree - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Improving The Search Tree - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lZwAkhX1ayY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so using the search tree for practical
purposes we may have already gained some
efficiency but now the question is does
it really affect the running time of the
algorithm when we use Ono tation and
worst-case running time or is it just
something that gives us some constant
factor savings in practice it's hard to
tell right now because this tree as
we've considered it it's highly
dependent on the structure of the graph
that we're analyzing and we need to
think a little bit more about this one
interesting thing to consider is the
following there were only two cases when
we stopped further exploration in this
tree here one case was that we had found
a valid vertex cover the other one was
when we considered an edge that could
not be covered any more actually doing
it this way is not the smartest possible
way because for vertex cover we already
know one thing if you look at an edge
such as this one here then this edge
here has two endpoints and now we want
to assign these endpoints to be in the
vertex cover or to not be in the vertex
cover so far we have looked at the
vertices individually but we could also
look at both vertices at the same time
so not go into two different
possibilities but actually go in three
different possibilities there's three
cases that make sense here of assigning
the vertices to be in the vertex cover
or not so we know this edge needs to be
covered somehow and there's actually
just three different possibilities of
doing that one is you take this endpoint
here enter the vertex cover the other
one is you take this vertex here into
the vertex cover or of course you can
also take both but you can ignore the
case where you would put none of the two
endpoints into the vertex cover because
then you already know that your solution
doesn't make sense this of course also
covers other edges as well and now our
algorithm can actually very quickly come
to a solution because when we look at
this edge here there's only one possible
choice that remains and that is taking
this vertex here into the vertex cover
all edges are covered we have a solution
of size two so now let's do a first case
analysis and say that this is the edge
that the algorithm considers next in all
of the three cases the edge is uncovered
so it again goes into three
possibilities here three possibilities
here three possibilities here of course
if we had been lucky and had
chosen this edge here the algorithm
would have had a much easier choice and
actually we're later going to look at
such optimizations for the algorithm and
again we're going to branch into the
three cases that make sense for that
edge so this one here would make sense
for that edge but of course it leads to
an invalid solution this one here is
actually the best possible solution and
this one here is also a solution but
it's a larger one and we're gonna do the
same thing over here now what you might
be thinking is oh no now we're trying
nine assignments but the good thing is
that we can now do a worst-case analysis
of this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>