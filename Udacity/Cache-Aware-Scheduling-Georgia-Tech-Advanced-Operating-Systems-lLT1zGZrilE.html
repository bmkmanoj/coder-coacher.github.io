<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cache Aware Scheduling - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Cache Aware Scheduling - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cache Aware Scheduling - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lLT1zGZrilE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let me briefly introduce you the idea
of cash over scheduling when you have
these multi-threaded multi-core
processors and to make things concrete
let's assume that you have a pool of
ready threads and in this case I'm going
to tell you that the pool of ready
threads i have is 32 so i have 32 ready
threads and i have a four-way multi-core
the cpu meaning that there are four
course in the cpu and each core is for
way hardware multi-threaded in other
words at any point of time the operating
system can choose from this pool of
ready threads 16 threads to be run on
the processor because that's the number
of hardware multi threads that are
available if you pull together all the
forecourse so each core has for multi
hardware multi threads together they
have 16 Hardware threads that can be run
on the CPU at any point of time and the
job of the operating system scheduler is
to pick from the available pool of ready
threads 16 candidates to be scheduled on
the CPU so how does the operating system
choose the 16 threats to be run on the
CPU at any point of time what the
operating system should try to do is it
should score schedule some number of
cache frugal threads and some number of
cache hungry threads on the different
course so that together the sum of all
the cash hungriness of the 16 threads
that are executing at any point of time
in the CPU is less than the total size
of the l2 cache and I said l2 cache in
this simple example I gave you two
levels of caching caching that is
associated with each of these cores and
an l2 cache that is sitting outside of
this course but it is it is common to
all the four course but of course you
can generalize this and say it is a last
level cache or in other words you want
to make sure that the universe of
threads that are scheduled at any point
of time on the CPU the sum total of the
cash requirements of the universe of
thread scheduled on the processor is
less than the total capacity of the last
level cache in the CPU because if you
miss in the last love
cash on the CPU you're going outside the
chip out to memory long latency
operation bad news that's the thing that
you're trying to do so we're going to
characterize threads as either cash
frugal threads or cash hungry threats so
cash frugal threats are one and ones
that require only a small portion of the
cash to keep them happy on the other
hand a cash hungry thread is one that
requires a huge amount of cash space in
order to keep it happy meaning that the
working set of cash hungry threads is
much bigger than the working set of the
cash frugal threats now how do we know
which threads are cash frugal and which
threads are cash hungry well that's
something that we can know only by
profiling the execution of the threads
over time so the assumption is that many
of these threads get to run on the CPU
over and over again so over time you can
profile these threads and figure out
whether a particular thread belongs to
this category of cash frugal thread or
this category of cash hungry thread and
the criterion that you want to use in
picking the set of threads to be
populated in the CPU at any point of
time from the pool of available threads
is to make sure that the sum of the cash
requirement of all the cash frugal says
if there are n cash frugal threads and
there are M cash hungry threads then the
cumulative cash requirement of all the
threads put together is less than the
total size of the l2 cache and as I told
you we can generalize this l2 cache to
the last level cache that is the cash
that is sitting at the last level inside
the CPU beyond which he had to go out of
the chip go out to memory and so that
last level cache becomes the determinant
in saying whether the size of the last
level cache is within bounds of the cash
requirements of all the threats that I
want to schedule so this is a set of
threads that I want to pick where in
this particular case since the total
number of hardware threads that I have
available to me is 16 I want to make
sure that em the cache hungry threads
and the cache frugal threads is 16 and
this inequality is
satisfied as well so that's what we want
to shoot for in picking the set of
threats to run on the processor at any
point of time I mentioned that we have
to profile these threads or monitor
these threads as they are executing in
order to figure out the cash occupancy
over time so that we can categorize
these threads as cash frugal or cash
hungry and the more information the
scheduler has the better decision it can
take in terms of scheduling but he had
to be careful about that in order for
the system to do's is monitoring and
profiling clearly the operating system
has to do some work in the middle of
these threads doing useful work and I've
always maintained that a good operating
system gives you the resources that you
need and gets out of the way very
quickly and so it had to be very careful
about the amount of time that the
operating system takes in terms of doing
this kind of monitoring and profiling
and this information is useful in
scheduling decisions but it should not
be disrupting useful work that these
guys have to do in the first place in
other words the overhead for information
gathering has to be kept minimal so that
the OS does not consume too many cycles
in doing this kind of overhead work
accounting for making better decisions
in in terms of scheduling</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>