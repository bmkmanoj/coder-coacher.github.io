<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Parsing - Design of Computer Programs | Coder Coacher - Coaching Coders</title><meta content="Parsing - Design of Computer Programs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Parsing - Design of Computer Programs</b></h2><h5 class="post__date">2012-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CY1TnbVE7PI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now I'm going to define the parser and I
want it to have this signature I'm going
to define a function parse which takes a
symbol saying I want to parse something
like an expression it takes text that
we're going to parse and it takes the
grammar that defines that symbol and all
the other symbol I want it to return
when we had regular expressions we
looked at returning a set of remainders
I'm going to have this return a single
remainder and the idea is that we want
the author of the grammar to have some
control over what's going on and make
this grammar be unambiguous so that
there's a single result for each part
rather than having to keep a set of
results and the idea is that for each
symbol we're going to consider the
alternatives in left to right order so
we're going to first say if we're asked
to parse an expression will say can we
parse this alternative and if we can if
we can parse in succession a term and
then in plus or minus or then an
expression then we'll commit to that and
will say that's the result we're going
to return that's the single remainder
and we're not going to even explore the
other alternatives and because we have
this left to right choice that's why we
decide to write the expressions in this
order and we don't write them in the
opposite order because if we wrote the
rule this way and we were trying to
parse the expression A plus three we'd
be asked to parse this we try to parse a
term we'd say yes a is a term and then
we'd stop and we'd say that's the end we
wouldn't even consider parsing off the
term plus expression this is no good
it's up to the author of the grammar to
write rules in the correct order so that
the longest thing gets tried first our
regular expression functions where what
it's known as recognizers and they told
us yes or no is a string part of the
language and here what we're doing is
different it's a parser so it tells you
yes or no is it part of the language but
then it also gives you an internal
structure a tree structure of the parts
of the expression so here it would be a
plus three if we had M times X plus B
then that would parse into its structure
that had M times X plus B and
so here I said we were returning a
remainder but actually I want to return
a two-element tuple of the tree followed
by the remainder and here's what we're
going for if I asked to parse the
expression a times X with the grammar G
I want to get back this tree structure
and it looks kind of complicated all
it's really saying is that we have an a
in the first element then the multiply
sign and then an X in the third element
and there's no remainder we parse the
whole string that's what it says but
there's all these intermediate parts
here because that's the way the grammar
is defined and i should say here that
this is a tree common remainder result
we're going to use the convention that
fail corresponds to a value of none so
let's think then about what we have to
do to be able to parse a text I can
think of for cases that we have to deal
with one we want to be able to parse an
expression or a symbol like the
expression keyword and to do that we've
got to be able to look that up in the
grammar G we've also got to be able to
parse a regular expression plus or minus
and we've seen how to do that before so
we've reduced that to a solved problem
we're going to have to be able to parse
a tuple of alternatives here at one
alternative or another alternative done
in left to right order and finally we're
going to have to be able to parse a list
of atoms representing a sequence one two
three now I'm going to tell you the plan
for how we're going to implement this as
code within the function parse so this
first case I'm going to handle with a
subroutine called parse Adam so this is
in a Tom expression we should be able to
handle that the second part the regular
expression is well it's a type of atom
so it occurs within the parse Adam
routine we're going to define a variable
called tokenizer to help us do that and
then we're going to use the built-in
re-match along with the tokenizer to
recognize those regular expressions then
for the alternatives tuple of
alternatives is what you get when you
look up the symbol like expression in
the grammar and so I could have had a
separate function called parse
alternatives but instead I just decided
to have that be part of parts Adam
because it was so simple it was just
an immediate step to go from the symbol
to the list of alternatives finally to
parse the sequence of atoms I have a
subroutine or function called parse
sequence</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>