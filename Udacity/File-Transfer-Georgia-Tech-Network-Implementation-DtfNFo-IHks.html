<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>File Transfer - Georgia Tech - Network Implementation | Coder Coacher - Coaching Coders</title><meta content="File Transfer - Georgia Tech - Network Implementation - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>File Transfer - Georgia Tech - Network Implementation</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DtfNFo-IHks" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's suppose that computer a wants to
send a file to computer be the file
transfer program on a asks the file
system to read the file from the disk
the communication system then sends the
file and finally the communication
system sends the packets on the
receiving side the communication system
gives the file to the file transfer
program on B and that file transfer
program asks to have the file written to
disk so what can go wrong in this simple
file transfer setup
well first reading and writing from the
file system can result in errors there
may be errors in breaking up and
reassembling the file and finally there
may be errors in the communication
system itself now one possible solution
is to ensure that each step has some
form of error checking such as duplicate
copies redundancy timeout and retry and
so forth one might even do packet error
checking at each hop of the network one
could send every packet three times one
might acknowledge packet reception at
each hop along the network but the
problem is that none of these solutions
are complete they still require
application level checking therefore it
may not be economical to perform
redundant checks at different layers and
at different places of this particular
operation another possible solution is
an end-to-end check and retry where the
application commits a retries based on a
checksum of the file if errors along the
way are rare this will most likely
finish on the first try now this is not
to say that we shouldn't take steps to
correct errors at any one of these
stages error correction at lower levels
can sometimes be an effective
performance booster and the trade-off
here is based on performance not
correctness so whether or not one should
implement additional correctness checks
at these layers depends on whether the
amount of effort put into the
reliability gains are worth the extra
trouble another example where the intent
argument applies is with encryption
where keys are maintained by the end
applications and ciphertext is generated
before the application sends the message
across the network now one of the key
questions in the end-to-end argument is
identifying the
the intent argument says that the
complexity should be implemented at the
ends but not in the middle but the ends
may vary depending on what the
application is so for example if the
application or protocol involves
internet routing the ends may be routers
or they might be ISPs if the application
or protocol is a transport protocol the
ends might be end hosts so identifying
the ends in the antenna argument is
always a thorny question that you have
to answer first</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>