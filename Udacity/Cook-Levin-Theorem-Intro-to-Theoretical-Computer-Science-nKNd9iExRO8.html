<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cook Levin Theorem - Intro to Theoretical Computer Science | Coder Coacher - Coaching Coders</title><meta content="Cook Levin Theorem - Intro to Theoretical Computer Science - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cook Levin Theorem - Intro to Theoretical Computer Science</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nKNd9iExRO8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so now that you know what the sad
problem is how do we actually show that
sad is np-complete so what was the main
ideas that cook and Levin used to prove
this because it still sounds quite
difficult doesn't it to show that sad is
in p-complete what we basically have to
show is that for any problem in NP there
is a polynomial time reduction to SAP
and before we go into the details of
this proof I want to show you the three
main ideas that are used to show this so
the first one is well it's not really an
idea it's the trivial definition of what
it means that a problem lies in NP if a
problem lies in NP that means it can be
solved in polynomial time by a
non-deterministic Ram so why do we state
this going back to the definition
actually allows us to make a very useful
observation because if we can solve a
problem in polynomial time on a
non-deterministic Ram then that means
there must be some polynomial time
algorithm of course that algorithm is
going to use the if-better function
because it's running on a
non-deterministic Ram but we know that
if a problem is in NP then even without
explicitly having to come up with this
algorithm we know there must be one
because otherwise this problem would not
be in NP which brings us to the third
point and that is the main idea that
cook and Levin had and that is instead
of having to show that any problem in NP
can be encoded as a boolean formula what
they did is they showed that any
algorithm can be encoded as a boolean
formula because if you can show that
well with certain constraints of course
but basically the idea is if you can
show that any algorithm can be encoded
as a boolean formula then you can also
encode this polynomial time algorithm
here as a boolean formula which can then
be used to solve an np-complete problem
so if you can encode any algorithm then
you can also encode any algorithm that
will solve a problem in NP and of course
we're going to go into the details but
that was their main observation they
showed that we should not look at the
problems in NP but we should actually
look at the algorithms that solve those
problems in NP and we know there must
always be such an algorithm because
the problems wouldn't be an NP</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>