<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memory Consistency Model - Georgia Tech - Advanced Operating Systems | Coder Coacher - Coaching Coders</title><meta content="Memory Consistency Model - Georgia Tech - Advanced Operating Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memory Consistency Model - Georgia Tech - Advanced Operating Systems</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EWTNNm_s8MM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here I'm showing you a set of
accesses memory accesses done on
processor p1 read access and write
access and so on and these are the
memory locations being touched by these
accesses on p1 and on p2 I'm showing
similarly a set of accesses to shared
memory locations and we know that
processor p1 accessing memory and
processor p2 accessing memory a
completely independent of one another
and therefore it is possible that in one
execution of p1 and p2 this particular
access of of writing into memory
location a happens after reading a
memory location a happens on p1 in one
execution and if you run the same
program again p2 and p1 constituting the
program run it again it's possible that
another execution of the same program
right away happens before the read of a
it's perfectly feasible for this to
happen because there is no guarantee on
the ordering of these accesses going to
main memory and if you think about it
both of these executions whether it is
the earlier execution where write
happened after this read or this
execution in which the write is
happening before the read both these
executions are reasonable and correct
and something that the programmer can
live with it's acceptable to the
programmer now in other words what the
programmer needs to know is what to
expect from the system in terms of the
behavior of shared memory reads and
writes that can be emanating from
several different processes and this is
what is called the memory consistency
model so the expectation of the
programmer is is is what is ingrained in
this memory consistency model as a
programmer you don't want any surprises
and this is the purpose of the memory
consistency model to sort of satisfy the
expectation of the programmer so I'm
going to talk to you about one
particular memory consistency model
which is called a sequential consistency
and you consider the accesses from p1
and p2
well one expectation that you have as a
programmer is that the accesses that you
have on a particular processor is going
to be exactly in the order in which
you've written it or in other words if
you look at this sequence of accesses
you have a write of B here and the read
of B here you know that you won't expect
to see when you do this read whatever
you wrote here is what you expect to see
that's what is called the program order
what you expect is the program order to
be maintained namely the order in which
you've generated memory accesses should
be maintained by the execution on that
processor that's program order and in
addition to that there is this
interleaving of memory accesses between
p1 and p2 and this is where we said we
have no way of controlling the the order
in which these accesses are going to be
satisfied by the memory because it
depends on the execution are of p1 on
processor p1 and the execution on p2 and
how they're each memory and so on and so
this interleaving can be arbitrary that
is the interleaving between accesses
that you see here and the accesses that
you see here can be arbitrary so that's
the sequential consistency memory model
which which has two parts to it one is
the program order that is the order that
you see textually in every individual
processes I'm showing you two here but
you can have n of these processes but in
each one of these processes the textual
order in which memory accesses are
generated they're going to be satisfied
that's the program order on the other
hand the interleaving of these memory
accesses across all the processes is
going to be arbitrary so those are the
two properties of the sequential memory
consistency model you know an analogy
that will drive home the point about the
sequential consistency and what you
might see in a casino and if you if you
watch a casino card shark shuffle cards
he might take a card deck and split it
into two halves and then he'll do a
merge shuffle of the two splits
and create a complete deck exactly
what's going on in sequential
consistency you have splits of memory
accesses on several different processors
and they're getting interleaved in some
fashion just like the card shark is
interleaving all these cards from the
two decks and creating one card deck out
of it by the way this particular memory
consistency model sequential consistency
was proposed by Leslie Lamport
and this is a popular guy you're going
to see him again later on when we talk
about distributed systems but he came up
with this idea of sequential consistency
memory model back in 1977 and since then
there have been lots of different
consistency models that have been
proposed and in future lessons on
distributed systems we will see other
forms of memory consistency models such
as release consistency and lazy release
consistency and eventual consistency but
hold on we'll come back to that later on</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>