<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Much Testing Is Enough - Software Testing | Coder Coacher - Coaching Coders</title><meta content="How Much Testing Is Enough - Software Testing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Much Testing Is Enough - Software Testing</b></h2><h5 class="post__date">2012-07-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6LhslWDXg10" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one of the trickiest things about
testing software is it's hard to know
when you've done enough testing and the
fact is that it's really easy to spend a
lot of time testing and to start to
believe that you did a good job and then
to have some really nasty bugs show up
that are triggered by parts of the input
space that we just didn't think to test
let's look at what's really going on so
we're gonna start with the domain range
diagrams that we know and love we're
gonna have some test cases in the domain
after a while we're gonna start to feel
pretty good about what we've been doing
what it's gonna turn out is without
really knowing it our testing has been
confined to some small part of the input
domain and the problem is is that even
this small part of the domain may
contain an infinite number of test cases
or else a finite number of test cases
that's large enough that it's for
practical purposes it's not
distinguishable from infinity and of
course what's going on is there gonna be
test cases in other parts of the domain
we didn't think to test that can result
in outputs that are not okay
it really depends on how we've broken up
the input domain for example let's think
about the case where we're testing with
their act 25 radiation therapy machine
that I used an example in the last
lecture so it might be the case that all
of the inputs that we thought to test
the ones in this region are the ones
where we happen to type the input to the
machine slowly we simply didn't realize
that there was a whole other part of the
input space that has to be treated
differently that happens when we type
the inputs fast and of course it's in
that region where we trigger the race
conditions they were leading to massive
overdoses similarly if you remember from
lecture 1 we had a small Python program
called the Python runtime to crash the
distinguishing feature of it seemed to
be a large number of cascaded if
statements it's pretty easy for testing
Python programs to remain in a part of
the space where for example we have less
than 5 nested if statements over here's
another region containing programs with
five or more if statements nested and
these are the ones that caused for
example the Python virtual machine to
crash to take an even more extreme
example let's say that we're testing
some software that somebody has inserted
a backdoor in well in that case there's
gonna be an absolutely infinitesimal
part of the input domain maybe way over
here that triggers the backdoor because
remember if you're putting a backdoor in
code you don't want to trigger it
accidentally and that's gonna lead to
something extremely bad happening over
here we didn't test the inputs
triggering the backdoor because we just
didn't know what was there so what we'd
really like is some sort of a tool or
some sort of a methodology that if we
are in fact testing only a small part of
the input domain for a system would
really like us some sort of an automated
scoring system that looks at our testing
effort and says to us something like
scores 14 out of 100 you're not doing a
very good job testing the system keep
trying and that's what today's lecture
is gonna be about it turns out there are
a lot of different reasons we might want
to assign a score to our testing effort
probably the main one is that this helps
us find part of the input domain that
need more testing so for example if we
can increase our score by testing this
part of the domain we're naturally going
to be led to do that and our testing
effort will improve other reasons to
assign a score to a testing effort are
that we might want to be able to argue
to our boss or to some sort of a
certifying authority we've done enough
testing similarly we might want to argue
that a system we're developing hasn't
been tested well enough but it's not yet
safe to deploy and that it needs more
testing and a testing score can provide
a numerical justification for that sort
of argument finally it would be nice if
we could take a large test suite one
maybe that takes several days to run and
identify parts of the test suite that
are completely redundant that is to say
parts of the test suite that test
exactly the same parts of the input
domain even though they occupy different
parts of the input domain have roughly
the same testing effect on the system
assigning a score to our testing efforts
can let us do that as well</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>