<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Consistency Matters - Georgia Tech - HPCA: Part 6 | Coder Coacher - Coaching Coders</title><meta content="Consistency Matters - Georgia Tech - HPCA: Part 6 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Consistency Matters - Georgia Tech - HPCA: Part 6</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uh8gF64345I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it turns out that consistency does
matter and here's how let's say that in
program order to course do this the
first score is gonna store a 1 into
location D and then store a 1 into
location F let's say that the end F are
both 0 initially the second core loads F
into R 1 and then loads D into R 2 and
let's say that now we print the
registers r1 and r2 note that we can
have an out of order processor the three
orders loads and stores so in execution
order core one might still be doing the
stores in the same order but quarto
decides to reorder these two loads
note that in a uniprocessor reordering
of loads if this score is not writing to
these locations is perfectly okay and in
fact even in a multiprocessor most of
the time it's okay now let's look at
what's possible to get in r1 and r2
after this in program order these two
loads on core tool might execute before
these two stores in core 1 so we can get
r1 and r2 are 0 here these two loads in
core 2 although they've been reordered
can still happen before core one gets to
store so we can get the same thing these
two loads can happen after the two
stores so we can get one in both
registers here in execution order even
if we reorder them they can execute
after the stores so we can get one in
both of them in the program order if
these two happen like this in between
the two stores we can get r1 when we
load is still loading to 0 here but r2
when we load is already loading the 1
the same thing can happen here if these
two loads are in between the stores then
r1 is gonna be 0 because it comes before
this and r2 is going to be 1 because it
happens here
now it gets interesting we have seen
that there are these three possibilities
so the question is but can we get our
one to be one
while our two is zero and in the program
order if we consider that it's not
possible our one being one means that
when we read F we read one that means
that this load has to come after this
store if that happens then this load has
to be after this load too so pretty much
if we execute this here then this has to
be here and that means that if we read
one from F we will read one from D as
well so the R 1 equals 1 R 2 equals zero
cannot happen in program order but here
R 1 equals 1 means that this load needs
to be here and we can get a zero in R 2
if this load comes here so if we put the
stores in between the loads in the
execution order like this we will get a
situation that was not possible in the
original program order so the programmer
might have expected that this code can
never result in this but in an out of
order processor execution on each core
it can and note that this doesn't
violate coherence at all in all cases a
load and the store or Beit coherence but
do we really care about that sure for
some obscure orderings this can happen
do we really care when does it really
matter that this doesn't happen and it
does</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>