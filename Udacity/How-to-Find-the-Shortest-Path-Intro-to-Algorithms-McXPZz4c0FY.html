<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Find the Shortest Path - Intro to Algorithms | Coder Coacher - Coaching Coders</title><meta content="How to Find the Shortest Path - Intro to Algorithms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Find the Shortest Path - Intro to Algorithms</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/McXPZz4c0FY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's take a look at an approach for
actually finding shortest paths in
graphs and we'll use this example once
again it'll help to actually have names
for the other nodes so I'm going to add
those in so let's remember what
breadth-first search does for this graph
starting from a we put we mark a as
visited and we add it to the open list
we pull it off the open list and add all
the neighbors of a to the open list
which are C B and D then we choose one
of these nodes say C and add all its
unexpanded neighbors to the graph but
all its neighbors are expanded do the
same thing with B be has F and DS
unexpanded neighbors are e all right now
F son expanded neighbors are G and E has
no more unexpanded neighbors so we've
finished this this depth-first search
what we get here is that by the
assumptions of a breadth-first search
the shortest path from A to B is this
direct link from A to B the search would
have actually terminated here but we'd
ran it out anyway so these are
supposedly the shortest paths in terms
of number of hops to all these nodes
does that actually make sense one hop to
see one hop to be one hop to D two hops
to F Shore two hops to e Shore three
hops to G one two three one two three
yep there's no faster way to get to G so
this actually it does the right thing in
terms of number of hops but let's take a
look at what happened when we went to
expand B at this point even though we
have a shortest hop path to B we don't
have a shortest length path to B all we
know is that from a you can reach C in
three steps well that's really all we
know this even this a to D we don't know
there might be a very like a half wait
path that goes from C to D but we do
know that there's gonna be no faster way
to get to C right because that is the
shortest edge out of a any of the longer
edges we're assuming we can't take
negative weight edges that would cause
this for to get smaller than the three
so all we really know is that this three
is the smallest so what we should do is
not expand B but we should focus in on C
we now know that there's a path that
actually can get us there in thirteen
right this 10 edge plus the three that
it takes to get to C so we can get to be
faster than fifteen we can get it we can
get to B in 13 now is that the shortest
possible path for B we don't know
because we know that we could get to D
and for
and maybe there's a length one i mean
ignoring the graph for a second maybe
there's a length one path that would get
us to be which would be even shorter so
all we know from what we've done so far
is that the shortest path from A to D is
four so let's let's lock that down and
pull D off of the open list and let's
focus on in on D so D has edges to be F
and E here's B and here's F and E so
this path to F through D gonna add
another seven for a total of eleven and
this path to e through D is going to add
another three for the length of seven
and remember there was also a D to B
link which would add nine to this which
would get us there in thirteen and we
already knew how to get there in
thirteen so that doesn't really change
anything so based on this tree we know
the fastest way to a C and D and of the
ones that we have also been able to
reach we know that E has the shortest
distance which is seven and there isn't
going to be any faster way to get to E
because there aren't any other nodes
that we could get to and then get to E
faster than seven so we can lock that
one down pull it off the open list and
all its edges to the non completed node
so e can go to F and that has a length
of five so we could go seven steps to e
and then another five to F or total of
12 now we can already get there in 11
that's probably not a good idea from e
we can also get to G in one step which
would have been seven plus the
additional step for a total of eight and
that's all we can reach from e looking
things over we now know that G the
fastest way to get to G is eight steps
because the only other ways we could get
to G would be to visit one of the other
nodes and then go to G and that will
have to be longer than eight we're gonna
lock it down and now we pull it off the
open list and look at the edges out of G
so G can get to F in two steps oh and
that's an improvement because before the
best we could get to F was eleven steps
now we can get to F in and come again
anywhere else new no because the only
nodes that aren't complete now are B and
F and they're already in the picture and
in fact now we see that the fastest way
to get to F is going to be in ten steps
because the only other way to get to F
that we haven't considered is getting
there through B and that's gonna be
longer we can lock this down all right
let's look at F what edges are coming
out of F to uncompleted nodes just this
one to B that would have been F is ten
steps plus one more would be 11 to get
to B that's an
provement over what we had before and
that's it for F now the only node that
that we've got left to think about is B
there is no way to get to be any faster
than 11 because there's no other place
that we can go and then get to B so we
can lock it down and that finishes the
picture we now know what the shortest
distance is from a to every other node
in the graph the distance to B is 11 now
we've kind of lost a little bit of the
information of how we get to be in 11
but we'll deal with that in a little bit</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>