<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Useful Bytes Delivered - Intro to Parallel Programming | Coder Coacher - Coaching Coders</title><meta content="Useful Bytes Delivered - Intro to Parallel Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Useful Bytes Delivered - Intro to Parallel Programming</b></h2><h5 class="post__date">2015-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UhmX_RBwZK0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I find it helpful to think the memory
system as a pipe threads issuing
requests stuff memory transactions into
that pipe for example these could be
load instructions to read in a certain
address in memory and the result of that
transaction eventually falls out the
bottom of the pipe to head back to those
threads now the pipe is really deep it
takes two or three hundred clock cycles
for a transaction to move through this
pipe and the pipe is also really thick
and wide okay it's designed to be filled
with many transactions at the same time
from lots of SMS running lots of threads
so when you only have a few threads
issuing transactions the pipe is mostly
empty this could happen for example if
you don't have all of your SMS actively
filled with threads that are issuing
transactions or if the latency between
the transactions coming from a gift from
each thread is too high right so if we
only have a few threads issuing
transactions the pipe is mostly empty
and not many bytes are being delivered
and littles law tells us that if not
many bytes are being delivered then our
total bandwidth is going to suffer so
you can make this better by having more
threads issuing memory transactions or
by having more memory in flight per
thread so here's one of those strategies
this is measured data from taking a GPU
and copying a bunch of data from one
matrix to another just like we're doing
and the important thing notice is that
we're doing it in three different styles
we're doing a four byte word so this is
the equivalent of a single precision
floating point which is what our code is
doing an eight byte word for example if
we were moving double precision floating
point around that's what we would be
getting or a 16 byte word and there
exist in CUDA datatypes in the four
eight and sixteen byte variety for
example float which is what we've been
using so far float two which is two
adjacent floating point numbers float
four which is four adjacent floating
point numbers and so one option that we
could do is we could try to restructure
our code around the idea of having a
single thread pull in four floating
point numbers at a time and do its
transpose on that that would move us up
from this line in terms which is percent
of achieved
with up to this line that's a healthy
increase on the other hand the sort of
torquing the code around to do something
that's less natural like manipulate for
single floating-point values at a time
in this case it's not a particularly
natural thing to do what we we have
coming in an array of floating-point
numbers or a matrix of floating-point
numbers and to read them four at a time
you know a little bitty rows and
transpose those in the little B columns
we could certainly do it but I think it
borders on a ninja topic while this
would help this is the kind of ninja
optimization that will prove useful I
don't think that it's vital let's talk
about other things that we can do so if
we can't make all of our memory
transactions wide or very easily then we
can try to have more transactions let's
have a quiz which of our transpose
kernels so far probably suffer from too
few transactions our first version had a
single thread for the entire matrix our
next version had a single thread for
every row of the matrix our third
version had a single thread for every
element and our fourth version was tiled
check those which probably suffered from
too few transactions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>