<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Better Hash Functions - CS101 - Udacity | Coder Coacher - Coaching Coders</title><meta content="Better Hash Functions - CS101 - Udacity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Better Hash Functions - CS101 - Udacity</b></h2><h5 class="post__date">2012-05-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/N9jaYcCXQgU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we've seen the basic looking at just
the first letter does not work very well
doesn't use enough buckets and it
doesn't distribute the keys well so now
we're going to think about how to make a
better hash function so we want the same
property we had before in the sense that
it's one function that takes two inputs
and the two inputs are the key word
which is a string and the number of
buckets which is the number those are
the two inputs and the output is the
hash value and it's in the range from
zero to number of buckets minus one and
our goal is for these numbers to be well
distributed so we can have any number of
buckets we want the key words will be
spread evenly among the buckets and
every time we hash the same keyword
we'll get the same bucket so we'll know
quickly where to find it so in order to
do better than we were doing before
we're going to need to look at more than
just one letter the key word if we look
at just the first letter we're not going
to do better than having a limited
number of buckets and a bad distribution
so we want to do is something that's
going to look at all the letters of the
key word not just the first letter and
based on all the letters will decide
their appropriate bucket we saw that
with lists if we had a list of items we
could use the for loop construct to go
through the elements in the list like
this and this will go through each
element in P assigning it to the
variable E and executing whatever is in
the block for each element of P we can
do something similar with strings so if
we have a string s we can use the same
construct to go through the characters
in s so each time we go through the loop
the value assigned to variable C will be
a one letter string corresponding to
each character in the string and order
so first it will have the value a then
the value B then the value C then the
value D so this gives us a way to go
through all the elements in the string
and if you remember how he turned single
letter strings into numbers and modulo
arithmetic then I think you know enough
to define a much better hash function so
for this quiz your goal is to define a
function hash string that behaves like
this it takes a keyword a number of
buckets and it gives a number
identifying the bucket where that
keyword will belong but instead of just
using the first law
the key word is going to use all the
letters and produces as output a single
number that represents the bucket where
that keyword belongs and your goal is to
do this in a way that depends on all the
characters in the string not just the
first character there are lots of
different ways to do this so we're gonna
specify exactly what you should do so
what we want to do is make the output of
hash string a function of all the
characters and we can think of that with
modular arithmetic that if we have a
circle which is the size of the number
of buckets so this is going to go from 0
to the buckets minus 1 what we want to
do for each character we're gonna start
at 0 and for each character in the
string we're gonna go around Ord of that
character distance around the circle and
we're gonna keep going so each character
we're going to go some distance around
the circle the circle can be any size
depending on the number of buckets and
we're going to keep going around the
circle using modular arithmetic for each
letter and as we keep going we go lots
and lots of times if it's a big word
wherever we end up is gonna be the
bucket that we use let's say that's
position 27 who knows where it is so
that's the idea and I'll give you a
couple examples so you know if you're
implementing it the right way let's
suppose we have as our string the single
letter a and we have 12 buckets well in
that case we're gonna have 12 buckets we
wouldn't have 27 here this is going to
be 11 is the last bucket the ordered
value of a is 97 so for a what we would
do is go around the circle eight times
because 97 is 12 times 8
and one more because ninety seven is
twelve times eight plus one you don't
actually have to go around the circle if
you use the modulo that's what it will
give you and so the hash value for a
should end up in bucket one as another
example if we tried hash string where
the string is the single letter B also
with 12 buckets well that's going to
also go around the circle eight times
because the order of B is 98 but it's
going to end up in bucket two since
that's 96 plus 2 which will end up in
bucket 2 if we change the number of
buckets the results will be different so
let's say instead of having 12 buckets
we have 13 and we tried hash string on
the single letter string a with 13
buckets the result there should end up
being 6 and the reason at 6 is because
97 is equal to 13 times 7 plus 6 so the
size of the hash table matters as well
as the string we don't want it to just
work on single letter strings with
single letter strings we're really
getting the same thing we defined before
where it gets interesting is where we
have multi letter strings so let's look
at a few examples like that so where we
can see the difference between what
you're gonna find at 1/2 string and the
bad hash string we had before is once we
have longer strings
so suppose we tried the string a you the
Ord of a was 97 and that when we went on
the circle ended up at location 1 the
Ord of you I can tell you is 117 when we
add those two we get 214 and modulo the
number of buckets which is 12 here we
should get 10th so that string with two
symbols doesn't end up in position one
where the a would end up it ends up in
bucket 10 and as another example we
won't work through the details on this
one but you'll be able to test if your
result is correct if you try the string
Udacity it should end up in bucket sorry
I forgot the input size this is very
important
we need two inputs to have string both
the string and the number of buckets
matter so here we're also assuming 12
buckets here we'll use 12 buckets again
the result should be 11 so see if you
can define a function half string that
does this and we want it to take these
two inputs and produce a number that
tells us what bucket that keyword should
be in</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>