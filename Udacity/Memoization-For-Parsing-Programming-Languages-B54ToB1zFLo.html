<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Memoization For Parsing - Programming Languages | Coder Coacher - Coaching Coders</title><meta content="Memoization For Parsing - Programming Languages - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Udacity/">Udacity</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Memoization For Parsing - Programming Languages</b></h2><h5 class="post__date">2012-06-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B54ToB1zFLo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this gives me a great idea let's use
memoization to make parsing very fast
let's cast our minds back to the glory
days of regular expressions and finite
state machines in order to see if a
string was accepted by a finite state
machine we'd essentially keep our finger
on the state so on input a bee bee a bee
bee I just sort of keep my finger on
this middle state to see where things
were going if I stop here then the
string is not in the language but if I
add one more character c a b b c i just
put my finger on it and i can tell we
accept we're going to use this same put
your finger on it trick for parsing to
keep track of where we are to keep track
of which state we're in now for a finite
state machine state that was pretty easy
they were the circles for a parser stay
this is not so clear so we're also going
to solve parsing by putting our finger
on it but just like how
non-deterministic finite state machines
might require two or three fingers
parsing might also require a number of
fingers it's going to be somewhat
complicated consider this simple
arithmetic expression grammar as a
starting non-terminal but then quickly
goes to e e plus e e minus e + 1 + 2
instead of number let's just make it
finite suppose the entire input is 1
plus 2 which is in the language of the
grammar and currently we've only seen
the one in the Plus remember that to
figure out if something was in the
language of a finite state machine we
look at one character at a time we're
going to do pretty much the same thing
for parsing we're going to look at one
token at a time but the question is
where are we now well we don't have
states that look like circles but we do
have these rules in fact we've got five
of them written over here and if we've
already seen the one in the plus and
we're about to see the two I claim that
they're one or two of these rules that
match more closely than others for
example s goes to E that doesn't seem
particularly relevant now minus sign
that doesn't seem particularly relevant
egos to one if we've already seen the
one and the plus we're kind of past that
but these two eep lussi and two
that's kind of where the action is
that's where we are now in some strong
sense in fact I'm going to claim that
we're right here in the rule egos to e
plus e we've already seen the E and the
plus here's my finger and we're about to
see the next e since I can't always
leave my finger on this slide we often
formally draw a red dot in the middle of
one of these rules to keep track of
where we are this is one example of a
parsing state the first d is going to
correspond to or come from the one in
the input ideally the second D will
match up with the two in the input we've
already seen everything to the left of
the red dot we have not yet seen
everything to the right of the red dot
the red dot is right where we are now
this is the past this is the future this
is now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>