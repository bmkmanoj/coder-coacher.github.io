<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>CPU Bound vs. I/O Bound | Computer Basics | Coder Coacher - Coaching Coders</title><meta content="CPU Bound vs. I/O Bound | Computer Basics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Dave-Xiang/">Dave Xiang</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>CPU Bound vs. I/O Bound | Computer Basics</b></h2><h5 class="post__date">2017-05-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wsv07g4ml8I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey what's up guys hope everyone's doing
really really well
wanted to make a quick and dedicated
technical video today about a very
important concept in software and that's
going to be CPU bound vs IO bound and if
you've never heard these phrases before
I hope this video can be helpful its
these are pretty important concepts in
computing if you've already heard this
this is too basic for you feel free to
just leave I won't feel too bad so first
of all what is this well these two
phrases you'll hear this a lot in
software but these two phrases describe
the characteristics of your program so
when you write software and you can kind
of describe the software you wrote you
wrote a program that was very CPU bound
or you could write a program that's very
I Oh bound and what does that mean so
first let's just answer the question of
why is this important well writing
software is just one part of software
development but we also have to always
understand how that software gets
executed on an actual computer or actual
hardware and that's equally important as
writing the software so pretend you just
spent six months building an awesome
piece of software and you're ready to
deploy it somewhere it's time to make a
decision of which computers you're going
to buy or which flavors of Amazon
compute instances you're going to rent
and how do you choose wisely so
hopefully by the end of this video
you'll be able to answer this question
much better all right so let's just get
started the first thing I want to do
again is always just review some
fundamental truths for computers so one
thing I like to do when I get confused
when things start getting a little over
my head I always try to refer back to
really basic fundamental truths like to
kind of ground yourself because often
there's so much stuff you have to learn
your brain will be overloaded that you
need to just ground yourself again and I
usually do that by going back to a lot
of those really really basic truths so
we're going to do that first just to
give a premise for this whole video but
shoes number one that we're going to
review is that remember
that all software eventually gets
translated to some kind of machine
instructions for the processor to
execute I'll just say it one more time
all software eventually gets translated
to some kind of machine instructions and
my definition of a computer just my own
definition of a computer is that it's a
bunch of software telling a bunch of
hardware what to do that's all a
computer really is and if this doesn't
make sense to you at all
I'd recommend watching these two videos
I did about how computer works and I
talked like for 15 30 minutes just about
this truth so all software no exceptions
always gets translated to machine
instructions interpreted Python code
compiled Python code compiled C code
compiled C++ code Java byte codes on
running on a Java Runtime assembly
instructions all this at the end of the
day is just machine instructions so
that's truth number one and hopefully
that's all that all makes sense
truth number two is that remember that
any moment in time on your computer or
on your phone any moment in time your
computer is handling hundreds hundreds
of active threads Accent execution
threads at any point in time and it's
not doing these things in parallel but
it's squishing between them very very
fast and we get a crazy simultaneous
experience but our computers they
execute things very concurrently so they
execute hundreds and hundreds of things
concurrently but remember that's
different than in parallel so let's just
open up activity monitor and showcase
that real quick so Activity Monitor is
what's on Mac OS there's I think task
manager for Windows and probably
different command-line tools for UNIX
systems but pretty much Activity Monitor
just gives you a basic rundown of you
know your computer's resources how
things are going but when I said
hundreds of threads I just want to
reiterate what hundreds of threads means
so these are all the active process
names on my computer right now there's a
ton of them you can see the total count
is 2,100
sixty-five there's 418 processes
processes but like Colonel tasks
whatever this is doing has 328 Dropbox
is using 153 chrome and 51 threads going
screen recorder right now screen
recorder has 47 threads so obviously two
thousand threads at one point in time
your computer doesn't have two thousand
cores right my computer probably only
has four cores but those four cores are
so fast they switch between those two
thousand threads really really fast and
everything gets done so that's truth
number two so at any moment in time your
computer's handling hundreds it's
actually thousands of active threads of
execution all right at any point in time
that's always happening the next thing I
want to do is just go back to our chef
analogy if you've watched some of my
other processor videos computer system
videos I always make this analogy of a
processor to a chef and I professor told
me about this analogy and I always
always go back to it because it's the
easiest for me to understand at least so
just as a summary I have a lot of other
videos that talk about this but this is
a summary of those analogies so a chef
is kind of like a processor and the
recipes the food recipes are execution
threads or the software that has to be
run so a processor has to execute a
bunch of different threads and a chef
has to execute a bunch of different
recipes if you make a beefy chef with
multiple arms that's kind of like
beefing up your processor giving your
processor more Hardware having it handle
Hardware threads instruction level
parallelism and if you have four chef's
if you have four beefy arms chefs with
multiple arms that's kind of like quad
core processors each with crazy
capabilities all right so that's the
basic chef analogy and we're going to
run with this for the rest of this video
and hopefully those analogies are still
ingrained in your head so one thing I
want to do now is just revisit the truth
number two and use this analogy Andrey
restate truth number two so at this
moment in time your computer is handling
thousands of active threads of execution
it's not doing these things in parallel
it's just swishing between them very
fast so using the chef's analogy at this
moment in time the chef is handling
thousands of recipes to cook the chef
isn't doing all these recipes in
parallel because he's just one person
but he's so fast that he can switch
between all these recipes very fast ok
now we're on to a new truth and this is
going to we're going to start getting
into the differences between CPU bound
and i/o bound we're almost there but
it's all going to click that whole
introduction I hope is leading to this
so truth number three is that all
recipes aka your software but all
recipes are different some recipes will
get faster if we get a faster chef but
some recipes will not get done faster
even if we get a faster chef so here's
two examples of that just to showcase
that you have one recipe and this is
what the recipe says it's chopped
one-trillion tomatoes chopped - Trillian
onions and then multiply them all
together and you can see by this recipe
if you have a faster chef he's going to
get this done faster than a slower chef
right if a faster chef can cut a million
tomatoes a second
he or she is going to do that much
faster than a slower chef who can only
cut a hundred Tomatoes a second so it's
very clear that given this type of
recipe faster chef is going to do it
better so let's take another recipe
recipe B so this recipe is we want to
store run one-trillion recipe
translations into the restaurant
warehouse across town and the thing is
for this case the chef doesn't control
how fast things get stored into the
warehouse because it's not part of the
kitchen so the key point here is that no
matter how fast the chef is he's not
going to be able to store the recipes
into the warehouse any faster because
what if the warehouse just has one
entrance there's only so much that can
fit
to one entrance over some period of time
right so how would you ever possibly
make recipe be better but the only way
to make recipe be go faster is you have
to actually improve the warehouse if the
warehouse got improvements like if the
warehouse has four big doors with huge
entrances then we could actually move
things into the warehouse faster and
this program could actually perform
better
right so recipe B is actually bounded by
how good our warehouse is and it's not
bounded at all by how fast the chef is
so if you didn't get it by now I think
recipe a is the essence of cpu-bound and
recipe B is the essence of i/o bound and
let's take it out of abstract win and
talk about some real things now so that
recipe a cpu-bound
recipe B IO bound so we won't let's not
talk about chef stuff anymore let's talk
about real CPUs and programs but the
definition of CPU bound is that a thread
of execution or a program this is a
fancy word of just saying the software
you write or your program but a thread
of execution is CPU bound if it's
performance is correlated with the CPU
all right a thread of execution is CPU
bound if it gets better as the CPU gets
better so examples of this are heavy
duty math operations image processing
video processing a lot of these type of
software it's a lot of CPU work so like
we said before a faster chef is going to
cut one is going to cut a trillion
Tomatoes faster than a slower ship just
like a faster CPU is going to matrix
multiply 1 trillion matrices faster than
a slower CPU all right so hopefully
that's clear recipes or software that's
heavy and math heavy and CPU processing
these are always bound by CPU so let's
take the other the other example which
is IO bound the definition these are all
just my definitions from what I
understand but IO bound means that the
threat of execute a thread
execution is IO bound if it's
performance is correlated with a
subsystem or peripheral or something
else that the CPU does not control so
this includes writing files to your
hardware or hard-disk
sorry harddrive writing files to your
hard drive waiting for responses from
the network so in our chef's example we
said that a more upgraded warehouse with
more doors let the chef's store the
recipes faster right and then now the
analogy for that was actually writing to
disk so writing files to a brand-new SSD
hard drive is just going to be straight
up faster than writing to an old
spinning hard drive right waiting on a
network response from Reddit say your
software calls reddit a lot to get on
the top top reddit post well your
software is going to be limited to how
well the reddit servers are performing
right if the reddit servers are being
slow there's actually nothing you can do
at that point you can't get a faster CPU
on your computer to improve reddit
server performance so this is kind of
the essence I about and I hope the
distinction between this and CPU CPU
bound is more clear now so last but not
least the truth number four the final
truth of this is that programs are more
often i/o bound than they are CPU bound
this is much more practical like
practically maybe like 80 90 percent of
the time the majority of times programs
are going to be IO bound and less often
they're going to be CPU bound so that's
just truth number for so many people
optimized for this case and there's less
need to optimize for these cases though
they're still possible so to close this
video out I thought it'd be kind of cool
to just propose some questions for
everyone to think about these are just
random questions that I thought of that
hopefully if you think about them too it
would test your understanding of these
kind of things so question one if you
were to design your own scheduler how
would you give different
already two different programs if you
knew there were more i/o bound or more
CPU bound if you had a CPU that could
handle four threads at the same time and
you knew that you only had to run
programs there were 100% CPU bound you
never nothing at all as i/o bound how
many threads of execution would you
practically let your system run at one
time
how would you how to schedule there even
determine if an execution thread your
software is more i/o bound or more CPU
bound how would how would you write a
scheduler just to determine that how
would you even figure that out based on
everything we talked about there's
another phrase called memory bound and I
think you guys can probably probably
guess what memory bound means and last
if you have a hundred different big
objects that are not related to each
other each object requires you to do a
bunch of complicated CPU work and then
you got to store that result on your
computer so it's a mix of CPU work and
i/o work let's say you have a dual-core
processor that can handle eight threads
at any point in time how would you
design your software is to do this the
most efficiently so those are just some
questions to think about I am running
out of time here hopefully this video
was helpful for anyone that wanted to
just kind of understand better how their
software is run on Hardware it's really
really important that you can write
software and also understand how the
software is executing so I hope this
video is helpful more technical videos
to come and I hope everyone has a great
rest of the week all right take care</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>