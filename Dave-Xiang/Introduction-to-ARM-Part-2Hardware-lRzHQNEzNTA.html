<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to ARM - Part 2(Hardware) | Coder Coacher - Coaching Coders</title><meta content="Introduction to ARM - Part 2(Hardware) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Dave-Xiang/">Dave Xiang</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to ARM - Part 2(Hardware)</b></h2><h5 class="post__date">2016-12-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lRzHQNEzNTA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right guys part two of introduction
to arm video and let's just jump
straight into it where we left off from
par one alright so section a 14 a-14
okay architecture extensions all right
so I guess each architecture will have
kind of like a base level like we just
talked about the profiles from part 1
but even aside from the profiles you can
actually customize and extend the
architecture for a specific use cases
alright so what exactly are these
extensions but they're just extra
goodies alright extra goodies if you
implement these extensions you get more
features and they're all specified very
well so let's just run through the real
quick and I'll just give you guys a
rundown of what some of them means so
some EE this is there's a variant of
thumb instructions that we already
talked about them a little bit so not
too important vfp is a floating-point
coprocessor so this is probably like
extra instructions that are particularly
good for handing handling floating-point
math which is actually much different
than integer math right doing two plus
two is quite simple doing three point
five six seven plus two point eight five
nine or whatever is much more difficult
so floating-point floating-point support
is a big thing another cool accession
they have is cindy advanced simdi SIMD i
always print is pronounced simdi
casually but this is instruction set
that provides single instruction
multiple data functionality and this is
pretty cool I have a small example to
explain this a little bit on the right
but single instruction multiple data
what does this mean so think about a
basic add assembly instruction all right
it might look something like this I want
to add r0 plus r1 and move it into our 0
this might be what a simple add
instruction looks like it just takes two
registers puts it into one red dress
what a simdi instruction can do is
actually with one instruction with still
just one instruction you can actually
access multiple data points at the same
time so this instruction could actually
be like I want to add our 056 I want to
add ours sorry this is wrong this should
be so I want to add four registers are
zero r1 r2 r3 I want to add each of
those correspondingly with four other
registers four five six and seven all
right I want to store the results and
are 0-2 are three so what this is
actually doing this is doing like for
ads at the same time and putting it all
into the same place right with one
specialized instruction and this is
really cool some of these type of
instructions where you add all this
stuff kind of like at the same time
these are used for like advanced signal
processing type of features make maybe
audio processing digital signal
processors use these kind of cool single
instruction multiple data instructions
all right other extensions security
features is kind of boring I'm not
boring but i guess not going to dive
into that too much another cool one that
i want to mention is that there's a
extension called giselle forearm and
what is giselle but let's just read it
this is a Java byte code execution
extension that extended from arm so it's
a lot of fancy words but if you guys are
familiar with Java this is kind of like
hardware support for a java bytecode so
if you guys know java is a little
different from some other programming
languages because when you compile Java
code it compiles to this special java
bytecode you need a run time to execute
it right there's that JVM and the JVM
knows how to execute java bytecodes
because those bite counts aren't really
machine instructions so it's kind of a
runtime software to execute these byte
codes
pretty much what this extension is
saying is that there's actually a way
that the hardware itself can interpret
and understand the java bytecodes
directly and so this could be like
potentially really executing java
bytecodes very fast straight from
hardware which is a really cool
extension and they probably added this
when you know Java started blowing up
but let's just keep going on so the next
section a 15 the arm memory model is
just a quick snippet about the address
spacing and memory and it's actually
kind of a nice segue to just talk about
memory a little bit so the ARM
architecture uses a flat single flat
address space of two to the 32 8-bit
bites the address space is also regarded
as 2 to the 30th to to the 30 32 bit
words so hopefully that math kind of
makes sense if you can support two to
the 32 8-bit bites you can also kind of
support to to the 30th 32-bit bytes
because this is actually divided by four
you have to understand binary to
understand why this is true but i'll try
to explain it a little bit on the right
so let's just talk about addresses a
little bit all right so when they say
they have a flat address space of two to
the 32 bytes it means they have just
like 32 to the 32 this is about 4
million or four gigabytes this is just 4
million but I don't know the exact
number is just 2 to the 32 unique things
and those addresses can be listed all
the way down from like zero one two
three all the way down to two to the 32
so each one of these addresses
represents a unique bite alright so
don't look at let's just take this
example right so each address here
represents a bite and this is a
shorthand way of representing a bite all
right so remember a bite let's just do
some basics again
but one byte is eight bits right so
let's just take this is so this is hex
this X means hexadecimal if you open up
your calculator this de as hex decimal
this is the number 222 but actually here
they have it in the Bight version so you
can see how this is X exactly one bite
or eight bits the bit representation is
a 1101 1110 so these eight bits
represent de and if you go back to our
little memory table here like address 0
correspond the value de is at address 0
the value ad is at address 1 the value
be e is at address to whatever but no
one writes it like this I'll show you
how people usually write it people
usually write this in like word
increments or chunk your comments
alright so this is a much more easy way
to kind of just read memory because you
always interview usually interpret
memory in four bites at a time at least
in the ARM architecture you always
interpret things four bytes at a time so
1 x 2 x 3 x 4 byte nobody would ever
read it like this we kind of read it
like this so an address 0 we're storing
deadbeef this is 4 bytes and address for
we're storing this value at address 8
we're storing this value address see
which is 12 we're storing this value
alright so another cool thing to kind of
recognize here is the cost of the big
verse little Indian I'm sure some of you
might have heard about this but how do
we know deadbeef here represents
deadbeef when we look at it in a chunk
right when we look at that per byte it's
actually very clear this address is for
despite but when you group it there
actually two distinct ways of grouping
it so if the de if bees kind of if this
bite comes first and it's actually the
lowest memory address we call that big
endian but also you can reverse that and
people call that little endian so
actually at address three they have D
address to they have ad address one they
have be but it's literally just the
reverse and all this is is a different
way to interpret the bites you you
either interpret it as is this is dead
beef right dead beef or you can
interpret it kind of backwards like dead
beef but either way no matter what your
system uses the word store that address
zero is dead beef alright so this
concept I'm not doing it just this by
explaining it here but hopefully gives
you a little bit of an intuition about
how bites are stored in memory and how
you address them alright so let's go on
to Part A to debugging is not important
it is important but so this section is
actually pretty crazy so like many of
you guys know that when you use new
software you read API Doc's right if you
like learn this new API you read the
documents for software right but
actually there's an API for hardware and
they just call it application level
programmers model but what this really
is is literally just like the
programmers interface to the hardware so
this section a 2 is kind of like the
just like the api docs for the hardware
and just like software you have these
things for hardware so this is where
it's getting a little complicated and
i'm just going to actually focus on the
left and let's just go through some
important parts of this part so this
section a2 is very important because
this actually specifies the size of the
core data types
remember within different specifications
they will call these things will have
different sizes all right so arm is just
one of them and based on whatever
specification you're looking at these
numbers could change so for a bite it's
8 bits a word is 32 bits which is very
specific to arm a double word is 64 bits
but you know these definitions could
change across processors but it's really
important that they specify it all out
here so the instruction set contains
instructions supporting the following
data types so these are all the
combinations of things like you could
hold a 32-bit pointer in one register a
32-bit integer in one register you could
hold two 16-bit in the cert integers
sorry guys you could hold two 16-bit
integers packed into a register or for
apron integers packed into a register or
even one 64-bit integer held in two
registers so every specification must
specify these definitions arithmetic
this is not this is too detailed this is
too detailed oh this is also really
important so every single processor
specification will specify kind of what
registers it needs to use remember if
you guys don't remember the memory
hierarchy but like the register is the
closest piece of memory to the processor
and it has the fastest access time so
for the arm v7 it has 13 general-purpose
registers are 0-2 are 12 where you can
just do general math special registers
and actually they have three 32-bit
special registers are 13 to our 50 these
are special ones so
these are actually really important to
understand like I'm not going to do a
just this by this video but every single
processor architecture does have special
special registers so one of them is a
stack pointer the stack pointer is used
for calling into and out of subroutines
it's used in conjunction with this link
register so both of these work together
to kind of implement something called a
call stack and what a call stack is is
just like when you have your function
calling a function calling a function
then returning then returning and
calling a function tracking all that
state is done with these two registers
all right that was so simplistic but
hopefully that's the gist of it the
program counter is actually very
important the program counter is
actually a special register that always
points to the instructions you're about
to execute so pretty much the program
counter is always pointing to different
memory instructions and you're always
always always executing whatever the
program counter is pointing to and this
is also very important register so
alright guys so that's that was section
a 23 and we are on page 43 of page two
thousand I think that's enough for this
set of videos I'm going to stop it here
I felt like I talked about a lot and I
kind of rushed it but obviously we're
not going to go through 2,000 pages but
I hope this video gave you guys a good
introduction of what a processor
specification kind of looks like so this
was a good introduction I hope it gave
you guys a taste of hardware a little
bit in a taste of processors a little
bit alright thanks for your time and I
hope you enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>