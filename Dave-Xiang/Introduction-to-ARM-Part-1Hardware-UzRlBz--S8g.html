<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to ARM - Part 1(Hardware) | Coder Coacher - Coaching Coders</title><meta content="Introduction to ARM - Part 1(Hardware) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Dave-Xiang/">Dave Xiang</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to ARM - Part 1(Hardware)</b></h2><h5 class="post__date">2016-12-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UzRlBz--S8g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey what's going on guys hope everyone's
doing really well as usual it's gonna be
a pretty technical video this week
whenever I look at the analytics the
technical videos always do a little
worse than some of the more life and
like wishi videos which those are also
good too but I know they're a handful of
people on the channel that still
appreciate some of the more hardcore
kind of tech videos so this week's video
is going to be hardware related and it's
going to be an introduction to arm
alright so there's definitely a learning
kind of a basic level of requirements
before this will make any sense I would
suggest that least to watch my computer
systems playlist so basic knowledge of
RAM memory hierarchy processors all that
stuff please go watch that sub first if
you haven't or else this video won't
make too much sense alright so what
we're gonna talk about here is on the
Left I had this crazy 2,000 page ARM
architecture reference manual for a
specific arm specification alright and
what we're gonna do is I'm gonna keep
this open on the Left we're gonna walk
through it together and I have some
notes on the right to explain some of
the stuff on the left so let's just get
to it so if you guys remember arm arm is
just a very very popular processor
specification usually found in like a
lot of chips and mobile phones a lot of
embedded devices there's definitely a
lot of processor these days that are
implementing arm instruction sets
alright it was originally a British
company I think that made the
specification and it's it's a little old
and it's definitely grown over a long
period of time and this is this is even
an outdated document that I somehow was
able to get my hands on but it's arm v7a
and this is a lot not the latest
architecture I think they're out with
v---aids or v 9 or something but this is
going to be a walkthrough of the arm v7a
architecture and we're just going to
walk through this document
alright so 2,000 pages but it's not so
bad all reads some important stuff if we
go across it
stuff table of contents let's just go
straight to the intro so so about the
ARM architecture let's just read what
they wrote so maybe they do a better job
explaining it the ARM architecture
supports implementations across a wide
range of performance points it is
established as the dominant architecture
in many market segments the
architectural simplicity of ARM
processors leads to very small
implementations blah blah blah okay so
pretty much what they're saying here is
that we're awesome this is a great
architecture and you should implement
processors for our architecture right
remember guys always distinguish the
architecture or the specification versus
the implementation so like pentium
one-two-three-four they're all different
implementations of one specification
right so in the document on the Left
where we're going through the
specification of v7 but there are so
many implementations by different
companies around the world for this
architecture alright and we're just
gonna walk through the specifications so
first thing to know is that the ARM
architecture is a reduced instruction
set computer or a RISC carpet
architecture so what does risk really
mean but let's just go over to the left
a little bit so there's always been this
old debate I don't even know if this is
really a debate anymore but like this
was like a popular interview question
when I was in school but it's pretty
much the differences between a risk and
a Sisk Sisk Sisk instruction set
computer all right so the key word to
understand the key differentiating word
is reduced versus complex all right so
our market texture is the reduced kind
so what are some differences between
complex and reduced computers so right
off the bat a complex computer has a
large number of complex instructions and
a RISC computer has fewer more simple
instructions all right so very few
instructions but you can probably build
up simple instructions to make
complex instructions the next major
difference is that Sisk computers have
variable length encoding and this is
good for code density and I'll explain
this a little more whereas risk has
fixed length encoding for all its
instructions so let's just take an
example but let's say there's a computer
instruction like add R 0 to R 1 like
this is an assembly instruction right
guys what a fixed length encoding means
is that this is always a set number of
digits whatever length this might be and
this is always the same for any single
instruction whether that's add jump any
instruction will have the same exact
length of encoding so when they say
variable encoding that kind of means
that the length of these and codings can
differ so ad might be like maybe ad is
just a few but then you have like a
multiply and that's like a lot much more
complicated and it's a different length
than you have like divided and that's
like a little shorter but one of the
really key characteristics of Sisk
was that you could have variable length
encoding for all these different
instructions and it was actually very
good for code density because you know
some instructions are really simple you
don't really need a lot of binary to
represent it all right
and on the for risk all these are the
same all right so that's kind of what
this means by fixed length and codings
every instruction is 4 bytes and
variable length encoding z' so last
major difference there are a lot of
other differences between these two
architectures and I encourage everyone
to go ahead and read about them but one
thing that you can do in a 6 Sisk dam
that word the Sisk system is that math
operations you can do directly on memory
or registers which is pretty crazy too
so you could have like one specific
instruction that can manipulate like
something in memory and that sounds
intuitive right but just compare that
with how risk works so in a RISC system
all the operations are only allowed on
registers so if you want to access
something in memory it's actually a
two-step process you have to access the
memory you have to first load the memory
into the registers before you work with
them all right so it's actually quite
different
everything you do in a RISC system has
to be done on registers if you need to
use something from memory you need to
get that thing from memory and load it
up so this is also all the if these
words don't make sense I have one video
on the memory hierarchy which you should
watch which kind of spills out spells
out sorry all the different levels of
memory and remember registers are the
closest level of memory to the processor
all right so let's just keep going on
the left here this video is gonna be
pretty long I'll probably split it up
into two parts but that's just the basic
introduction of the ARM architecture
alright another thing they have that's
kind of cool is they have these thing
they have two different instruction sets
so they have an arm instruction set and
they have this thing called a thumb
instruction set which is kind of like
shorter instructions so let's just read
the thing on the left first so the arm
instruction set is a set of 32-bit
instructions providing comprehensive
data processing whatever whatever the
thumb instruction set was developed as a
16-bit instruction set with a subset of
functionality of the arm set it provides
significantly improved code density at a
cost of some reduction in performance a
processor executing some instructions
can change to execute arm instructions
for performance critical segments in
particular for handling interrupts
alright so I guess the main thing that
if we look on the left a little bit is
that these are just actually two
different instruction sets that one
specification has defined alright and
they have different use cases so this is
pretty cool
but thumb this kind of you can think of
the thumb as like a subset of arm
functionality if the instructions are
also much smaller like they mentioned on
the left the thumb has 16-bit size
instructions which are 2 bytes
whereas remember arm has 32-bit
instructions which are 4 bytes so each
instruction is half the size so like
your code level will be much smaller
another important thing to note is that
these instructions are very different
right an arm instruction is 32 bits and
a thumb instruction is 16 bits so a
processor can either process thumb
instructions or arm instructions but not
at the same time right so a processor is
kind of going in thumb mode because you
can't like interlace these instructions
and expect the processors to understand
if we're thumb mode we're expecting
thumb instructions if we're an armload
respecting arm instructions so those are
kind of different modes of operation for
the processor and as they said in this
paragraph is that you know there might
be special use cases where you would
want to use like thumb over arm or
something all right so that's actually
another really cool feature of arm is
because they have two different
instruction sets embedded in the same
specification so keep it moving oh this
part is pretty cool so this is where the
word egg comes from so architecture
version profiles and variants so these
things are always evolving so the arm in
thumb instruction set architectures have
evolved significantly over time and the
ARM version seven has a different
profile right it actually says it has
three different profiles and each of
them is really different so let's just
read about each one real quick there's
an a there's an R and there's an M so
the a is a application profile so this
implements a traditional ARM
architecture with multiple modes but
application profile this is confusing
but what application profile means is
that this is like
the beefiest one like the strongest one
this is made this is meant to be used
for like application processors running
like really big operating systems
running really big applications all
right
the are ours for real-time profile so
real-time is a little different right if
you have a real-time system that's kind
of like a missile on the ship or
something that actually is broken if it
doesn't execute in a certain amount of
time
that's what real-time means right if our
computers are slow then that sucks if
like a radar is slow or something super
real-time that's actually it's broken so
that's the real difference in that
system real-time systems really need to
finish stuff at a certain time or else
they're just straight-up broken the last
profile is this microcontroller profile
so this is probably the most simplistic
one designed for microcontrollers
microcontrollers are very simple think
of microcontrollers as like the thing in
your like like your fridge or your
microwave or maybe the car dashboard or
like really simple or like the toaster
like your toaster probably has a
microcontroller in it so these are very
like small simple like kind of small
simple hardware and arm has a profile
for that so it's kind of like three
different profiles depending on what you
need so if you're building a rocket
maybe you need to use this real time
profile if you're building like a mobile
phone maybe you need the application one
if you're building a toaster maybe you
need the microcontroller one alright and
here is oh this is actually pretty cool
so this document I picked is just ARM
version seven but it's gone through a
lot of different versions and evolutions
so I just picked seven eight is already
out but they give you a little
historical view of you know how it's
evolved over time like our version for
this is the earliest architecture
variant it includes only the arm
instruction sets version 40
they added some version 5t they improve
interworking of arm and instruction arm
in some instructions they added a couple
important instructions on v te they
added more instructions so this is like
the evolution up to seven and it will
continue to evolve alright so that's
pretty cool so this section just talks
about all these different versions well
there's a lot so obviously some of them
are obsolete but yeah just keep going
alright arm actually we're coming up on
I'm gonna finish this off as part one
actually this video is so technical that
I need to break it up into parts
properly because I do want to discuss
every section and you know make sure I
talked about each section pretty well
and not skip over it so we're gonna make
another part of this video and it's
gonna we're gonna dive straight into
this extension part in part two alright
guys so go on to the next one</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>