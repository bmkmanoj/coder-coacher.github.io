<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambda Basics 19 - Closures in Lambda Expressions | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambda Basics 19 - Closures in Lambda Expressions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambda Basics 19 - Closures in Lambda Expressions</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WcLum7g6ImU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this tutorial I will talk about
closures which is a very important
concept when you're looking at
functional programming that is if you
are able to pass functions from one
place to another in the code as values
you will have to deal that closures
explain what closures are in this
tutorial and how we have kind of already
seen closures in action even in Java 7
well probably not theoretically there's
probably a theoretical computer centers
who's going to come and say no that's
not closures but it kind of behaves like
one and just so that we start off with
the familiar setting what I'm going to
do is I'm going to create a new class
here and demonstrate what kind that
happens with the you know the anonymous
inner classes concept in Java 7 and how
it's very close to closures so I'm going
to create this example class called
closures example I have a main method
here and here I'm going to have an
interface call the process which
basically has a wide process method
right it just sticks in let's say it
takes in an int I I'm going to have a
method here static do process which
takes in a process instance then it
performs it be dot process pass in an
integer I I'm just going to do process
off that I and this has to be a void all
right so it just takes in an integer and
an instance of this process interface
and it just executes the process for
this thing now let's say I want to call
this do process over here let's say I
have an int a equals 10 for example
these are all random values here so just
they don't have any specific meaning but
what I want to do is call the do process
method over here and say do process off
a and then the process so I'm
to create a new inner class I'm going to
say new process it's an anonymous inner
class and I'm going to print the value
of whatever is getting passed and so I'm
going to implement this method which is
process of and I and I'm going to print
println off high okay fairly simple it
is an anonymous inner class which has an
implementation of process which is
prints that I this should print 10 no
surprises there
we would execute this then gets printed
now here is a thing you can do now
rather than print I let's say I want to
print I plus some other integers they
say I have a int B equals 20 right I
want to print I plus B can I do that
over here can I say plus B over here
well I kind can assuming that this is a
final if this does not change right
let's say I save this and execute now
here you see the value shows up fine now
what this what's happening here seems to
be very simple now how B being a used
over here and I'm taking the value over
here so the compiler is basically
resolving be 220 right this class
implementation does not have a B but the
compiler knows that there is a B over
here that's looking up the value but if
you think about it it's kind of strange
because when is this method getting
executed it's not getting executed
inside the mean it's actually passed
into the due process and it's the due
process method that executes the
implementation of process so when this
happens in this line line number 22 is
there a variable B in the scope well
here there isn't because this method
does not have a B so what's happening
here is the Java compiler or the Java
Runtime actually is keeping track of the
value of B over here right it knows that
B has the value of 20
it knows exactly what to use if I were
to do something like this B equals 40
and notice what happens I get another
the error says the local variable
defined in an enclosing scope must be
final are effectively final now before
Java 8 what you had to do to do
something like this let's do this final
you're basically telling the Java
Runtime that you don't intend to change
the value because as you notice if I
were to change the value of variable
like this it would give an error I'm not
supposed to change it so you have to
declare that it is a final in the
previous version but now you don't have
to do this end Java 8 this variable is
what's considered effectively final
which means that the compiler is saying
hey you don't have to put a final in
there but I'm going to trust you that
you're not going to change this variable
however I'm still keeping an eye and if
you change that variable I'm going to
complain see that's what it does when I
do change the variable it complains
gives me an error but it didn't really
want me to put a final in there it's
like it's saying I trust you to do the
right thing but I'm going to catch you
if you do the wrong thing so we cannot
get this by we are essentially creating
something that does not change I can
however read the variable in this inner
anonymous class and if I get passed
around the value of this variable it
does get passed the variable itself does
not get passed around the value which is
frozen
is going to get passed so when this gets
called you still have the value of 20
which gets printed then this actual
method is getting called all right so
this is similar to the concept of
closures that we have in functional
programming now if I were to replace
this with a lambda expression what's
going to happen is something very
similar let's say I take this out and
rather than creating an anonymous inner
class I'm going to create a lambda here
it's going to take the I single argument
and it is going to do a system dot out
dot println of I plus B I've notice here
that this is a lambda expression I don't
need the parentheses here this is just
one variable one argument and notice
that this is lambda expression which is
getting passed around right this is
getting passed to do process the due
process is going to accept it and it's
going to execute it then it executes it
it's going to execute this body system
to router print of I plus B over here
now there is B coming from it is coming
from this thing called the closure
whenever there is a lambda expression
here and it's using something in the
scope some kind of a variable in the
scope what the Java compiler on the Java
Runtime do is they kind of freezes the
value it says okay this lambda
expression is using B and B happens to
be 20 at this time so it's going to
freeze the value of 20 along with this
lambda expression so wherever this
lambda expression goes whenever it
accesses the value of B it takes the
frozen value of P because this could go
and this new process could execute this
process somewhere later in time but by
that time maybe this B has changed to
some other different value doesn't
matter this process is going to contain
that frozen value of B so wherever that
lambda expression goes that frozen value
goes along with it okay so this is a
concept of closure if you also learn the
concept of effectively final which is
that when you're using these kind of
scoped variables in your lambda
expression the compiler expects it to be
effectively final you don't have to
actually have a final here this is
actually final what the compiler says is
you don't have to put a final in there
as long as you can guarantee that it's
final I'm good okay so make sure you
don't change any variables that are in
the enclosing scope inside the lambda
because it doesn't consider that you
just throw the compiler error you're not
allowed to change those variables</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>