<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambda Basics 20 - The this reference in lambdas | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambda Basics 20 - The this reference in lambdas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambda Basics 20 - The this reference in lambdas</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x9ovGHK7r2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this tutorial I'll show you a special
difference in the veiled lambdas work
when compared to an anonymous inner
class and that is with reference to the
distance so you know that the distance
for any object refers to the instance of
that object itself that's being used so
you can access that instance by using
the special keyword called this it works
just like you would expect it to from an
anonymous inner class but it doesn't
quite work that way for a lambda
expression and let me demonstrate that
this is among many other things is a
true indication that a lambda expression
is not really a syntactical sugar around
anonymous inner classes but it's that it
is its own thing so let me give an
example of so let's say I have the
method over here that are copied from
the previous example but rather than it
be a static method I'm going to make it
an instance method so this is basically
something that has two input arguments
as an integer it has an instance off
process and it just executes the process
a-b dot process method with the integer
we have done this before and what we did
was we passed in and either and a lambda
expression which just printed out the
value of that integer right now what I'm
going to do here is create a main method
so let's say I have this public static
void main and now I'm going to create a
new instance of this class at this
reference example alright now what I can
do is I can call the do process method
on does this reference example by
passing in whatever arguments it expects
which is an integer and an instance off
process and what I'm going to do first
is create an anonymous inner class off
this process interface and then pass
that in so let's say I do a this
reference example dot do process by
passing the value 10 as integer and now
for the second are given I'm going to
create an anonymous inner class that
implements the process interface will
see a new process
and implement this method called process
and now here what I'm going to do is I'm
going to do assists out off let's say a
couple of things value of I is then I'm
going to print I and then I'm also going
to print the distance this one printed
as this now what's happening over here
they're calling the do process method
off this instance of this class and now
what is this new process do it takes in
two arguments one is the integer and one
is an anonymous inner class and it just
executes it so what will happen over
here is first it prints the value of I
which is what is the integer that gets
passed in to stem the second thing that
it does is prints the dis reference now
what is it this reference here let's
find that out by executing this and we
notice here that this reference happens
to be the instance of this anonymous
inner class that we created now what is
this method apart of which object is
this method a part of it's part of this
anonymous inner object that was created
over here so this reference points to
this new process instance that was
created in line by using this new
keyword alright
so that's what it's referring to and
that's what gets printed in the console
that is this one so since it's an
anonymous inner class it has this unique
token which identifies it as the name of
the class what I could do further is do
a override of the two string method
all right try to run this you're going
to get that to string because it's
actually printing out the two string of
this anonymous inner class I hope that
makes sense this is not Java 8 this is
the classic anonymous inner class and
the method of an anonymous in my class
referring to the instance of the
anonymous inner class when you refer to
this reference that's actually the
reason that you can even access that
this reference over here because you
remember the we are in a static method
and then the static method in Java you
really cannot access the distance but
here you can do this because you're
working in an instance of an object so
the dis reference is perfectly valid
over here if I would access at this
reference outside of this it's not going
to work let me demonstrate that if I
were to print the distance over here
notice what happens the compiler
complains that I cannot use it this in a
static context which makes sense right
the public static void main is being
called without the context of an
instance of an object so you cannot
really access to this reference now
notice what happens when I change this
from an anonymous inner class to a
lambda expression of course I cannot do
a two-string so let me get rid of this
and now instead of having a process
method here as an instance method of an
anonymous inner class I'm going to make
this as a lambda expression so this is a
lambda expression which implements the
process write it Dickson unite
implemented the process method takes in
an integer and it you know it's a
function which returns a wide so I'm
going to take an I and let's say I have
this block of code and I face these two
things inside and notice what happens
you get an error for the distance again
say so it cannot use this in a static
context and why is that
I am NOT using this inside this static
void main directly I'm using this inside
a lambda expression now why is this
still complaining it complains because
lambdas treat this reference in a
slightly differently than an anonymous
inner class in the case of an anonymous
in a class like we've already seen that
this reference refers to the instance of
that anonymous inner class but in the
case of a lambda
the instance of a lamb that does not
touch the dis reference that this
reference is actually unmodified when
you're using it in a lambda expression
this is intentional this is by design so
when you're using a lambda expression in
any part of the code the value of the
dis reference is basically the same as
what the distance would have been
outside the lambda expression the lambda
expression does not overwrite the
dystrophin so here you can see that it's
not poor lighting it it still refers to
the static context which the main method
had and so this is still giving an error
now I'm going to comment this out and
Mark that this would not work now how
about if it's in an instance method so
let's say I create an execute method
here and inside this execute method I'm
going to call the due process so this is
not a static method anymore right I'm
calling the due process in the execute
method and over here what I'm going to
do I'm going to do with this reference
example dot execute now here since it's
not in the static context can I use the
distance well turns out we can but again
like I mentioned since this is inside a
lambda this does not modify that this
reference now in this case what is it
this reference point to this points to
the same value as the distance pointed
to outside this lambda expression now
what is this reference point outside the
land expression so if they are using the
list reference somewhere over here what
is this point to this points to the
instance off the object on which the
execute method is being called now
what's the instance on which the execute
method has been called it's that this
reference example okay so this this
reference points to this instance I hope
that makes sense so let's verify that by
executing this I'm actually going to
comment this out completely so that we
just have
one print statement and now if I were to
execute this you can see that it is
pointing to the distance example so I
can verify that one more level by adding
a two string so I'm going to have a
public all right so I'm overwriting the
two string on the this reference example
class and if I were to run this you can
see that the distance inside this
instance method inside the lambda in the
instance method rather points to the
instance that the method is being called
on I hope this makes sense
in a nutshell what you need to remember
is that in an anonymous inner class when
using the distance you basically have
overwritten this reference the anonymous
inner class instance overrides with this
reference the value changes inside that
anonymous inner class but in the case of
a lambda that does not happen it still
refers to the instance that it points to
outside of the lambda
there's no overwriting that happens</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>