<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 35 - Understanding AOP Proxies | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 35 - Understanding AOP Proxies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 35 - Understanding AOP Proxies</b></h2><h5 class="post__date">2011-10-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yiinKulgm4U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi guys and welcome to this tutorial in
this tutorial I plan to explain some of
the concepts behind aspect oriented
programming will try to understand how
and why aspect oriented programming
works well if you think about this in
you know in a pure object-oriented sense
let's take this main example you know if
you look at it in a pure object-oriented
sense I am calling a method of an object
and that method has some code which is
already in it now this code has to run
whenever I call this method
now how is it possible that some other
code which is in some other class in
some other method runs when I called
this method how do how is it even
possible never have an aspect configured
over here and this advice needs to be
applied based on my point get definition
and now if I apply my pointer definition
to this method this code will run
whenever this code runs it could be
before or after around or whatever but
this code runs even though we do not
have this call to that method anywhere
in the school now how is it possible in
a pure object-oriented paradigm well
it's actually not possible and as I said
earlier aspect oriented programming is a
completely different type of programming
and what we do in spring is we use some
of the object-oriented concepts to
achieve aspect oriented programming and
the very spring uses these concepts is
using a proxy now we have heard of proxy
as a design pattern so what we do is
instead of making a call to Class A we
make a call to Class B and Class B
internally makes a call to Class A but
then it also adds some additional
functionalities and this is something
that spring is doing behind the scenes
for us actually it's not just spring I
have made another tutorial in hibernate
series where I talk about hibernate uses
a proxy object in order to get dynamic
fetching of data so spring is one of the
frameworks that used
and we'll have a look at how spring
manages to implement all these different
features using a proxy object so I'm
going to write and demonstrate some code
now and looking at that code should give
us a good understanding of what's
happening behind the scenes when it
comes to spring AOP so let's look at
this get beam we are doing a context dot
get beam and the context is behaving as
a beam factory so we give the
information about one beam we want and
then the gate beam method is going to
give us an instance of that beam now
let's say we have to implement a factory
object now how would it work what would
we have to do to implement a gate beam
of our own factory service let's quickly
try creating a factory service class or
call this factory service and now let's
say I have a public object gate being so
1/2 my own gate beam method that returns
an object so what would this gate beam
have to do now let's say I have a string
input argument I have a beam type that
takes information about what is the beam
that we're actually looking for and it
returns an object an initialized beam
now I could looking at the beam type
create a new beam so let's say I have
only a shape service and you now have a
circle and a triangle now it could be as
simple as a very primitive
implementation if beam type dot equals
shape service return new ship service
it's as simple as that now I'm just
looking at this all hard-coded here a
true object Factory would not be
hard-coded but just to be just to show
this as an example now I will check if
the shape service is the beam that's
being requested I would create a new
instance of the shape service and then
of course I'll check for circle say now
if the name of the beam a circle of
create a new circle beam and if the
Nima's triangle add create a new
triangle of course I'll have to import
these two and then since I'm returning
an object I'll return null here just to
keep the compiler happy but you know I I
plan to use only one of these three
strings in my example search it should
return an instance of these three
classes now away an actual factory
woodworkers instead of hard-coding these
values will probably look it up from a
configuration file or some other
configuration for our example this
should serve the purpose so depending on
whatever string I'm going to pass it's
going to return an instance of each of
these classes so we save this and all
I'll do is instead of using the
application context get beam I'm going
to create a factory service instance and
I'm going to use that to get a beam
become in these two lines of code here
so I'll say factory service
equals new factory service and then over
here shape service shape service is
instead of using the context I'm going
to use the factory service get B and I'm
going to pass shape service now this
will return me an object so I need to
cast it gas into a shape service now if
I do a shape service dot circle it will
run a good circle on a newly
instantiated beam called shape service
that it's returning from the factory and
I'll just add a line of code to the get
circle in order to print something out
so you can see that running so go get a
called now if I save and run this you
will see that the Gator has been called
now what we are seeing here is an
instantiation of an object that we have
done ourselves we are not using spring
so none of the you know the spring XML
or the aspects
none of these are coming into play here
it's our own factory service which
initializing a bean and then we are
calling a method of that bean and that's
it believe it or not we have an
implementation of a factory service well
it's very simple and then we have
hard-coded the instantiation but then
there you go this is it this is all it
takes to create a factory service you
just have to move these instantiations
and configurations to a separate file
and you have a pretty much full-fledged
factory bean now having implemented a
factory service we'll have a look at a
primitive implementation of aspect
oriented programming here now let's say
I have
a good circle as a target method and I
want a separate method an aspect method
say to be called whenever a get circle
needs to be done now how would I do that
in my primitive implementation of a
factory being now let's say I have a
separate class over here and let me use
the same class this is this after all
just a plain mean we don't have any
aspects over here now let's say I have
public void logging advice then level 2
versus out logging from the advice ok so
just this is a plain java method inside
a simple java class now I want the
slogging advice to be executed whenever
I run a get circle on my shape service
that I've got from the factory service
how would I do that
well the way spring works is by creating
a proxy object so let's try creating a
proxy object over here now I know that
the the beam that I need to pass back
whenever a get beam of shape services
called has to be of type shape service
because I'm casting it to shape service
and I'm assigning it to a local variable
over here so the return type of this
gate beam shape service has to be of
type shape service so what I do is to
add extra functionality instead of
returning an instance of this class
shape service I extend this class and
then I return an instance of that
subclass which will be an extension of
the shape service class now I'll just
implement it so they'll get simple so
what this actually means is I need to
create a new class that extends this
shape service class now I call this
shape service proxy and this has a
superclass as
shape service and finish okay so what I
do is instead of returning an instance
of shape service at a turn an instance
off the shape service proxy now let's
change that over here edit an instance
of the shapes of ass proxy and now
without doing anything without doing any
without adding any code over here then
what happens if I execute this in a word
if I get the shape service proxy but I'm
casting into a shape service and I'm
putting it into a variable here and I'm
calling a get circle now what happens it
still calls the same method because I
have not ordered in any methods over
here now even if I were write a method
over here let's say I override the get
circle from the shape service let's say
I write this but what I do is I do not
add any code over here I just refer to
the super so I'll say return super dot
get circle
so while I'm doing this I'm just saying
hey I'm not going to implement any code
over here all I'm doing is I'm calling
the gate circle of the super which is
the shape service get circle okay so now
what happens if I don this it is still
the same so what I'm doing here
effectively is I'm giving a proxy class
as a return to the main the main does
not know what the main things that it is
a shape service and that's all it cares
about it just needs to execute a method
of the shape service so instead of
returning an instance of the shape
service what I do is I create a proxy
class and then the method of the proxy
class just calls the super so it's it
behaves as a shape service it's
disguised as a shape service but it does
not shape service it's a new
class and I'm creating an instance of
that in my in my factory so this is
essentially what spring AOP does now you
might ask what is the advantage of doing
this why not pass the shape service
itself what's what's the fun in creating
a new class and then getting an instance
of that class to return and not the
original class well the beauty of this
is since I have a new method here I can
actually make additional calls before I
call the target method now this is
similar to what we saw in the around
right we had a new method and then I
could call the target method whenever I
wanted and then I could write code above
or below whether you can do pretty much
the same thing over here now I have one
line of code in data in this method
which calls the actual get circle this
is what calls the actual get circle not
this I'm just calling the get circle of
the proxy here so what we can do is here
I can actually make a call to my login
advice do that here I call logging
advice off the logging aspects let me
introduce that new logging aspect start
logging advice I will import this now
what's going to happen now from the main
I'm saying get been off the shape
service what the factory service does is
it returns the shape service proxy which
is this guy over here now when I do a
get circle what gets called is the get
circle of the shapes you know the shape
service proxy and I make a call to the
logging advice on this proxy and then I
do a get circle so this is effectively
doing or before advice so this acts as a
before so this gets executed before the
actual coil to the target method
and every time you run a gait circle to
this shape service which is actually a
proxy every time we run a gait circle
you can be sure that this method is
going to run the gait circle of the
proxy is going to run and then the
logging advice is going on every time
you run this gait circle so let's test
that out here you can see the logging is
run and then the actual target method is
run so this is our own implementation of
before advice so you can see how simple
is of course we have taken away a lot of
the intricacies this actually happens
dynamically in spring but then here we
have to statically write the code but
then this this whole exercise is to give
an idea about how spring actually man
uses it behind the scenes there's a lot
of good material available in books as
well as in the official spring
documentation that explains these
concepts in theory it explains about
proxy objects in Howard encapsulates the
actual target method of the actual
object and after going through this
tutorial actually looking at our own
simple implementation of a factory bean
that returns a proxy object
I hope the concept is clear about how
spring implements aspect-oriented
programming using these proxy objects</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>