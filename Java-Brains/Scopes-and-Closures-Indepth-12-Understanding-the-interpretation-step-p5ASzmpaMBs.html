<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 12 - Understanding the interpretation step | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 12 - Understanding the interpretation step - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 12 - Understanding the interpretation step</b></h2><h5 class="post__date">2016-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p5ASzmpaMBs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now let's look at the execution phase
and see how the compliation step and the
work that it does leads to the execution
phase so I'd like to think of the
combined ation step is more like a like
an accounting or bookkeeping step where
the compiler kind of makes a record of
all the variables that are being used
and where they're being used and all
that information is ready for the
execution step to use and the execution
step doesn't really look at the VARs
okay it just looks at what it needs to
do
there's no declaration that it that is
applied the execution step the execution
step execute it act so for instance in
this line if the compiler ation step is
looking at this part of the core and
registering the variables the execution
step is going to look at this part okay
the other part so it's not going to
worry about the VARs and declarations
it's going to see what it needs to do
and it's going to do it now when it
needs to find what variables to use it
actually looks at the scope chain that
was created during the compliation step
we looked at how different scopes and
different variables are registered in
those different scopes now the execution
step is going to look at that in order
to identify what variables to use then
all right so let's run through the
execution step now we're going to play
the role of the execution process and we
look at how it handles this piece of
code this is a code that we've seen in
the previous video this is the scope
chain for this code now let's look at
what the execution set does when an
execution step executes something when
it sees a statement like this what it
has to do is obviously take this string
value and assign it to this variable now
which variable of which scope does it
assign to okay so in order to do that it
looks at the bookkeeping that the
compliation step is already done now
this statement is being executed in the
global scope so what's going to do what
it's going to do is it's going to look
at the global scope in the scope chain
and say hey global scope do you have
variable with the name my name okay so
it's going to check the global scope for
it and now we see that there is a my
name registered in the global scope so
it's going to get bad and it's going to
assign this hard-coded string to it all
right now there is this function
declaration and there's nothing that
happens over here now this line gets
executed this line calls greet
my name now this is available and this
is available now again this is something
that it needs to access from the global
scope because remember even in line 7
the execution context is still at the
global scope right it's not inside a
function so now the interpreter is going
to check the global scope to see if
there's a variable called grid and it
does find it so it's going to use that
that variable which happens to be this
function declaration now the next
variable that it needs taxes is my name
now again since this is still the global
scope it's going to check the global
scope for a variable register with my
name and sure enough it finds that it's
registered in the global scope now it
gets that variable and it calls the
first variable which is a function and
passes in the second video bill which is
the argument right it has found those
two variables now when this function is
called it executes that right so now
here we have an assignment we talked
about this there is an implicit
assignment here where the name variable
is assigned to the value that is passed
toward the value we know is Kaushik now
what this does is it again has to do the
assignment because it's interpreter
right it acts so it has to do the
assignment and now this assignment is
inside the scope of the greet function
okay so it has to take something and
assign it to the variable called name
now HX hey greet scope do you have a
variable called name and now it finds
the variable name inside the scope of
creed no it gets that and it assigns the
value Kaushik to it because that's
what's passed to this function and up
here it has to execute console.log hello
last name all right so now this is
actually an object reference okay so
there is a global object called console
which is what which is why all of our
console dead logs and all of our code
works so it's gonna check the greet
scope and say hey greet do you have a
variable called console declared in your
scope now the grid scope does not have
it because you see here there is nothing
declared on the grid scope with the name
of console so what it does is it
actually goes one level up it checks the
global scope and that's how the scope
hierarchy works if if the interpreter
does not find something which is in that
scope off the function it goes one level
up and checks if it's there and if it's
not there it goes one level up and it
keeps going till it hits the globe
scope in our case here in order to find
console it checks the great scope it
does not find it
the next scope itself is the global
scope so it checks a global scope do you
have a variable called console but turns
out even though we don't have it
registered in our function our code
right so this code has resulted in this
scope chain and we don't have that
register but there is this cope you know
there is this variable called console in
the global scope because that's a part
of the JavaScript runtime so it gets
that console object because that's
available in all whichever strip runs
right so now that console object has a
dot log method now we're going to call
this and it's going to pass in this
string plus name now here you go another
variable reference it has to resolve
this variable right the interpreter test
results variables now again this is
inside the scope of greet now it's
checks the greet scope to see if there's
a variable with the name name and sure
enough it finds out it was the same
readability access before but it does
the check anyway every time it makes a
check to make sure that it's referring
to the right way table now it checks the
greet scope and it finds the variable
called name so it gets the value which
happens to be Kaushik and all it adds
these two up hello kochak and it sends
that string to the console that log and
now this function ends and the program
execution it's okay so this is what's
happening in the interpretation step of
this program's execution so again think
of the execution as a two-phase thing
the first step is the compilation step
where these scope chains are created
right so there is variables being
declared and each variable goes and sits
into one of these scopes in the scope
chain and then you have the
interpretation step where it gets those
variables by referring to the scope
chain it interrogates the scope chains
for the scope that it's trying to
resolve the readable far and then it
uses those variables depending on what's
available in the scope chain and if
available it needs is not in the scope
that it's trying to use it goes one
level up the scope chain and checks
again and it if it doesn't find it at
kingo's one level up and so on till it
goes all the way to the global scope all
right now the question is what happens
if it does not find it in the global
scope we have kind of looked at this but
let's revisit this with our knowledge
of the scope chain in the next video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>