<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate Tutorial 23 - Understanding State Changes | Coder Coacher - Coaching Coders</title><meta content="Hibernate Tutorial 23 - Understanding State Changes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hibernate Tutorial 23 - Understanding State Changes</b></h2><h5 class="post__date">2011-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sjZGFHEdD4M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we learned about three object states in
our previous tutorial we learned what is
a transient object what is a persistent
object and what is a detached object and
we learned when an object goes from
being a transient to persistent and from
being persistent to detached and all of
this has to do with how the object is
being treated by hibernate when we do
not have an object that's associated
with hibernate when happen it is not
tracking a particular object it's just
transient so as soon as you have a new
object it remains a transient unless you
do something about it now once you
assign that object to hibernate and ask
hibernate to save that object then it
becomes a persistent object and when the
object is in the persistence stage then
hibernate is going to track the changes
to this object and it's going to save
the changes to the database and once the
session is closed the object becomes a
detached object so whatever changes
happen to the subject is not tracked by
hibernate a couple of tutorials back we
looked at crud operations using
hibernate we had create read update and
delete operations being done using
objects and using the hibernate EP ice
now what was happening behind the scenes
was that our object or entity objects
were actually going through all these
different states so what are we going to
do now is we're going to look at how the
states you know change from you know one
state to another as we perform these
different operations so that we'll have
a better understanding of these three
states now let's start with the create
we did a new object we had a user
details object so we need a new user
detail object and the moment we did new
the object that was created was in a
transient State we had not asked
hibernate to save it now when we do a
session dot save the same object becomes
a persistent object now once we are in
this persistent object hibernate will
keep track of the changes and then it
will update the database accordingly and
once we are done with our action we do a
session
our clothes and the moment we do a
session door closed it moves from being
a persistent to a detached okay
so this is the flow for a create the
example that we saw in our previous
tutorial next take a look at a read now
for a read we do not do a new okay we do
a session get and we get the object
depending on the value that hibernate is
you know depending on the primary key
that we passed or hibernate prior you
know hibernate pulls up the actual
record from the database and then it
gives us the object itself
now the object that hibernate gives us
as we do a session or gate is a
persistent object so by default the
object goes into a persistent state now
I can do a session or gate and get any
object depending on the primary key I
specify and once I have that object I
can make changes to that object and
hibernate is automatically going to
update the database depending on the
changes we also did a session rod update
in that tutorial which is not really
required by default the values that we
update in are in the object that we've
got this persister automatically we're
going to look at the update the session
rod update it's a special scenario that
we're going to look at later but the
thing to note here is that the object is
persistent by default when we use the
session gate to retrieve the object you
don't have to do any updates as such the
you know when you modify the object
itself it gets updated to the database
so persistent it starts with persistent
and then when you do a session about
close it goes to a detach there's no
transient state here we can convert this
to a transient state we can look at that
in a minute but by default if you just
get the object it starts off being
persistent now let's look at the update
here now update is a little bit tricky
we can do an update either by a create
flow or by using the read flow if I you
know do an update using the create flow
I have a new object here and then it's
transient by default I cannot make any
updates here whenever I make an update
it's the object is not gonna bleep the
database but then I do a session god
save it becomes persistent but the
changes that I make here are going to go
into the database it's going to you know
it's going to get an update and then
it's going to be it's going to continue
the update until I do a session not
close then the same thing happens here
once I do a get I can do an update here
as long as the object is persistent it's
going to do with the update actions and
then once you do a session dot close
it's going to get detached so update can
happen in both of these ways in our
example tutorial we we did a read you
know we did a session gate and then we
did an update for that doesn't have to
be done that way you can also have a new
object persisted so that it gets saved
and then you can make changes to that
and it can it also automatically gets
updated because it goes into a
persistent state okay so now we have
seen create read and update now let's
have a look at delete delete as this
again has two floors
once your object is in a persistent
State of course this an object can be in
a persistent state either by using a new
and a session dot save or by using a get
and result in an object for the
persistence state now this persistent
object will go to our transient object
state when we do a session or delete now
why is it a transient because once you
do once you have a persistent object you
have a corresponding representative of
that object as required in the database
now when you do a delete the record in
the database is no longer going to be
there
so there's no point in having the object
as persistent because if you make a
chicken shear what is it gonna update it
doesn't have anything to update in the
database so what hibernate does is it
automatically converts this to our
transient state now I can do a session
dot save and convert this back to a
persistent in which case having it is
going to create that record form it's
the same as a scenario here either we
got this we got a new and we had an
object in the transient state but it
could as well be a persistent object
being deleted and moved to a transient
state so no matter how you get into a
transient state doing the session dot
save is going to convert a transient to
a persistent if it was a previously
deleted
record its going to insert and create a
new record so that you know I can have
an object in a persistent state and
updates can go through so that's one way
in which a persistent object can become
a transient again and then of course the
same thing that we've seen earlier a
persistent can become detached by her
session dot close okay so these are the
flows that we saw in a previous tutorial
the thing to note here is that you know
the change from transient to persistent
and the change from persistent rigid ash
is happening because of the section
involvement the transient object becomes
persistent once it's attached to the
session and the persistent object
becomes detached once it is removed from
the session now there's this one
particular scenario where you would want
to move an object from being in a
detached state to a persistent state
again which means that the object was
persistent somehow and then the session
which persisted the object was closed
and it became detached and now we want
to attach this object back to the
session and make it persistent again we
look at a use case when this might be
required</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>