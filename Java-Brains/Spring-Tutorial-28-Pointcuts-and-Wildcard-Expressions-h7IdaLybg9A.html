<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 28 - Pointcuts and Wildcard Expressions | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 28 - Pointcuts and Wildcard Expressions - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 28 - Pointcuts and Wildcard Expressions</b></h2><h5 class="post__date">2011-08-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/h7IdaLybg9A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial the last
tutorial was about writing an advice so
we wrote an advice method inside an
aspect and we use aspect oriented
programming to actually call this advice
code whenever a particular target method
is run so this is a very simple advice
and a very simple configuration here we
have a before annotation that tells
before which method this advice has to
run so we used this particular string in
order to configure that method which we
are interested in the target method now
we ended the tutorial with one
particular problem that I showed you we
have used this before annotation to make
this advice run before a public string
it name is called we originally intended
this advice to be called before the get
name of the circle class is called
but now what what's happening is since
we have not made any mention of the
circle class over here it's this advice
is running for every call to every
public string get name no matter where
it is even if it's in the triangle class
you know in the triangle we have a
public street name so even when this
method is called that advises call so
this is one problem that we will try to
correct we want to make this advisor not
only for a get name of a circle and this
is one of the things we look at other
ways in which we can configure this
particular definition of the target
method so in order to restrict this to a
particular class or a particular object
what we need to do is we need to provide
information about that class in this
string so we know that we want this
advice to get executed before the
execution of this method so in order to
make this restricted to a particular
class what we need to do is we need to
give the class name over here so since I
want this advice to run before a get
name off a circle class all I need to do
is before the getname method that I'm
writing
I need to write the name of the circle
class with the package name so this
would be org dot Koscheck Georgia our
brains dot model dot so cool duck it me
so all I'm doing this I'm specifying the
class for which this getname method
belongs to so that I can give more
information to spring about which give
name I'm actually interested in so now
that I have specified this spring is
going to look for this particular
pattern and it's going to match only if
a get name off the circle class with
this particular package is executed so
if a get name with the same signature
public string get name of another class
is executed like a triangle here this
will not run so let's quickly test that
out save this and let's run this class
now I'm calling shape service start get
circle target name now this advice has
to run so here you see circle name is
printed but the advice is run so now if
I change this to a triangle running the
get name for triangle ideally the advice
should not run and it does not it just
prints the triangle name but here even
though the gate name is run the advice
is not kicking in and executing this so
this is the way we can restrict the
method and you know the advice can be
applied only to particular methods that
we are actually interested in okay so
now that you've covered how we can
restrict this I'm going to show you two
different ways in which we can configure
this now the two scenarios that I'm
going to show you is what if you want
one particular advice to be applied to
different methods after that's the point
of an adviser's net we talked about
cross-cutting concerns and how one piece
of code that applies across different
points in the execution of your code
needs to be isolated
out so now that I've isolated a
cross-cutting concern I need to be able
to apply this cross-cutting concern
across different points and we look at a
way to do with that and the second thing
that I'm going to show you is the the
other way now say I have one particular
point in the execution of my code where
I want different advise methods to get
executed now how would I do that
so these two things are something to
build cover in this tutorial so let's
look at the first thing one advice
applied to different points in the
execution the way to do that is of
course you can replicate this say you
want another method so you want to apply
this for the triangle you can just
replicate this write another method and
then apply this just change this to
triangle then that would work but then
you are again you know duplicating the
code so the way to do this is by using
wildcards now we saw one way we actually
did it I mean we didn't we didn't intend
to do it but it actually happened now
this applied to all methods of the code
which have a public string gate name as
a signature so this is actually what
actually happened with an intent for
that to happen but we did implement an
advice method across different points in
the execution so as long as different
points in the execution of the code have
a public string get name one advice can
be applied to different methods in your
code now there are other reason which we
can configure it now let's say I want
this advice to be applied to all Gators
in the code no matter where they are we
have a get name here right so I have a
good name for a circle and I have a get
name for the triangle so this expression
is going to apply this advice to all
public string get names but let's say I
want this advice to be applied to all
get us whether it's a good name or a get
anything else I want this advice to be
applied so notice here in the shape
service I have a get circle another get
triangle now let's say I want this
advice to be applied to
as well so the way I can do that is by
using a wild card
now instead of specifying the gate Nemo
here what I'll do is I'll say get star
so what I'm saying here is get anything
so whatever be the method that starts
with a gate and then it has a public
string I want this to be applied so this
would work for all Gators that are done
a string but notice here in the shape
service I'm not returning a string so
the gate triangle is returning a
triangle and a good circle is returning
a circle so what I'll do is I'll remove
the string and I'll add an a star over
here as well so this is another wild
card so no matter any method if as long
as it starts with a get and it no matter
what it returns I'm putting a start here
so irrespective of the return type as
long as a method there is a public
method and it starts with the words G
with the letters G et I want this advice
to be applied so this is the same
expression but I've used wildcards here
so I can apply this advice across
different points now let's save this and
see what happens now the ideally what
should happen is this get star should
apply to a get circle get name so it
will happen twice so in my yupi get
triangle let me change this to a circle
and save this so now the get circle will
trigger the first coil to this aspect so
it is a public irrespective the return
type the method starts with GE t so the
first call is triggered and then a gift
name is called now again this satisfies
this expression it's a public key
respective the return type the method
starts with GE t so again it's going to
get called so now this single line of
code a shape service target circle dot
get name is going to return in two calls
this logging advice now let's see that
in action that you see you have two
coils so the first coil is for the gate
circle the second coil is for the gate
name now even if I change this to a
triangle it's going to result in the
same output because we have not
specified the class all we are saying is
any Kitter it respect to the return type
just make sure this advice is called so
we have to get us that our call here the
gate triangle and the gate name so again
this is going to result in two calls to
the advice so you can use different
permutations and combinations say you
want you don't you do not want to
specify the you know the whether it's a
public or a private you can just remove
this so what we are seeing is any return
type as long as it has a GED as the
first three letters of the method
execute this locking advice so there are
different ways in which we can specify
these wild cards you can specify a wild
card here as well so what we did earlier
was without this wild card what we are
saying is this method should not take
any parameters there are no arguments to
this method so that's what we have
denoted here by not specifying anything
over here but now let's say you have a
getter method which takes in an argument
and you want this advice to be applied
for that as well then what you do is you
specify a wild card over here so that
would mean that as long as there is an
argument some some argument then it's
going to get applied for all Gators that
have some argument now if you want this
advice to be applied for all Gators
irrespective whether they have arguments
or not then what you do is you add a dot
dot over here so a dot dot here means
that it can be zero arguments or it can
be any number of arguments it's going to
match this and the logging advice is
called so in summary what we do is you
specify star or the asterisks for any
any wild card
that you want to apply for either the
return type or the method name and as
far as the parameters are concerned you
apply the dot dot expression for any
match of you know zero or more arguments
and you apply a star for one or more
arguments and if you remove this you
just have open close that means that
you're matching for zero arguments so
this is this gives you a lot of
flexibility actually you can mix and
match this to catch a lot of signatures
and specifically apply for the other
points that you are actually interested
in so this is the weight in which you
can apply single advise methods to
different points in the execution of
your code and of course you can use the
you know the package name to get more
control so he can go say I have org the
cross shape dot Java brain started model
dot star dot get started so what I'm
doing is I'm saying all classes inside
this modal package then a method that
starts with the gate so you can you can
mix and match this so you can you know
get complete control over what methods
you're actually interested in and for
what methods this advice has to apply ok
so now lets me remove this okay so now
we have looked at ways in which we can
apply a single advice to multiple points
in the execution now what if you know we
are looking at the other way now you
have one point in the execution of your
code anyone multiple pieces of advice to
get executed one way we can do this is
again by using different methods and
repeating this expression now let's say
for all Gators I want a logging advice
to get executed and I want one more
advice to get excreta let me at that
public void let's say second advice
so I'll again print something out second
advice is executed now I want these two
advised methods to get executed on all
Gators so it's very simple all I need to
do is I need to copy this and biggest
this here right so it's going to happen
both these methods are going to get
executed for all the execution of all
the methods that match these patterns
but if you have a lot of methods like
this you will be repeating this
expression now this is a very simple
expression but let's say it's fairly
complex you have specified the package
name the return type and a whole lot of
configuration if you had if you have a
lot of methods a lot of advice methods
then you would have to repeat this
expression and you have to repeat this
before annotation for all those methods
now there is a shortcut for this now the
way you can do this is by defining what
are called as point cuts point cut is
AUP terminology again for all the points
in the execution of your code where you
want this advise method to cut in so the
point where you want the method to cut
in there's a point cut so this star get
star of no arguments is a point cut for
second advice the same way this is a
point cut for the logging advice so what
we can do is since you have the same
pointer that are being used by two
different advise methods what you can do
is you can define a point cut separately
and put this expression over here and
then when you are configuring your
advice you just say hey I already
defined a point cut over there so that's
where you want this advice to run and
again through the same thing you can
just refer to that point cut and then
that point cut will have this expression
you don't have to put this expression on
all your advice methods so let's do that
now
I'll define a point cut by using the ACT
point cut annotation that point cut
annotation takes an expression it's same
as the before it takes an expression
about where the actual point cut needs
to take place so I'll just copy this and
paste this over here so this is it's a
simple point cut that says on all
execution of all getters this point that
needs to be applied now I can't just
leave an annotation like this the
annotation has to annotate something so
what I'll do is I'll write a method over
here let's say all Gators now this is a
dummy method all Gators is a dummy
method it does not have any code inside
it but what this does is it holds a
point cut expression we see here this
point cut is applied to all Gators now
that I have defined this pointer over
here I don't have to use this expression
everywhere I want an advice to get
applied so I have this expression over
here and over here
logging advice and second advice I don't
have to put this expression over here
what I need to do is I need to say
before this all Gators what I'm saying
is he already have defined this point
get expression over here so that's what
I want this advice to use so all I do is
I'll change this expression to all
Gators
and even for this advice so this advice
you know is annotated with before of all
Gators so all that it does is it checks
for the all Gators method and it takes
this expression and the same thing for
the second advice so this saves you
typing as well as make sure that you
type your expression only once and then
you can use that expression across
different points so let's let's run this
now let's see what happens
so here you see this both these advisors
are executing twice so this is for the
first one is for the get triangular the
second one is for the get me and that's
happening because it's running for all
Gators now the all Gators has the
pattern that matches for the Gators and
now I do not have to use the pattern for
each and every advice I just refer to
this method which has the pointed
expression so this is the way in which
you can use a particular expression and
match multiple advice methods so so we
have looked at two ways in which you can
configure point get expressions one is
if you one the same advice to get
applied to different points and
different point cuts then all you do is
you use wildcards or you write your
expressions whether it matches different
points and then the second thing if you
want one particular point cut expression
to get applied to different advice
methods what what you do is you use a
point cut annotation and then annotate a
dummy method and then you can use a
dummy method as a reference for all your
before annotation so that no matter how
many advise methods you have those
advise methods will point to this point
get expression and then it's going to
apply just like you it's almost as if
you have used this expression in each of
your advice methods only thing is you're
just referring to one consolidated place
in which you have your point cut
expression</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>