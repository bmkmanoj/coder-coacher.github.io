<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate Tutorial 07 - Primary Keys | Coder Coacher - Coaching Coders</title><meta content="Hibernate Tutorial 07 - Primary Keys - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hibernate Tutorial 07 - Primary Keys</b></h2><h5 class="post__date">2011-05-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Xuofihmkl_k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this tutorial we're going to talk
about primary keys and what are the
different ways in which hibernate
provide support for primary keys we have
defined the primary key in our previous
tutorial itself I have actually
simplified the code here I've kind of
remote all the other properties I just
have the ID and the user name alone just
for simplicity so here we had already
defined this @id annotation to denote
this particular field as the primary key
and we had given the field a value of 1
and you know a simple user name in order
to you know fill that property value and
then we had saved that using hibernate
now what does this ad ID do first of all
it created a primary key column in the
table and it you know it created a
column for this user ID and then it
denoted it as a primary key and then you
can use this primary key for fetching
data that's again another thing we saw
in a previous tutorial we can pass the
value of the key to a session or gate
and then we can get the object itself
now we look at what are the other ways
in which hibernate supports primary keys
before we get into what hibernate
supports we'll have a quick discussion
about our natural vs. a surrogate key
what is a natural key and what is a
surrogate key let's say for example in
your application you have a column that
you know for sure has distinct values
and then you know for sure that it's
mandatory take for example a user
registration application and you have
people registering by giving out their
email address and the first and last
name all those details say your business
rule dictates that every user needs to
have an email ID and then every user has
to provide a distinct unique email ID
when they're registering you cannot have
duplicate email ids you cannot have two
different records that has the same
email ID so in that case we can have the
email
as a primary key so such columns which
actually are there for a business reason
but then you assign one of them to be
the primary key so such keys are called
natural keys the other option is to have
something called as a surrogate key in
which case you you don't know if any any
column can be marked as unique you don't
have a column that can be marked as
unique or you anticipate that it that
could change in the future so in that
case what you do is you add a new column
and the purpose of the column is to
entirely act as a primary key alone it
does not carry any business significance
but you need to have a separate column
just to have you know just for it act as
a key so in that case that's called as a
surrogate key it's kind of like having a
serial number column in front of a table
the serial number column does not serve
any other purpose does not get any data
apart from the fact that it's marking
out all the different rows as separate
and it has a unique number for each so
having these now that we have these two
types of primary Keys we look at how
hibernate supports each now what's the
key that we are using over here we have
something called as user ID and we have
a user name now if the user ID is
specifically for the purpose of
declaring a primary key and then it does
not have a business use then yes this
would be a surrogate key but if it has a
business use or you know it's a login ID
for example and you're making making a
login ID as a primary key then that
would be a natural key because a login
ID is also used for other purposes like
a syndication and stuff so if we are
having a natural key it would make sense
for us to provide the value because it's
up there is the significance we need to
know what the value is and we need to be
able to control it but if it's a
surrogate key then we can ask hibernate
to do the job for us because it really
doesn't matter for us what the value is
going to be you know it for as far as we
know it can be the you know the
value plus one that would work as well
but we just need to make sure that it's
it just has to be it just has to be
unique and it has to be mandatory it you
know it cannot be optional cannot be
null so these two things are something
that happen it can manage for us we can
tell hibernate to generate a set of gate
key for us whenever we using such a
surrogate key say for example this user
ID happens to be a surrogate key I've
just in say you know added this value
here but I don't need it for any of the
reason apart from using it as an ID so
in that case we can ask hibernate to
generate this value for us every time we
do an insert I don't have to be I don't
have to create this ID every time I
don't have to pass it to hibernate
hibernate can automatically generate and
manage the newly created objects keys so
say I have to insert a new user all I
have to do is to set the username and
then hibernate will take care of
creating the right user ID for me now if
I had to supply the surrogate keep
myself then what would I have to do what
I have to first look up what is the last
surrogate key ID that I know that was
created the probably we have 500 users
and the last user ID that was inserted
was 500 so I will have to add one to it
and then insert user ID 5:01 so this is
something that I would have to do if I
use hibernates help hibernate will do
that work and it will generate a primary
key for me so I can use that
functionality of hibernate by specifying
another annotation here called ad
generated value what ad generated value
means is it's asking hibernate to
generate this value for me I am not
going to generate this myself now
hibernate is going to look at the data
type of this property it's an integer so
it's going to generate a new integer for
me and then it's gonna add that value so
now I don't have to pass user ID value
I'm just going to set the username and
then when I do a save it's going to save
the value so just to demonstrate that
let me add one more object here call
this user two and let's say you use a to
dot set user name second user and I'll
save both of them I'll save session dot
save user to okay save and run this so
there you can see it has inserted these
two values but notice what's happening
here it's done a next Val of hibernate
sequence so what's happening is
hibernate is maintaining a sequence
internally and it's generating the user
ID depending on the sequence it just
gets the next value of the sequence and
then uses that next value to insert the
user ID this was not happening before
because we used to pass the user ID but
now that we have market as a generated
value hibernate is getting this value
from the sequence and then it's
inserting it now let's test the data
there you go user ID 1 &amp;amp; 2 has been
inserted with first user and second user
now this generated value is has
something called as a strategy so there
is this configuration called strategy
equals now here you can see there are 4
values here belonging to the generation
type enumeration we have Auto identity
sequence and table now what's happening
if you do not specify any strategy
is that it's going for strategy as
generation type Auto now what is this
Auto generation type it just means that
we will let hibernate make a decision as
to what is the strategy it needs to use
in order to come up with these unique
primary keys now you can have more
control over this
you can specify one of these other
options here so the other options being
identity sequence and table so identity
means that it's going to use hibernate
is going to use identity columns and
it's going to generate that now what is
identity column it's a feature which
provided in some of the data pieces it's
not a gender acquits available in all
the databases I believe sequel server
and MySQL I could be wrong but I think
those two databases provide this
identity column features so if you are
using one of those databases you can you
can say generation type as identity in
which case hibernate is going to use
that feature of the database in order to
come up with the unique primary keys
sequence is something you know it's
called as sequence high low in hibernate
so sequence has it uses the sequence
object in the database in order to come
up with unique I think that's what's
happening here
it's using a hibernate sequence object
the sequence object is something that
you can have in the database in order to
maintain sequences and you can use that
you can add sequence you can when you
say an ex Val it automatically pulls up
the next value and then updates a
sequence so that subsequent next Val's
pull up the next data so it's something
that databases manage by themselves and
you can use sequence to come up with
unique unique values for the primary key
table is another option you can have a
separate table and that table will have
record of what is the last use primary
key so that you can increment it and get
the next value so again if you use the
stable option high beneath is going to
create a separate table and use that for
generating the primary
so most of these depend on the database
that you are using so Auto is the
recommended option if you use generation
type ler Auto that means that it you
know you're going to leave it to
hibernate to make the best decision
depending on the database that you are
connecting to</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>