<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SOAP Web Services 19 - Using Endpoint | Coder Coacher - Coaching Coders</title><meta content="SOAP Web Services 19 - Using Endpoint - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SOAP Web Services 19 - Using Endpoint</b></h2><h5 class="post__date">2014-01-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ExGgevg3i94" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so far in this course we have written
web services and deployed it the
GlassFish application server so we've
created web applications with certain
classes which have the web service
annotation so we annotated let's take
the product catalog class we annotated
it with add web service and deploy this
application on glass fish and glass fish
notice that this is a web service
thanks to this annotation and it
published the web service so this is
ideal in a food production mode you
would use a Java EE application server
in order to deploy your web services but
there is one handy way to test web
services in development environment
without having to depend on GlassFish so
when you're writing code when you're
testing out different scenarios and
you're making frequent changes it is a
bit of an inconvenience to deploy it to
GlassFish every time because it takes a
little bit of time to have it apply and
have the web service published so there
is one quick way to do this without
having to use GlassFish and actually we
don't even need any external server at
all so Java provides support for web
services in JDK itself we don't need
Java EE so if all you have is the JDK
set up in your development environment
you are actually all set to publish web
services so that's what we're going to
take a look at in this tutorial so the
way to publish web services without
having to depend on any external web or
application server is by coding it so
I'm going to create a new class I'm
going to right click on the package new
Java class and I'm going to call this
test Mart
publisher and I'm going to have a main
method in it simple Java class and in
this Java class I'm going to actually
write code to publish the web service if
that sounds scary don't worry it's
actually fairly simple so all I need to
do is use a class called endpoint so
there's endpoint class is from Java x XM
l WS package right so I'm going to use
this class and this class has a publish
method it actually has an overloaded
publish method I'm going to use this one
which has two arguments one is string
address and the object implementer okay
so I'm going to use this so the publish
method takes in the first argument as
the address where you want the web
service to be published so I'm going to
choose the address HTTP localhost
because it's local to my machine I'm in
the development mode anyway so I'm going
to be the only person using this so I'm
going to choose localhost and actually
let me change this so the port here has
to be something that's not currently
used so we know that 8080 is a POC is a
common port I might run another server
later which would need the port 8080 so
I'm going to use a port which is not
currently in use or it's not something
that I would do is later so any port
which is not likely to be used should
work I'm going to use port one two three
four and I'm going to give a name to my
web service so I'm going to call this
product catalog right so it's a name in
the URL so I'm basically specifying the
URL where I want the web service to be
published so this is the first argument
to the endpoint or publish method the
second argument is an instance of the
class that is the web service so here
there is the class which implements the
web service interface and it has the web
service annotation so it needs an
instance of a class like this I'm going
to create an instance of the product
catalog class and pass it here so I'm
going to say new
product catalog and believe it or not
this is all it takes so I can actually
save this and run this main method as a
java application
well that's it now I can access this URL
so let me copy this URL here and access
it in a browser
and here you can see that there is a
page that's created the service name the
address is given over here and there's a
link for the Vista I can click on this
link and here you see the Vista and all
its glory has been auto-generated so
this is pretty much the same as what we
saw in glass fresh right without of
course the whole cycle of deploying the
application to GlassFish so we were able
to do this just by running a program now
the question is who's doing all this
work so far we've been talking about
GlassFish publishing the web service
right we create web services just by
deploying an application to GlassFish
and just we conveniently said yes it's a
glassfish doing all the work but i think
now is a good time to think about who is
actually doing the work since we're able
to achieve this without even involving
GlassFish in the picture so the jax-ws
standard that we've been learning so far
has been just that it's a standard so we
learned about these annotations we
learned about all these attributes to
the annotations the whole lot of stuff
that we can do and have the web service
work without really coding anything
related to web service we just annotated
stuff and that was pretty much it so the
jax-ws standard tells us what
annotations we need to do right it tells
us that an annotation call web service
has to be over here the you know the
property call endpoint interface has to
be here so it's a standard it tells us
the standard way to write web services
but then there is actually something
else entirely that does the work there
is code which looks at this which looks
at your web service looks at these
annotations make sure that they're all
following the standard and if they're
following the standard that code
actually does the work of publishing the
web service right so that cord is
actually
while the implementation of the standard
so Jax Tobias is a standard it provides
guidelines for us to write web services
and then there is this other part of it
which is the actual implementation which
takes the code that we have written
following the standard and then it
actually does the work of publishing the
web service so there are a lot of web
service implementations and one of the
standard implementation is called Metro
so Metro is what is called a reference
implementation so that is an
implementation that strictly follows the
standard so as long as you have written
code that follows the jax-ws standard
you can use Metro to publish your web
service right so the Metro is actually
the thing that does all the work
so Metro is a reference implementation
that comes bundled with GlassFish which
is why the code that we write following
the jacks tabria standard can be
deployed in GlassFish so it's not really
GlassFish doing the work
it's Metro that's bundled inside
GlassFish which is actually doing the
work
so Metro looks at this class Metro sees
that there's a web servers and metro
publishes the web service so it's
actually a different project it's a
reference implementation but it's
bundled with GlassFish so we don't
really bother about it we just deploy
the application and GlassFish and then
let it do its work so interestingly
enough Metro also comes bundled with the
JDK which is why we are able to do this
we are able to do an endpoint that
publish and then it's Metro which does
the actual publish so if you notice here
the console's is Metro monitoring root
name successfully and if you look at the
Vista as well you see here in the in the
comments you see the name Metro come up
and this is the same thing with the
visitors that class position routes as
well so even in that visual you can see
the garments should have something
called Metro because it's basically the
same thing that does that's doing the
work okay and this is what makes you
know if I send soap requests to this
and point we do get a sope response
because it's actually Metro which makes
a call to this to the right method and
gets the right return type and then
converts it to XML and does all the hard
work so that should explain how we are
able to publish a web service without
having to use GlassFish so there are
some limitations to this though by
default the at least the way I've done
it so this is actually a single thread
model so when I make a soap request to
this now for a web service that's using
endpoint or publish there's only one
thread that can execute at a time so if
I have one request that goes in and the
web service is executing and another
request goes in in the meantime
then the second request has to wait for
the first request to complete so it's
actually single threaded it's fine
because the use case for this is
basically a development environment a
developer while developing the code can
use this right so we don't really need
multiple threads there are ways to make
it work but I'm not going to go into
that in this tutorial but if you use
GlassFish to publish the web service you
get multiple threads it's you can pretty
much run a production environment on a
class fashion should be fine but if
you're using this of using in pointer
publish it's not recommended for the
production scenario it's something that
you would use just for development so
this is how you publish web services
just by running this one line and when
you're done just hit stop so that the
program stops and now this web service
is not accessible anymore right so this
is a very simple way it's kind of a
shortcut to publish web services fairly
quickly and to test out different
different code when you're developing
you don't really need GlassFish for it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>