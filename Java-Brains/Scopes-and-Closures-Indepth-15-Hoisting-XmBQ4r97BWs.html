<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 15 - Hoisting | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 15 - Hoisting - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 15 - Hoisting</b></h2><h5 class="post__date">2016-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XmBQ4r97BWs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this tutorial I'm going to talk about
the concept of hoisting in JavaScript
hoisting is a concept in the JavaScript
programming language and people then do
get confused too much about what it is
and what it does but with the knowledge
that we have about the compliation and
in the interpretation step the concept
of hoisting should become self-evident
now that you've seen those tutorials
once I explain the concept of I sing to
you you'll be like oh yeah I already
knew that so hopefully it's not going to
be too much of a new thing considering
what we've just covered the idea of
hoisting is that whenever you'd write
variable declarations in JavaScript it's
almost as if when the interpreter runs
the variable declarations are hoisted to
the top let's move to the top and it
kind of feels that way because of the
two-step process that the compiler and
the interpreter goes through first the
compiler looks at just the worst and
then the interpreter executes whatever
the wires are doing so it almost feels
like all the world declarations are kind
of heisted to the very top and then
whatever code you write with those
variables executes so no matter how if
you've written the code for the worse
it's almost as if it always goes to the
top so let me explain what I mean by
that so let's say I have a variable a
assigned a value 10 so it's an
undeclared variable at this point let's
say I have a console that log of B and
then I have C++ we're basically using
three variables here or the first line
uses the variable a and it's a write
operation on e the second line uses a
variable B and it's a read operation on
D the third line uses the variable C and
it's both a right and a read operation
because C++ basically takes the value of
C adds one to it and then assigns it
back to C so I have read and write
operations in these three variables but
I haven't declared them yet okay so at
this point of time they're undeclared
free tables let's say I declare them
after I do all this stuff right so let's
say I have a bar a or b and a VAR c over
here so the point of high string is that
it really doesn't matter that you have
the bar ABC declared at the very bottom
since the whole execution is a two-step
process and the compiler is the first
step the compliation is the first step
it gets to this war's first anyway it's
gonna skip through this part and it's
going to get to the Wars anyway so it's
almost as if you had the wars at the
very top for the compiler to run and
then after the wars are processed only
then would the interpreter step run and
process these things so the idea is it
doesn't matter where you declare the
wars it's always almost as if it's
heisted to the top that's the whole
concept of hoisting we've looked at
examples before where you add a bar
after you've used it and it still works
because the compiler gets to the war's
first anyway so this has this works for
both functions as well as variables let
me give you an example of a function
let's say I have a function my F in 1
and I have some logic over here but now
let's say I call my F in one before the
function is declared this still works
fine because this is something that the
compiler interprets right the compiler
says okay I've got this function so it's
going to take that and create it on the
scope we've seen it at the moment it
sees this function declaration there is
a my FN one created on the global scope
and so this function can execute even
though the function declaration is below
this is especially important when you're
dealing with recursive functions with
two or more functions so what what does
recursion look like in case you're not
familiar the cursor function is when a
function calls itself so let's say I
have a function whicker's and then
somewhere inside I call it a curse
alright so this is a recursive function
this of course has to be inside some
condition so that this doesn't keep
calling itself for eternity but there is
some kind of a condition which makes it
break but with the condition you can
actually have a valid business logic in
a recursive function this is okay but
now you can have recursion with multiple
functions so the way you can have the
question with multiple functions is lets
you have functioning in a function be a
function a calls B &amp;amp; B calls a you
essentially have a recursive function
with two functions so let's say I have a
function f and a and then inside this
somewhere I call F and B
okay and then I have a function f and B
which calls
FN a now this could be a valid reason to
implement functions this way and now you
see there has been an inter link between
two functions he calls B and because hey
now which one would you need to declare
first if you cannot declare a before B
because b calls a and you cannot declare
be before a because a calls B right so
this is an important reason why you
wouldn't need some kind of readable
hoisting so when you write code like
this it really doesn't matter which
order in which you do it because the
declaration all this happens first
because of the compliation step that
runs first so it really doesn't matter
which order you run it if the order
mattered the second function could call
the first function but the first
function could never have called the
second function that gets declared after
it right no matter how we switch it
whatever is the first function could not
have called within itself the second
function because the declaration follows
so this is where function hoisting helps
it doesn't matter which order you run it
it's almost as if function a and
function B are the declaration is
heisted to the very top and then the
execution always happens afterwards so
this is an important thing to remember
and also important to remember is that
this happens for function declarations
only doesn't happen for function
expressions we give you an example why
let's say I have a function here and
calling function e and let's say I'm
creating a function e here not as a
function declaration but as a function
expression so you bar F na equals have
an anonymous function over here now what
is going to happen well the compliation
step runs first what does it do it
ignores this line because there is no
new variable being created it comes to
line 5 it says it just looks at this
part right wire fna it creates a
variable called F any in the global
scope it doesn't know what type it is it
doesn't do the assignment because the
assignment is the job of the interpreter
so this creates an empty variable in the
global scope which has a value of
undefined obviously and now it says ok
and the compiler says ok I'm done now
interpreter you go ahead with your thing
but the interpreter tries to execute fna
and it is undefined so this is not going
to work so this works if it's a function
declaration right if I were to change
this to a function declaration then this
would work but it doesn't work if it's a
function expression because an
expression gets interpreted by the
interpreter it's not the compiler which
actually assigns the value so hopefully
this made sense a player on with it and
you know when you're looking at code
it's kind of obvious where function and
variable hoisting happens this is an
important concept to remember there is
always declaration hoisting in
JavaScript be it variables or functions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>