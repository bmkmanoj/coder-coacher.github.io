<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambda Basics 9 - Lambdas vs Interface Implementations | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambda Basics 9 - Lambdas vs Interface Implementations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambda Basics 9 - Lambdas vs Interface Implementations</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kpK2e343v48" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now I want to talk about the difference
between this thing here which is the
Halliwell greeting and this my lambda
function here both of them are off type
greeting right let me get rid of this
greet method or maybe put this way below
so look at these two lines line 13 and
line 14 line 13 is basically an instance
of a greeting interface which is a
custom class that we have written try to
give written the syllable greeting which
implements the leading interface line 14
is a land expression the surround
expression and we've learned that a type
of a lambda expression is basically an
interface that has a method of that type
so since this match is here we have of
titrating and the compiler is really
happy now the question is what's the
difference between this and this what's
the difference between hello well
greeting and let me change the name for
this thing lambda greeting right what
are they the same or are they different
hello while greeting is an instance of a
specific implementation which also
happens to do the exact same thing which
happens to print hello world so are they
the same now we know that we can do um
column method on top of lol greeting
called
perform and this should print hello
world to the console if I execute this
it's going to print hello well to the
console now let me try doing the same
thing for the lambda greeting if I were
to use this what's going to happen turns
out we still get hello well printer to
the console so what's happening is this
lambda expression is kind of behaving
like an implementation of this interface
what we have here is an actual function
so in a way we are implementing an
interface by just implementing the
function and not implementing a class
okay that was the difference here
between lines 13 and 14 in line 13 we
created a new class that implemented the
greeting interface and then we provided
the logic in that
however in line 14 be not creating a
class for it we're just creating a
function a lambda expression in line and
that is what's getting assigned to a
type greeting so it's almost as if we
have created an implementation of the
greeting interface now how can be sure
that it's not actually an implementation
well the thing is there are certain
things which make the lambda greeting
different from the halliwell greeting
and what those differences are we'll
have to look at it a little bit later
but trust me on that this is an instance
of a class that implements the greening
interface and this is a lambda
expression of type cleaning interface
that is a difference there
the difference is hard to find though
because if you think about it what we
did here in the hello world greeting we
don't really have to create a brand new
class we could have done what's
considered an anonymous inner class I
hope you're familiar with what what an
anonymous inner classes let me give you
an example let's say I create a new
greeting instance inner class greeting
and what this is going to do is it's not
going to create an instance of another
class it's going to create an inline
instance of the greeting with the
implementation being in line right here
so let's say I do this new greeting and
I'm going to define the implementation
right here so I have this public white
perform and then I'm going to do a print
inside this so what I have here is an
inline implementation of an interface
this is commonly referred to as an
anonymous inner class it's a class that
we are defining inside another class so
it's an inner class and it doesn't have
a name
so it's an anonymous inner class and
this one set of lines is actually doing
a couple of things it's creating an
implementation of creating which has
this method this is the code that needs
to run and then it's also creating a new
instance by
using a new and inert class greeting
variable is now containing that instance
so let's see what happens here if I were
to do an anonymous inner class greeting
that perform what is it going to display
but it's still going to do hello well so
we don't really need this let me
actually get rid of the hollow while
greeting so you have two types of
implementations over here one is the
lambda treating where you have the
lambda alone and then you have the inner
class greeting which is basically doing
all this stuff so it's very tempting to
say well what we're doing over here is
basically just syntactical sugar it's
basically another way of creating this
kind of an anonymous inner class because
that's what's happening right we're
creating an instance of greeting just
like we're doing over here it's just
that it's a fancy new shortcut in java 8
well for the most purposes you can think
of lambda expressions as a shortcut for
creating these kind of anonymous inner
classes but it's not exactly true
there are things that the inner class
'end does which is different from what
these lambda expressions do so it's not
exactly creating an anonymous inner
class we look at those differences in a
further tutorial but be careful of the
fact that you're looking at a completely
different thing I see a lot of online
tutorials which talk about lambdas
starting up as it being some kind of a
shortcut for doing anonymous inner
classes that is unfortunately not the
case lambda is its own thing and you'll
learn more about that later but for now
think of this as another way of doing
something like this instead of doing
this approach which is creating this
inner class and having an implementation
you create a lambda expression like this
and of this perform method doesn't have
to be over here I can pass either of
these to something like a Greek method
because it's of type greeting so any
function any method that already accepts
this interface works just fine the in
the in the method drill really doesn't
care about whether it's a lambda or an
inner class just to prove that I'm going
to call greeted greet for the
degrading and twittered greed for the
inner class squeaking and these two
lines should print to Allah Wells as it
does so I understand that what I'm doing
in this tutorial is telling you that
they both look very similar but I'm also
saying trust me they are not the same
I just wanted to contrast these two ways
of creating implementations of an
interface one is using something like
this another is creating a lambda
expression which happens to be off type
interface it's not really a way to
create an anonymous inner class and the
details are going to come much later</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>