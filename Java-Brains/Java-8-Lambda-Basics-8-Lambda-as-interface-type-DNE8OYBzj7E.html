<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambda Basics 8 - Lambda as interface type | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambda Basics 8 - Lambda as interface type - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambda Basics 8 - Lambda as interface type</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DNE8OYBzj7E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here's the code we've been looking at
in the previous couple of tutorials so
we have a grid method which takes in a
greeting interface and we had an
implementation of the greeting interface
called hello world reading which just
did system dot out dot print of hello
world and now the greeter can pass that
instance to the greet method and then
the greet method calls the perform on
that interface which means that the
implementations perform method runs now
we want to change this to a lambda
expression what we want to do is let's
say I call this my lambda function this
is going to be a lambda expression in
place off this implementation of the
greet the perform it so what I'm going
to do is go to greeter and write that
same thing as a lambda expression so
this is an expression that there's a
function that doesn't take in any
arguments so that's going to be empty
and then the body is system dorada print
off hello world and then end this with a
semicolon in the question that we were
struggling with is what's the type of
this variable it's a variable that
contains a lambda expression a lambda
function so what's the type is it a type
called function in Java 8 so let's say
there was is something like this right
function like you don't have this in
Java 8 but let's assume we had this well
this function type if it existed would
have had to provide all the inputs for
what this function is going to be like
it had to tell what the input argument
is what the return type is in this case
let's say it was something like this
right so input argument is void and then
they're done is also white this could
have word but the Java language
designers didn't really do this didn't
create a new type called function type
they actually said hey we have this
really nice system in Java to declare
functions declare methods and that's the
interface so they have reused the same
construct for declaring lambda
expressions as well so here's what you
need to do to create a new lambda
function type in Java first step create
a new interface right we are leveraging
the concept of interface in order to
declare lambda functions so in order to
declare this function the first thing
you need to do is to create create an
interface for it so let me go ahead and
create one interface my
lambda the name is not significant yet
we can give it any name you want but
this is the first step the second step
create one method in this interface
which has the exact same signature as
the lambda that you're trying to declare
so what's the signature of this lambda
here it's a function that takes in no
arguments and it returns are white so
you need to create a method here which
takes the exact same signature as that
so this would be a void and then I'm
clicking call this any name I want for
the function and we call this foo and it
doesn't take in any method arguments as
well so now I have an interface with one
method which has the exact same
signature as the lambda expression that
I'm trying to declare now I can use this
interface as the type of this lambda
function I'm reusing the type of this
interface for this lambda function so
what I can do is I can declare this
variable as of type my lambda and this
is it Java is happy Java says okay I
have all the information I need to
figure out what the type of this lambda
expression is it's going to go look at
this interface and you are pretty much
guaranteeing the Java compiler that it
has only one method it's going to look
at that method and it's going to say
okay I know exactly what this lambda
expression does it basically takes in no
arguments and it returns a wide
okay now this lets the compiler do the
type checking now I can have an
expression like this let's say I ate it
take an int I as an argument this is not
going to work because you see what they
error is it says the lambda expression
signature does not match the signature
of the functional interface method foo
so it's basically looking at this
interface method foo and it's saying
well the signature doesn't match so
that's basically what the Java compiler
is doing it's basically reusing the
concept of an interface to declare a
function expression a lambda expression
okay let's do one more example so let's
say I have the add function that we
looked at in the previous tutorial so I
have a function I have a lambda that
takes two integers and it returns the
sum of those two so let's say I call
this odd
function this is going to be a lambda
which takes in two integers into a and
then int B and the return is a plus B
what do I need to do to find the type
for this thing well I can create a new
interface that's the first step so I'm
going to create an interface called my
add and then that's the first step the
second step is to create a method in
this interface which has the exact same
signature as this lambda expression
what's the signature it takes two
integers and it returns an integer so
I'm going to make this an int add and it
takes in two integers again the name
doesn't matter I can call it int X and
int Y now I have an interface which
describes this lambda expression it has
a method which describes lambda
expression so I can take this type and I
can reuse this type far the lambda
expression as well now again if this
were to change now let's say I have an
int C this is not going to work because
it's going to say the signature doesn't
match see it's the same matter and
similarly if I were to change the
interface signature to say something
like this string s again this is going
to fail notice that the interface is
fine interface is just any arbitrary
interface with a method that you've
declared is just that when you are
applying it to a lambda expression the
compiler says well that's this is not
good we need an extra parameter and it
has to be a string now I can mix and
match these things and you can see the
error right away now if I were to make
this the second one on my lambda again
you can see an error because the
signature doesn't match but now think
about this for a minute I'm going to get
rid of this add now get rid of this I
can get rid of this now notice that I
told you that the interface name really
doesn't matter over here I can I call it
my lambda but I could've call it
something else and the method name here
doesn't matter I've called this foo but
I call this something else if you look
at this line the line where I have
declared this land expression all that
matters is a name of the interface
should be the same as the type so
whatever I'm calling here
I need to call this lambda expression
the exact same thing and the method
really doesn't matter now do you think
you have seen an interface like this
recently which is basically an interface
which has one method which takes in no
input arguments and it has a return type
as wide does this look familiar well
turns out we have already created an
interface for this which is the greeting
interface you see this this is an
interface which has a method called
perform which takes in no arguments and
it returns a white if all that matters
is that there needs to be an interface
with the method that matches the
signature can I use the greeting
interface for this lambda well the good
news is you can now if what if I call
this greeting well the compiler is still
happy because guess what the signature
of this lambda matches the signature of
this interface so the step one that I
talked about about creating an interface
is actually optional if you have an
interface which already matches this
well you are already set you can just
use that interface okay so I can
actually get rid of this interface you
don't need to create one we already have
one so my lambda function is of type
greeting over here now I can create a
hundred different interfaces like this
each of them having one method which has
a wide method name with no arguments and
I can choose any of those interfaces for
this lambda expression all that the
compiler needs is to make sure that this
type matches the type off the method
inside that interface now here's another
thing that I could potentially do let's
say I add a method over here let's say I
add the add method right so let's say I
do an int add int a and then in B well
this is a perfectly reasonable thing to
do I can add as many methods as I want
inside this interface but now guess what
happens when I switch back to this thing
you see here now it's going to give me
an error the target type of this
expression must be a functional
interface I'm going to cover what a
functional interface is later but the
idea is of the compiler is confused the
compiler is basically saying hey
developer I know you're asking me to
check out this interface to figure out
what the signature of this method is but
when I go see that interface there's not
one method actually two methods now I
don't know if you meant to create a
lambda expression for this method or for
this method the compiler is confusing
and gives us an error so the implicit
rule here is when you're using an
interface to declare a lambda expression
that interface should have only one
method and that method should be having
the same signature as this expression
and do that that the compiler is going
to be happy again now since this is of
type greeting how is it different from
something like this if I were to say
greeting other well greeting equals new
Hallowell greeting so what I'm doing is
I'm creating an instance of a specific
implementation of the greeting interface
here what am i doing I'm creating a
lambda expression which is in early
implementing the only method in this
creating interface now what's the
difference between this and this let's
talk about that in the next tutorial</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>