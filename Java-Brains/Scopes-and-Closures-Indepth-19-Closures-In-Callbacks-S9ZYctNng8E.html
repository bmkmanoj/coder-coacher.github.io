<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 19 - Closures In Callbacks | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 19 - Closures In Callbacks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 19 - Closures In Callbacks</b></h2><h5 class="post__date">2016-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/S9ZYctNng8E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we've talked about closures in a quite
theoretical sense we've seen how this is
something that happens and you don't
really do anything to enable it it's
just a feature of the language and now
let me talk about some real-world
scenarios where closures are very
helpful one very common use case where
closures are kind of essential is when
you're using callbacks so JavaScript has
a feature of callbacks where you send a
function to another function and have
that function execute whatever code you
have in your function the example that I
can give you is the set time arm as you
might know JavaScript execution is
single threaded whenever you have a page
open in a browser there's one thread
assigned to execute the code that
executes on that page so you don't
really have an option of creating
multiple threads because it's single
threaded the JavaScript language doesn't
have features like late or pause for
instance you want to hold on the
execution for like a second there's no
blade you know there's no concept of
8,000 milliseconds this feature does not
exist in JavaScript because if you were
to make the browser wait then you're
essentially kill you know holding on to
that thread the single thread that you
have for the page and the whole page the
whole tab in the browser becomes
non-responsive so you don't have
features like weight or pause in
JavaScript what you instead have is a
feature called a function called set
timeout so let's say I want to have like
a equals 10 and now let's say I want to
wait for one second and then here I want
to do console that log okay okay if I
don't have anything here to make that
browser Beit it is going to say equals
10 and then it is going to print console
the log of faith with me heart of war
here now how do I make the browser wait
for one second since there is no late or
hold or pause or anything like that the
way to do this is basically by using a
function call set timeout of
this is a function that comes with
JavaScript to enable things like this to
enable things like having an execution
happen after some time now the same time
odd function as you can see from the
Tuesday pure it takes in two parameters
the first parameter is a function that
it needs to execute and the second
parameter is the milliseconds which is
the time it needs to wait before
executing it okay so you're basically
saying hey set timeout
execute this function after so many
milliseconds so delay it to have
something execute after one second in
this case is to send that function that
needs to be executed after one second as
the first argument the second argument
is how much you want the JavaScript
engine to rate here in this case it's
one second so it's thousand milliseconds
so I can do something like this I can
have a function over here which is the
first argument the second argument is a
thousand milliseconds so I need to
create this function first let me do
that over here you can say var FN equals
simple function which prints console.log
of a which is what i want to execute
after a second right so let me clear
this thing out so this is the function
that I want to execute after one second
so this is the function I'm gonna pass
as the first argument to set by mod
remember that I'm not doing this if I do
this what the engine is going to do is
it's going to execute this function and
then take that return value and send it
to set time on I don't want to do that I
want to send the function itself which
is why I don't do the open close so the
function itself is this function object
so I send that function object as the
first argument second argument is the
time I want the engine to wait before
executing this function object all right
now if I were to execute this reload and
run you see that it waited for a second
and then it printed this all right this
is how you execute functions after a
delay in JavaScript let me clear out the
comment as well and again to clarify the
flow of control that's happening here
the first line executes right away which
prints which doesn't print anything
sorry it just creates a variable called
e and assign the value 10 do it
then line 5 execute which creates this
function object nothing gets printed on
the console yet and then line 9 executes
says said timeout so it's got sending
two arguments to the set timeout
function which comes out of the box with
JavaScript the two arguments are the
function that needs to be executed after
the timeout and the second argument is
how many milliseconds it needs to wait
before executing this function so line 9
executes and then line 10 1112
executes I mean it just the execution
keeps going on now if I were to say
console that log I've done here this Dan
is going to get printed right away and
then it's gonna wait for one second
right so from the time this was set it's
going to wait for one second and then
it's gonna execute F n which happens to
be this and then console that log of a
gets printed so even though I have this
function sent over here it's done that
gets printed first and then then gets
printed because this function gets
called after one second to illustrate
that let me clear this out and reload
and run you see Dan got printed and then
Dan got printed I can increase the delay
to 6 seconds so that it becomes more
obvious clear reload and run so Dan gets
printed right away still waiting for 6
seconds and then then gets printed right
so this is the asynchronous nature of
JavaScript itself and it has nothing to
do with closures really but why am I
telling you this
the reason I'm telling you this is I
wanted to explain how closures actually
play a part in this working and we don't
even realize it unless you really look
at it so set Dan mod is a function that
comes with the JavaScript engine right
so there is some code somewhere in the
engine which is a function call set
timer which takes in these two arguments
it says hey give me a function and give
me how long I need to wait before I
execute that function so you're sending
these things to set time up you have
created this function here which prints
gone so left ography now what do you
think is calling this function this guy
here it's not your goal right you have
never done FN open/close right you are
not calling this function here basically
having somebody else something else
call this function now when this
function is being sent to somewhere else
right there's some library code or
somewhere which is executing this
function you can be pretty much sure
that there is no variable called a in
that context whatever the code of set
timeout is it's probably written in a
completely different file if at all it's
a file and it's some different piece of
JavaScript code in some other Island
right then that code gets hold of this
function object and it executes consult
of log of a if it's probably not an a
there right it doesn't even know what it
hears and this is where the use of
closures become obvious because what's
happening is when this line executes
when line five executes we put the
semicolon here you should because it's
an expression now in line five execute
you remember what happens it makes a
snapshot of all the variables in the
scope so there is a VAR a in the scope
which contains a value of 10 doesn't
matter it knows this variable here it
got created at this point so this
function object then created knows that
there is this variable a at this point
in this place in the memory and it
remembers it in this function itself so
when you pass this function to set
timeout you're actually also passing
information about the scope information
about where this variable here is which
is why then the set timeout function
which you're passing this to then it
gets your function and then executes it
after your delay whatever you tell it it
executes this F in function and the
console that log of a execute the a is
still pointing to this they write so
this consulted log of a is getting
executed somewhere else but it's still
pointing to this K so we have a closure
here there is it available a part of the
closure which gets bundled with this
function object gets sent somewhere else
and that executes with knowledge of the
closure and knowledge of this variable
Hey
all right so this is a practical usage
of closures this is very useful when
you're looking at callbacks set timeout
is one of the many different callback
api is you can write your own call that
api's where you expect people who use
your api is to send in a
option and you can execute that function
and you can rest assured that when you
execute the function the function
remembers what the scope of variables
were when it was created so you don't
have to worry about copying over the
scope right the scope always exists as a
part of the function object</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>