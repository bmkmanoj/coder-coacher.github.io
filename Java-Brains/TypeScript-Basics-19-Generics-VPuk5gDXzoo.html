<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>TypeScript Basics 19 - Generics | Coder Coacher - Coaching Coders</title><meta content="TypeScript Basics 19 - Generics - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>TypeScript Basics 19 - Generics</b></h2><h5 class="post__date">2018-02-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VPuk5gDXzoo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">typescript has a feature called generics
which lets you parameterize types that
might sound a little bit odd what does
parameterizing types mean the
parameterizing values make sense and a
function for example you have a function
we have a bunch of arguments or
parameters and those are parameters for
values you pass in values using those
parameters how do you parameterize types
let me give you an example so I'm going
to create a new file called generics TS
and let's say I have a function which
echoes values which you have a function
echo which basically takes in an
argument call it Arg and then it returns
that same argument it's a little bit of
a contrived example but I think it's a
good illustration for our generics now I
can call this a KO function with a
number and what it returns should be a
number if I call the echo function with
a string what I get back should be a
string now here's a question how do i
type this function what are the types
that I add what's the return type and
what's the input argument type you know
doing typescript after all we should be
typing it one thing I could do is type
this as any because there is no
restriction really on what type the
input argument could be and again the
return type could be any but here's the
problem I'm losing that information that
whatever is being passed here is the
same thing that it returns from the echo
function now if I were to call echo of a
number I know by looking at the code
that the return type is also a number
but typescript doesn't know this you're
basically saying anything goes now I can
see a war my string which is a string is
the result of echo of one so it takes in
a number and then
it's am i sending it to a string now why
does this work this works because
typescript allows it you're seeing any
any so that could doesn't stop you from
doing this what you want to do they
somehow have tell typescript that these
two types are always the same whatever
is the type that's being passed in is a
type that the function was gonna return
and you want to prevent people from
making mistakes like this how do you do
this the way to do this is to use the
typescript generics feature generics
feature lets you create three soldiers
four types that you can use in multiple
places in your function definition in
this case so the video create a
placeholder is by using this syntax
which is less than letter greater than
alright so I'm doing this next to the
function name to indicate that this is a
generic function and the placeholder
that I'm using for the type involved is
T now when I do this I can use this in
place off any type declarations rather
than put in any over here I'm just gonna
put this T and has this any I'm gonna
put this T so what I'm doing here is I'm
a couple of things I'm telling
typescript first I'm telling it that
this is a generic function and I will be
using types with this letter called T
you don't actually have to use T but T
is a common convention and now type
strip knows that T is a placeholder for
type informations rather than explicitly
mentioning types over here in the
declaration I'm gonna be using this
placeholder then secondly I'm using that
placeholder in a couple of places first
to declare the input argument and to
declare the return type typescript
doesn't really do anything with this
thing as far as checking is concerned
when you create an input argument and
assign it to a placeholder to a generic
that doesn't do any type checking but
what it does is it makes a note of
whatever you have passed in over here
and then when the function completes
execution since it's also marked as a
return type of type T it makes sure that
whatever this function is returning is
same as the type that was passed and
because it made a notified earlier right
so it's comparing the two and me
sure that it's the same and now when it
tries to compile this line it notices
the error right away so you see here one
is not assignable to type string because
it's checking what this value is so when
it looks at this one it says okay D is a
number and then it looks at this
function it's returning a number it
should return a number and now it looks
at what it's being assigned to which is
a string and well string in number
doesn't they don't go well together so
it complains and throws an error over
here so the way to get this to work it
is to change this to a number or you can
just get rid of this declaration and the
implicit type definition assumes that
this is a number because of this generic
declaration all right so this is a very
simple example of generics there are a
lot more things you can do with this
especially with classes now let's say I
have a person class I'm going to copy
this over from our other example a
person class here and guess it's called
making this a duplicate identifier
because of another file that's in the
same path but we don't have to worry
about that here ignore this header for
now the person contains a bunch of
properties right first name and last
name now let's say I want to create a
class say admin extends person and then
I have some stuff related to admin let's
say class manager extends person and
there's some stuff relating to manager
and now let me create a couple of
instances
all right so I have what I'm doing here
is I have a class called person I'm
gonna have two classes which extends
person and I have an instance for each
of those two classes now let's say I
want to create a similar echo function
but for a person instance all right so
let's say I have a function
let's call it person echo which takes in
a person and then it returns a person
now I want to call a VAR foo equals
person it go off let's say admin now who
is of type any because there is no type
information here but if you learned that
generics are helpful I can make this off
type T and then the return type is gonna
be of type T and of course before I do
that I need to make T as a generic
variable by doing this and now foo is
gonna be of type admin because I'm
passing an admin over here all right
this is good but let's say I want this
to be restricted to only classes that
extend person either person instances
are classes that extend person now let's
say I'm doing something like this I'm
making maybe I'm calling person dot
first name for instance making
assumptions that the person that has
been passed this is of an instance of
this class so how do i restrict it to
either the person instances are classes
that extend person now there's one thing
I could do I can just get rid of
generics and then I can make this be of
type person right so this is
polymorphism now any instance of person
can be passed in and then I can access
this person dot full name last name
they're all accessible now because
typescript knows that any instance
that's
is of type person but don't notice what
happens when I call person echo of admin
and I hold on to that in a variable of
this readable becomes of type person
because this returns person so I have
lost some information over here now I no
longer get the same type that was passed
in I pass in an admin I'm gonna get
person I pass in an instance of manager
I'm still gonna get person now that's
not what I want I want this to echo the
type but I also wanted to have
information that this extends person so
the way to do that is by creating a
generic like before so I'm gonna do this
and put this back so now we have the
type information I pass in admin I'm
gonna get admin but how do I safely
access person's member variables off the
person class assuming it's of the person
class the way to do this is by telling
typescript that whatever TM using over
here should be a class that extends
person and the way I do that is by using
extents and in the class that I'm
restricting it to so basically what I'm
doing is just the same as what I did
over here creating a placeholder for a
time which is generic but I'm providing
additional information here so not only
am i creating a placeholder I'm also
telling typescript that this placeholder
applies only to classes that extend
person right so now when I pass in admin
it checks to make sure that this extends
person yes admin extends person so
that's good and then the generic
mechanism applies and then what do you
get back is a type admin so if he's here
there is of type admin and let's say I
do a war bar equals person echo of
manager if I pass in manager I'm gonna
get back a type which is manager so you
can do a bunch of these things to
configure what the generic type should
be you can enforce restrictions and it
just doesn't have to be any here we just
created this placeholder and there were
no restrictions
if you had any right and just mirroring
that in the response in the return type
of the function but here not only do you
have a placeholder also have a
restriction so generics allows you to do
that that's pretty powerful in certain
situations</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>