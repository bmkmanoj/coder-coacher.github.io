<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 32 - Around Advice Type | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 32 - Around Advice Type - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 32 - Around Advice Type</b></h2><h5 class="post__date">2011-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jwRwHOIwwdQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial if
you've seen the past few tutorials on
spring UB you have a good idea of how to
write different advice types in
different stages in the execution of the
target method you can write an advice
method to get executed before a target
method you can write advice that gets
executed after the target method and for
the after case we also have more do you
know define control you can write a
method that gets executed when the
method completes successfully and also
when there is an exception in the method
so with all the concepts that we have
discussed so far we have all the tools
required to intercept and run advice at
any point in the execution of the target
method that we need both before and
after there is one other advice type
that we haven't discussed that's the one
that I'm going to talk about today which
is the around advice so the reason why
we would need an around advice is if you
happen to use all these different advice
types if it's required for a particular
use case say you have a target method
and you want some that you know advice
code to get executed both before as well
as after and it could be any any
combination but let's say you have some
use case where you know you need
something to get executed say before the
method runs and after the method
complete successfully or before the
method runs and after the method throws
an exception or in other words you want
the advice method to run around your
target method but we can actually
achieve this by writing a separate
advice method for before and separate
advice for after but if we use around
you have a little more control and it's
a little bit more powerful than two
separate before and after advice method
so we'll have a look at that what I'll
do is I will use the same logging aspect
and I will write advise method over here
that works around the target method so
the annotation for this is at
around let me import this from the same
package that we've been using so far now
I can write the method over here I'll
write my around advice submitted now the
condition for an around advice method is
that this advice has to take a
compulsory method argument and that
method argument is called the proceeding
join point define that proceeding join
point now I can import this here and now
I can write any code that I want over
here at the around advice type is like
any other advice that we've seen so far
you know it takes a pointed expression I
will use this pointer expression over
here the oil Gators you will see why in
a minute
so now what I've done is I've configured
this around advice method to run for all
Gator so this method will run around or
get us now whenever you write around
advise methods there are two things that
you will compulsorily have to do the
first thing is with something we already
seen we need to have a proceeding join
point as the main argument to the advice
method itself we could have more
arguments depending on what your
requirements are say for example if the
point get was something like this you
have to have name as an argument because
you're catching all the parameters that
have names so probably name would be a
separate argument over here but in this
example since we're using this around
advice for all Gators we don't need to
have that so irrespective of what other
arguments you need based on your
requirement we need to have at least one
argument which is the preceding joint
point it's compulsory so this is one of
the rules the second rule is in your
advice code if you want the actual
target method to get executed you will
have to use the preceding joint point
dot proceed method now what does this do
the preceding joint pointer proceed
method actually executes the method that
this around advice is actually advising
so anytime during the execution of this
advice method then this line of code
appears this is when the actual target
method execution happens so I hope this
is clear how it's an around advice now
so what I can do here is I can actually
write code before this call and I can
actually write code after this call so
essentially I am writing advice code
around the actual target method
execution so the target method execution
happens in this line and then I can have
advise code the transfer for this as
well as after this now when I said you
need to have this line if you want the
target method to get executed what there
also implies --is we have a choice we
can if we want skip the execution of the
target method entirely so let's say I
have some preconditions that I want to
check here or wanna write you know I
want to execute some code over here and
depending on the execution here I can
choose to execute this or not and it's
not complicity but if we need the target
method to get to get executed that's
when you'd actually need to write this
line but otherwise you can actually
bypass it that is one of the real value
adds that we get by an around advise
that we cannot manage with the before
and the after in the after returning in
the after throwing so this is one
powerful feature of an around by
we can decide whether or not the target
method actually gets called and of
course we can have code both before and
after the execution of the target method
if at all we choose to do so okay so now
what I'll do first is add a try-catch
let's surround this with a try-catch and
before the actual method execution
happens I will print out a statement and
then after the method executes I'll have
a catch block here and inside the catch
I'll write another source out and within
the try after returning and then over
here after finally so this is actually
self-explanatory what's happening here
so all the code that you write here is
the before advice so this gets executed
before your target method gets executed
the target method gets executed by this
line that I'm doing a preceding joint
point dot proceed and then immediately
after that any code that you write here
is an after returning because in case
this results in an exception indirectly
goes to the catch over here so if the
lines below get executed that's because
this has returned successfully and then
inside a catch I'm catching a throwable
so any exception it comes over here we
have a after throwing so again here I
can have multiple catch blocks here it's
similar to you know the exceptions that
you can catch over here and then after
throwing you can catch as many number of
exceptions as you
one and have different after throwing
advice cold over here and then finally
once you are out of the cache block are
as a finally block over here I can have
you know a few more lines of code which
actually correspond to a after finally
annotation so this is around advice in a
nutshell so the only special
considerations that we'll have to make
when writing around advices first of all
you need to have a preceding drawing
point input and you need to do a
preceding join point dot proceed if you
want the target method to get executed
and of course you can write code around
this line inside your add rice method
now the question that I had when I first
read about the around advisors why use
any other advice why not use around
advice every time because that seems to
be the most powerful of them well the
best practice here is to use the advice
type which is sufficient and necessary
for the use case that you're trying to
achieve if you know that the code that
you want to write as an advice has to
run before the target method runs there
is no reason why you should go for an
around advice it's actually recommended
to write a before advice so you need to
choose the option you need to use the
least powerful option that serves the
purpose so if before will serve the
purpose you should not go for an around
you should go for a before and then you
know only if you have requirement for
and around advice that's when you would
choose the around advice so the
advantages of the around advisors first
of all you have more control you can
write different lines of code around it
you can have method variables that are
shared with the before code as well as
the after code so a local member
variable that you have over here can be
shared by both the codes it's not
possible to do that in a thread safe
manner if you have two different methods
one for before and one for after and the
only other thing you need to note here
is that if this returns a value say this
is
returning value as it happens in this
case this is all Gators so this returns
a value that needs to be send to the
calling program so in the case this
advice cannot return a void it has to
return the value that it's returning so
let me call this a object so I do not
know what this you know this method is
returning here it happens to be a string
in that case I can actually mark this as
a string but generally you would want to
mark it as an object so that you are you
know leaving the option open for any
return type and then here finally what I
do is I of course have to do this here
I'll declare an object and I will use
that object to get the return type over
here and then I will have to return this
object here return return value so this
is what needs to be done in case the the
target method is actually returning a
value you can use that and one more
difference here is when compared to the
after when we were talking about after I
said we cannot modify the returned
object we can of course use it see here
we have a return string and we're
catching their object over here so we do
get a handle to the object when you're
using after returning but then you
cannot modify it you cannot you cannot
say for example send something else but
we do have that luxury over here now I
have the object here I can modify it I
can return whatever I want so this is an
additional way in which the round advise
gives us some more control okay so now
we are all set let's execute this now
this is happening for all you get us so
I will make sure the Gator let's called
see here a get circle is what does
called over here this is a gator and
this has to be this has to trigger this
around advice now let me remove this set
name because we do not want the other
advice to get executed at this time
let's run this also here you can see a
before advises run after returning its
run and then I have to finally is run
now if the method that we are calling
over here had thrown an exception in
that case what would happen as this
catch block would have executed and then
the code which you know gets executed is
he after throwing so essentially this is
what is the around advice so you can
write code that gets executed at both
before the target method you can control
when the target method runs whether a
trance or not and then you can have an
after returning after throwing and after
finally and an additional feature is you
can get hold of the return value you can
either modify it or return it as is so
this concludes the you know the advice
types provided by spring AOP starting
with before after after returning after
throwing and around to hope this was
helpful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>