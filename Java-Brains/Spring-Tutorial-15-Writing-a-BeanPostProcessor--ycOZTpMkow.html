<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 15 - Writing a BeanPostProcessor | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 15 - Writing a BeanPostProcessor - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 15 - Writing a BeanPostProcessor</b></h2><h5 class="post__date">2011-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-ycOZTpMkow" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial here I'm
going to talk about something called as
beam post processors beam post
processors are classes that tell spring
that there are some processing that
spring needs to do after initializing
the beam hence the name beam post
processors what happens is when you
write some Gordon ear beam post
processor then spring execute that code
after initializing each and every beam
so this is something that you can use in
order to extend the functionality of
spring so say you want the framework to
do something to perform some actions
after being initializations
then you can write a beam post processor
and then spring is going to execute that
piece of code then every beam is
initialized so a couple of significant
points about the being post processor
first of all the method the single
method runs for every initialization of
every beam in your spring XML so no
matter how many beans you have no matter
how many types of beans you have if I
open my spring or XML now I have
triangle beans and I have point beans
each of a different class so no matter
how many types of beans you have when
every bean is initialized then the bean
post processor method is called it's the
first point the second point is at the
bean post processor it is a separate
class obviously because it caters to
initializations of different types of
classes we have to have a code in a
common place so there is a separate
class and the method of that class runs
on an initialization of all the
different beans in your spring XML now
in the previous tutorial we saw about in
it and destroy methods we saw how we can
write a method that gets run on
initialization of a bean and on
destruction of the bean the thing is
that you're supposed to have that method
inside the corresponding class itself so
if you want a method to get run on
initialization of the strangle class the
method needs to be inside this triangle
class if you want a method to get run on
initialization of the point class then
that method has to be inside the point
class so when you think about that bean
post processor seems to be a very good
way to have a method that needs to be
run say you have a we wanna method
it needs to be run across all these
different types of classes you want an
init method then it makes sense to put
it inside the bean post processor most
common and the recommended usage of a
bean post processor is to extend the
functionality of the framework you might
make some configuration related coding
in the bean bus processors in this
tutorial I'll show you how you can write
your own bean post processes and in the
subsequent tutorials we'll see some of
the out-of-the-box bean post processes
that spring provides so the use case
that I'm going to do here is I'm going
to write a class with the method that
prints out the bean name and I want the
bean name to be printed out after every
bean and my spring XML is initialized so
what I do is I write a method to print
the bean name and I put it in a bean
post processor and then I define the
bean post processor and spring so that
spring knows that it's there then what's
going to happen is when spring
initializes each of these objects it's
going to call the method of that bean
post processor and of course each of
these bean names are printed so let me
write the class first so what I'll do
I'll create a new class click call this
display name clean post processor ok so
here I'm going to write code to print
the bean name so in order to make any
class the bean post processor I need to
implement the bean post processor class
okay now this let me import this first
this is from the beans factory convict
package okay so when I implement the
bean post processor there are a couple
of methods that I'll have to write so if
I add the unimplemented methods you see
here there are two methods that you know
Eclipse comes up with now these two
methods are again callbacks for spring
to call when each of the beans are
initialized so you have two methods you
bannister you know post process before
initializer
and a post process after initialization
note that these two methods take two
arguments one is the object and one is a
string and even this method takes an
object and a string so what's happening
is before initializing any beam this
method is coil okay and then after
completing the initialization after
doing all the dependency injection and
all that stuff this method is called
and the argument seller passed are the
first argument is the object which is
the beam object itself and the second
argument that's passed there is the name
of the beam as configured in this spring
XML so again the same here the object is
passed and the name of the beam is
passed and the both these methods have a
return type as an object so spring
expects you if you if you implement
these methods spring expects you to
return the object back so that it can
continue its configuration using the
object that you are returning so what
happens is let's say you're you're
getting an object over here you need to
make sure that you are returning the
same object you might want to make
changes to the object again it depends
on your configuration needs but then
once you are done with it
you're supposed to return the object
back otherwise you're going to break
this flow so here what I'm going to do
is I'm going to implement the post
process after initialization or final
implement both
I'm going to change this going to remove
this piece of code here so the first
thing I'm going to do is I'm going to
print the statement system dot out dot
here in in the for initialization method
we name s and I'm going to print out the
beam name let me name this right so this
is the actual beam and the string that
we are getting is the beam name so I'm
going to print out this beam name here
okay so let me print the same thing here
of course I'm going to change the
message this is after now note here that
it's throwing an error because it's
returning an object and I haven't
written anything I need to make sure
that I'm returning
the beam that I'm getting here so I'm
going to return B even here this is the
beam and this is the B name and I'm
going to return the beam
note here that you can return any object
you want and spin is going to take that
so you have full flexibility here you
can make changes to the object that you
are getting you can return a different
object so all these things are possible
but here in this particular scenario I'm
not making any changes to the beam
object itself I'm just taking the beam
name that I am getting and I'm printing
out a message over here so let me save
this so here I have created a being
postprocessors now what I need to do is
I need to tell spring that I want this
to be registered as a being post
processor just having a class that
implements a being force processor
enough spring needs to know that you
want this to be in action
so what I do is I go to the spring got
eczema and I define this being over here
so I'm going to see Dean class equals
and class here is goes the package name
dot display name begin post-processor
and that's it this is all it takes note
that I'm not creating an ID here because
this this class is not referenced in any
other class no class is actually
dependent on this class you wouldn't
want to do get Dean of this and you
wouldn't want to have some other class
having this as a dependency so since I
don't have a dependency I'm not giving
it an ID and I'm not doing any
configuration as well I'm just letting
spring know that I have a beam like this
here and rest is automatically did you
spice print itself it knows that this
class implements being post-processor it
has these two methods so it's going to
call these two methods so this is all it
takes in order to have a being
post-processor now note that I can have
any number of such classes like this
that this is just a display name I can
have any other number of classes and
then I can have all of them implement
the beam post processor and you can even
have them implement the ordered
interface so that you can have an order
property and then you can specify the
order in which spring executes but in
this example I'm going to keep this
simple I'm just going to have one beam
pass processor and then I have defined
both the before initialization and the
after initialization methods I'm just
printing on the main and then returning
the beam that I'm getting so let's see
how this works now I'm going to not
going to make any other changes okay I'm
just going to call the gate beam as
usual and then the dependencies are set
here as usual no other changes to the
existing code I'm just plugging in this
new functionality and then this
functionality gets executed before and
after initialization of each and every
being here so
we run this well there you go you can
see there is a before initialization of
point a after initialization of point a
before initialization of point B after
of point B before of C and after of C so
these are the first set of objects that
get initialized and after that you can
see before initialization of triangle
after initialization of triangle of
course we had to have these three
initialize first because triangle is
dependent on these three objects so
after triangle is initialized that's
when the flow of execution continues you
have point ABC prints so what's
happening here is these two methods are
being executed for the initialization of
each and every object that you have
defined over here so this is a very
handy feature if you want to override
some of the default functionalities of
spring or you want to write your own
configurable piece of code that gets
executed on each and every beam
initialization note that there's no
destroy here you cannot have a common
class in a common piece of code that
gets executed on the destruction of each
and every beam this is for
initialization again as I said this is
very helpful if you want to make
configuration related code overrides</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>