<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 44 - DAO Support Classes | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 44 - DAO Support Classes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 44 - DAO Support Classes</b></h2><h5 class="post__date">2011-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UOyjFjilPIo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial we have
looked at different JDBC templates in
our previous tutorials and we have seen
how using a JDBC template can simplify
our do clasts before we wind up spring
JDBC support there's one other concept
that I would like to talk about and that
is do support classes now the
implementation that we have done here
using the JDBC template has actually
reduced a lot of lines of code but then
if you see here there are a few lines of
code that need to be added for all your
do classes of course here I have
multiple JDBC templates you wouldn't
have that normally you would just have
one JDBC template but then you would
need to have a data source you would
need to have these lines of code over
here what this does is on the setter of
the data source I'm initializing the
JDBC template and saying new JDBC
template and I'm passing the data source
to it so these lines of code have to be
there for all your do classes well in
this project I just have one so it's not
such a big deal but let's say you have a
project where you have 10 do classes 20
do classes that means that these lines
of code would have to repeat for each of
those 20 Dao classes so this is again
something that can be optimized as we
all know in order to be a good
programmer you have to think lazy so
let's let's see how we can get a little
bit mortal easier and see how we can
optimize even these lines of code now
think about this I have 10 classes or 20
classes with the same lines of code of
one simple way to eliminate these
repeating lines of code is to have one
common parent class that has these lines
of code and then all my other 10 or 20
classes will inherit it from that so
what we are looking at here is having
one common Dao class we call it the
generic Diego and that genetic Dao will
have this member variable it will have
these skaters and setters so these lines
of code will be in that genetic Dao and
then in my project all my other Devo
classes will extend that generator
well this is actually a common practice
and in a lot of enterprise applications
you would have all your da was extending
one common do anyway and spring also
recommends this spring advises us to
isolate all these features out and put
it into a common Diego and your do
classes extend that and what spring is
actually done is in the framework Spring
has a support class that that does this
very thing now spring has support class
with these member variables and with
these getters and setters because this
is something that you would most of the
times your end up doing because your
Diego class would need to have a data
source anyway it would need to have a
JDBC template anyway and you would have
to assign it and this is something that
you would do 99% of the time in your do
classes so spring says hey let me
provide you a class you don't even have
to write that do class the genic do
class I will provide you this generate
do class all you need to do is your Dao
class has to extend the generate do so
in that case you can actually do away
with all these lines of code now the
question is there are three different
JDBC templates over here I have the JDBC
template have the name parameter JDBC
template the simple JDBC template now
which template does that support class
actually contain well there are three
different do support classes so you have
the JDBC Dao support which has a JDBC
template you have the name parameter do
support which has a name parameter JDBC
template and we have a simple Diego
support which has a simple JDBC template
and then again did that do support class
doesn't really do anything it just has
these lines of code that's it so your
code does not need to have this it's as
simple as that but it's a good design
practice and this is something that you
would normally use so let's have a look
at how we can do that so the first step
is deciding what JDBC template you need
I have gone through gdb C template in
the name parameter JDBC template in the
previous tutorials in this tutorial I'm
going to use the simple JDBC template so
now when I'm creating a new Diego class
that uses the GDU support I would have
to get the
right do support class depending on the
template that I need now if I want to
write a DA vu that use a simple JDBC
template I would have to extend the
simple JDBC Dewas support it's as simple
as that so each of these templates have
a corresponding do support class so in
this tutorial I'm going to choose the
simple JDBC template so I'm going to
write a Devo class that extends the
simple JDBC do support so I'm going to
create a new class and I will call this
simple JDBC dym PR and now this class
will extend the simple JDBC Dewas
support so I'm going to browse here
simplicity BCD will support you see this
is here you also have the others so I
can i can choose JDBC do support so this
is the one which has the JDBC template
and of course this one for the named
parameters as well see here name
parameter JDBC to your support so for
this example I'm going to choose simple
JDBC D with support and then click
finish so there are no abstract method
so you don't have to implement anything
all you need to do is know that this
this class the class that we are
extending has the simple JDBC template
as a member variable so you don't need
to define it you don't need to
initialize it with the datasource you
don't need to have any of that all you
need to do is whenever you are writing
your Dao method whenever you need to
access the simple JDBC template all you
need to do is use this Gator here get
simple JDBC template so this is
something that our class inherits from
the simple JDBC da with support so we
have a fully initialized JDBC template
with us and we just use the Gator in
order to get the JDBC template now the
question is how does this do DBC
template
where the data source is because that is
something that we've been doing over
here we have been initializing the JDBC
template with the right data source so
we'll have a look at that in just a
minute but let's quickly implement one
of the methods that we have already
implemented over here let's take this
one get the circle count I'm just going
to copy this and leave this method here
so this is a method that gets the count
off records from the circle table so I
have a select count of star from circle
and then I'm using the JDBC template dot
query for rent method and passing the
sequel and returning the count now this
JDBC template was a member variable in
the previous class and I accessed it
directly but here as we discussed just
now I'll be using a getter
so I'll lure this dot get JDBC template
dot query for int so this is a method
that's run on the JDBC template member
variable that we are inheriting from the
simple JDBC D with support and guess
what this is it this is all that your
Dao has to do so none of the
initialization code will be that in each
of your individual use it will just be
just this line of code which runs the
corresponding method on the JDBC
template and then return the value in
your done so let's save this and now
let's look at how this JDBC template
actually gets initialized so here we
have a data source and then we are
passing the data source value using the
spring XML right we have the data source
being defined over here and then we are
passing this data source a fully
initialized data source object to the
JDBC temp you know to this class using
this auto wire annotation show I am auto
wiring the data source directly to my
data source member variable over here so
now how do I do that
in this tu class note that here I do not
have access to the source for the member
variables or the setters the member VD
and the setters are happening in the
parent class in the simple jdbc to your
support so I cannot go and auto wire you
know the code in this class I cannot
write an autobiography
since that is in this class however I
can still use the member variables then
I say I cannot control the annotations
that's because the source code is over
here but still the member variables of
this class are the member variables of
this class so since I have the JDBC
template and the datasource over here
I can add I can always access them using
the getters and setters because I'm
inheriting them from the bail-in class
so the obvious way is to use spring XML
so what I do here is I define this deal
as a beam in the spring XML and then I
assign the datasource to the member
variable of this simple do JDBC impl so
let me do that here so I define a beam
simple JDBC DUI MPO and the class is my
new do class that I have over here so
now I have defined that as a beam now
what I can do is I can dependency inject
any data source I want into the data
source member variable of this class
since it's extending this class the
member variables of this class will also
be inherited now I can dependency inject
into that so it is as simple as having a
property here like this so I have a
property datasource referring to the
datasource being that I have already
defined over here so what's going to
happen as this will ask spring to do the
dependency injection so this data source
reference will get injected to the data
source over here and this data source is
a member variable of my d-u class
my deal and of course the JDBC template
will be aware of the data source so
again it's nothing different from what
we're doing over here so here we are
using an auto wired because we have the
source code here and we can annotate it
but here since we are extending it from
a parent class and we do not have the
source code what we do is we use the
spring XML in order to define this so we
save this and of course it's actually a
good idea to have this definition in the
XML because this is something that you
might want to change
well for example depending on the
environment that you are in you might
want to point to a different database
use different data sources so it's
definitely a configuration rather than
the way the program works or the
functionality so this is actually a good
idea to put this configuration in the
XML anyway so now that I have passed the
data source to the JDBC template or
rather to the DAO support class the
simple you support class knows what the
databases and it has a fully initialized
JDBC template and I don't have to worry
about all the rest of the things what I
do is I use a gator to get the JDBC
template and then and the methods on it
so that is it
so now let's let's just test this out I
will I will run this method get' circle
count off the simple JDBC do so I'm
going to change the code over here this
would be simple JDBC DUI and here then
of course I have to import this and now
I will print out
the output off this method get' circle
count let's leave this and now what's
happening is I'm utilizing the dije view
which is this one my new Devo and I'm
calling a good circle count here again
the method itself has not changed only
thing is instead of using a member
variable I'm doing a gator off Oh parent
class now let's make sure this works and
there you are get a value of five which
is the number of records and circle
table so this is the way in which you
can use the do support classes that are
provided by spring this is again not
very different from what we've done so
far
it is just that a better way and then we
using one of the support classes that
spring provides and we can do away with
all these code that we need to do to
initialize RDA was in case we're using
JDBC template directly</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>