<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript for Developers 17 - Type Coersion and the === operator | Coder Coacher - Coaching Coders</title><meta content="JavaScript for Developers 17 - Type Coersion and the === operator - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript for Developers 17 - Type Coersion and the === operator</b></h2><h5 class="post__date">2016-02-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IQoBAaxR3Ng" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the next thing I'm going to talk about
is something called type coercion this
is something that JavaScript does
automatically and there are similarities
in languages like Java there are similar
things which happen but just want to
highlight that this is something that
happens in JavaScript so what is type
coercion type coercion is where you have
variables declared with you know and
assigned to a value and you are
operating on those variables and there
are certain points of time where the
interpreter or the compiler will have to
do some automatic type conversions for
you in order to make that operation work
right so lecture you are dealing with
some values of different types variables
of different types you're adding them or
you're doing some operations with them
there's no way those operations can work
unless there is some automatic type
conversion that happens right so this is
usually called type coercion a standard
example is concatenation with string
values let's say you have something like
this 123 plus the string 4 what do you
think happens this is again common
behavior you see this in other
programming languages as well as you
would expect the value will be 1 2 3 4
string what the interpreter does is
looks at the first value which is a
number and it's added to the second
value which is a string it obviously
cannot work right you cannot add a
number to a string so at least one of
those two values has to be converted to
the other type so that they both belong
to the same type so what the JavaScript
interpreter does is it takes the number
and converts it to a string so the
number 123 becomes the string 1 2 3 and
then it appends 4 to it so you get 1 2 3
4 which is a string this is something
that behaves like you would expect it to
but remember that there is type coercion
that happens and JavaScript does a lot
of type coercion which is not what you
would expect it to and I will cover that
soon all right now I'm going to talk
about the equals operator the double
equals operator so one thing that's
common in a lot of programming languages
is that this
single equals is usually taken up for
the assignment operation right you say a
equals B is basically B you know the
value of be assigned to a so that single
equals is always taken for assignment so
when you want to compare two values
right if you know if it's an if
structure if a equals B what you would
typically do is you use double equals
because the single equals has a
completely different meaning
this is exists in almost all programming
languages so if you want to compare if a
is equal to B you say if in parentheses
a double equals B so the double equals
operator compares those two values and
then returns a boolean whether it's a
true or a false depending on the values
of those two now in JavaScript that's
kind of the same thing but it goes one
level beyond what you would expect it to
so let me give you an example all right
so I have I'm going to clear this out
and fill this out as well let's say bar
a equals 10 bar B equals 10 and then I'm
going to do if a double equals B say
console dot log values are equal
all right so I'm going to right click
and say reload and run and if the values
are equal no surprises here
I hope this if block is familiar like I
said this is similar to other c family
of languages so this should not come as
a surprise to you so this is double
equals so what's different in the case
of JavaScript the difference is let's
say instead of having a value of a
number for B I have a value which is a
string containing the value 10 okay so
now in this F block I'm comparing a
variable which has a number 10 and I'm
comparing it to a variable which holds
the value of string then I'm checking if
they are equal now what do you think
happens over here ideally it should not
print the values are equal right turns
out javascript has different intentions
in mind so if I reload and run still
shows values are equal what on earth is
going on here so you remember I told you
that when JavaScript was created it was
meant to be easy for people to get into
and use right so I told you that the
interpreter is very forgiving it makes
assumptions it tries to cover up what
could potentially be mistakes and in an
attempt to do that what the interpreter
also does is make a whole lot of
mistakes on its own right so when the
double equals was designed in JavaScript
right when javascript was being created
they wanted to make it super friendly
they wanted to make it a common data and
understanding so what they decided was
let's you have two values and you're
trying to compare the two if one of
those values can automatically be type
converted to the other do the type
conversion and then check and see if
they are the same okay you remember I
was telling you about how you can do
like things like 10 plus 10 and this
will result in a string 1 0 1 0 right so
this 10 is being automatically converted
to a string
so when the double equals operator would
design for JavaScript they decided to do
the exact same thing so if then you're
doing a double equals and they are off
the values are of two different types
the JavaScript interpreter tries to
convert one of them to the other and
then see if it matches
so what javascript is doing here is it
says okay this is the number 10 this is
a string 10 they're obviously not equal
so probably the developer needs some
help here so it converts the number to a
string and then sees if those two match
if they match the if block gets executed
as you can see this is all kinds of bad
you wouldn't want to do something like
this
so when the language was rolled out and
people started using the double equals
other people started getting frustrated
and they said okay we got to change this
but now you cannot because that's the
thing about languages once you roll
something out it's hard to change
because when you change something it's
very likely that the people scored is
going to break and it's not going to
work anymore you don't want that so for
JA what the JavaScript language
designers did was well the single equals
is taken by the assignment say equals B
B goes to a can't use a single equals
now if the double equals in JavaScript
is taken by this weird thing which does
type conversion and does automatic
things for you they don't want to change
that so what they did was they
introduced a new operator which is the
triple equals I'm not kidding this is
actually true so JavaScript has a triple
equals operator which does the
comparison like you would expect it to
it does not do type conversion if two
variables if two values that are being
compared with the triple equals operator
are of different types it is going to
return false okay so let me try this out
I'm going to clear this out and reload
and run it should not print the value of
the console and you see it does not okay
so the triple equals is the right way of
comparing values in JavaScript okay so
this takes the place of the double
equals that you are already familiar
with but the double equals is there in
JavaScript it just doesn't do what
1 &amp;amp; 2 it kind of doesn't most of the
cases but when you have things like this
a number and a string then you can lead
to trouble so it's better to be safe and
always use a triple equal so that you
know exactly what it does</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>