<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 14 - Some Exercises and a surprising result | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 14 - Some Exercises and a surprising result - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 14 - Some Exercises and a surprising result</b></h2><h5 class="post__date">2016-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aO4QWSQW7yk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay time for a couple more quick
exercises we're going to look at a piece
of code and kind of deduce what the
compiler step does and what the
interpreter interpreters step does this
might seem like I'm beating this concept
to deck but hopefully this example is
going to uncover a couple of things so
this is slightly more complicated than
the code if you've been using and then
at the end of this tutorial I'm going to
show you something that might come as a
bit of a surprise so even though you
feel fairly confident about scopes and
the interpreter logic I still recommend
you work your way through this one I'm
going to show you the code and I'm going
to pause for a couple of seconds for you
to kind of pause the video and come up
with an answer and then we'll see if you
know if you're right okay so let's start
with this simple program which starts
with wor equals 10 which is a global a
and now let me create a function called
outer which has a variable B and then
it's assigned the value which is a and
then I'm going to print console that log
of B okay so now inside this outer
function I'm going to create an inner
function okay so I have this function
called inner and in that inner function
I have a VAR b equals 20 so I'm read
eclair in the variable B and then I have
a VAR c equals V and then I'm printing
console that log of C and so now I have
a function called outer and inside out
to have a function called inner and I'm
going to execute the inner immediately
after I've defined it so here is the
Declaration of inner and then I'm
executing immediately so whenever outer
is called it does some stuff and then it
executes the inner function okay so now
all I have to do is call outer because
if I don't do that nothing is going to
run so I'm going to call outer so that
outer gets called and then inside outer
I have a function call dinner and then
outer cause you know so inner gets
executed as well okay so now it's time
for us to okay the roll ask the compiler
and the interpreter draw up a scope
chain and see if you can guess what gets
printed on the console
okay so let's look at the scope chain
here and now we have the compliation
step let's run through this quickly we
have avoir a so there is a global a and
then there is a function outer so there
is a global variable called outer and
now it's going to examine this line or B
again we're looking at the compiler
steps so we're just looking at the VARs
so barbie is going to create a new
variable called B in the scope of outer
and then no variables here now there is
a function inner so there's a variable
called inner created in the scope of
outer alright and now this line executes
there's a barbie inside inner so there's
a new scope called inner and then there
is be registered inside the scope of
inner and now there is a war c which
means that there is available c
registered in the scope of in our this
line the compiler doesn't care about
this line the compiler doesn't care
about and this line the compiler doesn't
care about because all these lines do
not create new variables all right then
the compiler is done now it's time for
the interpreter we have created a scope
chain here which are which comprises of
three scopes alright
now let's look at the job of the
interpreter what does it do we have a
first line a equals ten the interpreter
looks at this part now and now it
allocates ten to a again the interpreter
goes to the global scope and says hey
global scope give me a and the goodwill
scope does and ten gets assigned to it
now this is a declaration so the
interpreter doesn't really do anything
about it at this point of time when it
comes to line 14 now addicts cutes outer
so now the interpreter says hey global
scope give me a variable called outer
i'm assuming it's a function so give me
that and the scope does have a variable
called outer which happens to be a
function of course and now then put your
execute it comes to line four
interpreter looks at this part alone B
equals a now it says hey outer give me B
outer says yes I've got it now it's AC
outer give me a outer says I have no
idea what he is now then put it goes one
level up it says hey Globo give me a and
the global gives it now it has the value
10 now the B in the outer scope contains
the value 10 now console that log of B
gets called console of course results to
global I'm not gonna
get into that but now B needs to be
accessed it's read operation so again
the interpreter says hey out give me B
and then the ultra scope contains B
which can extend so then gets printed
and now this again theta printer doesn't
care about at this point of time now it
comes to line 11 now line 11 says
execute the function inna now inner is
again available reference so the
interpreter says hey the scope of
outdoor do you have a variable called
inner now there is so it gets that
variable which is in this cocoa powder
and then it executes that now the
execution leads to the interpreter
coming over here says B equals 20 now
the execution the interpreter says hey
scope of inner do you have a variable
called B inner says yes I've got B and
now it allocates the value of 20 to it
remember that this is different from the
B in the outer scope right that was a
completely different variable now it's
going to come to this line this part is
what the interpreter looks at C equals B
which says hey scope of inner do you
have see there in the scope of inner
gives it C scope of inner do you have B
scope of energy should be enough console
that log of C is going to print the
scope of energy because it says again it
looks at spoke of inner to get that C
and that gets printed and that's the
final result hopefully this was
instructive this is one of the more
complex examples we've seen in this
course so far it actually looks at
multiple nested functions and this is
what happens when you have multiple
nested functions you have multiple
scopes and then variables gets
registered in those scopes and there is
always a lookup and again if you were to
have a variable access of a over here
without the bar then the interpreter
would have gone all the way up to the
global end access this one now even
though there were multiple scopes in
this scope chain it was fairly simple to
figure this up at this point of time you
would have probably thought hey I don't
really need to draw this scope chain in
order to figure this out I can actually
look at the code and say hey this is
what it is and I can figure out what the
output is without having to go through
the process of being the compiler and
being the interpreter but here's the
twist in the tail here's where there's a
little bit of surprise that I have in
store for you
now imagine what would happen if I make
a couple of minor changes to this code
now let's say I let's say I take this
line out and then add it after the
concern that log
okay let's say I remove this line and
move it around
now would you be able to guess what gets
printed on the console in fact let me
ask you this
in this line of code line seven what is
the B over here what variable does this
B point to if you're not careful what
you'd probably think is that this B
points to the outer scope because at
this point of time there is no bar b bar
being the inner scope happens only over
here right if this were to be the inner
scope there is Warby which happens below
but now here at line seven there is no
VAR b yet but we are accessing B so you
would assume that B is actually going to
get delegated to the outer scope right
it's going to look up one level up and
it's gonna find this and now it's gonna
find the value 10 and up 10 gets
assigned to see well there you would be
wrong what gets printed in this line is
not 10 what gets printed is undefined
and in order to understand that you have
to draw the scope diagram and play the
role of the compiler and interpreter I
know it's not fun but there are got just
like this where you really need to step
through the process in order to
understand it and again the reason why
this comes as a surprise is because
there are two separate steps there is a
compiler steps which looks at the bars
and there is an interpreter step which
doesn't look at the Wars so the order of
the bars is really not affecting the
flow of the interpreter so to illustrate
that let's look at this cob diagram
again so for the inner scope right if I
was a compiler and I was looking at the
inner scope because the other scopes are
just fine there are exactly the same the
novel is looking at the inner scope what
would the compiler do it would say warsi
I create a new variable in inner and now
it ignores this and it comes here
Warby never creates a new variable
called B in the scope of inner ok so
this happens before the execution before
the interpreter now when the interpreter
comes here that this is the
chain and now it executes this line now
what happens here it wants to look up
see and it a say inner do you have see
you know gives a variable called C right
it is in the inner scope and now it says
hey inner do you have B guess what the
inner gives available called B which is
in the inner scope right so even though
the VAR b is below it really doesn't
matter because what gets the variable B
added to the scope is the compiler step
which had already happened before it has
already gone through one full pass at
the cord and it already knows that there
is a variable B in the scope of inner so
the interpreter executes this line and
wants to look up B it already knows that
there is a VAR b somewhere below in
inner right it doesn't care where the
article you just looks up the scope it
says hey I've got a B so it actually
looks at the variable B in the inner
scope it does not go and level up okay
and what's the value of B at this point
of time there is nothing that's assigned
to B so the value is going to be
undefined so now this gets the value of
undefined and of console that log of C
over here is going to print undefined
this is a little bit tricky because
again you have to remember that there
are two passes in the code and it's in
during times like this that it actually
helps to run through the cord as a
compiler once before you actually go to
the execution the interpretation step
and this kind of behavior can be
summarized in a more simple code okay
let me take all this thing out and let's
say I do something like this and say I
do something like this alright so this
is the code this is kind of simplifying
what all we talked about and what
behavior you would expect I've told you
that when you access a variable which is
not declared and you do a read operation
on it the interpreter is going to give
an error right now is this an access of
a variable read access of a variable
that's not declared if you didn't know
better you would have said yes at this
point of time a isn't declared so it's a
read operation on an undeclared variable
it is going to give an error
but now that you know the compilation
step and the interpretation step your
answer will be different this is not an
access off and undeclared variable
because the variable is declared below
and it really doesn't matter what where
it's declared because the compiler would
have drawn run through this first and
created a variable a in the global scope
so when the interpreter actually
executes this there is already a
variable a in the global scope so this
does not give an error and what is the
value of a here it is undefined because
the interpreter has not gone to line two
which actually assigns the value 10 to a
when console that log of a prints it
prints undefined but still it is an
existing variable so it does not result
in an error so this is putting the
problem in the simplest code that I
could put and hopefully this can
illustrate what happens here are due to
the two passes and this behavior is
what's called as high sting it's an
important property of JavaScript
variables and we'll discuss more about
that in the next video</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>