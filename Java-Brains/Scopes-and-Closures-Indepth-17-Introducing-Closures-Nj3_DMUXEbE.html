<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 17 - Introducing Closures | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 17 - Introducing Closures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 17 - Introducing Closures</b></h2><h5 class="post__date">2016-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Nj3_DMUXEbE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you
welcome to unit 3 in this unit you're
going to learn about tortures in
JavaScript closures are one of those
concepts in the JavaScript programming
language that's commonly perceived as
fairly complicated in advance and that
discourages people who are learning
JavaScript from even tackling right
attempting to tackle but hopefully in
this unit I would disprove that idea and
I'll tell you that closures are fairly
simple and they are actually everywhere
whether you know it or not whether
you're explicitly using it or not
closures are a part of the JavaScript
programming language and they are there
whether you want it or not so we're
going to start this unit but learning
what closures are and how they affect
the functioning of the functions that
you write in JavaScript and then you're
going to write some code which uses the
concept of closures you're going to look
at a pattern called the module pattern
which very intelligent very
intelligently uses the concept of
closures and does something to the
native JavaScript programming language
doesn't have as a feature to explain
what closures are let me give you this
example that we've already looked at in
the exercises video so let's say I start
with wore a hood stent which makes a the
global variable and I'm going to create
a function called outer which has a VAR
b equals 20 okay and b is now in the
scope of outer i'm going to create a
function inside the outer function and
i'm going to call that inner ok so i'm
going to create a function inner which
is inside out door and I'm going to
print concept of log of a and console
the log of B inside the function inner
and I'm going to call it I'm gonna call
inner inside outer and finally I'm
outside of the outer function I'm going
to call output itself so basically I'm
calling outer now how to execute an
inside outer I have defined a function
called inner and then it executes sinner
so when inner executes these two are
printed now can you look at the code and
guess what gets printed on the console
which obviously 10 and 20 right so here
the variable a is being read and there
is no variable a inside the function
inner
there's nothing inside outer it goes all
the way to the global scope and then
gets
the value a which is ten similarly be
there's no variable be inside inner so
it goes one level up to the scope of
alternate finds be declared over here
with a Barbie so it's going to take that
value and it's going to print twenty so
it should print ten and twenty so let me
copy this to the Firefox scratch pad and
execute it okay I'm going to paste the
same code here in a right click reload
and run there you see ten and twenty
printed on the console and we've looked
at how this works the compilation step
creates the scope chain and the
interpreter is actually looking at the
scope chain so then they printed
executing lines seven and eight it knows
exactly where the a is and it knows
exactly where the B is now it knows that
this is referring to this B and this is
referring to this a so this seems fairly
simple but this is where things get
tricky now let's look at the function in
R now there is the function in R
declared it's declared in the function
outer ok and where is inner executed
it's all it's executed in the function
outer as well okay so it's declared in
the function outer and it's executed in
the function order it's can execute it
in the same place where it's declared
but not question the question that I
have for you is is it required for a
function to be executed in the same
place that it's declared well no concept
of JavaScript having first-class
functions means that you can take a
function object and pass it around and
execute it somewhere else right so the
function could be executed in a
completely different context in
completely different scope from where it
was declared so let me convert this to a
function expression first so that it
becomes more obvious rather than it be a
function declaration I'm going to make
this an anonymous function and then make
this a function expression for inner
equals this function okay now I could
say inner open closed in which case it's
exactly the same as what we did before
but that's not what I'm going to do now
what I'm going to do is instead of
executing the function I am going to
return it my goal here is to execute
this
outside the context of this function the
function where it's actually declared it
okay so what I'm going to do is I'm
going to return it here and then I'm
going to execute it somewhere else all
right so now that outer is returning a
function I'm going to hold on to that
return value in available so I'm going
to save our inner function equals outer
okay now inner function is going to get
a value which is this function object
because this is what the execution of
outer is gonna deduct see we are
returning this here which happens to be
this function so when outer executes to
return that function and then inner
function is going to point to this
function all right now that inner
function is a variable which contains a
function I can execute it like this all
right now let me ask you this what
should get printed if line 17 executes
all right so all this thing happens line
15 execute and get the inner function
back and now I execute the inner
function what should get printed let's
reload and run the first let me clear
this out and I'm going to reload and run
goodd 10 and 20 get printed which kind
of seems obvious because well that's
what was printed before as well when you
executed inner directly now what you're
doing is you're doing one extra step
taking it into a variable outside and
then executing it but here is the thing
you need to remember there are two
variables being printed over here a and
B what's the scope of a a is a global so
I can access a over here from line 17
what is the scope of B B is in this
group of outer which was over here now
when outer executes B is valid right
over here line 15 you're executing outer
so B has a scope from this to this all
right so any time inside the execution
about where if you were to access B you
would get hold of this wait it will be
but now your cross line 15 and at line
17 there is no function alter that
exists anymore
it is just a declaration it's not
executing the function
so if it's not executing the function
out there is just executing this
anonymous function how does it possibly
able to print B because b is in the
function scope outer which doesn't exist
anymore whether the reason it works is
because JavaScript has the concept of
closure so what you're seeing here is
closure is an action what happens is
then JavaScript creates the scope chain
right we've looked at how the scope
chain works and how the compiler creates
all these different objects in the heap
which knows what the scope is what
javascript does is when it creates a
function no matter where it is really
maybe it's a function declaration or a
function expression when it creates this
function object it also remembers the
scope chain then that function was
declared or when the function was
assigned right so here there is a
function an anonymous function object
created over here and it's assigned to
inner now what gets assigned to inner is
a function object that contains not just
the function itself it also contains the
scope information so it remembers
everything in this scope at this point
of time when that function object is
being created
at the time the function object is
created there is a Barbie which is
training and there is a war here just
then right it knows that there are those
two variables and the thing is it
remembers it so no matter where you pass
this object right you pass inner here
you execute it completely outside or you
give it to some third-party library
doesn't matter that function has a
snapshot of the scope chain it knows
where each variable is that it needs to
point to okay so it always knows B and
it always knows a no matter where you
take it right this could be executing in
a completely different file right that
file may not even have a global a
doesn't matter the function inner
function the object always knows where
to go to access those variables and when
I say snapshot you need to remember that
it's not really a copy of those
variables that it it has it has a
pointer to the actual variables so no
matter where you send this function it's
actually pointing do the exact same a
and
that you see in this code so if it were
to modify the variables you could modify
the exact same variables okay so it
doesn't create a copy of these videos
it's pointing do this same one copy off
a and B this is how closures work so
what you're seeing here is actually a
closure a definition of a closure is a
function which remembers its scope okay
so we talked about the lexical scope in
JavaScript right we'll all the things
that we looked at for scoping how it
knows what different scopes are the
global and then the outer and the inner
it exactly it works exactly the same way
okay it's just that the function
remembers that thing and it remembers it
even if the function is being executed
in a different scope from where it is
declared okay so what the function
remembers is the scope during the time
off the declaration and that's what it
remembers if you were to take it outside
and executed somewhere else it does not
matter it still holds on to it okay so
that's the concept of closures</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>