<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Java 8 Lambda Basics 15 - Using Function Interfaces | Coder Coacher - Coaching Coders</title><meta content="Java 8 Lambda Basics 15 - Using Function Interfaces - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Java 8 Lambda Basics 15 - Using Function Interfaces</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yubVRLP9Htw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here's the tank this is the Java a
tree that we saw in the previous unit
this is the Java 7 B the one thing that
this has extra is this interface with
the condition that I was importing but
apart from that this is all the code
that we had to do in order to implement
all this stuff which is quite verbose in
the Java 7 approach Hindoo the java 8 up
which is much tighter because we have
lambda expressions in it so it's just
one line but if you think about the
interface itself what did we do we have
this condition here which had a boolean
test method and it took in a person
instance this seems like extra work for
what we're trying to do here we are
looking to pass in a condition we don't
really care about what this condition
interface is called as this could be
called foo and it would still work right
so this we call this is foo this is just
a variable and this method could be
called for us as well and we could just
execute it it really doesn't matter what
the name of the interface is and what
the name of the method is but we still
had to specify a specific method on a
specific interface because we had to
specify that as the type so it feels
like we have defining this interface as
kind of an or head wouldn't it be nice
if we didn't have to do this so to just
write the lambda expression and somehow
create a type for this you remember I
told you that Java 8 does not have a
function type they haven't created a new
type called function we are leveraging
the concept of interface but what the
Java language designers have done is
they've actually created some
out-of-the-box interfaces to address
some of these common scenarios see
condition is a common thing even when I
write code which accepts some kind of a
condition like this does a test takes in
an input object and it returns whether
it's a true or a false right this is a
common scenario there are other
scenarios like this maybe there is a
function which takes in an object and it
just prints something to the console so
it's basically an interface in that case
which which contains a method which
takes in an object and writter terms of
wide we've already seen that before so
there are all these common bad
which the Java language designers have
said an interface when you have all
those common patterns just use some
out-of-the-box interfaces so in Java 8
there is a specific package called
functions
so it's Java util dot functions which
contain some out-of-the-box interfaces
now here is the Java Doc's for Java util
that function you can see here there's a
bunch of different interfaces over here
so let's take this example of a
predicate to a predicate as an interface
which is a generic interface which
represents a predicate boolean valued
function of one argument it's not very
helpful so let's look at the details so
the predicate interface contains the
method called test ignore the other
methods for now they're either default
are they're static so this is the only
method that is an abstract method there
is a method called test which takes in
an object of type T's it's a generic
type and it returns a boolean so if you
were to ever need a lambda expression
that takes in an object and returns a
boolean so you don't have to create a
new interface Pritikin you just use the
predicate interface it comes out of the
box so in this case that's what we're
doing here if we are doing a condition
that s so the condition interface is
kind of like a predicate it takes in an
object and it returns a boolean in this
case it takes an object of type person
but since the predicate interface is a
generic type we can have the generic
type be person and store words so let's
try that out here so rather than have
this be a condition what I'm going to do
is I'm going to make this a predicate
back predicate I'll call this predicate
now predicate is a generic type first
let me import it from Java ready to the
function and now since it's a generic
type what I'll do is I'll make this off
type person
now predicate will have a method mean
take this out dot best and here you see
it takes in a person instance I'm going
to pass in P now notice what happens
there's no compilation error I didn't
have to change the code that
this method you see I just changed the
method itself because the code that
called the method is a lambda expression
this is a lambda expression this is a
lambda expression and as far as the
lambda expression is concerned it
doesn't really care what the interface
is as long as this signature of the
abstract method in the interface matches
the signature of this lambda expression
what's the lambda expression doing it's
just taking an object and returning a
boolean which works just fine because
that's exactly what the predicate
interface does it has a method called
test which takes in an object and
returns a boolean so these are some
out-of-the-box interfaces that come with
Java to handle some common scenarios so
if you look at the package itself there
are a lot of these out-of-the-box
interfaces some other examples are
something called supplier a supplier is
something that doesn't take in any input
but it returns an object of type T so it
can be customized to anything that you
want there is also a function which is a
you know generic type of two types which
basically takes in an input and it
returns an output so this is the only
abstract method here everything else is
as you can see default or static if it
takes in a type and it returns another
type so these are common scenarios now
since these are generic types they will
work for the types that you are
concerned with so you can use them when
you have such farm and lambda expression
then you don't want to create a new
interface form so you remember I told
you in the previous unit that the first
step to creating a lambda expression is
to create an interface for it and define
a method in that interface which was
step two which has the same signature as
that lambda expression now here is a
further shortcut if you find an
interface in the Java dot util that
function package which pretty much
addresses the lambda expression that
you're writing well you don't have to
create the interface as well you can
just use these out-of-the-box interfaces
so let's make sure this works with the
predicate example so I'm going to run
this and now we see the things getting
printed all these person objects are
getting printed so it still works the
same
but we have not completely bypassed the
need to create an interface for this we
just have to find the right interface
from the java.util that function package
and we can just use that in the next
tutorial I'm gonna give you one more
example of how we can use some of these
functions to write more lambda
expressions without having the need to
declare an interface first</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>