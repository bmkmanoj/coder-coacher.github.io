<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Maven Tutorial 03-  Maven Build Phases | Coder Coacher - Coaching Coders</title><meta content="Maven Tutorial 03-  Maven Build Phases - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Maven Tutorial 03-  Maven Build Phases</b></h2><h5 class="post__date">2011-05-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IYRYbPR5Gek" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in a previous tutorial we looked at how
maven chooses the standard directory
structure and makes changes and
customizes the structure depending on
the archetype that you select in this
tutorial we're going to look at the
second half of the process which is the
build process once you have done the
coding and you want to actually build
and deploy the code you would use maven
again for this purpose and we look at
how maven helps us in this part of the
process so build was something that we
did using just a command or a couple of
commands have you gone through the
introduction tutorial we do the mvn
compile and we did a MV in package and
you know there is this one command took
care of the whole thing
that's because there's a lot of
intelligent defaults that's a that's set
up so we don't have to specify each and
everything if you can compare this with
something similar like and you would
have to specify each and everything that
you want and to do for example if you
have five classes you would have to
instruct ant to compile and package all
those five classes of course you don't
have to mention each class specifically
you can use wildcards but every step has
to be explicitly mentioned but in the
case of maven is that that's not the
case it has it has a standard directory
structure and it knows what needs to be
done one example that we have seen is
that we have two folders called the main
and the test so if the code is in the
main it assumes that to be the actual
application source code and if the code
is in the test folder then you know may
even assumes it to be test cases and
depending on that it compiles and it
packages the main source code it does
not package the test but it uses the
test to run test cases before we
actually package it so let's try to
understand what's happening there in a
bit more detail the maven build has
something called as a build lifecycle
and this is something that has been
defined as a part of the maven
architecture every build follows a
lifecycle indeed every build that we
would do without
without even considering maven we would
have a lifecycle for the build first we
would actually write the code and then
we would compile it we would run test
cases on it and we would probably
package it we would install it in a
particular you know repository or a
shared location where other developers
can use our binaries so there is there
is this step by step process that's
there for every build life cycle and
that's something that may even
understands and incorporates so maven
has an internal build life cycle itself
the build life cycle has been split into
different phases compile is a build
phase and test as a built phase so all
these phases together comprise of the
build life cycle in maven and if you do
not explicitly configure it
maven chooses the default build life
cycle we'll look at what the default
build life cycle is but we actually saw
that in action when we did a MV and
compile or when we did the env in
package so some of the phases have
default behavior I just talked about
compile compile takes the code in the
main directory and then it compiles it
assumes it to be application code and
the compiled assumes the you know the
code in the test directory to be test
cases so these this is the default
behavior that the compile phase has so
similar default behavior exists or even
in the other phases when we have all
these different build phases say for
example let's take three build phases
here we let's take compile test and
package in order to do a package you
would have to do a compile and test test
is not really necessary but it's ideal
you know if you're packaging a code you
would prefer that it be tested and it's
necessary that the code be compile so
the other default behavior that maven
has is once you specify a phase it
automatically executes the previous
phases so if you specify a package maven
automatically runs the compile phase and
the test phase so you don't have to
explicitly specify that
so now with this understanding let's
have a look at what the phases actually
are some of the phases that you would
commonly use in maven there's not a
comprehensive list but this is something
these are some of the phases that we
would use a lot so the first phase is
the validate phase you won't actually
explicitly call this but as we've
discussed some of the other phases that
we run automatically call the previous
phases so in that way validate the first
phase ends up getting called a lot
so what validate does is it checks if
everything is in order whether we have
the pym dot XML in place whether it's
all the configuration is proper whether
we have all the code in bra you know in
a proper way these kind of validation
checks are done in the validate phase so
once this is done we have the compile
phase we know very well what the compile
phase is it just takes all the dot Java
files and then it you know compiles it
into dot class files if we run the
compile phase directly it automatically
runs the validate phase because that's
the phase before this after this is a
test phase test is where we run the test
cases which we have specified for our
code say for example I have a my app dot
Java as my application class file and I
have a my app test dot Java as the test
case for my my app Java class so test
automatically knows that there is a test
case for the code that I'm trying to
compile so what it does is after
compilation it goes and pulls up all
those test cases and executes those test
cases so again if you specify tests
directly it makes sure that validate and
compile are run so next phase is the
package phase now you package the code
and in this sense you package all the
class files that come up and this phase
again executes all the other phases and
say test fails for example take a
package also fails and it says ok you
have you have a test case that's errored
out so if that's the case there's no
really no point in packaging the code
because it's probably a bug if all these
three phases execute successfully then
package happens package ends up in our
dart jar file or a dot
war or ER file depending on what we
specified in the Palm D'Or XML so this
will end up in the output artifact that
we intend to achieve by writing then
compiling the code so after package
there's one more phase and this is
called as the install phase what the
install phase does is after you've run
the package phase and generated the
artifact install installs that package
the artifact into a local maven
repository note that install here is not
installation into your server say for
example you're writing a web application
install does not mean you take the word
and install it into your Tomcat or any
other application server install is
maven specific here it actually installs
to a local maven repository most most of
the times the local maven repository is
on your machine itself and this is a
discussion we had in a previous tutorial
whenever we when we have dependencies
and whenever we need to reference other
artifacts that we have say one project
reference is called in another project a
jar which has been the output of another
build for example
so what maven does is maven first you
know when it sees a dependency it goes
and looks at local repository and if it
doesn't find it only then it goes to a
online repository and pulls up the jars
so install is something that helps you
to publish your jars into your local
repository so that if you are having a
dependency on another project it goes
and pulls it up from the local
repository itself and finally there is
one more phase which often ends up in a
lot of confusion because of the name
this phase is called as the deploy phase
again just like I mentioned for the
install the deploy does not deploy your
application server so you'd use the
deploy phase only if you're publishing
your artifact to the remote repository
where other users can download so this
is not something that you normally use
when you're developing applications
unless you are writing code that is on
the repository and can be shared with
others
so in order to run any of these phases
first we need to go to the directory
where we have the Palm D'Or XML validate
that so here we are we have the bounded
XML here and we have the source code as
well so this is the default directory
structure that we've got by selecting
the artifact that we did in a previous
tutorial so now that we are here in this
directory in order to run a fix
we need to type env in and the phase
name so for example I need to do a
compile so I type MVN compile so compile
checks for the projects it sees that
there is a dot bomb load XML in the same
directory and then it goes to the source
directory and then finds all the Java
files and then it compiles it here it's
found just one source file and it's
converted that to a class file and it is
saved it into the target class so here's
the target directory that's created by
the compile command so inside this
target directory you have a classes
folder and here we have our class file
dot Java converted to a dot class file
now let's say I want to run all the test
cases that I have written for this
application so what we need to do again
is MV in and run that phase name which
is test now maven is going to pull up
all the test cases that are available in
the test directory and run them so we
have only one test class which is the
app test it's a dummy class that me even
created for us we don't have anything so
it obviously is that the test has been
executed successfully now let's say I
want to package this I don't know m VN
package now note again that it's going
to do all the previous steps the compile
and the test so if you scroll up here
you can see first let's try to run the
compiled and then it says there is there
is a there are no classes left to
compile because it based on the time
stamp it sees that all the class
set up to date then it tries to run the
tests yes it does run the tests and you
know there is only one test case which
executes successfully and then after
that it tries to build the jar and it's
done that here it's built the jar and
it's placed it into the target directory
so if we look at that target directory
has the maven test at now if you look
here there are a few other directories
that have been created so we'll get back
to that some of these surefire
directories are related to the test and
there are few other directories here as
well we'll have a look at that in the
later tutorials but for now note that a
jar file is generated when you run the
package command now this jar file also
has the version number that we have
specified that's also there in the name
along with the with the artifact name
itself now after this is done and I want
to install this when I do an install it
publishes this jar file into the local
repository again it does not start from
the publishing it actually starts from
the first phase which is validate it
runs through all the steps again in some
steps in a for example in the case of a
compile it can bypass that step because
it notices that all the classes have
been compiled but test cases I believe
will run every time so there are some
steps which will be skipped but it makes
sure that all the steps are considered
one after the other
before the step that we are trying to
execute runs so now in the case of a
install again you can see it runs all
the previous steps
it runs the compile it is running the
test
now here it's running the install step
and you can see it's downloaded a few
components from the remote repository
and then finally it has actually
installed it I think this is downloading
this because this is the first time I've
run an install on this machine so if you
if you're running it for the second time
you do not see the downloading part but
you would see this part see you see here
it's installed the char to this
directory so it's in my home folder dot
m2 and repository and then again you
have the package folder structure and I
have my application name here and the
version and then the jar file with the
same name that we've seen earlier so
this again a handy way to check where
exactly are jar files are being
published in the local repository you
can open up this local repository
directory and have a look at this you
can see a few more things all the
downloads that you see here will go to
the local repository and it will be
saved in a similar file and folder
structure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>