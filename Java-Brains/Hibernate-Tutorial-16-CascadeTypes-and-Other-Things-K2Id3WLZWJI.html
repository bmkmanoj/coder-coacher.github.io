<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate Tutorial 16 - CascadeTypes and Other Things | Coder Coacher - Coaching Coders</title><meta content="Hibernate Tutorial 16 - CascadeTypes and Other Things - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hibernate Tutorial 16 - CascadeTypes and Other Things</b></h2><h5 class="post__date">2011-05-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/K2Id3WLZWJI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial we've
covered the relationships between
entities the one-to-one one-to-many and
minute 1 and many-to-many in our
previous few tutorials and this tutorial
we're going to look at a few concepts
that are common across most of these
relationships and you know we will cover
a lot of concert theories are the
miscellaneous concepts which kind of fit
at different places so just wanted to
take a separate tutorial and cover some
of these concepts here so okay let's go
so the first one is the first one that I
want to cover is this annotation here
let's take this example say I have a
mini two menu here and let's assume this
was a one-to-many or let's take the
vehicle object and take this is a mini
two one see this now and this was this
would be a private user details use it
okay now assume that this car is not
this vehicle is not having an owner okay
they do I mean this vehicle is not yet
rented or not it purchased so there is
no user for this vehicle so now what
would happen if you had a mini two one
Association here and say you had the
getters and setters forget get user and
set user now imagine if your code would
get the vehicle and try to do a get user
and there was no Association for this
vehicle in the user mapping say there
was no user for this vehicle then
hibernate would throw an exception it
would say hey I don't have a user for
this vehicle so a get user for a vehicle
object which does not have a user would
throw an exception so there is a way we
can suppress this exception so that you
know it does not happen it does not come
up with an error every time there you
know the data is not there and if it's a
common situation for the data not to be
present at any point of time
then you can prevent all these exception
errors coming up by using an annotation
here called add not found okay so what
I'm doing is I'm saying if this is not
formed if the user is not found then
what do okay so if I import this you can
see this is a ARB dot hibernated
annotations so this is not a GPA
standard this is a feature that Hibernia
provides but I have found this very
handy especially if you are working on
old systems where you didn't actually
have data from the scratch that supplied
by hibernate it was it with some legacy
data and you might not have all the
relationships available so in that case
what you do is you can use this at not
found annotation to treat to handle
situations where there is no such
relationship available so what you can
do is add not formed you will have to
give what is called as an action
property so if the you know the
relationship is not formed then what you
need to do you need to do this action
equals there is a not found action
enumeration dot ignore so not found
action has this ignore enumeration so
what happens is if your user is not
found then you're telling happening to
just ignore it not throw an exception so
this is something that I found very
handy and just wanted to you know throw
this concept in there so that if you
feel that you might you know you might
come across such not found exceptions if
you want to handle it gracefully this is
one way you can can actually handle that
okay the next thing that we're going to
talk about are the collection objects
that hibernate supports so hibernate has
its own internal data types that it maps
to for the collection objects that
you're creating and there are a few
semantics for collections that are that
are you know available in hibernate so
the first semantics is the bag semantics
hibernate has a bag kind of a collection
object that it supports so what a bag
means is you know it doesn't it's it's a
similar to a you know
realize bag it doesn't matter how you
put things inside it you can you can we
know put things into a bag in any order
you can retrieve it in any order so that
is a bag semantics that happen it's
opposed so you can implement a bag
semantics by using either a list or an
ArrayList and similar to a bag we also
have a bag with an ID again this is
something that we can use with it is
less than ordinary lists so a list or an
ArrayList will have an index property so
what you're doing is you can you know
pull up items depending on the ID that
your you're supplying so the next one is
a list semantics so this is again a list
or an ArrayList it's the same thing the
only difference that that is applicable
from a list or a bag is that a list can
be ordered you can have a sorted list
whereas a bag you know it really doesn't
matter which order in which you get the
data the next one is a set semantics
we've seen a set this is similar to a
set data type in Java so I'm not going
to go into much details and then finally
a map again this is similar to a map
data type of Java okay you don't have to
actually worry about the semantics
what what what usually happens is you'll
be working on one of these data types
here you'll probably have a list of
objects or you know a set of objects or
a map of objects so what's happening is
hibernate is using one of these
semantics behind the scenes in order to
maintain the collection okay so the
final thing that I want to talk about is
something called as a cascade this is
applicable to all the relationships be
one-to-one one-to-many many-to-one or
many to many so we'll have a look at
what cascade means here let me just undo
the changes that I've done okay and I'll
save this user details
you haven't modified this so yeah what
does cascade mean
say for example I have this you know
this program where I have a user
and let's say this user has ten makers
or something like that so I will have
all the ten vehicle objects and I will
assign those vehicle objects to the to
the user so now if I have to save the
user so what I'd have to do is I'd have
to first do a session dot save of user
and I'll have to do a session dot save
of all the vehicles of the user say I
have ten makers or 50 vehicles saving
all of them is going to make the code
look messy and it's also a pain so it's
not just for saving say for example you
delete the user and you want to go ahead
and delete all the all the vehicles
associated with the user we haven't seen
how to delete a value we'll have a look
at that subsequently but you know you
should note that whatever operation you
are doing for the user you will have to
do all the operations you know you have
to do the same operation for all the
vehicles so a save or an update or you
know creation will affect all the
vehicles so you have to pass all these
vehicle objects to a session dot save so
there is a way to avoid this and we can
use something called as a cascade so
have the user derails class and the
rated class here this is the same two
classes that we've been looking at in
the previous tutorials the change that
I've made in the user details classes
have changed to a one-to-many this was a
mini to many you know at the end of our
previous tutorial so I've changed us to
one-to-many and I have a vehicle
collection inside the user object and in
the vehicle there is no backwards
reference there is no inverse reference
from the vehicle you cannot go to our
user it's just from the user to the
vehicle so this is a one-to-many
relationship which is which is a classic
scenario to study the cascading that we
are about to learn so we have the saw
vehicle collection they have implemented
an ArrayList here now what I want to do
is when I want to create here is our you
know the test class that we run we have
a user object here and we have to wake
up objects so we assign the vehicles to
this user so
- and jeep are the two vehicles that
have been assigned to the to the vehicle
collection in the user so this
collection here will have two values
which are the two vehicles car and Jeep
now when I save this I am saving user
the vehicle one and vehicle two which is
you know the car object as well as the
Jeep objects so what happens if I just
save the user isn't that enough let's
let's remove this these two lines so the
user has a reference to both the car
object and the Jeep object but I'm not
explicitly saving the car object in the
Jeep object now what happens if I run
this let's save and run let's see what
happens so here you can see there is an
exception it says object references and
unsaved transient instance so it's
asking us to save the transient instance
instance before flushing so what this is
saying is you have an object that you
are trying to save
but this object reference is another
object that you have not saved so we
need to make sure that those objects are
saved as well so this is the problem why
does hibernate not automatically save it
we know that this user has two
references one is a vehicle and vehicle
two which is the car in the Jeep objects
now why does hibernate not save it
directly that's because these are also
entities this vehicle is an entity this
vehicle is again another entity
now hibernate cannot make that
assumption and save the entity because
you know that might be something that
you would want to do differently you
know sometimes you wouldn't want to save
these entities automatically you would
want to have control over it now if it
were a collection object let's say this
weren't an entity it was just a value
type then this vehicle would the whole
purpose of this vehicle would be for
this user so it makes sense when the
user is saved you save that vehicle also
but since it's not a value type it's an
entity these two vehicles have a life of
its own it's not really bound by the
user so you wouldn't want an automatic
save or an automatic any operation to
happen
so that's a reason why hibernate gives
this the benefit of the doubt and then
it does not do any automatic saving it
you know it wants us to specify when and
how this needs to be saved so which is
fine we we did this earlier so what we
did was we did a session dot save off
both the vehicles now the problem is if
you have a huge list of objects here you
would have to do a session to out save
of all of them and that's a pain so
that's what we're going to avoid by
using the Cascade so what I do is in the
user details wherever I have this
reference you know I'm saying this is a
one-to-many relationship with the
vehicle so here I will have to tell
hibernate saying hey I do not want to
save each and every object here if you
come across this collection and you have
unsaved objects when I am doing a save
for this user class go ahead and save
all the objects in this collection as
well so that's what I want to say and I
say that using the Cascade so the
one-to-many annotation has a property
called Cascade equals and again there is
a there is an enumeration that supplies
the values so I have Cascade type dot
okay so here you see there are a few
options you have detach merge persist
refresh and remove we will look at all
the other things later but right now we
want the gas scaling to happen on save
when you want to save the user it has to
save the corresponding vehicle instances
so I will have to select this persist
so busses tells hibernate that if you
see any new entities inside this you
know the vehicle collection which has
not been saved when the user is being
saved go ahead and save them as well so
this is what the Cascade dot persist
means okay now we are actually all set
to run this but there is one other small
change that we'll have to make i'll make
the change now and we'll learn a bit
more about this in the later tutorials
so here where we have a session dot save
instead of a dot save I will call
another method of the session which is
busses now a persist kind of does the
same thing as what I saved us but there
a few differences and this is something
that we'll explore in the upcoming
tutorials but for now just make this
change this change session diaper cyst
Tizen with this change that we have made
to gas Kade persist
so whenever a birth cyst happens a
cascade needs to happen so that's what
we are doing here we are saying hey
hibernate passes this collection when
you are persisting this entity and when
we are actually saving this we are
calling this session dot vs. that that
ensures that this user is persistent so
again we will look at the difference
between persist and save later on but
for now let's make this change and save
and run this up there you go you do not
see that error anymore and even though
we are not saving the vehicle objects it
is inserting values into the vehicle and
it's also inserting the mappings so this
gasket update process is one of the
different cascade types now you can have
a cascade type dot remove which you know
there's a gasket for delete operations
and again margin detach are things that
we are going to explore later when we
when we look at the lifecycle off of
entity objects that's when we're going
to learn a bit more about purses and
fresh as well and the final thing is if
you want all persistence to happen I
mean everything to happen cascaded all
operations need to be cascaded whether
it's creation or a deletion or updating
anything like that if you want all these
to apply then you can choose a cascade
type dot all so what this mixture is
that instead of specifying each and
every individual operation you say
cascade everything so no matter what
happens to the user
entity the same thing gets propagated to
the vehicle entities as well so the
Cascade type dot all it's kind of like a
shortcut so that you don't have to enter
all the individual cascade types</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>