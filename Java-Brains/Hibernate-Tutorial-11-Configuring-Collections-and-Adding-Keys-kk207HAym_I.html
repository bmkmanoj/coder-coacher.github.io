<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hibernate Tutorial 11 - Configuring Collections and Adding Keys | Coder Coacher - Coaching Coders</title><meta content="Hibernate Tutorial 11 - Configuring Collections and Adding Keys - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hibernate Tutorial 11 - Configuring Collections and Adding Keys</b></h2><h5 class="post__date">2011-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kk207HAym_I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial in our
previous tutorial video out a collection
of objects in our entity class and we
person said it in a separate table we're
going to look at some ways we can tweak
the collection object here we can tweak
the very hibernate saves this collection
and we'll also explore some advanced
options so the first thing is the name
of the table hibernate has given this
name for us it's the class name user
details underscore the you know the
member variable name list of addresses
say I want to tweak this this is not a
very user friendly name I want to have
the name as user underscore address so
all I do is add an annotation here pad
join table we import this and what I'm
mentioning here is the configuration for
this join table join table as this one
their user details underscore list of
addresses so I'm just using the join
table annotation to configure it the
join table is not mandatory as we've
already seen without this join table
configuration there are defaults that
happen in goes for including the name
and a few other things and which is fine
but if want to configure it you would
use this annotation so then you know the
configuration that I want to do here is
name equals user address that's so on
top of the the collection declaration in
the definition I just use the join table
annotation save and run you can see the
table name has changed its now user
underscore address okay now how about
this primary key when this is a this
doesn't look very good it's a user
details underscore user ID which is the
key again how it's got this key name is
by using
this class named user details underscore
the primary key name of this class which
is user ID so this is again the default
and we can all write this so what I do
is inside this joint able annotation I
will add a comma here and I will add a
join columns equals add join column and
now I can give a name here and other the
name be user ID itself okay I will have
to import me remove this so that it
gives me the autosuggestion then this
just a shortcut there okay so what i'm
doing here is the join table has a
property college are in columns and the
join columns takes a join column
annotation now i can define a new join
column annotation with this name so that
the join column that's used inside this
drawing table will be this gen column
here so clear this out save and again
run this
there you go you know the prayer
reference ID this is again the foreign
key is it was earlier the class name
underscore user ID now it's just user
underscore ID so this has you know this
is the join call that it's taken okay
the next week that we can do um let's
have a look at this table here okay this
is no longer with this name let's use an
underscore address okay now have this
table here we have a foreign key which
is user ID but this table does not have
a primary key there's no index column
here now what if you want to define an
index an ID for this table you want to
define an ID for a collection which is
inside your entity class so in order to
have an index column I need to have a
data type that supports index I cannot
use a hash set because there's no
there's no index supported in the hash
set so the first thing I will do is I
will change this from a set to a
collection I'll probably implement
implement an ArrayList ArrayList is a
good option because you have indexes and
erases so ArrayList arrays are all
possible options so I'll just go with an
ArrayList this time I'll again declare
that the interface I am NOT going to
declare the array list here my list of
addresses will not be in at list it will
be difficult as the interface collection
now we import this now from Java dot
util the reason why we are reason why we
write the interface here and not the
implementation will be clear in our next
tutorial where we're going to talk about
eager and lazy loading of objects this
is this is a very important concept and
we're going to cover that in the next
tutorial but for now note that this is
is always going to be an interface
when you are defining when you say new
that's when you have an implementation
so I'll see a tray list so I have
defined this as an ArrayList now I'll
update the getters and setters okay so
now I have an ArrayList having the list
of addresses this will not change it
will still be get list of addresses
start ad because we are putting the
object using the interface method that
will still be a dot ad and it will take
object as a parameter so it instead of
adding to a set now it's adding to a a
collection which is another distance
case now what I need to do here is I
need to define the primary key
configuration here so the way I do that
is by using this annotation call ad
collection ID now this ad collection ID
is unique in that it is not a JPA
annotation so far whenever we've been
doing imports for the annotations we
have been importing from Java X toward
persistence you see here all the
annotations that we have have imported
in the past they're all from Java extra
persistence what this means is that
whatever annotations that we have
written so far are all compliant with
the Jaypee standard the JPA standard is
the standard that has been specified for
persistence implementations by a
standard body and now what we are doing
is we are not using the JPA annotation
we are using something specific to
hibernate
now hibernate implements the JPA
standard so even though we're using the
Jaypee annotations the implementer of
all these is hibernate because we've
added the hibernate library so when we
say do our table hibernate reads this
add table and
hey I need to create this table so even
though the specification is JPA the
implementer is hibernate but in this
case this feature is not provided by GP
this feature is additional feature
provided by hibernate alone so if you're
if you're changing your implementer from
hibernate to something else
all these others would work provided the
implement GPA but this would not work
because this is specific to hibernate
but which is fine you can you can use
features that are specifically provided
by hibernate but it's always better to
use a JPA standard because that'll leave
us with less things to change then we
move from one you know GPA provider to
another GPA provider it's already
imported it here it says all dot
hibernate tell annotations dot
collection ID now what this means is
that the collection ID annotation is not
from Java X dot persistence the
collection ID annotation is from orb dot
hibernate or annotations or it's an
annotation specific to hibernate alone
ok now here I'll do this add missing
attributes now these are the attributes
that the collection ID expects first of
all the columns what is the column that
you want to define that's the primary
key next thing is the generator how is
the gender is the primary key to be
generated and the third thing is the
type what is the type of the primary key
now this is me start with the first one
so they'll use the add column annotation
to define name equals I'll call this
address ID so what I'm doing is I'm
giving a name for this ID which is going
to list all the the collection of
addresses so I'll call this the address
ID so for generator I will define a new
generator here I'll call this the at
generic generator now
import this again you notice this is
from our dot hibernated annotation so we
going deep into hibernate editorial
where we are away from the standard JP
annotations now the generator you think
all this in name I'll call this hi-low
Jen and let's say strategy equals
high-low so high-low is a is common
generator type which hibernate supplies
so I'm going to use that and here in my
collection ID annotation I will provide
this generator name so I will call this
high-low Jen ok so now this leaves us
with the last one which is the type so
it has type equals ad type ad type is
again that annotation in order to define
the type of the of the you know the
primary key column that we are entering
here so I will have this type as type
equals I will make this a long so it so
the you know the primary key column is
going to be long okay in summary in
order to have a collection of objects as
a member variable inside your entity
class the first thing you need to do is
switching is a data type of the
collection to something that supports
IDs it's something that suppose indexes
and an ArrayList supports indexes I'm
going to use an array list now so again
I change this one to an interface which
is Safari list and I'm an interface
which are a list as implementing which
is collection so write that here now I
have you know a list which supports
indexes the next thing I do is I define
this add collection ID annotation of the
add collection ID annotation tells that
this collection should have an
identifier now the add collection ID
properties which define what the
identifier should be first of all I
define the column which is address
underscore ID the identifier should have
a column name of course so that column
is are you know listed here next thing
is the type what is the type of the
identifier I want this to be a long and
the third thing is what is the generator
see this this ID is not present here
address does not have an ID so I cannot
really set the ID it has to be
auto-generated now in order to generate
it what I do is I define the generator
which is a high low high low is one type
of generator that hibernate provides so
I define a generator which is a high low
and then once I've defined the generator
I can use this in many places here I'm
going to use it for the generator tag
and I'm saying generator is high low
which says use this generator in order
to generate the primary key for this
address ID which is an index for this
list of addresses and alkane has we
discussed all these are hibernate
annotations which means that they are
org dot hibernate or annotations import
they are not JPA standard so if you
change your provider from hibernate to
something else then you will have to
modify this but we need to learn this as
well because these are the features have
happen it provides and you know it's a
there's no point in not using me some of
these if they're helpful even though
they are not JP standard so let me save
this and I'll run this again you know
let's see how it's created so here you
can see address ID has been created and
the values 1 and 2 have been entered so
this has been auto-generated so now I
have a primary key for my address stable
and depending on how many of our values
insert the user ID is going to be a
foreign key depending on the user that
the addresses are assigned to this value
will be different and multiple rows
could have the same user ID but this
will always be your cue
Collin will have unique values and you
can this will be the primary key for
this table</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>