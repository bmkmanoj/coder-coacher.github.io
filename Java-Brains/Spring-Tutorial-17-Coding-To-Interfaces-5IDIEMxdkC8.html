<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 17 - Coding To Interfaces | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 17 - Coding To Interfaces - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 17 - Coding To Interfaces</b></h2><h5 class="post__date">2011-07-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5IDIEMxdkC8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome to this tutorial in the
last few set of tutorials we've seen
some of the basics of Spring Framework
and we've seen what are the features
that spring framework has when it comes
to injecting beans into your classes
injecting dependencies into your classes
but in this tutorial let's let's go back
to the first tutorial which started off
the series we were talking about
dependency injection with an example of
a shape interface and then two different
shapes a triangle and a circle notice
what we have do what you're doing here
we have a drawing application that is
dependent on the strai angle object I
have a triangle class here and my
drawing application this class is
dependent on the triangle class and I'm
using the give beam of spring in order
to inject this dependency in order to
get the dependency instead of having a
new to instantiate the triangle now this
is fine this works fine but in order to
utilize the true power of dependency
injection in order to make it more
extensible in the future we need to do
what's popularly called as coding two
interfaces what this means is instead of
having an instance of the beam itself
directly what you do is you have an
interface and then you use the interface
and not the beam inside this class and
of course the advantage is that the
drawing application class does not have
to know whether it's calling a draw
method off the triangle or any other
shape it just works on the interface so
that's the concept of coding two
interfaces we'll implement that in this
tutorial what I'm going to do is I'm
going to create an interface called
shape create a new interface I'll call
this shape and I'll define a simple
method here public void
drop now this is a method that all my
shape objects have to implement so let's
save this now I have a triangle shape
here I will see this implements shape
okay and of course it already has a draw
method so be good that now the
advantages now let's say I have another
shape object let me let me create a
circle object here circle and this
implements shape and now I have to add
the draw method here okay I will say
okay let me just create a point object
here
okay and I will generate the Gators and
setters okay and now in my drama that
I'll just print out this point here so
your system dot out dot print chart get
why of course let me climb this is
around this that's it
so I'm just printing out the this into
point for this circle and in my triangle
draw method I will write call this
drawing a triangle
and that's straightforward enough I have
a triangle which is dependent on three
points and how it has a draw method and
I have a circle which is it has just one
point and it has a draw method and both
of them have a draw method because they
implement a shape interface which has
defined this draw method okay now what I
need to do is for every object that I
define I need to write the beam
definition in the spring XML so let me
just copy this and I'll define the
circle as well call this circle and then
it has only one point property and it's
the center okay so so far rear this is
all fine we have two classes over here
to shape classes one is a triangle and
one is a circle both them implementing
shape and I have defined the
dependencies for both of them over here
now if I if I need to draw a triangle so
this is the code that I have to write
and then when I run it I get a triangle
and now if I need to draw a circle I
would try it
circle and then of course I will have to
cast this to a circle
and then get the circle checked itself
and then I do a circle dot draw
okay now if I run this I'll be drawing
the circle now if you have to go by
interface what I would do is instead of
you know instead of having a circle or a
triangle here what I'd do is I'd have a
shape instead so I am coding to the
interface not to the specific
implementation and then here I do a
shape dot draw okay now the advantage is
obvious now if I am doing a good beam of
circle it draws a circle if I'm doing a
get beam off triangle it draws a
triangle so the advantage here is that
the drawing application does not know
whether it's drawing a circle or a
triangle or any other shape all it knows
is that it is getting a beam which
implements the shape interface and then
it's calling a method of the shape
interface so the other advantage is
later tomorrow if you have you need to
add a new class so you need to add a
rectangle class as long as it implements
the shape interface you just drop the
class in there and then you add these
configuration so you you call this as
say shape for example and then the shape
has been defined as a circle in this
instance you can later modify it and add
new implementations of the shape
interface and then all you need to do is
you need to change just the class over
here let's say I have this as shape all
you need to do is modify just this beam
definition you add the right class and
then you satisfy the properties and then
the drawing application is going to draw
different shapes which were not even
there when this application was first
coated and all that's happening because
you're just concerned with the methods
of the interface itself and not the
methods of the individual
chicks that implement that interface so
this is the main advantage of coding by
interfaces and what this translates to
is in your application normally you
would have say business services or do
layers what you would do is instead of
having a say of you layer data click
call a business service object what you
would do is you would have an interface
for the business service and then you
would call the methods of that interface
and then the implementation would be
later plugged in with the specific
business service implementation that
you've coded and then if you want to
change it later you don't have to change
the view layer for example you have to
just add the new business service
implementation and then rewire it in
your spring XML and then you're good to
go
so this is this is a very good practice
to implement you know when you've you're
doing dependency injection always use
interfaces so that if you change the
implementation you don't have to change
the actual class which depends on which
depends on this interface you just plug
in the new implementation and then you
know change the wiring so that the class
can use the new implementation</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>