<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Objects and Prototypes In-depth 06 - Switching function types and calls | Coder Coacher - Coaching Coders</title><meta content="Objects and Prototypes In-depth 06 - Switching function types and calls - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Objects and Prototypes In-depth 06 - Switching function types and calls</b></h2><h5 class="post__date">2016-07-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hKJ6b-Z5Z3U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so here is the constructor way of
creating the bicycle object and here is
the normal function which initializes a
bicycle object and returns it I told you
that a function that was meant to be
called as a constructor should be called
as a constructor using the new keyword
and a function that is not meant to be
called as a constructor should just be
called as a simple function without the
new keyword so in this tutorial we'll
understand what happens if you switch
the two what if I call this function
using the new keyword and I call this
function without using the new keyword I
think you can guess what's going to
happen but let's test our hypothesis so
let's start with the first one I have
this create bicycle call with the
parameters and the create bicycle
function is a simple regular function
which creates an object and then
explicitly it returns it so we don't
need a new keyword here because this
this function is doing everything on its
own so all I need to do is call that
function without any extra special
treatment last in the arguments and it
does the work and initializes the object
for you but now the question that I have
is what happens if I use the new keyword
here let me clear this out we don't need
bicycle too so what happens if I say new
create bicycle can you guess what's
gonna happen you remember I told you
that when there is this new keyword
added in front of a function and
execution a function call JavaScript
inserts a couple of lines of code button
to the beginning in one to the end so
you can think of it as JavaScript adding
a for this equals an empty object and at
the end it has a return this but now
knowing that there are these two lines
added over here how do you think it
affects what gets returned over here to
bicycle one well the first line of code
is pretty much like there is it this
variable which contains an empty object
but we are not really using with this
over here you see create bicycle does
not use it this so even if you were to
use the new keyword the first part of it
the first line that it injects is more
or less wasted your JavaScript says hey
there is a new keyword so it has to
create this
variable called this initialize it to an
empty object javascript does it but
you're not doing anything with it so
it's more or less wasted but you know if
the execute your line of code over here
and then here at line eleven which sees
return new bicycle so it returns the
object that you initialize not that this
okay it returns the object that you
initialize and the line that it adds at
the end is a cane wasted because at line
eleven you already returned so line
twelve is essentially and Noah
nothing happens over here so what gets
returned over here is the new bicycle
that you've already you know you
eventual eyes and you already populated
so this is essentially off no use when
you're doing a new over here so it still
works when you say new create bicycle
it's basically the new bicycle that
you've created over here which gets
returned and assigned to bicycle one all
the extra stuff that JavaScript does you
know these two lines
thanks to the new is essentially useless
all right so this is something that you
would not want to do because you're
basically having javascript interpreter
do some extra stuff thanks to this new
keyword but you're not using that extra
stuff
so you wouldn't typically want to call a
regular function with the new keyword
but even if you do it is fine it'll
still work all right so let's execute
this reload and run and if I open my
console and try to get bicycle one you
see I still get this object with the
properties that are missing over here
only thing is with the new keyword
you're asking the JavaScript interpreter
to do extra stuff that we are
essentially ignoring so not the end of
the world right it's not idea you're
having JavaScript do all that effort to
create a new object and then try to
return it but it's all in vain so don't
do that but it's even if you were to do
it it's going to work fine now let's
look at the other way let's look at
trying to call a function that was meant
to be called as a constructor but let's
call it as a regular function without
using a new key
right I'm going to remove the new
keyboard over here so I'm calling this
constructor function as a regular
function now what's going to happen it's
going to be the value of bicycle three
will it still be the object then let's
see since I'm calling this function
without the new keyword the JavaScript
interpreter does execute this as a
regular function it doesn't add these
two lines of code remember this this was
thanks to a new keyword but now that I'm
removing the new keyword the JavaScript
interpreter is just going to execute the
code that you have written all right and
let's see what the code you've written
does it makes a call over here to
bicycle and it has these three arguments
and now what does it do the first line
says this start cadence equals cadence
now what is the value of this since it
has not initialized this to anything
right
like it does with the constructor this
actually refers to what this was
referring to before and that in this
case happens to be a global object and
we are wondering how do you know that
this here is a global object well I'm
going to talk about that in the next
couple of videos but the idea is at this
point of time you're not changing the
value of this so the reference this is
basically whatever it was at that point
of time so at this point of time it
happens to be the global object right
we'll cover why later but you're gonna
have to trust me on this at this point
so this happens to be a global object so
when you do this dart cadence equals
cadence it's creating a property called
cadence on the global object this does
feel equal speed creates property speed
and this creates a property care on the
global object and it sets these three
values on the global object and now what
is getting returned there is no return
value here there was formerly a return
value thanks to the new operator because
JavaScript interpreter added that return
value per return test but since you're
not using the new keyword here there is
no return so when you execute a function
that does not have an explicit return in
JavaScript and you get hold off the
return value and assign it to a variable
what would that very book contain it
would actually contain
because that's the behavior of
JavaScript functions if you don't return
anything explicitly the function by
default returns the value undefined so
in this case bicycle 3 is going to
contain undefined because you've removed
the new keyword over here which caused
the interpreter to do two important
things that were necessary for this
function to work all right
so let's run this and I'm going to prove
by accessing bicycle 3 and you can see
that it's undefined because hey there is
no new object being created and be
whatever you're doing over here is
somewhere else and it's not returning
anything so basically just because then
define so again the thing to learn from
what you've seen here is it's not a good
idea to mix these things up you create a
function with a specific usage more in
mind you either create it as like a
factory function where you call a
function normally are you created as a
constructor function in which case the
user has to call it using the new
keyword so that's actually the reason
why you have this convention it becomes
obvious how to call a function and you
always make sure you use the right mode
to call the right function</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>