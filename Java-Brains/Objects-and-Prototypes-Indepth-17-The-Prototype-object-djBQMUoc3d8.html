<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Objects and Prototypes In-depth 17 - The Prototype object | Coder Coacher - Coaching Coders</title><meta content="Objects and Prototypes In-depth 17 - The Prototype object - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Objects and Prototypes In-depth 17 - The Prototype object</b></h2><h5 class="post__date">2016-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/djBQMUoc3d8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay now you're all set to unwrap the
last couple of layers of object-oriented
JavaScript and I'm going to start by the
employee example again so let's say I
have a function employee which is just
an empty function for now that should be
good
and I'm going to have a new EMP equals
sorry why am p equals new employee now
what are the objects that are created as
a result of these couple of lines of
JavaScript that I've added one is the
employee function object of course and
then there is the prototype object for
employee and now I have the EMP which is
created using new employee who's done
two proto binds to the employees
prototype so I'm sure you would agree
that the picture looks something like
this it's the employee function the
employees prototype and then an instance
was done the proto points to the
prototype now remember in the last video
I told you how if you are not using an
explicit constructor then there is this
default constructor or function which is
the object function and that happens for
any for any object that's created
without an explicit constructor function
now this EMP object was created by
calling new on this employee function so
this has a deliberative which points to
this prototype but what you should
realize is that the employees prototype
object this one over here there's
actually an object as well right so this
is an object which we didn't create by
calling a new on anything so now the
question is what was the function that
created this object well turns out
whenever there is a prototype object
that's created for a function that you
would write this prototype is actually
created by calling new object so since
this is an automatic object that was
created this is called using new object
which is the object function in
constructor mode so this turns out as a
dunder proto property as well which
points to the object prototype so this
is similar to just creating an object
using double curlies it's done the
proto-tool prototype okay so this is
happening behind the scenes you didn't
create this prototype object was created
for you when you created the imply
function so when this prototype object
was created for you it was created using
the object function and constructor more
which is why the dunder proto binds to
the object prototype so what you have
here is kind of like a hierarchy so you
have your employee object whose dunder
proto points to the employees prototype
and employee prototypes dunder proto
the prototype now that you have this
picture in mind let's say I make a
property reference on the EMP object
that we just created let's say I do
something like this
EMP dot test well I get back undefined
and you've seen that how the JavaScript
engine checks EMP first and if it
doesn't find it it checks the MPS
prototype object using tender proto and
if it doesn't find that that's where do
you get back and the fine if I were to
switch to the diagram again the
JavaScript engine first checks this
object say hey EMP do you have a
property call test doesn't find it it
goes to the subject hey implies
prototype object do you have a property
called test well if it doesn't find it
guess what happens this is still an
object reference so this way the
JavaScript engine checking this is no
different from the JavaScript engine
checking this just wanna check this if
the implies prototype doesn't have it
guess what happens it checks the done
the proto and it goes to this object so
you say objects prototype do you have a
property call test if this doesn't find
it that's when it returns undefined well
we have seen this pattern all along
what's important to notice here is that
there's actually a third hidden level
there's this third object that is
checked far when there's a property
reference and this happens for every
prototype and that is the object's
prototype so let me demonstrate that by
putting some properties on both these
prototypes and verifying that it does
work let's say i do a EMP dot prop
employ so if i were to access EMP prop
i'm going to get back imply thing and
simple now let me add a property on the
EMBs prototype object so I'm going to
get EMP dot down the proto I'm going to
set a property on this
parent prop I'm going to call it parent
of employee so if I were to access EMP
dot parent prop I'm going to get that
back because it doesn't find it in EMP
it goes and checks the pennant now I can
set another property on the grandparent
right so it's the tender proto dot done
the proto so I'm going to levels deep so
if I were to say EMP dot down the proto
dot turn the proto I'm going to get the
object's prototype I can either access
this are I can access the object dot
prototype I'm going to make sure that's
the same so let me set that on the
objects prototype so that's the object
dot prototype now call this the
grandparent prop grandparent of employee
or let me actually just say grandparent
will tell you why in a minute
and now if I were to access EMP dot
grandparent prop I'm going to get back
the property that we set on the object's
prototype this is the picture that's
happening it's going here doesn't find
this it goes here doesn't find it here
it goes to the object prototype now here
is this implicit benefit or I should say
consequence of putting something on the
objects prototype but guess what happens
if you put something on the objects
prototype you're essentially adding that
property to every object in your system
so let's say I create a function foo
which is completely different right and
I say var TMP equals new foo now guess
what happens if I do the MP dot
grandparent prom I'm going to get back
the property that I added on the objects
prototype because this link here is
something that happens for every object
the matter what the function is if
you're calling it using a constructor
it's going to have a prototype which you
didn't create so it was created using
the object function so it's done the
proto is going
why into the objects prototype then you
like it or not so if you put something
on the objects prototype you're
essentially creating a property for all
your objects in the system this is both
good and bad this is kind of like an
equivalent of Global's you really don't
want to do that too much you want to
abuse this power but this is an
indication of what happens in the
JavaScript engine when you are accessing
a property on an object by default if
there is something on the objects
prototype it is going to get accessed by
every object that you create
unless that object has a property off
the same name in which case it just
serves it directly and it doesn't go to
the objects prototype or that objects
prototype has a property of the same
name in which case also it doesn't go to
the objects prototype but if any of
these objects don't have the property
it's always available in the objects
prototype once you added it here now
here's an interesting question if this
hierarchy is to happen always but the
objects prototype is also an object now
will this have a tender proto that this
should have a done to proto I have this
should point to something else right so
would this lookup be infinite well it is
not infinite because the prototype of
the object has it under proto which
points to null okay so this is something
that the JavaScript engine implements by
D file so that this chain does not go on
and on and on right so the objects
prototype is where it ends the global
object function has a prototype and that
prototype has it in the proto which
points to now so it doesn't go beyond
this so this is where it ends so this
Delta proto points to null so there is
no opportunity for the JavaScript engine
to look up further so you can think of
the object prototype as kind of like the
global grandfather of all objects in
JavaScript and anytime you look up a
property on an object if it has it it's
going to give it and if it doesn't have
it it says hey wait let me check with my
dad and see if my dad has that property
checks with that dad says okay if I have
the property it's going to give it and
it's going to look as if the object had
it all along
but if dad do doesn't have the property
he's going to say hey I don't know what
you're looking for let me check the
granddad and so you've generalized the
property in ads granddad is the object
over here and if trying to add knows
what we are done it's going to get that
property back and if granddad do doesn't
have that property that's very good
undefined
okay so this happens for every object
property look up in JavaScript so I'll
happening behind the scenes we wouldn't
even know it but once you start
leveraging this feature by adding things
on the objects prototype then you are
essentially creating properties that
could be accessed by every object in
your JavaScript environment</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>