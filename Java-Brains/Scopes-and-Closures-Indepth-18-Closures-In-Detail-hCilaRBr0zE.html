<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 18 - Closures In Detail | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 18 - Closures In Detail - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 18 - Closures In Detail</b></h2><h5 class="post__date">2016-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hCilaRBr0zE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in the last video when I was talking
about closures I told you how these
functions point to the single copy of
variables right so they remember the
copy of variables that were available
during the function creation so in this
video I'm going to explain what that
means what does a copy of a variable
mean it's it's not really duplicated and
will also address the patient vendors
these variables actually get created now
let me clear this out except for this
one line right let's take all this thing
out now I have a bar equals 10 if I were
to run the script how many copies of a
would get created there will be just one
right now if I were to run the script
the second time how many copies of a
would get created again it'll be just
one but this would be a new copy of V no
because we're running this for the
second time the area that gets created
for the second time is obviously
different from the a that God created
the first time I ran this crack because
every time I done the script there is a
new copy of a that gets created now let
me put my code back over here now if you
let's look at bar b equals strength but
b equals 20 is inside the function outer
so just like it worked for the global
variable a the outer function execution
is what creates a new variable B okay so
every time I call outer there's a new
variable B that gets created and the
value training is assigned to it okay so
I call outer the second time there is a
new variable B that gets created in that
side the value of 20 so the B that was
created during the first execution of
the outer function is different from the
B that gets created in the second
execution of the outer function so the
thing to remember is whatever variables
you have in functions are actually
created for each function execution all
right so when I run the script then I
say reload and run there is one here it
gets created and now I have a function
declaration then I'm going to execute
the outer function here this creates a
new V okay and now when this function is
being created this function object is
being created and assigned to inner
there is one copy of a and one copy of B
okay so there's one instance he is the
first instance of cost
that got created when wine one executed
and B is the second instance when line
15 executed and then came here in line
four
now you have a new copy of B so then
this function object is created there is
in memory 1a and 1b
okay and that those two variables
contain the values then and 20
respectively that's what I mean when I
say that the function remembers where
the copy of a and B is that it needs to
refer to okay so when the function is
created there is a function object that
gets created remember we talked about
this a function is actually an object in
JavaScript so this actually creates an
object and assigns that object to the
variable inner it's assigning a
reference here but you get the idea
now in this object there is also another
property which remembers the state of
that scope it remembers the B that was
created due to this line 15 and it also
remembers the a that was created due to
line 1
so that gets preserved in this object it
gets assigned to inner and now when you
are done in R you get it over here this
variable still has that value preserve
now alter exits this function does not
exist anymore right the instance of the
function the instance of the variable B
that was created doesn't exist anymore
or does it because think about garbage
collection the concept of garbage
collection is and this applies to a lot
of other languages works similarly in
JavaScript as well once you have a
variable or an object that does not have
any references that does not have any
pointers it gets cleared out by the
garbage collector but remember now that
this there's a function it has a
reference to this B so it cannot be
cleared out so even though the function
outer is already executed so when this
function outer was executed it did all
this stuff it created B and ideally when
the function execution completed it
should after B out I should have been
garbage collected but it will not in
this case because you have of we have an
object here which holds a reference to
the scope chain here which indirectly
holds a reference to B so B is not going
anywhere that's
inner function object holds a reference
to this a and this B that was created
thanks to this execution okay now the
thing to remember is when I execute out
there a second time there is a newbie
that gets created okay now let's say I
have bar inner function 2 equals outer
now what's going to happen after execute
once again now it creates a newbie all
right now it comes to line 6 it creates
a new function object now this function
object has a reference to in D because
that's the whole scope chain at this
point when that function object has been
created so it refers to a which is still
the same name because it's global but it
refers to the new beena the new B that
got created when the outer function was
executed the second time ok so this is
the second function object now I have
two function objects the first function
object refers to the same global a and
the local be that was created during
this execution have the second function
object that still refers to the global a
but it now points to the second B that
was created during this second function
execution over here now in order to
prove this here's what I'm going to do
I'm going to change the value of these
variables from inner right now inner is
just printing the values and it will
print 10 and 20 no matter how many times
I execute this but now that's not my
goal I want to change the variable and
see how it affects it now let's say I
change this to a plus plus and B plus
plus
okay so I'm incrementing a and I'm
printing the value of a I'm incrementing
D then printing the value of B and if I
were to execute inner function to now
there should be four lines that get
printed on the console can you guess
what those four lines are remember that
when the first function executes he has
the value of 10 and B has the value of
20 so a plus plus is going to leave a s
laven
and B plus plus is going to leave PS 21
now it should print 11 and 21
now I execute outer again if there's a
newbie that gets created B is again 20
but now a is 11 so when a plus plus
happens
he becomes 12 and B plus blessings it's
a new copy of B it is 21 so console dot
log of a and B print 12 and 21 let's
clear this out and reload and run there
you go the first execution prints 11 and
21 the second execution prints 12 and 21
which proves that there is a new B that
is created for every execution of outer
so this function is referring to the
first copy of B this function is
referring to the second copy of B but
both these functions are referring to
the same copy of a so this is what I
mean when I say the copy of a variable
then the snapshot is created for a
function it's basically a snapshot of
whatever variables were in the scope at
the point of time when this function was
created that's what a function remembers
and that's what closures mean</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>