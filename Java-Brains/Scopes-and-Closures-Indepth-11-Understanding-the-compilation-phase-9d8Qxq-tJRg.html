<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scopes and Closures In-depth 11 - Understanding the compilation phase | Coder Coacher - Coaching Coders</title><meta content="Scopes and Closures In-depth 11 - Understanding the compilation phase - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Scopes and Closures In-depth 11 - Understanding the compilation phase</b></h2><h5 class="post__date">2016-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9d8Qxq-tJRg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright let's write some simple code and
see how this works with the compliation
set and the interpretation step so let's
say I have of R equals 10 and our B
equals 20 and I'm just printing
something in the console it's a sum off
a and B now this code let's say this is
the code right and this is something
that gets executed on the browser and
the browser runs through the compiled
Asian step and then the interpretation
step so let's look at what the
compliation step does here the
compliation step is just worried about
the variable declaration of course it
does a lot more but at least in this
context of scopes the compilation step
examines the variable declarations so
whenever you have a bunch of code that
gets compiled as far as the variable
declaration aspect of it is concerned it
just looks at these VAR keywords so you
have to set two lines which have a bar
so it's going to look at the first line
which is war equals 10 but the
compliation step doesn't bother with the
RHS it's just looking at the ward
keyword so it just looks at this portion
of the code so it's soirée say okay I
got it
now I've registered a variable called a
and that is in the global scope because
this is not inside a function now it
comes to line 3 and I'll here it sees
just this part warbie okay so the first
compilation step just look looks just at
the war so it doesn't care about the are
it just again
now it says okay I've got Barbie so it
registers another global variable called
B and again it's global because it's not
inside a function now it's gonna examine
line 5 does it see any war here no it
does not so it just ignores it and that
is the compliation step the compliation
step in this code has basically
registered two variables a and B in the
global scope okay let's look at the
second example now again I have a var
equals 10 and now I've created a
function called my FN and inside the
function I have a couple of variables
have barbie equals 20 and 1/2 or C
equals B and now I just say I print
something on the console a plus B right
and I call my function from outside now
if you look at this code can you
identify what are the variable
declarations that are happening over
here how many variables are being
declared if you answer this question as
3 well then you're actually missing out
on one variable declaration so there
at three Varzi all right so there is a
war a which declares variable a to the
war B and a war C so there are three
variables here but what if I were to
tell you that there is actually a fourth
variable what is the way you explicitly
create a variable of your own but then
there are a bunch of things which also
end up creating variables what I'm
referring to here is the function
declaration over here you notice there
is a function declared with the name my
FN remember I told you how functions are
actually objects in JavaScript and the
minute you create a function you're
actually creating a sort of a variable
which contains that object so this
function declaration actually results in
JavaScript creating this variable called
my FN and binding it to this function
object so there is actually a fourth
hidden variable declaration which is my
FN all right so now let's play the role
of the compiler and see what it does
with these variable declarations it's
going to start from the top again it's
interested only the left-hand side
variable declaration soirée so it
registers a to the global scope like
before now it's going to come to line 3
and here it sees a function declaration
call my FN so it is going to register a
variable called my FN it knows that it's
a function but for the purposes of the
variable it's just just another variable
rights bound to the name my FN I'm just
going to come down to line 4 and it sees
a VAR b again it's looking just at the
left hand side the VAR b exists inside
of a function declaration so when it
registers b it does not register it in
the global scope it actually registers
it in the scope off my FN okay since it
sees this function here it creates a
scope you know it at least makes a note
that it is off a particular scope and
then VAR b happens to be inside the
function so it gets registered inside
the my FN scope similarly it looks at
war c and this is also inside my FN so
it registers variable c inside the my FN
scope and now here console.log does not
have any variable declaration so it
ignores it
my FN execution does not have a variable
declaration right it's just using a
variable that was already declared so it
skips this line as well so the compiler
compiles the score actually ends up
creating four variables a my FN B and C
let's look at one more example now okay
in the last example we saw how you can
create a variable by using a function
declaration right we were able to create
a variable without using a bar now in
this example I'm going to show you one
more way in which you can create a
variable without using a war it is kind
of hidden but hopefully you can notice
that based on what we have seen so far
all right I'm gonna start with the bar
my name equals cosh ik okay so the
simple program which assigns a string to
a particular value and now I have a
function here called greet which let's
say it takes in a name argument okay and
then it prints console that log hello
name and let's say I call this greet
function with the my name readable now
if you were to play the role of a
compiler can you identify how many
variables are created by this code if
you said the answer is two but you're
actually missing from fun more all right
so let's take a look at the two which
are obvious so you have before my name
so there is a variable called my name
created and in the last example we saw
that when you create a function you're
actually creating a variable right so
this is greet it's a new variable called
greet which refers to this function
there's actually a third variable here
which is the name okay even though
you're not using a pod here the fact of
you creating a method argument means
that there is a variable that gets
created when that method gets executed
so then I call greet over here and pass
in a very positive value then that value
gets assigned to this variable right so
there is a name variable created over
here and it's assigned the value that's
passed to it and then you can use that
variable over here so even though you're
not using a wire here you are actually
creating another variable so let's play
the role of the compiler again if the
compiler were to run through this code
what would it do we first look at line 1
or my name this should be very obvious
now it creates a variable called my name
on the global scope now it comes to line
3 it looks at greet now it realizes that
it's a function but it creates a
variable called greet anyway and now it
creates a scope far greet there any
variable inside this
option is registered in that scope and
the first variable that it resistors is
name here because name is an argument so
there is a variable registration for a
name in the scope of Crete okay so it's
register set and then this line really
doesn't have any new variables created
so it ignores it and then it comes down
to here and even this line doesn't have
any new variables created so it ignores
that too okay so this is how the
compiler basically registers these
variables and their different scopes
depending on how you're calling it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>