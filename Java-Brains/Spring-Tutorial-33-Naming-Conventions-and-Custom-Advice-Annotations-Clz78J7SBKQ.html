<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Tutorial 33 - Naming Conventions and Custom Advice Annotations | Coder Coacher - Coaching Coders</title><meta content="Spring Tutorial 33 - Naming Conventions and Custom Advice Annotations - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Tutorial 33 - Naming Conventions and Custom Advice Annotations</b></h2><h5 class="post__date">2011-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Clz78J7SBKQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi and welcome this is going to be a
quick tutorial but I'm going to cover a
couple of concepts that I believe are
important and I hope they're helpful the
first thing that I'm going to talk about
is conventions when it comes to
organizing your classes and packages
well it's a known fact that we need to
stick to some standard conventions when
we write code especially in huge
enterprise applications where the number
of classes are going to run to a huge
number so what we normally do is we
organize them into a you know a set of
packages that are named as per the
convention and then even the class names
are as per the conventions and they're
uniform throughout at least one web
application if not all the applications
that the team develops so when I say
package names and class names it could
be as simple as what I've done over here
so here I have you know I have an aspect
package where I would now put all
aspects and I have a model package where
I put all the model objects and then I
have a service package where I put the
service classes and of course if you're
having different interfaces and
implementation classes you would
probably have our dart impl package
which holds the implementations while
the service being packaged will have
only the service interfaces so these are
typically found in most of the
enterprise applications these are very
simple rules that have said but adhering
to those rules can be very helpful and
I'll show you one such use when it comes
to what we are discussing about just
aspect oriented programming so here if I
open the logging aspect over here if you
see the kind of point cuts that you
would normally apply most of the times
it would be something like this you
would use the execution point get
expression and configure what are the
methods whose execution will trigger
your advice methods so what happens here
is you need to provide class names and
package names that will trigger the
execution so you can actually narrow
down which methods of which classes are
going to trigger this advice
so typically what would happen is let's
say you have some kind of a logging
advice or transactional advice that you
would want to apply generally let's say
you want to apply it to all your
business service methods so when it
comes to that when it comes to writing
point guides for such situations it's
very handy to have a predefined package
structure and a predefined class name
convention so that you can write your
point cut expressions easily so here
let's say I want to write a point cut
for let me get a new one here let's say
I want to apply a point cut for all
service methods so it could be as simple
as point cut execution put star over
here and then here I can write the
actual package name dot service dot star
so what I'm doing here is I'm mentioning
the package for all my service classes
so you know if we have a convention
followed for all the classes this
becomes very easy to do so here I can
add a star so that I'm saying for all
methods of all the classes inside the
service package and then I use a dot dot
so that I'm not worried about the
arguments so again this can be modified
further depending on your requirements
as long as you have the naming
conventions proper now let's say for
example you want this to be applied to
all your service classes within there
are a few other classes in the same
package which are not service classes
and you don't want the package you know
this point could to be applied for that
so as long as you have this naming
convention set like you know if your
class names all end with the service for
your service classes then you could as
well do service over here so sorry
the method name we've over here you
could have a service so it picks up all
the classes as long as it ends with
service so in summary naming conventions
are important and you will feel the
importance of that when you're writing
tricky point cut expression in spring
AOP okay so having said that let's move
on now let's say you have your your
application fully coded and you have
followed really strict naming
conventions and everything is fine but
let's say you have a particular aspect
that you need to write and you cannot
really find a pattern that covers all
the target methods that you have in mind
now let's say I have I have this shape
service now let's say I want an advice
to be applied to a get circle of the
shape service and I wanted to be applied
to let's say I take this triangle I
wanted to be applied to a set name of
the triangle now how would you do you
know how do you write a point get
expression for such as such a situation
well one way to do that is you get the
point get expression for this method and
then you get the point get expression
for this method and then I've already
told you about the and operator in when
it comes to point expressions you can
say expression a and an expression B in
your you know in your point get
expression and then it's going to take
care of applying that advice method to
both these target methods well this is
fine because we have two methods but
what if we have more what if you have
like ten such methods we don't really
fit into a pattern or what if you have a
possibility of you know you being able
to apply this kind of an advice for
different methods which you are not even
aware of in which you cannot predict a
pattern for for situations like that
there is a very very handy way of
describing this point that expression in
it and that's by using custom
annotations so we can write custom
annotations and we can apply those
custom annotations to all the different
methods where you want this advice to be
applied
and then in your in your advice you can
actually have a Poincare expression
saying all the methods for which this
annotation is applied so that's a very
easy way to do this and it's more
readable also when I say redouble what I
mean is if you look at a service for
example see if you look at this service
class over here you will know that this
particular method has an advice tied to
it you can find that out only by going
through each and every aspect that you
have in your in your code you need to go
through each and every point at
expression and see if there is a
particular method that matches this
pointer expression so you will have to
evaluate this method let's say for all
these different point guard expressions
and see if any of them match so if you
use this custom annotation it's very
handy and it's more readable so we'll
just give a quick example of how to do
that now I will use this logging aspect
itself I would want to have a custom log
able annotation and I want to apply that
to different methods and I'm not really
sure what the you know what the point
expression is I don't have to worry
about it all I do is I apply a point cut
expression for the annotation itself so
let me create a quick annotation here
I'll call this log a bill finish and
this is all I need to do I don't need to
have anything else you can of course add
extra you know code for this but for
this example I'm gonna stick to this so
have a log of the interface I'm sorry an
annotation so now what I will do is I'll
in my aspect let's take this one I have
an around advise which is applied to all
Gators now what I'll do is if I want to
write a point get expression for this
logger book I will use this point at
expression call that annotation this add
annotation takes the annotation class
itself with the complete package name so
I'll see argh don't gosh sake dot Java
brains third aspect
luggable so now what I'm doing is
instead of specifying a point cut that
is tied to the method signatures or the
class names or the package names what
I'm doing is I'm tying it to an
annotation so no matter what the method
name is no matter what the class name is
as long as the method is annotated with
log Abell this advice is going to apply
for that method so now that I have
defined this it gives me the freedom to
apply this log of the annotation and
this advice to any method I want just by
and reading it now let's say I want to
apply this to a get circle so what I do
is I do a at lockable it is as simple as
that I'll have to import this so now I
don't have to worry about the name or
the naming conventions say this so what
spring is going to do is it's going to
look at this advice it's going to say
okay I'm going to apply this advice for
all the methods that have the annotation
as loveable and then it sees this method
has the log of the annotation so it's
going to apply that advice for the kids
circle so you can apply it to as many
number of methods as you want and you
can of course apply two new methods
without having to change the point cut
expression that you have defined over
here so just to test that it works let
me run this I'm doing a get circle which
is annotated over here with log abbu and
this my around advice should execute
because that's what is the point get
expression so let's run this well there
you go
the advice has been run but not because
of the point gate expression that we had
defined earlier it was not for all the
Gators it's happening only for one
particular method here because it's all
it's the only one which has been named
log abbu you can of course extend it to
other methods just by adding this
annotation so these are some handy tips
we should be very helpful and it also
makes your code readable just by looking
at this method you can actually see that
K this is lockable annotation and the
advice will be applied to this method so
that way I found this very helpful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>