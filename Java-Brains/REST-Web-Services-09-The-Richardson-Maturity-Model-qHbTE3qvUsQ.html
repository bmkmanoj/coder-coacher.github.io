<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>REST Web Services 09 - The Richardson Maturity Model | Coder Coacher - Coaching Coders</title><meta content="REST Web Services 09 - The Richardson Maturity Model - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>REST Web Services 09 - The Richardson Maturity Model</b></h2><h5 class="post__date">2015-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qHbTE3qvUsQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is the final tutorial in Section 1
API design we've looked at different
factors than building restful api is for
our messenger application in this
tutorial we'll wrap up and take an oral
look at how far we've come and what that
means the tutorial page for this
tutorial is going to list the API
documentation summary for what we have
so far
I hope the choices in the design
approach for this API is clear to you
now if you're unsure of why any part of
the api is a particularly I encourage
you to revisit through the relevant
tutorial now that we have designed the
API this way let's look at what this
means are we in a position to say that
this API is fully restful remember in
the first tutorial I mentioned that this
isn't a yes or a no question that there
is a spectrum of anyway from not fully
restful to almost stressful to not
restful at all
well these thumbs are hard to work with
how do you know how restful an API is
though there is one way to Nome and
that's a model developed by a guy named
Leon and Richardson this is called the
Richardson maturity model and it breaks
on all the concepts that we have
discussed so far into three different
levels every REST API belongs to one of
these three levels the model also
defines a level zero which is not a
restful api okay so there are four
different levels actually one is not
restful api and then three different
levels for each restful api it's not
necessary that every api score highly as
per this model but it helps to
understand this model when designing a
nearest full api so that at least you
know where you stand and try to make it
better if possible let's start with
level zero i hope you're familiar with
some of the basics at least of a soap
web service the various hope web service
generally works is that there is a URL
called the endpoint where the service is
exposed right there's one URL and that
URL receives all requests from the
client if you were to write a messenger
api as a soap web service you probably
have one you are
se7en slash messenger write this URL
receives all the requests how does it
know what to do how does it know what
operation to perform how does a client
tell it how to do different stuff like
looking our messages or deleting content
well that happens in the message that
sent to the common URI right the message
contains about the operation that needs
to be performed and the data that's
needed for that operation for example
the XML here could create a new message
right so there is a create message
portion in the request itself which has
the action right and the delete common
request would be sent to the same URL
would look like this right so there is a
delete comment in the request itself and
that's how the single URL knows how to
do these different things so since the
action is a part of the message itself
the same URI could work right and in
fact the same HTTP method can be used
for each operation because all the
details about the operation is in the
request body in fact that's what soap
does the requests are always post with
the post body containing all the
information right this is level zero in
the Richardson maturity model this is
often called the swamp of pox this
refers to the common use of plain old
XML or parks to define everything that
the operation operation needs right
everything is defined in excellent plain
old X no no HTTP concepts are leveraged
for communicating this information here
right since everything is in the XML
there's no use of the HTTP concepts the
HTTP constructs to communicate
information between the server and the
client
this is level zero and this design
approach as obviously not what something
that you want to do when designing
restful api is if you were to refine
this model and introduce a concept of
resource you are eyes you will reach
level one in the Richardson maturity
model right this is the starting level
for restful api so the earlier level
isn't even considered rest
according to this module we've designed
resource you arise for messages profiles
and so on so if you did just this and
nothing else
you standard level one now you have
message requests going to one URI
comment request going to another URI
profile request going to another URI and
there would still be information about
the operation inside these requests
because a single message URI would
probably need to handle adding and I'm
adding a message deleting a message
updating a message and so on a single
profile you are I would handle updating
a profile getting a profile and all that
stuff so the message the request would
still contain what needs to be done but
you basically split a different you are
eyes as different resource you are eyes
and you send the right request to the
right resource URI right so that's level
one if you take the next step and
introduce different HTTP methods for
these different operations then you
reach level two in the Richardson
maturity model an epi on level two uses
standard HTTP methods like get post put
and delete to do different operations on
the resource you arise the URI specifies
the resource that's being operated upon
and the HTTP method specifies what that
operation is there also needs to be
better use of the HTTP status codes and
the write use off idempotent and non
idempotent methods for an api if this
happens then the api said to be as level
two finally level three is when you
implement haters that is the responses
have links that control the application
state for the client the client doesn't
have to be aware of the different API
you are eyes all the URIs the client
would mean would be sent to them in the
response an API that implements this is
said to be at level three of the
Richardson maturity model and it is sort
of considered to be fully restful
and there you go now we can look at any
REST API design and easily identify
which level in the Richardson maturity
model it belongs to again this is not
supposed to be a strict rule I encourage
you to use this model as a guideline for
designing your REST API s as a tool for
learning and understanding rather than a
scorecard to measure your API so you may
choose not to make every API achieve
level 3 off this Richardson maturity
model but this helps to understand what
the theoretical ideal is okay once again
look at the API documentation for the
messenger application in the tutorial
page in the next section we'll start
looking at jax-rs and we'll start
implementing this API there is a lot to
REST API design and the tutorials if
you've covered so far have only
scratched the surface I encourage you to
explore more about REST API is more
about rest design and treat these
tutorials as a starting point rather
than a complete learning experience so
this ends the first section if there are
any addendums depending on the kind of
questions that I get for these code for
these tutorials I vlad subsequent
sections probably in text rather than
video tutorials later but in the next
section we will switch to implementation
we will start with jax-rs we'll
understand what it is and the start
writing code to implement the messenger
api that we have been designing so far
in this section see in the next section
and thanks for watching</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>