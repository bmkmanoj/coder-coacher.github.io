<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular 1 Services In-Depth 12 - Asyc JavaScript and callbacks | Coder Coacher - Coaching Coders</title><meta content="Angular 1 Services In-Depth 12 - Asyc JavaScript and callbacks - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Java-Brains/">Java Brains</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Angular 1 Services In-Depth 12 - Asyc JavaScript and callbacks</b></h2><h5 class="post__date">2016-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/lgGjlsPj02o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's spend some time trying to
understand what the asynchronous nature
of JavaScript is because with JavaScript
unlike other classical languages you're
going to be relying on async a lot of ie
synchronous the thing is JavaScript is
designed to run on the browser right the
users web browser and typically web
browsers allocate just one processing
thread per tab or per window of your
browsing experience so let's say you
open your browser open a web page in the
tab what the browser is essentially
doing is creating one thread which is
supposed to work for the sake of
displaying that page in the tab right so
any JavaScript that executes the
printing and all that stuff it's all
handled by this one single processing
thread so because of this javascript is
usually considered to be a single
threaded programming language right so
you write javascript assuming that
there's just one processing thread
that's executing at any point of time
which means that every operation needs
to be non-blocking
think about it you have a web page open
so if you're writing an angular page and
you have JavaScript to make a REST API
call make an HTTP call now let's say
that thread that one single thread which
is allocated for executing all your
angular code write everything in that
block in that window in that web page is
all handled by that one single thread
now if you say hey processor go make
this REST API call and if that call were
to be blocking if the thread is waiting
for that response to return you've
essentially frozen the browser window
till that happens typically a REST API
requests in a response takes about 2 ish
seconds not if it's a really fast API
but I'm just I mean on an average it's
probably going to take like 2 seconds
for a typical REST API so when something
like that happens you don't want the
user's browser to freeze you don't want
the JavaScript code to actually wade
there while that HTTP call is happening
if you looked at the dollar HTTP GET in
the previous slide when the dollar HTTP
target is executing you don't want the
whole thing to freeze you want the next
line to execute and then once the
response is gone
only then you want to handle that
response you don't want it to freeze so
every operation and JavaScript needs to
be non-blocking now how does this work
if you know you need to make these calls
but the calls also need to be
non-blocking and the calls do added up
taking time so how do you prevent this
blocking this kind of a long-running
request is typically handled using
something called callbacks in JavaScript
if you've written code using jQuery you
are already familiar with callbacks the
concept of callback kernel leverages the
idea of functions being things that you
can pass around to other functions in
JavaScript right in JavaScript we can
take a function and pass it to another
function that's a callback so here is an
example in jquery of a callback so
what's happening over here is i'm using
the document object to pass it to jquery
and say when this document is ready
execute a function that i pass to you
right so I'm calling the ready function
off the jquery framework and i'm passing
a function right to this function open
close open curly brace close curly brace
is an inline function which is going as
an argument to ready all right all
that's happening is I'm calling ready
with the function the argument being an
inline function so what I'm doing over
here is basically telling Jake where you
say hey when the document is ready call
this function I'm giving you a function
that's inline I don't want you to
execute it right away wait till the
document is ready and only when that
happens execute this function so notice
what I'm doing here I'm not holding the
processing till the document is ready it
is not synchronous it's not blocking
I've just told somebody else some other
framework to execute it when it ends up
getting ready right so when it does
happen there is one single thread and
that thread comes to executing it but it
doesn't wait for the document to be
ready all right so here's another
example a button click when a button is
clicked you want to buy it in an event
handler right so what are you doing over
here you're saying when this a anchor
tag sorry not a button when an anchor
tag is clicked you want a function to
execute so you pass that function as an
argument to this other function you can
in like
here so essentially you're having this
function executed asynchronously you
don't want this function to execute now
you are passing it to a framework to
have it execute then a particular
condition is met so this is callbacks
and this would work well for
long-running processing so you have a
long-running process anyone execute some
code after that you don't want to wait
for that long-running process to
complete something lazy tipi request for
example you want to make a REST API call
when I process the data after that
ristic a call is returned now you don't
want to actually have the browser thread
wait for the reciprocal to return what
you can do is pass a function along with
that HTTP GET you say hey HTTP service
make a get request and now here's this
other function that I want you to
execute then your get request is
complete and your going to take time
they're not hanging around here waiting
for you to complete the REST API call
I'm giving you this function go execute
this function when you're done right
this is asynchronous programming in
JavaScript using callbacks you pass a
function to another function that's
supposed to be long-running so that you
have that function execute the past
function write the pass function is a
callback
the problem with callbacks however well
there is a problem with powers the issue
is that you can have a lot of T's in
JavaScript if you've written some
advanced JavaScript programming using
callbacks you'll be familiar with this
now here is a picture that I usually
like to show which shows how deep this
callback you know a hierarchy can get
now what this is doing is there's a
function called hell very a clean aimed
which is basically returning a function
right so this function is calling load
link which is I'm guessing loading a
link or a file for instance now when it
loads the link executes this other
function right so this loading of the
link is something that obviously takes a
lot of time so you're passing another
function it says when this is loaded
call this other function what does this
function do it loads another script
ready see here it loads another file
that can be long running as well so you
say okay after that is done what do we
do we have to load something else we
pass in another function which looks
something else so all these are
functions
passing to other functions is a hey when
you are done execute this other thing
right so this goes all the way to the
bottom and now when the first thing is
complete right so this load link
function completes with style that CSS
for example it's going to say ok I'm
done now I'm going to execute the
function that's fast to me going to look
at this function execute it well guess
what that does it loads another thing so
it waits for that to complete and so on
I hope you get the picture this is
what's commonly referred to as callback
hell that's probably why they call this
function as hell you essentially end up
with a structure like this you have a
function inside a function inside a
function and if you've done decent
amount of JavaScript programming you
will be familiar with this in a lot of
the you know both client-side and
server-side frameworks again you can
very easily end up with this kind of
callback hell so this is not a good
pattern thankfully the dollar HTTP
service does not accept a callback to
deal with the response you could have
done a $2 HTTP GET could have had a
signature where the first parameter is
the URL in the second parameter is a
function that it needs to execute after
it's gotten that URL but they didn't do
that what the angular team has created
is another pattern where they haven't
actually created it's a popular pattern
that they have kind of leverage and the
pattern is something called Promises
Promises is an alternative way of
dealing with asynchronous programming it
kind of solves some of the challenges of
having callbacks and it definitely
avoids that callback hell picture that I
showed you in the previous slide now
let's talk a little bit about what
promises are this is actually very vital
to understand if you have to deal with
dollar HTTP nygh Euler and making REST
API calls</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>