<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Plumbing the Web with Unfiltered, a toolkit for servicing HTTP requests in Scala | Coder Coacher - Coaching Coders</title><meta content="Plumbing the Web with Unfiltered, a toolkit for servicing HTTP requests in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Plumbing the Web with Unfiltered, a toolkit for servicing HTTP requests in Scala</b></h2><h5 class="post__date">2012-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hnndN1InXYw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so i'm nathan hamblin and i'm
co-founder of the unfiltered project
along with doug Tangrene who is sitting
here in front and why is this pipe
bursting well the main reason is because
everybody on earth is getting onto the
internet the internet is still growing
rapidly in population and the people
that are on the internet are usually are
more and more active so doing more
different kinds of things and another
thing that jumps out at me about this
graph is that in the united states and
countries like it we already reached our
plateau in the user population of the
internet some years ago but the
Internet's still growing all the growth
is coming from different places and
different people so if you think the
internet is converging on a single kind
of website or people doing the same kind
of thing it's really not happening it's
diverging in the other direction because
each new user is more and more different
from the last one is reaching a
different population to people the
internet is a is getting increasingly
diverse but even if you're looking at
that slice of the internet like the
apple pie slice of it represents
Americans doing American things even
even there we're not converging in the
way that sometimes it seems like we are
onto a single into a single website or
single platform every time it seems like
everybody's you know huddling into the
same to the same thing like a well or
Facebook then you find it and it some
new upstart comes in and shakes things
up so if you don't know what it means to
put a pen on something just ask someone
of the opposite gender and she will tell
you all about it but this is just a
website called pinterest that is like
right in right and Facebook territory
and just like taking on users taking on
user activity people are sharing things
with it and it's right there on the wild
wild web even though we think of those
kinds of users is maybe less
sophisticated Internet users that would
be happier if they were just on some
controlled site in fact they keep going
to different kinds of sighs so um I
found this chart on on
oracle's servers even though it's
ancient this is this is the j2ee
architecture and something i noticed
about prescribed application
architectures is that as they get older
they become universally despised but
there's there's sort of like a honeymoon
period where where they're new and there
they're kind of okay and and before
they're even built there always going to
be the best thing ever but it just you
know you have this cycle of love and
then disappointment that happens at the
end and that's kind of sad that that
happens to application architectures so
this is a this is what the unfiltered
application architecture looks like we
call it for short there's nothing wrong
with the video except for the blue tent
it is there there is we aren't totally
doesn't tell you how to build your
application because you know better than
unfiltered that's how to build your
application you're inventing something
new I don't even know what you're doing
and I not even understand it if I did
know so the the idea is that the
unfiltered gives you an interface to
build for the web the way you do behind
that interface is totally your business
and and we're not going to tell you
what's the best way to do it because
there's no possible way that we can know
that and apparently this is resonating
with some people I just pulled this off
the unfiltered listserv a couple weeks
ago saying that the main strength of the
framework is what it doesn't do so the
idea that unfiltered is not going out
and putting its fingers and all
different kinds of parts of your
application has been valuable to some
people so it's unfiltered doesn't tell
you how to build your application and it
doesn't keep your hair out of your ramen
noodles then what exactly does it do
what is the frame like what is the
toolkit good for it just does HTTP
that's its full aspiration for what it
wants to do for you it just wants to
help you with HTTP and putting your
application exposing it to the internet
so that people can do things with it and
so we call that unfiltered being a
toolkit for servicing HTTP requests in
Scala that's its mission so how
what exactly does that mean for what
exactly does that mean in the first in
the initial build and still importantly
that meant that your building servlet
filters with unfiltered and circlet
filters are a great way to build for the
web on the JVM and you know as much as
we can like laughs about j2ee and other
big architectures circlet filters is is
itself a pretty a pretty basic and
modest design for for how you can do
that kind of interaction it's just that
it's for Java right so we wanted a way
to create these kinds of filters in
Scala and the the original motivation
was to get on to App Engine which uses
the filter interface and follows that
decently well it doesn't really conform
to a lot of other ideas in Java and it
doesn't let you bring along your own
database and stuff like that so if you
want to build for App Engine you want to
you want something that allows you to
build filters really well and then you
can use the app engine stuff that's in
Java so whereas if you're using a large
framework that has its own ideas about
the full stack of what you should be
doing and that framework is going to
have to pour be ported to App Engine in
order to get the rest of the stack on
there and then by the time they're done
with that Google is going to change the
pricing model and nobody's going to want
to be on App Engine anymore and then
your voice is your time so it's better
just a right straight for the right rate
for the spec in that case because then
you then you can just write only the
application that you need to write okay
so here's an example of a making a
filter and unfiltered so the echo class
that we made also implements the the
filter interface you don't see that but
it is just the same as a filter that you
might make in Java and all it's doing is
taking the path that you requested and
responding with it so it's just a very
dumb echo filter so how would you use
this and and in your servlet container
the exact same way you'd use a Java
filter you just throw it in there and
the web.xml and and it will work so what
if you're writing
an application and you don't have a
servlet container and you don't really
care if you have a servlet container or
not because you're not now doing that
kind of stuff you just want to put
something on the web well fortunately
the jetty project has been doing this
for a long time embedding a server for
you inside your application so that you
can write servlets and filters and then
just start them up from within the app
so in filter just gives you an interface
to jetty so that you can do that and
very little code so here we're just
doing this the same configuration that
was in the last slide we're just
starting up a server with our echo
filter and running it but then you start
to think well if I don't want to if I'm
not tied to the servlet container
paradigm then then do I need to use it
at all well no you don't need to
necessarily so if you want to use server
like Neddy you can use that with
unfiltered as well using the same
vocabulary and the same path matchers
and the same response functions as you
would use to build up a filter you can
use to make an eddie handler so this was
a pretty straightforward conversion it
was initiated by dag I think it's in the
other time so it works the same way you
create a you create a handler and then
you you give it to Nettie and and start
it up now the thing is if you're if
you're using if you're using Eddie you
aren't usually building exactly the same
kinds of apps that you would if you were
writing a filter you want to do
something that exploits the the raw
networking capability that you get from
Nettie so unfiltered has no opinion at
all about what you do with that stuff it
just gives it to you and a type-safe way
so if you have a request that comes in
for some magic path then you can just
take out the underlying context request
and event which are Nettie typed objects
and do whatever you want with them and I
don't know what you're going to do and
you know you can do it doesn't really
matter as far as I'm filter is concerned
you might want to respond
at some point otherwise the connection
will just be left open forever but i
don't know maybe maybe not like that's
up to you but the neat thing is that
even though you have all that access to
the raw functionality of Nettie you
still have your vocabulary for
responding to requests with the
unfiltered objects that you already know
from from working with other things so
you can handle the boring parts of your
application and a tiny little bit of
code and then you can get into the
nitty-gritty you know with the same
stuff around it but but working with the
underlying library so why why why bother
with a small framework like what's the
what's the real motivation to use
something like this is it just so that I
can put up a slide with a full web
server on it is it just like deck where
I think Nicole no it's actually got a
lot of uses one of them I just took
advantage of a couple weeks ago you
don't have to be able to read this code
it's just to show you how much there is
when I was rewriting the posterous SBT
plugin to be used as a as an independent
application since i have unfiltered now
I was like oh well why don't I just use
unfiltered to make it a little bit
better so the way things worked before
is if you wanted to well first of all
what the plug-in does is that publishes
your release notes to implicitly if
you're writing scallop projects so
before you do that you probably want to
make sure you didn't make any mistakes
and preview them so it would a copy
convert them from mark down to HTML and
then open a web browser on the output
files and then if you realize oh yeah I
did say something stupid then you can
just edit it and then run the task again
to copy them and then refresh your
browser so better than that you can just
start up a server now and every time you
request from it it gives you the the
preview based off of the source markdown
files Thursday is a minor improvement
that I was just able to drop in and I
only was able to do it because it's just
a couple lines of unfiltered so like
this part this is the whole preview part
of the app and it's 43 lines of code and
a lot of it is just the HTML that's
wrapping around the preview another cool
thing you can do with a modest tool kit
like this is you can just build a filter
and put it into the servlet container or
whatever whatever architecture you have
that if it involves servlet containers
you can just make a filter that does
something in Scala because you want to
do it in Scala and and slide it right in
there without maybe you know everybody
knowing about it so in it oh yeah you
really can't see that but right there it
says unfiltered so you know right
between your jsps and java servlets like
you know it's in there it's doing
something smart and nobody's quite sure
what except for the scallop programmers
don't know about it but you can you can
just make a filter right on one final
use case this is like a chart that's
going like whoa but if because you can
so easily build different kinds of
servers including servers using new I
owe you can prototype things really
easily so for example if you have a
services running in a circle a container
and you think it might actually be a lot
faster on an iOS server you can just
bang out a prototype in half an hour and
then benchmark it and see if if your
guess is right and in this example the
guess was right so we went ahead and
built out the rest of the server which
took another couple days and and then
solve vastly better improvement just
because new i/o can be better than old
io sometimes so unfiltered it turns out
that it didn't invent this idea that
small tools that do one thing well are
really good and I can't say that it was
inspired by a program designer in the
unix environment because i read that
until last week when Doug email it to me
because there's like this will be really
good for your talk it's like it's
awesome paper but
yeah so the idea is actually been around
for a long time right that you have the
tool that's focused on one task and it's
going to be honed to doing that task
well and then somebody down the line is
going to do really amazing things by
putting together your smaller tools and
into whatever it is that they've
conceived a building but sometimes
sometimes users just want features right
they don't want to be told that it's
super easy to build this thing on their
own they actually want you to help them
do the thing they need to do so we came
up with this idea which is anybody could
come up with it to build on top of
unfiltered but just to build kits that
are for particular features that you
want to have in your application and the
way they work is they kids are able to
look at the incoming requests and
they're able to affect the response not
by doing anything magical but just by
using the request the pattern matching
that's already in place and the response
functions that are already in place they
just wrap around that and and make it
work in a particular way so the first
the first kid that we made was to have
gzip encoded responses in your web
server something a lot of people quite
reasonably want to do so at first we
were like well we'll just give you a
sure that will only match if the client
says they accept gzip and then you can
respond with a header to say oh this is
going to be Jesus encoded and then you
can encode it that you know you can put
a filter in front of your response to
compress everything and then you can
respond that seems all right but it's
not super easy for the application to to
factor out that logic in fact if the
application what's factor it out really
well it needs to build something like a
kit so that's what we did and now that
there's a gzip kit you can just wrap
that around the function that handles
all your requests normally so you don't
have to change anything because you
already had your function which we call
an intent you just you just wrap it in
this kit which is going to do some smart
stuff
before it calls your function and and
handle a response and compressor
response if it's appropriate even so and
unfortunately the the raw materials for
doing that work are still there and
unfiltered the thing we built the kit
with is right there available for you to
use in a straightforward way so maybe
you have a service that serves gigantic
text files and you simply refuse to
serve them unless the client accepts
gzip that's fine you can just match
against that header and if the client
doesn't say they accept gzip then you
can return and say sorry too bad for you
we're not going to serve this content
and a hugely inefficient way so that's
not you know that's not built in it so
I'm filtered but if that's how you want
to respond to the request that's that's
your business another thing that we came
across from user feedback and what
you're looking at here is the general
way to match paths and unfiltered we use
pattern matching and if you're if you're
a scallop person then then you might
like it because you can just say well if
I have a path which has a segment of
users and do this or if one that has
users and then something else then do
that and and we you know we can read
that and we know how extractors work and
that's great but there's one one
practical problem with this approach is
it doesn't take very long to hit than
maximum size of a method in the JVM if
you're doing large partial functions in
this way so if you have a application
that has a lot of different paths in it
you're going to hit that limit and
you're going to have to start breaking
them apart arbitrarily just in order to
satisfy the the compiler so that sucks
and and the other thing is that like you
know people who aren't scala people will
get something like this I mean like what
the hell are you doing like what is that
I don't know so if you want people to be
able to look at your app and just see
which path is going where and and and
what methods are handling it then that's
totally great you can just use the
routes kit and which has a couple
different versions too to do that and in
a way that's probably a lot more
readable to the average person so this
again didn't require any changes to the
foundation of unfiltered it's just
another way of creating that partial
function that's going to handle a
request so the routes kit uses the
familiar rail style path specification
so same kind of thing we're doing in the
last slide users go to the user index
page users have an ID after that go to
the ID page the way that it's the way
it's handled is all these users index
users get places index places get they
all have to have the same they all have
to take the same parameters the same
type so that we can call them statically
based on based on the incoming path and
whether or not it matches the path that
you gave to the specify function so in
this case specify once functions that
take a request and a map which is going
to be a map of the keys and the path
strings to the values that were found in
the request if it matched so you can
actually you can assume that in this
case the ID key is going to be in your
map because we're not going to call your
method unless it was present just
because of the way that's written so
it's a generic way of delegating
processing to somewhere else in your
application but you can continue to use
the request that gets passed to it to to
extract parameters it might have been
there if you care about which HTTP
method was used you can use that so
users object is not isolated from the
web it's just a little bit lower the
level behind some routing so this is a
just a flesh out an example
of the users get handling hell and
getting a specific user we can say you
mean use a for expression to say well if
if there is an ID and the P map which we
know there will be because we wrote the
path mapping that way but if there is an
ID and the P map and there is a user
that corresponds to that ID then will
yield will yield a response function but
here we're seeing another another helper
that unfiltered gives you which is a
response function for Scala templates so
if you're using Skylit and you have it
on your classpath and you can use this
builder for responding to requests with
Scala templates so here we'll just say
there's a user profile SSP and we're
going to give it a user the user object
that we retrieved with keyed by the word
user and if none of that if that didn't
work out so well then we're just going
to pass on the request so what pass
usually means that nothing else handles
it then it's going to end up with some
404 handler which probably makes sense
if they gave a bad user ID but you could
also do something totally different if
you felt like it so to sum up senator
and fell and Ted Stevens once referred
to the internet as a series of tubes and
we all giggled when he said that for a
couple of reasons but one of them is
just that the internet is not that
organized the internet is not that clean
it's not this like you know cylinders
next to each other extending forever and
from here to there and taking your data
from you know the big phone company back
to you like we're not just we're not
that organized we are more the internet
which we're all part of is more like a
system of dirty old pipes and there have
been put together by a lot of different
people at different times extending them
in different ways and you know whether
or not it's always the best way it is
always a way that somehow get some user
something that they want
somewhere so if you think about how a
plumber might deal with walking into a
room with a set of pipes like this he's
not bringing with him his idealized you
know what should all pipes everywhere I
look like and I'm just going to replace
this with that because you know nobody
can afford to do that it's going to find
a way to integrate with what's there and
add his like hot water heater or
whatever he's working on using using the
different tools that are needed for
exactly that task so unfiltered is the
same same mindset of we're going to
we're going to give you what you need to
integrate with a larger system that
you're a part of whether that is a
six-month-old application or a
six-year-old application or if that
larger system and it always is if that
larger system is the web itself that you
want to integrate with then the most
important thing is that you have tools
that will allow you to do your super
smart secret great idea with it and
integrate well and cleanly and truly
with the the web itself which means
integrating via HTTP it's it's the it's
the one thing that you can count on and
that's why unfiltered is is purely and
solely focused on serving that need so
that's that's all I have for the talk we
can go into questions or I can show you
a little bit about how to how to create
an app with unfiltered if you have a
question raise your hand otherwise I'm
okay the yeah so the question is how do
you compose the kits together the return
type of the kids is is itself a partial
function and it's the same typed partial
function that's going into the kit so
you can wrap multiple of these together
assuming the kit follows that convention
so it you know it's all based on whether
or not the types do what you want but
the gzip kit works that way and and and
that's that's the that's the ideal way
for it to work so that you can just nest
them that way
yeah so the question is the rack
middleware which i'm not sure i'll
explain anyway but are we heading in
that direction of being able to
configure stacks of things like kits
that allow you to assemble an
application that way and it's it's funny
because even before we started working
on unfiltered we were talking a lot
about how would we do something like
rack and Scala and I couldn't come up
with a good way to do it because it all
the way that that is built it's all
dynamic and it's all based on putting
things you know into the request and
putting stayed in and doing stuff with
it later and I basically you know I
wasn't going to be on the project to
recreate rack on Scala and then the way
we spent you know a year or two with
unfiltered and when we started getting
into kids we started solving the same
kinds of problems I think that people
use rack for so you know we're insisting
on static typing for everything so I
think it's a little bit harder it's also
a little bit more stable as far as where
if it's heading that way that really
depends on community contributions
because we're we're so solidly focused
on making a do HTTP well that we've
built all the kids that have built so
far have been in response to users
asking for a particular feature and I
say oh it's too hard to do it with with
you know without some help from
something so we built it but yet I in my
in my mind since the kids can be built
outside of unfiltered I like to see
people making them outside unfiltered
and then if they look good we'll just
bring them in and so yeah I that is that
is a direction that we seem to be
naturally moving any more questions okay
thank you for your attention</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>