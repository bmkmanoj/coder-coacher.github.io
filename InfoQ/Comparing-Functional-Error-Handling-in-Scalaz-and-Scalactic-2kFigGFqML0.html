<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Comparing Functional Error Handling in Scalaz and Scalactic | Coder Coacher - Coaching Coders</title><meta content="Comparing Functional Error Handling in Scalaz and Scalactic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Comparing Functional Error Handling in Scalaz and Scalactic</b></h2><h5 class="post__date">2015-02-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2kFigGFqML0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I don't sure if it's exactly time to
start but I'll go ahead and start my
name is Bill venner's and today my goal
is to compare functional air handling
and scala sea and sky lactic without
creating an explosion on the expels
emailing list so we'll see how I do in
particular there's there's two types in
scala z one of them is called
disjunction which is that that v-shape
it's a symbolic name and then the other
one is validation and what for those who
aren't familiar disjunction is basically
a biased either so it's it's something
that's it's geared towards functional
error handling if you're calling them if
you're writing a method that may succeed
or fail you can return a left that has
the success value and I'm sorry I write
that has the success on the left that
has the failure value so you can
actually return the failure instead of
throwing exception that's the idea and
the difference between disjunction and
validation is that this Junction is
monadic and it would short circuit if
you put it in for expression you can
kind of combine many method calls that
may succeed or fail and it will
short-circuit give you the first error
validation is used for accumulating
errors so it's when you want to combine
several method calls that may succeed or
fail but you want to know what all of
the errors are okay or does the same
thing but in one type right so what I
wanted to do was not be controversial if
a possible and start by kind of
explaining what i think is a lot of the
differences in the design the way the
design came out is differences in gold
so what us versus them is is that i
think the scalzi folks are designing for
us and i'm designing for them so when 20
more started the project he said that he
doesn't really care if it's used he just
wants it to be usable and what I think
that means is that he wants to use it
and so in particular people who he's
designing for himself and people like
him who are already familiar with FP so
that to us is where as I'm actually
trying to
this for people who aren't familiar with
FP so that's more like I do want it to
be sort of a way for people to get into
doing things in a more functional style
people who are not familiar with Haskell
or FP before so that's one difference
another is the people who the
powers-that-be or the powers that
survived the recent ordeal really like
type class coherence and I don't think
it makes sense so the type class
coherence goal is really something that
didn't form the scalzi design and the
fact that I'm not trying to do that has
informed the Galactic design so that's
another difference the other thing that
I find is that there's a real strong
desire to make things general in the
scholars II community which i think is a
good thing but I think that there are
times when it's good to be specific and
that's another difference I think in
like philosophy that made these two
designs come out differently one more is
that the folks in Scala Z really want to
do FB this is my opinion or my
impression they're not really in love
with a JVM because it's kind of doesn't
it's not the best fit for FB but it's so
pervasive that you often end up writing
things for the JVM so they'd be nice to
have something FP like on top of it and
Scala is pretty much the best way to get
there and scholars E is sort of the
layer to do that whereas what I'm trying
to do is more merge them together like
bring oh and FB together I think a lot
of the scholars II feeling is that o.o
is not really needed and regardless of
that what I'm trying to do is merge in
which i think is kind of what Scala is
more about so the last thing is that
they don't like the standard library
that much there's those parts about the
standard library that that they want to
just not touch so they make replacements
and what I'm trying to do is is some do
something that will fit in with the
standard library so those are just
there's nothing wrong with the way
they're they're doing it I don't think
it's just different wait so that is
basically my intro and I have just a
bunch of demos so I I need
when to hold the mic for me otherwise I
would have to do coding with one hand
this is yeah this is uh Josh sure it so
he's going to hold the mic for me and
make interject comments from time to
time that's fun alright so essentially
the thing about type class coherence if
you look I actually was in a bin in the
scholars emailing list a few times
mostly asking questions kind of as a
curious grasshopper saying why does he
do things this way and one of the things
I just didn't understand is why do you
have two different types you have a
disjunction type in a validation type
because what I saw in the community was
people would have confusion about which
ones to use when and the answer was
because there's two different
duplicative so disjunction has a monad
instance and that comes with an
applicative that short-circuits
validation needs a different app liket
of that accumulates errors and they want
to use applicative to accumulate errors
and because they only want one
applicative / type they want it that
makes them have two types that's why
they did it so what type last coherence
is is that for any type T there's only
one instance that's what it means and
you can always rely everywhere on that
instance so what happened in school
actic is first of all I don't use
applicative for accumulating nation I
just wrote on API for it so I didn't
have that problem anyway but even if I
did I don't think I mean I see how type
class coherent scan is an attempt to
make things simple you can you look at a
type you know what its its instance does
but I think it doesn't really match a
lot of times there's just naturally more
than one instance for a type so so let
me give you a quick tour of or this is
the sorry that was good yeah this is the
type or is it son either so there's two
possible values a disjoint Union one of
them's good and one was bad so if you
look at either it's very balanced this
one is just it's like an easier designed
just for functional error handling so
one of the success result in worms that
fail
result I call them good and bad because
success and failure were taken in the
standard library and to fit in the
standard library didn't want to use the
same name that's what it means and so G
is the good type and B is the bad type
maybe it's an error message string maybe
it's some kind of hierarchy that you
created to handle errors and then good
and bad are just subtypes those are the
two subtypes so good just takes a G if I
can get there and bad just takes a be ok
so if one quick demo of how you would
use it if you had a functional if you
have a method and you want to return
either a string or if something went
wrong an error message you would
actually put the result type of your
your method like this you can just say
string or error message or if you want
to return an int or something goes wrong
an error message you could say hint or
error message well learning he learned
so this syntax are not sure you've seen
it before it you can actually do that
with any type in Scala where there's two
type parameters so you know another way
to write is this or ant come error
message is int or error message and you
can do that with map if you've mapped
from int to string you could write that
int map string if you want to do and
then here's a method that's going to
return a person or error message and it
calls those two guys in for expression
and just yields person and it will
short-circuit at the first sign of
failure so if the first one fails it'll
just give you that error message ok so
that's a quick tour and one of the
things that I wanted to do was test that
this thing obeys the functor laws and
the Monad laws and so this is an example
of testing that this type obeys its map
method obeys the functor laws and for
that I need to make a functor instance
for or and so this guy what it does is
it calls the map method and the thing is
that there's also a another method on or
called bad map that maps across the bad
side and that one should also pass the
fun
laws so I wanted to test that too right
and so that's down here this says the
bad the bad person and behavior of or
should also pass a functor law so I have
a different or a functor that calls bad
map so right there there's actually two
functors that are useful for one type or
and that's the problem with type I have
with type class coherence is that it's
kind of contrived as just force that
into one right and the other thing that
I demoed a few I don't know a year ago
or two to the scalzi folks is that you
know there's a way in Scala to override
an implicit so you could actually have
sort of a default type class instance
applicative instance for disjunction and
then if you want to accumulate just put
a different way applicative in scope for
that and then accumulate with
disjunction so here's an example of I
took disjunction scholars ease
disjunction and I was able to accumulate
Arizona I didn't need validation right
but but what that violates is type class
coherence because now i have i've used a
different applicative for this for valid
for disjunction so okay so that's type
west coherence so actually I'm gonna
take questions at the end for the video
but just save it though and also cries
of blasphemy those kinds of things
please save those for the end what can I
class what here what happens if the bad
Matt breaks do you get a breaking bad
oh so clearly I hired the right guy oh
yes you do just I'm not going to tell
you how it ends but so okay so that what
i wanted to show was an example of what
I've noticed in users they'll have a
little bit of confusion about which one
of these two types to use so this person
actually I don't know who it is I'm
sorry but ol a traveler Oh some types of
people don't really name sign their
blogs but this is an article called
favor or blog post called favor
disjunction revalidation where someone
says they have the epiphany that they've
been using these two wrongly and that
most blogs show them to use them a
certain way which is his first demo here
which is simply if you have a bunch of
methods like parse age parse int a purse
age parse name those kinds of methods
where you're returning either a success
value of failure value that you would
return if you want to accumulate the
errors you would return something like
this so this oh it's very tiny let me
make that larger sorry like it won't go
up now there we go validation non-empty
list error message coming int which
means if it succeeds it'll return it in
if it fails that return a non-empty list
of error message which he's type alias
to string this guy has done and then
down farther what you can use is the
cinnabon operator or the home alone
scream operator whatever you want to
call it to accumulate errors and so what
you do is you take a few of these
together right so this is like calling
parse age this is like calling parse
name and you take those together and you
put well this whole thing is calling
that and then you you pass it a function
it's very much like like well something
I've been shown you yet never mind so
this is a function that will return if
all those succeed it returns a success
full result of this function otherwise
it gives you a non-empty list of all the
errors
okay and what he says that he he his
epiphany was that the problem with it is
that this type here is to it doesn't
really fit because this is only ever
going to return one error either an ant
or one error message but it doesn't say
that and he thinks that's problematic
and it also there's a problem he
mentions with requiring a semigroup in
the wrong place but what he suggests
people do is use disjunction instead so
now he's rewritten his code and this how
he does it now which is you use his
Junction everywhere and you only so what
this means is if things go well you're
going to get an imp back otherwise
you're going to get a string which is
what error message means and then down
here where you want to accumulate you
actually convert all those disjunctions
to validations before you pass it to to
the home alone operator right and then
you call that home alone operator thing
and then you convert it back to a
disjunction right so I think that's kind
of her bow so he talked about how that's
kind of a roast and how he's meeting
that he made a implicit to make that
less verbose so that's the kind of thing
where I think it's like having two types
adds some complexity I mean type class
coherence add simplicity over here
because when I look at validation I know
what its applicative does but then it
had you know the complexity pops up
somewhere else okay so the way that that
looks in galactic where we don't have
two types is one thing I did was I added
a every type which is there's a
non-empty list in scholastic cold chain
but there's a non empty vector called
every which is really designed for a
functional error accumulation and in
every is either a 1 or a mini so there's
two subtypes of every one is like a sum
and so it just takes one thing so here's
a one that takes the lone element and
many takes at least two right so here's
the first element second mill and maybe
more alright so that's and every is
either one or many and what that allows
you to do is if you really want to write
some method just for you know that will
be immediately accumulate able you
say it's a string or one error message
so you can't actually say in the type
that this is an accumulator Bowl error
but there's only one of them right and
now here the parse age is enter one
error message and then the poorest
person method now returns a person or
every error message because it may be
one or two in this case right but it's
always every error message that happened
and then instead of using a for
expression you use this thing called
with good which is kind of like the
cinnabon operator but not as general
right it's just a API that only takes
orders that's just for accumulating
errors so the difference there i think
that that that's one of the differences
where they they like generality and they
want to use the same algorithm over and
over again which i think is good but if
you're not familiar with FP following to
figure out what that little @ sign part
does is you have to find it in scala
Zeke code there's no documentation and
then if you figure out a set then doing
something with the polygamy got to look
that up there's a paper good paper on
that but that uses Haskell so maybe you
should learn a little Haskell and then
it's just if you don't know if P that's
a big hurdle so for the people i'm
actually targeting i'd rather have them
just call with good follow the with good
method they can look at the
documentation and kind of figure out
what to use so it's it's easier to
google and i think the downside is i had
to do more work i have to write more
code but i think that if it makes things
simpler that that's a way i can provide
value so both you know there's
trade-offs right it's good to actually
minimize code duplication but sometimes
for example performance you may
reimplement an algorithm or in this case
i think is just simpler for the people
i'm trying to reach okay so that's a
usability somebody close these guys and
go to the next one no comment you can
make a comment I've had a time yes okay
oh my goodness okay you're holding the
end all right alrighty so essentially i
wanted to show I mean the thing I just
talked about was was kind of the
trade-offs of general versus specific
with good as a specific API for
accumulating errors whereas the one that
spells he uses is general so you can use
it for other things but here's another
case where I think they tried to make
things general by using a monoid in the
filter method so this is the filter
method on validation and it takes a
predicate from the good type to boolean
that says you know is it still cool and
am annoyed that they use the zero value
if it is not cool and so if you get a
failure back if it's if it's not a valid
and some whatever that function is
testing so this junctions the same way
they also take a mono and they use it
for the this means bad because it's a
left because that little arrows point of
the left that means left left is the
failure side so what I wanted to show is
it was an actual demo in the repple of
what happens when you do that so I've
imported scalzi here and I just made an
age method age field value that is is of
type validation string coming aunt so if
it was successful it's an int and if
it's a failure its a string and I've
made 42 42 is a valid in right so it's a
success so if i do this filter which may
show up in a for expression i'm going to
say is it i'm going to filter out
anything that's not a round number right
divisible by 10 and what I get back is
since this is not I get back the monoid
04 string which is an empty string
alright so my failure message is an
empty string and the good thing about
that is like empty string failure
messages is when you when you print out
the log file you save a lot of paper but
it's a it can be frustrating right and I
just I don't quite understand why
there's and I just sort of feel like
this is too general and doesn't really
fit here so what what you get when you
do the same kind of thing in scholastic
find my code here is
dimage let's also also puts Galactic in
there basically when you do the same
thing you get a compiler error on
purpose because I don't know what you
want for your error message and so what
I did differently which I wasn't sure
was kosher actually talked to this guy
about at one time and he was
non-committal but what I did was I said
ma if I can find it here ok the filter
method on or doesn't take something that
results in boolean it retakes something
the real to this thing called validation
which is this is Galactic's validation
and it's different what it is is a
option with attitude so this guy is
either a pass or a fail and a pass is
kind of like none it's just an object it
means it was cool and it's this is kind
of like the type of a test like when you
run a test you don't really want to
value back you just wanna know it passed
or not but if it failed you want to know
why right so fail actually has an arrow
type in it so that's what I thought made
sense for filter because if this thing
fails I need to know what air type to
return and so if you what you'd have to
do once you gets compiler error is
replace it with something like this
whoops not like that I'm not very good
with computers okay so instead of
passing a boiling expression I have to
pass an expression that actually returns
a validation of in this case error
message and so now what I get is 42 was
not a round number right so I think
that's a I don't understand at least
there may be something I'm not getting
but that seems like a pretty major
usability issue in their approach using
it's like sticking mono it's where it
doesn't really make sense ok so f p+ 00
p I want to actually go to back to the
slide ok hey I'll take this off your
hands for a sec but then i'll meet you
in a sec thank you very much yes
so one of the things that I've had
discussions with 20 Morris about is is
identifier name he thinks I'm too
focused on identifier names that I make
more out of them than I should whereas I
think he and I he probably I'm probably
too focused on it but I think he's not
focused enough and what he talks about
which does make sense is that you want
to actually look at the types not the
names I do agree with that and but he
kind of talks about identifier naming as
if it's a dynamic language and what I
wanted to say was that you know in java
the java way is that that you're really
not reasoning about identifier names
what you're really thinking about is the
contracts of the types and the names
just remind you what those contracts are
so what I've drawn here is basically
what how I got into all this stuff this
stuff was I want to do when I created or
I didn't have a weighing scale test to
say or should pass the Monad laws and so
I've been trying to come up with a synth
nice syntax for laws testing for Scala
test and it means i needed a functor
type class in ammonia tie plus an
applicative type class and whatnot and
so there this is what it looks like
right now in our in our master in github
and what our mo you know basically a
monad in this case is an object and an
object has an interface in an
implication and interface it consists of
these signatures that can be checked by
the compiler and a contract that is got
to be caught looked at or checked by
tests and that's always been the case
what's different about monad and functor
and applicative is that the interface is
just I'm sorry the contract is just
expressed in terms of algebra like
mathematical equations which is a good
thing because it's it's clear right it's
also general so so anyway that's one of
things I wanted to say is that you know
one of the things I've heard from from
folks coming from FP is that they don't
really have a lot of need 400 that FP is
composable and actually realizes the
promise that oh gay but never did right
and what I wanted to point out is that
it is composable FP but that there's
nothing unobjectionable this that what
makes it object-oriented programming
composable is bring efp to it and that's
what Scala is about so so anyway that's
that's what I wanted to say about that
and I think it's you know it's I think
ask Allah is is an object-oriented
reform movement object owner programming
was historically founded in objects have
state in a capsule eight state and what
Stella says is well you can make them
immutable and actually get the benefits
of functional programming so oo does
need FP and FP probably doesn't need oo
i would i would say but what Martin oyes
points out is if you're going to make a
pure FP language functional programming
language you need to have some ways
you're going to scale up you need to
have some way to put your functions into
modules so that there isn't one global
namespace and objects provide a way to
do that so that's sort of what o.o does
is one thing it can bring to FP okay so
what you know I I did want to say lat
yeah go ahead I do want to say last was
this what are these things good for if
you're really like applying them 200
like moneda and applicative in functor i
mean one thing they're good for is
testing because i think it's very useful
to say this should pass these laws and
that you get a nice test and it's very
useful to say these are you know express
your contract saurabh generated
contracts in terms of algebra so that's
where I'm starting and there's other
uses certainly but I haven't really got
there yet okay so the last thing I
wanted to do is look at the standard
library stuff and is can somebody tell
me how much time I have left just oh
there it is that's how much I've left
awesome so one of the things that I
mentioned early on was that I I wanted
to make things fit
the standard library and I do that just
cuz i think it's simpler for users so
one of the differences is that i put the
i had the audacity to put the good value
on the left in the bad value on the
right which was like everybody thought
that was strange and I the reason I did
that is because it it fit better be I
felt it fit better the standard library
that first transform method is try and
that takes two functions the first
functions it takes is the successful one
the success side and the second function
it takes is the failure side the other
track the next transfer method is from
future and it its first function it
takes is for the success if it's a seeds
and the second one it takes is for the
failure and the third one is or the
first function it takes is success so
it's on the left and the second one it
takes is the failure that's on the right
the other one is called by map from
spell Ozzy and the it does the opposite
it takes the error first and then the
success second and it's so or is
consistent with the standard library
disjunction and validation are
consistent with Haskell and there's
nothing wrong with that Haskell has a
very good reason to do it that way and
it's because they partially apply types
one at a time they're all curried so
there's a really good reason to do that
in Haskell and there's no problem with
doing that in Scala that's what you want
to do but Scala actually doesn't carry
types so there's no advantage of putting
it on one side or the other so what I
did is I thought it actually read better
to say you know put the happy path first
int or something goes wrong here message
and I thought that fit better with other
examples in the standard library so ok
so that's that and another example of
what they did was oh these are the old
ones let me get rid of
guys I less safe seeks and okay they
have a couple things that are like
replacements for things in a standard
library like they have one called maybe
where the which is a replacement for
option that doesn't have any hits with a
big fan in the middle there it doesn't
have a get method so you can't shoot
yourself in the foot that way and it was
I think really worth putting in because
of the the the message when the person
submit the pr was this is crazy but
option has get so call me maybe so I
think that was pretty funny there's also
an I list which means invariant list and
the point of that is to get a type-safe
contains because scholars list and all
of it seeks well most of it seeks are
covariant and if you try to say that
contains just takes type a it won't
compile because it'll say that there's a
covariant position a co viet type
parameter and contravariant position and
the reason that there is so because
someone could write a contains method if
you'd allow that if quite allow that you
could write a contains method that blows
up at runtime right so it's not sound
most of these contains methods aren't
Annette way but it could happen right so
what I try to do was um well Paul
Phillips is probably here somewhere he
also had Paul Phillips had also posted
one of these on exists at one point and
I showed an example where you could
implicitly convert away the covariance
and actually get a type-safe contains
and Han Lars Lars at that time was still
in the scholars the world and he they
both informed me that I was relying on a
implementation detail of type prints
prints and and I went back and forth
with Paul in a while he said it probably
won't change because there's bugs that
actually rely on it being fixed he said
but you know it's probably won't change
but I didn't quite like that but I also
wanted you know I I trust Paul but I
wanted to verify so I tried to find a
way to prove him wrong and so what I
came up with was I actually came up with
a way you
do this without an implicit conversion
with an implicit parameter and so this
this type safe contains method on every
was actually every is covariant and it's
actually on the type it's not an
implicit conversion and then I made
there is i added a safe there was an
implicit conversion that would add safe
contains two lists and using the same
technique but i looked at that and there
was a contra minus sign in the type i
was just left in there because i copied
it from another type class and I thought
well actually if there's a minus sign
there that means i could put any there i
think so i tried to take the minus sign
out and i got a compiler the usual
contravariant position yeah so it's like
oh oh so i actually typed in the type
class explicitly with any and it
compiled and so and then I knew I was
still relying on an implementation
detail of type inference and so I don't
have a mathematical proof that Paul was
right but I have a gut feeling he was
that there's no way to do it so then and
the other thing is it's like who wants
to write safe contains what people want
to write as contains so I got to
thinking that it really needs to be
either you need an invariant list or you
need static analysis something does
outside the type system and then I
thought at first maybe we should put
that in the compiler that was my first
suggestion but having done all the
Equality stuff that I kind of was aware
of a lot of it's a lot of complexities
it's not as simple as you would hope so
then I decided right one so that's what
I actually released this morning at two
in the morning it's called super safe
it's a plug-in and if you say list 1 2 3
is ask allah's list that contains one
you get a tiger so i think that's what i
mean if i were designing a language and
a library from greenfield design i would
try to make that a type error in the
secretory I said typer it's not a type
error it's just a compiler error I would
try to make that a type error but since
this is the list that we have then I
think you know this is a good way to do
it the other thing this guy does is
for example it'll say catch things like
comparing an option of string with
string for equality so these are things
that I you know I think are at some
point you need to use static analysis to
find problems okay so all right the last
second last thing I want to actually do
I'm going to grab something on my bag i
forgot to get ready is up these guys
Andrew Andrew and nirman wrote a
puzzlers book and it's a really awesome
book it just came out a month ago scala
puzzlers looks like this so we're going
to give away six free copies of people
who can actually put together these
little cubes and I'm going to talk them
out in the audience like little flippy
cards and we're going to do is want to
sit near the near the coffee stand at
luncheon at this afternoon break and
anybody who wants to buy it sits a half
off its twenty bucks cash only and whoa
oh I got shred it gets on my way in the
back this is fun I'm gonna go wear that
with that side oh yeah sorry this is fun
I see if I hit the back row oh no sorry
I'd hit him in the face I'll trade i did
in the face all right way there in the
corner oh sorry ok ok ok so that's that
ok and the last thing I can leave you
with is kind of this this idea of
gardening where you are I live in
California and where I live it doesn't
rain for eight months out of the year
even when in a normal year and I have a
law or had a lawn and I pulled it up
because lawns take a lot of water and I
planned a native plants that are adapted
to drought right so they don't take as
much water and it we like it a lot
better all my neighbors have lawns and
they're they're really nice i like them
but i'm doing something different which
is i'm trying to make something fit so
i'm not saying that ooo is better than
FB or any that kind of stuff
just saying where we are is on an
object-oriented platforming the JVM is
at heart an object or a platform in an
object or industry and so the way to
sort of make that better is to bring FP
in and merge it with oo in a way that
makes sense to those folks so that's
what I'm trying to do so that's all I
have and I have 15 minutes for questions
thank you thank you
yes you're welcome yeah future gonna
work yeah I think the question is about
is it a future a future a future or a
future of ora ora boar which okay I
don't know but can you come up
afterwards and I won't understand the
the use case but one of the things that
I think like another thing that the
scalzi folks didn't like was try and I
think try is useful for you need it
because anything could blow up with an
exception so you need a type a disjoint
union where the bad type is an exception
because a throwable because it just
could happen if you're going to do
something a sink you really need that to
come back so if you also are calling
something that has an orange side of it
where do you put it you really have
three states now and so one other thing
I thought which was to make an extractor
so the instead of saying success good
success bad which sounds like it's like
a successful bad is weird you'd have the
good the bad and then the ugly would be
the exception but I think that's too
cute but there's something needed I
think for handling three states and I
don't know exactly what it is yet so
you'll come up after and we can talk
about it yes Daniel item maybe it is
i'll have to look it might be but i'll
tell you what it would be I know what I
know what an answered that I just
thought of which is it would work in a
for expression in other words if you
make a filter in a for expression then
it actually works as long as your your
filter your if has something that takes
a validation it just rewrites it it
doesn't care if it's a predicate or not
so I was trying I mean that's another
way to try to make it fit was like make
it work in four expressions and that
kind of thing but but I had actually
when I was doing the we were doing the
applicative stuff I had one of my wif
goods I didn't realize it until we were
doing the book of stuff but it's the
same as map so i should really
deprecated there's a with good with one
thing it is actually map so that it's i
need to be deprecated that one
remove it so so anybody else yes that's
a good okay that's a great comment so
that was one thing I wasn't sure about
either can you I'm sorry can you uh yes
what he said was that the the good type
like hairs or and if I go too good it
says true for bad also okay so or hikes
a grb Great Britain yeah yeah good boy
be where's the good one so the good one
just takes a G but it has both types
right and it's like either either does
that to the other way I could have done
that is just say takes one type and
extend or with nothing because the
covariant that would have worked and
actually the type system was I think
telling me that because I had to do a
cast and if you look in the code there's
one place where I cast oh oh thanks
there's one place where I had to cast
but i think the type system was telling
me I should have done that but I wasn't
sure because you'd lose the type if you
ever go down and want to go back up
you've lost it so I what I did is I did
what either did but that maybe I'm not
sure that's the right way to do it but
that's that's what I did I did make some
syntax to make it easy to deal with I
tried to but I'd be interesting to if
people have comments on that afterwards
to ideas about why it should be one way
or the other anybody else yes way back
in the guy hi okay you said and since
college is a reform
that's my opinion I said that yeah yeah
yeahs anyone said you you move
mutability from oh no I didn't mean to
apply that now I think functional 0 is
still 0 0 and it doesn't need mutable
state what i was saying what i said was
that if you remove 00 entirely from FB
you have FP and FP doesn't really i mean
skull is not an FP reform movement what
needed help was 00 by bringing a
functional and that's that's what i
meant no i don't so not all module
systems are object oriented so wut wut
oo provides to FP in Scala is that's the
module system so that there's one system
but what Martin likes to say is there's
one system in the small that also is you
can be used in the large so it can be
used for the module system but ofp
languages can have a different module
system that isn't object-oriented it
just in Scala it happens to be that is
that answer your question okay oh okay
all right anybody else sure did yeah why
pick a civil or just be multiple I'm
just confused sometimes
oh I don't know I think this one is is
looks like if you look into mathematics
that looks a lot like the the
mathematical meaning so I just want to
this one I think is is nice I don't like
the the that one I find cuz i'm not i
don't think I'm Dyslexic but when you
see a bunch of those i have they kind of
move and i have to really think okay
that one's pointing to left okay that's
a lift left you know I have to do too
many mental hops yeah but but yeah I
mean that itself i think was not bad so
I actually think the disjoint Union
symbol was they designed that after they
watched the money does hi Alec see ya
the future of no no a that's the
question is what is the future of scale
Arctic so I've been trying not to but
what's interesting is that a lot of all
the stuff in squats it came out of
testing and things that from scholars as
people ask for that they also wanted
their production code so there's a lot
there's a quality there that people
wanted to do a cust custom equality for
their testing but they also needed the
production code in very specific
problems they were having that just
wasting their time having to catch those
things at runtime and that bet overlaps
with equal it was something else Oh or
so or came from someone asked for like
Scala tests tests a short circuit
because usually you want to when you
find a bug you actually want to quit and
bail out otherwise you get a bunch of
failures that don't make sense or aren't
don't add any information and it may
take longer but sometimes people wanted
all the errors they want to accumulate
all the assertion failures in a test so
i made a type for that which was
imperative which I thought fit you know
once you kind of go down the exception
throwing things stay kind of imperative
but I wanted to see how do you do that
functionally and that's when I first
came to scholars ian was looking at
their their stuff and
them why they do this way that way and
and so they kind of came from from
testing also and you know pass/fail is
very much the type of a test in your
production code so the Monad an
applicative and functor comes from when
i wrote or i wanted to actually test
that aspect of it and i thought that was
important i really did think that the
scholars e folks were right about that
way of testing so i thought it should
you know be in scala test at some kind
of syntax and I just needed type classes
but there are no instances it's just for
testing currently so that's where I'm
starting and actually there's a bunch of
these type West's is popping up in
various places and and you know there's
not all focused on the same thing this
one's focused on testing so yes four
minutes five minutes yeah um that was
another difference I I sort of had with
Tony I think he didn't like either even
though he wrote it he felt he was you
know people guided him in a bad
direction and what I feel is that it is
not good for functional air handling I
agree with him on that but that it is
good for when you're not doing air
handling and you need a disjoint union
it actually happens sometimes you have
two things are equally valid like you
need to pass in a file handle somehow
and you either have a string filename or
actual java.io.file doesn't matter which
one you pass it's not like one is good
and what is bad right that's what either
is good for SOTA peak and and so i use
it for that so i use or and either
together whereas what I think those guys
well I don't know that I'm not sure but
I get the impression I got was that that
either was bad and you should use
disjunction actually said that in a
tweet so I think that's what he thinks
but uh but I like either I have a
question yes so given that this uses or
as a type operator yes recommend type
operators to other API developers you
mean like the thing I've put in the
middle yeah I guess so if it makes sense
it's just not sure how often it would
make sense uh have you run into any like
weirdness
tax I guess is what I'm asking okay the
only thing that I would be nice is that
when you when you make an or in the
repple and it shows the type or a
compiler it doesn't in fix it so it
might be nice to be able to annotate a
type saying please show this in infix I
think that's already been requested so
it's same thing with disjunction it
shows it the old-fashioned way with
square brackets and all that it'd be
nice if that just always showed up in
fix but otherwise know that it really
works the same so so okay all right I
think that's it thank you very much for
coming war oh yeah thank</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>