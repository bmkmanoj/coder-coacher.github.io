<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Collections: Why Not? | Coder Coacher - Coaching Coders</title><meta content="Scala Collections: Why Not? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Scala Collections: Why Not?</b></h2><h5 class="post__date">2014-01-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uiJycy6dFSQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello I'm Paul Phillips I gave a
variation of this talk last night and
the audience looked like like
shell-shocked genuinely they looked like
they've been through a war and I
realized so I think I'm going to tone it
down tonight
yeah no your turn you're all
disappointed I think I one of those a
week is probably good you got to come
too if I'm going to do back-to-back
nights you got to come to the first one
if you want the exciting stuff so I'm
going to be all chill tonight but on the
other hand I'll probably not actually be
able to hold to that but I'll try yeah
so my slides I'll just tell you up front
of pretty bad they're all over the place
I don't know what's going on we're just
going to have to live with a think of it
as one of those nonlinear narratives
like Quentin Tarantino movie or
something so something suddenly
something happens late this should wait
didn't up yeah okay so it's nonlinear
but you know so we have this little
stable of maybe ten programming quotes
that get recycled indefinitely and this
is one of them
and but it's good and I'm going to read
it when I'm thinking when I'm working on
a problem I never think about beauty
I think only how to solve the problem
but when I finished if the solution is
not beautiful I know it is wrong this is
always on my mind especially when I see
stuff like this at this point I feel
like anybody would know we're doing it
wrong but that you know that thought
process has to take place you got to say
wait a minute are we doing it wrong
well yes you're doing it wrong this
trait you this is pure boilerplate it
has no purpose in life except trying to
pass all those type parameters around it
is a true monstrosity it has dozens of
buddies spread out throughout the
collections it accomplishes essentially
nothing it's the the base this is par
seek view like so it was
views its views parallel I don't know
it's like a bunch of stuff and then you
then you you've got all these variations
on the same those are all just trying to
keep track of what the type of this
thing is
and so that subclasses can figure it out
anyway this is not right this is not
beautiful this will never be beautiful
and this is impossible to maintain this
is not how you do Butte and so now I'll
tell you who I am
um so I guess most of you know me I mean
unless you're brand new to Scala but I
always have to assume there's somebody
in the room who doesn't know me
I wasted about half of my last decade
slightly more on Scala that's a little
unfair I didn't wasted I mean I learned
some stuff but in the end it's a failure
I had to quit because I can't make Scala
do what I want and so I'm going to try
something else but I you know I worked
really hard on Scala and I wrote a lot
of code a crazy amount of code and I
drew a lot of conclusions which I guess
you will hear now but yeah I quit and it
really was a dream job
I mean typesafe was like a fantastic
place to work and they didn't say I had
to do anything terrible and I could you
know basically do what I wanted I quit
because I was just Scala is never going
to be the language I want and I know you
guys are sitting you're going to wait a
minute this is supposed to be the like
pro host Scala thing and I'm you know
I'm not anti Scala I'm just not exactly
pro skål at least I'm not pro on the
inside anymore more of an observer but
this is to show you how why you should
care because that bonfire right there is
me and that's that's about a million
lines of code on github and that's just
the tip of the iceberg I mean I've
written at least like three million
lines of Scala code at least it's it's
yeah I should spend a lot more time
designing to be honest that's what you
should really learn from that but it
does mean that I like every sort of
idiosyncratic thing like you know the
kind of observation that you have to log
n enormous amount of time to really see
I have all those my head so that's like
where my my information comes from and
then here's here's my other credential
891 tickets closed mostly those are bugs
fixed 482 tickets tickets opened mostly
those are won't fix things that you know
I wanted to do and got won't fixed I
don't know about mostly but plenty of
them are 150 of them I think or maybe
still open but I've personally
discovered in the neighborhood of 500
scala bugs
I mean discovered and report in I've
actually stopped reporting them so I've
discovered more have you discovered 500
scala bugs I some days I can't believe
the things I just like nobody's ever
encountered this before do you guys
report bugs I don't know but one way or
another I got 500 on my name and so yeah
anyway the point is that you have to
listen to me you don't have a choice it
doesn't matter what you think of me I
know something it's impossible for me
not to have you know osmotically
acquired some knowledge about scala
in the course of doing this but yeah I'd
like the live really the difficulty for
me here I have no problem speaking my
mind as is probably apparent from like
the things I've written online but I
don't want to be standing here raggin on
Scala all day for both like personal
professional and just like general not
being seen as a giant jerk reasons it's
very natural and easy for me to do so
but that's not what I want to do and
because I did plenty of that last night
I'm going to try not to do it too much
tonight but you can always prod me with
questions and I'm sure you can get get
me going
so is Scala too complex this question
goes around sometimes you hear this hear
that let me simplify yes there's just no
question I think I to me it's like what
are you guys talking about
I mean you these sort of imaginary
metrics about what complicated means are
thrown around not complex you know it
when you see it it's like obscenity and
if you program in Scala you know it and
if you try to use Scala in any way that
pushes the implementation you really
know it and so I mean I don't see how
this is really an arguable point but and
I can't tell you how often people tell
me that they
report bugs because they don't know if
it's a bug I'd say that's a good litmus
test for complex people don't can't even
tell when they see something happening
whether it's supposed to happen
something is complicated somewhere right
I mean they're not all in way over their
head and I include myself in that group
for sure and you know it happens all the
time is this a bug I don't know we have
to go debate it so this meme goes around
it's too complex
well so these are my ideas about like
what one might do in the face of that it
assuming it's problem we can own it say
all right yeah it's complex we're
dealing with complex stuff and it's a
complex implementation you know eat it
or go do something else if you don't
like it
we try to make it less complex that'd be
a reasonable thing to look at us we're
making it less complex or we could try
to obscure it we could leave it complex
but maybe if they don't see it then
we're in good shape as you can surely
surmise from the lead-in we went with
option C as we will see now in detail
the use case the use case is emblematic
of why I don't work on Scala any more so
the use case is what I've just described
it's too complicated people say it's too
complicated let's just not let them see
that complicated thing so here's the
result look at the look at the signature
of map what's wrong with this picture
you guys ever seen when a map actually
looks like it's got two type parameters
it's got a key type parameter and a
value type parameter we sell this as the
signature map here it is a 2b you get a
map B whatever that is I don't have a
clue that's the official documentation
this isn't some like you know fringe
thing but fortunately you can expand it
and then see the full signature which is
also alive it conflates the B type
parameter from the enclosing class with
the B type parameter that comes in
there's no indication whatsoever that
this is totally wrong and that's totally
wrong anywhere this is the official
documentation it's outrageous so you're
thinking
well it's a bug it's something recent
they'll fix it any day now
I'll come back to that in a minute
because I got into this line I guess
this is what you actually have to do to
see the proper signature of map and it's
here where you can see a Kay of VOB and
of that the outer B has been renamed for
clarity here which is the point that you
need to know the difference between
what's coming in and what's going out
when you call Matt this is the earliest
ticket I could find that brings this up
I think it's clear from the problem
description in the ticket that it's
talking about exactly the same thing
obviously Matt B doesn't exist well yeah
obviously Matt B doesn't exist but forty
four months later that's still the
official documentation so as I say your
time has no value that's that is that is
the message I would get from somebody
who in four years cannot be troubled to
change the documentation to remotely
reflect reality oh excuse me my amazing
effect there with a little jiggling
forty four months forty four months but
it I mean that's a long time right this
is the evidence it's a screenshot you're
gonna have to take my word for it that
that's 2014 you know I don't know but
anyway there it is that's your the
nightly documentation from January 14 so
unless they fixed it in the last five
minutes it's still there and so this
it's this sort of like callous
indifference to the impact that this has
that drives me nuts as a person who
reads the documentation you might think
that's true but you can't trust it and
it's intentional that you can't trust it
that's you know if something's
complicated you got to live with it
right I mean it is it's complicated it
doesn't go away by pretending it isn't
and the impact of trying to hide it is
going to be really far-reaching it's
going to extend through a bunch of stuff
so why we it why is there something to
hide at all well here we are looking at
it so we've got map
and we've got math so because what the
what map in quotes is bringing to the
table and this is what happened and you
know this is where things really started
going wrong in the collections is it
took this beautiful pure abstraction you
know I'm like absolute beauty for
reasoning and you name it it's like one
of the like the monadic foundation I
mean everything about it is great and it
put this thing on it implicit builder
can build from three type parameter
nightmare right nothing will ever be
beautiful again it's this guy right I
mean it's like it should have been that
it should be called Gollum Ryan Gosling
I'm sure everybody will agree very
handsome man not Gollum so why why was
this done what what's the what is like
we must be getting something great out
of this right so we're getting what I
call the bit set gimmick the bit set
gimmick is that you can take a bit set
and call map on it and if you map to int
you get a bit set back but if you map to
something that you can't make a bit set
out of then you'll get a lesser type
back like a set that's pretty cool great
wonderful look there it is working
correctly now just come at it from any
angle at all or just tweak it or look at
it funny and it doesn't work right for
instance take the very same operation
the first map and do it in two maps now
taking the collection and calling map F
map G should be the same as calling map
F and then G and that's long gone
because the the intermediate call has a
hole type inference stage a can build
from comes in does a bunch of stuff
invisibly and makes it impossible to
reason about anything so there's a good
example of what happens in the one case
you've got a bit set and the other case
you get back a sorted set and then and
then here we are just map identity right
I mean something map identity is
supposed to be something that's kind of
what identity means but here we are
something map identity and try to get
the one out a wait a minute it doesn't
even compile anymore can build
what's that nobody told me about can
build from I saw the signature of map
it's a to be similarly and this is
pervasive throughout the collections
there are these qualities that may or
may not be in a collection and that may
or may not persist so you've got a
sorted set and you do something to it
you map it you filter it you reverse it
I don't know I guess you get reverse a
set doesn't matter you do something is
it still sorted when it comes out the
other end who knows right roll the dice
and here we see some like of the sicker
sort of things this is essentially the
same problem yet again in that doing
something as a series of steps gets you
a different result in this case not just
a different type but because it's a
different type a different thing those
aren't the same numbers I'm looking at I
mean they are the same numbers but
they're not in the same order because
they're not sorted and the third thing
in the fourth thing here if it's not
obvious are the same thing it's only the
number of times I called math that's
different there's this idea that you
should be able to in a programming
language you should be able to take a
sub expression and assign it to a
variable use the variable in place of
the sub expression and get the same
result this is like just a key it's a
foundation of reasoning now even without
these issues we wouldn't be able to do
that in Scala but this but this makes it
you know impossible and if that's you
know not bad enough we've thrown out
like these what should be these
invariants like if you call map you get
out the same number of things that you
put in this is a you know this is the
this is the invariance of map this is
what math is but instead we have this
idea that you know it's more important
that a set be a set and that you get to
map a set and get a set back then the
map excuse me then that map can do what
it's designed to do so instead we just
throw stuff away on the back end of map
if they have
collide so here you've got a set with
three things in it and you call map and
that first map they all map to three so
whoo there's only one thing after that
because they all just got thrown away
then we call GE and there's one thing
here we do it all at once and then it
never gets a chance to get in the middle
and make it disappear so again now we
have a different size set if you cannot
reason about code you cannot write
correct code it's literally impossible
to call Scala's map from java if you
were going to design a collections
library and java Interop was like one of
the basis on which you sold your
language which is certainly true of
Scala I would think that you would do it
with Java firmly in mind but we've
literally made it impossible to call
into Scala it's again it's can build
from here it is I played with it until I
got two TVs this is in response all the
details are at that ticket this is a
response to my ticket years ago saying
we literally cannot call from map and it
turned out to be true well at least
neither Martin or I could I mean if you
want to like show us some of your stuff
maybe you can figure out how to do it
the variances of can't build from cannot
be modeled in Java Java doesn't even let
me override it with a cast so you can't
do it because Java is broken so this is
like a common theme when stuff doesn't
work blame John just a moment all right
now that I got this nice and wit all
right back are you guys happy to hear
that this is the version where I don't
spend a lot of time ragging on to go
I'm actually trying to race third so I
can get to the part where I don't but I
don't know I'll be honest with ya I'm
emotional about this I invested a huge
amount of my life into this language and
I'm now I have to leave because nothing
good happens that frustrates me and it's
going to be apparent
what can I say won't fix
indeed it won't fix so now I'm just
going to do the laundry list here of
stuff more stuff that it does wrong or
that it does you know in a way that
causes trouble
so the collections in general and every
actually everything in Scala the
implementation details are never
separated from the interface and so
there's and I'll have examples of this
in a moment but it's there's no there's
not even attempt to say that like here's
an abstract model of how the thing works
and here's the implementation it's just
a blob and it evolves like a blob and
it's always a blob the collections have
556 explicit casts as counted by grep
that's just the explicit ones that
doesn't count all the pattern matches to
pattern match casts because you can
blindly cast by wave of how to match
easily enough there's probably another
thousand so here we are the world's most
complicated type system as people think
from some distance and we can't write a
collections library that doesn't have
thousands of casts in it that's kind of
nuts castle just the beginning though
because we suppress variants checks all
over the place because it's unsound so
we have to suppress variants text to
support the model so of course all this
stuff adds up to you know various forms
of unsoundness many of which exist
there's at least a dozen specificity
rules are you know this I'll show you
that by example because I don't explain
it this one is is something probably not
on your radar but it's going to be
gigantic because of the way that
implicit selection and type inference
are codependent I mean that in the in
the clinical sense because of the way
they're codependent they affect each
other in such a way that they are
becoming impossible to change and
because nobody knows
actually what happens in type inference
it's an experimental science with Scala
see all you can do is like you know
throw particles at it and watch them
bounce see you know see if they go
through the two slits yeah because of
this fixing bugs is it crazily difficult
you generally break things that you
can't even see because it is some corner
that you haven't tested yet but people
will discover it for you and report it
as a regression six months down the line
that situation will eventually just
freeze the entire thing in place in the
collections inheritance of
implementation is essentially the the
hammer for all purpose but like
tragically nobody had discovered final
or private and then when you know the
most of these are being written so all
that stuff is out there in the world
it's impossible to maintain correctness
in an inheritance oriented language when
you have methods doing stuff that depend
on the other methods and they can be
overridden selectively it's literally
impossible to maintain correctness
so deprecated non-final annotation had
to be invented for the purpose of you
know two years from now after another
release cycle we can start finalizing
these methods of course I don't think
that I'll be I'll still be giving these
talks at that point I won't be getting
invitations anymore there is a this is
just an example of many many many
possible examples things that if you
don't nail them down upfront burn you
terribly it's really important to be
able to make optimizations like that or
for instance if I take a giant set and
another giant set or a dime set in an
empty set and I'll add am I allowed to
return the original set if you don't
specify these things upfront then people
will just start depending on whatever it
happens to do and surely that's what's
happened here so people can do a
reference equality check on the return
of this and that means since it was
since it says it's a new collection it
has to create it so if you take a you
know some billion element list and
filter it so that you just get it back
you still have to make a new billion
element list these are not small things
these are giant things but
because they're not like nobody's taking
the trouble to nail down these semantics
you get the worst of both worlds as the
user of it you have to assume the worst
as the compiler developer you cannot
make any optimizations variance again um
covariance I mean you guys ever think
about what covariance really implies if
you have a covariant thing or a
contravariant thing for that matter if
variance is in play it's essentially
just an opportunity to not have errors
it'll find a way to make it work why are
we using types if we wanted to find a
way to make it work generally that's not
what we're looking for the compiler to
don't try to find a way actually just
see if you can do what I asked you to do
in a sort of a direct way rather than
like ambitiously looking so for instance
this I've got a list of instant a list
of doubles as it turns out and I put
them together and I get a list of any
Val truly the world's most useless type
any Val
it is literally literally useless if you
ever wrote any Val like intentionally in
a signature you would be nuts you know I
said what are you doing is it some kind
of joke and yet will happily infer it
and you know say hey no problem that
must have been what you meant is like is
the purpose like you know some devotion
to some idea of generality or it'd be
useful I really wish that the purpose
was to be useful this is what my list
does how does my list accomplish this
magic by being invariant oh well that
sounds bad that's Java right there
stuffs invariant they don't get any fun
you can't you know a list of apples
isn't a list of fruits that sucks
well you get the best of both worlds you
have a super type that has everything
except the things that cannot exist in
covariance and if you want you can
gladly your PSP list can just fall back
to the next type up in the case of list
it would be seek for instance so you
would say well it's a it's a co bearing
its sequence but it's an invariant leaf
class and the only n contains doesn't
derive until the leaf class and you're
done it's type safe
and it's covariant so its inference plus
variance that is at the root of like
many puzzlers and just nuttiness the the
fact that there are these implicit
sitting around and in the waiting in the
wings to say here's something for you
that you not at all what you were
thinking of because we need to take
something like can build from all three
type parameters of can build from our
variant
two of them are contravariant one is
covariant and so there's a classic bug
involving fallback string can build from
which is you know a low priority
implicit hiding in pre death but because
two of the type parameters are
contravariant you can be asking for like
some super specific thing involving
lists doubles and did two done it's just
going to dial the variance up as far as
it has to for it to match so eventually
it gets to any ante and says here you go
fall back string can't build from that's
what you want it what it's not this is
what I mean about the various rules
rendering contravariance useless now
please take a moment to look at what's
happening in this slide so that you can
tell me that I'm nuts because I
essentially have probably put a hundred
hours into this one trying to convince
that this is not the useful definition
of specificity on the second line I'm
declaring there are two implicit there's
an ordered any and there's an or list
double that means that the second one
takes lists double as its parameters the
first one will take anything as its
parameters now I asked implicitly for a
list double ORD and I get to any the
reason is that in the same way that when
something is covariant it goes looking
for the deepest subtype when it's
contravariant it goes looking for the
shallowest one which is invariably any
but that's not what i want right you
can't subtype upward you can't subclass
upward right the only way to write
things and to actually extend existing
things is to go downward when you ask
for this there is no chance in the world
that you're thinking well there's an if
there's an order any that's the one I
really want not the Ord lifts double
it's not
and yet in five years I couldn't
convince the powers-that-be of this and
it's you know again that's among the
reasons I've just abandoned the app so
one of the true boondoggles in terms of
correctness in the collections is the
abstracting of immutability and
immutability this in hindsight I say in
hindsight because I did not properly
understand at the time how bad it was
but yeah it's a nightmare you just don't
want your mutable collections to have
all the operations that your immutable
collections do
it's terrible idea that you shouldn't be
doing that with your immutable
collections you shouldn't be like yeah
I'm just passing it around and we'll
call you no filter and debt to de no no
you should be squirreling your mutable
things into little tiny zones and making
them sit there in highly controlled
circumstances and then maybe if you want
to let them out you then you to list
them or something and get the immutable
one and that's what you deal with but
your code if you like correctness if
it's an interesting thing for you to
pursue you should not be treating
mutable things is just like immutable
with fewer letters they're not they are
not it's not an abstraction that you can
do so drop is a very fine example here
so you've got a long list list of a
thousand intz and somebody comes in and
says drop a hundred well so if it's a
mutable thing I can't give you back the
back of my mutable thing or now you can
now there's two guys each of whom think
they have their own mutable thing so I
have to copy it there's no choice but if
it's immutable I cannot copy it the only
reason the immutable collections are
acceptable performant is that kind of
sharing so one of them is wrong by
definition always and that's the case in
a bunch of methods when look that when
you have to override constantly to avoid
the wrong method in the guy above you
that's a sign you're doing it wrong so
in the triumph of code reuse we have 24
concrete implementations of slice slice
is not chosen to cherry pick a bad
example it's just a typical
and in fact it's one that I reduced the
count dramatically a couple years ago
this is the current situation it climbed
all the way back to where it was 24 how
is it possible that there are 24 ways to
write slice can you even think of 24
ways to write slice
I mean if I say if I made it like a but
a gun here and I want to see 24
interestingly different ways to write
slice I defy you to do it so there's
some classics up here list 1 2 3 to set
false can do you know what's going on I
mean if you've seen it before you do if
you haven't you might think what would
somebody like to share what's going on
so all right so Scala will happily just
insert a unit if it if it thinks that's
what you would if it's like what do I do
Oh a unit would make this work then do
it give them a unit so you called to set
and to set doesn't actually take any
Titan any any thing it doesn't take any
parens you need and so because you gave
them it thinks you're calling it on the
result of the two set so you actually
are now calling the apply on the
resulting set and then it says oh well
you know we need that takes an argument
well oh look it's a set of any because
we inferred that because we can because
list is covariant so this is a list of
int but it's going to when it infers the
type for the two set it's like it's a
list of any hey it works so then it's
got a set of any and it doesn't have
unit in it and so false there's no unit
in a set any of one-two-three there's no
type in there think think of the chain
of events there that's like how long
thousand go in mad saying like well if I
follow this chain of reasoning like a
series of craziness then I should just
evacuated you know send on them all out
in the space
there's no way you want to do it any of
that stuff what's the next one another
favorite how could that be
I how can that be so Scala decided that
whatever Java does is good and we have
to do it all so even if it's wrong and
in this case that means if something
takes a float then give them a float
even we wrote an int in the it doesn't
fit in the float and if round happens to
only work on floats and doubles and not
int then we'll just round that down to
whatever and then there we are with
what's left which isn't the same thing
we started with by the classical
definition round I'm not a mathematician
but by the classical definition around
that would not be the answer again no
error there I mean really it's 2014 and
here we are and we cannot make up the
compiler in the world's most typed
language tell us that a list of strictly
integers does not contain your mom I
think there's something wrong with that
that's not entirely scholars fall that's
like the laws of variance to some extent
but it is and it's our fault for putting
up with something so ridiculous that we
cannot find a way to make that an error
it's nuts then we're no good at this if
we can't do that frankly there's like
where we should give up another favorite
there's no actual call to sum here but
this is the the set thing again and this
is an actual bug that we have in the
collections for a while the way a sets
hash code is calculated is by adding up
the hash codes of its elements okay
here's the obvious implementation take
myself map to hash code some great it
works mostly and then sometimes it's
wrong oh no it's the worst kind of bug
because it's not that obvious it just
burns you when people show up saying
like well you know one time out of 100
the thing disappears on me turns out
that if two things have the same hash
code you're only going to get one
because when you map your set you got a
set of hash codes and only the unique
ones survived
now you sum that and and remember this
is for emphasis your you might not even
know it's a set here this summary here
is written to work on iterable certainly
seems reasonable to do it on interval
unit and set never crosses your mind but
then the user of it of course might call
it with a set and you lose sense so this
is this is where we get into
implementation details have infested
like an implementation details and just
ill-considered sort of like let's just
do it the way a first way that comes to
mind have infested the interface to the
great detriment of the overall usability
these are the ways from a distance
forget about Scala that one might
sensibly define a set in each case
there's one method there's one that's
defined in terms of the qualities of the
things in the set that's an intentional
set there's one that is the actual
members of the set that's an extensional
set in the one case it's essentially
just a predicate anything that matches
the predicate that's the set in the
other case it's an iterable or some
variation of that something that allows
you to enumerate the members of the set
both of these are very useful things
they're very different things they're
not the same thing they have totally
different qualities they have to be
considered separately now this is the
actual interface of set as can be seen
by attempting to make a concrete class
that extends set and seen what isn't
implemented so here we have both of
those kinds of sets coming together and
now you see why set has to be invariant
because intentional sets have to be
contravariant and extensional sets have
to be covariant and if you mix them
together there's only invariance left
and then you have these two hangers-on
that I end up implementing with dummies
half the time because why because
somebody thought we need to have minus
and plus on set I don't know for
whatever reason you don't have to do
that on sequence there's there's no
rhyme or reason to
it only requires one method to define a
set everything else is something else it
is not the definition of a set is maybe
it's a definition of a grow a bull
shrinkable set right I don't know don't
you know you shouldn't be cannibalizing
bits out of other things and putting
them on set set can be defined with one
thing purity is not a priority a purity
of interface but purity is that's how
you actually have or usable abstractions
size size is one of the worst so size is
on everything always
you can't avoid sides size is mandated
you have to have a size and it has to be
an int so if you're Infinite forget it
you've got to make something up or just
don't terminate I don't know throw an
exception if size is extremely expensive
to compute you know like it's Oh n like
it is for list doesn't matter you still
have to have a size right there and just
make it available for everybody use just
no protection from anybody calling that
just you know eat it
there's no reason size it should be
assumed to be universally available and
universally an int and you don't gain
anything from it either there's no
benefit it's not like there's no
convenience if you need size to be
universally available you can easily
implicit your way to all these bad wrong
answers if that's like you know that's
your thing but you don't need it to be
but once it's on the core types there's
no avoiding it all right I think I'm at
the end of slagging on Scala let's hope
let's oh I know you'll get me going
again the questions so here we have just
a few things that one might do so most
of the things in here are real I wrote
them already they're simple they're not
like fully fleshed out they're just more
their illustrations because I often hear
people say like well I understand that
all of the complexity the Scala
collections is necessary to accomplish
these things but you know they sound
like abused people honestly even when
they talk like that it's true it's you
know you don't blame yourself if it
seems really complicated more so than
necessary trust your intuition these
things can be done far more simply
this is not intended for you to digest
in its entirety but it's an example of
the kind of thing that doesn't exist in
Scala which is to say an abstract model
of the thing being implemented you need
this in order to have a check on what it
is that you're doing in order to have
something that tells other people what
it is that you're doing if you have an
abstract interface it's you know a level
of abstraction is negotiable
but the existence is not this is just
defining like some names for types and
giving them sensible youlike brief names
defining what they are nothing else
there's no code here other than you know
types but with this you have a
tremendous head start on actually like
knowing what you're doing and creating
something that's going to continue to do
what it is that you think that it does
in such a way that other people can see
what it does so in the collections there
are mutable and immutable collections
there is a division into sequence set
and map the whole thing got doubled with
parallel collections
so there's parallel and sequential and
then everything's got a view and a
regular now all of that is like
simplification because in fact there's
like exceptions and special cases all
over the place
but in principle that means there would
be 24 combinations in there right so
there's like immutable sequential
sequence view right and a lot of those
do exists par seek view etc that's a lot
of freaking code these 24 combinations
as I see it you need 1 out of those 24 a
set as a sequence without duplicates
that's all that it is that's an
extensional set a map is a set with a
buddy that buddy is an apply that takes
a set which has the qualities of map
keys and turns them into values now you
have a map
there's no once you have that you're
done you don't need to have a bunch of
variation different things incorporate
tuples into you know you don't need all
this this nuttiness that exists mutable
collections forget it write your own
immutable collections problem solve
because you shouldn't have mutable
collections in here
parallel collections problem solved we
can't get sequential ones what we'll
never get parallel collections right I
mean it's comical it's so hard to get
parallel stuff right we have these
trivial things are not right forget it
so no parallel collections problem
solved and views are what should always
happen because if you're programming
immutably and sensibly then you are glad
for it to be behaving lazily in these
situations so you're done you want seek
view immutable seek view sequential and
then everything else is an add-on and
then suddenly I have 4% of the code to
write that the main collections do sighs
so that's the problem with size in a
nutshell
maybe it's constant time maybe it's
linear maybe I will never see that
return ever I don't know there's no way
to know but I do know that if I have a
thing that will never return on a call
to size it'd be better if it just didn't
have the method right it's like if
something's going to shoot random
fireballs at you maybe we could just not
have the shoot random fireballs method
so this is what I came up with in order
to make some sense out of size the
reason that size has all these bad
behaviors is that things have to either
lie or tell something they don't know
and they might have to work very hard to
find out the thing that they don't know
so don't ask a question that requires
them either to lie or to do really hard
work ask them something they know when
you ask them and that means like
everything in computer science adding a
layer of indirection I'm not going to
ask you what your size is I'm going to
ask you what you know about your size
now if you know your exact size that's
great tell me I'll take it I'll use that
info that's constant time if your
infinite help me that I'll take it
that's also constant time and if you're
know very little possibly nothing at all
because bounded can be zero to infinity
then tell me that also constant time so
it's going to be constant time you're
never going to lie to me and you're
never going to be running off into lala
land and now I can do something with
that
here's an example of how that works
infinite look I have defeated the laws
of reality an infinite collection told
me its size it's infinite so there's
logic in there that does things like if
you call take ten thousand on an
infinite collection the size is going to
be ten thousand easy you call map on it
since we don't just throw away
duplicates at random it's still going to
be ten thousand we still know the size
and we've we've burned about three CPU
cycles at this point and we haven't done
anything yet that's the thing this is an
infinite collection with two operations
having been applied and nothing no work
whatsoever has been done I guess this is
yeah I was still screwing around with my
slide so we can see here redundant I we
already did contains right yeah aha this
is the the best I could get anything to
do in Scala with this operation I have
them by two orders of magnitude up there
what it's doing is taking essentially
the range from one to a million mapping
it three times dropping the first
999,999 elements and then summing the
last one there's nothing in Scala that
allows for this to do what it should do
which is to say it just index into the
last one and add three right the
operative when you when you do this what
you want to happen is go straight to the
last element add one add one add one
done that's what that does this one
builds all the intermediate collections
why well remember the signature of map
it insists on a builder and there's no
way to defer it so map is going to sit
there building the intermediate
collections best case it will build
optimized range like things but far more
likely it actually has to build a
million element collection three times
to go for the last one so that's a
million times more work than necessary
I'm sorry that only two orders of
magnitude are apparent in the time
that's probably just measurement error
it's more like when you know one
point four to seven microseconds not
milliseconds and then the great tragedy
of all of it is that it was totally
unnecessary because even if you love the
bit set gimmick you don't need to
pollute map and here is an illustration
of it there's a string I mapped to an
int and back to care in Scala the
regular one you get a vector of care at
that point for obvious reasons at this
point I get a string back
why because I didn't insist on building
it here I waited and the same element
type came out as went in and that's all
that I need to build the same thing and
map has a signature the beautiful a to
be the Ryan Gosling signature not the
Golem signature the builder comes in
here this can be implicit if you are so
inclined I don't think that's wise but
if that's the deal breaker since I know
small things are always like oh well
then so that's still really important
that I don't have to force it somehow
okay fine that can be implicit in which
case all of this looks exactly like this
except that it works so we beat the bit
set gimmick without ruining map that's
my last slide so I will I can talk up
here for about Scala stuff as long as
you want but they wanted me to leave
time for questions so I guess I did you
guys don't look quite as shell-shocked
as last night but still pretty good
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>