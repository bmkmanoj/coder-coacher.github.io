<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Category Theory for the Working Hacker | Coder Coacher - Coaching Coders</title><meta content="Category Theory for the Working Hacker - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Category Theory for the Working Hacker</b></h2><h5 class="post__date">2017-08-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KyEHkUacXxQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">you for being here early in the morning
so are you ready to learn the deep
truths behind real programming languages
so and we'll have some fun on the way I
actually got the name of the conference
wrong I apologize for that on the slide
you can see I turned it from a verb into
a noun but let's have some joy anyway
but I want to be as happy as that
octopus so compositions as types is
about this really cool idea
right that's why I talk about real
programming languages right - this cool
idea which was discovered in the 1930s
is that if you formalize the core ideas
behind logic and you formalize the cool
ideas behind programming languages and I
have two specific formalizations in mind
on the one hand we have Jensen's system
of natural deduction which formalizes
what logic is and on the other hand we
have churches simply typed lambda
calculus which formalizes a programming
language and right this is the right way
to do things like what is the right time
to formalize the notion of programming
languages just a few years before the
computer is invented right that's the
right time to do it okay so that's what
happened and then so these are both
formalized in the 1930s and you wait a
bit because that's what you do with real
things it doesn't happen overnight but
all you need to do is wait 50 years and
somebody will have a new idea and indeed
you wait fifty years and these two
things that were both discovered in the
1930s in 1980 William Howard publishes a
paper saying oh look they are exactly
the same thing
right and that gives you a sense that
you've not invented something you've
discovered something so lambda calculus
the core of every functional language in
existence is discovered not invented
right and we know this because God
Jensen and Alonzo Church both came up
with the same idea but it took about 40
years before people recognized oh these
are the same idea and that took another
10 years for Howard to get around to
publishing it okay but that's the core
of why I want to talk about so that's
what the talk it's dreams loop was about
but I'm not going to give you that talk
you can go see it online and if you like
or you can read about it in
communications of the ACM and by the way
I think
so in accidentally mispronounced a it's
not propositions ed and types
it's propositions as types right so the
same thing propositions of logic and
types of the programming language it was
the questions afterwards is does this
connect to anything else and that
reminds me to say oh yes there are deep
connections to category theory so that's
what I thought I would talk about today
is the additional connections to
category theory and this is categories
category theory is basically very simple
here's the key idea behind category
theory you take some concepts that sub
people know really well and you abstract
it to the level where it becomes
impossible to understand
that's what category theory is about
things that you know well made difficult
so what willing to do is give the
simplest introduction to category theory
that I possibly can I figure I'll make
it so simple I'm actually worried I
might not use up my half-hour but I bet
I will well we're speaking of which is
there a clock anywhere so I can make
sure that I'm not late know how great
how many minute have I got left
25 okay give me a hand sickle I've got
five minutes left and then that gives
another ten minutes for questions after
it's right perfect
okay so I'm worried that I might have
made it too simple but I bet not but
this is making as simple as possible
explain as we go on so are you ready to
learn about object-oriented programming
right because that's what category
theory is because we've got objects
except object in category theory it's
the name of a type and then what do you
do what what are types good four types
describe functions right
your function will have an argument of a
given type and return the result of a
given type you can all take the
functions like that so what all you
doing category theory is instead of
calling a type of type you call it an
object and instead of calling a function
a function you call it an arrow and it
turns out there many instances of this
so you can think of a programming
language with types and functions or you
can think of set theory so your objects
are going to be sets and then your
arrows can be functions between the sets
or they could also be relations between
the sets or you can do domain theory and
then your objects or domains and your
arrows are again functions between the
domains or you can do abstract algebra
and your objects are things like groups
and then your arrows are things like
morphisms between groups which just
means morphism is a fancy name for
function that needs a function that
preserves some structure so a group is
something that has a binary operator and
a unit and it just means that the
function takes the unit of one into the
unit of the other and if you've got two
values and you combine them with the
operator of the first group and then
apply the function you could instead
apply the function to both arguments and
then apply the operator of the second
group neither in the second group and
that gives you the same result see your
head's hurting already isn't it
and what can we do with function so
we'll just talk about two simple things
we can do with function you can can you
see the little thingies I'm pointing to
ID with there yep good you've got the
identity function on object a and what
does that that's the function from a to
a guess what that function does nothing
right give it an argument it returns the
exact same argument without changing it
and the other thing you can do is
function just compose them so if I've
got a function from A to B call F and
another function from B to C called G I
can compose them and that's a function
called F semicolon G sometimes written G
F because people like to reverse things
to confuse everybody right and that of
course would be a function from A to C
that's all category theories about just
enough types to know when you can
compose two functions so the answer is
you can compose them if the target of
one is the source of the other the range
of one is the domain of the other so
that means F goes from A to B and G
starts at D and goes to C so that
composition is well-defined whoops
don't want to be there yet and then you
get some laws right the law says the
identity followed by F is the same as fo
by the identity oopsey I've already
gotten the air in here is the same as f
right you can tell these slides are
old-school right I actually I wrote them
out by hand with these pens and writing
things out by hand right I had to do at
each one of these slides about three
times before I got all the really stupid
errors out but there's still some arrows
left so you can point them out right if
you ever have a question just raise your
hand and ask a question are there any
questions yet not yet okay don't be shy
with questions but anyhow identities
followed by F is the same as f ball by
date density
which is also the same of course as Jeff
death and then if you compose three
things it doesn't matter what order you
compose them in and that has a fancy
name that's called associativity okay so
good I see at least a couple of people
nodding so is your head starting to hurt
are you bored because this is all so
simple not quite okay so now we get the
so on videos I'm going to show you the
three most important structures in
programming languages and show you how
those arrives in category theory and of
course because there's correspondence
between programming and logic it turns
out the three most important structures
and programming languages are also the
three most important constructors in
logic so the first is the product so
what's a product so given an object a
and the object V we form the product a
times B so these are sets this would be
Cartesian product how many people are
familiar with that quite a few of you
and if it's a programming language what
data structure are we talking about here
the tuple write or the record so this is
in particular a special case of the
tuple record one with two fields right
and the first field has a value of type
a and the second field has a value of
type B so how are we going to
characterize what it means for something
to be a product well you better be able
to extract the fields from the object
right so you've got a function first
which given an a B pair returns the a
component and you have functions second
which given an ad pair returns the B
component that's boring right you all
follow that not if you follow that
you're not nodding
you're still not nodding ask you a
question people lie about this without
okay I'm going to slowly sweep my gaze
through the room and if you're bored so
far if you understand what a product is
just not your head okay he's asleep
everybody back here is catatonic yeah
now even people in the back row or
nodding good okay so the party last
night wasn't so good that you can't
understand products okay now but there's
more okay what what else do we need to
know but what we need to know is given
some other things see some other type
see I might have a function C from C to
a called F and the function from C to B
called G and then what can I do with
that well given to see if I apply F I'll
get an A and if I apply G I get a B and
I can build a pair from that a and that
B so this function is called funny angle
bracket F comma G close funny angle
bracket right and that just means
building a deep air from a see how do
you do that apply F to C to get your a
component and apply G to C to get your B
component so that's important right
first and second are how you take a pair
of part and then this construct is how
you build a pair and the
we've got a property right indicated by
the diagram what does the diagram tell
us it says if you build a pair using F
and G and you extract first the first
component will that get you from a C to
an a but it does of course just the same
thing as using F right they're identical
and similarly if we go from C D F G to
an ad and then we use second that gets
us to a B but that's just the same as
using G so you can see there are two
paths from C to a one that says do F G
and then do first and one that says do F
and those are both the same that I wrote
this down it's written down here and the
other path says do F G and then do
second and that's the same as G now
immediately we already know some stuff
about our programming language right
because this tells us F and G better not
have side effects that intercept them
are important because if they did write
s G would do both sets of side effects
but F just does one and G justice one so
if they're going to be exactly the same
you better not have side effects so this
is an argument against having side
effects if it gives you nice simple laws
so FG followed by first is f F G
followed by second is G and then this
line is dotted and what's the dotted
means is if a line with a function makes
this oh right more terminology this is
called a computing diagram and all that
means is what I just told you which is
if there are two different pathways
through the diagram from one place to
another that involve applying different
functions they must be equal right so
here's one path and here's the other
path and they're the same which is given
by this equation
and similarly here now let's have got
eight an arbitrary H and all we knows
that H followed by first is F
G followed by H a second which is what
I've written down right here then what
we can conclude is H is the same as FG
that there's only one arrow from C to a
B that makes this diagram commute okay
so if there's a unique s G is unique and
we indicate that by writing a dotted
line here and that has a fancy name
that's called a universal property okay
so pairs so then if we got you can take
pairs apart using first and second you
can build them using FG those operations
are inverse to each other and FG is the
unique thing that makes this work pretty
easy it's being unique important yet
there are all sorts of things that you
can work out from that that are really
useful like you can prove things like if
I start at a D and go from D to C and
then do s J is what would that be well
that would be some other function let's
call it the F G H I I going from D to C
we do first let's call e AE going from D
to C and E followed by s G in brackets
is the same as in brackets e followed by
F and E followed by G what I really need
to be able to write that down too bad
you've all visualize that clearly in
your head right but you can prove that
from it I'll show you another thing you
can prove which is also important
consider
pick F and G to be anything we want
right so here's standard categorical
trick pick them to be the simplest thing
you can think of so I'm going to do is
I'm going to and we pick C to be
anything we want to okay so what's the
stupid simplest thing I could do here
let's pick C to be the same as a times B
now I need something that goes from a
times B to a what's that oh wait first
does that so I'll pick F to be first
I'll pick G to be second okay and then I
get what this diagram and we know it
commutes right so what does that tell us
since if we do a times B and then first
second followed by first that's the same
as just doing first an ad oh by first
second then do second that's just the
same it's exactly so what what what is
for a second going to be well ah wait if
I do identity right so I do nothing to
go from a times B to a times E and then
do first ah that's the same as doing
first and similarly for second so we
know that ID makes the diagram commute
and we know by definition that the first
second pair makes the diagram commute so
that tells us for a second must be the
same as ID does that make sense let's
see I've got this thingy a pair and I'm
going to build a new pair and what I'm
going to build a new pair is from a B
I'm going to take the first component
and let that be the first component of
the new pair and from a B I'm going to
take the second component and let that
be the second component of the new pair
oh that doesn't do very much does it
okay that's it
all right you now thoroughly understand
category theory okay yay give yourselves
a round of applause
okay so let's turn that into a
programming language right so I'm going
to let L m and n range over terms and in
the program level you have some free
variables found in gamma and using the
three variables we're going to build a
term M of type a how many people have
seen something like this before for
programming languages and types not many
of you okay so the rest of you should
now consider yourself initiated right
this is the way that you write down a
type system all you guys have been using
English or Dutch or whatever language
you like to write down your description
of your type language guess what there's
a better way and it's this this is the
standard way to write down to the
description of your programming language
and right it's basically been around
since just before the invention of the
computer ok so gamma is just a bunch of
free variable gamma might be X is an
integer and Y is a character okay and M
might be take the integer and add one to
it well that will give us another
integer and n might be take the
character and tell us if it's a letter
or not and that will give us a boolean
okay so gamma has two variables x and y
x is an integer Y is a character and
looks at X and adds one to it gives us
another integer and looks at the
character tells us this it's a letter
and gives us a boolean and then we can
build an M and pair right which would be
an integer boolean pair so pairing
straightforward and then if L is an a B
pair first of L would of course be an A
and second of L would be a B so category
theory gives us exactly what we need for
doing the semantics of that
so gamma represents our environment
it's just the type that binds the gives
you a value for each free variable and
then f converts that into a value of
type a and G converts that into a value
type B and then your FG pair build you
an a/b pair and then if H is some term
to take your environment into an ad pair
H followed by first gives you an A and H
followed by second gives you a B okay so
we can convert good old type system into
good old semantics using category theory
and how does all this relate to logic so
times we've been using to build a record
what does x correspond to in logic one
of your three main constructors and
correct so x is just conjunction so what
does this tell us if you if M is a proof
of a and n is the proof of B and MN
carries a proof that a and B both hold
and if I know a and B then by extracting
the first component of the proof L I get
a proof of a and if I know a and B then
by extracting the second component I get
a proof of B this by the way is the
second grievous error that I made to
doing me slugs which is M and then at
all these terms here and all the arrows
I should have colored them in red so I
could have just said just look at the
blue bits and that gives you the logic
that's what I normally do that's the
second grievance error in the talk okay
that's it that's products any questions
about products anybody once this is all
really simple why are you bothering to
show us this you've just taken something
really easy and made it hard anybody
feeling that raise your hand if that's
what you're feeling just a couple of
people are feeling that okay why would
we want to make it hard I will show you
why okay
here's the other major data structure
the sum
so a sum is sometimes called a disjoint
union or record variance I think are
what they're called in Pascal what's
what's your favorite name for this kind
of data structure unit Union okay it's a
disjoint Union yeah anybody else have a
favorite name for this data structure
eater either yes and has schools called
either in Ruby it's called this is too
hard for us and most object-oriented
languages you have to go to a lot of
trouble to build this in an
object-oriented language using
inheritance or whatever but you can
write so an object-oriented language
would sort of be like well what a and b
inherits from and inherits for B or
something like that I can't even
remember which way around the
inheritance goes you can probably do it
either way
okay but this is disjoint Union right
and so given an a we can inject it into
the type a plus B so right in your
computer how would you actually
represent this so a might be an integer
and then an A plus B would be something
with a tag field followed by a value so
this injection sets the tag to be zero
say and then copies in the integer in
this direction if B as a character say
so it's the tag to be 1 and then copies
in the character and then your second
field needs to be big enough to contain
either an integer or a character people
used to that kind of data structure IQ
structs for that in C for instance
and now so in less than n write build
one of these things how do we take it
apart we do a case analysis right so if
we've got if F is a function from an a
to a C and G is a function from a B to C
how do we get a C from one of these some
abs well you look at it and if it's an A
you apply F to it but if it's a B then
you apply G to it and then what do the
rules tell us well if you have in left
follow
by F and G that gives you an F and if
you have n right followed by F and G
that gives you a G and again it's dotted
it's universal so if you have some H
that makes this diagram commute you know
that that's the same as F and G what am
I going to do next identity right so
right we pick the simple case pick f to
be in left pick G to be in right to
accede to be a plus B and then we know
that identity makes these things commute
so in left third with in right must be
the same as identity so what does this
one say this is okay look at the sum
look at the sum and is its ah
if the tag is zero then it's an A and
you see a to build an A plus B pair with
tag zero and the tag is one it's a B so
use in write to build an A or B pair
with tag one and oh that doesn't do very
much does it
okay now notice by the way that what
we've done here right what is this was
like saying it says what is an arrow
from C to a times B says any arrow from
C to a times B can be built up by a pair
of arrows one from C to a and one from C
to B right and FG built that and then
given such an arrow from C to a times B
I can get back the arrows to a into B by
a plot composing with first and second
so there's an isomorphism having a pair
of arrows one from C to a and one from C
to B is the same as having an arrow from
C to a times B and so we say with an
isomorphism so it's curly C followed by
C and E a just means I actually defined
that here right curly C of a and B it's
just a set of all arrows from A to B
in Category curly see okay so just using
a little bit more advanced notation and
this is the cool thing about category
theory is everything that I did in this
diagram at length is just summarized in
this one equation and similarly what
does it mean to have a sum it means that
having an arrow from an A plus a B to C
is the same as having an arrow from an a
to a C and having an arrow from the B to
a C so FG the case analysis builds that
up and to take this apart you can just
pre compose your arrow from a plus B to
C with either in left that'll give you
an arrow from a into a plus B to C or
precomposed it within right which gives
you an arrow from B to a plus B into C
so arrows from A to C and B to C so
again we've got lots of morphism okay
and then we can turn it into a
programming language if M is a term of
type A then in left of M is the term of
type A plus B and for the semantics we
just build our term of type A and then
apply in left to the result to get
determine type A plus B that's how you
construct a sum m and in right similarly
oh and then the fun one is case analysis
which looks a bit different doesn't it
how do we do case analysis in our
programming language with a case
expression so L is an A plus B term and
X is if we extend the environment
variable X of type a or we extend the
environment with a variable Y of type B
okay and then P and Q are terms in those
extended environments that give us a C
so House case analysis work do case L of
and then if it's if the tag is 0 we bind
X to the value of a so X will be a value
of type a and then we can evaluate P and
if the tag is 1 we bind Y to the value
of type B and then evaluate Q
okay so it's just as okay so how many
people have seen case expressions like
that before okay so not many of you so
this is a very useful construct right
this is how you pull apart two
alternatives so this is a standard
contract in Haskell and F sharp and
pretty much every functional language
you can name is it's called pattern
matching that's right so the patterns
here would be in left X or in right Y
and then to give this a semantics how do
we do that well let's pair so gamma is
our environment let's do a pair of that
with H and that'll give us an A plus or
B's now we've got the environment gamma
and the a or b and then we can convert
that to a gamma paired with an A or a
gamma paired with a B right how do you
do that well look at your a or B if it's
tag is 0 pair gamma with a if it's tag
is one pair gamma with B and then put
back your tag and then we've got things
that we can apply FG 2 and that gives us
a C so this we need this additional
contract which is called distributivity
here it is right it just says given an A
plus C pair are paired with an A a
choice of an A or a C and a choice of a
B or C we can get an a a choice of an A
or B and a C and this is the function
that goes one way and this is the
function that goes another way oh and
uses this funny thing called cur what's
that well we'll see that in a minute
it's actually going this way around is
the one that we needed okay so that
gives us the semantics and again this is
logic what connective of logic do you
think pluses or disjunction right so it
says well if I thought of proof of a
I've also got a proof of A or B and the
proof is a or B is true because a is
true and similarly with B and then else
I've got a proof of a or B and if I
assume a write you told us never to
assume anything but we're going to
assume stuff if I assume a then I can
prove C and if I assume B then I can
prove C so if knowing a I can prove C
and knowing B I can prove C and all I
know is a or b ah I can still prove C
right because either a is true in which
case C is true or B is true in which
case C is true so either way C is true
and then this is the categorical way of
assigning a meaning to that logic okay
so I mentioned this thing called curry
and that requires this thing called
Exponential's yep I was right it would
take more than half an hour and this is
a little bit trickier so we have to
assume we already know about pairs
products we don't actually need sums to
define this but let gamma I should you
see here but I've called the gala so
I've got gamma paired with an A and F
takes that to a B this is like an
environment that defines everything in
gamma and also defines a what this says
curry F right here's our another
isomorphism for us it says an arrow from
gamma times A to B is the same as an
arrow from gamma to this a arrow D thing
so a arrow B is a function space this is
the type of functions from A to D wait
if our arrows were functions they're
saying objects are functions so if you
have a language where data is one kind
of thing and functions are another kind
of thing that's called first order and
category theory can model that but if
you have functions as first-class
citizens sometimes how its foot so that
your data can itself be a function so
you can function to act on functions or
functions that return functions or pairs
of functions or disjoint unions of
functions or whatever you want then
those are called higher-order funk
and that's modeled by saying oh okay
functions aren't just something in the
category but they're every arrow in the
category also corresponds to an object
in the category and that's what we're
doing here so if that doesn't make your
head hurt it should right that is the
most profound idea in computing the idea
that programs are also data not every
data is a program but every program can
be converted into data and in category
theory you capture that idea with what's
called a Cartesian clothes category
which is a fancy name for just saying
we're going to be able to treat
functions as Zeta so Curry of F takes a
gamma and gives us an A to D function so
remember F takes a gamma and an A and
gives us a B and this takes just a gamma
and gives us an A to B so it stores away
gamma it stores away the function f and
then says wait and then as soon as
you've given me an A I'll pair that with
gamma and use F to get a B it's just
delaying for a bit so in programming
terms this is called a closure so what
happens what's the meaning of this
so curry s is our way of building a
function and if I built a function f
what does that mean well if I take the
gamma and I take a value of type a don't
change the values type a so cross ID
just means leave this part of the pair
the same and you can actually build this
using the angle bracket construction
right this just says start with a gamma
a pair and apply first and curry as to
get the first component of the pair and
apply second an ID to get the second
component of the pair so we've applied
curry F to the first bit left the second
bit unchanged and then apply takes the
function and applies it to the value to
give the result of type B this just says
take a function apply to the value give
a result of type D
and again we can turn this into our
programming language so if in
environment gamma we also have a
variable X of type a and n is a term of
type V then lambda acts yes there's
lambda lambda X dot n is a function from
A to B so X might be a number and gamma
might have some other number in it say Y
is the number and then n would be X plus
y so this is the add Y to things
function which goes from integers to
integers and has Y in gamma somewhere
which is stored in the closure and then
the other one is even easier right given
L is a function from A to B and M is a
term of type a L applied to M if you
will be and then it turns out that the
first one you give it a semantics with
curry and the second one you just pair
up the two things and then use apply so
the semantics is very straightforward
and again this corresponds to logic and
what thing is arrow in logic implication
you've just learned the three most
important constructs in programming
languages the record the variant record
and the function so let me just finish
by showing you two cool things this is
it like this is low filling up to
prepare to have your socks locked off we
look what's the relationship between
products and sums
it's the same diagram you just reverse
all the arrows these are exactly the
same thing we just turned all the arrows
around so it's not like products and
sums are a little bit similar no they
are what's called dual they are exactly
dual
I didn't logic when you learn and an or
are dual to each other by de Morgan's
laws this is explaining that okay so
this is why category theory is worth
learning because you know you'd never
see this in the programming language
right this with this case thing
does not look duel to that does it
they look rather different but no
they're exactly duel and that's what
category theory buys you I just I just
think this is so cool and I hope you do
too and then the last thing is right we
had all these things apply some
morphisms right how do you define
product well it says this pair of arrows
is the same as this arrow same for some
and then for functions it says well see
paired with an A a function from that to
be the same as a function from C to an A
to B function you already learn these
right you learn these back in high
school because all we do is we write an
arrow from C to a how many of these are
there let's say C na or finite sets so C
is a satisfy C and a is a set aside a
how many functions are there from C to a
well if a is three there'd be C cube
right 1/4 if sorry a is C is size three
there would be a cube functions right
one for the first value C 1 for the
second value and one for the third value
so if a is 2 and C is three there are
eight different functions and we can see
that by just writing a to the C for the
set of all functions from C to a and B
to the C for the set of all functions
from C to B and then a times B to the C
for the set of all functions from C to
an ad pair so this isomorphism gets
rewritten like this you knew that
already didn't you and the other
isomorphism gets written like this and
you knew that already as well and the
third isomorphism gets written like this
and you knew that to write B to the C
times a savings just raise B to the 8th
power and then raise it to the C power
so notice that here we've
exponents and products for exponents and
products both in the category level and
at the object level those careful
distinctions that we made between arrows
and objects that represent arrows have
all gone away but other than mushing
everything together you already knew all
this in high school right so it's easy
stuff made hard made even easier
that's category theory okay so I need to
finish now right I'm just going to leave
you with one thought right all of this
was a build-up to explain the semantics
of lambda calculus and to explain deep
connections between programming
languages based on lambda calculus and
logical ideas for natural deduction and
what you learned in high school
right what you take away from all this
lambda calculus should be the basis of
what you do you should use some function
some programming language which is based
on lambda calculus and no matter what
the people with Java and C++ tell you
yeah they've added Lin lambdas as
johnny-come-lately sck but this means no
use Haskell use F sharp use standard ml
use one of the language use lists you
scheme use one of the languages that has
to set its core what's the lesson when
you have a tough job what you should
think is that this is a job for lambda
calculus</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>