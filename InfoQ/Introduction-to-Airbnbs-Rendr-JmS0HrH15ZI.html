<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Airbnb's Rendr | Coder Coacher - Coaching Coders</title><meta content="Introduction to Airbnb's Rendr - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Airbnb's Rendr</b></h2><h5 class="post__date">2013-05-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JmS0HrH15ZI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright everybody how you doin yeah
let's talk of the day you guys excited
to talk about backbone all right me too
okay so i'm spike brim I'm a web
developer at Airbnb which is a local
company couple blocks away and I want to
talk about render which is something
that we're open sourcing today you can
go check it out and github and so it's a
little little library that we've written
that allows you to render your backbone
apps on the client and the server so I
want to start with a brief history
lesson of the Airbnb web app so in 2008
which is when we were founded this is
what this is what it looked like it was
air bed and breakfast calm the little
rails app very static very typical of
the web in 2008 maybe a little bit
JavaScript sprinkled here and there but
for the most part fully server side and
it's beautiful right and it's amazing in
the last five years there's been so much
that has happened I mean I don't think
this comforts even exist five years ago
and so today our homepage looks like
this and this is basically it when you
laid on the homepage as a backbone app
that bootstraps itself and there's way
more JavaScript way more everything I
mean it's probably at least a megabyte
sad to say but there's there's been
there's been so much innovation last
year's and but I think we're not we're
not quite there yet so it's an exciting
time in the world of web apps today
there's all these cool frameworks that
allow you to build rich apps like
backbone ember angular basically you
know there's a million of them there's
another one released every day just like
today render and there's a lot of
fragmentation and this is kind of what
we're seeing mostly this is like the
client-side MVC model it's very popular
these days
so got the client on the top serve on
the bottom basically the idea is most
your app runs in the client-side review
rendering your routing your like model
persistence internationalisation all
that stuff and then your JavaScript app
which is running the client-side talks
to an API for data pretty standard and
the server could be various levels of
dumb and stateless and so we've been
making apps like this this is our wish
lists app which we released this past I
guess about six months ago and it's a
rich backbone app which lays loads data
and you just push state and all this
fancy stuff and you know it works pretty
well it's a its backbone on Rails and
it's it's a pretty nice user experience
but there's a few issues that we noticed
so first of all there's poor SEO you all
know why because the renters in the
client side it's not serving two
crawlers but more importantly there's a
huge performance it because before you
can really render anything meaningful to
the user you have to download in parse
couple hundred kilobytes of JavaScript
and then evaluate it and then finally
you can start to render your UI and
finally there's a duplicated application
logic oftentimes because especially if
you start off with a rails app you tend
to migrate more and more of your logic
to JavaScript to backbone and you start
to duplicate things like currency
formatting internationalization like V
logic weird you know weird model logic
and then finally contact switching so
sometimes I'll be switching between
working JavaScript working in Ruby and I
think that's a bit of a drag and so it's
still a bit of a pain in the ass to
build fast maintainable rich client apps
there's no silver bullet there's no like
great way for a small team to build a
really scalable performant beautiful
experience which is a shame
so we started thinking what if our
JavaScript app could run on both sides
what problems with us solve and wouldn't
this be awesome I've been I've been
dreaming of this for like years and we
getting close so this is what that might
look like this is the Holy Grail which
you've probably probably people caught
report so this is the Holy Grail so the
bulk of your application logic runs
shared between the client and the server
so that's routing your V rendering your
model logic all that kind of stuff and
then of course certain things only
happen on one side or the other whether
that's handling these are like you know
browser events or logging might just
happen on the server but the idea is
your application the core application
shouldn't be restricted to one
environment or another it should be able
to run it both sides and then both both
sides can talk to the same API in the
same way this is this dream and so it
will provide SEO because you're you're
serving up real real content from your
server and initial page load is
drastically faster I can't really stress
this enough we saw Steve suitors keynote
this morning but Twitter you ever
Twitter used to have a hash bring in the
oral about a year ago here have to go so
they that was pretty cute this call
client side is very trendy but then they
ended up spending a year and 40
developers switching the back to client
side are switching back to server side
rendering because performance and they
had a metric which was first time to
first tweet just how long from
refreshing the page to seeing that first
tweet show up and they cut that by five
times which is really significant and
there's that's like very directly
correlated to users staying on your site
you making money so that's this huge and
finally consolidated application logic
because it's all in JavaScript and it's
all in one place you don't have to
duplicate stuff which is awesome
so we started looking around we thought
has anyone already done this because we
don't want to be in the business of
creating frameworks because that's not
really fun to do or good use of time so
we look there's there's a few projects
out there there's meteor which you
probably heard of it's got some really
interesting client server side stuff it
runs on node but it doesn't actually
render on the server side it just has a
phantom j/s plugin which is it can
scrape itself so that was really cool
and it also owns the entire data layer
kind of expects everything to be in
Mongo and it wants to own that and it's
hard to tack that onto an existing app
or two restful api there's a similar
project called Derby which is also a
node framework and this is cool it
actually does client-side server-side
rendering using handlebars I'm just some
really neat stuff it's real time but
again it owns that whole data layer in
Mongo and that wasn't going to fly for
us and you guys might remember mojito
you guys have heard of mojito has anyone
heard of LaHood in the last two years so
it came out in 2010 I was really excited
about it because it was it's just no
jazz thing your your app can run
everywhere but it didn't really catch on
i think there's a couple reasons one is
it's like very full stack it you have to
you think it's good for a green failed
app for you to write your whole app in
mojito and another issue is its yui
which is yahoo user interface library so
yahoo is a bit of a branding problem
with its open-source projects if you're
anything like me when you saw that blog
post announcing mojito you look at the
code sample the first thing you saw was
why you i dot think stopped reading
which is a kind of a sad reality but but
mean he doesn't bullshit and it i would
like to look at that that's would be a
cool another talk so we thought all
right well how hard can it be let's see
what we can do and we started with our
mobile web app mobile website so you can
go check this on your phone if you want
no this is mr bean be calm this was a
backbone in rails app just like our
wishlist sab but we thought it would be
a great test bed to try a new approach
because it's fairly separate from the
rest of the site and it was kind of its
own little code base so we decided to
replace rails with node with the dream
of sharing code between client server
and this is in production this has been
in production since I guess December so
you can check it out and so this was the
genesis of render so what is render its
JavaScript MVC on the client server so
models views collections etc its
backbone and handlebars is the back is
use the backbone of rendering and
there's there's a bunch of base classes
which I'll get into later but but the
basic idea is it builds on top of the
standard backbone classes and then adds
a few more and kind of decorates them
rather than trying to read them at the
wheel because many of us know the
backbone conventions and so why would we
rewrite that when we already have a
community and then finally it's a set of
Express middleware because you know
expresses that the de facto nodejs web
server basically and the idea is express
like backbone has a large community set
of conventions so you can just tack on
render app to an existing express app
which is kind of cool then this is
actually finally
and there's a minimal glue between
client and server to make it all kind of
work together so here's what it's not
it's not a batteries included blood
framework it's not something that you're
going to go to your boss tomorrow and
say I'm going to rewrite our entire site
and render yet and it's not finished so
it's a bit of a prototype which we have
running in production on a few apps and
it works and if you're the Braves sort i
encourage you to to download it today
and hook right on it I'll show the week
in a bit so here are our basic design
goals for render so the first and
foremost is right application logic
agnostic to environment the core of your
application logic is things like what
data should I fetch what attributes on
this model am i interested in how do i
transform those attributes into
something to pass to a view what is my
template a lot of that isn't necessarily
tied to environment and so the goal is
to abstract that out from the
environment so another goal is to make
it a library and not a framework and so
I kind of think of backbone which is
amber so backbone is very much a library
it's kind of a set of set of classes you
can build upon rather than like an
all-encompassing solution for every
problem you ever have and I think it's
easier for people to get started and
it's easier to maintain and then people
can write plugins to do the rest we want
to minimize code that looks like this if
server then do some stuff else these
move stuff if you've got code like this
that's like all of your application
that's a sign that you did something
wrong that's a leaky abstraction and so
of course sometimes you have to do this
but the idea is to consolidate that in
certain places and provide that
abstractions so the application
developer doesn't have to think about
that if they don't have to if they don't
want to him to go along with that we
want to hide as much of this complexity
for solving this problem into the
library rather than that
a code it was important for us to talk
to a RESTful API for all the data
because we already had it it was
powering other apps and it's just the
interest like backbone is set up by
default to talk to speak rest so this
was important for us it also kind of
preclude real time so real time is this
other big area of of research and web
apps which we didn't even address we
didn't want to have a server-side Dom
there are implementations out there but
they're slow and it just doesn't feel
right to have to use a server-side dome
and like I mentioned before we want it
to be some set of a simple Express
middleware that you can include into an
express app so there's a few base
classes i'm just going to mention
quickly that we provide so there's a
base app and app is the kind of context
that is the glue that holds everything
else together every model view
collection has a reference to app which
is a kind of an unfortunate thing that
comes from the fact that on node you
have these concurrent requests happening
at all times and you can't access to
global the browser's where you might be
used to saying window dot dot you know
whatever and mutate state or access
state you can't do that so we have this
app that we will inject down to every
class there's a base model which
inherits from back will model so i
forgot to mention that app also inherits
from back from model we do that mostly
so we can set attributes on it and we
can listen for changes on metra beats
it's just useful so base model extends
back one model and that provides just a
few utilities for making it easier to
work with in render and do you handle
like whether you're on the client server
based collection is the same same idea
we've got base view and that's a little
more interesting on the server we have a
ride all the dom methods and we also
provide kind of a view life cycle which
is similar to some of these other
backbone i get plugins I'll get into
that in moment we've got a nap view
which extends base view and is
responsible for kind of global events
like these are action user interaction
events we've got a client router in a
server router which extend a base router
and this is this is not the backbone
router this is just a class of our own
so base router handles holds all the the
common logic between parsing routes and
and matching routes and handling that
part of the app and then the client
router has a backbone router that it
that delegates to and the server router
will just delegate to express there's
also we have like a model store in a
collection store and a fetcher and these
are a few classes that just make it
easier to manage like bootstrapping data
into your application and I'll get it to
that a second so I thought it might be
easy to start with a directory structure
of first render and then of an
application so render is the library
right not the application so render has
a few main directories things are split
out into client shared and server than
their sub directories and the idea is
that client and shared we will send to
the client will send to the browser but
server obviously we won't server might
hold things like middleware and the
server router and then client will have
the client router then shared is the
bulk of it right there's like the base
base app the base model based collection
and so in an application there's a
pretty basic directory structure there's
the app directory public which is assets
and stuff and then server which is
server specific stuff like Melbourne and
so if we look into app there's this kind
of looks like hybrid of a rails app and
a backbone app kind of so there's like
collections and models which you're used
to we've introduced controllers there's
views and templates and then a few class
a few a few modules here op je s which
is your your base application context
that ties it from together is a router
and a routes file and so the entire app
directory gets sent to the client
because this what's shared so one thing
that's really neat about this approach
my probably my favorite part is using
stitch so I don't you've heard of stitch
it's it's similar to browserify it's a
way for you to package up your modules
to use them in a comma J s way in the
client side and it allows us to use
modules in the same way on the client
server so on the server we might say far
user equals require and then the path to
the user and one thing that we can also
do on the server is so render is shipped
as an NPM module so you can require into
an NPM module to get at the modules that
are inside of it so we can say base view
equals require and then the path to that
base view within the module using some
stitch trickery with grunt and our
deploy process we can do the same thing
in the client that's exactly the same
that's that's really neat because you
just think about the path to the module
you don't think about it ought to deal
with aim to hear anything like that
and here's the rouse file it should look
similar to rails basically you're
matching a pattern to a controller in an
action you can also pass additional
parameters if you want to but in this
case this is the users controller and
the show action so I'm going to walk
through the rendering cycle of like
rendering a user's show action it's a
bit complicated so stay with me she so
on the server it looks like this when we
start the Express server will parse that
routes file and mount express routes on
the on the Express app that correspond
to each of those rats and then let's say
we've got a request coming in for users
/ some ID user / 1337 so this is this
comes into the server expressible will
handle it'll match a route so the so
then we have a router class that matches
that pattern to the users show action
and then it'll also create these prams
right and so it pulls the ID out of the
pattern out of the URL and grabs that so
ID equals 1337 then the rider will grab
the controller and so we use naming
conventions just to make it easier so
users corresponds to users controller so
the router will grab that it will
execute the show action on the user
controller and pass in these params
and then what the action does is the
action to responsibilities fetching the
data and saying which view to render so
the action in this case will say fetch
user number 1 through 37 and then use
the user show view class to render this
page so then the router will take that
information it'll render the the it'll
create a new instance of these are
showing you and it will inject the data
and then I'm not view instance that will
call gate HTML so that's not that i've
added to backbone view to the base for
you so get HTML will do things like you
know evaluate the template with the data
and it's the outer HTML of the view and
then we just hand that to express
express decorate set with a layout and
serves it so it sounds pretty basic
right like a pretty basic kind of
rendering flow of any NBC app it's very
similar on the client side with a few
differences so instead of on server
startup we have on page load the router
will parse that routes file and mount
each one of those is a backbone route
and when a push state event comes in is
its alter state if you don't have pushed
state enabled then you just fall through
to the server we don't you can deal with
it in size so when the first date event
comes in for a certain path the router
will match it to controller in action
frames it will find the controller it'll
actually keep the show action with the
parameters mr. action says to fetch this
data use this view the router will then
instantiate the view with the data
social sound familiar and then the where
the difference is the router calls view
render and so that will then the view
create a Dom element and insert all of
the HTML into the Dom element and then
we just insert that to the dog so this
whole part is exactly the same all right
this whole part is just application
logic and it's not specific to
environment at all now the rest of it is
is specific to environment but it's
analogous it's like this part it's a
parallel metaphors that doesn't make
sense it's parallel and so that's the
ydn render so I want to look at some
code so here's the user's controller
with the show action and it's just a
real basic common j/s module this is the
most trivial case so we've got the key
here is that's the name of the actions
show and we pass in several things to we
pass in prams and then a callback
parameters in this case is ID equals
1337 and the callback is it's kind of
like the render call back so right here
calling it first argument is null which
means is the first argument and low GS
convention is often an error so this
means there's no air and then we're
going to execute it with telling it that
this is the view we're going to render
and that's that's like the total trivial
case this is if you're not specially any
data you just rendering an action its
synchronous that's what you do but
that's not very interesting so let's
actually fetch the data
so it's a little more complicated once
we fetch some data but basically the
idea is we specify which which model or
collection we want so here we're saying
we have a model property and then that
corresponds to a user model with frames
within you passing these params and so
prams ID equals l 337 and then we have
we have access to our app here our
little app instance because we're
executing this within the context of the
router so you can call this stock
redirect to this dot a few other things
but the app is kind of the glue so the
app has a fetch method which delegates
to some fetcher class so you pass in
what you want to fetch and then you give
it a call back and so when it's done
fetching or it specially from the cash
it will it calls the call back and so
that first parameter is air so say there
was a 500 from that from the API or 400
or 40 for whatever you can handle that
in middleware so it just passes that
through and then you tell what view is
and then results here is an object for
the kia's model and the value is the
actual model instance so this is a bit
of abstraction right because you can
imagine we could just create good new
bar user equals new user user got fetch
what what abstracting this does is it is
it gives us some flexibility and and it
gives us like there's a caching that can
happen there's air handling also it it's
important for the bootstrapping part for
that first render and I'll show you how
that works but basically when we fetch
all of our data for a certain view weed
up needing to bootstrap it onto the page
and so this will handle that part
and now remember this code gets run on
both sides this is run on the client
side on the server side it's kind of
hard to wrap your head around at first
so one push to action thistle soul this
is what execute it will fire an xhr to
the API get your data down the server
it'll just go straight to the API so
let's look at a view this would be the
view for this action so we're going to
extend the base view and you can see
we're just using like the commonjs
pattern because we reason stitch here
and this is just classic backbone right
so basically that extend will pass in
some stuff and so here we're passing
class then you can also add events hash
and all sorts of other methods but you
notice there's no render method stay
tuned for that and we're also adding
this ID to the constructor this is a bit
of a this is this is one thing I'd like
to find a better way to do to do this
but basically the constructor the view
needs to know what it is and that helps
for hydrating it later once you get to
the client side so okay yeah so we could
add events to this event handlers
different things so this view does get
run on both sides but none of that event
stuff will ever happen on the server
it's just for the client and its
convenience to keep it in the same in
the same class so that's the users show
view here's the users show view template
and it's very basic we're just going to
say username from settings this is
handlebars and what this turns into when
you render the HTML is something like
this so we've got our Dom element with
the class name you specified we've got
our content but there's a few data
elements here it's our data attributes
we've added so the first one is data you
and that specifies what the view class
is that we rendered
that it corresponds to and that's
important for once we get to the client
side we need to match that up with an
actual class we also specify with the
the user sorry with the model name and
the model ID are because we need to
fetch that for the bootstrap data so you
might be asking where the data come from
where's the render method how do i
customize what gets past the template
and the answer is just sensible defaults
so my one of my hypotheses about views
is you should never write a render
method ever unless you're doing
something custom which is what Daryl
saying there's a few methods you can
extend so let's say so by default the
view like if you can render if your call
get HTML it knows what the template name
is based on the name of the view and
knows what data by default because if
you pass it a model or a collection
it'll basically just called to JSON on
it and do something smart but if you
want to change that you can so there's a
good template data method for example
which by default is just model to JSON
so let's say we want to decorate what
we're passing to the template with
similar data so we call super here with
JavaScript and so data in this case is
basically just model to JSON and then we
can decorate that with let's say name
uppercase because we're very shouty so
return extend the data with name upper
case then we can change our template to
have the key and then there it is so
that's just a little example of with
views there's a lot of other stuff with
views there's actually this whole view
hierarchy and a declarative way of
nesting your views using a hand wash
helper but I don't think I've time you
get into that quite yet so stay tuned
for future updates here's what
that HTML looks like in the context of
your entire page on your first load so
this is a bit simplified but and bold
here that's that's our view the rest of
it's in the layout and at the bottom we
bootstrap our app so we create our appt
instance and so window dot app is app
and that's release for because you can
go and look in the inspector and type
app dot router you know all sorts of
stuff and it's kind of inspect the state
of your app and then we have a bootstrap
data method so this is everything that
we've all the day that we that we
fetched in the controller we want to
pass that through so it can be hydrated
into like real classes once we get to
the client side so in this case it's a
user as the data and whatnot so this
leads to view hydration so one of the
tricky things when we first came across
this problem is so do you when you load
the page how do you attach all your back
one piece with the elements how do you
touch with the right data you just you
can do two things basically you could
just rerender everything and throw away
what you had and then you would have
then all your events are bound and
you've got all everything created nicely
but then you might be a flicker and you
might lose some important context
because somebody could be typing in a
field or whatever dude was that so the
other approach which is what we decided
upon is to reconstruct your your
backbone classes based on the dom so
that's what i'm calling you hydration so
the first step is find all the Dom
elements with a dataview attribute
because those are those represent views
and so this is like kind of pseudocode
to go along with it but basically we
would use jQuery and find all the
elements and then
we want to look at the data attributes
and figure out if it corresponds to a
model or collection or both and so we'll
figure out what's the model name what's
the model ID and if we were to log this
out and our little example would be user
in 1337 so we know we know the name of
the view we know that the name of the
model so then we would affect fetch the
model or collection data from either the
model store the collection store and I'm
not going to go to detail about this but
but that's when we bootstrap the data
we're just shoving everything into the
model store the collection store so we
can save our model equals model store
get model name model ID and that will
return us like an actual user instance
so then we need to get the view class
like the background class that
represents that view so we'll grab the
view name based on the data element will
wreak up require that module then we
just instantiate the view instance
passing the data so in this case will do
bar view equals new view class passing
the model a few other things and then
we'll attach to the Dom element that we
already have found so if you set element
ul and then delegate events and that's
pretty much all we need to do so then we
have we have our view hierarchy can be
reconstructed in the client side the
real they're real backbone views they've
got their proper models and the beds are
bound and so that point you just have a
backbone out and then the final step is
profit
so it's it's a bit of a hoop get to jump
through it but then you've got a fully
working back one app we're running the
client side you brought you browse
around it fires per state events and
it's just like any other back when I've
ever seen except for that whole first
step so render is available starting
today look under your seats you've got
render it be let's get it should put
that Giffin so if you go to Airbnb /
render you can check it out disclaimer
there's not enough documentation I'm
working on that there's also a sample
app which you can check out render dash
app dash template which you can find on
the github page and it's just a real
basic app which uses the public github
API as an example so i encourage you to
to boot that up and see how it works for
you so there's still a lot to do because
it turns out this is a really hard
problem and it's really difficult to get
the right abstractions and you have to
touch pretty much every part of the
application so one of the things is to
properly share the routing logic between
client server so right now i mentioned
we're using backbone router and backbone
history in the client side to do all
that matching and then we use Express on
the server side that works except for
some special cases so until backbone 0.9
point 10 which was released I don't know
month ago if your URL had a query string
in it then it wouldn't match so you know
how to duplicate all your routes or hack
around that another thing that's
interesting is before matching all of
your routes like if you if you have a
backhand router and you list your rat's
backbone reverses the object or the
array or whatever and then it matches
them which is kind of strange so to
reverse those another one that fit us in
the butt a couple days ago on production
was trailing slashes
so so an express if you have trailing
slash it doesn't care it's just you know
a little it's the works fine the
backbone of trailing slash doesn't work
so I just got to run that for now a
really simple Express middleware if
somebody lands on your on your site and
the trailing slash just redirect them
with a 301 that works but if we shared
that all that logic in a single module
then it would be Nishan so another thing
is I'd love to be able to lazy load like
view classes and templates and model
classes and stuff so at the moment we
package everything up into one big
bundle which works fine for smaller apps
but as our appt grows it makes more
sense to lazy load this it'd be cool to
support other templating languages so
there's a few handlebars view helpers
which we're using which allow you to do
like nested view hierarchies and stuff
but that's almost kind of a separate
that came to be a separate module so
it'd be cool to support jade and
whatever else is like coffee cup eco ejs
hell yeah me I don't know and I'd like
to break it down into smaller modules
because like for example the view
hierarchy could be its own module this
router could be its own module which you
could just use with a Express app
without render there's a lot of a lot of
these little concepts which would make
sense to break out but in our prototype
and are getting things to work on
production it's just kind of all in
there so there's there's some cleanup to
be done and i invite you to help also we
need to rewrite it in javascript so
right now it's mostly CoffeeScript I
know it's controversial it's probably
not actually as controversial because
you're all front-end developers mostly
but if you go to like a nodejs
conference and you say it's all copper
script people will be having so I think
I think it doesn't make sense to write
it we write at javascript because it's
easier to solicit contributions from the
community it's less fragmented
so that's ongoing feel free to help out
and there's a lot more to be done
because you know I said one of my goals
was to create a small library which you
can build upon rather than a framework
but it turns out for immature useful and
right now it's somewhere in the middle
so it forces some some amount of
structure on your app and it'd be cool
to make that more modular and support
different use cases so hackers are
wanted I really would love if if you
guys are interested to clone the repo
hook around in it and submit some issues
because it's really only a few months
old and I needs a lot more work but I
think this is an interesting approach I
don't so for render I'm not itten I
can't any for it to be like the next big
thing that everyone uses for every app
it's more of a prototype and it works I
running in production but I imagine that
it's like one stepping stone along the
road to a much brighter future and
there's tons of different approaches you
could take so in fact there was Tim
Branyan had another talk earlier today
on backbone on the server and his
approach was very different but also
very similar and then Lori is doing a
talk tomorrow on background the server
as approach was very different to very
similar to both of ours and so there's
like a lot of I'd imagine a lot of
people trying to sell the same problem
and there's some common ground which we
can take advantage of so that's it
that's actually all I have so I guess I
have some time for questions and I can
even show you some code
code cache ability okay caching so
there's a couple different caching a lot
different layers of cash from there
could be right so you're talking about
like what I mentioned caching of X hrs
in the views okay so the only caching we
do right now is if your if you try to
fetch a model certain ID or collection
with certain parameters and we already
have it then we won't refresh it and we
each cache at memory so while we were
cashing that a look of storage which is
cool but that introduces a whole other
set of problems like what if there's
different users using it privacy
exceeding your quota so we took that out
so we're doing some very basic caching
so if you just cashing within a certain
page refresh now you you could add other
layers we don't we're not cashing fees
or anything we have precompiled
handlebars templates you could add a
caching layer on the server or in it
like a reverse proxy and that wouldn't
have anything to do with render itself
so to summarize what he asked is how the
heck does the few hydration really work
and you're right so the idea is we go
through and let me look at a real app so
this is Airbnb mobile oh wait you can't
see that can you
it's really good resolution so
I'm good knocking knocking him here
okay so this is this is not bringing on
production submit a bunch of different
views this is like the listings show
page you can click to other places it's
really it's really fast right for state
it's pretty cute okay but your question
is about view hydration so if we take a
look at the source here
so there's a bunch of different views
that have this data view attribute and
for so here is the listing view you can
see that all right so yeah so so we just
go through and look for every dime
element that has an attribute like that
and then we can require the class and
then you know the model appropriate
model illness thing or model or
collection and that's about it and so
Tim branyan he he did that the flicker
and in his approach he didn't do this I
think mostly cuz it's hard and it was a
bit of a prototype and so but it
basically works right so you create a
view class for each one of these views
and one thing that it does as well so
you see that there's views with
interviews here so when you hydrate
it'll go through and create a hierarchy
of views and there's a parent and
children and so they can reconstruct all
that and attach the right context and
attach the right models and clutch for
each one of those which is actually
pretty cool I think the answer your
question oh and then at the bottom we
bootstrap all the data and so if you if
you have an optimized API endpoint like
a public API which are developing off of
which has a bunch of extra crap in it
then this might be a bad idea because
we'll be all this stuff which you don't
need but if you can have control over
your API responses it's not so bad
question yeah when you built this did
you consider building off of wow this is
loud did you consider building off of
backbone marionette or chaplain or one
of these other libraries that already
adds it some of these additional
features to the client side that's a
good questions so I looked at those
looked at marionette a bit I think they
all have really useful useful things
that they add on top of render I think
they can all a lot of those can be used
directly with render or can be
you could create similar plugins for
surrender so I don't think render should
have opinions about a lot of those
things right marionettes a great example
of things which you can add on top of it
to make it easier and I would like to
leave that to the community but
definitely some of those concepts
chaplain is really cool if you guys
haven't seen chaplain it's awesome it's
an application framework built on
backbone it's all in CoffeeScript and I
was actually inspired by them a lot so
my routes file looks exactly like the
chaplain routes file that's where I got
the idea for controllers and they do
interesting stuff with how like events
they all or so all the modules
communicate with each other through the
events which is really neat I I'd like
to actually be more inspired by it it
got a few more minutes you guys wanna
see more code
how much so how much traffic can it
withstand so far a lot I mean our mobile
app doesn't even get like a whole lot of
traffic but we've got three web servers
running an AWS supporting this and the
only reason we have some moneys for
redundancy I mean CPU is like pegged it
basically zero I mean the notice super
fast compared to Ruby or rails which
this replaced we're not seeing any
issues there but I imagine those issues
might arise once we once you started
pushing push it harder one thing nothing
that element I didn't mention before is
like session management this is
something that we added in our apps but
isn't part of the framework sorry or the
library excuse me but it's easy to add
you know it's just use the Express
session middleware and then you can you
can add it to the to your app instance
and i'll i'll create it I'll do that in
the this sample the app sample so you
guys can see it most of any more
questions I've got three more minutes
and now to show you some pit okay cool
so
so let's take a look at a real live app
so this is our mobile website that's a
good example so this is this is the
search for you which corresponds to new
to this so you'll notice there's this
you helper and here this is including
the search bar view here with no
arguments here we're including a search
listings view passing in the collection
so this is this is an interesting
concept which i think is actually
separate from render but is pretty
useful so the idea to declaratively nest
your templates and so this will create
this will actually create a view
hierarchy in the client side so if we
were to look so if we did well first of
all here's our appt instance right we've
got appt dot router which is a which is
the client side router we can do ab dot
radder current view which is the search
for you so you see here this is the
current view and then you can also
inspect different stuff in here right
there's a who's the model here it's a
collection I think it's a collection
give you different stuff on it what
but there's also child views so in this
case there's two child views and this
was all created using that view type
that view helper and so we've got the
search bar of you let's look at the
search listings view so you can see
these are the listings this actually
subclasses something which there's like
a couple levels of object-oriented
hierarchy here because it's this like
infinite list view so there's infinite
scroll and it manages that and we use
that a few different laces but but it's
neat because if we look here child views
there's each one of these is super back
with you if it's on model that's kind of
neat what what else is so I mentioned
bootstrapping so we've got app that
fetcher which is a little utility that
helps us fetch things then there's like
a model store and there's a collection
store and this is kind of a central
place to stick these things when you
when you fetch them from the API so the
model story we've like
so we've got all these different
basically all these different objects so
you can see this is the model the model
name and ID and one thing that's neat is
so let's say we refresh mmv calm it
returns the full page no flicker or
anything and then but we loaded we've
been stretched every model for each of
these listings and so what we can do is
we'll click on one of these and that was
instant right because we already had the
data for that model but we don't have
that's a smaller representation when we
get it in like a collection like that so
we had a few really important things we
had the name we had the photo the first
three photos and so what we'll do is
we'll instantly render that but then in
the background it's actually doing a
fetch oh geez but we're we're fetching
from the API and then re-rendering that
smartly so that's that's like anything
that's actually built in to render so
far what does it look like you mean like
the actual you I or the code yeah sure
so I actually might I'm just about out
of time follow up on that with me I
think that's all I have so if you have
more questions or what you want to talk
come find me I me on Twitter spike REM
find in github find intervene be a
github and we're obviously hiring we're
trying to hire as many great Jesus great
engineers as we can so that means you
cyber attacks me alright thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>