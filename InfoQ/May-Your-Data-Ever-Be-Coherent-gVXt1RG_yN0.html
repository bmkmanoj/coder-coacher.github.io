<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>May Your Data Ever Be Coherent | Coder Coacher - Coaching Coders</title><meta content="May Your Data Ever Be Coherent - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>May Your Data Ever Be Coherent</b></h2><h5 class="post__date">2014-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gVXt1RG_yN0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">coherence what is what is data coherence
well this is basically the word I've
been using to describe a concept that's
been kind of peeling around the the
corners of my brain for a while and as
with most thing most things in informal
research it probably already exists and
it's probably already been described and
it probably has papers that were written
about it 25 years ago and so there's
probably a term for what I'm describing
here but as is the case they did
informal research I haven't been
bothered to actually look it up so we're
going to call it coherence for now and
go from there what do I mean by it well
basically what I'm referring to is the
the problems in the design
considerations which arise when you have
multiple data that you have to work with
together in the same function which is
to say almost every function ever so
here's an example of this now this is
obviously the stupidest possible way I
could write this function but I'm
writing it this way to prove a point the
coherence issue that I see in this
function arises from the fact that we
have two input parameters we have two
lists of integers that we're trying to
put together in this sort of merge
algorithm right and the fact that
they're coming in as two separate lists
is a problem because it means we have to
make some assumptions there have to be
some prerequisites about relations
between these lists and relations
between stripe these lists structurally
in order for us to put them together
same length and in fact these
assumptions cause problems in the way
I've implemented the function so
obviously this predicate right here is
the source of bugs right because I'm
only testing the left-hand list if the
right-hand list is too long then we're
losing data if it's too short then we
actually explode so this is this is
really really bad and this is not a
particularly good way to write the
function a better way to write the
function would be to split out our
prerequisites split out our
preconditions between the lists and have
a different way of encoding them so we
could have a function that instead of
actually doing the the summing right and
the the logic that presumably were
interested in at the pairwise level we
could actually just pair up the lists
together and this would probably be
implemented as some sort of zip or
something like that but you know this
would encode all of the all of the
assumptions that we have about the two
different lists and it would have a
different way of communicating back to
the user that or the user of this API
that something is wrong if these
assumptions are violated right it
doesn't even necessarily have to return
a list of int pairs right it could
return an option of list or a validation
of list and given that we could write
this function in a much saner way where
we just take a single input list we only
have one data to deal with we don't have
any assumptions or preconditions about
our different parameters we only have
one thing and therefore we can't have
these sort of you know errors where we
line things up however there's still
there's still some coherence issues even
in this snippet right despite the fact
that we only have one input data we
still have multiple expressions within
our function and these expressions are
slightly incoherent so we have for
example we have a conditional right this
conditionals checking to see whether or
not the pairs are empty the pairs lists
are empty and then in the else clause we
have some expressions which are actually
semantically dependent on the results of
that conditional without being
syntactically tied to the conditional
itself so we get the head and the tail
of the list without actually being tied
to that's that conditional and sure
right we can make an argument that is in
fact correct that this code can never
really fail because you can't get into
the else clause if the list is empty but
you know that that's an argument that's
something that we have to do looking at
the code as humans because Scala doesn't
have strong enough syntactic static
analysis to answer that question for us
and I would argue that writing code that
depends on these sorts of arguments is
bad and it makes it hard to understand
and it's another form of incoherence
this time at the code level not at the
data level it's much much better to
write a function in this way where you
have the conditional and the data
extraction tied to the same thing in
this case with pattern matching so you
can't possibly have any incoherence
you're basically taking these two
expressions the dot tale and the dot is
empty and merging them together into one
thing so that their coherence is
directly expressed
so I'm going to talk about three
different areas it was going to be four
but I ran out of time I'm going to talk
about expressions and loosely tangled
expressions which we've already seen
some examples of I'm going to talk about
sequences because sequences are really
interesting and whenever you have you
know a lot of things as opposed to just
one thing you can have that many more
bugs and finally we're going to talk
about parametric city because I think
parametric city is really the payoff to
thinking about these sorts of problems
because it's where you get to get some
validation and some static verification
out of being more disciplined in how you
write your code so also despite the fact
that I had to cut entire section I think
we probably have a decent amount of time
so if at any point anyone has any
questions go right ahead
expressions this is another form of the
example that we saw earlier this is the
get or else function from the option
type right and it's kind of implemented
in a dumb way where we have this
conditional where we check to see if the
option is empty and if it's empty then
we return the default otherwise we
return we just do dot get and we grab
the value out of the option because
we're absolutely certain that it's there
and the incoherence is of course here
right we have these two expressions that
are dependent on each other right the is
empty it's its dependence on the get is
sort of harder harder to see than the
dependence of the get on the is empty
right because if yet if you call a gap
without checking that is empty then you
don't know whether or not it's going to
explode but if you call is empty without
calling yet or something else that
depends on that then it's sort of a
useless boolean that you just grabbed
for no reason other than I don't know -
or it was something so I think the so
the the incoherence of the dot get is
really easy to see right because we have
to make this argument that this is valid
there's another problem here which is
that we're working with a type which is
essentially entirely useless and that
type is boolean but it's difficult to
see in this partially because we're
using an if-else right so through long
long ages of tradition up from COBOL and
Beyond through C and Java and it's a
Scala
we've been trained to look through
if-else statements we don't even see
them anymore we're just like oh okay
there's a predicate and this predicate
means out okay now this is safe we're
inside of here block we just we just zip
right through it but if we build our own
hierarchy such that this such that we're
not actually using your files I think
this problem becomes a little bit more
obvious so let's write a bool algebra
okay
bulla has two cases true and false very
very obvious and it has a full function
on it that takes a true case and takes a
false case and will invoke them
depending on which case that we're in
very very very straightforward stuff
this fold function is literally what if
else does write it has a predicate which
is the boolean on which we are invoking
this function and it has a true in a
false branch one of which will be
invoked depending on where we are very
very very easy and we can rewrite our
function we can rewrite our function is
empty to return this boolean and then we
write our function down here to use this
and now I think it's a little bit more
obvious where the problem is
right the problem is that we have to go
through this whole rigmarole of boolean
to get at what we actually want which is
to say the dot get function the contents
of the option the contents of the option
are the point to this whole function but
we had to go through a completely
meaningless type to get there and I
would argue that this is really a
problem this is a problem that is
extremely prolific in most programming
because you know why not all sorts of
functions are written with this sort of
indirection it's data indirection
its indirection at the data
representation level and it's
essentially wasting our cognitive
resources to try to understand what's
going on in these cases because we
effectively have the we write functions
that do this sort of thing where we're
like okay we're going to get this piece
of data over here that we're going to
ascribe some meaning to and if this
meaning is satisfied okay we're going to
go back over here and do something else
like that's I don't know that's that's
really absurd and it leads to these
situations where we have expressions
that are intrinsically related but not
actually syntactically related in the
structure of the code that we wrote so
the dot gap function is intrinsically
related to the is empty function in that
it doesn't make any sense at all in fact
will explode if is empty is
satisfied but it's not syntactically
related in how we wrote the code so this
shows up in the case of preconditions
right if your option is not empty yet
explodes it also shows up in other areas
like side effects right side effects are
sort of like the ultimate uber
precondition through the external
universe right I'm I hope that this file
exists because I created it over here
and I'm just going to pretend that this
rounds after that thing like these are
these are things that are these are
preconditions and these are coherencies
between expressions that are not
expressed in the way that we
traditionally write code or they may not
be expressed in the way that we
structure our expressions and that's
really bad it leads to reasoning solely
by control flow so at the beginning of
this section I had a flow chart up there
which I would venture to guess none of
us have ever actually written outside of
the classroom but you know that's that's
actually how we have to think about code
a lot of the time right we have to look
at a function even a function written in
a functional non imperative style and we
have to reason about ok control flow
enters the function here and then we
make these checks and okay this guard
checks over here and this branch goes
over here and then we're in this branch
okay well how did we get in this branch
like we have to make those sorts of
reasonings
that's dumb that makes code really
really hard to talk about it makes bugs
really really easy to lose because you
have to kind of reverse this tree of
decisions that led you to this
particular point in order to understand
how you got into a buggy case it's much
much better if you can reason instead in
terms of data flow right so I have data
that goes in and in order for to in
order to access that data in order to be
in this case at all that data has to be
valid right it's much much better to
structure code in that way so I said
side-effects right well what is what
does that actually look like well it's
it's kind of like this so here's a
here's an obviously imperative function
right where we write to a file that may
be created I don't know how the right to
file function works we'll just pretend
read that data back out as a string
concatenated and returning very
straightforward stuff of course the the
tangling of concerns here
as between the read and write function
right we're making this assumption in
the read function in the way that we've
invoked it that the write function has
in fact been run that this file exists
that was created in some sort of
external universe world thing that we
call the file system and it has some
contents that week insanely decode as a
string and return as a result this is a
dependency between these two expressions
and it's a dependency that no static
checker in the world is going to be able
to help us with at the end of the day
right maybe in this trivial example but
I can make this more and more and more
and more and more complicated until
every static analyzer anywhere we just
fall on its face it's much much better
if we can use a tool to combine these
expressions together in such a way that
they cannot possibly be wrong but they
cannot possibly run out of order this is
where the IO monad comes into place so
most of the time when you're you're
looking at the IO monad from The
Skeptical outside view of imperative
programming the IO monad just seems like
something that you slap onto a function
that has side effects and it labels it
as evil that that is sort of true right
and anything that anything that returns
inside the IO monad should be treated
with some suspicion but the real real
value of it outside of simple labeling a
simple dogmatic labeling is that we can
use it to merge together functions to
merge together expressions and represent
their dependencies in terms of the
dataflow and it looks like this right
of course the for comprehension syntax
was chosen specifically to make
functions look very imperative so this
is sort of defeating the purpose so
rather than rather than looking at this
maybe we should de sugar it into the
actual flat maps and you'll see
structurally here what we've done is
we've taken the operations the writing
and the reading and we've related them
together in such a way that it is
brutally explicitly clear where the
dependencies are it is impossible to get
to the read from file expression without
having gone through the right to file
expression so we've taken our dependent
see our side affecting dependency and
we've put it together in such a way that
it's represented in the structure of our
program this is very powerful this
avoids bugs and this is what monads do
so monads in general take take they take
code flow right
they take control flow and they turn it
into data flow where you which is
something that you can reason about
right data flow is something that we can
reason about because we know that you
and you can't get this piece of data
except from here right and if you can
only get this piece of data from here
then just make sure that all of your
prerequisite operations are up here and
they spit out the data at the end of the
world and they spit out the data and
then everything is linked together
rather than just having this sort of
hand wavy assumption that oh well this
happened and then this happened and this
happened because that's hard to reason
about and it is hard to type check so we
always want to reason by structure and
within that structure we always want a
reason wet but with data flow because
data flow is typable data flow is
something that our type checkers
understand now I think that may be
something of a historical accident
because I you know I don't really know
why data flow is so much easier to
type-check than control flow because
they really are kind of the same thing
right code is data data is code you can
always make the transformation why is it
the type checkers have such an easier
time with one case than another I don't
know but that's just the way it is we're
working in Scala we have to work within
the bounds of what the type checker can
give us and if we want to exploit the
type checker we have to structure things
much more in terms of data but in terms
of control dataflow is great because it
explodes very very quickly if you get it
wrong now I'm not even talking about
just static typing here right so sure
it's great if your static type checker
can look at your data flow and make sure
that everything is actually lining up
correctly right and most of the time
Scala will do that but this holds true
even in dynamically typed languages so
if you're working in closure for example
and you're composing together some sort
of complicated data flow pattern if you
get it wrong chances are it will simply
explode the first time you try to run it
it doesn't matter what data you're
feeding through it it doesn't matter
what case of the branch is you
and two if you compose your data
structures incorrectly chances are
you're just going to get an exception
regardless of what case you land in and
that's really really powerful because if
you can't get type errors you may as
well just get runtime errors right away
in every case right
catch your bugs as early as possible
dataflow allows you to do that control
flow is much harder because if you don't
happen to hit that magic nested case
inside 27 if-else statements well good
luck to you because you know you're not
going to realize that bug until it hits
production somebody types in the wrong
value as I said code is data you can
always always always take your control
flow and turn it into data flow monads
are the easiest and most obvious way to
do this most of the time but there's a
lot of other ways too and learning how
to do this I think is a really really
important skill that all programmers
should develop tie your data to your
branching so this is what I was
referencing earlier and this is kind of
a general pattern for one way that you
can turn things more into data flow is
you shouldn't be able to access data
unless it is valid to do so and the dual
of that is that if it is valid to access
data you should already have it there
should be no distinction between the
check for validity and the actual gating
of data and in Scala this generally
shows up as pattern matching right this
is really the most natural way to do it
well I just completely fork the
recording if you know if you're if you
are a certain persuasion of mind well
let's say I don't judge you could you
might be you would write this as a fold
instead but they're the same thing right
in either case you are performing the
test to see which case that you're in
which branch that you're in and
simultaneously extracting the data that
will probably be useful to you precisely
because you are in this case right this
is why pattern matching you know avoids
bugs anecdotally because you land in
this case and you can't possibly get it
wrong this is this is very very powerful
and this pattern I think extends beyond
even simple pattern matching and
deconstructing composing of algebra
right you always want to contrive your
data structures such that the only
possible case you could be in is the
correct one and we'll get into how you
can do that more in a little bit the
first sequences so one very obvious
thing that you could do with a sequence
one very common thing to do with the
sequence is get its length right this is
a common property to be common thing to
be asking for especially if you're
coming from a Java world where you know
the standard way of actually getting out
of sequence get its length and just sort
of walk over it I am going to make the
argument that the length function and
the value that it gives us is in fact
useless there is no point to performing
this operation absolutely none why well
let's think about what length does what
is length give us well length gives us
an integer what can we do with integers
well we can add I think we can subtract
we can multiply and if we squint we can
pretend to divide what does that have to
do with the list answer nothing there
there's no reason to be doing this like
absolutely no reason whatsoever the the
information about the length of the list
is already encoded in its structure
right and if we want to do anything
useful with the list we have to do
something with that structure that
presumably respects the length why do we
need to get the length as this separate
integer thing that isn't related to
anything whatsoever it is sort of
hanging out causing bugs answer we don't
getting the length is going in the wrong
direction right it is good when we can
take two pieces of data and collapse
them into one piece of data that we can
feed through our code we saw an example
of this in the very first slide that was
useful right where we had a function
that took two lists and there was a bug
in that function implementation that
stemmed from either my naivety or the
fact that we were taking two lists
rather than one right so it's good when
we can take two things and collapse them
into one early as early as possible
representing our assumptions and
preconditions
therefore it is bad when we go the other
way
think about length what is it doing it's
taking one piece of data a list right
and it's exploding it into two pieces of
data a list and an integer and now we
have both and we have to deal with them
to do anything useful it's also focusing
on the wrong thing right who cares how
long your list is I don't what I care
about is the contents of the list I care
about what's inside that list and that's
what I want to perform computations are
we do not care about the length unless
you have some sort of algorithm yes aha
so that was my very next sentence if you
have I I'll actually get there's a
caveat to that as well specifically with
merge sort but if you have an algorithm
which is fundamentally algorithmically
dependent on the length of your sequence
then it is valid to get the length the
number of algorithms which are
fundamentally algorithmically dependent
on the length of the sequence can
practically be enumerated on a
blackboard like at least classic
algorithms there really are not that
many merge sort is not one of them merge
sort does not depend on the length what
you just have to do is be a little bit
clever with how you split things up you
don't even need the length for quicksort
either it's just a little bit faster
stochastically if you have it so like
most of the time when people are writing
code that depends on length they're
actually writing code that depends on
very very different things and they're
just using length as a very inconvenient
approximation so it's a good point
though I think there's probably a lot of
stuff with matrix manipulation and stuff
like that that also is length dependent
legitimately length dependent but yeah
how many of us actually do that on a day
to day basis yes Eric
yes yeah okay so I don't care about the
length Eric does I care about the
contents and we can go from there
yeah Eric Eric didn't get to talk so he
has to ruin mine anyway so most of the
time what people are doing with the
length is something like this
monstrosity where where you get the
length and you sort of iterate over it
this unfortunately is another case of
since the early days of what we were
doing whenever we were in the early days
of programming we have been trained to
look through patterns like this and just
sort of x-ray down - OH
while we're printing out the contents of
the list it's it's a lot clearer that
this is terrible if you do sugar it
right just like with the if expression
and you know it's really obvious with
this this construction why this is
absurd right
so we get the length of the list and we
put it together with another completely
arbitrary integer and we construct a
range what does a range has to do with a
list well we're working on that we take
the range and we iterate over that range
and then we use the elements of the
range to get the contents of the list
out this doesn't make any sense at all
it's really really really obvious that
what we care about are actually the
contents of this list not the contents
of the range the range is completely
incidental complexity and this is why
things like for each directly on the
collection tend to make a lot more sense
when you're introducing functional
concepts to newcomers is that holy cow
we can actually get at the content we
can get at the contents without going
through this integer thing that's
completely unrelated to anything and
yeah yes so I think that's an example of
where you have domain logic that's
predicated on the number of things you
have right and they're counting the
sequence might actually make some sense
I think another more broaden example
more broad an example of that is when
you have some sort of statistical
process
where you want to determine some sort of
summary of your data
counting the data is really important
for determining about summary and
usually you do those counts while doing
other things but you know counting
really really fundamental there but I
think that gets into the realm of like
business logic and stuff like that that
I don't know I don't care about picking
a random element there are there are
algorithms work so that the correction
to that is you do need the length if you
want to pick it in constant time yeah
there are there are algorithms which
don't require the what what no you're
we're using Scala we don't care about
constant time yes so they can sometimes
be an optimization if you have so if you
happen to have a sequence representation
that uses you arranges itself in memory
such that you can get random access
constant time jobs then right because
then indexing into it is an interesting
operation indexing a list is not
constant indexing a vector is constant
so you better see let's not start that
again
indexing an array is constant right
Elmen you all real men use arrays I
don't remember where we were going
representation is my next point so
thinking about the representation of
data is really important and it's I
think when I when I think about a new
problem right and I'm trying to write
some sort of algorithm or system or
something the very first thing that I
spend time thinking about and usually
the thing that I spend the most time
thinking about is how am I going to
represent the data structures involved
what kind of data what kind of form is
this data going to take because the form
that your data takes guides the entire
rest of your implementation so an
example of this that I think is really
instructive is looking at sequence
representations so
observation sometimes we don't care
about the sequence at all like I've
already told you that we don't care
about the length and then a number of
people were contradicting me sometimes
we don't care about the sequence right
sometimes we don't actually have to have
the sequence at all as a thing sometimes
the only thing we care about is
iterating over that sequence so it's
like if you didn't care that a list was
comprised of like some sort of head tail
thing that you could deconstruct or you
know split into two or whatever if all
you cared about was fold and map right
well that's that's kind of cool and you
could write a lot of stuff with that and
sometimes that is all you care about and
sometimes with some data domains it's
actually a lot more convenient to think
in those terms because it's hard to
represent the sequence but it's easy to
represent iteration for some domains so
then the question becomes well how do we
represent iteration what's the minimal
representation for iteration and I think
the very first step along this highway
is something that looks like this so we
have an inter trait that's parameterised
in type a and it just takes a value and
returns a new inner right this makes
sense
we take each element of a sequence in
turn and then we return the you know a
new it earth at maybe has some new
internal state maybe we're summing stuff
up or something like that
right we just we just build it along and
we build this chain of things and we
could we could use this very easily
right we we call our it ER with one and
then with two and then with three and
with four and with five and we start to
see a problem because this itter is only
useful on infinite sequences because
there's absolutely no way to get
anything other than an inner out of our
inner so we can keep applying it to
stuff and we can keep feeding it more
data but that's all we can do so we've
sort of accomplished half of our goal
here which is to say we've got iteration
and you know with there's a way of
giving it some sort of sequential like
thing but we don't really have a way of
making use of that in some sort of
finite process so this is not quite
right
well we actually have to do is enrich
our algebra just a little bit and go
beyond that so now we have an inter that
has two type parameters has an input and
an output because now we can actually
get output out the other end and it has
two states it has
the continued state which is a function
that takes an element of our sequence
the next element of the sequence and
returns us a new iterator right so a new
itter
that has maybe some new state maybe an
increased count increase some something
like that and we have a second state
which is we're done okay and this is
just common sense right we have to get a
value out of our inner how do we get our
value out of our inner we just represent
it directly in the inner so our result
is a type B we have a little bit of
variance annotations just to make things
fun because who doesn't like subtyping
and I wasn't a call for hands we can use
this iteration just like we did before
except now we can actually have some
bounds to it and this is maybe the
ugliest code in history because in order
to actually run this iterator this inner
thing we have to have this weird little
dance of like map and get or else and
this this weird comander and this
utility function that's sort of hanging
out here I don't know let's do super
ugly but like I said we don't care about
it because this is the sequence right if
you squint really hard you can see the
sequence inside of this code the
sequence is 0 1 2 and that's it then the
sequence is done so it's encoded in here
somewhere that's the only thing that
matters to us because what we care about
is representing the iteration in a
reasonable way not the sequence we don't
care about the sequence and so this
actually implies something really
interesting sequences are nothing more
in this representation sequences are
nothing more than functions from it ER
to it err that's pretty cool and this is
in fact forced so if you think about
what this function from it ER to it er
would do right what could it possibly do
with a knitter well there's there's two
things that you can do with a knitter
right
you can depending on which state you're
in you can either run the inner 1 step
right if you're in the continued state
or if it's done you can return it so a
function from inner to inner could
return the inner that it's been given or
if it's done it could return it right
or it could run it may be one step maybe
two steps maybe three steps however many
steps it wants to run it but that's all
it could possibly do so functions like
this very very directly represent
sequences they represent nothing but
sequences because the sequence we have
said in our representation is simply the
iteration of our inner running it an
additional step
so sequences are functions on it or you
can't do anything but how you can't do
anything but have a sequence you can't
do anything I have no idea what I was
saying with that you can't you can't do
anything else with the sequence but
iterate it which is kind of cool right
the sequence is just sort of this opaque
function right and the only way we can
interrogate it is by feeding an inner in
one end and reading the inner out the
other end that's the only thing we can
do what's beautiful about this is not
only is that the only thing we can do
with sequences it's the only thing we
can do with ITER's what can you do with
an inner other than run it in a sequence
answer nothing you can read what state
that inner is in but that doesn't really
do you much good so you can read out the
function that's in the inner end you can
apply it to some element and get the
next inner but that's the same as
iteration right there's no difference so
we have built a representation by
starting from these really minimal
building blocks where iteration and
sequences are both constrained to be
exactly and only the use to which we
wanted to apply them exactly and only
the correct usage and what's beautiful
about that is that our type system comes
into play right our type system is able
to help us and constrain things and give
us guarantees about stuff if you try to
do things wrong it simply will not work
and I'll explain in the next section
about how that is exactly but first a
tiny little bit of historic note just
for the record in our terminology what
we've been calling a sequence is
conventionally called an enumerator what
we've been calling an inner is
conventionally called an either a T so
if you've ever looked at like Scala
Zed's it or a T implementation or
something like that and been really
confused well it's it's actually very
simple and it's it's not that difficult
to explain and yeah there are there are
implementations out there as well so
anyway I think it Ortiz make a really
interesting case study in this in this
process right because it's basically
going back to really really really
simple fundamentals of what do we need
out of a representation what is the
simplest most basic thing that we needed
of a representation okay start there
work your way up if all data structures
in the world were built along this
pattern then we would work in a much
more bug free environment because you
wouldn't be able to do anything but what
the what the data was designed to be
used as and that's very powerful it's
powerful because of something called
parametric City so what is parametric
City and why do we care about it well
let's think about this type okay this
type says for all a a function from a to
a how many different implementations are
there of this type anyone have an idea I
were saying one anybody else have any
ideas you guys have been reading the
homework okay so I can actually think of
four implementations of this function
alright we have the obvious one we have
the insane one we have the dumb one and
we have the landmine thank you scallop
for the purposes for the purposes of our
own sanity though we I think we can all
agree that the lower ones are wrong
right the lower ones are just bad right
so if you have a function that loops
infinitely the fact that it claims to
give you a certain result is not
actually useful if you have a function
that throws an exception that's that's
kind of terrifying so we're just going
to pretend that these other three don't
exist and we're just going to work
within the realm of the one
implementation which everybody was
basically referencing right away and
pre-empting me to my point so okay
parameter s'ti why is parameters to be
useful in the concept in the context of
data coherence well it's useful because
it allows us to take multiple data and
put the
together safely so we saw at the
beginning where we had two lists and
there were some implicit assumptions in
our function about how those lists were
relative to each other and what we could
do with those lists and what structure
they had parama tricity allows us to be
really really constrained and really
really explicit about the sorts of data
we accept and what relations between
those data we have so you usually set
yourself up in a situation where you
have two pieces of data one and two and
data one can only be used with data two
and you cannot do anything else with it
it's impossible to do anything else with
it but link it to data to add data to
defines how data 1 can be used that's
really really powerful most of the time
you find yourselves making arguments of
the sort well where else would you get
that sort of value right you could only
get it from data one and you can only
feed it to data too this is like the
argument that we made with it or at ease
and with enumerators right the only
thing you can do with an enumerator is
iterate over it right this is a it's a
very very common argument to be making
in these sorts of really constrained
functional designs and it's it's very
very very powerful this is where static
typing really starts to shine at least
static typing in the language that we're
working with which is Scala if you can
say to your type system hey this is what
my data looks like it only looks like
this this is how my data relates to this
other piece of data you're only allowed
to put them together in this sort of way
then the type system could slap you on
the wrist when you do it wrong and it
can slap you on the wrist really really
early very very very powerful concept so
here's another really trivial example of
this this function also only has one
implementation because we're saying if
you think about this backwards right so
we say we have a function that returns a
seat well where could we possibly get a
seat the only place we could get it from
is function G right but function G needs
a B where could we get a B only from
function f well function f needs an A we
can only get an A from the first
parameter which means that the only
possible implementation of this is the
following right G composed with F
applied to a less trivial example
right fold left function on list this is
a function that takes not just one not
two but three parameters since that one
of them is hidden because we're
object-oriented so it takes a list a
list of a it takes a B and it takes a
function from B and A to B right three
parameters that's more than triple the
number of bugs I am going to claim but
because this function is polymorphic
because this function is defined for all
a and for all B we can bring arguments
with parametric city into play right we
can argue that there are only a few
number of implementations a few number
of ways that we can do this function and
all of them end up leading us into
essentially cases that are
definitionally correct so the most
obvious way that we can implement this
function is to just return the value
that we're given right so we have to
return a B we have to get that be from
somewhere we can get that B from two
places right we can get it from the
value that we're given and we can get it
from the return result of the function
so we just ignore the function return
the value right very very
straightforward but um this represents
this correctly represents in fact the
empty sequence the empty list if you
implement all of the functions in list
on top of fold left which in fact you
can then if your fold left is
implemented in this way all of your
lists are empty all the time regardless
of what data you put into them that
seems useful so maybe maybe we don't
want to have the empty sequence right
maybe we want to do something more than
that well where else could we get a B
from well we could get it from the
function right but the function takes a
B which in turn we have to get from
somewhere and some other element a which
I mean we have to get that from
somewhere too all right so we you know
we have to we have to get an A from
somewhere and the only way we can get an
A is get it out of the list the only
place we can get an A is to get it out
of list because our list is a list of a
and we have no other sources of a's this
is the sort of constraining argument the
parametric city thrives on right
whenever you find yourself in the say
situation where you're like hey I need
of this I can only get it from here
parametric City is going to be a really
powerful tool so we need to get it out
of the list we'll a list is one of two
cases right it's either a con cell which
has this a unit that we need so much or
it's a nil which doesn't have an A in it
at all
so what could the only possible
implementation in the nil case be well
return the B that's the only possible
thing we could do there in the not milk
case we could you know apply our
function and in fact we do here and then
just return this represents a sequence
of length one so as soon as you start
applying this argument inductively you
see how fold left is really really
constrained in what it can do right it
can basically permute any of the
elements that are inside of the list
right because that's where it's getting
a is from and we don't distinguish
between the elements so it can take the
first element and repeat it like as many
times as it wants or it can shuffle
around the elements like it doesn't have
to fold left's type signature says
nothing about the order that it does
things in but it does say where you can
get data which is a heck of a lot more
constraining than if we just have some
random function hanging out there that
claims to give us a value of some type
that we don't understand um once you
start seeing things in terms of
parameter st you start seeing these
arguments jumping out pretty much
everywhere right look at the map
function map takes a list of a and a
function from A to B and returns a list
of B well how the heck are we going to
get a list of B except by applying the
function from A to B right
what lists out empty yes so you could
return nil that's that's a good point I
should have used non empty list because
that would have made a more compelling
argument well you have to get your first
B somewhere yeah yeah so clearly this
type signature parametrically tells us
nothing about length tells us nothing
about permutation you know it doesn't
give us that information but it does
give us some really really strong
guarantees about where data can come
from if you have data at all partition
is the same way right so now we have a
function from a to boolean Loulou
artificial algebra ok but you know in
this case we kind of have an artificial
algebra right are we on the left hand
side or the right hand
of a pair kind of makes sense there's
very few ways that you can write this
because there's only like you can get a
from where you can get it from yourself
and nowhere else
zip is the same way length is not like
this length returns an int how many
different ins could it return four and a
half some odd billion that's okay there
is nothing that constrains this length
function in any way it can return math
dot random we don't know so this is this
is an example of kind of the limits of
parameter s'ti and why it is that
polymorphic functions are so great
because not only can you apply them to
any data right because it's for all but
they also give you really really strong
guarantees so with parametric city it's
okay to write higher order and higher
arity functions right functions that
take multiple data because we can
constrain how they are related together
we can control what the meaning and the
relationships between your types are but
you can only do this if your functions
are polymorphic length didn't work right
we couldn't make these arguments about
length the big concept the notion that a
lot of this is predicated on is that
data can really only come from one place
if you're saying that this works over
for all a then you can't just make up an
arbitrary a that came from the ether
over here with parama tricity we
basically learned that if you can't
constrain your data if you can't confine
it to be a certain thing
well constrain where it comes from and
constrain where it's going right build
your constraints and encode them in such
a way that the type system can help you
and be very very very suspicious of
concrete types anything that's an int or
a string or something like that that's
not generic is very very very worrisome
and you should suspect bugs whenever you
see that so data flow not control flow
transform your control flow into data
flow if you have to using monads or by
some other means because it will be much
much more helpful don't go through day
in direction right don't get the length
of the list when really what you want
are the contents don't encode things as
a string and then decode them later
because read compose show is so great
constrain your representations only
allow people to do what you want what
you specifically want your data to be
used as very very very important
choose your representations very
carefully and you will limit the space
in which bugs can occur and finally be
as generic as you possibly can
specific types are bad specific types
cause bugs specific types cause people
to make assumptions that they shouldn't
make don't be specific be generic don't
let people know what your types are be
very very very generic and it will pay
off in the end because you won't have as
many bugs we are essentially out of time
I don't think very quickly what would be
the four I was going to talk about
resources and linear typing so that was
going to be really fun but it didn't
happen all right thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>