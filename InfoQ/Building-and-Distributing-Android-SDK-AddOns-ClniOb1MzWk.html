<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building and Distributing Android SDK Add-Ons | Coder Coacher - Coaching Coders</title><meta content="Building and Distributing Android SDK Add-Ons - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building and Distributing Android SDK Add-Ons</b></h2><h5 class="post__date">2015-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ClniOb1MzWk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning everybody
oh come on it's not good morning
everybody oh so much better thank you
everyone for coming and spending your
morning here with me my name is Dave
Smith I am the Android lead at new
circle training and I am here today to
talk to you about building and
distributing SDK add-ons Google's way of
distributing your Android code to
developers again I mentioned my name is
Dave Smith I am dev on wired on pretty
much all of the social things if you
want to follow me or connect with me
after the fact the only exception to
that is Google+ because I decided to get
clever and tried to use my real name so
if you want to follow me on Google+ I am
at Dave Smith dev instead ok question
for everyone in the audience how many of
you sitting out there either have worked
or are currently working on building an
Android based device or customizing
Android for a device ok good that's what
I would expect now of those how many of
you have built cool new features into
that device that you would like
third-party app developers to be able to
access ok good I was hoping to see most
of the same hands that's good so what
we're gonna talk about today is we're
going to discuss what are some what are
some potential solutions to that problem
you know how do we distribute our code
to developers so all of us here are most
of us are likely engineers we've
probably worked on a Android project and
we've spent painstaking amounts of hours
putting awesome new hardware features or
extending the Android platform to add
all maybe some new sensors maybe you put
15 cameras on your device you know who
knows what the exact piece might be but
then one day your boss comes to you and
he says how can we basically take all
this stuff that you just put into this
device and how can we integrate it so
that other developers can take advantage
of it
you know we'd like to get this out into
the ecosystem so that's really the
question that we'd like to solve here
today now there's a couple ways that we
could do
you know there's you know basically what
we've decided is well if we're going to
distribute this functionality to
developers we need some kind of SDK but
we could do that in a number of ways
right you know an SDK a good SDK is more
than just the library code you know we
could start by building all the code
that we need into a library package that
up as a jar file or whatever we need and
the simplest case is we just throw it up
on our website let developers download
it give them some information on how
they would integrate it into their
project and they could move on and move
forward from there but there are some
other problems that we really need to
solve associated with an SDK such as how
do we distribute it well how do we
version it what if we want to ship a new
version to our developers and we want to
let them know that that has happened do
we want to be able to document it
probably I'm sure we've all worked on
projects Android included that is not
very well documented and so we want to
be able to provide as much documentation
as we can to the other developers and
potential validation you know how can
they test the code that we're giving
them to make sure that it works as
they're moving through this and very
quickly the basic idea of just throwing
a jar file up on a website starts to
fall apart right it gives them the code
but it doesn't really give us any other
functionality around that to be able to
better fit that need okay you know but
there are other options you know with
the recent advent of Gradle as the
common build system for Android
applications developers are becoming
more savvy to common dependency
management functionality like maven and
ivy and so dependency management might
be a good system for this we could
bundle up our library code with its
documentation into say a maven artifact
and we could host that up on maven
central and we could then take that
information and tell the other
developers simply what is the artifact
ad that they need to use and this
presents some new functionality to us
now we can deploy it to a central server
so if we want to deploy an update we
just push the update back to the same
server artifact IDs are inherently
version
so if we want to tell developers that a
new version is existed then they can
simply modify their artifact to update
to the new version it will download into
the system so a lot of these problems
are taken care of when we start using
dependency management but one big piece
from a custom Android device standpoint
is still missing and that's the
validation piece you know without us
giving them some kind of physical piece
of hardware that is you know is our
custom device target whether that's the
device itself or some sort of an
evaluation board that's based off the
same platform how do they run the code
test it and make sure that it actually
works to some degree of accuracy anyway
okay
Google's solution to this problem is the
SDK add-on okay so this is a it's an SDK
component that has been around in the
Android build system you know for as
long as Android has been part of AOSP
Google uses this internally for their
Google API s targets so anyone in here
who's done application development has
worked with the SDK manager and you've
seen the not just the Android platform
targets but the Android with Google API
is targets those targets are built as
SDK add-ons so they use the same
functionality internally and we're going
to show you today how you can use it
inside of your own device builds as well
so this an SDK add-on basically starts
as two primary components now it used to
be one but in lollipop they've split
this out into two there is what I'll be
calling the library package and that is
these are basically two zip files this
is a zipped up contents of the actual
library code that you need to distribute
to a developer as well as the
documentation associated with that and
we'll talk about how that gets built and
then just some metadata associated with
what's in that package okay so this is
all built as what we would call the
library this is what a developer would
need to target to link against in their
applications so that their code compiles
with your new functionality the
secondary package which again used to be
bundled in with the first but now
they've split them out is a system image
and this is where it really starts to
shine beyond any of the
traditional methods when we're talking
about a custom Android device this SDK
target lives right alongside the
existing device target that you have and
it allows you from the same Android
build system to generate a the library
package and be a package with a working
system image that they can take and
developers can download and spin up an
emulator instance that runs with your
custom system image so this is a full
package it has the system data
partitions the RAM disk you know all the
pieces the custom kernel image if you
need it all the pieces that you need to
integrate this together and hand it off
to a developer so that not only can they
use your code but they can spin up an
Android virtual device that's running
your custom system image to actually be
able to test their code okay that's a
very unique component of this whole
system so we've got the validation piece
in there that we discussed earlier now
in addition to this the Android SDK
tools provide a specification for
something called an SDK repository and
the repository really ends up just being
a specialized XML definition that allows
you as the distributor or the builder of
this SDK to throw up somewhere on the
public web the archives that are
generated and this additional XML and
provide developers nothing more than a
URL what we're calling an update site
that they can add to their existing SDK
tools to pull down your code directly
into their environment okay we'll talk
more about how these are built and some
of the features associated with them in
just a little bit the SDK repositories
have additional features they're going
to be very helpful for us from a
distribution perspective one the URLs
that we can give the developers but also
the ability to version our SDKs add
licenses to our SDKs that the developers
have to agree to before they can
download it and we can also see here in
a little bit that we can split out
portions of the SDK by platform so if we
have separate archives we need to
provide to developers for Mac Windows
and Linux say we can generate those
archives compact them together in one
repository and the SDK tools will do the
job of installing the approach
on the appropriate platform when the
developers go to the site okay so this
as an entire package really provides all
the things we need to solve those four
problems that we just discussed done
who's buying beer all right if it were
really that simple I would just walk off
the stage now but let's talk a little
bit more about how we need to go through
this process what are the things that
you as system image developers need to
make sure you're doing in your system
image builds and then the additional
pieces you may need to add to take your
system image code and pop out this sdk
add-on okay now the first piece is you
got to make sure you have the right code
you know most of you have probably seen
this type of code before this is a
snippet from a repo manifest if you've
ever looked through the repo manifest
though you may have may not have noticed
that each project in there has a series
of groups associated with it
and if you do just a generic repo a net
repo sync you don't get all of them
there is a series of groups called not
default that is on predominantly the
tools packages but just with repo nat
repo sync those do not come down to your
machine because in most cases they're
not necessary the basic repo sync gives
you everything you need to build a
system image but nothing else if you
want to build a component like an sdk
add-on you need all of the additional
tools packages that are associated with
building the sdk and those again are
marked in this case with this not
default group now the way there's a
couple ways we could pull that down the
simplest is when you're running repo in
it you just want to throw that - G flag
on the end that defines which additional
groups or which specific groups you
should pull down as part of the next
sync in this case - G all tells us that
we get everything you could also do a -
G Tools if you only wanted the tools
packages but generally we're talking
about building the system image and the
SDK as part of the same system so we're
just gonna grab everything okay so
repoing it with the - G all and then a
repo sync will give you all the packages
you need to be able to do the additional
steps
question basically everything yes so the
question was are there packages in the
manifest required for SDK generation
that are that are set as not default
basically everything under the tools
subdirectory so the there are there
sections under tools that are specific
to generating the IDE plugins as well as
just building the core SDK and the
basically anything that's under tools
slash in that project list is required
to do a make SDK which is effectively
what we need to do a little bit later on
good question okay so from a system
image perspective what do you have to
change on your device assuming you're
not already doing this to sort of
facilitate this process SDK add-ons run
along with a functionality inside of
Android that is their shared library
support android supports shared
libraries in a very narrow specific way
which is they allow system image
developers to expose Java libraries
inside of their system partition to
application developers the advantage of
this is you can develop the code that
you need to share with developers into a
expose or an extracted Java library and
rather than distributing the code to
each of them you can simply put it on
the system image as a shared library and
then the developers can reference that
library by name so that when they're
running their code on your device it can
be properly added to their class path so
this allows us to distribute the library
with the device or the functionality of
that library and allows the developers
to link to it without having to copy jar
files or other things into their own
package into their own project so you
don't end up with multiple copies of the
same thing strewn across the device okay
they're all referencing the same
instance that's on your system image so
what we need to do effectively is we
need to build that library code into a
shared library if it's not already by
wrapping that up into a individual
module inside of our system image build
there's basically three targets that
we're going to look at that will do this
the first piece that's necessary to make
this work is this shared library
definition file that I have listed at
the bottom of the slides there it's a
very simple file there are several of
these on any given Android device in the
system Etsy permissions directory this
is where all the shared libraries as
well as all additional optional hardware
features are declared on any Android
device
so you'll see files in here for devices
that support NFC or certain types of
Wi-Fi there will be a file in here for
each one of those features a shared
library is considered one of those
features so this is just a simple XML
file that Maps two things together
it Maps a library's name to the actual
file that has the the library code
inside of it that library code is
typically found in system framework
although if you're massaging the build
system a little bit more you could
pretty much put it anywhere on the
system partition as long as this file
maps to where that location is okay so
this XML file is a piece of boilerplate
that you just have to create it would go
in your device directory somewhere so
that it can be copied into the final
system image okay this file exposes that
library to other applications I jump
past that using the uses library
declaration on the client side so this
is something this is some syntax that
application developers are familiar with
they've done this before
especially if they were working with
some of the previous Google API s there
is an attribute that a client
application developer would use called
uses library that goes in their
application manifest and that definition
would declare that library used by name
and would tell the install process that
when this application is run it needs to
link in with the shared library on the
device it also has some additional
features that if that library doesn't
exist that application cannot be
installed on that device and some of the
more common distribution mechanisms like
Google Play will enforce that they will
determine whether or not an app can even
be shown to the user in the App Store by
whether or not it has the shared library
declarations that that particular device
is look application is looking for in
that device okay and that definition
comes from that XML file
now in addition to that you have to
actually build your code into a shared
library so if your if the code that is
associated with the functionality you
want to expose is already somehow baked
into say one of your core apps maybe you
added a custom system service and all
the functionality to work with that
service is inside that application the
best way to do this is to break out the
codes specifically for working with that
feature into a Java library so you're
going to take that code define it as a
module in your build system so it's
going to have its own Android m'kay and
it's going to have that familiar syntax
that you can see up there that we want
to define this as a Java library then
your system services application can
still use the code internally by
declaring that it uses this local shared
library in the build system so you can
do that all internally and still get
your code to work but by exposing this
code as a shared library module it makes
it easier for the build system to
exercise that for your SDK add-on later
okay so that top section there in the in
the build file is essentially what
points to that section and again the
syntax should be fairly familiar the
only thing you may not have seen before
is the build macro which is build Java
library that effectively just takes that
code and instead of turning it into say
an apk or something like that it's going
to turn it into a jar file and by
default it will drop it in system
framework on the system image okay then
in addition we have to add in a rule
that takes that XML file that I just
described and copies it in okay so that
second half of the make file there is it
uses a build pre-built macro which if
you've never seen it before is basically
just a glorified file copy that will
take that XML file from your device
directory or whatever your host sources
are and drop it into the appropriate
location on the system image which in
this case is system NC permissions okay
so those two pieces are sort of the core
bare minimum of what you would want to
do to modify your system image that you
have existing to make this code
accessible to the SDK system ok now
being good SDK developers we probably
would want to document our code because
we like it when other people document
their
so there is a build macro inside of the
Android build system called build droid
dock this is essentially just a scripted
wrapper around a Javadoc parser so if
you're familiar with Java dot comments
it is the same idea there where if you
as you're building your Java code inside
of your library if you comment that or
decorate your classes and methods with
Java Docs style comments the droid dock
macro will go through and scrape that
code and generate the HTML files
necessary to essentially be the same
thing you would get spit out from a Java
doc so droid doc is really nothing
special other than it's a way to hook
javadoc comment parsing into the Android
build system okay
so again another make file snippet for
that module which has the build droid
doc at the end most of these attributes
again should either be familiar or easy
enough to figure out the only one that I
think is a little awkward is the droid
doc Options attribute that one is
actually designed to point to the root
Java package that you want to generate
your comments from okay so if you don't
necessarily want to generate Java doc
for the entire module maybe it's just
for a specific subset of the Java
packages you can do that by defining the
root Java package Android doc we'll
start there and only drill down
recursively into the sub you know the
sub packages from there and it can leave
other things alone so you can use that
to narrow scope if you want to but in a
lot of cases and what we do in our
examples is we'll typically just set
this to whatever the root package would
be of the same code so that we get
everything okay all right that's pretty
much it for what you would need to put
into your system image definition now
maybe you've already doing those things
in which case you're way ahead of the
game but you're going to want to make
sure that you get that code separate it
out so that you don't have those
problems the next question is how do we
get this stuff to developers right we
discussed a couple options as far as you
know maven central or throwing it up on
a website the recommended way to do this
and what I would tell you is the best
way to do this is hook into this thing
this is the SDK manager if you've never
seen it before this is a tool that
developers understand they know how it
works they use it all the time if you
want your applicator or your additional
library code to be easily accessible to
them
use this tool okay and that's what the
whole point of the sdk add-on is to do
how do we add on some additional pieces
to our build so that we can generate
packages that this tool will recognize
immediately and will simply integrate in
alongside with the rest of the base
platform exactly what they need to work
with your code okay
so there's some additional pieces that
we add into our device directory that
are specific to the add-on the first one
is this manifest at ini file this is a
very simple metadata file it's just
designed to provide some basic
information to the SDK manager about
what your library code is so it's going
to have some information like what's the
name of the add-on who's the vendor that
this is providing this add-on what is
the base target API so you're gonna have
to tell the SDK add-on what version of
the Android platform is your add-on
based off of because the add-on is not
going to provide the entire SDK along
with it it's just going to decorate the
existing one on there so it needs to
know for instance that our add-on is
based off of an Android 5.0 base device
that's API level 21 and then it's going
to use that as the base target and
simply include our libraries on top of
that okay so that one's very important
and then additionally what are the
definitions of the shared libraries
we're providing so this is just a list
of library names and then each name is
referenced to the the file on the system
image that that library is associated
with and giving it some sort of a
display name so again just some
information that the SDK manager will
use to display your contents to the
developers inside of that tool okay and
we'll see that this this file actually
has a secondary usage a little bit later
on stubs probably one of my favorite
features of add-ons something that you
you could probably do yourself in
another way but I think it's cool that
this has really hooked in so the
question often would come up as we're
developing this SD
add on one of the problems with just
exposing these Java libraries even if
they're compiled to other developers is
that if we have to give them all of our
source code they could decompile it they
could look at what's in there and they
you know if there's some proprietary
information in there you know Java code
is not that hard to reverse engineer
right so is there a better way that we
could distribute this to developers and
there's a functionality inside of the
build system that's then used in the SDK
which is used to generate stub jars from
the code that's on your system image so
that means that the library code that is
actually put into the library package of
your add-on is not full working code it
is empty stubbed classes and methods
with nothing in them in fact if you D
compile the source you'll see a bunch of
empty methods that throw a runtime
exception saying stub so there's no
actual code that you give to the
developers you give them the bare
minimum necessary to link their
application code and have it compile and
then when it runs on the real device
it's going to run against the actual
system image where the real code is okay
so you don't have to worry about
distributing your code necessarily to
all third-party developers additionally
the SDK add-on has this functionality
that allows you to control what from
your system image goes into the SDK
package so let's say that you build a
Java library but inside that library
inside that jar file there are still
some internal classes versus maybe some
actually public facing classes that the
developer needs to see using a stub
definition file the SDK add-on allows
you to control what goes into the stub
before the stubs are generated okay so
it's just a very simple text file using
the syntax that I have up there where
you have this sort of plus/minus idea
that I want to add everything from this
package but not these pieces and you can
do this all the way down to the
individual class level ok so I can
remove unit test classes or other things
somehow in my code but I don't want to
ship those off to the developers even as
stubs I can remove those elements out by
putting into my stubs definition file
what should go in what should pull out
and then
it will take all the resulting
information and generate the stubs from
that okay all right one last piece of
information that is necessary for or I
should say boilerplate that is necessary
for our build for the system image
template so I mentioned that we had the
manifest at I and I as a file that's
necessary to let the SDK manager know
the the contents of our library package
there is a similar definition of
metadata for the system image package
the package that has your your binaries
in it that they can use to create an
emulator okay so that in this case it's
not called manifest ini it's called
source dot properties and the the build
system supports another extension called
source type prop template that allows
you to generate essentially the same
information but this time the build
system is going to use it to generate
the system image package instead of the
library package now one of the nice
things about the system image template
is that it is actually a template it
supports inlining certain at all but
certain build system variables like the
sdk version the target ABI like x86 or
arm that you might be supporting and
instead of hard-coding those into your
file you can put them in as templates
and the build system will inject the
right values before it generates the
resulting source top properties file ok
this is in a lot of cases may not be
super useful since most of us are
building to one version of Android on
one specific architecture if it's our
custom device but Google uses this
internally obviously because they build
google api s4 arm x86 x86 64 now and
they can use a single file and each time
they do the build the right file just
happens to be generated okay so if
you're if you're in that game at all
it's very helpful with that with all
these pieces in place we just have to
create another product definition so
again this should be very familiar to
most of us in the room it's going to
look just like a product definition make
file now some of the attribute names
have changed a little bit and that
allows them to be co-resident with the
actual system image in the same target
but it's the same basic information
right we're gonna give it a name we have
rules for copying files into that addon
which in this case is just that manaphy
file we generated a rule to copy modules
which is similar to a product packages
declaration which is going to take the
shared library jar files or whatever
those modules put out and copy them into
the resulting zip file that becomes the
archive you know the stubs definition
file needs to be added in here as well
as you know the definitions of any
documentation modules everything we've
generated up to this point that system
image sis prop I point out specifically
that that's new and lollipop because if
you're building any other version of
Android which I imagine some of you
still are that attribute doesn't exist
and is not necessary there because in in
previous build systems the system image
and the library are together in one
package so that is new so that the two
could be split out and distributed
separately okay all right then before we
walk through and build this we simply
need to append it to our device target
so common you know the common way of
doing this is that your system image
probably already has an Android products
file that is in directed to the make
file that looks similar to the one I
showed you before right the device make
file that defines all the product
definitions for the system image target
in that same line we can just modify
that file to append an additional make
file which is the SDK add-on file that I
just showed you before okay so we don't
have to create a separate directory for
all our add-on stuff with its own
Android product file its own vendor
setup file it can live in the same
directory and all those files can live
there we just have to define both
products at the head of the Android
products m'kay okay and they don't allow
us to build both now there is one slight
difference with an SDK add-on though and
that is that you cannot build an add-on
from a lunch target so there's no way
for us to run lunch see the add-on build
it that way that is only for system
image target builds okay there's some
specific make target definition
boilerplate that you would use to
generate this add-on directly and it
looks just like this so the the device
SDK add-on that section there is the
name of your add on what you defined in
the add-ons make file and then it's just
going to be bracketed by that
whether played information so you'll
always have product in the front and the
type of product you're building on the
tail which in this case is SDK add-on if
you get too deep into this you might see
some other things here like SDKs or SDK
extras but in this case that will always
be SDK add-on okay and you just run this
and this will generate the SDK add-on
now the nice thing is if you have
already built your system image this is
really just considered an incremental
build on top of that so it does take a
little while but it's not like building
from clean this is going to just build
the SDK components necessary on top of
the system image but reusing those
intermediates similarly if you haven't
built it before you can build the SDK
target and it will build just enough of
the system image to generate this so
they're common enough that you can build
one or the other you don't have to have
this order of operations necessarily
that go how to build this one first and
then I do this it doesn't matter
whatever works well for your workflow
the build will will appropriately do
what it needs to do okay so the last
step is how do we get developed or how
do we hook this back into the
distribution system for developers so
the SDK manager I mentioned before has
this concept of an add-on site and the
add-on site is a section in the SDK
manager where developers can simply get
a URL from you or any other manufacturer
to where your SDK repository is hosted
and all they have to do is throw that
URL in this list and the next time the
SDK manager refreshes it will search for
your packages along with all the other
Android packages at the same time okay
and you can add as many of these as
you'd like as a developer into this list
now the question is what gets added here
well there's a couple things you will
upload the archives that we've been
talking about those zip files which will
become the output of that make build
that will get uploaded to somewhere on
the public web and then these repository
XML files need to live right next to it
so you'll just have a little directory
somewhere out on a CDN or somewhere in
the public web where you want to provide
these things and it will simply have the
this XML file which is
a little bit small to read up there and
an individual archive now this
repository definition is going to have a
lot of the same information in it that
that manifest I and I or that source
that properties file does it's just a
bunch of metadata about the archive so
it's going to have information like the
name the vendor name the base SDK and
then it will have references to the
archives themselves so the the archive
block in this file defines the actual
name of the zip file associated with
this add-on or with this system image
and then for checking reasons it also
you have to provide a correct sha and a
correct file size that the SDK manager
will use to verify the download after
the fact okay so this this first SDK
here is for the system image template in
the example that we've been working
through and then I have another one next
to it on the slides for what you would
see for the actual library package okay
again similar data this one has those
library definitions on the bottom the
same things that were at the bottom of
that ion manifest on ini file but again
defines the same information now there
are some important values in here that
we're not in that file though the first
is revision okay you can version your
SDK components using this repository so
you know initially this would probably
be revision one but then if we decide
later on that we want to ship an update
to developers all we need to do is
upload the new zip file modify this XML
to say revision 2 and then the next time
the developers open their SDK manager
and it goes through and it checks all
the add-on sites they'll see that there
is an updated version of your SDK and
they can download it and install it
straight from the tool they already know
ok so it allows us to distribute
versions to them and update them but it
also has that notification mechanism
built in you know if you're hosting
these up on a dependency management
system there's really no good way for
the developers to go check and see if a
new version is available this allows
them to do that in a tool they're
probably in quite a bit anyway without
necessarily automatically downloading it
for them the option is there for them
pull it if they want to and you'll see
what that looks like here in just a
minute and of course I mentioned before
the other one the other big one for a
lot of SDK developers is licensing so
you can attach a license to your SDK and
that license will be shown to the
developer or the user before they're
allowed to download it so they'll see
the license text they're forced to agree
to it before the download begins so it's
just an additional feature that you
probably would have otherwise had to
write yourself just right in the system
for you okay okay just a couple
additional things here before I show you
a quick demo and that is there are a few
things that are part of AOSP that can
make this a little bit easier I
mentioned before that each one of those
archives in the repository XML you had
to define the SHA and the file size
inside of it these are these top two
elements are just a couple of snippets
that I figured I'd throw at you that you
can keep in your back pocket that are
easy ways for you to generate that sha
and that file size so that that sha cut
and that stat command will give you the
exact piece you need to drop right into
that XML okay now I didn't write those
myself I actually stole them and I'll
show you where in just a minute in
addition to that the AOSP comes with
some schema definition files for all of
those XML files that I just showed you
so the question might come up well how
do i generate one of those things great
you showed me an example but what can go
in them the XS D files for all the
schemas that Google supports and they've
revved this a few times so there's going
to be a couple versions of them for
instance the latest version of the
add-on schema is version 7 and they'll
probably Rev that again at some point
but the the XS D files it defines here's
everything that can go in what's
required what's optional all that
information is inside AOSP you'll find
it it pre-built dev tools repository and
they'll all be listed there ok so at a
minimum you can use these to validate
the XML you're generating whether you're
crafting it by hand or you've come up
with a script or some other tool to do
that you can use with something like XML
lint you can validate that against the
schema and ASP to make sure that it's
actually going to work with the SDK
manager
okay so that's a very helpful tool and
then the other piece that's in AOSP
which is kind of helpful is this make
XDK repo XML script this is a script
that is designed to take your archive
parse through it and generate the XML
that you need for your repository it
doesn't quite work that well it does
generate correct XML but it's incomplete
and part of that is because there is
additional information that I showed you
that goes in the repository that's not
in the archives like in the archives
manifest or its source top properties
things like the license distribution
URLs revisions those don't exist in
there so they don't get thrown into the
XML but that XML is required for it to
validate properly against the schema so
if you attempt to run this script and I
encourage you to play with it you'll see
that it generates an XML file but it
will always fail validation every single
time and it's at first you think it's
wrong but it's just because it's
incomplete the nice thing about this
script is it will do things like
generating the SHA and the file size and
that's where I stole those snippets from
so it can do some of that work for you
initially but you're gonna have to go
back in and sort of fill in the gaps if
you decide to use this script as part of
your workflow okay all right it's just a
little bit of time here so let me
quickly jump into a demo here okay
so what I'd like to show you here is the
example that we use in our internals
classes of a device target that lives
side by side with the SDK add-on so just
as I showed you before in the slides if
we take a look at the Android products
definition of this particular example
here we can see that I've added the SDK
add-on make file right on top of the
make file for the product definition so
I won't take too much time to look at
the product definition of the actual
system image but just to show you what
it is we have the system image here that
is defined by this product definition
that inherits from the emulator build
that has some additional
products and own packages added to it
and our SDK add-on is just living right
alongside that in the same directory we
don't have to create a new directory or
anything like that to separate this from
the individual target so we pull up the
SDK add-on here we can see some of those
pieces that I just described to you here
so the add-on has a name we define all
of the files that need to be copied into
our SDK add-on and this specifically the
one we discussed before was this
manifest at I and I if there's anything
specific to your add-on that may need to
get copied you can add that in here as
well
an interesting example is that the
kernel image that we're using in our
internals example for alpha is actually
a custom kernel and by default it
doesn't add the custom kernel to the
system image package that gets built so
we have to explicitly tell it to take
our kernel and copy it into the
resulting build by default it's going to
take the pre-built
image for the QEMU emulator that it has
along with the AOSP we've added the copy
modules declaration to include that
those two Java libraries that are
associated with our system image that we
want to expose to these individual
developers and we'll take a look here in
just a minute of what's actually in
those libraries only one of them really
is is of importance in this particular
case and then the stubs definition file
that I showed you has to get included in
here as well the required definition of
our source type prop template for the
system image and our documentation so
basically everything that I've just
walked you through as we were going
through the build up of our SDK add-on
you can see it's all lined out here in
this product definition for our SDK
add-on living right alongside our system
image here ok so just in the interest of
time I'll just briefly go through what's
going on in here so our system image has
a handful of apps inside of them and
sort of the high-level view of what's
going on here is we have a services
application that adds a new system
service to the device that in this case
is exposing some additional logging
functionality that isn't otherwise
exposed to applications and then we have
a demo
raishin of a client application that
accesses that functionality using this
public java library that's exposed for
other applications to use so as I
mentioned before the best way to do this
is to really extract your Java code from
any individual app that you want to
expose to a developer into its own Java
library in this case we have included
that code so we have of generating a
system service similar to the other
managers that developers would find in
the framework but the point here is that
this log manager is a class that client
application should be able to access but
it's not part of the core framework so
if a developer simply starts developing
an application in Android studio or an
eclipse and they try to declare this in
their code by default that isn't going
to compile they're not going to be able
to build it and that's the whole point
of the SDK add-on in general so what
we're going to show you in this
demonstration is how including this
add-on gives the developer in their own
environment access to a class like log
manager ok so log manager this entire
build here is wrapped up using that
Android m'kay that I showed you earlier
with the three primary modules in it so
the module to build this is a Java
library the module to include that XML
definition as a pre built into NC
permissions and then the Droid duck
module to generate the HTML
documentation to go along with the Java
library that we're building here so all
that code for the log manager log
listener and services are going to get
built into a jar file and in our system
image build the
we'll be dropped into system framework
where we can access them from other
applications so as an Android developer
if I were inside of my favorite IDE and
for the moment I will choose Android
studio if I were to want to build an
application using this fancy new library
there's a couple things that I would
want to do the first is as I mentioned
in the slides you would want to include
the users library declaration using the
name that is exposed for that library
inside of that XML definition so just to
jump back here for a minute this XML
file defines the name of the Lib and
that same name is what a developer would
use inside of their Android manifest
declaring that this application wants to
use this shared library so first of all
that shared library has to exist on the
device and secondary we want that
library to be added to the Java class
path of this process so that the
application can access those classes so
this is important for the runtime use
but we also want to assist the developer
in building their application from from
the get-go so for instance if I just
show you this simple little activity
that we've created in this demo
application the problem should be
readily apparent as a developer I'm
trying to use the fancy new luck manager
that is specific to this device and just
targeting a regular Android application
base API I cannot do that because this
symbol is unknown when we're just
linking against the core framework so we
have to include the SDK add-on so that
all of these issues will go away so as a
developer the way that I would do this
is I would hop into the SDK manager and
when the SDK manager comes up I need to
add to my environment
the add-on sites where those custom SDKs
are being provided from so I can jump in
here from the tools go up to manage
add-on sites
and there is a section for user-defined
sites and you can see that I've already
added a couple of those to repository
xml's that were in the slides that I've
just got locally hosted on a web server
on my machine here you would obviously
want to host these somewhere out on the
public web but these are the
repositories I've created for my add-on
and for the system image and this way
with those add-on sites in place when
the developer looks at their list of
available options for installation in
this case I'll go down to 5.0 since
that's what we targeted they'll see a
couple additional options they'll see an
option for my custom add-on and an
option for the accompanying system image
so I can select both of those and choose
to install them on my system notice that
it requires me to verify read and agree
to the license associated with these two
elements which was that license text
defined in the repository XML and then I
am able to install them are the install
partners to take just a moment and once
that install is complete we can go back
to the IDE and we can start using this
code okay let me start SDK manager here
and first of all notice that both of
these are now listed as installed on my
system so I can leave the manager and
come back to my application now in an
Android studio application which is
constructed using the Gradle build
system the build Gradle file defines
what the compiled target of your
application is and the best way to
modify this today is to simply manually
change the compiled SDK from the base
platform to the value that's associated
with your add-on this is not yet set up
in studio to go through the IDE
graphical property settings I imagine it
will be in the future but for the moment
we have to actually do this manually in
the file so we have to know
what the name of our SDK add-on is and
this is least for the time being might
be something you want to explicitly
convey to developers when you're
providing documentation on how to
install your add-on until this gets
cleaned up a little bit at least in
Android studio so we have to provide the
fully qualified name for what this value
is and in this case an add-on is always
defined as the vendor name followed by
the add-on name typed correctly followed
by the base API associated with it so
this is the way that the Android SDK
names and uniquely identifies the add-on
that I just installed so I resync the
project a couple things so as Gradle is
rebuilding the project if I reopen my
project Explorer down here under
external libraries we can see that the
target for the SDK has changed to my
alpha add-on and that in addition to the
Android jar that's always there the stub
jars for my additional libraries are
also included here as well so we know
that it's now linking against all the
stuff that we need it to and if I jump
back to log activity I can now see that
all of the things that wouldn't resolve
before now resolved properly because
they have stubs in our add-on that they
can link against now reminder that this
is just stub code I can't jump in and
actually look at the definition of
what's going on in here
these are all just going to be empty
stubs but it's enough to get the
developers up and running and link their
application so that they can build and
run it now just as a side note if you
are an Eclipse user the functionality
here is similar but it's done in a
slightly more polished way in Eclipse
the developer would go to the properties
of their project and underneath the
Android group they would select the
add-on as their SDK target don't see
here and let me just try it
it's quit eclipse and restart and see if
it comes back
sometimes it clips likes to cache
information a little bit too heavily
okay so we go to the properties of the
project Android we see the option of our
alpha add-on here so we can select that
as the target API and notice that as it
switches from the base target to the
alpha add-on all the red that was
associated with this file has now turned
proper and this file resolves as well so
you can do the same thing if you are
still developing on Eclipse or if you're
the developers that you work with are
still using Eclipse that functionality
exists as well and in fact from a tools
perspective it's still slightly a little
bit more polished so the last thing that
I want to show you here is that in
addition to being able to link against
the library project we the functionality
has also been added for us to create an
emulator of this device so if I jump
back into the SDK manager and this time
we decide to manage a beedis abd stands
for Android virtual device we're
basically going to create a new emulator
so in addition to the library package I
also downloaded that system image target
and if I create a new AVD then there
will be an option for me to first of all
select a device
pick your favorite from the targets list
to select the alpha add-on and
immediately the alpha addon selects that
it has available system image in this
case targeting x86 the
is available to work with now it's
important to remember that the way that
these two things link together which we
saw briefly in the slides is that the
system image must be tagged with the
same ID as the name of the add-on and
those two things will allow the tools
like the AVD manager to determine when I
select this target that it should
present this option as the available ABI
that I can select from for my emulator
then I could go through and add
remaining components that I want to and
may AVD and create it and then at this
point as a developer I could spin up a
version of the emulator that has all the
functionality in it that is specific to
this device associated with these new
api's that have been exposed to me
during a library and I can fully code
and test my application against those
device specific changes okay so just
final notes here before we part ways as
I mentioned that entire example that I
just showed you the fully functional
device target and the SDK add-on built
alongside of it are hosted publicly on
github there on our site at github new
circle alpha and if you want to learn
any more about this information if you
like what we're talking about here today
you'd like to dive a lot deeper and talk
more about how to build SDKs building
the android platform and all of that
our next android internals class where
we teach all this in great detail is
coming up in June so you're welcome to
sign up for that and if you would prefer
to instead have us come directly to you
and train your team come talk to me
afterwards and we can talk about private
training we would love to do that as
well so thank you very much for your
time and if you have any questions go
ahead and come up afterwards thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>