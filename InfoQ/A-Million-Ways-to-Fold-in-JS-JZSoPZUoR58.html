<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Million Ways to Fold in JS | Coder Coacher - Coaching Coders</title><meta content="A Million Ways to Fold in JS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Million Ways to Fold in JS</b></h2><h5 class="post__date">2016-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JZSoPZUoR58" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okey I'm probably gonna run over time so
I figured I'd just start a minute early
oh wait let me start my screen recording
here so I'm gonna be talking about folds
and recursion and Co recursion and fun
stuff like that in JavaScript I'll
probably be showing lots of code and
you'll probably get really frustrated if
you try to read all of it because we're
just gonna like keep hitting next you
could be like stop it so so the point of
the talk is to kind of show you
alternatives to loops and kind of point
out some cool stuff with recursion and
don't get caught up in the details just
kind of you know kind of look at it from
a high level and then later on if you go
look into it further you'll have like an
intuition and a better understanding
you'll have like a head start basically
so I'm a little hoarse I did a class
yesterday first horse joke BAM
trying to try to keep it interesting
okay so the agenda is recursion code
recursion transducers mono it's and F
algebras so much fun you guys here let's
just do it so just like there's no
crying in baseball
there's no loops in functional
programming and mainly because loops are
going to just mutate or do some side
effects or whatever and it's really
low-level you know you have all these
little bits and pieces everywhere and
you have to rewrite it every single time
from the ground up we can capture these
in functions so I like to call them
SpaghettiOs
instead of Leafs so let's talk about
recursion as an alternative strategy so
we have this sum function and this is a
recursive version of it and you've got
your base case your action your
recursion do you guys show your hands
how many people know about recursion
already all right
great awesome so I'm just gonna go
probably pretty fast
so here's reverse it looks very similar
look at that
and it's the same stuff Scott's base its
recursion it's action something to stop
their courage in something to call the
recursion over and over
and if we look at how its evaluated it's
just going to keep growing in memory
it's going to say one plus the sum of
the rest one plus two plus the sum of
the rest one plus two plus three forces
and it finally hits the base case and
starts to come back down the stack and
the memory can kind of be released as it
falls back down but don't be worried
don't be scared
es six I mean yes 2015 sky out for tail
calls
there's the optimization for tail calls
and so what does that mean if you look
at our sum if we actually say first plus
the sum of the rest it has to come back
to this particular invocation and add
this element to the sum of the rest and
we could rewrite that oh you can get a
maximum call stack exceeded and stuff
like that so if we rewrite it way more
complex down at the bottom with this
helper function called go and an
accumulator we're gonna call a function
at the end and there's nothing left to
do here and it can release the memory so
es6 will give us that I'm gonna be great
and we have this reduced function and
that's also tail recursive except it
doesn't really matter how reduces
implemented this could be with a for
loop under the hood you know who cares
just call reduce so let's use some in
Reverse you know in terms of reduce and
the intention is much more clear we've
captured this recursion pattern here
that we looked at with some and reverse
and all these other functions that are
really useful in this higher-order
function and now the intent the actual
style of recursion has been captured we
could just say it's gonna add to the
accumulator starting at 0 or we're gonna
can calculate or starting an empty list
much more expressive we could also
define map and filter in terms of this
which is very useful you guys use map
and filter all the time I'm sure you
most people do and reduce is very
general it can implement all these other
helpful useful list functions with it
it's actually cat a morphism so reduce
is an implementation of academ orphism c
cata
Morpheus
it's also called a fold and you can fold
left or right I'm just gonna say fold
because I don't really care if it's left
or right at this in this talk and all
these really useful functions like all
in any and all these things that you
would see in like lodash or ram de or
underscore whatever that you use on
lists all the time can be done in terms
of this cata morphism or our reduce
actually any loop can be captured with a
fold or reduce I'm gonna say fold from
now on stop saying reduce this is
actually kind of a backward slide
because you would think that Superman
would be it doesn't matter it's because
she has a lasso and it's a loop okay
so there's other things like in April
morphism and that's another different
recursion scheme we've got a pair of
morphism if you can capture that with a
higher-order function as well and it
doesn't matter if it's recursive it's
you know a loop underneath this one's
cool it passes in the rest of the list
to your accumulator function and that'll
you know be useful for things like sorts
but you can still do this
with the reduce as well it just kind of
gives you some helping hands here anyway
so these extra functions and these
recursion schemes can be caught in
higher-order functions I like to call
them higher-order recursion schemes or
horse second horse joke I was gonna do
that I thought it'd be too racy anyway
so that's recursion in a nutshell you
guys already knew Co recursion there's a
little bit more interesting it's gonna
get more interesting as it goes along so
bear with me so this is called an
Animorph ism frozen fans where my dad's
at so if you've seen unfold you can be
implement this in plenty of different
ways this is just a really simple
implementation you don't have to worry
about that code too much here we can do
with unfold though is we can we start
with zero which is our seed and then we
return a pair of our value and the next
seed so the next seed here is x plus one
and our value is the actual character
code and then once we return nil it
stops so this is basically like the
functional equivalent of a while loop
and you could just call unfold and it'll
do cool stuff like that
we've got range
we can implement in terms of unfold so
we've got our folds and we got our
unfolds and once generating stuff one's
reducing things down and you know we can
do this to many other data structures
not just lists or arrays I'm gonna use
those two interchangeably so tree can be
folded down or unfolded and you know
we've got event streams that can fold
with an accumulator
we've got objects infinitely many data
structures you can just fold it down
there's an intuition about it we say we
have this data structure and we want to
kind of reduce it into a value with an
accumulator so there's something
important here there's some kind of
theory and something really general that
if we can understand and get at we can
define this for many different data
types and we can find all those useful
this functions you know those ones that
any all some find sort like these things
are really really useful so here we go
we've got a linked list but we're gonna
use for ourselves and so we can kind of
investigate this mystery
do you guys know linked lists all right
it's a basically the first elements
ahead and the rest is the tail so cons
three and its second a property is the
rest of the list all the way down to nil
we could represent that with a
JavaScript object here I'm gonna by
convention do this gross thing of
calling underscore cons as my object but
then a non underscore cons so I just
don't forget to write new and nil it's
just a singleton so I don't have to do
that but for the rest of the talk I'll
be doing underscore for things that are
actual objects and the rest is just a
public constructor so yeah here's our
cons linked list and we can do the same
thing with trees don't worry about is
the tree definition so that's that's a
code recursion and I define those extra
helpers so we can we could look at
things throughout so transducers are you
guys excited do you guys know what
transducers are all right cool let's
look at those for a second I'm going to
go too deep into it I just want to kind
of explain the idea behind him so if you
have map and you're doing a reduce this
is kind of just like a general reduction
here where we have
of a few things going on we have an
iterator ours we're doing iteration
we're doing accumulation and we're doing
transformations so as you walk you're
your list you've got your input list and
then you've got your output list doing
accumulation there could be two
different types right I could start with
the list and end with a number or
whatever so our accumulator and our
iterator thing have two different types
sometimes we transform everything so I'm
gonna make some terminology here this
first argument to reduce I'm gonna call
that a reducing function or a reducer
let's just call it a reducer okay so
this first argument reduce is called
reducer it takes an AK and an X and it
just returns a new accumulator so what
if we kind of pull out the reducing
function the first argument to reduce
and we just you know return it by
calling mapper so I call mapper and it
just gives me the first argument to
reduce and there we go why would we do
that well let's make it a little bit
more general since this reducing
function is also dependent on can cat
let's pass in kanne cat there so we're
giving map or a function to map and its
way to accumulate right it's scan cat
and we can do the same thing with filter
there's our filter and that's so so
basically all these functions are doing
is returning the first argument to
reduce a reducing function or reducer
and that's the reducing function but
look at this signature here the King cat
function has the same arguments and does
the same thing as a reducing function it
takes an accumulator in an element and
returns a new accumulator so that means
our King cat you milady function is
a reducing function as well we can
actually just pass King cat directly to
reduce now just copy the list so we can
pass other reducing functions to other
reducing functions all the way down and
it's like reducing inception so you
basically what is that inception thing
gonna get played out so you've got kin
cat and you know it passes that into
mapper and that makes a reducing
function and that gets that turns into
the concat passed a filter and makes a
reducing function all these things
return
reducing functions that's called
function composition and we can actually
make a kind of a pipeline of
transformations and mapper and filter
here are called our transducers so
transducers are just a mapper just the
filter apart but the interesting thing
here is that the reduction itself is is
in one loop
there's no first you map over the whole
thing then you filter the whole thing
it's just we're gonna make this this
transformation pipeline that's totally
ignorant of its input and its output and
we're going to give it to the reduce so
it does it once and go both filter and
map so that's really cool it does this
kind of stream fusion for us we kind of
do it manually as we build it up and as
a bonus we have our list here and we can
we have a iterator protocol that we can
program against in es6 so i'm using fat
arrows here cuz why not I'm talking
about es6 anyway but so we can iterate
over this list and we don't need to keep
its shape so we can actually use the
iterator protocol to implement this
reduce but this part is a little bit
trickier we don't have a protocol here
for accumulation so we have to know that
we want to start an empty list and we
have to know how to build it up how to
accumulate them together same thing with
our linked list here that we defined we
can make it an iterator that's all good
but what about this nil and append like
we have to have them publicly available
to kind of construct this computation
and we have to know like where to start
and and how that works and same thing
with our tree here so we've got kind of
our iteration just done iterator
protocol cool
we've got transformation just grand-slam
out of the park like we can build up
composable generic transformations that
work on any data type because they don't
care about their input and they don't
care about their output we're actually
feeding that stuff in and then the
accumulation not so much there's no real
protocol to work on and I have to know
stuff about you know what I'm trying to
build up and I have to have access to
those functions so I just slide there is
actually a protocol for building things
up it's called a mono age so let's talk
about them for a minute so let's see
here
can cat properties to it
so we just saw a concatenate and it
turns out if you can cat an empty list
to left or right of any list you'll just
get that list back or it's just like a
neutral thing that doesn't do anything
so it's a great place to start and then
it's also associative so you can
concatenate lists or you can you know
flip it around you always end up with
the same result
so in Fantasyland j/s there's actually a
specification for this so it's saying
anything is a mono if it has its can cat
and it's empty method and it opens by
these laws or this contract or however
you want to say it so let's let's do
that let's make a mono I'd so it turns
out list or array was already a mono ID
with King cat and empty array but let's
make a few other ones so here we have
some and we're gonna do something wacky
we're gonna make a some type like an
object we've got that underscore private
thing and then my public constructor and
it's just got one property called Val
and then we basically put the first
arguments to reduce on the type itself
so the first arguments to reduce is
going to you know add two things
together that's what our can cats doing
it's saying I've got a sum so I'm gonna
add it to another sum we're gonna add
they're their bowels together and then
we start with an empty sum with the zero
as its first argument so these two kind
of correspond to each other the can cat
and empty are just the first two
arguments to reduce and if we have that
well we can make a reduce that doesn't
care about its first function or its
seed argument it just or its first
accumulator we could just call it
directly with a list and of this type
and it can figure out what those are so
folding down the list of sums will give
me a sum of 10 the first time I saw this
I was like what anybody do that it's so
weird I would rather work with functions
what am i doing like making this some
type that's only good for this but it's
actually really useful we'll look at
that why in like two or three slides
from here so just hang tight but so
we've got a fold that will just fold
this list down into one sum and and this
should be relatively clear what's
happening even though I'm just
lasting through slides so sorry if you
get lost in the code so we can do the
same thing with products products can be
combined with a you know multiplication
and start with one we can fold that down
we could do the same thing with Max and
min just always keep the highest and
start with negative infinity which is an
actual JavaScript value which is so cool
that should be my new avatar and when
it's negative infinity and we've got all
in any's this works for boolean's and
stuff - it's so all just says hey
everything in the listened guess what
don't these look a lot like those really
useful list functions that we listed at
the beginning all any sum products max
moon yeah these are these are really
useful functions just kind of put into a
type remember we were able to reduce
things and make things in terms of
reduce well now we're putting those
arguments on the type themselves and
we'll see the benefit so you can make
all these functions with these things
we'll see the benefit of that here in a
second also I'm iterating over a list
here which is you know we get that
iterator protocol so that's cool we can
iterate over data to other data types so
we can make this little fold map
function this is a really simplified
version and it depends on map so don't
worry about it too much there's a really
complex one that uses the iterator but
if you look down at the bottom we've got
some max and E and all it's doing is
saying hey take your list of something
put it make them all sums and then fold
it down and give me the value or put
your list of anything make them all
maxes and fold it down give me the value
any all that's how you can basically
define these functions and we can make
them work on anything that that's an
iterator so that's pretty great so we've
got our tree some tree product and our
cons any and our cons all and it's also
because of that associativity we can do
it in parallel so that's pretty great
and to be fair you're not gonna get much
of a win if you try to do parallelism in
JavaScript you're gonna have to spend
more time chunking an array and running
down the list but it's often useful to
know that property just in case you do
want to try that so so we've got our
iteration done
our transformation not so much because
these things are already built in we're
not actually transforming anything we're
just saying hey make my Sam make my
product like not running functions on
values but the accumulation is what this
is all about we're we're killing it
there so this is kind of different from
transducers and in fact there are mono
toll transducers that you can use I'm
not going to talk about them today but
you can kind of combine the two so if
you look at this type we've got this
array of sums and it's gonna give me a
sum and you know there are a list of
products and lists of Max or mins and it
basically takes it down a type like
we've got some type of another type and
it gives me that other type that's kind
of the idea behind folding right if I
reduce a list of things I'll get of one
value in this F of a there's some type
of a to a even though the type is a list
of another type
that's called an algebra so let's look
at F algebras and no not that F a lot of
people like F algebra so cata morphisms
we can actually there's a lot of ways to
skin the cat a morphism and this is
another way to do it so we've got this
two things to notice here we're
depending on map here and we actually
are depending on map here we can't use
the iterator protocol and it's going to
recursively call itself this is an in
tail position because I wanted it to be
simple and readable but you can totally
do it so this will map over everything
and recall itself over and over again
until it hits the fixed point of our
functor what the fixed point of a
functor a functor is anything with the
map method and you know behaves
correctly you can look that up and the
fixed point is the thing that returns
itself so it has a map method and
whatever returns itself is called the
fixed points so if we you guys know the
Y Combinator that's kind of like the
type level version of that so map know
that map
it's a functor and it returns itself
awesome that's the fix point of the
function at map that will actually pass
F into its children or give its children
to F
it's tail so this is not the intuition
you might have normally when you're
looking at you know a map you would
think I have a list a linked list and I
want to run a function on every element
that's that's what I think of when I
want on a map on a map over every
element but here I'm not calling F with
the element I'm calling F with the tail
it's the children that we're after here
it's like the child snatcher I'm sorry
chitty-chitty bang-bang fans so just to
be aware of if you're going to do this
you need to define a different kind of
map so we look at our sum function here
up here it's called an algebra I think
yeah there's an algebra because it's
going to take our X which is our entire
cons linked list thing and it's going to
return us a value out so it takes it out
of its type and then we've got our list
here and if we give some our algebra to
Quetta it will actually fold our
structure down so that's a whacky thing
to do let's look at how this actually
works though so the first time X comes
through it's nil so it's starting bottom
up and the next time comes through
you've got cons for onto zero and that's
if you're paying attention that zero
shouldn't be a zero it should be the
tail of the rest of the list and every
time it's coming through it's actually
already folded by that point so I'm not
actually working with any recursion
I'm just working with one level and all
its children have already been folded by
that point so I don't have to worry
about anything
recursive I just pass it to cata and I
say do it and here I'm working with a
list of four and zero then four then
three or three and four and then two and
seven it's pretty cool so it's summing
that bottom up so we can make map in
terms of this catimor fizz emits pretty
cool it's like our F algebra version of
map on our linked list and we could do
the same stuff with trees here I'm at
you know empty is a fixed point and
we're passing our children into F and we
can sum this down and look what's
happening here is I don't want you to
cringe at the case statement but it's
the best I can do for pattern matching
here but the idea is that we've kind of
pushed our data specific stuff to this
in line
algebra here were passing Nakata so this
is the part that needs to know about our
tree and the cat a morphism takes care
of all the recursion for us it just
calls itself in math so let's talk about
an Animorph ism in this way so we've got
our again we're depending on map and
we're recursively calling ourselves and
this is called a Co algebra this array
to lists which is a Co scary word anyway
so this array de list is basically going
to take a value that's not in a linked
list and then put it in one that's why
we call it a Co algebra it takes our a
to our F of a and we've passed that Co
algebra to our anamorphisms and it'll
make us a linked list which is pretty
cool we've got this make alphabet that
just like we saw before we can do this
kind of unfold but this is basically
working with our linked list type and
we're passing in algebras to this
recursive thing that just takes care of
it for us don't have to worry about any
recursion our Co recursion in this case
we can do the same thing with range cool
so there's flg bras we've got our
iteration and our transformation or
accumulation we kind of dropped the ball
in the iteration because we have to
define our own map that doesn't work
like an iterator it's passing all the
children and at once but the other
things are cool transformation we're
just doing whatever they're so we can do
that and accumulation works great but
this is where it gets interesting
so it's kind of like building up to this
part and the whole talk so if you're
gonna pay attention to anything so
programs are actual data structures that
can be folded down into a value it's
called interpreting the program so you
can build up a structure of instructions
and then you can interpret that by
Valley Academy morphism so sorry yeah
you're welcome
so here we've got a add two and three
together we'll get a five and then we'll
multiply that by a four so we have to
wrap these things at the type level
these are unev alyou ated pure data
structures representing our program that
we're going to fold down and we could do
this you know this object definitions
same as always and we're gonna pass the
map near the children in
and this is where it gets interesting we
have our interpreter that takes our
structure and just runs these functions
if you hit multiply multiply if you add
atom otherwise just get the value out of
a constant and our program gets
interpreted and we do indeed get 20 out
I have the gist if you don't believe me
so you can download and play with that
but this is really this is really cool
this means we can make programs that are
entirely pure and they're just
instruction sets that we can kind of
build up dynamically and pass around and
compose and combine and we can write
interpreters one for maybe a test and
one for you know when we're in the
browser one on the server it's really
interesting stuff here and we could send
them over the wire and whatever so we
can do this again with lichen cat and
replace an input just to illustrate past
their children in and this interpreter
will turn hello world into mellow world
which is pretty cool and so it runs
right-to-left and will fold down that
data structure but we can also do this
one it's a different interpreter that
actually describes what's happening and
saying Concannon the world after
replacing age with m on hello so
basically these things these
interpreters are when things actually
happen and everything else is period
think about that if you're doing age you
know API calls or writing files or
deleting things and all that's really
hard to work with and test and and you
can actually just generate your
instruction set and pass that around and
work with your little algebra that will
interpret it down and if you've heard
about free monads this is like half of
it and the other half is the pure but
you can do Co routines and stuff with
this so this is like almost a free monad
it's a very very important design
strategy and architecture pattern and
functional programming because it
basically makes everything in your
application pure and you don't have to
worry about you know side effects at all
and then you can interpret it down and
you can make little sub algebras
throughout your application which is
really neat
so that was my F algebras and my MA
nodes and all that stuff so next time
you're sitting down to write a loop and
you know you're you're like should I
should I write another for loop you know
stop and think like
how long as are these for loops gonna be
around they don't really have the
composability and they're not being
captured and listen that so there's my
talk
thanks I started a minute earlier so so
I I guess I have a minute or two for
questions if anybody wants to ask a
question I won't make you feel stupid I
promise okay oh what's that
yep that's right that's kind of the idea
of an algebra you take your F of a to an
A so you yeah it's like a fold you just
write down out of the data structure and
that's if you look at reduce same
signature pretty cool stuff but that
goes to A to B and I think algebra is
take a to a so that's something else
anyway
anybody else you can go to this github
repo and play with this stuff
oh there's also by functors and stuff in
there that I really get to talk about
because when I practice it at home I
kept going ten minutes over I just cut
it all out but there's stuff called like
by functors and they've got things
there's by map anyway I'm not gonna
waste your time all right thank you guys
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>