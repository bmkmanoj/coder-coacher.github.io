<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Using ES2015 in Your Applications Today - Forward 4 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Using ES2015 in Your Applications Today - Forward 4 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Using ES2015 in Your Applications Today - Forward 4 Web Summit</b></h2><h5 class="post__date">2016-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WiANbp0alPs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Matt Blair I'm a software engineer
an open table I'll talk about es6 today
specifically what we can do with es6
today in the browser I know the the talk
description mentioned a lot of different
things but like end up getting narrowed
down when I try to get this fit into 20
minutes just about like what can we do
today in modern browsers with es6 and
researching this talk i was talking to a
friend of mine and he was like oh man
yeah es6 it's so cool but we'll never be
able to use it like we're always gonna
have all these legacy browsers his
support we're enough to support IE and
like and what's the chance browsers
actually implement these features in a
timely manner and that was kind of the
attitude i had going in to i was like
this stuff's never going to be available
to me and then i started looking at open
tables user log of like you know who's
using an evergreen browser whose is in a
modern browser and i found seventy-eight
percent of our user base was using a
modern browser an evergreen browser and
evergreens a self updating browser and
the term modern in this context means
ones that support already support cs6 so
seventy-eight percent of our user base
already uses it in the global web when a
zillion statistics it was closer to
eighty percent so if anything open
tables actually lagging a little bit
behind some sites i looked at the
statistics for as high as 93% so the
fact is that like you can use es6 right
now certain features of it on your
website and you would have a you know a
giant portion of your user base excuse
me all right so where are we at where we
at with the specs support since it was
formalized in a in july the latest
version of chrome and opera is that
ninety-one percent of the spec firefox
85 edge is 83 and Safari nines at
fifty-four percent of the spec oh and
one other caveat when I say modern
browsers I'm not including ie11 only
edge because it's the only actual self
updating browser so it has to be an
evergreen browser as well all right so
so what if we want to use a transpiler
we wanted to try to get those features
in what can we do and oh by the way all
these slides are online they're all open
source and all the code i'm showing is
all open source as all my speaker notes
so with babel the latest version of
Babel you get seventy-six percent of the
spec tracer gives 59
typescript and other super satin
languages 56% closures at 31 and jsx is
up twenty percent alright so I'm going
to dive right into examples of what
features right now all of those
platforms share so what can you use
right now and all these different
browsers that will work currently for
your evergreen users and your modern
browser users a little note on the
syntax that works everywhere some
environments require a use strict
statement so like these features are
there but if you're not using you strict
they won't won't be available and you'll
get an error alright so you get lat
Const arrow functions object literal
extensions and string templates I'm
going to walk through each of these with
some examples let so here's some here's
some es 3 some like code we probably all
seen and this kind of exposes some
problems with how we declare our
variables today the top line you see I
declare X is equal to 31 and then I this
if block if true then they declare VAR
ax is equal to 71 but because of browser
hoisting and how JavaScript works VAR x
31 + VAR x 71 are actually the same
variable so if you ran this code and did
console logs you would expect this to be
71 and then 31 but it's not it's 71
everywhere however let resolve this
problem and introduces block level
scoping so now when you declare a
variable inside of a block like a while
loop or a for loop or an if block that's
actually a different variable than the
outer scope from a variable so you get
the kind of correct behavior that you're
expecting an open table when rewrite
variables we almost never use var
anymore I can't actually think of any
instances when we use var because that
is the behavior we're actually looking
for all right let errors so if you re in
using VAR if i declared the same
variable twice it would just work
because of hoisting with let it'll
actually throw an error if you try to
read eclair the same variable again
it'll say you've already declared this
um something else if you do use a
variable before you declare it it will
actually throw an error as well and that
wasn't the case with VAR VAR we just
hoist a variable up and it would work
even if that variable wasn't set yet all
right const const is another block
scoped um
it's got a block scope syntax except in
it it's exactly what you would think
it's it lets you declare a constant
variables but there's one caveat i'll
get to that caveat in a second all right
so you can see at the top I say const my
fav is equal to 7 the next line I try to
I try to change that variable that would
be an error you can't change a constant
once it's been set except well you can't
change the value but one thing that's
interesting about that is that um sorry
I'm us because I'm like in Firefox and
Chrome you get an actual exception in
Safari just swallows it silently but
doesn't change the value so it's one of
those things where const is there but it
doesn't quite work how you'd expect it
to so you can see on the next one I say
console.log my favorite number is and
then all those cases the number would be
seven whether you got the error or not
now you can see a further down I try to
read eclair that variable is another
constant that would throw if I try to
declare a variable or user or a lat with
that same name that would also throw you
can only ever declare a constant once
and again at the bottom even with all of
those cases if I had those in my code
the variable wouldn't actually change
value with const you have to supply to
value to start it is declaring a
constant variable that cannot change so
if you just try a con su and then try to
set food later even the declaration will
explode something cool about counts is
that it doesn't have to be primitive
types you can declare objects arrays
SATs maps and we'll talk about some of
those other data structures later but
you can't a constant most anything is
equal to that and that works and then
same thing where if you tried to then
change that a complex objects value it
would explode here's the caveat though
constants are basically like object
pointers so they point to a reference in
memory so you can actually change if you
have a complex object you can change its
internal values and that doesn't cause
any explosions that's fine you can
declare a constant object and then
mutate all of its properties and that's
fine and that's part of the spec so what
it's saying is this object can never
change in the object reference can ever
change but the internal properties of
the object can constantly mutate that's
something that's good to know if you're
first trying out with
all right arrow functions I don't know
how many of you were at the es6 talk
earlier the ESX panel then it's like
have enough there's a lot of mention of
arrow functions arrow functions really
don't give you anything that wasn't
already available to you in es5 it's
just really nice syntactic sugar and
again there's some caveats so basically
you can see in the comments on the right
what the the equivalents are you know I
have parenthesis arrow you know curly
braces foo and that's basically the
equivalent of function you know
parameter is curly braces foo so that's
pigs at us lose the function key word
out a couple races so it's like and then
there's the implicit return which is one
of the nice benefits you can see here I
don't have the curly braces and that's
basically the equivalent of saying curly
brace return those parameters and one of
the panelists mentioned that's like one
of their favorite features if you're
writing chaining lambdas or things are
constantly returning values you can
write a structurally an expression like
this and it just implicitly returns that
value also if you only have a single
parameter and only in the single
parameter case the parameters are
optional again that's really nice if
you're working with Landa's so if this
is just syntactic sugar you know why
would we use this okay so fat arrows for
one in a bind to the this context so if
you're using them in like a class or a
prototype everything in that arrow
function will be bound to this you could
do this dot whatever and that's bound to
the outer scoped context so that's one
advantage to disadvantages of using
arrow functions are that um one you
don't have access to the arguments
object so in this case where I've a 1 a
2 a n I can't do arguments whatever it's
actually bound arguments is down to the
outer scoped function you're calling the
lambda n so it's not available to you
second thing is arrow functions don't
work with generators so if you're right
here in generators base code you can't
yield out of an arrow function so
there's some places they're very useful
and there's some cases where they don't
work at all alright object literal
extensions ok so I have some es5 written
up here and then I'm gonna show you
another slide where I show you the
equivalent with es6 so I have some
variables
clear to the top then I declare a and
bar then I declare an object and I say
you know property a is equal to a and
then I say property m is equal to this
function and then below that I
dynamically set a a property so i say
object bar and brackets equals 10 4 and
so that's the equivalent of saying
object foo is equal to 10 4 and then I
use object to find property to set up
set a getter I don't know if you guys
have seen that object property nothing
but that's very standard es5 that's out
there so this how you'd write this in
es6 so you can see it's a little tercer
there's a lot of short hands going on
here at the top I declare my first two
variables button on that next line you
know after the VAR object I say a comma
and that's object shorthand basically if
the property is the same name is the
variable you don't need to say it twice
just saying a common goes ok this is
property a is equal to value a em prins
e so basically I don't need the function
key word at all when you're declaring it
in an object or in a class it just says
name of the function / ends in the
compiler knows the difference then so
function goes out the window down here
you're the next line i have the square
brackets baller that's a computed
property so it's basically saying take
the value of bar and make that the
property name so that's basically the
equivalent of object foo the previously
that doing a dynamic computed property
wasn't possible at object instantiation
time and then the last one is I don't
actually use Gators that often but i
love the syntax is this shorthand get
name of the getter and then what returns
from the getter so instead of that
object to find property mess of syntax
you can do that now and make very
quickly set up a getter or a setter all
right the last thing I'm gonna talk
about syntax is string templating so
this the first line in the second line
are equivalent and as you can see in the
first line I've got this you know the
was it called again double quotes and
I'm like string text line one newline
string text line two and then the next
line i say string text line one i do a
line break and then do string text line
two so this is the string templating
character the fact that i added the new
line in string templates just recognized
and say oh you want a new line I'll
insert it in for you so you can actually
do formatted text as a template with all
the line breaks correct and it'll just
work out of the box on the next line you
can see placeholder values and this is
one of the things I think most people
who use string templates use I say 15 is
dollar sign curly braces a plus B and
line breaks not you know a bunch of
other stuff that data what's inside
those curly braces interpolated and
directly insert it into the string
without doing string concatenation so
this is a really nice feature of string
templates and I think this is most of
the use case always this is how we
primarily use them an open table all
right so I've rushed you through a bunch
of syntax now I'm going to rush you even
more through a bunch of new data
structures that es6 gives you that are
available through all modern evergreen
browsers so it's set map week set week
map symbol and promise and again these
are all available to you today all right
what's asset asset is basically like a
set of boolean flags you knew up a set
and then you add a bunch of things to it
primitives or complex objects it doesn't
matter and it basically checks for
uniqueness of those values and then
keeps track of those so you can see on
that second line I say s dad hello I add
hello again and then I add an object the
next line I say what's the size of this
set it says to because I added hello
twice it just throws out the second
reference and it says I've got two
objects the next line and say s has
hello that would return true so it's
basically as a way of keeping track of
like what objects have you seen and with
with the caveat that item allows you to
see like uniqueness you can keep adding
the same object hundreds of times and we
just keep throwing it out and those
objects can be complex types and on the
next one you see for let key of blah and
that actually prints it out an insertion
order so you can keep adding objects to
this and then print out what order did
it actually see those objects which is
kind of nice all right now there's a map
this is very much like a hashmap except
it takes nylon e primitives about
complex types so you can see here i
trade a new map I set the value I say
the key
hello is equal to 42 then I say the key
object s is equal to 34 and then I say
you know get the value with that complex
value s and so yes it's 34 and then I
asked for the size and it's too so
somewhat similar interfaces and then
down there for lat of key value of M
entries same thing it's done an
insertion order so this is like a very
robust hash table that they've added to
JavaScript if you guys are needed now
the next two were part of the ones that
the least people are using and are
probably the my opinion the most useful
weeks at all right week set is a way to
keep track of what objects you've seen
but as soon as they're ready to be
garbage collected they're taken out of
the set excuse me so you see at the top
I say let thing to delete equals an
object next line I say let WS equal new
week set then i set the object WS week
set set thing to delete one thing one
caveat with week said is that the
objects cannot be primitives they have
to be complex objects or arrays or other
types so then the next long ago you know
have I seen this thing and it says yeah
you've seen it on the next line i delete
that object I basically market for
garbage collection on that very next
line if I check if that object exists
the weeks that will say no so if you
ever have like let's say a dynamic page
you've like dynamically trading sections
of a page you could load them into a
week set and you've said you know oh how
I loaded this stuff and it would tell
you yes but then as soon as those
dynamic portions are deleted you're not
going to hold a reference to them so the
garbage collection can freely collect
them so it's a great way if you're like
checking for you know conditions before
voting dynamic features they're going to
you know come in and out of memory it's
a great way to do this without
introducing memory links week map is the
kind of the same concept except it's the
hash table concept so I have an object
to delete let wame go new week set I set
a complex object to a value know again
the key cannot be a primitive it has to
be a complex type and then I go and I
grab that you know I say hey give me
what that object value as i said earlier
and it's 42 in this case then i delete
it and then I go hey does that that
thing in there and it goes nope not
there and if
try to get the value of just return
undefined this is extremely useful in
the case of like tracking event
listeners you can register event
listeners get them and as soon as the
object disappears from memory there's no
pointer from the event listener to the
object which keeps both of them in
memory so again he's a really useful
concept if you're doing like any type of
dynamic objects in the browser where you
want things you know to not not leak
memory all right a symbol symbol is
probably the one that people have the
least idea what to do with it but it's
actually really useful in a lot of
different instances okay so just bear
with me and I'll explain the use after I
walk through it a bit so symbol foo is
not equal to symbol foo every symbol you
create is globally unique no matter what
keyword you pass into it or what
variable you pass in so you can see
there I say you know cons foo and bar or
equal to new symbols I say type of foo
in it gives me back oh this is a symbol
and then i create an object i say let
object you know i create an object and
then I say object foo is equal to the
word feu object bar is equal to the word
bar so I've said object this symbol is
equal to the value foo object this
symbols that go to value bar then if I
json.stringify that object those symbols
aren't there and if I object if I do an
object keys and the object those symbols
aren't there so basically I've traded an
object I can't you know I've traded
these properties that can't be found and
so like what's the use of that well one
you could create private variables with
them you can introspect symbols but it's
just it's not easy it's basically like
kind of out of the primary path of how
people get properties so it's an easy
way to tack on little bits of private
data that you don't want your consumers
to see but you want somehow to be able
to be surfaced another thing you can do
with this is like metaprogramming you
could use a symbol to define like logger
behavior for a whole class of objects
and then you say hey if this symbol
exists on this object log it in a
different way or give you know provide
additional data so you kind of change
the behavior of built in pieces of code
based off these symbols the other thing
that the release force constants you're
creating like a massive I kind of like
enumerations you can say each one's a
different symbol and you'll be guarantee
that they're globally unique and that
they can't possibly
overlap with any other symbol in your
system and if you have questions I'm
going to stick around after this guy see
a lot of questions right now on the last
object I'm gonna talk about our piece of
syntax I was going to talk about its
promise but promises I feel like who's
these promises in here I'm not going to
talk about them they're part of the
language they're baked in you don't need
a third party library anymore they're
available to you so what else is there
that I can't talk about in 20 minutes
that I wish I could the class keyword
the super keyword in generators these
are like probably 20 minute talks the
first two and the last one on their own
and I just didn't have space to fit them
in but they're globally available in all
of the modern evergreen browsers to you
right now so what's not available to you
and what is not shared between all the
browsers proxies which if you haven't
heard of or seen they're basically a way
to like wrap an object and then anytime
anyone interacts with that object you
can raise an event and then like kind of
track what's going on it's a really
interesting way to interact with objects
you could say every time a function is
called call you know call Cole lager or
something is that an example so it's
like really it's a way to basicly
introduce that kind of aspect-oriented
programming in a javascript d
structuring they talked a little bit
about this earlier this is something we
use really extensively at an open table
and our code base and we really like we
think it simplifies but just not not
widely available and the last thing is
subclassing array and functions and
other baked in like primitive types or
complex types so in the future and es
sick and this six in the spec you'll be
able to do something like say I want to
have an a this something called like a
promise array that inherits from an
array and maybe overwrites some of the
base methods that hang off of array
currently that's not possible that's
coming but it's just not widely
available all right so right now if you
wanted to write like the latest and
greatest es6 code what are your options
well you can write us if you know if you
have control your user base you're like
maybe like have internal users you could
write a client single page app and
chrome 49 plus give you 90 1 / 6 the 91
% of es6 give you proxies to structuring
and sub classing of the primitive types
but doesn't have module import or export
yeah so use something like browserify
and require a required dress or
something else to get module import in
there you can write in of things
application using the XX s6 runtime I've
never heard of this runtime before but
apparently it does ninety-seven percent
of es6 implemented but unfortunately
it's limited to proprietary hardware so
it's kind of like if you won easy a six
on their boards you can use this runtime
and it will work and it'll give you most
of the language the last thing you can
do is use like node 4 or 5 use like
babble on top of it give you
seventy-five percent of es6 it gives you
d structuring it gives you module import
and export and it also can give you some
other features because Babel allows you
to put in plugins into its
infrastructure so you start using other
things like es 74 sync on the way object
rest spread you can also use things like
jsx typescript flow things that are
outside of the language with this
approach because Babel is more like a
platform than than just an es6
transpiler all right oh thanks so much
for your time I know I rushed through a
lot of material very densely this is the
link to my blog that's the getup link
which has all this all these slides and
all my notes and those two links at the
top are kind of like invaluable if you
want to find out what features are
available where and then how those
features work and isn't many questions
we have a minute and actually no you
know what there's a break after this so
technically we have a minute and then if
you don't wanna leave for the break I
can answer some more questions in the
back a symbol in JSON um I guess I'm not
100% understanding a question you mean
like a JavaScript object like how would
you use it on an object or what how do
you use it like JSON across the wire
because symbols won't show up in JSON
like as it is right now i'll give you do
json.stringify you will never see
symbols
not really not for that use case you
can't really pass symbols across the
wire or the way it's bill and I mean if
you wanted to write a custom
implementation of json.stringify you can
introspect out symbols you can find out
all the symbols on an object then you
have to write like your own syntax and
it wouldn't really be JSON anymore that
makes sense all right any other
questions you a shallow comparisons
looking object references so it's not
doing like it's not checking if the
properties all align if you cloned it
you could set them both that's right
right there okay so there's a
performance implication if you're trans
piling and there's a performance
implication if you're bundling using
something like browserify or web pack
was the other one was looking at the
other day I can't remember but anyway so
and but the performance implementations
are always from browser fine web pack or
just like the amount of code they add to
the batch everything together and then
with transpiler they're adding code to
shim out that feature so there's
additional code there now there's
actually a really great article that
someone who wrote that's causing the
which is called I think the cost of
trans filing is 2016 in 2015 if you
google that you'll get a link i have a
link actually on my laptop if you want
to come up afterwards which really talks
about like what is the cost of using
es2015 today so yeah there is a cost but
honestly it's like what is your
acceptable level of cost you're going to
deal with it's it's similar to
innumerable false it's just one use case
it's just like not having to use object
to find property you can just say symbol
property done and you're out and then
and the fact is it that like it's it's
such a separate use case I think I think
honestly the people who use symbols are
going to be people who are doing a lot
of meta programming it's not actually
gonna be for the use of like a private
variable in the end it's for people who
want to like don't frameworks that if
you define this symbol on an object it
will behave differently like what's the
underlying implementation I'm not sure
honest so I've more like tested the
behavior and poked with it I mean it's
basically a hash table but like with
complex keys so but honestly under the
hood I can't tell you about each browser
does it so I'm sorry about that actually
I'm gonna in know but if you guys want
to come up I'll stick around for a
couple
it's okay like thanks a lot for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>