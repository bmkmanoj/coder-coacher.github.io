<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Richard Feldman Discusses Elm and How It Compares to React.js for Front-End Programming | Coder Coacher - Coaching Coders</title><meta content="Richard Feldman Discusses Elm and How It Compares to React.js for Front-End Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Richard Feldman Discusses Elm and How It Compares to React.js for Front-End Programming</b></h2><h5 class="post__date">2017-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U6fOXONqD9M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this podcast is sponsored by click
playground this free programming
environment lets you explore and test
your data-driven app ideas using clicks
engine and api's the goal less query
writing and more efficiency with
associative indexing visit playground
click comm to learn more and see it for
yourself
welcome to the info cue podcast my name
is Wes rice and along with the committee
of Architects senior developers and
engineering thought leaders from places
like Netflix stitch fix reddit and a
variety of other places doing amazing
engineering I chair and plan the content
for the english-speaking Yukon software
conferences published by info cube the
next one by the way is skew con New York
in Manhattan June 26 to 28 the info cube
podcast is an architecture learning
podcast that chats with some of the
engineers you typically find speaking at
Q con or writing for info q in today's
podcast we talk with Richard Feldman and
it's all about Elm
Elm is a front-end focused functional
programming language that compiles to
JavaScript in this very densely packed
podcast richard talks a lot about things
like being an early adopter of elm the
architecture of elm Elms immutability
timeline debugging semantic versioning
package management and more he talks
about community ecosystem I really hope
you enjoy this podcast it was a lot of
fun Richard welcome to the info cube
podcast
I went to your talk at Q con London I
was super impressed I guess my second
real exposure to elm and there were a
lot of things in that particular talk
that got me excited like the debugging
experience for it for example okay so
I'm really excited to learn more about
elm and ask you some specific questions
from that talk and from some other
things but before we do let's kind of
set the stage tell us a bit about what
the work you're doing today is and about
the company so we can kind of learn
about the problem space you're solving
with Elm today yeah so I work for no red
ink and we make grammar and writing
software for English teachers so
basically the founder was an English
teacher for eight years and he kept
running into these problems where he was
like I can't solve these with pen and
paper I really need software to do a
really good job teaching these concepts
so he hired a guy on Craigslist to build
the software for him to use in his own
classroom and then other teachers
started asking him about it grew it grew
and sort of eventually he decided you
know this
what I want to do is I want to you know
build this out and turn into a company
and down five years later here we are
okay so we're now yeah over two billion
questions answered millions more being
answered every day got seen about 20
engineers we're hiring by the way trying
to grow that team and make it money and
it's going really well so I just
imagined from just the context of this
being Elm and being a front-end that
it's a very front-end heavy heavy app
it's running mostly in the browser yeah
definitely about a quarter of our users
or iPad but we don't have a separate app
it's all just in the browser and we sort
of pride ourselves on taking a really
customized approach to each different
concept that we're teaching we kind of
view like multiple choices the last
resort we always try to do something
more interactive more tailored to the
individual curriculum and so that means
lots of custom UIs for all the different
concepts for teaching cool so you have
Elm on the front end I would imagine
among some other things probably still
but what about the rest of the
architecture what's that look the back
end is almost exclusively Ruby on Rails
we just started introducing similar
services we've got one in production
we're working out another two and
basically as we've sort of scaled up and
up we've started to run into certain
limits and the old approach of just a
big rails model is it's really scaling
anymore so we're pretty excited about
elixir 2 on the back end and there's
been a lot of talk about the Elwood
Lakes repairing going on so happy to get
on board that train yeah I was gonna
assume that you it was Elm elixir that's
why that's why I asked him yep so you
mentioned just before we started
recording that it's been about two years
since you started this journey to Elm
what did it look like before Elm and
then I guess what kind of triggered you
into picking up Elmen and taking it into
production yeah so before that it was
you used the term earlier JavaScript
jungle which I think it's pretty
accurate we had just jQuery and it's a
backbone it's a little bit angular and
just a big mess of things
and then react came out in in 2013 and I
found out about it now I've been sort of
into the functional programming idea I
hadn't really done much with actual
functional languages but conceptually I
was like this is a pretty cool way to
write programs and I heard about react I
was like oh wow this sounds really
great so we were actually really early
adopters of react I actually co-opted a
book on react like one of the really
early books on react and basically we
had a really good experience with that
and that sort of became our dominant
paradigm and sort of led us out of the
jungle of all these different
technologies and into the like okay
react as is what we're doing but
separately I'd been kind of wanting to
actually try a you know a first class
functional language that was designed
from the ground up to be functional so I
ended up for a variety of reasons
settling on Elm as the the one I wanted
to try so I was using it for a side
project and basically there came a point
where we did a really big feature it
react at work and at the end of that
feature I was like wow this would have
gone so much better if I used Elm with
it that I actually think based on my
experiences with Elm it was kind of a
mistake not to try doing it an elm and I
regretted that and I said you know I
kind of I knew better I knew that you
know this this technology was there and
that it was good but I I didn't use it
because it was kind of a new thing I
didn't really want to take a risk on it
and I thought okay well you know fool me
twice shame on me I'm not gonna do that
next time I'm just gonna just go to try
introducing it and see what happens so
we just tried it out on a really small
feature and it worked it went well so we
did a little bit more a little bit more
and then before we knew it that became
our new dominant paradigm it was like
yeah this is what we want to do it yeah
that's what it's been ever since you
used a phrase in the talk or a comment
in the talk where you said we could have
taught everybody to use Elm and still
delivered it faster than than we had
with react that kind of stood out to me
yeah as a really telling state yeah for
sure and I mean a lot of that had to do
with the the feedback loop where you
know this is a project where we needed
to do a lot of heavy revision like we we
would try out a design we took it out to
a classroom tried it out and it just
didn't work it wasn't effective and so
we went back to the drawing board and
when you have to make a lot of big
changes like that L was really conducive
to refactor z' too rewriting stuff
because basically the the typical
experience is you make a bunch of
changes and then you work through the
compiler errors the compiler has these
really friendly error messages that help
you figure out you know all the
different corner cases you missed and
then once it recompiles it typically
just works with no regressions that's
like a pretty normal
experience and it sounds kind of hard to
believe would you yeah you certainly was
to be but now I'm just you know I take
it for granted but basically I kind of
you know had a very different experience
with react with you know I make these
changes and I run it and I get a runtime
exception and go Tracy sat down and
figure out what went wrong and there was
just a lot of you know crashing into
things until finally I hammered it all
out and got another version working that
we could take out to a classroom and try
out again and we had to go through
several of these iterations and yeah by
the end of it I was like this took so
much time to revise that even counting
the amount of time it would have taken
to introduce l2 ram people up on it like
by the end of the project it would have
ended up being in net time savings and
the results would have been more
maintainable so that was how I knew it
was a mistake not to use L well that's
crazy so tell me something how did you
sell that to your leadership to be able
to introduce Elm I mean this was two
years ago I just read maybe I'm a late
adopter to it but I just found out about
L last year sometime so two years ago
that had to be even more of a challenge
to try to sell it to your leadership so
you know the interesting thing is it's
it really comes down to risk and the key
for us was just you know we talked about
it and we were kind of like okay so this
is a new technology you know it's it's
not mainstream the key was just saying
well look we're just gonna do it on a
really small project right like this is
just gonna be one part of one page if it
doesn't go well we can always back out
and if it does go well we can say okay
well then we'll just do a little bit
more and see where that takes us so it's
you know a big difference doing it on a
small piece of one page versus saying
our next project is going to be an L
right then you're really betting the
farm on it
that's a big risk and so if you can
minimize the risk of introducing it then
it's not such a hard sell it's not
saying like you know we're not
committing to this this is not a
commitment this is an experiment we're
just gonna try it out and see where it
takes us and so this incremental
adoption strategy is by far what I hear
as being the most common way that other
people adopt Elm I mean we we didn't
nobody told us to do that we just happen
to do it that way and thankfully it
worked out that was what we did with
react too so it kind of had a little bit
of experience with that approach
but basically mancine to be a pattern
where when I talk to people who are
using Elvin productions today that's by
far the most common way that they got
there was just starting with something
low-risk makes no sense sounds like a
lot like lean lean UX to be able to
start with something small test it out
minimize the risk and then kind of
iterate doesn't work you cut your risk
and then iterate from there absolutely
exactly what's up what is a really good
use case to start with that someone who
may be coming from the react community
or from from the angular community for
ember for community for that for that
what's like a really good use case that
can show maybe the power of Elm for
someone to start off with I'd say
anything that you're sort of afraid to
maintain and now that's a that is a bit
of a double-edged sword right because on
the one hand if you're afraid to
maintain it then maybe you're afraid to
change it to something else but I would
say if the reason you're afraid to
maintain it is that it's changing often
like you you often have to find yourself
having to go in and tweak the business
logic something like that
rewriting that chunk of the code in L
and and you know of course using Elm has
JavaScript Interop so that would be the
way that you incremental e introduce
something and put it in there then have
JavaScript talk to it sort of elm as a
service and then once you've got that in
there then you can just sort of use that
as a way to get an experience with what
happens when I need to maintain this
chunk of the codebase now and my
expectation would be that you'd find a
way yeah this actually isn't scary
anymore we recently had one of our
newest team members and she's been
working here I want to say two months
maybe and she just like earlier this
week she made a series of reef actors
that touched something like a hundred
and fifteen files and she just made a
full request and she's like wow I'm just
not at all afraid that this is gonna
break anything because it all compiles
I'm like I I you know again the
experience is just like typically if it
compiles it just works again and like we
have a QA guy so we're not you know just
gonna like shoot it straight into
production of course sure but you know
just that level of confidence is just a
real game changer when it comes to
developer productivity yeah I was gonna
ask you I think you just answered it by
saying that but what the ramp-up period
was I'm imagining when you typically
hire people and I I know this for a fact
because you're talk but you're not
hiring people that have this tons amount
of Elm experience you're right you're
marrying them that may be from the
JavaScript community or so and then
bringing them into elm and so the ramp
up period within two months you've got
someone who's refactoring across the
entire code base pretty confidently
that's something that sounds like a
pretty good ROI there yeah I mean so we
we don't expect any experience on day
one like we does just not even part of
our job requirements and yeah so we have
people writing Elm in their first week I
mean usually not making such a big
invasive change at the code base but
honestly that's less about ailment more
just about I mean how many companies
hire somebody and then on their first
week they're like I'm gonna make a huge
refactor you know you just don't know
the codebase well enough yet but I will
say that you know it's been surprisingly
easy to get people ramped up on Elm and
the key for us has just been pair
programming it's you know sort of saying
okay we're gonna get you up to speed by
just pairing with someone and they'll
just explain concepts as you go and you
can you can build up a lot of good
intuitions from that and then once you
do get on your own the compiler helps
you out a lot like if there's something
that you know once you've got some of
the basics down and you know you don't
know about this edge case you don't know
about this technique in a lot of cases
you can just be like well there's sort
of a guardrail around you know what can
go wrong because the compilers gonna
help me out like if I try to do
something crazy the compilers gonna give
me an error and then it'll usually
explain to me you know here's why this
is a problem here's where you can go for
more information on it and so it that
gives beginner is a way to sort of build
stuff be productive ship stuff get stuff
done you know maybe in a pull request
somebody says oh actually you didn't
know about this other way you could have
done this here's a cleaner way to do
that but the risk that they're gonna
actually break something or cause a
problem is a way way lower than what it
is in JavaScript or typescript for that
matter yeah that makes sense
okay so let's back up for a second so we
can't just jump right in but let's start
off with what is elm because you know
when I when I think of em I think of it
as a trans compiler and I don't think
that's accurate so what is Elam yeah so
Elms a functional programming language
that as it happens right now compiles to
JavaScript but there's absolutely no
reason it can't compile to other things
but it's it's primarily focused right
now on compiling to JavaScript and
letting you use it to build reliable
delightful web applications so it's
of two-pronged focus is developer
delight and maintainable applications
like really reliable stuff and the key
to both of those is basically the design
of the language and the compiler that
backs up that design so the friendly
error message is the idea of getting all
of your checks done at compile time
rather than at run time you know we
talked earlier about we've we've had
element production for two years now
we're over a hundred thousand lines of
elm code and we still have gotten in
production a total of zero runtime
exceptions in that entire two years you
mean so I mean undefined it's not an
object nothing you don't get those
anymore yeah not at all I mean so so we
used roll bar to do an error tracking
and so whenever something throws an
exception roll bar tracks it and so we
have still a lot of legacy JavaScript
code like it's a minority of our code
base now but obviously you know
historically we wrote a lot of
JavaScript before we started writing so
much element and so we still see runtime
exceptions from our legacy JavaScript
code all the time so we know that they
still can't happen we didn't all just
become you know magically amazing
programmers yeah and it's also not that
Elms design encourages swallowing errors
it's actually the opposite where Elms
design really encourages handling errors
and so the key is basically that Elms
design is such that the compiler can
catch all of these things for you at
compile time this is like an overt goal
of the language to be really explicit
about here are all your edge cases don't
leave anything up to just oh well we'll
figure it out and if it turns out
something's wrong we'll just crash
that's always considered you know not
the right thing to do and because the
whole language like all the primitives
are built around this concept other
programs you know libraries that are
built on this sort of solid foundation
also inherit that same characteristic
sort of by default and a really good
example of this is null so you have you
know Java you have null pointer
exceptions and JavaScript you have
undefined is not a function or you know
null equivalents of that in Ruby you
have nil el doesn't have any of them it
doesn't have a concept of null so I said
this is the talk like sir Tony Hoare has
this great quote you know he introduced
the concept of null and he considers it
his billion dollar mistake because he
thinks it's caused over a billion
dollars in economic damage absolutely
and it just doesn't have it instead if
you want to represent the idea of you
know there's a potential absence of a
value here which is conceptually what
null does elem has a way to do that in a
way where the compiler is capable of
checking for that and explicitly saying
oh you need to handle that here like you
can't forget to handle it when you use
it it's been kind of an astonishing
experience but what's even more
astonishing is that we're not the only
ones who've had this like whenever I
meet somebody who's used tell Z they're
using elven production that's always the
first question I ask is you know how
many runtime exceptions have you gotten
and so far it's been zero from everybody
I've asked this is you know no that's
cool I mean honestly that can't go on
forever I am aware of this because it
like you can still run out of memory and
cause a stack overflow right there's
there's just ways you can crash programs
like no matter what your design is so
I'm sure it's got to have it sooner or
later but just the fact that it's gone
this long without happening to me or
anybody I talk to you is pretty
impressive I mean so you've mentioned a
few times that the compiler really helps
you out
I'd like to dive a bit more into that I
mean we've had statically typed
languages forever
compilers always helps us but but how
does that compiler really helping you
out to make this experience such an
amazing awesome thing I'd say two things
one is the design of the language and
two is just that Elvis one of the first
languages that's really focused on the
idea of compiler as assistant not just
compiler as you know something that
generates the byte coder generates the
JavaScript okay so actually evan chip
flicky the the creator of element he's
done such a good job on this and has
spent so much time thinking about how to
give a good compiler experience that Elm
is I'm gonna say easily the most cited
language for like when I whenever
another language says we want to try and
make our compiler error messages better
I see this all the time now they cite
elements like we want to be more like L
and it's not like you know nobody could
be doing this I think it's just that
Evans the first person to say I'm
actually gonna devote a lot of time and
energy to trying to get this right he
actually gave a talk at UCLA like a year
or two ago to a roomful of programming
language authors about how to get nice
high quality error messages and like you
know Martin odorous kievskaya famous in
the audience taken notes
you know this is you know it's it's
really kind of like on the frontier of
how to get a good user experience from
your compiler so that's one aspect of it
and the other is just that the language
is very design is around like how can we
have a really nice user experience where
things don't crash so some good examples
of this are so we talked earlier about
null the idea of having the sort of opt
in way of representing the absence of
something where you sort of have to go
out of your way to say this can
potentially be missing so you think
about array access right you have an
array of things in JavaScript you can
just say you know bracket 5 bracket 7
whatever and what it'll give you back is
potentially undefined if something's not
at that position so an L when you have
the equivalent you've got an array and
you want to get something out of there
that's explicitly where it says ok this
is this is one of those opt-in moments
this is where we can potentially have
the absence of a value and what that
means is that you can't forget to check
for what happens if the index is out of
bounds what happens if there's nothing
at that oh cool right and this is
something we're in in JavaScript it's
just very easy to end up with it
undefined there and just have that you
know filter through your program so when
you say you can't forget to check that
to make sure that there's a value there
what does that mean is that in the
language or it the the compiler enforces
you is the developer to handle that
condition both so basically what comes
back when you do like an array get like
at a certain position is it's basically
a container around the value you want so
let's say you've got an array full of
strings what you get back is not a
string it's a container wrapped around a
string and that container says I've
either got a string inside me or I do
not and so you actually have to do a
second check once you get that value to
pull something out of that container and
there's basically a conditional that
will let you say ok here's what I want
to do in the case that there is a string
in there and then you can actually get
the string into scope and work with it
or here's what I want to do in the case
where there is no string in there and
then this there is no string in scope
you can't work with it
so the compiler then checks all of that
and says ok like you have to have both
of these branches and you can't leave it
out and nice yeah so I know that there's
been some work in like typescript and
flow to do this with null checks right
where it's got this notion of
you have to have an if statement that
checks the conditional to see if Noah's
being handled or not but an important
difference is that with elm that's
actually baked into not only the
language but also all of the libraries
and all the AP is you know across the
board it's not just for null is for
basically everything so all of these
corner cases where something might be
missing or something might be one of two
different options or one of three
different options and they all work a
little bit differently this notion of
you can't forget to handle it is just
pervasive across the language it's not
special case to null it's just
everything works that way and so that's
how you can get from you know things are
better to things just don't crash that's
pretty awesome I want to take a second
and kind of go up a little bit higher
level and talk a bit about the
architecture of Elm itself and how it
how it all works so I'm gonna test your
ability to describe things without a
whiteboard so how how does Elm work how
does this all get packaged up well first
off what do I need in my environment
before you go into it do I need to go
set up you know grunt and gulp and do I
need NPM do I do I need to set up you
know 15 other JavaScript packages
started what do I need and then once I
have all that kind of tell me walk me
through what it looks like to compile a
program how does all that work yeah sure
just do NPM install - GL and then
that'll just install everything for you
so Elm is very self-contained if you
want it to be so the compiler is just
called I'll make and you just say L make
you give it the name of your main file
and then it'll just spit out the the
compiled JavaScript actually if you want
it'll even give you an HTML file that'll
that imports that JavaScript so you can
just have it all right there that's not
quite what people use for production
typically when people are using it in
production they in practice are still
doing some amount of JavaScript Interop
which means that they end up wanting to
use stuff like web pack or grunt or gulp
to manage the JSI to that so if you're
doing a pure elm project and it's got no
JavaScript dependencies that you care
about you don't need any that stuff you
can really just get by it with just I'll
make just the whole way through so like
I said in practice people tend to want
to access you know the JavaScript
library ecosystem is much bigger than
the Elm library ecosystem so people end
up wanting to do that in fact
but if you're just trying to get started
yeah you don't need any of that you can
just start with you know NPM install -
GL and then go from there
without installing anything else yeah as
far as how elm programs are put together
the basic interaction paradigm centers
around three sort of central concepts
which is model update and view so at
your basic level you have your model and
your model represents your entire
application state it's immutable it's
just one immutable value and it
represents everything that's going on
your application and I really do mean
everything this is sort of distinct from
you know react or redux or flux or
angular ember where you have sort of
your application state is distributed
amongst lots of different places you
have you know the flux stores or you
have stateful components yeah well does
not have a component system on purpose
there's no way to store State anywhere
other than the model and this has some
really interesting implications and
particularly for debugging but basically
you take that model this immutable value
represents your entire app state and the
L runtime which is sort of the
JavaScript that gets generated to make
all the the engine run will just take
that model and pass it to a view
function that you define so you write
this view function and all it does is it
takes the model and then it returns some
virtual Dom that is a description of how
you want the page to look so the
argument is the entire application state
and the return value is here's how I
want the page to look then you have user
interaction people click on the page and
then based on that user interaction it
calls this update function that you
write and update functions job is to
take the old model the previous
application state and a message
describing what the user did and then
use that to generate a to return a new
application state and again this is just
one immutable value it's just like
here's everything here's the entire
state of the world yeah and then it gets
that new one calls the view function on
the new one and then that gets a new
description of how the page should look
and then from there you're sort of off
to the races that's a you know I'm sort
of breezing through this but that's
that's the high-level idea sure sure so
it's basically events flow into the
system it's very reactive it's just
taking it binding that new event to the
model and are taking that model rather
and binding it to the view and that's
how things yeah that's all there is to
it it's it's very consistent
yeah nice so a couple questions
come it's all there is to it so a couple
things come to mind
so so you have this elm code and it gets
compiled to this runtime what's that
sighs look like is that is that pretty
heavy yes great question um I would say
it's currently pretty medium and it's
about to get pretty light so right now
it's if you do to do MVC like LM to do
MVC it's smaller than react to do MVC
after like minification in gzip that's
even though it's including basically
immutability library like persistent
data structures are built in and also
state management is built in so in
practice you know react to MVC doesn't
have state management like redux or flux
and it also doesn't have an immutability
library built in but most people who are
using in production tend to want one or
both of those as they scale and get
bigger that's actually going to change
in the next release of elements it's
most likely I mean you know the release
isn't out yet so obviously anything
still subject to change but that's been
actually a big focus right now is on
asset management and on things like dead
code elimination so the idea of here are
these functions you know like the HTML
library has helper functions for you
know button form input all these
different things but in practice you
don't end up using every single one of
those so dead code elimination is
basically saying oh you're not using all
these functions let's just throw them
out let's not even keep them sure and so
I don't know what the exact numbers are
but what I've heard is that preliminary
numbers suggest that it's like really
small especially considering that you're
getting in a beautiful new library and a
state management library it's I expect
to be a pretty exciting release for
people who are really constrained on
bandwidth ok so the next question that
comes up for me with what you described
is if you're keeping the entire state
for application and it's completely
immutable with every state changing
event you have you have to completely
recreate the immutable state that that
seems like a huge performance hit to me
what's the performance like using M yeah
so the key there is that these are using
Elms built-in persistent data structures
so they're actually you know you're not
cloning the entire thing every time it's
just you know syntactically you're
expressing it as like here build this
whole new thing from scratch but
actually under the hood what it's doing
is it's just you know it's doing lots of
node sharing and it's like only actually
changing the stuff that needs to change
ok performance-wise LM actually
benchmarks better than react
angular and ember so there's a blog post
on the website that's basically going
through like here are the methodologies
we used and like you know a lot of
details about like here's how we
compared apples to apples on rendering
performance there's also some pretty
cool tricks that Elm can do because the
entire language is built out of
immutable values and pure functions like
there's no you can't write an elm
function that has a side-effect so it
unlocks these really cool performance
optimizations that are safe to do an elm
that are not safe to do in the general
case for you know react and other
libraries for example batching your view
functions so you can actually and not
you can but it actually just does this
for you Elm will call
requestanimationframe and only call your
view function basically like right
before it's time to render 60 frames per
second it doesn't actually get you
anything to call that view function on
every single time the model updates it
only gets you something to call the view
function on the current model whatever
it's about ready for the browser to
render okay and so that's what L does it
just says okay well we'll just only call
the view function that happens react you
could do that but since view might have
a side effect you know that could
actually cause some pretty nasty bugs
but an elm at compile time it's
guaranteed that there are no side
effects so it's definitely safe to skip
that oh whatever in it yeah whenever you
want to that's really cool there's
another thing I wanted to ask you about
and that was I think I mentioned at the
very beginning the debugging experience
with Elm I was kind of blown away about
but this whole idea of a mutable state
and then just having this model flow
through the system and then be able to
do these updates gives you some really
interesting capabilities with debugging
could you walk through what the
developer experience is like debugging
an open project yeah it's totally so one
thing I didn't mention earlier is that
when the user does interactions like
clicking or typing in a text field or
something like that what happens is that
you specify this in terms of messages
and a message is a piece of data that
says here's what the user did and here's
whatever information is necessary to
perform the update so let's say you
click on a button it might just be hey
the user clicked on the submit button if
the user is typing it might say hey the
user typed in this text field and by the
way here's what they type and so since
your update function is written in terms
of these messages what the debugger can
do is it can actually just display and
it does
display just a list of all the messages
that are flowing through your system and
you can just step back in time and time
travel and say okay when this message
came in where what was the state of the
world how about well this one came in
how about when this one came in now you
can look at that and also you can look
at the model which again is your entire
application state so you can just kind
of expand out the tree and just look at
okay what were all the values and my
system at that point it's like you have
a watch on everything and again you can
you can approximate this thing by you
know like Redux which is actually based
on the Elm architecture as Dan Abramoff
was looking for a way to implement time
travel debugging for a conference talk
that he had submitted and he was looking
around he's like this is really hard to
do and react any and he found Elvin was
like oh they're doing it how are they
doing it and so he sort of based Redux
on that but there is this really
important difference between having it
on an opt-in basis versus having
everything built around it right so like
if you're time-traveling in redox all of
your redox state comes with you but
everything else that's you know like
your staple components and stuff like
that it's just not aware of those it
can't you know those are not part of the
picture whereas four elements really the
whole application you know the fact that
not only all the stuff you write but the
entire Elm ecosystem is built around
this means that you get this whole
different level of like well I'm going
back through time it's really going back
through time yeah you do they in in the
presentation I saw you do you exported
the entire event order and then brought
it into another browser and kind of
recreated that entire state and gave you
some really interesting things if I'm
working on some kind of feature branch
that has a bug in it I can export bring
in that state and give it to another
developer who can then check out my
branch and be able to recreate it that
was that was a really cool experience
for a developer to be able to get to
that exact condition that raised that
bug exactly yeah I mean it's it's it's
like reproducing bugs is a surprisingly
time-consuming experience when the bug
is hard to track down just being able to
say look here's the file just import it
yeah definitely and a difference so I'm
gonna throw you for a loop a little bit
here maybe throw you for a loop but what
um so so where the sticky parts of them
if I it sounds like a great story
and it sounds like you know it's gonna
be an amazing experience for me to bring
it into my project but where's the but
there's got to be something in there
that's the sticky parts the tricky parts
the parts that I need to over
and learn about what are those with them
I'd say a couple things so the biggest
one is that basically elves approach is
to say okay we're gonna make a really
clear bright line distinction between
Elm land and JavaScript land and so Elm
is saying like okay we have these
primitives that we're building on top of
these primitives and that lets us and
foresees guarantees that give us this
really good experience the trouble is L
doesn't have a complete wrapper around
like every single thing you can do in
the browser that's like done in this
nice way yet so that means that you end
up doing JavaScript Interop for
something you know maybe surprising
things so there's you know the part of
your application that's written in elm
and then sometimes you'll come across
something we were like where's the elm
library for this oh it doesn't exist yet
and actually no is it not exist yet but
this is just not something you can
express in elm at this point so I know
in particular some people who have been
doing things around content editable
like people who are making WYSIWYG
editors like text editors and stuff like
that death tends to be some pretty Dom
mutation heavy stuff right and at this
point element just doesn't have a lot of
libraries you know a lot of support for
like really digging into the Dom and
doing the manual manipulation and so
when you get to that point you know you
just end up going straight to JavaScript
Interop and you know obviously that's
not as good at the experience as you
know when you're building a more
general-purpose application you can kind
of stick more to just you know elm for
ninety five hundred percent of the thing
you said a second one I want to ask you
a quick question about that and let you
come back to the second one so what does
that JavaScript Interop look like I mean
you're in your L map location how are
you wiring in you know I think you used
a calendar example for for example in
your talk how do you wire in that
javascript call into another library yes
so the way LM talks to javascript is
basically the same way that it talks to
servers which is to say all you do is
you send immutable data out to
JavaScript and then JavaScript can send
some data back to you just like call on
a function well different from calling a
function in in one important way which
is that you're only allowed to do it at
certain points in your update function
like at the end of your update function
so again LM programs are built out of
functions that don't have side-effects
and since JavaScript functions and just
have side-effects so another way in
which it's similar to kind of talking to
servers is that basically the way that
you
do a sync the way that you do effects in
general and elements that you return a
value from your update function so
update returns here's my new model and
that can also return here are some
effects that I want the runtime to
execute and like what I wanted to do
when they're done and so you do
JavaScript Interop the same way where
you you would either say at the end of
update okay I want you to do this HTTP
request and when it's done send me back
a message to update you know with what
came back same thing so in that way you
have the same error handling
characteristics as you do with servers
you don't have to worry about the
JavaScript code sort of like sneaking in
and breaking your guarantees gotcha but
it is more work so you said one of the
second way that you thought that there
could be a tricky part without and so
that would basically be the the
server-side story so if you're writing
JavaScript you can do the same language
on the clients and on the server in Elm
you can't get so like theoretically in
the sense that Elm compiles to
JavaScript yes you can run elm code on
node on your server but there is no
ecosystem for it right you there's no
like HTTP web server library there's no
database access there's just nothing and
this is by design because basically the
choice was sort of should we split focus
and and you know go down the browser
path and on the server path or try to do
a really good job on the browser and
really get that solid and then move on
to the much bigger project that is the
server and that road seemed to make the
more sense yeah it makes sense well that
does mean that for right now if you want
to have the same language on the client
the server you just can't do that
without okay so one other question
whenever you're exploring another
language you kind of want to know about
the community in the ecosystem what's
the ecosystem look like with elm what's
the community look like yeah great
question so communities it's my favorite
parts I mean so we had elm conf last
year at st. Louis is gonna be coming
back again next year it's the day before
a strange that they sort of attached a
strange loop we're about to have elm
Europe in Paris in June I think actually
there are still tickets left for that
but very excited about that but I I just
like I love meeting community members in
person because they're just like really
nice really smart people and there's
just a great culture of like kind
helpful thoughtful friendly people I
always think about programming language
communities and what's it like if you're
a beginner walking into this community
is this going to be people who are just
like beginners so annoying they don't
know anything or is it like oh hey
welcome let me help you out let me
answer your questions and L was
definitely the second kind that's cool
as far as ecosystem goes I would say
that it is much smaller than JavaScript
ecosystem but also much higher quality
like much more reliable that's for a few
reasons the the biggest one is that elm
package so Elm has its own package
manager' completely separate from NPM is
really strict about a couple things one
is that you can only publish elm code to
it so if I make a new project and I'm
like here's some Elm code great I have
published it's like great thanks your
your package is now published people can
use it as soon as I do JavaScript
Interop in that package I can no longer
publish it it says no sorry can't do it
so what that means is that now the
entire ecosystem is all pure elm stuff
it's got all the guarantees there's no
asterisk there's no you know this this
might break at runtime you know on the
JavaScript side it just you know it's
it's all else but it does of course mean
that you know it's going to be smaller
right a good example of this is like
people wanted a hashing function right
like an md5 or a murmur three or you
know and somebody's like oh hey can I
just like rap you know the JavaScript
implementation it's like no you gotta
write that actually function in element
and so you know and at first people were
like oh that's too much work I'll just
I'll just do JavaScript Interop but then
eventually somebody was like okay I'm
just gonna do an L and so now you have
hashing functions written in elm on the
package very cool so that's one reason
another cool benefit of that by the way
is that the package manager enforces
semantic versioning automatically so if
I publish that package then I wrote an
elm and then I am like oh I'm gonna
delete this function or I'm gonna change
the arguments around and then I try to
publish that as 1.1 it'll say nope
that's a breaking change I saw what you
did there I can tell that you changed
the API you have to bump the major
version number you have to publish that
as 2.0 so it makes upgrading like a lot
nicer doesn't the experience we've had
with NPM I heard a great quote from
somebody actually in London after cuke
on which they said I didn't switch to
Elm because I was unhappy with react I
switched to Elm because I was unhappy
with NPM Wow yeah I can totally
appreciate that you know it's it's a
very different experience when that's
your whole package ecosystem and and the
other thing is just that culturally Elm
has this the packaged community how
this value that turns out to be really
good which is that it's the way things
are named so there's this cultural thing
where you're really supposed to name
packages after what they do so like you
have LM CSS which is the CSS
preprocessor you have LM tests which is
the testing library and pretty much like
you know 95 plus percent of people use
that one thing what's interesting about
this is that what that means is when
somebody goes to create a new library
the first thing they do is they're like
oh I want to name it the obvious thing
what's the obvious name so they'll go
and look and see if that already exists
and so they're more likely to just be
like oh this already exists I'll
contribute to it and so it's actually
kind of weird for you to say oh I'm just
gonna make another version just because
I want to do things a little bit
different that's great yeah and so it
ends up having this effect where this
sort of people use the term JavaScript
fatigue where you just have a million
different options to choose from and you
don't know which one yeah
part of that is that the Elm community
is smaller granted but the other part is
that you know when people make something
new they're sort of culturally drawn to
trying to contribute to the existing
thing rather than splitting off and
making an alternative and so as a
newcomer coming in you're more likely to
just be like oh there's just one obvious
popular way to do this and there aren't
just a bunch of different things that I
have to you know spend even more time
deciding between yeah that's very cool
that's really cool actually thank you
for the time Richard for chatting with
us if you enjoyed some of the stuff
you've heard and you want to learn more
about Elm make sure to check out
Richard's book I think you've got a meet
bow that's got three or four chapters
out is that right five right now I'm
almost done with chapter six very cool
so check out his Elm in action you can
catch his video for Q con London I'm not
sure when it's gonna be published but
it'll be out in the next at least three
or four months because cuz everything's
published within three months and also
check out Elm comp in Europe or in the
u.s. in st. Louis if you want to learn
more in to some deeper conversations so
Richard thanks for chatting with us
thanks for having me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>