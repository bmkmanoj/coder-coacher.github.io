<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Git: Tips and Tricks for Ruby Teams | Coder Coacher - Coaching Coders</title><meta content="Git: Tips and Tricks for Ruby Teams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Git: Tips and Tricks for Ruby Teams</b></h2><h5 class="post__date">2011-06-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z2ZL14WWEJI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so this is it just the tips I am
Jared grip i work for change the lord
you can find out more about me at those
two addresses I should let warn you this
is not a beginner get talk this is sort
of advanced to semi advanced tips that I
have accumulated over the years that I
find useful and my like daily usage of
get if you're still like a weekend
hobbyist or your beginner i highly
recommend scotch cones talk so i'm just
going to sort of shotgun fire through a
bunch of tips i'm going to go pretty
quick so a lot of the stuff that we're
going to go through is get configuration
stuff and so it's helpful to know that
it has at least two main configuration
files there's one in every clone of a
repository that's in the dot get /
config and then there's one optional in
your home directory and these just house
any number of options and variables that
can change the default behavior of just
about every get command that can be
useful first things first the best thing
ever color out of the box I've seen in
some cases get does not come with color
options so you don't get you know you
just get black and white Texas a lot
harder to read so if you add this to
your get config you totally turn it's
lame output to awesome output highly
recommend that git bash completion is
awesome also I don't think comes just
basic install if you follow that link
and just download that file and source
it when your shell loads you get bash
completion which is super nice it
completes a whole slew of stuff it'll
complete all the get commands it will
complete all your branches so it just
sort of makes like you know get
check out origin master super easy to
type these are just some of my basic get
aliases sorry about the word wrap the
ones at the toppers I feel like are
pretty canonical just sort of i think i
see everyone using those but you'll need
to know them if you're not familiar with
them to sort of watch me go through some
of these examples mainly i'll use st for
status and you know see I for check-in
co for check out fix up is a cool little
alias where oftentimes you'll put
together a commit you'll commit it
you'll realize that you have one other
change that you forgot to add to that
commit you just want to make a quick
amendment fix up if you just add that
change to your index and you get fix up
it'll just it'll just shove that right
onto the last commit and and redo that
last commit with the same commit message
get log get l is a just a sort of
prettier shorter more terse log version
on you'll see that as i go through some
of these examples and then these are
just sort of aliases to sort of get flat
lists for files in different states if
you want to use some bash foo to like
you know maybe delete all the on-track
files or whatever i found those useful
get diff dash weird if it's pretty
useful by default diff will just show
you the difference between one line and
another line and this will allow you to
see the difference between words let me
just so actually I should back up I have
this sample applicable git repository
that's just a book with a bunch of text
in it I used text for a book just so
that there wasn't code in your face to
sort of distract you from the things
that I'm talking about so just a bunch
of texts as we're going through some of
these exercises so right now it's it
looks like this and it's got a little
bit of history in fact I'm gonna reset
it back to you
just going to put me back to where it
was before so we just got a couple of
commits for the like this simple small
bit repository so if I go through and
let's say we're editing this and we just
want to like make some small spelling
fixes let's just say we found a couple
of things we're making a few changes if
we do get diff we're going to see that
these full lines are changed we do get
diff dash dash word yeah you get this
nifty output where you see the smaller
changes and I found this to be in a code
context rarely useful but sometimes you
have some long lines and you want to
really dial down and see what the
smaller changes are so that can be cool
get add patch is like the probably the
most use in my workflow most use tip
that I'm going to have in here today
it's pretty cool most get beginners that
I see you know should kept those they'll
go through and they'll make some changes
to a bunch of different files and
they'll just say okay excuse me the
changes I made are good i'm just going
to get add everything and get everything
and then just like get check in whatever
or maybe they'll do like check in dash a
and just sort of you know make some
changes commit something make some
changes commit something what get add
patch lets you do is go through make a
bunch of changes and then pick apart
those changes and commit parts of the
overall chain different difference that
you have so we have these changes here
in these files and we're going to do get
add Dash P or you can do dash dash patch
and it's going to present you with each
change individually and it's going to
give you this prompt asking you to enter
in one of these things and so the main
ones that I'm going to talk about our Y
and n for basically yes and no stage
this hunk or not and then split is
also a useful one that I'll go over so
let's say we've got you know will say
yes to this change and no to this change
yes to this change if you look at our
status we're going to have the changes
we said yes to in our index ready to be
committed and the changes we said no to
not yep you do get ad patch if you just
hit enter it puts it at the top I don't
know if there's like a help or yeah that
looks like that works like a chore help
or ? seems to work the question was can
you stage hunks line by line so let me
show you an example of how you would do
that so let's go and say we want to like
we're going to change each one of these
three lines I don't think it's going to
let you do line by line with split but
one thing you could do let's say i
change this line and then a subsequent
like every other line I think if they're
not together you can hit split and it's
going to split them so as you can see it
first asked me this is it thinks this is
one change because they're close
together if you do split it's going to
say okay I know that you you you want
this one line so you can say yes no yes
no and you're going to get like that
every other line but apparent I think if
they're right butter up next to each
other if split doesn't want to break it
apart another cool thing that you can do
is when it's asking you whether you want
to stage this hunk you actually have the
option to edit the hunk and so there's a
difference now between like what's in
head and what's on the file system and
if you hit edit it's going to show you
that diff so this is the patch and you
can actually come in here and modify the
patch in this file save it close it and
that modified version of the patch is
what's going to get applied to your
index hopefully that's clear so when we
do get status again we have those
partial commits will there so I use that
every day I find it super useful
especially when I find it it allows me
to sort of get the the end it allows me
to do the individual task that I'm
planning on
you know I'm modifying something i'm
planning on doing something i'm planning
on putting this commit together and if I
pause or if I see some other part of the
code that i need to change I don't need
to worry about like remembering that I
could just make that change and then
when i go to add when i go do add patch
i can see that oh yeah i made this fix
that's unrelated i'm not going to stage
that hunk now i'm going to do it in a
separate commit so i feel like it helps
get get out of my way a little bit fixed
white space is a setting that you can
apply either globally as you see here or
per applicant / get repository and what
this will tell get to do is anytime get
takes a patch and applies it like you're
doing when you do get add patch if it
sees trailing whitespace it will ignore
that trailing whitespace and give you a
warning so I don't have this enable now
but if I enable this well here i'll i'll
do a white space example first show
these changes and so let's say I went to
the file and I made this change and I
also happened to put let's say leave it
all this and I also happen to put a
bunch of white space at the end of this
line so if we do a git diff you're going
to see that change with the white space
you if I were to do get add patch now
that white space is going to get
committed into my commit if I add this
setting and you do get add patch it
shows you the same output you say yes
and you'll see this warning here
trailing whitespace you'll also notice
that I now have a partial commit of that
line if you look at my at what is staged
you'll see get diff the cash cash cash
shows me what's in the modified staged
area and that's my change that I
intended and then the diff without it is
that white space so I don't like that I
work in Ruby I don't like to have white
space at the end of my file so I like to
turn this setting on so that if I
accidentally forget to like wipe all the
trailing whitespace of my editors I go
through i'll get this I've this last
catch-all so when you're in this
position you can either come in or not
but you can use the opposite of reset or
excuse me the opposite of AD patch which
is check out patch so add patch is going
to take changes from you're working from
your from your working files and add it
to the index to stage them for getting
committed and check out patch is going
to remove those changes from the files
actually going to modify the file so if
i do get check out dash p it's that same
interface except now yes stands for
discard this hunk from the working tree
and no means leave it there so yes means
i don't want this change i'm going to
destructively throw it away and so now
i'm left with just that just that thing
I intended to commit excuse me that make
sense great that's cool yeah absolutely
if you're definitely if you're
absolutely sure that you never ever ever
want to commit white space then you
could totally do a commit hook that
would strip that out for you should I go
through like a demo of like the
difference we can get pull and get
pulled dash rebase yes yeah okay great
cool I'm sorry ah yeah I know how to do
okay so you can so we've got our origin
master branch is that the same as where
our masters now so I'm just going to
reset hardback you're my mouse was back
to two commits ago so if we look at our
timeline and that's that alias I showed
earlier it just shows the long version
of the commits and it just includes all
the other branches so you'll see that
what we have checked out now oh sorry we
are on a topic branch that's secure
cool so let's get reset hard back to the
Shah so now you see that we are have
checked out master and we're two behind
what's on the remote server so if we
were to do get pull now get would see
that those two Shaw's are fast forward
abul and we just put those right on top
just generally what happens if we were
to find ourselves in a state where we
made some changes and we added those
changes and committed so here's our new
timeline we've now forked in a different
direction from where our origin server
is what's going to happen when we want
to pull down these changes is gets going
to do a merge of what was on origin
master and what we have and it's going
to create this new merge commit so this
is what we had what we made and this is
what was on our remote server and it
just merged them together and by default
that's what get does because I'm
assuming because merging is
non-destructive it's not going to
destroy your old year old Shaw's is just
going to give you a new one there's
another way to do this so I'm going to
reset back to where we were before I
polled so now we're back to where or if
we do get rebates or get pulled dash
dash rebase I'm gonna tell yet to do is
take off this commit then put these
commits on and then put this commit on
top of those so if we look at that we
now have a nice clean timeline where the
modification we made which was
previously on top of this committee has
been severed and now put on top of the
new history that we've pulled down
that's another like technique that that
some people use in some people don't if
you want to keep the if you want to
maintain the the fact that you had a
branch and you want to keep that
expressed in the history of your
application then you would you know
maybe you rebase maybe you don't but you
would use a merge some people like to
have their
topic branches REE based off of master
and then just stuck right on top so that
their history is just nice and straight
I I prefer that preference which is why
I have this as a tip in my talk is that
these are two configurations that you
can add to your personal setup that will
just tell get that when you do get pull
that it's going to do a rebase by
default just because you know oftentimes
you know when you're working with side
by side with a large team stuff's going
on master all the time maybe and so if
you're if you're pulling down all the
time what you're going to end up with is
you're going to end up with a line
that's just like merge to mass or merged
origin master merged origin master over
and over and over rather than seeing
just like a nice clean progression of an
order of which those commits came so
unfortunately you have to do this in two
stages get does not have a way that I
know of a setting that I know of to turn
this on globally it's a per branch basis
so maybe I should backup if people
aren't familiar with git config get
config is a command that is going to
modify one of those two files I spoke of
earlier so you're going to see your doc
yet / config file they basically have
these these sections and then it's just
sort of a variable name of value so if I
were to do this initial command here
sorry about that what this is saying is
saying get config and it's going to say
branch Dom master and then whatever I
want and the whatever the value is so if
I if I set that to true if I show this
file now that setting is there you can
actually just go edit this file and add
it yourself so whether you prefer
editing files or using the command line
both are available to you so again
rebase true is on a per branch basis and
so for every branch that you want get
pull to do rebase by default you're
gonna have to add this the only thing
that makes that nicer is this setting
that tells get when it makes a new
branch to automatically set up this
option for you so for any of your
pre-existing branches you're going to
have to go and do that command replacing
master with whatever their branch name
was and then if you
add auto setup rebase it'll do it for
any of the new branches if if this is
the kind of style of polling that you
like this I like a lot so by default
when you have made local changes to
branches and you have remote
repositories like github or whatever
when you say git push get is going to
look at all of your local branches and
all of your remote repositories find any
branches that have equivalent names or
any branches that have tracking to a
remote branch and it's going to push
them all so if you're working on a
specific branch you say get push you
might accidentally push if you don't
know that this is the default behavior
push changes from another branch that
maybe you're not ready to push so I like
to be a little safer and setting this
configuration variable basically says
when I say give push just do it for the
branch that I'm in only if tracking is
set up and it just it puts a little
safety barrier kind of in front you so I
like to have that setting this is
something i found that is like sped up
my frequency at which I rebase off of
master at the canonical way and the way
I always did it was you know you're on
your topic branch you want a rebase off
master to suck in that the changes of
the evolution of the app that you're
working on you check out master you get
pull and you check out your branch again
and then uribe soph master and this is
great when you want to make sure that
your local master branch is up to date
which usually you want if you're ready
to pull your topic branch into master
but if maybe you're in a longer-lived
branch and you just want to suck in the
changes you're not ready to push it to
master you can do this nice one liner
where this basically says sink myself to
my remote repositories get fetch which
is which is done by get pull so you're
saying like sink me to origin what's up
it doesn't do any emerging at all it
just pulls down the data that you don't
have from your remote repositories
updating your local origin master that
is kept at the same state as the as the
master branch on the origin server or
repositories me remote repository and
based and then you rebase off that
branch so you don't have to modify your
local copy of master if you
just want to do like excuse me if you
just want to do like a quick rebase off
of where your team's master is yes so
you would start here on the top of
branch yet potentially out of date
totally yeah this is this second command
here does not affect your master branch
at all the first the first example here
and the way most people do it is really
doing two local branches you're going to
another local branch called master
you're updating it and then you're
choosing so you're saying i want my
local master to look like origin master
and then you're saying i want to rebase
my topic branch off my local master I'm
I'm in some Kate in some cases find it
useful to sort of cut out the middleman
of my local master branch and just
straight rebase off origin master so if
that seems useful and you want to do
that a lot this this can help get blame
dash C is super cool allows you to blame
the editor of a line not the mover of a
line so often when you're refactoring or
whatever you find a need to like you
know you have a huge file you break it
out into three files you move some code
when you make that commit of the moving
of that code you are and then you blame
those files whoever moved the code is
now the the person who gets blamed for
having written that code I don't know
when you would ever want that generally
I think you want this option which tells
blame to ignore line moves and just go
back to the last time the lot that line
was modified and it'll show you the
original author so you can feel free
knowing that this is in your tool belt
to go move code around refactor things
and when people are going to be lame and
figure out who wrote that code they
won't come to you just because you moved
it this is an example workflow that I've
found useful in spiking out either
spiking new ideas or just you know
getting get again getting get out of the
way and just using you you know using it
to its full potential using it's like
really cheap branches and it's really
cheap committing abilities to
allow me to make quick edits and then go
back and use things like get ad patch to
sort of curate finalize polished commit
and basically how it usually how it
works I'll just get ourselves back to
where we were before cool so i will just
you know i'll make myself a branch and
let's say I'm just like I'm spiking
stuff out I'm just figuring things out
I'm going around the code base and I'm
I'm you know maybe adding some code and
let's say I go somewhere and I'm like oh
no this is terrible and I find something
here and I feel free to like fix the bug
right let's just say I found something
and I fixed it but nothing to do with
what i'm working on it's totally
unrelated but i'm still going around and
i'm i'm just doing whatever maybe i'm
running tests now I've gotten to a point
where like I'm still spiking up this
idea but my tests are green I'm thinking
about refactoring it and I just want to
I don't want to worry about polishing my
idea and I just want to save everything
so I'm just like gonna just check in a
whip commit and I'm going to keep going
i'm just going to like maybe refactor
some of the stuff that i did before and
just make a bunch of changes and i'm
going to just keep going and keep making
just these little save points I call
them whips because they're like work in
progress it doesn't matter what you call
them but I I just go through and I just
keep making commit and I found this
useful where if you're when you're
spiking things out that often times you
want to like save something that you're
about to change so you can go that was a
horrible idea and just roll it right
back without having to pause and like
name a commit like feet and like polish
things for other people I just do this
for like maybe at an hour at a time you
know I'll just go through and I'll just
have like a really sloppy tree where I'm
committing stuff that's uncommented that
I wouldn't have ever let anyone else see
and then when I'm done
I look at my log and I go okay I've
gotten this thing working its priests
all idea I'm ready to like tweeze it out
into these maybe two ideas or three
ideas that I've been working on so I
find in the last good commit and you get
reset not hard i just do get reset by
itself and what that does is it just
drops those commits but it leaves my
changes so now I'm left with like the
bulk of the things that I'm working on
for the last hour I'll then I'll just go
through and do get add patch and I'll
just do yes I want this one maybe this
is part of a thing and this is not this
is not and this is part of a thing and
you know oh that was that bug fix oh I'm
not going to commit that this was part
of it that wasn't right I'm just going
through and I'm tweeting this out and
I'll just put like you know idea one or
whatever that was and we'll go through
and we'll this was my second idea well
that was that bug this is my second idea
or whatever check that in and then the
last thing I have is that bug so I like
in check and a sham bug fix right so now
you see like this is my is my history so
right off the bat like maybe I'm just
spiking something out but that bug fix i
found that needs to go into master so
I'm going to just check out master real
quick and I'm going to just cherry-pick
this sha right here so now if we look at
my master branch I've just moved that
right onto master so now I check out my
topic branch again and if we look at the
timeline that give us a better idea so
here's where everything is so there's
origin master here's master it's got
that bug fix and then here's my my two
ideas plus that bug fix so what we can
do is we can just say git rebase master
and master is going to put or that
rebase going to put these three commits
on top of that commit and what you'll
notice is I don't have that bug fix
anymore
in my topic branch because the fact that
I've been rebased on top of that bug fix
means that having that same commit in my
topic branch now makes no difference and
so that commit just gets dropped so
that's that's an easy way to just going
through the motions you just changing
stuff you find a bug you make a commit
out of it and you just suck it right
into master so now I've got these like
two ideas maybe I make a couple more
commits of stuff that I'm working on
right and maybe I find something that is
really has something to do with idea one
right so this change that I just made
right here I'll sometimes commit things
with just squash and i'll put the shower
or maybe i'll just put the name like
idea one or whatever so now i've got
these for commits and so now I'll use my
favorite thing and get which is get a
rebase interactive it's probably the
coolest part about get basically what
rebased by itself will do is it'll take
a group of commits and it'll take their
base or the parent of that group and
it'll put it on a different pair in this
case we're going to be rebasing off the
same exact parent we're just going to be
using the interactive functionality to
make some modifications to that but
basically what gets going to be doing in
this command that I'm about to do is
it's going to take these four shots it's
going to sever them from this guy and
it's going to put this one on and then
this one it's going to put them on in
order and we're going to we're going to
make some changes to that so what you do
is you find the commits you want to
sever from you do get rebase dash I for
interactive and you give it that commit
and it's going to open a text file and
it's a little weird when you first see
it because it's in reverse order because
we have like our latest head at the top
and then in this file we ever had at the
bottom so that's what we're weird but
what it allows you to do is the
following commands is it allows you to
modify what it has here
and change this to something else so
let's say we wanted to move these so the
less intuitive thing is that you can
just reorder these commits however you
want so if I have something else maybe I
want that to go first and this I told I
put this I wanted to modify this
committee with that so I'm going to
squash these guys together so I can use
either oh my god where's my mouth I can
use either squash or fix up there pretty
much the same squash will take tooth and
it will just combine them together and
during the rebase process it'll pause
and it'll let you modify the commit
message if you just do fix up you're
just going to take the bottom commit
stick a nap next to it and it's going to
take this commit and it's kind of stick
it inside the commit above it so you
make modifications to this txt file
configuring how the rear a scan or if
you save it you close it and then get oh
oh that's funny I have a get conflict so
it's going to go through and it's going
to rebase these things it's going to
pause like it did here when you have a
conflict so i'm going to edit this file
not part of the plan and you can see
here that I just have a conflict of
which i will just resolve in some not so
interesting way and so you then add that
file and you say git rebase a stash
continue it what it's asking me for I
change the commit message I'm just going
to leave it the same I should not have
edited the same file a bunch
what'd you say yeah exactly far more
cartoon real cool so solve that so we
add that file once we've fixed it and
just continue and now if you look at our
log we've now reordered the commits
we've got something else first that idea
got squashed or that other commit got
squashed into idea one and we have idea
too so that's another tool in the tool
belt for just sort of like not worrying
about your commit history not worrying
about your commits in general just
committing stuff getting it out of the
way and then when you're ready to push
this up to some team members by pushing
it to the origin server or show it to
anyone you can reorder commits and would
change their commit message or do do
what you need to to to polish things
together it's worth noting that if you
do a rebase you should you can see back
here this was the our original log file
sorry there's so much scroll buffer you
can't really see what trust me that
these these Shaw's are now different it
is it is taken those original commits
and changed modified some of them so
they now have different shots so you've
you've done a semi destructive action
here in that your original commits are
now not connected here anymore and will
get cleaned up by gets garbage
collection so if you made this mistake
and you want to go back and you did a
rebase and you're like oh no I screwed
it up and I want to go back you can just
go back to get the shop where you were
before of your previous head and you can
just do get reset hard and now you're
back to where you were before so again I
think it uses burge excuse me merge by
default in a lot of cases because rebase
does destructive actions like this you
can't it's not always easy to get things
back if you don't write
what the Shahs were that you're worried
about losing you can go into things like
the ref log and get them back but when
you're using rebase it's it's helpful to
know that you should be you know keeping
copies of these Shahs if you if you
unsure and you want to get back to them
the rest of these are just some tips for
working with teams some of the stuff
that we use here that we found super
useful on that I've used at other
companies we do a lot of pairing and so
one of the tools that we use it's pretty
invaluable as hitch if you haven't heard
of it it utilizes one of the features of
get that by default in your global
configuration file you'll have your
author name and you're off their email
address and all of your commits get that
information you can overwrite that
temporarily by setting environment
variables and hitch utilizes that to
allow you to do things like you can see
in my ps1 here I've got me and you can
look at the logs and it's getting
committed as Jared and then it's
engineers plus Jared if I do hitch Jared
and Steve it'll say it's jared and Steve
and if I were to do a commit message it
would be committed as the pair that was
working on the task so if you work
somewhere where you do pairing it's a
nice way to like see that like these two
people are responsible for this change
or these three people or whatever PS one
was actually i'll show it to you it's
actually kind of greedy
so that thing I talked about earlier
that does the bash completion will
provide you with this little method that
you can use in your pretty shirt no i
don't know i will i can publish it with
these slides but basically it provides
you with a bash function that you can
put into your ps1 that every time it
gets set will export things like the
name of your branch so when you check
out master it's pretty easy to know what
branch are on at all times that's super
helpful to another thing that's cool
that i read about a Miss loves blog
which is a super interesting utilization
of the git config basically like we
talked about earlier get config will
write to these configuration files so if
we look at our dot get config file you
can actually write whatever you want to
this so if you write git config branch
mastered up foo bar and then you don't
pass bar it's going to give you back
whatever option use passed in and it's
just going to store it and get doesn't
use that but it's just available to you
so what this allows you to do is save
metadata about particular branches so if
we wanted to say that like on this topic
branch foo was bad let me say we're
going to get back you know when we if we
know the branch that we're on we can
actually query these configuration files
and get back metadata so what he's done
is a lot is come up with a way to where
if you this is for in a rails context in
your database the animal you just had
some code here that gets you excuse me
get your current branch name and then
looks in your configuration file using
that a current branch to figure out if
you've set this option to true if you
have it modifies the database name so
why this is useful it's really cool why
this is useful is if you if you check
out a topic branch and you're heavily
modifying a schema and you need to go
back to another branch that has a
significantly different schema it takes
time to scheme a load and maybe
repopulate your database so what you can
do is you check out your topic branch
you set this configuration and then you
recreate your database and now when you
switch branches it just seamlessly jumps
from one database to another no it's
it's actually not stored in in gets save
everything at all it's just written
directly into this file this is not
version controlled not yep so if you
were to clone this somewhere else you
would not have the same right so it's
actually cool to if you take this
concept you can explode it out to you
know if you're using other data stores
or any other configurations or even
outside of a rails contacts you can do
some pretty nifty stuff with these per
branch variables that's it if you want
this is if you want some even more
advanced get tips i recommend another
scotch cone talk where he goes into some
crazy stuff that you can do with get
some super advanced crazy weird things
that are pretty interesting and a fun
watch i highly recommend it the question
was do I have a particular workflow I
guess any tips for a workflow of when
I'm forking another person's project and
changing it and then doing a pull
request yeah and also like some of them
might never actually make it into the
main brand main fork so like how do you
manage that I mean I guess I mean there
if if it's never going to get taken and
i plan on maintaining my own Fork i mean
other than just branching it on github
and and maintaining my own my own copy
of that I don't have anything that I
think is unique in in that if you have a
more specific question I can draw I just
know
diverging right completely and may be
harder for you to merge the new changes
of that right in so right I mean one
thing that you can do is you can add the
other so if you four get on get up
you've got your own copy maybe your your
origin and your local check out is your
copy on github you can add another
remote as the original project so five
fork jQuery I can have I can have my own
copy and so origin is my copy and then
maybe I remote like you know you know
upstream or whatever right and so now i
can do like get pull origin master or
git rebase upstream master and so now I
have these two different like remote
repositories which are just sets of
branches that I can rebase from and
merge two and and manage that
relationship that way so what he just
said was if he Forks a project he will
make a branch where he's making all his
crazy changes and then he will make
another branch will he'll check out the
reasonable things that he wants to get
pulled or wants to put into a pull
request sends on github pull requests or
per branch he'll make that he'll curate
that branch that he's preparing as a
pull request and keep his maybe some
other crazier stuff in his personal
branch that is a very good point what he
said is it's important to note that
since git rebase interactive or just
rebase in general is is potentially
going to take commits and change their
parent and therefore change the Shah of
that commit if you're on master and
you've pushed already and those shaw's
exist on master you can't modify those
and push those because just by practice
everyone has agreed that the master
branch doesn't get modified so if you
pushed it up it's there to stay and so
you need to be careful of how you rebase
the example I gave didn't violate that
but I could see how be easy to do that
yeah sorry he asked have you ever
thought about using pre-commit hooks to
run your tests I've never worked on a
project I never but most the time I
working on a project where the test
suite takes long enough to where if I
hit commit I don't want to wait that
even even it was 40 seconds you know I
wouldn't want to wait that amount of
time just to just to make sure the
commit was there I feel like commits are
commit should be light and mutable and
and and just a tool that you can use as
often as possible
I you could probably do a quick you
could definitely do a pre push hook
running it that's not a bad idea at all
actually yeah all right well thanks very
much guys
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>