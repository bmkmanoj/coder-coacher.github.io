<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Why You Should be Using Web Components Right Now. And How - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Why You Should be Using Web Components Right Now. And How - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Why You Should be Using Web Components Right Now. And How - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-08-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AvgS938i34s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody do we all enjoy the ice cream
yeah I'm enjoying my whiskey I didn't
come from Scotland so so yeah thank you
for coming
this talk is on as you can see why you
should be using web components now on
how I've been a bit cheeky with the
title you'll you'll work out why later
on I work for a company called pusher
out of interest to sort of pusher a few
people okay I'm going to say 25% cuz
this is recorded so it's going to sound
better
so I mean they flow me out here I you
know say pushes a hosted service helps
you integrate real-time data into web
mobile and IOT applications basically a
real time layer that sits between your
back ends at PHP Java whatever back-end
you've got and the client whatever the
client is before I work for push it well
I've actually worked for push it twice I
rejoined them again in December I had a
year and about and I worked on a
framework and toolkit called Blade
Runner Jess and it was all quite new to
me but I've worked for the company
coupling systems beforehand and when I
went and joined them I did did so
through kind of faith that they knew
what they were doing rather than really
understanding what this blade and Jess
toolkit did so I spent a year and a half
kind of learning around the concepts
around building large single page
front-end applications and what it
fundamentally came down to was building
modular front ends building component
based front ends you like the one here
that I knew they were going to put that
video in there so I kind of growl that
the you cannot asaurus so I was quite
pleased from that one and that's where
my kind of that my love for web
components came from I understood the
benefits of building these modular front
ends so I wanted to focus on so when I
found out about web components so kind
of a Nokia but that's exactly what I've
been talking about except natively
supported in the browser so I'm gonna
cover four different things I need to
cover what web components are now I
don't who's here already knows what web
components are and they're gonna be kind
of dozing off right a few people sorry I
mean I've got to cover that because
there are people here that won't know
what web components are but I want to
show the fundamentals I want to talk
about the state of web components talk
about componentize web apps and
that means and then how that feeds into
making web components the future of a
front-end development as I kind of said
anyone anyone it's it's a little bit dry
you know what I web components I'm just
going to tell you what they aren't I'm
going to show you how to use them I've
seen lots of really good talks on web
components that show that make people
turn down the lights and it uses the
camera detects that the change in light
and flashes the screen and that's
awesome but funda it's not showing you
fundamentally how to use web components
so I'm going to show you the
fundamentals with a very simple example
most people know web components are
custom elements HTML templates shadow
DOM and HTML imports firstly custom
elements HTML you know we probably all
learned HTML through going to a web site
viewing the source understanding what
happened following links through looking
at javascript looking at CSS and we've
lost that now you know we still get the
occasional web page that has real
semantic meaning and we can just look at
the source and understand how it works
but the common example that you'll see
Eric bidelman who's been working on the
web components team at Google uses this
example anybody that talks about web
components uses this example is that in
applications we have div soup we can't
look at that source and understand
what's happening in the application
there's no meaning to that structure
anymore in the HTML so custom elements
have the potential of going away to to
help us bring back that meaning to our
markup they're also more than just
markup and I'll explain why and and I
think they're fundamentally know the
core of web components so it might be
now this is probably a bit controversial
it might be that a new Gmail would look
something like this we've got our head
we've got our body we've got a header
now because with html5 elements as well
and we actually have custom elements
that define specific pieces of
functionality for our application so
Gmail search to you mail account strip
now there are there are arguments for
and against this and I don't have time
to cover that today there might be a
Gmail sidebar with a navigation element
which is odd which are our Gmail labels
the ability to filter the actual emails
that we're saying we've got contacts
well you've got a main which is
obviously the main section in Gmail
maybe there's enough in there which is
our categories you know the filters that
Google provides at the top level around
and promotions and so on and then our
Gmail list and then we might have a
standalone hangouts element now as I
said that's kind of probably way too far
to making custom elements beasts you
know you might as well just have my app
there are arguments for and against that
so I have given a talk specifically on
that at web components London and
Mozilla about a month ago so if you're
interested in what should be a web
component and the pros and cons of
approaching that in different ways then
please look at that talk so I'm going to
dig into just simple custom elements so
I'm going to look at an avatar which is
a really really simple example here I've
just got images I'm using avatars to i/o
for a bunch of different things I've
actually have an Instagram avatar and
down the bottom I've got a Skype URL so
you know a loads of different ways of
bringing in an avatar so let's build
that in custom elements be nice if I
could do that my avatar identify the
service this case Twitter the username
leggett err so to do that I take the
HTML prototype and create my own
prototype from that I'm just finding an
object this is we're diving straight
into JavaScript to define our custom
element there are a bunch of life cycle
callbacks in custom elements and I'll
mention those in a bit but the created
callback is when obviously that element
is actually created so I'm referring to
this and this in this case is the
element itself so it's the my avatar
element so I can do this knockout should
be user name which gets me leggett ER
and this don't get attribute Twitter is
very service which gets me Twitter I can
build my URL after i/o slash service
slash user name I'm going to create an
image element I'm going to set the
source attribute so I'm going to use the
image element and fetch that that image
and I'm going to append it to this which
is the custom element itself which is
the my avatar you need to also register
element with a document so I'm saying
register element my avatar and the
prototype is the object I've just
constructed and then I can use it so
really simply I've got my avatar service
Twitter
leggett ER Instagram leggett ER and
Twitter and for Jess so I'm straightaway
using this custom element so it's a
really simple example but it gives you
an idea of the sort of things you can do
you can also extend existing elements so
in this case I'm I'm taking the image
and inheriting all the functionality
that air provides already I'm saying it
is a my avatar EXO a new type of custom
element I've defined putting two
properties on it again to define it I'm
actually taking the HTML image element
prototype created callback I'm getting
the user naming it in the service I'm
building the URL and I'm using this
which is now an image setting the source
and setting the URL so I'm already I'm
getting that functionality that the
image provides already registering it I
need to say that the prototype is the
object I've created again and I need to
say that I'm extending the image tag
well the good thing here is that we can
we can extend existing functionality
that's natively support in the browser
the main benefits around this around
accessibility although unfortunately
there's a bunch of concerns around that
I'm not gonna have time to go into to
detail but I'm going to highlight it
that there's some questions around this
idea of extending and how you do it
the lifecycle events are created when
the element is created attached when
it's actually added to the dom detached
obviously when it's removed from the dom
and out to be changed so right look at
my inspect element can people see that
all right
so here if I change the username to
forwards Jess nothing happens so this is
just a my avatar text however down here
another one which is a my avatar changer
and then now if I go forward je s I've
got a callback that's registered
internally you'll see the URLs change as
well and I can just write code that
changes that URL so that's exactly what
actually changes do it's really simple
because these are custom elements
natively supported by the browser we can
do everything that we can do with
elements that natively live in the
browser that aren't custom elements so I
can use JavaScript to create elements
too so in this case I'm going to create
too many fills which is 104 I want it to
do a do-while loop just cuz I never get
to do them and I'm going to create these
my avatar elements set the attributes up
into the Dom again really simple pretty
boring anybody anybody this is a slide
as well from Eric bidelman talk from
Google i/o 2014 and he highlights the
benefits of this so the browser
understands custom elements it
understands elements so we get all the
benefits of that we can use all the
existing functionality that the Dom
offers on these elements and we also get
that the the performance benefits the
optimizations that the browser
understands how these elements are
formed how they're rendered and how
they're structured Eric pointed out that
you get interoperability so the base
level of the browser now will be web
components so you can take a web
component that you define and use in
angular and take it away and use it an
ember and take it away and use it in
react so we've got a different level
base level and we can reuse these
elements across different frank
frameworks or libraries accessibility is
something that where is generally hoped
to be something that we'll get from this
if we're extending existing elements we
should be able to access some of this
accessibility in benefit from some this
accessibility that's supported because
the browser understands these elements
there are some concerns around this
right now
and developer tools you've seen already
that I can start messing around with the
elements that I'm defining so because
the browser again understands how these
elements are structured we can use our
developer tools straightaway on them we
don't need this specific extension or or
add-on to start developing and debugging
what's going on with our elements
template so don't need to spend much
time on this who uses some sort of XML
template library come on everybody
everybody okay so that there's loes to
choose from so it kind of makes sense
that we you know jQuery had the ability
to query the Dom based on CSS so the
things that we do commonly we hopefully
you know w3c lists and the browser
vendors listen and they move to be
natively supported so it makes absolute
sense that the HTML templates move to be
natively supported there's a bunch of
things around the string manipulation
inefficiency cross-site scripting
injection and all sorts of problems that
can be seen if it's not natively
supported so that will let the browser
deal with that now so we've now got a
template element we can chuck whatever
we want in it and any any valid HTML
with a few caveats and then to use them
within our web components or custom
elements we can get access to that in
this case something but an idea of my
avatar template we access the content
property on it so that one of the
benefits with templates as well is that
there inert which means they'd actually
affect the document until they're
actually added to it properly that just
the template element on its own doesn't
affect the Dom it's not going to affect
that it's not gonna be rendered to the
screen not only not until you've cloned
it and actually imported it into the Dom
does it have any effect on the document
model so we've got this content we then
need to import it into the actual
document true means I'm going to deep
clone I'm going to make sure that I'm
copying all that all the contents all
the nested elements as well this gives
me the elephant element not the elephant
the element that's created and then I
can dive into that select elements set
attributes set text context and then
append it to this which is the custom
which is the actual custom element so
here's an yet you can tell I'm pretty
awesome at design
this is what's created so you'll see
I've got my avatar and all this content
is chucked in the middle now we register
it in the same way so we're doing these
in libraries anyway it makes sense to
move it to native we're getting old
again as with custom elements because
it's templates because it's native
supported we get all that benefits it's
lightweight document fragment when we
when we clone it we're not getting all
the stuff that comes with the document
just the document fragment and as I said
it's inert until it's actually cloned or
used shadow Dom now shadow Dom is
probably the one main sticking point
that the browser vendors are discussing
and going forward about that the idea is
to provide a level of scoping so that
we're not so that we have some
encapsulation within our custom element
that gives a level of protection to both
the page and the element
I'll go into some more detail on that
most people again have seen this example
we've already got the shadow Dom you
probably need to turn this on and dev
tools but you'll see video shadow root
div soup so the shadow Dom already
exists and the browser's already using
it so it makes sense for them to expose
this sort of functionality worse it's
the same problem with accessibility
actually at the minute that the browser
has provides a bunch of accessibility
functionality that the browser vendors
can use but we can't quite use that yet
but the shadow DOM is being exposed to
us to use now so you'll see here that
I've got a span element where the
classic container now I brought in the
element previously which had a also had
a defined style of container that time
gold this new one that I'm about to
create has a container style with the
background of cyan so if I bring that in
unfortunately the style element gets
added to the page and it bleeds up into
the page itself and overrides any
existing styles that exists existing
styles that were all even defined
elsewhere in in a stylesheet or so on so
the shadow Dom should solve that problem
it'll make sure that when we add that we
add some add some HTML to the shadow Dom
it won't bleed out into the page
so it also provides that level of
scoping so we know where they can only
use have one ID a unique ID you must be
unique within a page now an ID within
that document so now an ID must be
unique within that shadow Dom itself so
if you define if you have quite a nice
small component and you've got a
template in there you can actually use
IDs to uniquely identify elements and
you can start to use IDs again get up
get on them by ID so that's it's quite
nice that offers that sort of
functionality so to use it again I'm
having my template here I'm gonna create
a new my avatar shadow prototype I'm
gonna grab the the content which is the
the template again and this time I'm
going to use this doc create two shadow
root so that creates a shadow object and
then I'm going to import the template
into the shadow root and then I can
query the shadow root and then set the
attributes as I did previously so if I
actually create an instance of this and
inspect this we'll see that I've got my
avatar shadow I've got a shadow root and
then the content in there and I've got a
background color of red now if I go back
some slides it hasn't bled through to
these existing ones which is good news
okay so we're getting that DOM and CSS
scoping the page can't bleed in to the
shadow Dom you can't you know that if
you define the same style and use it in
your shadow in a template that you're
after the shadow Dom it won't bleed
through so you won't override any styles
and you get natural encapsulation in the
same way as the shadow Dom doesn't bleed
out HTML imports again they're some
questions over this the idea is simple
loading in dependency management a lot
of the stuff here I one of the reasons I
like is I'm not that clever but I
understand web components and I
understand the benefits of them and they
still imports for me or quite a simple
concept but quite powerful again I think
this is the example that a vital and
gave again this is bootstrap before we
include style sheets we include
JavaScript or jQuery dependency a bunch
of other bootstrap specific JavaScript
files and afterwards we simply import
bootstrap HTML which deal
with all the importing of all these
dependencies so a simple example of this
taking the idea that we've defined
avatars is that we can actually compose
other elements out of existing custom
elements so I can create team pusher I
can import my my avatar that I've been
using previously I can define a template
use that that avatar custom element and
identify all the people that work for
pusher I can then register it with the
Dom and then to use it I simply import
it add that tag to the page and they get
the resulting composed custom element
well an element compose from from
another custom element again quite
simple concept and it kind of makes
sense so we're bundling we're getting
the value of that we're getting some
form of dependency management very
simple and it's promoting sharing reuse
and obviously that idea of composition
there are a few gotchas just things I
want people people to be aware of as I
dug into this when you when when the
HTML input is included you need to wrap
that content in a closure and pass in
document current script then grab hold
of this owner document so that you're
referencing that HTML that you've
imported because later on if you make
calls from the page like make a call
into a function you define in your
custom element then the document will
refer to the page rather than the actual
HTML import so that's just something to
kind of be aware that almost this
current script thing that Phil mentioned
the other thing is when I went through
this initially I was using clone node to
bring in the template content into the
document and for some reason it broke so
again this is likely just a gotcha I
don't really understand why that
happened so I ended up having to change
all my examples to use import mode
something else that I thought would
would have been supported is it within
template so I wanted to use other style
sheets so I linked in some of the style
sheets and I got this area which says
HTML element link is ignored in shadow
truth
I didn't try script so again something
else to just be aware of so that's the
the four constituents of web components
so what's the current state of things so
I mentioned I kind of briefly mentioned
these as I went over them so this idea
of is there are concerns around
accessibility so that might go away at
some point it's been referred to a wart
on the custom element spec the point on
which the custom element is actually
upgraded from just being a dumb piece of
markup to actually be in the shiny
custom element is different with custom
Ehlert's than it is with natively
supported elements so with natively
supported elements say select to say
input it's actually rendered a pass time
with custom elements it's kind of
ignored on the first pass on the second
pass it's upgraded and there are some
concerns around this and the Christian
in his talk earlier mentioned about
moving to es6 that was part of the deal
of solving this so the point which I
don't know as a developer whether it
necessarily matters to us although there
may be some timing issues to be aware of
again thinking about that point of
upgrade and custom elements might change
templates we're all good that's one
thing shadow Dom there's a whole bunch
of things you can define your custom
element and you can define your own
content you know it's just an XML
element so you can put content in there
now where that content goes in the
rendered custom element needs to in some
way be configurable so the idea was that
you could within your say template
definition that was used within your
custom element you could select say
someone put a span in the middle of your
custom element you could use this syntax
to select wall if someone puts a span in
there it should go here when I build my
actual custom element up there are some
questions around how that's going to
work so that's ongoing I think Apple
specifically are pushing for being able
to make the shadow route inaccessible so
that you can create it but then as a
developer you can't dive in and hack the
contents about yeah they were protecting
a custom element that's maybe been
provided by a third party so create
shadow root will likely at some point
an argument passing there's also ways of
you can style the contents of custom
element shadow piercing combinators CSS
properties and again there are some
questions around how that should be done
whether it should be just CSS properties
so you as you define your custom element
you say you can override these things in
CSS but you can't ever have anything
else at the minute it's a free-for-all
you can just use these shadow piercing
so that might change as well
HTML imports Firefox I'm going to do it
right now they're thinking that
JavaScript module loading is potentially
going to be might solve this problem
again christian mentioned that earlier
it could be right and it could be that
we have to wait for es6
i really hope not because obviously i
want people to be somewhere for the
finance now two pieces of essential
reading for this Wasson page for Mozilla
about something on the state web
components and the Microsoft edge team
did a couple of blog post recently I'm
going to this in a lot of detail as well
so I'd recommend you look at those state
of browsers again Microsoft are pushing
the web forward they are developing
template the rest of them although it's
is under consideration here it is
actually on the backlog on their user
voice forum so they are looking at these
things in proper detail now and also
they're involved in the discussions
apple we generally don't know what
they're doing but if you dig deep enough
you can find that they are actually
contributing so this is they're talking
about custom elements they're talking
about shadow dom they're actually the
ones that wanted you know they're very
keen in this idea of open closed shadow
dom and which did it fault so what's the
state of things I think I've got
unfortunately we know the chrome you
know Google are pushing this forward so
chrome uses blink opera uses blink so
we're good there Android browser and
chrome we're good there
but for IE and edge Firefox Safari we're
sitting at 25% or 0 in some cases as per
usual
we rely on polyfills for this sort of
thing
there are questions over whether you
should be using polyfills or not or
whether you should be doing feature
detection or or progressive enhancement
out of interest who can who can say that
they will develop something and it will
only work in say IE 10 okay nobody
so polyfills money might not even be an
option for you but this is where the
next bit comes in componentized Web Apps
now again referring to Christian he
wrote a few blog posts recently one
saying that web components were on the
edge of extinction and I don't know that
this was part of it it might have been a
slightly separate one but I said what
when when we asked a very captive and
early audience at Edge confer about web
components and nobody raised their hand
that they're using them in real products
is anybody here using web components by
the polyfill in a real product
nobody he's got a point
um but does that mean we shouldn't be
thinking about building componentized
Web Apps now I don't believe so and we
should be building them anyway and I
would hopefully I'm gonna prove that
we're doing that already and we're doing
that already because we're using
javascript libraries and frameworks so
angular include angular defining an NG
avatar so we're gonna create we're going
to create a directive called ng Avatar
we're gonna say you can instantiate this
this directive via an attribute via an
element or via a class we're going to
say that we've got two attributes on it
you service a Newser name I'm gonna
define a template with an image which
uses avatars the io / service and user
name that angular deals with the binding
of those values and then going to add it
to the Dom all looks familiar doesn't it
let's have a quick look at that
okay ng avatar and there's an image in
there looks familiar
amber jeaious who uses amber yes okay a
few people this mgs1 include a bunch of
stuff I'm going to create an e/m avatar
component by extending envelope
component I'm saying there's a URL
function that builds up the URL avatars
that I add this this get service and
username and I'm saying about two
properties username and service by
convention I have a template which is
named component slash avatar which
builds a an image which binds the
attribute source to URL and then I use
it by defining a another handlebar
template that is actually the app I do
have an example about working from I
couldn't get it working in the slides
react I'm actually gonna do my
transformation in in the browser I'm
gonna define a class so I'm gonna say
render I'm gonna build an image avatars
do this not props top service dis the
props that user name I'm gonna have an
re avatar now I've actually hard-coded
these there would have been a nice way
of doing this but I'm saying re avatar
so it was Twitter user named Ligget ER
and I'm cheating a bit here I got this
re avatar I should be ready to be kept
grabbing the the attributes from that
this okay i reaiiy Betar there's no
shadow down there so it's not using web
components a few people think they're
using specifically web components when
they use react and not you know anybody
use polymer okay a few people so there
this looks like the sort of diagram that
I would create but this is hex Leon this
sets the on polymer 1.0 documentation so
the idea of polymer is that that's
saying the baseline of building
functionality for the web now is web
components web components will exist
within the browser polymer is a library
on top of web components and it uses
custom elements let's see how we use
that we have to include the poly field
right now we include the polymer we
include polymer by vera national import
we define a polymer element with the
name of peer avatar we said we've got
two attributes service
user name we build an image we have
service and username that again polymer
deals with the binding of those values
as they change we register the PR avatar
when we use it and this is the output
and the difference here is it's in a
shadow root this is a real web component
so could ask those that use angular
directives and apps to put the hands up
please and please be honest I want to
see how many people okay
keep your hands up who uses ember
components keep your hands up those that
use angular right who uses reacts ever
keep their keep your hands up still
knock out components vue.js components
backbone components can't yes famous ok
any that's it I'm gonna say that 25 to
30% of the room are using components in
their apps so if you're using components
in your applications then you're already
building componentized web apps and if
you look at the way that that we built
those components in that way they very
much aligned themselves with web
components now whether that's
coincidence or whether they've been
speaking you know the browser vendors
and the library vendors have been
speaking and ultimately that's how we
need to align ourselves to using web
components now and in the future we need
to think about building componentized
web applications and continue to do that
and eventually we will be using web
components and that's where it compute
ponens in the future I you know as I
said 30% isn't bad I think you know some
people are shy so I'm gonna say 50 for
the record so the trend is the library
usage is aligning with with web
components anyway
if you look at the AMPA documentation
they say embers implementation of
components users closely to the web
component specification as possible once
custom elements are widely available in
browsers you should be able to easily
migrate your ember components to the w3c
standard and have them
used by other frameworks so that's
actually specifically what ember is
aligning itself with if you look at
angular 2 you start by defining a
component now whether or not it will
render a web component under the hood I
don't know maybe it will if the browser
supports it it won't if the browser
doesn't interestingly here
it's my app so even app is a component
so you really need to have a strategy
you need to you need to understand
whether the library is going to deal
with migrating to using web components
and getting all the benefits of native
browser support with that or you need to
have your own strategy about making sure
you've got a way of migrating at least
that Dom layer to using web components
so a good example of that is splitting
out your UI rendering logic with your
business logic because then you can
ditch your library based rendering logic
keep your business logic and just change
to using web components rather than
whatever library you're using again
talking about trends all the browser
vendors are on board with this at least
working together to trying to find this
and fix things demand so this is the
Microsoft edge developer user voice
forum obviously auto updating ie would
be nice but position two shadow Dom
position three custom elements position
four temper elements position five HTML
imports so people want you know
developers want web components and I
would argue based on my experience
previously in that the time I spent on
the Blade Runner jairs team is that it
aligns itself with component base
development which which is a good
software engineering development
practice whether it's from server based
development or client based development
this is a bit woolly but you're getting
natural separation concerns it depends
on how you build your components what is
your component but if you take this
approach where you've gone with Gmail
search accounts through each of those
custom elements does its own thing focus
on it on its one thing we're separating
out functional concerns you could say
that you can you know if you look at
separation concerns and Wikipedia it
talks about CSS for presentation HTML
for content and JavaScript for behavior
that depends on how you structure your
applications but obviously you can still
do that with with web components - we're
getting natural encapsulation so we know
the benefits of software developers of
encapsulation shadow Dom naturally
supports that it doesn't offer
JavaScript protection so at the minute
JavaScript can reach out of an element
and mess with your page in some ways
iframe is probably right now better for
that so if you need that sort of
functionality you can look I've frames
but this talk in version 2 of web
components just to offer that level of
JavaScript protection - I'm not going to
do that demo there are benefits of loose
coupling as well now again you're not
absolutely forced to do this but we've
got custom events and we've got the
element has an API it has the standard
Dom API in any API that you want to
define on it so as a developer you
interact with that API you bind to
events on that on that element you don't
dive in and start hacking around with
the internal code or you could use an
existing framework so that the idea of
the services layering things like
angular and ember or a separate services
layer it's still very relevant and might
still be the nice way of approaching
that with web components I've got six
minutes so I probably will show this so
I mean most people have seen the ability
to I'm registering for a click event
here when I get a click event I'm going
to create custom elephant elephant
custom event a cheese event I don't know
why and and then I'm going to dispatch
that event and here I'm actually
registering for the cheese event on my
element I don't know again why I would
want to do that
that cheese so we've now got this you
know loose coupling through events in
the DOM
with its custom elements we can also
define functions so I can call get
access to my this element and then the
call starts pin stops pin so it's the
stuff I didn't okay so we've got that
again we've been building this sort of
stuff we do that with library components
anyway so as long as we've got that
level of abstraction right whether it's
a web component and they did web
component whether it's a library
component it doesn't matter and actually
supports change this idea that we can
migrate different pieces of our
application over time as long as that
API the surface area stays the same we
can change the underlying implementation
encapsulation they lose a couple thing
help that sort of thing
it's obviously encourages we use that
I've already mentioned its ease of
sharing and Composition something else
that as you start to scale and build a
large application you'll see the benefit
of is that you have high cohesion you
have functional occasion you have your
your HTML you have JavaScript you have
CSS you have your images you have any
assets relate related to a single
component on disk together there's a lot
of benefit to that there's still a bunch
of problems we don't know what's gonna
happen with HTML imports at the moment
if we're using HTTP basic eighths to be
at the minute I use db2 then if you've
got an excel in port and it's including
loads of assets and you're making laser
Network requests but HTTP two will solve
that until then there's something called
vulcanize which will deal with
concatenation will JavaScript modules
help
what happens if multiple components want
to share the same script jQuery are they
all going to use jQuery are they gonna
use different versions how do we deal
with that I mentioned that JavaScript
can can kind of reach out and reach in
right now at the minute in terms of web
components but version two will deal
that how should promote components
communicate with each other you know you
can still write a component that feels
like it's it's own thing but if you
write code that reaches out and grabs
hold and relies on another element being
in the page and you've broken you know
you've broken that nice independence
that encapsulation that separation of
concerns so maybe there needs to be a
way to a defined way of supporting cross
compound communication or maybe we just
leave that to the developer I think
you've got to be able to import certain
resources into the shadow DOM as well so
in summary
I you know I really understand custom
elements I understand the benefits of it
I think they're really easy to use but
also very powerful I've spoke about the
benefits of natively supporting this
sort of functionality in in the browser
we get all the benefits that the browser
offers and that's why we eventually once
we know that it's something that we're
all going to use we push it into the
browser we also have standards so we
have a standard way of doing something
so no matter who comes along if you
follow a standard we all understand how
that piece of functionality works and
how to create a new one or how to
maintain an existing on 30 50 percent of
you are already building componentized
web apps so it's aligning with the
future anyway and the trends hopefully
and best practice definitely aligns
itself with web components there have
been two attempts to do componentized
web apps already Microsoft had an
attempt back I don't know ages ago but
the i-5 it's probably been removed in in
Microsoft edge and it was xbl to in
Mozilla so we've we've tried to do this
sort of stuff already but they just
haven't taken on now everyone's come
together and created this standard and I
do you think web components in the
future loads of resources to go and have
a look at I'll share these slides
afterwards and it's definitely that
there was a decrease in interest in web
components for a while
but it's really put picked up again and
recently so I've got two minutes for
questions if anyone's got any questions
yeah okay so the question is is there
going to be any benefit from defining
custom elements in this way that the
browser will ultimately understand to be
able to optimize I don't know but the
idea that you move towards using web
components that the browser natively
understands means that the browser the
browser vendors know that elements are
built in certain ways so they can
optimize for that sort of thing so I
should certainly hope so and you think
well maybe you can ask a Christian
upstairs and on the IE booth because
he'll hopefully know any other questions
okay yeah yep
okay so the question is whether or not
there's any problems in terms of
importing XML importing like references
to scripts prototyping things timing
issues basically right is that the
question around timing issues okay oh I
mean definitely there are timing
concerns and that's one of the things
that's ongoing at the minute in terms of
discussions when things are constructed
whether things exist yet definitely
around asynchronous includes I think
HTML imports includes things
asynchronously obviously one of the
concerns because it's slowing the page
down I think that many of your minutes
but there are a bunch of things that
there's a podcast that I've referred to
in the resources Wilson page was on it
Christian Holman was on it a bunch of
other guys were on it around discussion
of specifically timing issues
asynchronous loading and so on that's
time thank you very much for coming
there's some t-shirts here push your
t-shirts some stickers so thank you very
much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>