<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What the... JavaScript? | Coder Coacher - Coaching Coders</title><meta content="What the... JavaScript? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What the... JavaScript?</b></h2><h5 class="post__date">2015-03-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2pL28CcEijU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk I appreciate
everyone being here
I am honored to be here at the second
forward and had a great time with the
first one so I'm looking forward to this
one as well there's been some great
talks already today yeah this is just a
quick reminder that oftentimes when we
when we have code you know I'm sure many
of you probably have had code that broke
and you weren't sure why it broke but I
think the more profound and more
difficult problem is when code works and
you're not sure why it works
so definitely understanding code is
important terms like readability get
thrown around an awful lot in our
industry people say well it's got fewer
characters therefore it must be more
readable I'm not entirely sure I agree
with that premise actually I have read
some some PhD thesis papers on the topic
of readability and I'm not really sure
it's quite as simple as just fewer
characters but today we're going to jump
in with the talk that I call what the
JavaScript this is kind of a
self-indulgent talk to have some fun
over the last couple of years now I've
been working on a series of books about
JavaScript and I'll get to that in just
a moment
but I've pulled out an awful lot of
crazy out of JavaScript collected along
the way and I hear an awful lot of
people talk about WTF s in the language
there's even a whole website dedicated
to it
there's many famous videos like the web
video and so forth
most of the time when I watch those
videos I'm struck with that doesn't
really seem like a WTF to me but perhaps
my perspective is skewed because I've
seen the real what - what the fuck's in
JavaScript and so I'm going to ask for
some audience participation as we go
through the corners of the language that
I've pulled out for you today we'll
start mild but it's going to get really
crazy towards the middle in the end and
I'm going to ask for audience
participation if you feel so inclined
each time I show one of these WTF just
yell out what the because that will
be much more fun for the rest of us I'd
rather not sit up here and curse the
whole time but you guys can curse all
you like and you can of course
substitute your favorite f-word if you
don't like that word flugelhorn
Fahrenheit whichever works for you all
right real quickly about myself my name
is Kyle Simpson and I'm known as getify
online I do a lot of open-source
development this is my current streak as
of today
to show off that I am obsessed with
open-source but to help inspire people
to do a little bit more with open-source
and I took it upon myself a little over
a year ago to try to have the discipline
to do something even if that something
is filing above against myself for
something to do the next day to do
something to help the open-source
community so I encourage more of you to
do that I mentioned that I've been
writing a series of books it's called
you don't know J s if you go to that
website it redirects the URL up online
on github they're all open and free you
can read them there are six books in the
series I'm working on the sixth of the
six books the other five are already
done and they're also being published
through a Riley so you can buy them
through O'Reilly or other book resources
basically these books are kind of the
anti the good parts and I don't mean
that like they're the bad parts I mean
that they're all the parts really trying
to go into all the parts of the language
that are oftentimes not covered so it's
kind of an unconventional take on
JavaScript and you might check those out
if that's interesting all right don't
any further ado let's jump in and I will
say definitely with the books and
especially with my teaching and my
speaking I often times find myself in
the position of defending the language
many people are very good at
articulating why they don't like
JavaScript there aren't as many voices
that stand up and defend why the
language is great and I often times find
myself in that unconventional position
so today is kind of a flip flop because
I am both the defender of the language
and I'm also today going to put on the
Hat of a hater of the language so let's
define what I mean by WTFs they're not
just things that are funny certainly
there's lots of funny things about
JavaScript that we can make fun of like
type of Nan type of not a number as a
number and other weird things like that
but I'm not talking about those WTFs
today I'm not just talking about bugs
there are certainly bugs like typeof
null object or I'm not even talking
about ugly code idioms things where it's
so much prettier in another language and
it's more difficult to do in JavaScript
and we call that a WTF I'm not talking
about that either because we've we've
got the opportunity to improve those
things and we have done quite a bit of
improvement with es6 I'm also not
talking about cross browser quirks these
are much fewer today than they were say
five to ten years ago but I'm not
talking about those things either I know
it's fun to sometimes find a nightly
version of a browser that does something
crazy not talking about those WTF some
either what I'm talking about are things
that are intentionally codified it into
the spec that produce in my opinion at
least inconsistent incoherent or
unreasonable code and it's obviously the
more you use the code incorrectly the
more you amplify these problems but I
think these are the things I'm going to
pull out today are things that I think
tend to lead us towards inconsistent
incoherent and unreasonable code let me
also say that I'm not bashing on the
members of the tc39 committee as some
people have assumed in the past I
actually think they're fantastic they're
really smart and I would not want that
job because it's a nearly impossible job
to balance all the concerns that they do
so big props to what they've done with
the language I'm also not really bashing
on JavaScript because I think Java
scripts great and I'm unabashed
about that I actually think Java scripts
great and it's getting better but that
doesn't mean it's perfect that doesn't
mean we can't look at them and as I said
before most of the WTFs that people look
at and call out about the language are
actually leading from lack of
understanding lack of understanding how
the spec says something should work or
lack of understanding what the reasoning
behind it was now it's true that many of
the things that I'm going to share today
I mean all of them are in the spec and
they're all intentional and many of the
things I'm going to share today probably
have some line of reasoning that led to
them other than just sheer stupidity
there's probably some method to the
madness but I with all of my time
looking at it and trying to figure it
out haven't been able to tease out any
such meaning so therefore it's a WTF as
far as I'm concerned so let me further
ado let's jump in I'm going to start
with a couple of simple warmups number
dot max value which is some huge number
like 1 to the 10 to the 309 or something
like that it's pretty obvious that
number dot max values really really big
and obviously greater than zero but
number dot min value many would assume
that's the most negative the smallest
number you can get it's actually the
smallest positive number that you can
get so it's like zero with a whole three
hundred nine zeros after it before a one
or something like that and and I've
actually seen code bases that got
tripped up misunderstanding exactly what
min value I'm not sure why they didn't
say min positive value or so
like that but they called it min value
and in and of itself min value is it
terrible but when paired with max value
which is the maximum positive integer it
certainly leads to misunderstanding all
right some warmups
this is another famous one that people
like to cite 1 less than 2 less than 3
is true accidentally because of coercion
because if we reverse it 3 greater than
2 greater than 1 it's false
also because coercion comes to bite us
so this is one of those ones that they
actually talked about fixing it would
involve changing the left associativity
of that operator to the right
associativity in the operator and they
thought about doing that I guess they
rejected it for some reason that means
somebody's code out there is relying
upon that stupidity and that's why they
couldn't fix it ok another one this is
another one of my small pet piece but a
frustration nonetheless I really hate
how inconsistent it seems like the rules
around the period happened with numeric
literals so we know that the period can
appear with a number so on line 3 for
example 42 dot that's a totally valid
number in and of itself which is why it
can't be immediately followed even with
whitespace it can't be immediately
followed by a method but what's weird to
me is that line 5 is okay because to me
the placement of that whitespace we
typically don't think of JavaScript as
being a significant whitespace language
but the more you look at it they're more
there are places where just a little bit
of a misplaced space and of course when
I call it out here it it seems quite
obvious but I've actually seen code in
code reviews where somebody did this or
actually this happens a lot on blog
posts people are very careless with the
code they put in their snippets and you
can get into some quick trouble if
you're not paying a close attention to
where your periods show up so it's kind
of annoying to me that for instance 3 is
bad but 5 and 7 are okay and also I
never thought that anyone would actually
do line 11 where they put two periods
together and then I saw a library it's
called Cylon J s and a while back the
heads in their documentation they've
added methods to the prototype so they
gave a legitimate reason for that even
though if I saw that or if most people
saw it you would think that's pretty
crazy okay so those were our warmups
those are things that are often cited
about WTFs but I got a whole lot more
crazy for you so don't don't feel like
that's all we've got in store we're
going to start with coercion and
coercion is one of those that is often
said to be totally evil and
awful you should avoid it it's LAN the
design and language I have an entire
book dedicated to why I think that's a
completely false presumption
I actually think coercion is awesome it
should be used you should spend your
time learning it and that's the third
book in my series so I'm going to start
out by showing a couple of things about
coercion that are actually not WTFs so
the first one is well cited that an
array is somehow double equal to the
negation of the mtra and take it on its
surface that looks nuts how can
something be equal to the negation of
itself but we have to understand that
the equals and the negation do not
happen at the same time even though
somehow our brains think that they do
the negation happens first and when you
negate an array you're taking it from a
truth e value to false so we're now
actually comparison comparing the empty
array to the false and it's actually
pretty straightforward in the spec what
happens when anything gets compared to
an object is that both things end up
becoming numbers so what number should
the empty array become you could have
argued I guess that it should have
become nan but it becomes zero and false
also becomes zero and that's why the two
are equal to each other and if you pay
any attention at all to the algorithm of
how coercion works it's actually pretty
reasoned like that it's not quite as
magical as you've been led to believe
now that's it for equals I've got tons
more of course in the book about equals
the double equals Lu sequels but what
about this one this is often cited as an
example of showing how Java scripts
addition operator is not commutative you
can't do it in the same you get
different results depending on what
order and that's nonsense the operator
is actually when taken in a mathematical
sense it is actually commutative not
with strings of course if you append
strings in a different or you're going
to get a different result but actually
what's happening here is that on line 5
we're not doing an addition at all even
though it looks like it you understand
it all about the JavaScript grammar a
pair of curly braces is just an empty
block when not used in an expression
location so this is taken to be an empty
block that you didn't do anything with
and then the plus is actually just a
unary operator that's operating on the
array again coercing it to a number
which is why we end up with 0 the point
I'm trying to make and the book the
third book in the series goes through
all this but the point I'm trying to
make is that there's an awful lot of
things that are cited is crazy and
totally unexplainable
they're actually pretty rational if you
read the spec or my book now there are
some things there are some things that
can be kind of weird so I've got a
couple of examples on here and what I
would really to point out is that most
of the times that we have frustration
about coercion it's actually related to
what's happening when you go from a
number to a string or a string to a
number that's actually where most of the
concern is and JavaScript has sort of I
guess I would say an informal design
philosophy around it from the very
beginning which is to try to do the best
possible thing that it can rather than
just throwing errors everywhere if you
do something even slightly invalid in
Java it just throws an error but in
JavaScript it tries to make a best guess
at what you're intending so for example
if you try to turn some white space or
some new lines or things like that into
a number rather than it throwing up its
hands and giving you an error and saying
you're stupid it says well what's the
best guess that I can give and it's
similar to if it was using an empty
string it basically strips off all the
trailing whitespace and then an empty
string somewhat reasonably will coerce
to a number some would disagree but I
think an empty string coercing to a
number is at least reasonable I don't
consider that to be magic and crazy and
of course the the zero string here we
definitely see that we have a positive
zero there's also a negative zero that's
a little-known fact and you notice that
the negative zero does in fact go in the
proper direction from its string form to
its number form now line nine looks like
it's the same thing it looks like it's a
negative zero it's actually a regular
zero that's been operated on by the
negative by the minus unary operator
which is why line 10 fails because
that's not actually valid syntax for a
number okay now going the other
direction we do start to see some things
that might be considered crazy for
example if you try to take a negative
zero and stringify it it always produces
a regular zero not a negative zero and
that seems crazy and I used to label
this a WTF but the spec literally says
do this and there are some historical
reasons mostly because most people don't
even know what a negative zero would be
for and they don't want to see a
negative zero so way back in the day
they just said lie to the user and
pretend that it's regular zero so we've
got that history of lying to us and we
should adopt that I would say this is
not exactly a WTF it's just it's kind of
a strange decision that they made but
there's history
local reasons all right so I've done
enough defending there's plenty for me
to complain about let's go into some
coercion stuff that is crazy all right
so here's some other examples taking a
string zero dot and making a zero that
makes sense and dot zero makes sense why
doesn't just dot all by itself make
sense I think it ought to but it does
not it's not valid syntax of course so
that's nan so that one's kind of
understandable but undefined in null why
on earth does null become zero and
undefined becomes nan exactly thank you
I was waiting for somebody to start
yelling this out that's nuts right I'm
again I'm sure if you pin down one of
the original tc39 members there's some
kind of reasoning behind it but it's
just crazy another thing I wanted to
point out by the way es6 is getting a
new octal syntax and I love the fact
that we can now do zero capital o after
it took to create octal syntax because
that's not going to create confusion in
people's editors at all seriously what
okay so some other examples of nuts
stuff if you take an object just an
empty object and you try to turn it into
a number it becomes nan but an empty
array becomes zero again exactly what
what is why would we have a different
rule well again if you look in the spec
there are some reasons behind it because
arrays are assumed that you want the
string version first so they actually
the array becomes an empty string which
then becomes 0 and for whatever reason
objects don't become an empty string
they become this crazy thing that we see
on line 4 and it's pretty clear why that
isn't a valid number so you can explain
these things but it's still
inconsistency that drives obsessive
compulsive people like me nuts here's
another one that I actually think I
really can't come up with any
explanation for this
if you string the fie the null value it
actually becomes string null which makes
a lot of sense but if null is inside of
an array it just goes away we just
pretend that that null value isn't even
there when we stringify
what the come on y'all or not you not
have enough coffee I need some help here
ok and same thing with undefined the
undefined value inside of an array it
just goes away when we stringify it by
default some other examples there's kind
of a new thing in es5 with this trailing
comma thing
going on and you notice that if you have
a trailing comets essentially dropped
off in terms of a suit of an assumption
of a value but the fact that we have
three entirely different values here
that all stringify to the exact same
thing is all what the what were
they thinking string applying all three
of these two you may think that the same
value but they're totally different
kinds of values and I'll prove that on
an upcoming slide here's another one
with coercion we've got an object oh one
just a plain old normal object and on
line six if I try to string a fight we
get the regular object garbage that
comes out but if you take an object and
you create it with a null prototype in
other words you creates like some sort
of dictionary object if you try to
coerce that to a string it's not like
you get some other kind of string you
actually get an error now wait a minute
I thought JavaScript is all about trying
to do something useful for us instead of
throwing errors everywhere why do we
have the inconsistencies that there are
sometimes errors and sometimes not here
it's because a null prototyped object
doesn't have access to its string of two
string and value of but still that's
nuts why why doesn't have some exception
to treat that more consistently with the
other case a new primitive value type
that's coming in es6 is called symbol
I'm not going to get into all of what
symbols about because some people love
it some people hate it but I do want to
talk about another crazy WTF which is
that they intentionally decided that
symbols can be explicitly coerced like
we see on line five but they cannot be
implicitly coerced if you try to
implicitly coerce it throws an error
again
crazy inconsistency that is going to
trip people up there are reasons there's
long discussion lists about why they
think this is the right decision but
when we take a step back and ask what
does that mean in terms of consistency
of my code if there's some places where
it's an error in some places it's not
that's asking for people to get tripped
up all right empty slots are another one
of my favorite things to hate on we see
the array constructor here the array
three and you would think that creates
an array pre size two length three
unfortunately there's no such thing as
there's no such concept whatsoever of
pre sizing an array actually underneath
the covers the specs is something
entirely different about this all right
but most people think array three
creates an array of three undefined
values and you notice it's a little hard
to read I know with the comments but
you'll notice that in chrome they
represented as undefined times three
when you when you print
value on in the console undefined times
three but if you look on line nine that
same array explicitly declared when
Chrome represents it it actually spells
out undefined undefined undefined that
should be our first clue that these are
indeed actually entirely different value
types even though undefined times three
looks a really awful lot like undefined
undefined undefined they're not Firefox
does a better job mostly because I've
been complaining at them for a while
they do a much better job and they
actually call it three empty slots
rather than trying to pretend that
undefined is the same thing as an empty
slot under the covers the spec actually
says when you do a something like array
three create an empty array and then
arbitrarily set its length property to
three so you can do that you can create
your own empty slots like this and then
you end up creating that sort that
weirdness of undefined times three is
supposed to undefined undefined
undefined now I said that they were
actually different values and this slide
will prove it because if you start out
with undefined undefined undefined and
you call join on it it works and if you
call join on it like you do on line
seven it also works but if you try and
map the map function you get it
different because the map function
actually iterates over values rather
than just doing a regular for loop so
map and join have a different semantics
that exposes itself when you're dealing
with these crazy empty slot arrays empty
slots this concept of array like objects
is the first true genuine WTF that I
identified in JavaScript it's nuts
there's literally no reason why we
should have a concept of empty slots
like this by the way that little weird
arrow syntax that you see there in line
four and also long ten that's es6 is new
version of the of the function it's
called an arrow function I'm not going
to get into arrow function today but
just to let you know arrow function is
also that people that make slides and
write books can write less code that's
really that's its only purpose
so I put it on my slides so that my
slides are shorter all right array apply
array this is how we create one of those
arrays that actually has the undefined
values and you'll notice up on the top
line we pass in one of those weird array
objects with a length three basically
apply doesn't really care what kind of
object you give it as long as it is a
property called length it will create
something of that same value just
doesn't internal for loop so you notice
on line seven I just do an arbitrary
object with length property three which
looks nuts but that works and even down
on line ten you see
function that has three declared
parameters because function objects have
a length property equal to the number of
their declared parameters WTF okay
quickly moving on this is a short one
but many of you have at least seen or
maybe you've toyed around or used switch
statements in your code
some people hate them but some people
find that they're actually quite useful
that often times can be more performant
than their counterparts a switch is
useful and most everyone that I've ever
seen in fact I'm pretty sure it's
everyone that I've ever seen uses a
switch statement and if they have a
default clause they put the default
clause at the end nearly all
documentation literature on the subject
turns out the spec says you can put
default whatever you want you can put it
at the top or right smack dab in the
middle unfortunately if you put it
somewhere else it does lead to some
really crazy WTF here's an example so
I'm switching on the value 42 now notice
that none of my cases match 42 so the
first thing that's going to happen is
the engine is going to go through all of
those cases skipping over the default of
course go through all of those cases and
it's not going to find a matching one
and then it's going to invoke the
default clause the way we would expect
but because we don't have a break inside
of our default because nobody puts
breaks in there defaults now we've
created this loop where we start back
and fall back through to one of the
other cases and we print out hoops what
the this crazy weird loop thing that
happens just because you move default
out of place now I know everybody would
say well just don't do that right
there's lots of things that we can avoid
if we're smart enough to not do them but
that doesn't mean we should create foot
guns in the design of the language okay
finally now I'm actually going to bash
on the finally Clause quite a bit I
don't mean finally I'm not anywhere near
done but finally the clause that comes
up in JavaScript alright so if you're
not familiar with finally essentially
what it says is after a try condition
and you don't have to have a catch but
you can but after a for a try slash try
catch condition after that is fully
completed whatever it's doing the
finally Clause is guaranteed to run it's
almost like a hidden callback it's stuck
somewhere on the stack and it's
guaranteed to run no matter what happens
even with an error which is really nice
for like cleanup conditions and things
like that so here we see kind of a
craziness of the finally which is inside
of the try condition I returned the
value two so in other words
I'm saying I want to finish up the
function now it is definitely there are
definitely cases we're having a finally
in this case is useful if you want to do
something after you've returned to value
that's great right there's there's
cleanup reasons why you do this but if
you put an explicit return in your
finally it overrides the previous return
so now you have two returns in your code
what on earth and where did to go we
just completely lost you it just got
thrown away but that's not even remotely
the craziness so finally all right so
this one is not a WTF this is just a
basic statement which most of us would
agree with that not returning from a
function or returning with no value or
returning with the explicit undefined
value in all cases that we're all
familiar with those are
indistinguishable they're the same
condition right and in all cases of es5
except for the one I'm about to show you
that is definitely true what happens
with the finally if we put a return an
explicit return inside of the finally it
overrides but if we do not put an
explicit return inside of the finally it
pretends that it didn't try to override
it also it doesn't actually behave the
same depending on a return versus not a
return so there we got the two now label
blocks everybody's favorite go-to
behavior in JavaScript the one we
probably wish would go away but they
exist and there are reasons for it the
break statement that we see on line
seven can break to continue after the
label block so basically we're going to
skip to line nine and finish after that
label block if you break inside of a
finally it cancels the finally and it
just lets the function continue going
like normal so even though you your your
function may have thrown an error or in
this case return to value because I
returned to two now when we get to line
11 we're not inside of the finally
anymore so we'll return of a returned is
the same thing as returning undefined
and we lost our two value what uh come
on you guys are dropping the ball I
shouldn't have to you must agree that
these are some WTFs alright one of my
new favorite features in all the Venus 6
is generators and so I'm going to show
you a couple of slides that are actually
really good these are not WTF so these
is cool but it may seem crazy to you a
generator in brief is a function
can pause itself and then be resumed
externally so rather than a function
running to completion we can pause it
they're actually really really powerful
for infinite lists of values they're
also really powerful for expressing flow
control when you combine it with
promises so I'm a big fan of generators
what you see right here is when I
execute foo I'm getting an iterator and
when I call dot next on the first on
line eight I get back the yield one from
line two so and the done false tells me
that's not done and then I call IT next
and I can pass in a value and that value
five goes back in and that's what get
prints that's why it gets printed out a
colon five so yield is actually two-way
message passing while it's pausing and
resuming fantastically power what's
going to look weird to you but I promise
this is not a WTF this is a super
awesome part of the language just going
to take some new getting used to and
finally once we're done with the
function we get back a value undefined
and a done true that lets us know that
we're finished iterating through a
function there's also a method on a
generator if a generator is paused
somewhere in between and you're totally
done with it you're done with all the
values and want to free up all of its
memory you can call return on it and by
calling return you're saying I want you
to abort where you have been pause just
completely aboard it's not an error but
abort and if you pass a value to return
you just get the value right back which
is a little weird it's like but it's
like injecting a return into your
generator it's a little bit strange but
it's still there's cases where that's
useful so again not a WTF but here's the
WTF when they start when we inject
finally our good friend finally guess
what happens when you have a finally
Clause again this one's not so crazy
we'll see in just I'm sorry we'll see in
just to the next slide if we inject the
finally clause into it we know that if
we call a dot return right in the middle
that it still runs the finally Clause so
we're happy with that probably because
that's the same as with functions what
is crazy is that if a finally if a try
condition is the one accepts a return
like if you try to abort inside of a try
the presence of a finally Clause cancels
the return of the generator so the
generator just goes back to working like
before without even doing the whole
break labeled block thing now in this
case I know it's a little weird to see
what the but you'll see the slides
afterwards I'll give you the URL but
when we call a dot return right in the
middle of the first line of that try
condition we would expect it to run only
the finally Clause and be done but
actually as we play this out it runs not
only everything inside of the finally
Clause including pause and resume but it
also runs the code on line 11 even
though we told it to stop running it
keeps running the rest of the code in
your function so you are going to
probably run into cases where somebody
accidentally writes their from their
generator in a weird way and you get
unexpected executions of statements
basically this would boil down to
finally is a really useful thing that
can really be abused okay now another
great part of generators is that they
basically represent an infinite sequence
of values that we can iterate over and
we can use this new for of loop the for
VAR I of foo and that will automatically
iterate over all the values that either
a generator or any general iterator has
to give us except if you notice the
return 3 value that I send at the end
just gets completely lost we yield 1 and
we yield 2 and those values come out but
when we do a return 3 the for of loop
throws away the final value it doesn't
run the iteration one more time
so you're going to lose values if you
accidentally use a return instead of
yield for example all right moving on ES
6 is introduced a new concept with block
scope and there's actually quite a few
places this can happen but they
introduced this concept of the temporal
dead zone but I'm not making it up
that's the actual name breviary tdz and
the idea here is that a variable can be
in this special state where it has been
declared but not yet initialized and if
you're in that special weird state
things go wonky so the type of operator
most people know the type of operator
used to be considered to be like the
safe operator you could use it even with
a variable that didn't exist and you
wouldn't get an error you would just get
this nice printed undefined however if
you try type of with a let declared
variable let being the block scoping
declaration if you use that you'll
notice on line 3 we actually get an
error so it's not safe because the B
variable is in a different kind of a
state than the non-existent a variable B
exists but it's not initialized and
you're not allowed to touch it so I'm
going to slap their hand if you do so
you got to be careful thinking about the
type of operator and again it's an
inconsistency
if typo
works safely with one type of variable
it's weird that it doesn't work with
this type of variable all right a huge
major feature that's coming in es6 is
going to make lots of improvements to
code and I'm a big fan object
destructuring
a couple of examples of really good uses
of object destructuring here's the old
way if I have a function that wants to
return more than one value I can either
put in an array or oftentimes you put it
in an object like I'm doing on line 4 so
I'm returning an object with some
properties and the values and if I want
to extract those values you see on line
8 I just declare variables for each one
of the properties and I pull the values
out you've probably written code like
that or something similar at some point
now object destructuring actually has a
really nice syntax for this you'll
notice on line 7 we can just simply
declare an object in the position of a
declaration on the left hand side and it
automatically declares those variables
for us and extracts them for us so now
we have these top-level variables and
that's a super useful feature that
you're going to find all over the
language in es6 that's not a WTF in fact
we also have property shorthands you'll
notice on the previous slide I had X : x
and y : wine that ugly older syntax now
if the property name and the value that
it's referencing are the same you can
just shorten it and leave out the colon
part so it's even better I love this
syntax it's going to be very useful but
there's a little bit of a problem with
inconsistency so here when I declare if
I wanted to have a variable that was
different than the property name what I
do is I declare the alias if you will as
lowercase X as you see on line 4 and
then the value that I'm referencing is
the capital X X value so it goes alias
value in a left-to-right fashion so you
would think for consistency sake that we
would keep that same pattern when we
start dealing with things with object
destructuring unfortunately they for
whatever reason chose to reverse that
pattern so as we see here if I want to D
structure with those values I'm sorry
one other slide I forgot so you can also
nice thing about object D structuring
I'm passing back a Z value but I don't
care about the Z value I'm throwing it
away I'm not even assigning it on line 7
and that's totally ok so you don't
actually have to account for every
property but here's where we start to
see some crazy and consistency you'll
notice on line 4 that it goes alias
value alias value but on line 7 if I
want to do this
same thing I have to go value alias
value alias again it's an inconsistency
in the way the brain thinks about these
structures if you've been used to
thinking about object literals with the
property name as your alias and the
value is the reference on the right hand
side now you have to reverse that when
you're thinking about object
restructuring now object destruction is
also awesome for parameters because we
can now get this concept of named
parameters so up on the line one you see
I can just declare an object in a
parameter position and those property
values that are listed there are
automatically extracted from an object
that's passed in so if I pass in the
object with Y 10 and X 25 even in their
reverse order I end up getting 25 10
printed out as top-level variables super
useful lots of shortened code easier to
understand code you can even add on
those extra parameters so that you can
use an object structuring more than once
in each location of a parameter so
that's great
but when we want to do when we want to
do that aliasing again the aliasing is
reversed so now you've got this
craziness of thinking about your
aliasing and reversed fashion now
default parameter aliens this is another
super useful thing in es6 and I promise
I'm almost wrapped up I know we're going
slightly over but I'm almost wrapped up
default parameter values here I want to
define a default value to hold for the Y
parameter if I don't pass in a Y value
so I can just say equals 10 in the
function declaration super super useful
almost every other language in the plan
that's had it we're finally getting it
as of you know 6 I'm real excited about
it but again we're going to see that
there are some WTFs waiting for us if we
dig into that syntax so what happens
when you start using objects as your
default values on line one you see that
I have two different ways of expressing
an object with a default fallback from
one of its property values I'm saying
that on the first one I'm saying X is
equal to and then I've got a fallback
value of an object with a Y property of
10 so if X is not past at all my default
value will be an object with y 10 on it
which is why you see on line 2 I say X
dot Y I'm going to get the object itself
slightly differently and a really
strange looking syntax at least to me is
the second one where you see y equals 20
inside of the curly braces and then
equals empty object what the hell is
going on with that
well what that's saying
is in sort of a bizarre way we kind of
twist our way around this this
processing what it's saying is if you
don't pass in any object I'm going to
give you an empty object and then it's
saying if whatever I get whether the
default object or the object you passed
in doesn't have a Y property default the
Y property to the value 20 which is
probably what most of us would want the
second of the two syntaxes is going to
be the more likely syntax that we use
but it's also the more WTF of the two
syntaxes yet again more inconsistency
and incoherency alright my last topic I
put classes in quotes it's no surprise
to those of you that follow me that I
really hate the idea of classes and even
though class is coming to JavaScript and
es6 I think it's a terrible idea this
was the old school way of doing classes
with the prototype based coding and
you'll notice that most of that probably
looks familiar the whole object.create
to link the prototypes thing look down
at line 15 you'll notice that crazy
ugliness this dot underscore underscore
proto by the way that's pronounced
dunder proto so this dunder proto dunder
proto dot another call this what in the
hell is that
that is our stand-in at least for right
now for not having a super keyword we
want to be able to do relative
polymorphism that's what super is all
about but we don't have that at least
prior to es6 so we have to do crap like
that and you may think oh that's bad but
not too bad except for the fact that you
actually don't know how many pro toes
you need until you know how long the
stack is because if you have three
classes in your inheritance chain now
you need three dunder proto's so it's
actually impossible to write it
correctly this just happens to work in
that case it's terrible but people have
been writing that kind of code for 20
years actually they've been stuffing it
inside of frameworks but they've been
writing it the new class syntax which
everybody is Valen ting is oh this is so
awesome it's like the best thing ever
happened at Java Script this slide shows
it working in a very same fashion I've
got a parent class that I call px and a
child class called CX I'm sorry I
shouldn't have left that parenthesis
there that was a mistake the parentheses
don't come after the class name but if
you extend if you use the extends class
you extend the parent class and then
when we're able to override in the child
class the another method and you notice
there that I can call super dot another
and it supposedly is going to give me
the relative polymorphism that
been missing forever that's one of the
big things that everybody's claiming is
awesome about es6 classes unfortunately
but if you push into what super is all
about and by the way I'm being generous
because I don't like classes at all but
it's not a WTF that's actually the way
it's designed to work but the thing
about this we know that this is a
dynamically bound property which means
if I take a method and I explicitly bind
it to some other I can borrow those
functions and use them around that's a
very common thing in JavaScript
unfortunately the super keyword is not
dynamically bound it's actually
statically bound at the time that you
declare the method it's this whole like
when it's parsing it adds it to it which
means that if you try to borrow a method
that has a super reference in it instead
of that automatically getting borrowed
now it's still bizarrely pointing to the
other one which is what I'm showing here
I know this is some crazy complex code
but I got two different parent-child
class pairs here I've got a px CX and a
py CY and down here on line 23 I'm
trying to take an instance of Y and
dynamically bind it against the X
hierarchy and it works for this keyword
but it fails for the super keyword now I
know that that may not seem like
something that's going to often be done
but Java scripts all about these dynamic
hierarchies that's what we've been doing
for 20 years and it's a strange stretch
for us to go back to having statically
bound methods they did it for
performance reasons but it's still going
to be strange when you poke on trying to
do dynamicism with classes even if you
try to change the hierarchy like I'm
doing with set prototype of you still
get the same problem now there was a
proposal to fix this inability for the
super to be pointing the wrong location
there was a proposal which looks crazy
but on line 18 there was this proposal
to use this to method thing literally
like less than a week ago they voted to
leave it out so we can't actually fix
those super values once they've been
defined at structured time you can't
change them ever again or at least not
in es6 unfortunately even though that
was ugly unfortunately that was going to
be quite useful for many cases people
that do mix-ins and things like that so
we're kind of left in this weird state
where super seems to work great if if
you're using a really simple case if you
start pushing on the complex cases with
dynamicism it's going to fall apart
quickly alright that was a super quick
run-through apologize for in a couple
minutes over but I would just end by
saying yeah haters are going to hate and
I'm
I'm one of them right so I'm hating on
the language a language that I love I'm
still going to JavaScript I'm still
going to write I'm still going to
encourage others I'm still going to
teach people as Brendan Eich likes to
say always bet on JavaScript and it's
WTFs thanks very much I appreciate
there's the URL for the slides if you
want to check them off</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>