<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python Fundamentals Training - Classes | Coder Coacher - Coaching Coders</title><meta content="Python Fundamentals Training - Classes - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python Fundamentals Training - Classes</b></h2><h5 class="post__date">2011-10-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rKzZEtxIX14" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">classes are factories that create
objects and if you get really technical
you can say classes are objects because
everything in Python is an object but a
class is a special kind of thing whose
job it is to be the specification for
the creator of objects so we make new
objects with classes and what
specifically did we explore about
classes what can you what can you do to
customize classes right so the basic
thing we want to do with classes is
packaged some code and some data
together the methods are regular
functions but they're attached to an
object they take a first mandatory
parameter called self that refers to the
object once it's actually created we
don't have to pass that parameter in and
it's a way for the methods to be
directly attached to the data they're
operating on they can set variables on
self and that's in the local namespace
of the instantiated object methods what
methods methods did we talk about your
study on classes we're talking about in
it what does in it do yeah and it is the
so you'll find out later that I've lied
to you for the purposes of
simplification but yes and it is the
constructor of the class there's also an
underscore underscore new method and the
deal is in Python you don't have to take
your construction and destruction of
your classes quite as seriously as you
do in many other languages so it's very
typical not to write destructors for
your classes at all which most other OOP
languages you would and we don't
actually handle the classes allocation
and construction in it really is called
after the class is made and it's a way
for us to go ahead and initialize the
data that should exist on every single
object if you really had to control how
the class is allocated you can use new
and you can also use yeah there's a
couple of complicated concepts that are
way beyond the scope of the class but
you can use the metaclass of the class
the totally control how it's created and
instantiated
they all sorts of crazy things like
returning objects that aren't even part
of your class at all if you wanted to
and it's it's way beyond the scope of
the class to discuss it but be aware in
it is not actually the constructor but
it is the initializer of your of your
object and it is what you're going to
use ninety-nine point nine percent of
the time to initialize your objects
other use cases are for people who are
writing complicated software that I
might use okay so talking about other
functions we talked about on classes
other methods of classes we actually
listed a whole bunch of underscore
methods and you Lee is asking kind of
how are these related to one another and
we did the underscore underscore string
method yesterday we did an underscore
underscore repper re PR method we talked
about like the underscore underscore add
the dunder add method and there's a
bunch more they're not related to each
other in any technical sense what all
the underscore methods are our protocol
methods I never Python does stuff with
your objects it checks to see if these
methods exist and uses them if they do
so Python allows you to influence how
your methods respond to all the built-in
operators so converting to strings
converting to representation responding
to ad responding to the call operator
which is parenthesis you can customize
how your object could handle being
called and responding two plus two x
divided you remember we did sets way
back and we could use functions to do
things like the intersection of two sets
but we could also use operators we could
say like set one ampersand set to and
that operator is actually a boolean
ampersand by default and it only has
meaning on sets because sets have the
set class has implemented the underscore
method that responds to that operator so
all those methods there just to allow us
to customize
how our objects get handled by Python
yes nope that's we are we are doing
operator overloading and this is how
Python accomplishes it yes it is yes and
again it kind of works by protocol and
you can read the documentation about the
protocol but Python will call even a
succession of methods so if you define
the underscore underscore and new when
you create a new object of your class
Python will call that if you then have
an underscore underscore in it Python
I'll call that if you didn't provide
either one it'll just make your object
so as protocol based there's no
syntactic enforcement of making sure
that you have a constructor or a
destructor or implement any of these
dunder square methods you'll just find
out about it when you try to use an
operator on a object that doesn't
support it and I'll say I'm sorry I
can't add a row in a row that operation
isn't supported protocol I'm using in
the sense that there is a defined order
of operations that Python follows and
that allows us to hook into and modify
the behavior of our objects but it's not
a syntactic level enforcement at all
yeah and just as an example of how
flexible that makes things you can
respond to the operator for brackets for
square brackets so if you want your
address book to be able to say I got a
new address book in its a and you can
just say a bracket one closing bracket
you're not getting into whatever data
structure you're using your calling a
function that can get into whatever data
structure using so you could enable for
instance indexing by position and
indexing by name on the same object
because ultimately being handed to a
function in the function could say hey
if this is an energy let's do positional
and if this is a string let's do a key
base look up so you can program how your
objects are going to respond to all the
operators and some things are operators
that you don't think of like square
brackets like parentheses it's just the
operator for call and it's you can make
very fluent interfaces using the dunder
score methods and emulation
okay what else do we talked about
yesterday besides OOP it seems like the
only thing we talked about but we really
talked about that for like an hour and a
half maybe list comprehension which
should be like your new best friend for
life seriously you should love these
things and list comprehensions are
indicated by what square brackets those
comprehensions have three parts with one
part being optional the first thing in
the list comprehension is yes basically
the return value the statement the
expression that will be evaluated and
become a single item in the resulting
list and it is everything up until you
bump into a four and it can mutate it
can change it can just be a value from
the iterable you're iterating over the
next thing is the next thing is the four
and that defines your iteration for
value in some iterable innumerable and
the last and optional part is the if the
condition you can optionally include
items in the resulting list so in the
list comprehension we can filter things
out and we can change their values in
one statement and we can nest list
comprehensions but um I don't approve of
that there we go so we talked about not
just functions as first-class citizens
but higher order functions functional
composition factories functions that
create special case functions for us and
return them decorators which do exactly
that but wrap the enclosing function
decorators we can mostly conclude make
you think when you write them but
they're trivial to use we're going to
use another decorator at today as we
continue doing oops it's super useful
and that's built in we took a look at
well we took a look at anonymous
functions lambda if you remember lambda
they have to be really simple a single
expression which is implicitly a return
an optional list of parameters no
parentheses just a semicolon separating
the two things and the keyword lambda
and we might use them as short one
liners to pass
things like filter or sort or map
built-ins that expect you to pass a
function that does something simple like
pick a key a return a value or compare
two objects we talked a little bit more
about namespaces yesterday namespace is
going from packages and modules
functions and nested functions and now
classes and objects and we're ready to
talk a little bit more about OOP today
I guess I shouldn't forget we had did a
little random coverage of the standard
library so we talked about like
itertools for instance and the operator
module as well so in our OOP section in
our curriculum we've got the first and
basic level of objects we talked about
emulation which is the section in the
curriculum it talks about the dunder
square methods another word for that
could be operator overloading but
basically how to customize the behavior
of your classes in response to various
operators it's worth noting that one of
the examples in the curriculum is
iteration so it shows a class this is on
page 44 it shows a class that defines an
underscore underscore writer function
and that simply enables you to do things
like for value in object it'll respond
to the iteration protocol so we hadn't
covered that we might do a code sample
of that today we did talk about static
method we use the decorator we left self
off of our function if you didn't use
the decorator and you left self off of
your function when you call your
function on an object it complains
because once the past self when you call
on the classic complains because you
want to pass self if you add the static
method object or the static method
decorator you can call your function
directly on the class without having
instantiated an object and that
sometimes a little bit useful there's
also the class method decorator that we
could cover if you have methods you
might want to call without like class
being instantiated but you do want
access to the class well I meant why
might you want access to the class
change the common data so objects have
namespaces and every object has its own
namespace but they also share the class
name space so if you wrote a class
method and it changed a variable on the
class every single object would see it
so there could be two ways of passing a
piece of information to all the objects
that exist one might be to ran
them all up let's say you've made 20
rows or you go through each row and give
it some data or you could just set the
data directly on the class and you might
want to do that as a class method in
which case every object would be able to
look up and see the change data the data
is in common and class methods we can do
real quickly and by the way today we get
to explain what this whole row object
thing is that we start our classes with
so if we want access to the class we
should probably pass it and the default
is to use again an argument that is
named nicely CLS this is not
syntactically enforced but again if you
write class methods in the first object
is the first argument is called food
than other people might hit you
there is no roex
I tell you
try this one more time
ok so I've written a class it has a
class method and that class method is a
function whose first argument is the
class and it takes a value and I set the
value on the class and when i
instantiate objects
we can see that we are in fact changing
common data that's shared between the
objects games games are kind of fun to
play around with and I've written a
bunch of games with a Python library
called PI game it's another one called
pikelet that I'm supposedly
transitioning to but they let you write
simple 2d games in 100 lines of code
stuff like our address book and you can
write simple 2d games if you want to do
3d and you want to do very much hardware
enhancement things get more complicated
but to write simple games i wrote
written games for my kids i wrote like a
typing game and a math game for my
daughter you know bubbles fly across the
screen with math problems and you type
the answer on the keypad and the bubbles
pop a sort of thing and it's fun to be
able to do that in 20 lines in 15
minutes but very frequently if your game
is at all complex you have tons and tons
of objects everything in your gaming
environment might be an object your
player all the enemies all the sprites
moving around the screen and I've used
class variables as a way to do method
passing to all the objects that are the
same type so if for instance I've won
the level and all the enemies in my
space game should blow up I might just
set a variable called destruct on the
class for enemies and all the different
kinds of enemy's ships people whatever
notice that they're supposed to be
distracting and start blowing themselves
up it's a way to do message passing to a
bunch of stuff instead of having to
reach out to each individual one and
tell it so shared data it's it's useful
and the other decorator that I wanted to
show you is going to skip ahead just a
bit this section called encapsulation
we're still not talking about
inheritance I'm going to do that
afterwards but sections 16.7 and your
curriculum has three different ways of
implementing encapsulation on our Python
objects and encapsulation basically is
the object-oriented principle that how
you do something
should be hidden from the end user of
your class you could just expose that
you do something and what that means is
the implementation details can change
but how your object is used might remain
exactly the same and I gave the example
yesterday of your address book scaling
if you are exposing all your data as a
list for our type programs that's fine
and you implement searching by searching
of the list and that's fine maybe you
want to store your data in a database if
all the access to your address book is
happening through address book methods
and Road methods you can change the fact
that your address book is storing them
in a list to the fact that your address
book is looking them up in a database
without changing any of the methods and
the program that uses your objects
doesn't have to know about it the
concept of coupling is involved here
tight versus loose coupling and
basically objects should be able to use
one another without knowing very much
about one another so as an example when
I say I want to represent a row if my
address book says print % s % s % s
first name last name role of my row my
address book knows a lot about my row
object it knows that it has three fields
it knows what the names of the three
fields are if I ever change the three
fields I have to change my address book
class if on the other hand my address
book class just says print row and we
delegate that printing operation to the
string the dunder score string method my
address book doesn't know anything about
row and when Row starts adding fields or
row decides that we want to show a
fixed-width format instead of an English
sentence the address book doesn't change
so what it does display a row is
completely separate from the
implementation and row hide that from
the address book if possible it should
be the relationship between all your of
your objects when you have one
object that is poking deeply into the
data structures of another object
they're tightly coupled if you change
one you're going to have to change the
other make one small change to one
object it may cascade up a chain of
three or four other objects that are not
directly related but would use it and
we'd like to prevent that from happening
so we have encapsulation and we already
have a basic level encapsulation which
is we can just make you do everything
through functions yes we may have data
structures but you know two functions
and we can emulate various operators to
make that nature so we can emulate
emulate iteration and hide from you
whether we're storing things in a list
are storing things in a database and
when you iterate over us we'll pull them
from a list or pull them from a database
and you don't know which and that's kind
of one level of encapsulation that's
useful and but we can also fake some
things about our objects and there's
three ways of faking things about the
properties of our objects I'm going to
tell you about one in detail but I'm
going to mention all three the first one
is that we can intercept attribute
access and attribute access is the dot
operator the dot says what comes next is
a variable but I want to look this
variable up in the namespace before the
dot so in this case the namespace before
the dot is an object and when I say RX
it looks up X in the namespace of the
object it happens that it doesn't find
it but objects look at their enclosing
class namespace and does find it there
and returns it to us we can use the
underscore underscore get at her method
to respond to the dot object which is
the most flexible way of doing
encapsulation but also way overkill for
most of what we want and what it means
is every single time we use the dot
operator instead of going to look for
the field it'll call our function and
pass it the name that is trying to look
up and let us decide whether that name
should be looked up and where it should
be looked up and it's probably not what
we want
it's probably a little too powerful the
simpler use case is to use a concept
called properties anybody done i need
java programming in here so Java it's
very frequent to write getters and
setters for the properties on your
objects you don't let somebody directly
say Rho dot X and X is an int you
probably say something like Rho dot get
X to get the value and if you're going
to assign to it you price a Rho dot said
X and pass a value and the idea is
encapsulation you're hiding the data
type of your underlying property it's
programmability let's say that we want
our object to do something every time X
changes if we start out with X as a
simple integer and we set the integer we
have no way of responding to that
operation so it's very common in Java to
hide every single attribute access
behind getters and setters Python has
the idea of getters and setters but in a
more flexible implementation so let's
write a property
ok so I've got a class a be for address
book I'm defining mine it function it
takes self it takes data it's just
setting data to a object level variable
and I've got another variable called num
rows that I get from calculating the
length of data I'd like to expose I have
in fact exposed num rows right now
obviously not passing a real address
book data here but I can see numrows if
I want to take some sort of action or I
want to do some sort of filtering
anytime somebody looks up numrows I can
use a property I'm going to hide numrows
slightly python has no concept of
private variables it is convention to
use a leading underscore for variables
you do not intend people to directly
access and what this basically
communicates is hey if you're peeking at
my underscore variables you may not know
what you're doing they may or may not be
accurate this isn't the way you're
supposed to use them it does have data
mangling that we'll talk about in a
little bit that's a convention not
syntactically enforced
now what makes the difference is whether
you set it on the class or whether you
set it on the object so back in our
class method the first parameter that
came in wasn't self it wasn't an object
it was class it was the class and so
saying back then CLS X is no different
than saying Road X and remember row is a
class so class variables are shared
between all the instances of the object
no so if you say self if you say self
dot X inside of a bound method a regular
class method you're changing objects in
the object name space and a different
for each object if you use a class
method and I I could have hard-coded the
name of the class inside my class method
and said road x instead of accepting it
as a parameter but as we'll see in a
little while sometimes methods don't
know what class it is that they belong
to we'll see that okay so back to my
example with a property here I've got a
and if you look at a i see i have num
rows and i also have data and i have
underscore num rows and what is num rows
it was a function right
it's this this piece right here and when
i say r dot numrows i would think i
would see like a function object as for
instance i say r dot in it it's a
function it's a it's a bound method but
it's ultimately a function but when i
say r dot numrows sorry when i say a dot
numrows it calls my function even though
i didn't use any parentheses and it
returns my value so what the property
decorator does is let you pretend that
your function is an attribute and the
default thing the property does is
handle the lookup of your attribute and
you can do whatever you want with a
lookup of your attribute you can keep
people from looking at your attribute
you can delegate it in some way you can
access the hidden variable which is what
I'm doing and I'm also just printing you
Pete this is differently making normal
function because it is not really num
rows that's being called it's the
decorator property if you remember
decorators they wrap the function they
do something and then they call the
original function that's what's
happening and let me switch over to my
text editor to do a slightly longer
example
I don't know
so there's no syntactic relationship
between num rows and they underscored
numbers it doesn't figure out that what
you really mean is this private variable
it leaves the implementation of the
property completely up to you and let me
experiment with that double callback
thing but let me also show the other
part of the property here we have our
address book class
and then the interesting thing about
properties is when you call app property
on a function at property does more than
one thing it does wrap the function it
also creates some new variables that you
can access and those variables are named
for your function and provide a list of
other decorators that you can use
to handle setting as well as looking up
so let's see if this works
that's what I thought the fact that I'm
getting it twice is an interface between
ipython and my Python between ipython
and Python runtime engine I'm not sure
why I patha why I python is echoing it
again but if i run it just from the
command line I'm initializing at the
same way I'm accessing my property
editor Lee prints at once and I could
say so it's an I Python thing and i'm
not sure why
okay let me come look at that in just a
second but let's also note it already is
10 I just said a number 0 equals 1 and
again if you think about the code that
I'm actually writing
it seems like I'm assigning to a
function variable and it also seems like
I have two deaths with the exact same
name but what's happening here is at
property has completely taken away this
deaf numrows function replacing it with
its own thing and is intercepting
attribute access to num rows at property
num rows setter is completely taken away
again my attempt to define num rows and
is replacing it with access to the
property number 0 and responding to the
equals operator there's some cool magic
going on behind the scenes the first
property encapsulation that I said was
too powerful is what the properties are
using and emulation to respond to
operators like the equal sign is what
those those decorators are using the
property decorators are using and would
be complicated to write them but we
don't have to write them and it's
relatively straightforward to use them
my first function is my the name of my
attribute and it gives the app property
decorator about half the time that's all
you need to all you need to do because
you just want to do something when
somebody looks up a value for instance
maybe if you're storing your records in
the database you don't keep a number
that says how many there are because
multiple programs could be using the
database and when someone checks num
rows you go ask the database how many
there are and you return the number but
again the in script doesn't know what
the actual implementation of num rows is
it can just directly use it as far as
it's concerned it's just a number on the
class even though what it really is is a
function that calls the database and ask
the database how many rows there are and
you can change how it works without
changing the interface that you present
to your using program sometimes you do
want to intercept setting it and setting
the number of rows doesn't make any
sense
carolee so don't get lost on that and
just demonstrating that anytime you
define the property any time you use the
property decorator it dynamically
creates for you new decorators that
didn't exist until you used it and their
name is at your property which in this
case is num rows and then dot and I
believe they're actually four of them
but usually we will just use dot setter
because what we want to intercept is
attribute setting as well as attribute
access and it works as I want it to work
I can say a dot num rows and it prints
out something's happening again I don't
know why it's printing twice but it's a
night python thing not a Python thing so
I'm not too concerned and it returns the
value and I can assign a new value and
again some extra code is happening but
it is setting the value so I've wrapped
some potentially complicated code around
what looks like direct attribute access
and what's really cool about this as
opposed to the Java way of handling
getters and setters is with the Java way
you need to remember to do this at the
very beginning the first thing you need
to do is write all your getter and
setter rose and lots of Java eclipses
lots of Java eclipses lots of Java IDEs
like eclipse will automatically let you
say here's my class and it's got ten
properties go ahead and make the get
name setname functions for all of them
and then i'll fill them out poof it
makes 20 functions for you because you
need to do that right away if the users
get used to saying dot name you've got
no way of intercepting that later on we
can directly expose num rows as a
property just a simple property
initially and if later on we decide hey
we need to change it we can use the
property decorator to introduce a
function into the mix and as far as the
user knows they're still directly
accessing that attribute we're not
forced to start from the very beginning
being as complicated as we'll eventually
need to be we can change the
implementation later on but the
interface to the user still just looks
like Dex
as far as they know they're just looking
at an attribute on your object just one
to get it the first one basic but
usually but if you want if you want to
get it and set it to i believe the
property decorator automatically creates
a couple of other decorators for you and
let me look that up in my Python on a
nutshell so that I steer you exactly
right because I never use the other ones
yeah that's why I didn't reviews I it
there's also a decorator for deletion
and that handles if you say del the
built-in function del lets us actually
delete variables so we can delete
variables from our local namespace we
can remove variables from a list we can
delete variables out of our dictionary I
know I've done that with a couple people
how if you actually wanted to get
something out of your dictionary you
can't just assign it to none or a blank
string the key still exists if you want
to get rid of it you can say del dicked
brackets label and it's gone there's a
property that allows your attribute on
your object to respond to the adelle
function as well I've never done that I
don't know why you would delete an
attribute on your object since in
general you want all of your objects to
have a consistent interface but you can
do it and there's also one for doc so
you can handle retrieving the doc string
on your property and I haven't used that
one either so yeah most of the time you
just need to write two functions one for
getting one for setting yuly you're
trying things along as you go and are
they working they're working fine okay
there is one other emulation topic and
this one I'm really going to skip so the
first one I said was so powerful you
rarely need to use it and it is the get
a derp underscore method and that method
will get called every time you access
any property no matter what its name on
your object and allow you to do anything
you want and we usually like we don't
want that most of the time I mean
usually we've got functions we want feel
just to call them we've got some
attributes want people just to be able
to access them it's too powerful the
middle ground is the property
decorator that we're using and so just
for the attributes that we're interested
in preserving protecting so for instance
this way you can make read-only
attributes right you could store numrows
as an int but you could leave off the
function that assigns to it or you could
write the function that assigns to it
and have it return an exception that
says I'm sorry you're not allowed to set
num rows that's a read-only property
alright so we can modify access to a
particular variable by writing our
property functions and using the
property decorators and then there's a
final emulation are there's a final
encapsulation method called descriptors
and descriptors basically involve making
the attributes of our class a special
kind of class Python defines for us that
once again lets us wrap access to our
class and some other functionality and I
find descriptors again usually to be
overkill they do change how your object
is inherited and that's handled
differently from properties which is one
of the reasons for using them but we
don't know what inheritance is yet so I
can't even discuss why you might
possibly want to use descriptors and
it's finally time to discuss inheritance
so the second part of
think about the classmate project that
we've been working on and we have Rosen
and address book and every row is first
name last name and roll let's say you
wanted to use this to organize all of
your contacts in your life Facebook
friends your Google+ friends your family
your cell phone numbers maybe a lot of
data and the data wouldn't look the same
necessarily like for a lot of people you
want to store things like there Twitter
account their website their phone number
and for cell phone contacts the most
important thing is probably their phone
number on the first and last name for
family maybe you want to print the
relationship and their first and last
name for celebrities you're keeping in
the database maybe you want to print
notable information about them some sort
of bio so all your rows might look
different and kind of with the single
row object that we have the way we could
handle that use case is to just start
putting lots of fields on our row right
every row could have a first name last
name Twitter website home number cell
phone number relationship but when you
print them out if we're using the diner
score string method to get a string
representation they'd all print out
exactly the same way and be really nice
to print differently depending on what
kind of object they are we can start to
do that since we're using a method by
saying okay what kind of object are you
and I'll use a different format string
in different fields I could get a little
bit complex really basic to and kind of
the second major reason to use OOP the
first reason is hey we can group some
methods and some data together the
second reason is we can create
hierarchies of related objects that
share functionality that's shared but
that implement functionality that's
different themselves
what I do I'm defining a class like we
have been and I said every class should
take object the parameters that you pass
to your class definition are the objects
that it inherits from and I'll explain
what inheritance is it is a valid Python
statement to have a class that doesn't
inherit from anything but that's only
there for backwards compatibility I
believe it's removed in three Python 3
and originally in Python like in many
programming languages there was a
distinction between base types and
complex types base types were not
objects and complex types were objects
that turns out to make things clunky for
the user and Python the language was
changed that every single type in Python
inherits from a base type of object
everything is an object and that
unification is really nice this
definition of row without a objectin tax
error but it gives you an old-style
class that's slightly different than all
the other classes all the other objects
will produce objects are slightly diff
and then all the other objects and is
always an error so you should always
inherit from object or another class and
my second class I made a class called
student and it inherits from row what
does it mean that it inherits from row
you
okay exactly right ro get the right
console here row except some data
with an init function and sets a local
member data you notice my implementation
of student I didn't actually do anything
at all besides inherit from row so far I
didn't even provide an anit function
and yet i'm calling the init function
and passing it data and the data exists
so how inheritance works is it modifies
our look up so on an object if i call a
method it looks in its local namespace
to see if the method is defined if the
method is not defined it looks up the
inheritance tree to find the method and
if it exists it calls it so for instance
when I say stir s what python is doing
is saying okay I have an object it's of
type student it's had the string
operator called on it so i'm going to
call its underscore underscore STR
function it doesn't have an underscore
underscore STR function but it inherits
from row I'll look in row and see if it
has an underscore underscore STR
function row does not have an underscore
underscore STR function row inherits
from objects so I'll look an object Oh
object provides the default
implementation of that Dunder score
method is just to print out a
programmable representation it's
actually calling wrapper which tells you
that this is a module OOP class student
instantiated object and print its ID ok
this is method delegation and it's a big
part of the point of inheritance we will
also share variables but we'll be
sharing class variables and I made one
comment earlier the reason we have class
methods and the class accepts the class
that it's attached to the class method
accepts the class that it's attached to
as the first parameter is because it's
possible that you have a function that
doesn't know what class it's being
called on
and that's because when we call a method
on an object we might not get a method
that was defined on that object we might
get a method that was defined on an
object someplace up the inheritance tree
so let's do a couple things with
inheritance here if the point of this is
to make rows that are different types
and accept different fields we could
define in its for each type and accept
only the specific fields we want but
that would mean initializing like like
this
but that would mean that people would
need to know how to construct the
different instances of our objects they
know about our implementation so let's
not supply any in its
so I'm barely implementing things here
but I've made a default class called row
it's an it just accepts and the tuple or
the list that we've been reading and
writing from now it seems like a
convenient data interchange format
because we're going to get a tuple or
list from our CSV file or from a
database I'm just going to store that
data we could use properties to give us
convenient access to the data when we
started to rewrite our address book
program our classmates program with
objects we noticed it's a lot more
convenient to say if you know Rho dot
role equals role than to say if row
brackets 2 equals role so we like having
names let's preserve the names that
doesn't mean that we actually have to
load the data into the proper field we
can just use property to expose the
appropriate index student is going to
work the same way presumably we'd right
properties to set the first name as well
a property for a last name in a role
celebrity has got a property Twitter
it's going to return the fourth column
of our data and we're not defining that
for student or four row
yes
you're going to break up the deal
so what I would do well yeah I can do
this I'm not super concerned about the
whole module level versus top level
naming structure because what I would
probably define is the dictionary that
map's a roll named to the appropriate
row object and any role names that
aren't found should just be default rose
and then when I get a new line as I read
my data I can look at the role and say
is this a role I have a special class
for if it is let's make any one of those
if it's not let's just make a default
row so I can store functions and data
structures I can also store classes and
data structures and just like we made
menus that had a key base look up and
you call the appropriate function I
could make a dict that has a key based
look up and instantiate the appropriate
object by storing the class as a
variable one class has to be defined
before it can be inherited from another
class load of the classes do matter if
we're doing inheritance it is CSS has um
CSS has classes they're not boob style
classes but they are things that denote
categories of objects which will have
implementation details in common it also
has IDs and that's a little bit more
like a specific object so you can write
Rho write rules and CSS that are common
to all objects of a particular kind and
then you can customize the details of
the first and the last one and the one
with a particular name yeah it's the
same sort of technique we're writing
code that's going to be similar for all
of them on our row
encoded it might be specific to the
implementation of this particular kind
of thing right on its object
so remember how much the delegation
works if I try to convert a celebrity to
a string it's looking for the underscore
underscore string method on that object
itself if it finds it it calls it yep if
it doesn't find it it will go up the
inheritance tree and this is this is a
good quick point the code that I have up
again this isn't syntactically enforced
but you'll run into problems when you
try the property function but just use
the plane property decorator obviously
has self the mandatory first argument
which is the reference to the object and
the method is attached to but the setter
will be passed an argument and if you
don't supply X here when you try to set
it you'll get a error it'll say I tried
to call a function and I tried to pass
it to arguments and it only accepts one
and that'll look kind of weird to you
because you think you're just setting an
attribute so that error message isn't
super helpful but underlying everything
it's calling this number whose function
and trying to pass it in argument so
last last thing here on classes before I
turn you loose to work on labs foil is
that sadly we can inherit from more than
one class at a time the syntax for doing
that is just a comma and additional
types and you can inherit from as many
classes as you want the main
complication this provides is that
method delegation now gets more
complicated when I say call a method on
my object and if my object doesn't
implement it look up that object on all
the classes that I inherit from it has a
particular order
it goes as you would expect in order of
declaration so the method resolution
order mro you'll see that abbreviation
sometimes is depth first and from left
to right if you don't use multiple
inheritance or you only use it in one
limited use case which I'll explain in a
moment you don't need to worry about
this if you do try to use multiple
inheritance you will inevitably at some
point get to your calling a function you
know that it exists in some object that
you're inheriting from but you're
getting some other objects function and
you're trying to figure out why
ok
ok
notice I'm also getting a violation when
i try to inherit from object and
something else that's inheriting from
object and it complained about my mr oh
that's that method resolution order and
basically if you're inheriting from
another new class that already inherits
from object you don't need to inherit
from object yourself the only reason we
inherit from object is to make clear
that we're a new style class everything
is an object but if I'm inheriting from
object it's not just redundant but wrong
to say my student is an object than it
is a row because row is an object as
well I can however inherit from two
classes this is a stupid example because
there's no point to saying a celebrity
is a student and as an address book I
don't think I did it nevertheless so if
I say this that's multiple inheritance
from object which is the built the
built-in base class and row but row
already is an object and the only reason
we provide object on our list of
inheritance is to specify that we're a
new style class so if we inherit from
any other class that is a new style
class we don't need to inherit from
object we do but we also inherit
everything that row itself inherited and
row inherits a bunch of methods from
object so when I say when I say I
inherit from object and I inherit from
row it's a duplication and it's noting
that when I go to look up methods
it does and it's basically why object is
sort of a special case it's the only one
Python will do the this checking for
although will complain about the method
resolution if you make some other
obvious multiple inheritance mistakes
because object is the base class for
everything so since I said celebrity is
a student and an address book
if I'm confused about how it's calling
methods and saying which method is
actually being called here I can look at
the dunder mro item on my class and it
gives me a list in order of how it would
look up methods so if I call any random
method it will first look to see if that
method belongs to celebrity celebrity
inherits from student and a B it goes
leftmost and says okay I would look at
student next to see if the method is
defined student inherits from row it
goes left most in this case there's only
one but it goes leftmost and depth first
and looks down to row if it still didn't
find it it would come back and take the
next class in line why didn't go to
object if its depth first again object
is a special case object is the base
class it knows when it has reached
object that it will stop so it comes
back and takes the next class and looks
in a bee a bee doesn't inherit from
anything else just object and its looked
at all of my multiple inherited classes
so it will check object and stop so you
can look at the MRO to see exactly how
it is that python is figuring out which
class your method should be called from
but if you ever find yourself looking at
the mro to figure this out let's clear
sign you're doing it wrong people argue
as to whether multiple inheritance is a
good idea or a bad design decision and
some languages outlawed completely so
Java for instance is a very object
oriented language much more so than
Python everything is an object in Python
there is no concept of simple types
exactly
there is no procedural programming in
Java but Java has only single
inheritance I would encourage you not to
use multiple inheritance except in one
limited use case which we'd call mix-ins
mix-ins are not syntactically defined
but the idea is you might have some
functions that you want to apply to a
bunch of different kinds of classes
method resolution order so for instance
we've kind of talked a couple times
about logging you might want your class
every class whether it's um dress book
or whether it's a row or a student or a
celebrity to have a function called
laget and you could get that by having
them all inherit from a new class called
logging class this does not imply that a
celebrity is a log in the same way that
it implies that celebrity is a row
you're using inheritance typically to
group things into hierarchical
relationships a celebrity is a row a
student it is a row that relationship
indicates fundamentally what it's type
is if you inherited from a log in class
you're not really indicating that it is
a log and you might not share any data
whatsoever you might only provide a
couple of utility functions other
languages have special syntax for this
kind of inheritance and call it a mixin
and sometimes you'll hear Python
programmers say well I'm using multiple
inheritance but this other classes is
basically just a mix in and what they
mean to say is that class defines
functions that no other class will it's
not going to have any mro confusion it's
just a way to get a function on to this
class that I want to call and that's
kind of a safe use of multiple
inheritance if you draw diagrams of your
class hierarchy and every class is
inheriting
three different kinds of classes you
will get in trouble you will find points
where you can't figure out what's going
on and multiple inheritance is just
basically dangerous so use single
inheritance maybe occasionally use
multiple inheritance just for a little
extra functionality on your classes but
primarily things are one kind of thing
proceeding up hierarchically not like
four kinds of things for your own sanity
sake okay so that's all the oop syntax
that we need to do I'd like to turn you
loose on our lab for a little bit we can
complete what we were starting yesterday
I was kind of getting around to
everybody which is refactoring our
address book to use objects yeah so with
mix-ins I'm just saying it's not
fundamentally expressing a relationship
where all access lots of stuff based on
the base classes with inheritance you're
usually saying like most of my
functionality is in the base classes and
then I'm customizing or overriding the
little bits that are specific to me with
a mixin you're actually saying I'm not
customizing overriding anything and all
the functionalities on the base class
and I just want to grab a couple of
functions and add them to my class it's
more like addition complimentary things
yeah cubbies Carla mixing yes yes yes
and you could always do that by
composition of objects which is you
could pass all these different kinds of
objects a logging class in there init
function and they could all have a
single function that called the logging
class to do whatever logging it is that
you want to do but that's a little bit
of extra glue code so if you just wanted
to inherit from a mix in class that
might be okay an acceptable use of
multiple inheritance that won't come
back to bite you in the butt too badly
probably
so I was going to have you I was making
the rounds and some of you are well
started on using objects in your address
book for those of you who are well
started I'd like to suggest that you try
a little bit of inheritance so I'm going
to put two assignments up if you're
still working on the first one that's
fine if you feel like you've got a
handle on lab 15 anyone move on to lab
16 that would be great and I'll come
around and see where everybody is the
point of lab 15 is basically we were
refactoring our program to use objects
you can decide whether you go address
book should be an object or not but
definitely your rows should be an object
and they should know how to do things
like sort themselves and print
themselves and I might talk about that a
little bit further knowing how to sort
themselves as a matter of implementing
the underscore underscore cmp for
compare method and if you do implement
that method and you call sort on a list
that contains your objects the CMP
method says given to my objects which
one should be first or last and you can
do things like simply return a
comparison of the last name and then you
could sort your list of objects by last
name just by calling sort on your list
that contains them optionally I guess
the address book should be an object
that knows how to print itself and add
new rows and then if you want to get
slightly more adventurous with lab 16
let's add some fields let's add some
types let's think about storing more
than just students and instructors in
your address book and you might have
different representations and be
interested in different fields so play
with inheritance a little bit to
implement that
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>