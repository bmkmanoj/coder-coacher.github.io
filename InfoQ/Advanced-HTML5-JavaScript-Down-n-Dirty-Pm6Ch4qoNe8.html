<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Advanced HTML5 JavaScript: Down 'n Dirty | Coder Coacher - Coaching Coders</title><meta content="Advanced HTML5 JavaScript: Down 'n Dirty - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Advanced HTML5 JavaScript: Down 'n Dirty</b></h2><h5 class="post__date">2012-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pm6Ch4qoNe8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm thrilled to be here so I'm a
software engineer for Zynga and we're
actually up here on our work week and
I'm flying home tomorrow so I was really
glad we got a chance to kind of squeeze
this event in San Francisco you guys are
an awesome town like I've been here a
few times but I'm just blown away by the
response to an event like this like I'm
nobody and you guys came out to hear me
so that's pretty awesome
so I have been doing JavaScript
development for a long time as a matter
of fact I sort of self described myself
as a JavaScript snob so there's a lot of
people out there that feel like they
want to be polyglots and into a whole
bunch of everythings and I'm the
opposite of that I focused entirely on
website technology in JavaScript and I'm
pretty much bored by anything else
so if that's if you hear that
perspective and what I'm talking about
tonight
that's why I've written a couple of
different open-source projects that have
gotten some traction namely one there's
actually one that I believe at least at
one point may be still true being used
by formspring is lab j/s say javascript
dynamic loader if you're interested in
that sort of world and want to ask me
questions about that please feel free so
we'll jump in that this this website
getify dot me that has all of my contact
information except for my personal cell
phone but every other piece way that you
could possibly get in contact with me
it's up there so if you have any
questions afterwards or even during but
I won't answer during but if you have
any questions just feel free to grab one
of those your prep for preferred contact
off of that site so as they alluded to
html5 cookbook just came out back write
the like the day after Thanksgiving it's
already doing we're pleased phenomenally
well and I encourage everybody if if you
have not gotten a good html5 book just
take a look at this one it's available
in eBook form we've got discount codes
we put a lot of work into it this talk
actually came because doing the the
JavaScript have
lifting for this book as my co-author
came to me and said hey I need somebody
to do some JavaScript and I said sure
I'm into that and I said I'll take over
the JavaScript part and we got some
other co-authors for some of the like
the more boring stuff like articles and
sections and stuff like that that people
don't care about but so I did the
JavaScript part and and one of the
chapters in there is advanced JavaScript
or really kind of dive into some of the
more heavy lifting of the api's and so
out of that came this talk I decided to
figure out a single demo that I could
build from scratch that would weave all
these different api's into one because
what was frustrating me actually writing
the book was we were using all these
disjoint examples she had an example for
history API and a totally different
example for something like local storage
and it didn't seem coherent and and
that's actually one of my regrets a
little bit from from the book is that
unfortunately some of those examples are
disjoint but that's the reason for this
talk is we're gonna actually build we're
gonna talk about the building of a
single game it's a multiplayer online
game it's the server is not currently up
right now but at the end of the talk I
will put it up and if you those of you
that have laptops if you want to connect
and play we can have fun with that but
we're gonna talk through weaving several
of these advanced api's together into
making a game this is going to be
extremely JavaScript heavy and code
heavy some of this code may be because
of the lighting may be a little bit hard
to read I'll try to explain some code
but they will have the code the the
slides up on line so you can refer to it
later if you want to so well without any
further ado we'll jump right into the
code and we're not gonna see any kind of
semantic tags this is all JavaScript the
code for today I forgot to mention the
code for today will be available is
available up on github all this stuff
both server-side and client-side this
web address you know the only part that
you need is the part that's embolden and
uppercase letters 5vl dot getify the
other parts just gravy but that will
take you to the github repo and now
let's jump into some code so we're gonna
first talk about canvas so this
particular project I'm using canvas it's
not in the traditional way that you
might expect for canvas is that a little
easier for people to read okay great
this particular project is not the
typical one drawing are
and gradients and stuff like that this
I'm using some of the more in-depth
features that don't get as much coverage
things like global composite operation
and things like that so what I'm using
it for is a couple of different things
in this particular case this code build
preview grid I call this function when
you have uploaded an let me back up and
explain what this game does so you have
some context this game is a multiplayer
puzzle solving game you upload an image
it slices it up into a bunch of
different tiles mixes them up and then
people collaboratively you can see
people dragging pieces around and you're
trying to put pieces in the correct
location as quickly as possible so we
have a preview grid when you are
uploading an image and it's a it's an
overlay on top of the image element and
it simply shows you based upon the
difficulty setting where that grid where
those slices are going to be made so
rather than just simply draw some white
or black lines on top of the image what
I realized is that people are going to
upload light images dark images it's
hard to figure out it's hard to inspect
that image and figure out what line
color to draw so I was trying to figure
out a way that I could sort of
superimpose the image of this grid on
top of an image and when I came up with
was global composite operation in canvas
so essentially what I do as I to draw
the grid I'm using if you see light line
300 and also line 303 so I'm instead of
drawing lines I'm gonna draw rectangles
that are one or another two pixels wide
so I'm essentially drawing lines but
with rectangles and the reason for that
is I want to use them as a clip or as a
clipping mask as it's referred to that
essentially means that I want to draw
something on to a canvas but only in the
place where the mask is and not anywhere
else so I'm gonna draw the grid as a
mask and then I'm gonna draw something
on top of that and it will only draw
into those grid lines what am I gonna
draw on top of it is the image itself
and I'm gonna do that twice the first
time I'll lay it over and then I set the
global composite mode which i think is
in the next slide I set the global
composite mode here on line 327 to
lighter and then I do the exact same
thing again what I get is the effect
it's the exact same image data but it's
been lightened by half and that's
overlaid on top and what we'll see here
we go.we so context raw image is how we
draw on from an image element into
a canvas element I will have a
screenshot here in just a moment I'll
come back to this so you can see here
when I have this image I don't have
actual lines what I have is the
effective lines by lightening those
pixels using the global composite
operation so let me go back actually to
some code there's a couple of other
places that I'm using a couple of other
ways that I'm using canvas one is to
slice up those tiles so I have one big
image and I can calculate I use some you
know fancy math to calculate where how I
want to size things and I want to slice
up all those tiles but how do I get that
image data out well there's a function
to get image data out of a canvas
element so if I draw an image into the
canvas element and I can give it
coordinates so I'm simply gonna loop
through I think that is I'm gonna loop
through and use context draw image on
line 259 and I'm gonna grab only those
slices one at a time so I loop through
one at a time and grab the data out of
the canvas element and get it as a data
URL that way I effectively split one
image up into 20 30 50 separate images
so again canvas has these really helpful
methods and it's kind of fun you find
yourself sort of jockeying between an
image element and a canvas and back and
forth because the image element has
width and height properties that you
want to read about an image and the
canvas element allows you to grab the
data and manipulate the data so I find
myself in this project kind of drawing
it into an image element back into a
canvas and so forth kind of swapping
that but once you get the feeling for
that it's actually really powerful to
manipulate image data this is what it
looks like once the image has been
sliced up you see the tiles there
they're all mixed up and then you drag
those into the grid okay so the next API
that will jump into is app cache and let
me give you a giant caveat Before we
jump in and explain app cache I don't
use app cache and I don't like app cache
I think it's kind of a sucky API I think
it's got a lot of problems before it
gets to the point where it's gonna be
useful but I thought it was useful for
us to actually learn what it does and
what are the pros and cons cuz if any of
you do mobile development you've
probably heard a lot about using app
cache it's one of those buzzwords and
mobile development it's probably useful
and desktop development too but
certainly more so for
so the theory behind appcache is that
the caching that we have in browsers is
too volatile and too unreliable for the
types of things that we want to do in
these really complex web applications
where we're shoving sometimes 8090 even
a hundred percent of the code down
through the browser through the wire to
the browser and we're relying on all
that code and all of that code to be
there to be available and if even a
single file is not available
the whole applications gonna break it's
like getting a corrupted download of an
app so app cache says well we need to
solve that problem we need to create a
more persistent - more reliable caching
mechanism and there's a couple of
offshoots that happen in addition to app
cache kind of giving us the ability to
make sure we can rely on the cache and
one of those is related to the online
offline status so you'll see down here
at the bottom of this file which will
explain them oh but there's a fallback
section it was brought up that perhaps
this game could have sort of a fallback
mode where if you're not online you just
fall back to single player mode sure in
this case I probably just would have an
offline HTML and say hey you need to
have a connection to you to play a
multiplayer online game but in some
cases you may have fallback content and
you would you would list what the
browser should do so in the offline case
the browser would use that instead of
one of the other resources that you had
provided so this file is I I named this
file cache manifest text you can name it
whatever you want and the important
thing actually which you'll see later is
that it has a content type very specific
content type
but this file is what we create to tell
the browser all of the resources that
are actually really critical that we're
gonna download and make sure that the
browser caches in this special app cache
and so we list them in the cache section
and then we have a network session
section starting there on line 17 you
can see that I just have that star there
essentially I'm saying every Ajax
request that I make needs to be
available if you do not specify a
location in an app cached application if
you don't specify an online location
that you're going to make network
requests to in this section the browser
actually won't let you connect so this
is one of those other offshoots it's
almost sort of a pseudo
purity thing that it will not let an
offline application or even an online
application connect to one of those
network locations unless it's explicitly
listed here
I took the lazy Road and explicitly
listed star so that I get everything but
that's another thing that you can use
the network section for but the main
meet that we're dealing with here is the
cache section we're listing all the
different things that we want to make
sure and you can see I have the absolute
address for jQuery and then I have my
other HTML and JavaScript and CSS files
this tells the browser create a special
cache that's not subject to the normal
rules of expiration that the caches are
subject to it's not subject even to
clearing through the normal methods of
clearing a user actually is to take a
special step in their browser and in
some browsers you can't really quite
clear it it's not that easy but it says
make sure that there's this special app
cache in place to hold all of this stuff
and so that sounds well all well and
fine that sounds actually really good
for us because we know that the browser
will make sure that's available every
time the user opens their page the
problem is the reason I don't use app
cache is it's actually really really
good at what it does it persistently
caches it so well that it's really hard
to update resources so let's say I have
this list of resources and I change a
line in my JavaScript file most of us
are probably familiar with the shift
reload paradigm where we shift reload or
even clear our cache and we make sure
that we get that new version of the
JavaScript file not true with app cache
you can change those files all day long
on the server they're not going to get
every downloaded to the client there's
only one way to force the browser to
revalidate those resources and that's to
change the manifest file well what if we
don't want to change the manifest file
because we're not adding files we're
just changing the contents of files so
it came along online to the kind of the
best practice if you will is to put a
comment in there and change the comment
cuz if you change the comment in that
file that's enough to let the browser
know hey I should get the new contents
of the file and therefore go and
revalidate all those resources so this
would be something that you would hook
up into your build step for instance you
would write out this file and you'd
write out a new version every time you
built your application or something like
that that's unfortunately just a reality
of the way app cache works and you have
to force that but there's even yet a
further
application which is yet another reason
why I don't like appcache that much the
complication is this let's say that a
user has your application open and you
change a file and maybe you publish out
some sort of update and you tell people
Hank go ahead and refresh your page so
that you can update it now I've changed
the manifest file the browsers going to
download it everything's going to be
cool they refresh it and they still have
the old version of the file and you're
like what the hell why would they still
have the old version of the file and I
changed the manifest file the reason is
this the browser in the loading of the
page it will see that there's a new
manifest file in it and it will do its
due diligence to go and request all
those files in the background while the
page is loading but it says well I
already have a good version of these
files so I'm going to go ahead and serve
the page with the old version of the
files and in the background load the new
version of the files so you actually end
up having to refresh the page twice to
get a new update to code and I don't
know about you that do development and
web applications but I don't like
refreshing once so I'm definitely not
going to refresh twice that's why I
don't have application up while I'm
developing this application there are
the reason why we're covering this
though is that there are ways to get
around this a little bit they did give
us somewhat of a helpful API but before
we get to that the way you hook up a
manifest file you say up online to the
HTML tag we set a manifest attribute we
give it a URL to our manifest that's all
you have to do now the browser is in
this special app caching mode so I don't
I do not have that in mind if you go and
do a view source this will not be in
mind yet but that's how you would hook
it up does give us a JavaScript API to
help us get around this and what it does
is it allows in JavaScript for us to
forcibly tell the browser go check and
see if there's a new manifest file
instead of waiting for a refresh we can
actually do so with JavaScript so what
we can do is we can say let's see its
line line 52 cache dot update this tells
the browser to proactively go and check
and see if there's a new version of the
manifest file and if so start
downloading those resources as soon as
it finishes downloading the new version
of those resources it will file the fire
the event update ready and it'll let us
know that those updates are there and
they're ready in memory so in this case
what I'm doing is I'm saying I might
hook this function up to run once every
30 minutes just to check to see if there
are any
and to my application something like a
gmail for instance and they have that
thing running just on a 30 second I mean
a 30 minute cycle in the background for
people that leave the application open
for a long time but I don't want to
refresh the page without them knowing
they may be doing something and lose the
work so I just pop up a little confirm
box that says hey there's an update
available would you like me to be
helpful and go ahead and refresh the
page yesterday if you instead have you
know an application button inside of
your web app that was a refresh button
that allowed a user to proactively do
that then you could do away with the
confirm because they've already told you
they want to refresh but this is the API
that we get we get one event and we get
this cash that update which forces this
ends up giving us the behavior of
getting a single refresh instead of
having away for two refreshes but it's
still kind of awkward still difficult to
deal with so my recommendation use app
cache once you're fully production ready
for an application don't use it before
all right
well jump into local storage and session
storage next a local storage and session
storage are the exact same API the only
difference is other than the name the
only difference is how long the browser
maintains or persist this data session
storage unsurprisingly maintains that
data only for the session and it defines
that session in most cases based upon
the lifetime of the tab that the
application is running in so as soon as
you open up a new tab in a browser
that's a new session as soon as you
close a tab that session dies so you
have in the cookie world when we did
cookies there were this concept of
session based cookies browser session
based cookies that would die once the
browser session died same concept the
local this this session storage will be
cleared out it won't be available once
you have ended a tab session that does
mean however that somebody can't share
between multiple tabs so if they're
logged in the same application across
multiple tabs those are different
sessions and they're not going to be
able to share that local storage on the
other hand is fully persistent storage
both these api's give you five megabytes
local storage will stick around forever
so you actually probably want to do some
sort of rudimentary expiration mechanism
or at least carefully manage your data
so that you're not just filling up
somebody's data so for instance if you
had an app that they used and and
a couple months you changed your scheme
and wrote out different key names if you
don't clean up after yourself you're
gonna end up just leaving a bunch of
extra data in that person's local
storage unless they're diligent about
cleaning that out so be careful about
that in this application I'm using them
for very simple tasks for the session
storage I'm keeping track of the
person's session that they've
established with the game server so that
when they refresh the page they don't
have to real aughh in so that's basic
I'm keeping track of session storage
that login session is lost if they close
the tab or go to a different browser but
at least across refreshes it will keep
them connected or be able to
re-establish the socket connection right
away local storage I'm using for a very
simple tasks to maintain the users name
and email address in the login form so
they don't have to retype it so as soon
as you've typed that in it stores that
in local storage and will keep that
across sessions even though you may so
when you come back and it says you have
to login you don't have to retype in
that data so again very basic usages one
caveat on local storage and session
storage API on this kind of the
performance side of things because I'm
also a performance geek these are
synchronous API and for those of you
that don't understand the much of the
difference between synchronous and
asynchronous from a browser vendor
perspective I used to work for Mozilla
before I worked at Zynga from a browser
vendor perspective asynchronous API is
the worst possible performance that we
can get so the browser vendors all sort
of cringed when the people that design
these things came up with synchronous
api's it's nice and easy for us because
we just call get item and it immediately
returns us the item
it's lots and lots of pain for the
browser vendors because they sometimes
many of these browsers like Chrome for
instance they have multiple processes
and your storage may not actually be in
that process that may be inter process
and creating synchronous communication
across those things is horribly
inefficient so the moral of the story is
do not use local storage in session
storage in performance sensitive code
for instance inside of a loop where
you're throwing a whole bunch of stuff
data into something because that will
lack very quickly you can like you would
never want to use that in something like
in an animation you know I don't know
why you would do it but you never want
to read or write from a from local
storage or session storage when you're
doing something time-sensitive like
animation but in this case we're just
doing a single read and write
refresh so it's not a big deal just keep
that in mind the synchronous API makes
it easier for developers to deal with we
don't have to have callbacks OOP but it
has the negatives that unfortunately we
have this performance implication two
browsers I think I've already covered
this but we have local storage dot set
item to set in some user info we have
get item to get it out and remove item
to delete it's pretty straightforward
it's gonna be the same thing this is
what it looks like for you know it's
remembered that my name and email
address is there in the forum for me
tells me that I need to login okay so
next we're gonna jump into the history
API history API means that we have taken
several big problems that we had with
history management in the browser and we
fix them across a couple of different
api's in the application and by fixed
them I mean we found all these problems
that we've been dealing with for years
like the hashbang ridiculousness and
actually fixed it so that we could do
the things we need to do in an
application so you know in a basic sense
the biggest problem that applications
have faced is that we got into the Ajax
era where we realized we don't want to
create a new page refresh every time
there's new page content that's being
asked for but when we did that when we
said hey we've got this you know this
nice ability to Ajax some data from the
server and we're not the page refresh
but we do want the user to see the
update in the address bar we do want for
them to have backward forward capability
because that's useful and we do want to
for them to be able to bookmark a URL
save that URL and come back to it later
and we lose that when we have this whole
Ajax concept so we got this whole idea
of storing the state of a page in the
hash of that URL because you can change
the hash without causing a page refresh
and this worked okay but it created lots
of other bugs and lots of other problems
so html5 came along and said let's fix
these problems let's give the existing
API is the capability they need so that
you're not even you do that kind of
stuff anymore so now when i HX request
some data on the page in this particular
game you click on a link to go to the
login page for instance the address bar
updates to say login HTML but we didn't
do a page refresh to login dot HTML we
simply went and requested that over Ajax
using a normal Jake
Corie ajax request for instance we got
that content we replaced the content in
the page and then i told the browser to
update the address bar and that's very
simple to do this ajax link function is
how i hijack all those links and you see
the bottom line is unlike on line 30 I
called go to page if this is a link I
want to hijack so go to page we have
here I'm asking if it's already and sort
of in my in page cache so I have to keep
refreshing it I kind of manage an in
page cache if it's already there I use
it otherwise I go and head and request
it using an AJAX request post injection
is the function that's going to call our
our history API so we'll look at post
injection before we do that here's what
this looks like you can see that I've
gone to the login page and I have an
entry in my history so I can click back
and go back to the home page from the
login page I have an entry in the
history I have the address bar updated
I've blurred out that address because I
don't want you guys playing the game
that don't you pay attention to I talk
but we'll get to the game later but it
has the entry in that history and it
would work for both backward and forward
a history entry just like we want
here's post injection so post injection
says ok we have we have already updated
our content now we just need to take
care of the history management and
you'll see online 82 and line 85 is
where it does uses either replace State
or push State a replace state means what
it says whatever the current address
entry in the browser replace it with
this new thing that I want here's the
address URL that's the third parameter
to the call update the address bar and
update the entry the existing entry -
what I'm asking you is this new State so
I use replace state when I am making the
login page what is called an
interstitial when you navigate to the
login page you can click backward and
forward as soon as you have logged in
now I don't want login HTML to be part
of your backward forward history because
there's no reason for you to ever go
back to that page so as soon as you're
finished logging in I replace the next
page refresh I replace on top of login
dot HTML and you end up being able to go
directly from the home page to a login
page so that's what replaced state is
and push State unsurprisingly adds
history state to it so history dot push
state in history
replaced eight are actually calls to an
API called history Jas this is a shim
for browsers that don't have these new
functions they implement it and they
fake it in some in some other ways for
you so I highly recommend using history
Jas makes it totally stupid simple to
use and they give you but these are
underlying functions that you would be
able to call in the native API if you
felt so again here's what it looks like
after I've already logged in I only have
two entries from we puzzle it into the
in the for advantage because I've
replaced the login page with this page
the last thing that we need to do to
deal with history API is that we need to
be able to respond when that when that
URL changes outside of the control of
our code but we just saw in the previous
slides was when we are specifically
having the user that we're responding to
a user clicking something and navigating
them to a page and we want to update it
but what happens if the user clicks the
backward or forward button or the user
paste in a URL from a bookmark or
something like that we want to respond
to that as well
we simply listen for the event you can
see on line 38 we listen for the event
state change and then we go ahead and do
the underlying work so whichever one
comes first the underlying page refresh
happens and then we update the history
or the history changes and we update the
page either way we can take care of it
and these are additions that have been
added on to native html5 history
handling and again history is a very
nice API to manage it next one of my
most favorite topics that we deal with
WebSockets how many of you are familiar
with what WebSockets means ok good a
fair amount of yet say like sixty
percent of you great so I use a a
library sort of a shim just like history
j/s I use a library called socket dot IO
it implements sockets both on the server
as well as in the browser in the browser
it has several different fall backs if
the browser doesn't support sockets that
uses like an invisible flash socket and
several other workarounds for sockets
long pull Ajax and things like that and
on the server it implements the latest
version of the socket protocol so it
takes care of all the server things it's
implemented either in nodejs they've got
ports to python and java and c++ and
other things like that so whatever your
back-end is there's a good chance you
can probably get a port
socket IO but it gives you the exact
same API for listening and subscribing
to events and omitting events that's all
this is is a two-way communication
between your browser and your server to
send events back and forth instead of a
one-way channel we have a full duplex
two-way channel we listen to events and
we send events and they can be any
events we want custom name events so you
see here I'm knitting a session online
8:25 I'm listening for the disconnect
event online 818 or 819 whatever that is
that's the line where I'm connecting
it's very simple and I start listening
for events with socket on and then we
see socket emit online 868 socket autumn
it is how we send an event so this is
happening in the browser this so we
listen for events from the server you
can see I just have you know custom
names for these events there's nothing
special going on and I can send JSON
data back and forth between the server
and the browser it's fully asynchronous
and very performant it's actually
surprisingly performant if you play this
game on a good you know internet
connection you'll see it's unbelievable
to think that literally thousands of
messages a second are traveling back and
forth between the server and the browser
and you don't see any lag it also so
here I'm omitting of akut event to say I
want to actually I want to ask the
server to validate my session and I'm
gonna listen for some responses like new
session or whatever again if when we do
socket dot on that's adding an event
listener you're probably also familiar
with removing event listener so you can
clean up after yourselves and it's
socket remove listener so it's a very
simple API if you have ever done any
kind of event oriented programming in
JavaScript most of you probably have
responding to click events it works
exactly the same way you don't even have
to think about it it's just very simple
this is on the server and you'll notice
that this code looks a lot the same of
course I'm using JavaScript and node.js
which is nice but this code the API
looks a lot the same safe socket dot on
socket dot Ahmet just like I have in my
JavaScript code this actually allows you
if you had the opportunity and you know
and you could work the code the right
way you literally could use the same
code in both places again some more
socket done I on I've got a line 362 for
instance there's some fancy stuff that's
supported only on the server I'm
listening to a channel called site so I
have two different channels of my
socket connections actually that's a
namespace called sight and then dot in
game and game ID on that line is a
channel so that's a way to partition out
your messages so if you broadcast a
message it doesn't have to go to
everybody it can go only to the people
in a particular game or only the people
in a game in a particular state so it
gives you the flexibility to partition
out your messages from the server these
are questions huh No so the of is for
namespacing and in is for channeling and
there's not really for the purposes of
most discussions not really that big of
a difference in my particular case I
have two main socket connections that
each browser makes one is for the site
management like your login session and
all that stuff and another one is when
you were in a game it's managing all the
communication the dragging of pieces and
all that stuff so I established two
socket connections and I have them named
spaced as slash site and /ww
and then I have channels for each one of
my game so I can further partition the
data okay onto webworkers I have to
admit that before I got into this
project I felt like webworkers was
probably one of the most like academic
api's yeah it sounds cool on paper but
will I ever find a real use for
something like webworkers and the truth
is that it's actually really useful and
really cool and the nice part is it
looks a whole lot like working with web
sockets you are remoting a message to
another thread just like your remoting a
message to a server from the browser it
looks the same way you're sending
messages back and forth asynchronously
so again no mental context shift at all
it's slightly different API but no
mental context shift at all it's the
same idea here we create a game worker
on line 294 we give it a URL for a
separate JavaScript file it will load up
that separate JavaScript file into a
separate thread of execution why is this
important well some of you may be aware
and this is another one of those
performance things some of you may be
aware that when you have a browser that
has has rendered a page and you make
some change on the page like you move an
element or changes style or CSS browser
to do re-rendering of that page has to
recalculate the position recalculate all
the rendering and repaint that page all
of that stuff happens on your main
browser session your main browser thread
javascript shares that same thread which
means if you have a long-running
algorithm you're gonna cause slowdowns
of that repaint even things like garbage
collection inside of your main
JavaScript can slow down the repaint so
you've probably been to pages and you've
seen what should be a nice smooth
animation but it starts becoming laggy
and Jaggi because of that exact problem
that you're sharing this thread and it
simply can't do enough especially in
low-power mobile devices just simply
can't do enough well we have the
solution we can run a long-running
JavaScript or an intensive processing
javascript in an entirely different
thread and it will not affect the
rendering thread of the browser at all
so we can get back to that more ideal
place where the browser is able to
repaint itself in a much smoother
fashion and we can have long-running or
more complex javascript happening
elsewhere so for the purposes of my game
what I wanted was to have this other
sandbox where the code was harder for
people to kind of muck around with
because it really is a fully closed off
thing they can't change the prototypes
in there and and muck with your code
inside of a web worker like you can in
the browser DOM and also it has the the
performance nicety that any any
intensity of communication between the
browser and server all the messages of
updating pieces and stuff I can buffer
all that stuff inside of the web worker
and send those messages over to the
browser rendering thread and hopefully
have a lot less slowdown in the browser
thread so for a real-time game web
workers actually have a lot of really
cool potential so game workers what I
could create my game worker I have on
message that listens for messages from
the worker and then down here I want to
send a message so I do game worker dot
post message pretty straightforward yeah
I think we're almost done with the web
worker stuff I wanted to show you this
is what it looks like inside of that WWJ
s this is what a web worker code look
that looks like we have only a couple of
things that look different from normal
JavaScript we have an import scripts
function that's how we can synchronously
import other scripts so here you can see
I'm loading up the socket IO library
inside of
inside of our web worker and then I you
know normal stuff variable declarations
and function declarations the only
difference here is if I want to listen
for messages from the server I do self
dot on message to listen for message not
from the server from the browser thread
and then I can do self dot emit to send
messages back pretty straightforward it
looks the same in both places last thing
I wanted to show was that we have so
some browsers do not have web workers
and there's not a really a way to shim
the missing web worker so that you get
full parallel threads you can't create
threads where the browser doesn't let
you create threads but you can create an
API that looks exactly the same and you
can take advantage of the fact that you
don't have to have totally different
codes so that's what I did here is I
wrote a simple little shim gives me the
post message and on message behavior for
a browser that doesn't have a web worker
still gonna my codes gonna function the
same they're gonna be slightly less
performing because we're not taking
advantage of having that separate thread
there are better shims than the one that
I wrote in this project that are much
more full and complete I just wrote a
very very simple stripped down one for
managing the code but this is the shim
for dealing with web workers I would
encourage you to search on github you'll
find better ones than the one I wrote
last API that we're going to talk about
is local file access this is actually
one of the more exciting ones as well
for years and years we had the ability
in an input type of you know a file
selector we could select a file
reference and we could attach it to a
form and upload it on the form but we in
the JavaScript world had absolutely no
control or readability into the data
that was getting sent so we'd have to do
these stupid things like upload a file
to the server and then tell the server
you know to send it right back down to
the browser or things like that so this
is a terrible problem that we just dealt
with for years and years and it's mostly
because of the security concerns that
they had and they didn't deal with that
security in a smart way so they just
said simply don't give them any access
at all to somebodies local file system
thankfully html5 came along and said no
not any longer we've got to give them
access to the file contents you do still
have to have a user initiated action so
it does still have the same security
protections that it otherwise would the
user has to pop open a file input box or
they literally have to drag a file from
their desktop onto the browser to
initiate a file selection event in the
browser but once a file selection event
has been initiated by a user then your
javascript is capable of grabbing a
reference to that file and reading its
contents and reading its properties so
what we use this for obviously is when
you're uploading an image in this game
it shows you the image right away and it
does that overlay of the grid and stuff
like that nothing has been sent to the
server at that point we're manipulating
that image using canvas that way I don't
have to actually go you can do that
image manipulation on the server but I
didn't want to go to the trouble to do
that if I've got the browser and I've
got canvas and all that let's do it all
inside of the browser manage all that
data and then once we're fully done
processing it we'll send it to the
server so here we say I've got a
reference to my file selector and I'm
listening for the change event as soon
as the change event fires I have an
array of files that were selected in
this case I'm only gonna let I'm only
gonna pay attention to the first file
you can't select multiple files but
theoretically you could have an array of
files to process so I grabbed the first
file and I immediately started doing
something cool I look at its image ty I
mean I look at its file type its mime
type and I make sure that it's an image
that has the word image in its mime type
so that you're not uploading you know
malicious word document macros or
something like that so I check to make
sure it's got the right type and then on
line 717 I check to make sure that it's
got the right file size so it's not too
big I don't want you to you know upload
a 16 megabyte file and crash my server
or something so checking for Mac's file
size so I'm getting access to these
properties right away on this file
reference that I never had access to
before and this is pretty awesome then
on line 721 I call read file that's
another function that I wrote which
we'll see here in just a moment but I'm
essentially saying at this point I've
checked that the file is the right type
of check that it's all right sighs let's
go ahead and read its local file
contents and we're gonna paint that
directly into an image element and then
use our canvas to mess around with it so
read file very straightforwardly there
on line 477 at the top we create a new
API called file reader this is a nice
little API we get the opportunity to
provide it a file reference and ask it
to read it it's an asynchronous thing
obviously when we ask it to read that
file we listen we have an onload
listener that listens for when that
finishes and once we get the contents
from it then
I'm gonna call render preview so it's
very straightforward I simply say read
and then on line 493 read as data URL
there's read as binary type or blob or
something like there's a couple of
different reads in this case I would
like to have a dating URL because I can
stuff stuff that right into the source
attribute of an image element so read is
a dating URL this is what it looks like
I clicked the choose file it pops up the
file open box and goes for it
so that's the api's that we're gonna
look at tonight this server I'm gonna go
ahead and switch over and start up the
game server if any of you have managed
to figure out how to get access to the
game in just a moment HP igf-i is where
that'll take you to the game we'll be
able to play it so we'll see if we have
any luck and actually showing off live
demo here alright so i'm connected to
this game i'm going to go and click
login we've already seen this before now
i'm connected onto the page all that's
happening without refreshing the page at
all make your own puzzle for those of
you are trying this out maybe you don't
have images on your computer i've got a
set of sample images that you can just
grab and try to play with to upload I've
already checked those out but we'll just
grab one of these files let's see this
is one of my favorite ones some of you
guys may know Ryan Dahle we've got an
image of him so that's not really
refreshing very well let me refresh this
let's pick a different ones that work
renders it better okay we got a crowd
here I've got a difficulty selector so
it's gonna it's not really drawing these
lines very well let me close this
browser and Chrome's sometimes funny
about getting into weird memory state
not lookit remember my login information
that's cool
used all right there we go that's a
little bit better so you see it's
drawing those grid lines on top of Ryan
if I select it as you know medium
difficulty it's going to draw smaller
tiles and hard difficulty let's go ahead
and try one of these hard ones will
create the puzzle so it's already sliced
all that image side sent to all that
image data up to the server created
files and reload it and that was pretty
darn quick so now we have all these tile
images and let's see if I can figure out
like let's drag this to here may be yep
I got that one correct so if any of you
guys can actually yep see so you can see
that other people are playing the game
and you can see where people are
dragging images around so this can
actually get kind of fun so all that's
happening right here my browsers
connected on a socket your browser's
connected on a socket and every time you
move I'm sending those XY coordinates
down to the server and then broadcasting
that as a to all connected that's how
we're getting hundreds thousands of
these messages getting sent out and
you're able to see that without too much
lag we're seeing the dragging of all
those images so this you can see how
that can get kind of fun in terms of
your collaborative gameplay and so forth
and see we see the liz is doing really
well scoring lots of points already so
we can take a look and see if anybody's
creating we can create some more puzzles
here for people to play with
let's try strike creepy clown
create that on let's try another one
bird is actually a really pretty picture
just stole all the DS off of Google
Images so I apologize to the author of
these images but I'm not making money
off of it so so there you go I am hugely
grateful for the opportunity to come and
do this and I hope that what you get out
of this more than anything is not my
specific code but I hope you're inspired
that there's a lot of really cool stuff
and it is actually practical to weave
this stuff into something useful in real
world and it's not just a game there's
ways to weave these api's together and
make real and useful stuff this is not
just the stuff of academics it's not
just the stuff of books although please
go buy my book but take this stuff from
that book and go build cool stuff like
this and I hope you're inspired by that
and thanks for the opportunity</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>