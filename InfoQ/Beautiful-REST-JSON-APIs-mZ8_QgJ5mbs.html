<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Beautiful REST &amp; JSON APIs | Coder Coacher - Coaching Coders</title><meta content="Beautiful REST &amp; JSON APIs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Beautiful REST &amp; JSON APIs</b></h2><h5 class="post__date">2013-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mZ8_QgJ5mbs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm going to get started this this is
a fairly in-depth presentation so
there's a lot to cover so I'm probably
going to use you know a good chunk of
the time I'll leave a little bit of time
at the end for for questions so a little
bit about me my name is les Hazelwood
I'm the storm pass CTO we offer a
Identity and Access Management and
control
API or fundamentally arrest JSON API and
we operate as a cloud SAS provider we
also have an on-premise distribution as
well and we're security guys in addition
to this I'm also the the PMC chair of
Apache Shiro
which is the Apache Software Foundation
is open-source security framework so if
you have any questions as a regards
security specifically with REST API is
feel free to talk to me at the end of
the show and are at the end of the
presentation and I'm happy to cover
whatever I can so we have a fairly
detailed outline there's a lot to cover
but don't worry each one of these things
can be covered in a couple minutes each
so it's it might look a little bit a
little bit cluttered but there's
actually a lot of information that's
really beneficial if you're developing a
modern rest app and and we'll cover each
one of these these bullet points as we
move through so we're really here to
talk about api's and and when I say
api's I mean something that a developer
can consume that to to leverage you know
particular behavior outside of their
system and so with that in mind I really
want to focus on pragmatic approaches
that are convenient for developers so
you're building applications your
developer building an application we
want to make a REST API and utilize
design principles that make it easy for
developers to consume these api's so the
developers are primary customers whether
they're internal or external you want to
make it easy for them to use easy for
them to understand and so how many
people here have heard of the term
restaff Arion okay so for those that if
you haven't heard the term a rest affari
and
an ideologue there's somebody who really
sticks to the letter of the law as as
rest is prescribed by a certain inner
circle of experts and if you do anything
outside of the that that inner circles
recommendations then you are I don't
know you're forbidden to interact with
them at a human level I don't know
they're they're just they're nuts about
rest and making sure you do things
perfectly
I'm not arrests of far in I am my
pragmatist and so there are some things
that I will talk about that kind of
diverges away from things that rest rest
afar Ian's really really care about that
being said I am also it's also very
important to me to stay true to dr. Roy
Fielding's thesis and some of the core
principles of why rest and restful
architectures are really important so
I'm not going to veer too far away from
best practices but we do want to focus
on adoption making things easier for
people to consume the API so that you
can they can adopt your service and will
also focus on scale you know how to do
things to allow other you know many
different heterogeneous systems to
consume your s API so it can be
ubiquitous so why restau why are we here
talking about rest dr. Roy fielding when
he wrote his PhD thesis on restful
architectures talks about these six
bullet points specifically as the
reasons why restful architectures exist
or why it's a good idea
the first is scalability and and when I
say scalability here I don't mean scale
from a performance perspective I mean
scale from an internet scale perspective
having things be ubiquitous so any
client technology any programming
language can can leverage these things
that's the internet scale that that
we're talking about here rest is also
very general it can be used to satisfy
many different requirements and use
cases so there there are a lot of really
good benefits for generality in the rest
paradigm it's independent I can have a
server written in Java server written in
PHP or Ruby and they can all communicate
with each other using the same restful
protocol so you have independence from
implementation level semantics or
details latency is also something really
important that fielding talks about in
this thesis and specifically with regard
it's to caching and HTTP caching and
it's often overlooked when people talk
about wrestle architectures so we'll
cover some some some techniques that are
beneficial to caching a security is also
built into the HTTP specification in the
form of the authorization header so you
can leverage existing security
mechanisms and encapsulation is
important I can have a RESTful API that
exposes data in a particular way that I
want to expose it but it doesn't have to
expose everything about my system or
maybe some of the internal workings or
details of data or some of the resources
so these six properties are why fielding
created is restful thesis and they're
really important and we'll talk about
all the properties that that kind of
help these things come to fruition
well why JSON so this is a rest JSON
based presentation
why is JSON so popular and ubiquitous
something like 55 of all new application
development includes some form of
JavaScript it's simple the grammar
actually for JSON is very easy to
consume it's easy to parse for tools and
it's easy for human beings to understand
it so it's it's very readable
it is also scalable in a use case sense
you can have JSON represent just about
anything it's just a bucket of name
value pairs so it's very flexible in in
providing you a data mechanism that
allows you to represent almost anything
you want
so JSON is really important these days
and also one of the things I want to
stress on this presentation is XML is
sort of been the dominant language in
the past for kind of rest-based API s
and JSON sort of taking over it's a
little more simple a lot of people like
to consume it's easier to understand for
most people so that's that's why we see
some of the shift to JSON how many
people have heard of this term h8 EE OAS
hey do-si-dos however you want to say it
this is a convoluted term you can call
it an acronym I guess a sense for
hypermedia as the engine of application
state and this is what the rest of far
ends are really really keen on on
communicating and it is actually a very
important concept and the idea is that
if I interact with the rest API I should
be able to discover and find out
everything I need to about that API just
by interacting with the API server so if
you picture yourself or think of
yourself as a web browser when you go
visit a home page for a particular
website you can navigate to all
different parts of that website you can
interact with functionality you can see
many different resources the browser
knows nothing about the format of a lot
of this stuff but it does know how to
consume data types that it understands
and it knows how to traverse links and
so this is really important for for
restful architectures linking and the
ability to reference other resources so
this is sort of more of a hade OAS ad
OSes is more of a restriction further
restriction on restful architectures you
can be you can be restful without
strictly adhering to Haiti O's
principles but this is sort of the
purity the letter of the law kind of
approach we'll talk about a little bit
about how these things apply later on so
we're just talking about rest HTTP has
been around for forever JSON is very
simple it's an easy grammar people
understand it therefore rest must be
easy write JSON is easy HTTP is easy
it's got to be really simple and that's
mostly true for a consumer of a REST API
the problem is is that for providers
rest is really freaking hard there's a
lot of intricacies a lot of details
involved in producing a nice clean REST
API and the reason why is that rest is
not a standard there's no RFC for rest
there's no w3c standard it's not there's
no specification body behind it that's
formalizing how to approach it
rest is fundamentally an architectural
style it's it's a way of solving
problems via patterns that is not
formally codified and because that's the
case you get a lot of people that
interpret things differently you know I
might want to represent a link
differently than the way you want to
represent a link and there's a lot of
debate on the public internet about how
things should be done because there is
no standard that being the case we're
here to talk about the things that make
life easy so we're going to talk about
guidelines or common conventions or de
facto standards that will make your
lives really easy so things that have
been vetted and proven and tested by a
lot other companies are really going to
be represented in this presentation so
where things must apply according to an
HTTP specification I will let you know
everything else in this presentation is
really a collection of best practices
and standards it's pretty opinionated so
we might not have total agreement but
this is really an accumulation of a lot
of research that that we've done over
the last couple years while we've
developed our own REST API so that being
said - I just want to bring up storm
paths domain very very briefly if only
to mention these things because the rest
of the code samples in this presentation
are going to be based on actual code
that we use that we we execute at storm
path and so a storm path you know we
manage user identities groups you know
mappings between these things the
associations between these various
things applications have access or users
have access to groups that which have
access to applications these are all
things I think most people in this
audience understand and are comfortable
with so we're going to see a lot of
examples using this stuff but let's just
talk about some fundamentals first
before we start talking about various
design issues we really want to focus in
restful architectures on resources and a
resource is a noun it's not a verb
something like an account or a directory
or a document or a video you know these
are all things that you can represent
via nouns verbs or behavior are not
represented in a resource we also want
to make sure that resources are
coarse-grained not fine-grain so I might
have an account resource but it would
probably be pretty silly to have an
account password resource
alright the passwords extremely specific
it's a single property but the account
resource is general it can be used in
many different scenarios and the reason
why this is important is that people
consuming your REST API will come up
with use cases and and have needs that
you could have never have foreseen when
you've written your REST API so by
keeping your data objects coarse-grained
you will satisfy a lot of conditions
that you have
or planned for and it will be easier for
them to use your service and it'll be
easier for them to consume it and it
really helps with longevity of your
service over time and so let's talk
about why we want to focus on resources
instead of just verbs what if I had an
API with URLs that did embed verbs in
them maybe I had to get account or I
wanted to access an endpoint called
create directory whenever I was creating
a directory or I want to update a group
or verify an account email address this
doesn't look so bad there's only four of
these things up here but but the problem
is this is that as behavior starts to
accumulate you might end up with this or
much much worse now maybe I can if I had
URLs to get all accounts or update a
groups name or search groups by name or
verify whatever the point is is that as
behavior changes or as you add new
features the number of endpoints that
you would have to support will explode
if you use kind of a pattern like this
this all smells like the old you know
bad RPC from the late 90s don't do this
this is not a good idea don't include
the stuff in your API there is a cleaner
way and so we'll talk about what that is
we just want to keep it simple there's
really only two things that we have to
worry about or two ways of representing
information in a REST API there's
fundamentally a collection of resource
and an instance resource and instance is
kind of what you would think it is this
is a Java conference so if I had a class
and I create many instances of it a
resource our instance resource
represents the single properties of a
single instance a collection resource is
something that represents multiple
instances and and it's important to note
here that I didn't call it just a
collection I'm calling it a collection
resource because it itself is its own
resource and a REST API can have its own
properties in addition to the things
that it contains and so if it has its
own set of name value pairs is it it is
itself a first-class resource citizen
and I'll show some examples of this in a
little bit but these are really the only
only the two things that we have to
worry about
so a collection resource kind of looks
like this this is the URL end point that
you know it says slash applications
it doesn't say slash application it's
plural
so the the thing that we've seen that
that makes we think makes the most sense
and that is easy to consume is that you
name your end points in the plural
because they do represent multiple
things one or more things it's not slash
application because I'm not interacting
with a singular entity and I'm
interacting with multiple entities or
multiple resources and typically by
convention individual resources usually
hang off of the collection that they're
a child of that that that owns them so
an instance resource might be accessible
in a URL like this slash application
slash some ID so trailing slash on the
collection resource it's not necessary
there's there's no need for it because
again in this this is kind of important
this is itself a first-class citizen
resource and so if it has its own
properties its own collection its own
items array that we'll talk about a
little bit it is its own resource so
just as you wouldn't this is a resource
just as this is a resource so there's no
need for a trailing slash at the end of
it you could put it there it doesn't
really hurt anything but it's not
required or at least I don't think it
should be required so we've talked about
resources collections instances now we
want to start talking about behavior and
in the HTTP specification there are five
kind of well-known behaviors attributed
to the spec get put post delete in head
head is a metadata operation you know I
just want to get some information about
a resource but don't actually give me
the resource back itself the other HTTP
verbs are are the way that we can
perform behavior on those resources but
there is something important to note
here a lot of people think get put post
and delete have a one-to-one
correspondence with read update create
and delete and that is not true and h2b
specification at least it's not true
according to
spec as far as how the verbs operate
there is not a one-to-one correspondence
between these things and I'll explain
where those differences lie as you would
expect however get delete and head
really do exactly what you think they do
they have a one-to-one correspondence
with the behavior you would expect get
is actually read delete is actually a
delete you know I want to remove a
resource and head is as I said give me
some metadata about the the resource I
don't want the actual resource back
itself but wooden posts aren't obvious
they can be both used for create and
update both scenarios are possible with
these two verbs but in very specific
under very specific conditions and I'll
give an example some examples of what
they are so you can use put to create a
resource or you can allow your clients
rather arrest client to create a
resource using put if the client knows
the ID that they want where they want
this resource to be stored so if you
allow your clients to generate their own
identifiers maybe it's a property name
maybe it's a user name for example that
shouldn't change for an application you
can allow this and this is totally legal
and the idea is that the client knows
where they want this resource to be
stored and so you can use put to do that
put can also be used for update if you
specify all of the data when the put is
executed when that request is executed
the issue with put is that it must
contain all of the properties puts
cannot be used for partial updates and
this is as I said I'd mentioned this is
not a convention this is actually
mandatory by the HTTP specification and
the reason why is that puts must be
ident and an idempotent operation is any
operation that could be performed once
or multiple times and result in the same
server state and skin it's really
important to note here that I didn't see
is a property of server state not
necessarily client state so as long as
the serve
state is differs the same between
multiple requests then the property of
idem potency is maintained and so this
is really important because going back
to this example let's say on request a I
specify only the name and then some
other client specifies or no and on
request B I specify just the description
you know just partial partial
information in between a request a and B
there could be another client that
specifies the name and so at the end of
request B now my resource has the other
clients name but my description so
because the server state isn't the same
after request a and B that's not an
identity operation you have to guarantee
I DEP attend C for HTTP and so that's
why I put must include all the data you
have to you have to include all the very
all the attributes or all the data for a
put resource so again put must be a full
replacement operation post however can
also be used as create and this is
typically done on a collection resource
and you're going to sort of add a child
to that collection resource and you're
allowing the server to generate an
identifier because you you might not
know what it is when you interact with
the server and so in this case you know
we're calling a post with a payload on
the applications endpoint and if this is
successful we're going to get a 201
created not a 200 this should be a 201
again this isn't mandatory but it should
be a 201 to let the client know not only
was your request successful but I also
created something for you oh and here's
the location of where that thing resides
by the way so you do want to set the
location header as a response as a
response header when a create goes
through successfully so they can see not
only was the request successful but I
created something and here is the
location of where that thing resides and
so at least in storm paths API we always
return the fully qualified canonical URL
of where that thing resides so clients
can just take that URL and immediately
execute a request for it if they wanted
to
so that is post as using post to create
resources you can also use post
an update mechanism as well and here you
see that we're actually putting some
data to an existing URI and we're
specifying in this case just the name
property and we're getting back a 200
okay saying stating that the request
went through successfully and the
interesting reason or the interesting
thing here is that this is totally legal
post does not have to be identity
it's the only HTTP verb and the HTTP
specification that does not require ID
NC so you can use post for partial
updates puts must be full updates posts
can be used for partial updates there is
an RFC RFC 57 89 that is trying or at
least trying to cover this notion of a
patch verb to be added face to be
specification it's sort of stagnated for
a while I don't I don't know that it has
a lot of leverage behind it because as
I've just demonstrated you can do
partial updates with post as well and so
because it's possible today it doesn't
seem to be a whole lot of drive to get
that out of out of the spec committee
but it's out there if you want to go
look at its RFC 57 89 so verbs nouns the
other thing that I want to cover briefly
is this notion of media types and this
is really important in restful
architectures a media type is basically
a format specification associated with a
set of parsing rules so clients know how
to interpret or respond to that the data
format the clients can tell the server
what they want
using the accept header so if the client
says hey my accept header is application
slash JSON they're telling the server
hey server when you process this a
response this request I would like you
to give me JSON back in response and the
server will set the content-type header
on the response to say I know what you
requested but here's what I'm actually
sending back most of the time we hope
they're the same you know if the client
requests JSON and the server responds
with JSON these two values should be the
same but you can also do kind of
preferential ordering ordering with
accept headers so the client can specify
not only do I accept JSON but I also
accept XML and plain text and all sorts
other things then the server can then
leverage that header to return a very
specific resource type back to the
client if depending on the clients
desires so here's some at the bottom
some representations of typical resource
or media types application slash JSON is
the one everybody's familiar with you
can also start creating custom media
types though and here's just some
examples there's many ways to define
these application /foo plus JSON says
not only is this a JSON document but
it's also a JSON document according to
the foo specification and and you can
also provide kind of parameters you know
via the semicolon and ampersands to
provide additional information about the
content contained within within the body
we'll talk more about media types in how
to leverage this in specifically for
versioning in a little bit but this kind
of gives you an idea of media types okay
fundamentals are covered let's get into
some design now it's really important to
know in restful architectures what your
URLs look like don't really matter a
whole lot and they shouldn't matter as
far as clients and servers interacting
with each other but they kind of matter
to people so it's also an often one of
the things that people talk about when
they're designing their s api's what is
my base URL need to look like so again
well it's not really important for the
technology it is kind of important for
people to kind of wrap their heads
around how do I start and so if you're
designing a REST API which of these two
things do you think you would prefer to
consume if you yourself a customer it's
pretty obvious that everybody favors the
top URL and the reason why is that the
bottom one you don't really know if the
rest API is an afterthought or is it
supposed to be you know some kind of
location that's buried within some
website and it's just it doesn't look
very clean it doesn't look like you're
catering to my needs as a developer who
wants to consume something user-friendly
the top one clearly communicates hey you
know this is where you have to go for
rest api's we got we have you covered
and we hope it's easy to use
so of course api's don't matter that
much but if developers are your
customers you're gonna want to make I'm
happy and so you should support the
smallest URL possible it inspires
confidence some questions we receive
sometimes or if a browser versus a rest
client visit the same exact URL what
should happen so in some cases if it's a
rest client I can return return back
just JSON but if it's a browser and the
other the client represents a human
being maybe I can return a full blown
HTTP page or excuse me
HTML page that renders completely in the
browser and shows images and all these
really good things that's a totally
viable approach and you can do that via
content negotiation you know the server
knows what type of format to return back
it seems to be though that the the
convention is to not do this is to not
show different types of format and I
think the reason why is that sometimes
when your developer and you're hacking
around with a service and you just want
to test things to get it to work you
want to see the content that's coming
back from the server so maybe my rest
client doesn't work correctly and I just
want to open up a browser and just
execute a request really quickly to see
if I get back something that I can
visually parse and so you can negotiate
different types of content in the storm
path API we've actually kept them the
same because we feel it helps developers
while they're debugging and and they
feel comfortable knowing what they're
understanding what they see what comes
back from the server so we recommend
that you keep them the same there's no
strict mandate that you should do that
okay so with URLs how do I handle
versioning if I'm going to upgrade my
API over time I don't want to break
existing clients and so how do I do that
in a way that's going to make life easy
for people so there seems to be two
dominant approaches the first is that
you actually embed the version number in
the URL and this is by far the most
common approach on the public Internet
especially with sass services and the
other one the other way to do it is via
media type and I'll explain the two
different I kind of compare and contrast
them the top one is definitely easier to
consume if you don't know much about
rest or media types or HTTP or all this
other stuff you know that if you at
least put that thing in a browser
address bar and hit enter you're going
to see something really she should or
you might be able to
the bottom one is probably much more
correct from a restful perspective and
that everything that's needed to
understand the resource is encoded in
the media type or the media type
representation so the bottom one says
this is an application this is a JSON
app actually I got the JSON and the foo
tokens swapped by accident but if it was
application slash foo plus JSON that
says this is a foo JSON document that
represents an application Oh in the
version of this resources at version one
so the data that comes back can be
parsed according to version one rules
version one semantics the reason why
this is really nice is that everything
that needs to be negotiated between the
client and server can be captured in the
headers or as the media type and then
the URLs for your app actually never
need to change which can be very nice
depending on the client or depending on
the code that you write so if I visit a
URL today and specify version one and
then I do a year from now and specify
version two none of my URLs need to
change none of my code needs to change
that's a really nice benefit the trick
or the difficulty with this approach is
that not a lot of people know how to do
this not a lot of people leverage it in
their server-side implementations of
REST API and it definitely requires some
kind of solid understanding of what
media types are and how to leverage them
and so if you have to support REST API
for people of varying degrees of skill
or education like maybe there's you know
some of your customers are coming right
out of high school and they need to
consume this stuff they might not
understand what this is nor how to
formulate a request so if this is really
hard for them to build up when they're
trying to interact with your REST API
they're just not going to call it so if
your business depends on people calling
your API for customers it's a really
hard sell to go at the bottom albeit
probably more correct approach the top
one is a lot easier to use and get
running right off the bat so storm path
we actually use that that top URL is our
base and most other sass providers use
that same technique for the same reasons
so this is kind of where we're kind of
diverging from ideology in favor of
pragmatism
resource format we've talked about this
already you can customize media types or
media type representations so the
recommendation here is that start off
with application slash JSON that's what
everybody understands it's easy to use
how do you parse custom data to our
media types and how do i specify version
attributes or other things that's a lot
more complicated so we recommend that
maybe you support this stuff at when
time allows you start with the top one
and then you add these custom media
types as necessary as you have the
ability to do so
okay media types done another thing I
wanna bring up is camelcase
so when you're returning JSON documents
or consuming JSON documents from clients
I just want to reiterate that the jas
and JSON means JavaScript and so you
should see things like my array dot for
each not my array dot for underscore
each right this is not our Sun it's not
Ruby object notation or our o n this is
JavaScript so keep these things
consistent and the reason why it's
important to keep to maintain this
convention is that if you do have a
JavaScript client a web-based client
that's running in the browser for
example maybe you know it's an ember
client or or angular or something like
that they will be able to start
consuming properties immediately off the
off the JSON object because this is
expected in JSON they don't have to
escape the property with quote by
quoting it for example so this
facilitates integration it keeps things
easy to understand for people underscore
or who understand JSON so stay
consistent dates and times this is an
interesting thing I've seen a lot of
different API is represent timestamps
and dates in many different ways and
really there's there's no reason to do
that there is a standard it's been
around for a long time it's called ISO
8601 so you should you should use it
this time stamp exists of this for the
specification rather exist specifically
represent text encoded times and dates
and time stamps so if you keep all of
your time stamps in your API ISO 8601
formatted then any number of tools will
be able to consume this very easily
basically every client language that I
know of knows how to consume in ISO 8601
time stamp
so keep things consistent use the
standards and integration will be a lot
easier for your customers okay
so me type camelcase dates 8 refs I just
want to touch on this briefly I'm one of
the most important things about restful
architectures is this notion of
distributed hypermedia fielding said
it's absolutely paramount it's one of
the most critical if not the most
important part of restful architectures
and the idea is that you need resources
need to be able to reference other
resources this is what makes the web
work at a global scale I can reference
the link on Google's web site just as
easily as I could on Yahoo's you know
and I have the ability to reference
these links and then traverse the links
and maybe Traverse very large content
graphs and it's this notion of link
ability or distributed hypermedia that
makes this possible and so you really
want to retain this property of this
behavior in your REST API and so HR FS
are super important you want them to
exist in your body content so clients
can know how to interact with other
resources and linking is very critical
as I just said but there's there's it's
kind of tricky and JSON and I'll cover
that in a little bit it's really
important though so we'll dive into that
in some detail but in this case you'll
see a storm pass example every one of
our resources that's returned from our
server always has an href property with
a fully qualified URL it doesn't need to
be fully qualified but ours is because
we feel it's easier for clients they can
immediately consume the string and
immediately execute an HTTP request
without having to worry about how to
construct the host and what port to
communicate with or any of that stuff
so again the name of the game for us is
make things easy for customers easy for
clients so all of our URLs are always
fully qualified canonical URLs question
the back awesome so ok so response body
some questions we've had is whenever I
create something right now I update a
resource I create a new resource on the
server
what should the response look like
should I get that back should it be
empty should it be some sort of success
message one of the things we'll get is
obvious right if I'm executing a
you get clearly I want something back so
give it to me but what about post if if
I do post into the server should I get
that same data back or some other status
the thing that we believe is the best
practice here that we've seen that works
very well is that if I'm going to post
an account you should theoretically give
me that account right back to me and the
reason why is there might be some data
about it that the server changes maybe
it applies the last updated timestamp or
whatever but if you get it if the
server's regurgitates that right back to
the customer the customer knows that
when they consume it they always have
the freshest most recent most accurate
version of that particular resource and
then they can either cache it locally or
they can use it for other things
immediately but we found that this this
approach makes things easier for the
customer or the client especially
specifically a rest SDK if you're ever
building a rest SDK you know that
whatever response comes back is
immediately available and can be used
and consumed or put into a cache so it
keeps things consistent if you always
know to expect it it makes client code
specifically a much more simple you can
however specify control parameters query
parameters to override this behavior and
a good example of when you might want to
do this is what if I up upload via post
a 10 gigabyte video file
I'd be absurd for the server to spit
that same video file right back out to
me right and so if you want to allow
customers or clients control of this
behavior you can support these kind of
override flags like underscore body
equals false for the client to say I get
it I know you usually give this stuff
back to me but in this case I don't want
it so that's one approach why the
underscore so the reason why it and this
again is a convention in our experience
typically things that start with
underscore perhaps underscore underscore
reflect meta operations or things that
are specific to the server the
implementation about how to communicate
with with the server whereas things
without underscores typically represent
fields or data that's actually part of
the actual resource and so you want to
separate what's part of the resource
versus what is a control parameter and
you don't want to get them confused
so that's that's why we use an
underscore in this case content
negotiation I cover this and I'll have a
whole lot of time left so I'm gonna skip
over it but again the client can tell
the server what it wants and the server
can spit back the content and set the
content type header I will mention that
the client should represent what it can
consume as a comma delimited list in the
order in which it prefers to receive the
feedback so in this example the client
saying I accept both JSON and plain text
but I prefer JSON because it's listed
first so the server can look at that and
then render content back according to
what the server supports based on the
preference we see resource extensions
sometimes on actual URLs and by
convention this conventionally overrides
the accept evers header so if a client
says hey give me application slash XML
but you see dot JSON on the on the
resource URL you should return it return
JSON back and the reason why is that the
URL is ultimately the most important
part of the overall request and so it
Trump's or it's more important than an
accept header at least by convention ok
how do we do linking this is super
important especially for rest
scalability set it's paramount bla bla
bla it's tricky and JSON though the
difficulty here is that there's no again
there's no standard for this stuff
there's no linking standard or
specification in the JSON grammar but
there is an XML right XML has it these
things are known as X links the w3c has
a standard for anchors which is a type
of X link you know the a element so
we've seen this many times before and
there's existing standards so it's it's
not an issue for people who do XML or
HTML but JSON does not have such a
standard so how do we do this so for
example let's say I am I'm getting an
account and in in store path system all
accounts reside in directories
directories own accounts if you will so
what if I want to get back an account
and I want to get back its parent
directory these are two separate
resources
um how do I represent this in JSON and
there's a lot of ways to do this by the
way there's I think how HAL is one of
the JSON specs or you know suppose it's
spec it's really a bunch of you know
community members getting together to
say hey this is how we like to do links
so there's how I can't remember this if
there's a bunch of competing ways to do
that to do this and the one that we
settled on that we feel is the best
actually and I'll give it reason why is
that we simply have a link be a complex
object that has a single property called
href that referenced the that references
the the fully qualified canonical URL
and the interesting thing about this is
that if you look at it it's not
complicated even if you don't know what
links look like or other these
specifications you can look at that and
immediately know that oh I have to go
somewhere else to get the directory I
have to go visit that href but what's
kind of interesting about this is in the
X link specification there's this
relationship attribute or arielle you
know a re l equals help you know the
relationship indicates the type of link
or Y that a link link visit exists maybe
to get some contextual information
around why the link exists and the
interesting thing in JSON is that sort
of implicit already by the fact that you
have an attribute named directory so
that the actual JSON attribute name
itself can be used as the relation
attribute that might exist in the X link
or w3c standard for for XML for HTML so
it's kind of it's kind of cool in that
now I have a relation and I have a URL
this is fundamentally what what anchor
is present in HTML and so you can
encapsulate everything very trivially
the house specification for comparison
by the way has a separate property in
the JSON document called links and it's
an array of links that have an actual
rel attribute and an href attribute and
so they're all the links for a
particular document would be collapsed
into a single or array property and we
don't really like that approach and in
our opinion and you know a lot of the
engineers I've talked to it requires you
to scan different parts of the document
it requires you to
have to go and switch context to
understand where this information might
go our might be might be linked to as
opposed to being in line or being more
contextual with the data that's already
there
and one of the really cool things about
this particular technique is that it
makes things brilliant when it when we
talk about resource expansion or entity
expansion then I'm going to cover very
briefly and I'll come back to this to
explain how that works
collection resources can work the same
way you can have in this case you know
show me all the groups that that are
assigned to that particular account and
that's just a normal href as well you
could provide additional metadata like a
media type property that says not only
is this collection but this collection
contains elements that are of this type
that would be really nice and that would
make things a little easier for people
to consume the API or the REST API so ok
let's talk about rest our reference
expansion this is also called entity
expansion or link expansion on the
public internet you know all three
things being the exact same thing so the
issue here is what if I um what am i
skipping through there we go so what if
I want to get the account and its
directory I want to execute a single
request and I want both of those
resources to come back because I don't
want to ask have to execute two
round-trip requests it's inefficient and
I already know the data that I want to
display perhaps maybe I'm running a user
interface and so you can support this
notion of an expand parameter that
references one or more of the of the
links or the attributes that should be
expanded inline and returned or excuse
me returned back to client and so in
this case the client is saying yes I
want the account but I also want you to
give me the directory fully expanded or
materialized if you will inline so when
I consume the doc I know that I have
both both both resources and so the
reason why this the linking technique
that I just mentioned is really elegant
is that if you notice it's the exact
same structures what we looked at in the
link scenario the only difference is
that it now has more properties and so
the beauty of this approach is that the
client the
have to have special logic it doesn't
need to say is this materialized yet or
is it not materialized or do I need to
go to another part of the document to
find a link a link array and then expand
those things as necessary and which one
do I expand it's all self-contained in
the same location as as the the actual
link was previously and it's very easy
for a client to tell do you have a
single property if so you're a link if
you have more than one property you've
been materialized and I have all the
data I need
very simple coding wise for clients to
consume this information so anyway
that's that's entity expansion you can
also do partial representations maybe if
you do rate limiting or quota based
limiting over s api's clients can maybe
specify if you want to support this you
know I know that there's this huge
document but I only care about these
four fields or three fields because
these are the only things I'm showing on
my current UI screen that I'm building
so this is a way that you can that
allows you to support customization for
your clients if they want to you know
engage or leverage this type of behavior
in this example you see the client wants
an account but they only want the given
name the surname and the directories
name to be returned in the response and
then you would just see those those
three things materialized in the result
whether or not you want to support this
totally up to you if you have to support
rate-limiting or whatever it might be
useful pagination how do you handle
pagination there's a couple ways to do
this the most common one seems to be
this notion of an offset in the limit
parameter and most api's and so the idea
is that I'm going to interact within a
collection resource right we said slash
applications was itself its own proper
resource and so I will also specify
maybe an offset parameter and a limit
parameter and what these two represent
is offset is the position away from the
zero index of where you want the results
to start and the limit parameter
restricts the number of results that are
returned and so this says you know maybe
if there's 25 elements per page I want
to start consuming on the third page and
give me 25 records so I can show the
third
eh so this is great and you can support
pagination techniques and the next
result can say offset equals 75 and
limit equals 25
you can keep kind of consuming these
different pages of the collection but it
might also be nice in true hey do you
know fashion where the client doesn't
need to know how to calculate those or
build those URLs and do the math to
figure out what represents a page or not
you can provide sort of nice convenient
link URLs so in this this is an example
of a collection resource of all the
groups assigned to that particular
account and as I said before it's a
first-class citizen resource it's got
its own properties offset limit and now
let's have some additional properties
the first page there is no previous page
because it's null the next page maybe
the last page in the collection oh and
these are ellipses by the way just so I
could save space they're not actual dots
or anything like that so you would
assume that these would be expanded and
then finally the items array could
either have a collection of links that
represent that the elements of that
current page or they could be fully
expanded you know to contain the actual
elements in the collection so that's why
we call this a collection resource
because it does have its own properties
in addition to the items that it
contains okay so moving on many-to-many
i've got an account and they can have
many groups but I can also have a group
with many accounts so how do I represent
this many-to-many relationship in a
restful architecture an idea is that
again we want to work with resources so
if you create a resource that represents
this mapping like in our case a group
membership now you actually have an
entity that represents these two
individual things and so like every
other resource it itself has its own
location its own fully qualified href
and then it's got links or at least
references to the account in the group
that for which the the relationship is
maintained and the reason why we've seen
a lot of other people do this and we
also did this in our API and we feel
it's a best practice is that the
relationship itself might have in very
useful information depending
on your use cases so maybe I want to
just in addition to these two links also
store information like who created the
association at what time was it created
you know does it expire there's all
sorts of other kind of metadata or meta
information about the Association itself
that you can encompass or encapsulate in
a resource to represent that information
and so and also additionally because it
itself has its own identifying URL if
you wanted to delete that association
you could execute an ACP delete to that
resources endpoint and it would delete
just the relationship it doesn't delete
the account or the group just the
connection between the two so it's very
flexible very powerful way of
associating things by representing them
as their own resources sometimes I've
gotten questions you know what if I
don't want the actual meta link the the
resource relationship objects themselves
what if I just want the group's I don't
care about the actual membership
entities and so there you can actually
create two different properties one is
the group's the other one is the actual
group memberships and the client can
choose what they want to consume
depending on their needs maybe they
don't care about the metadata between
the associations and they just want the
group's errors how do i how do I
represent an error something goes wrong
when I actually did a request the idea
here is that we want to be as
descriptive as possible right we want to
give the developer as much information
as we can so that they know how to debug
maybe you know self-service so they can
take care of the problem beyond their
way and back on a developing application
nobody likes having to wait for answers
from a support team so they can move on
with what their day so developers your
customers we want to make things very
very clean and easy to use for them so I
got to give a shout out to the guys at
Twilio they kind of spearheaded this
approach with their API and we've seen
other companies adopt it storm path has
also adopted it but the idea here is
that we're showing an error response
that contains a bit of information in
this case it's a 409 conflict like
something can't be something cannot
occur on the server because something
else already exists and so in this
example we're returning a resource with
the HTTP status code included within it
and the reason why we do that is so that
the client doesn't have to go
two different places to get this
information yes it'll be in the HTTP
headers but they can they can get
everything they need to just in there in
the response body if they want to we
have an internal code that is specific
to storm paths API and the reason why we
do that is because the HTTP spec only
has something like 24 25 error codes
from the 4x X range to the 5x X range
and if you think about it that's not a
whole lot of codes to accurately
represent air conditions or reasons why
something failed so in addition to the
HTTP status code we also provide an
application specific code that gives
them a lot more information of why that
things why their requests failed so that
they can go resolve that problem
themselves property in this case
represents the particular property that
caused the problem so they know that
when I submitted this this new directory
it's the property the name property is
the reason why the request failed and
the message property or attribute is
pretty interesting it is it represents
something that you can directly convey
to your customers application end-user
so what I mean by that is if you're
developed if your customers a developer
and they call you this message they can
take this and immediately relay it like
in a user interface to their own
end-user and that's really nice from a
usability perspective for your customers
because that's just that much less work
that they have to do in order to show
their users some meaningful information
so by this if they just take that and
relay it to the user they don't have to
translate this message or take this very
developer specific message and convert
it to something that the user can
understand you can you can give them
meaningful information right away and
the developer message of course is
something that that the developer
customer would actually understand maybe
it's information that tells them how to
fix that particular problem that's not
relevant to the end-user and you can
provide a more info URL this is nice
because it's a normal HTML based web
page and you can give them all sorts of
good things links to support forums and
knowledge bases and you know help links
and all this other good stuff to give
them more contextual information about
how to solve their problem I got a
couple minutes left let me run through
security really quick
obviously we're a security company so I
want to I want to cover it
avoid sessions if you can you know rest
architectures are supposed to be
stateless on purpose to help with
performance and scalability
so most people authenticate every
request that comes into the server and
they do that with usually with with
various different standards um you
should authorize actions or behavior
based on the content in the resource not
on the URL URLs can change right you can
have redirects you can put them on
different locations but if you actually
say that up sorry you're not allowed to
execute this behavior because the
specific account you're referencing is
you know not accessible to you that's a
much cleaner security check than just
saying you can't go to slash accounts
because it's contextual it's security
it's based on real data not on how you
access that data that's a really
important distinction for security we
recommend that you use an existing
protocol so most REST API is these days
we'll use OAuth 100 a OAuth 2 or even
HTTP basic but only over SSL
it is never secure it is never a good
idea to use HTTP basic over plain HTTP
connections and that includes internet
corporate environments because these
think this data can be parsed via log
messages and maybe there's errors and
they put the data in the logs that
information then is now captured in the
logs and it could be interpreted or
intercepted so even in corporate
environments always make sure you use
SSL to try and transmit this stuff only
use custom authentication schemes
if you really really really really know
what you're doing and only if you
provide your own client SDK so a storm
path where crypto people we have our own
custom authentication protocol it's very
similar in a lot of ways to OAuth 1 0 a
but it's actually more secure because it
guarantees authenticity of the request
payload which auth 1 DOTA oay does not
unless it's a forum post so there are
reasons why we did that because the data
the data is very secure and sensitive in
nature but we know how to design these
kind of algorithms we have crypto people
on staff if you're not that comfortable
with these things us use OAuth 1-0 a
Oh f2 is is also a good approach it's
not quite as secure as i1 dato a I can
explain that to you guys that if you
want at the end of the presentation I'll
give you all the breakdowns of why oh
and finally we recommend that use API
keys to give to your customers that
access your API and not usernames and
passwords
there's a whole lot of security reasons
you know around entropy and the
complexity of password keys and and some
really good techniques or good reasons
of why that's that's from a security
perspective beneficial but ultimately
the the most kind of obvious one is that
if your customer uses their username and
password to configure their rest client
to talk to you and now they go into the
web the user interface and they change
their password now all the rest clients
break so you don't want that to happen
that would be a really really bad side
effect so use API keys to give to your
customers so they can authenticate with
your REST API very briefly 401 403 are
codes that mean unauthorized or a rather
unauthenticated so 401 means you need to
give me some valid information so I know
who you are and a 403 is I know who you
are you've proven to me you are who you
say you are but you're still not allowed
to access this particular resource so
make sure that when you return these
status codes you get them correct HP
authentication schemes we don't really
have time to talk about that now I can
talk to you guys if you want to come up
afterwards and I can talk about how the
stuff works IDs are opaque they should
be the href you could support method
overrides maybe legacy clients don't
know how to interact with anything other
than post and get methods so if via post
only you supported this underscore
method equals delete or underscore
method equals put you can obtain or
achieve the same results within the
server but it's important that it has to
be over post because post means it's a
server processing directive there's no K
there should not be any caching of this
caching a concurrency control this is
important for optimistic locking there
is this notion of an e-tag header that
essentially represents a version time or
version stamp of that particular
resource and the client can then later
request hey
do you has anything changed for this
particular resource and the server can
respond with the 304 and said nope
the version of that particular resource
has not changed you're good you don't
need to execute the full request this is
really powerful and used by ACP caching
servers and this is kind of what makes a
lot of the the web stuff faster because
they can leverage these caching
capabilities almost done maintenance if
you need to maintain and change your
REST API over time use HTTP redirects
maybe you do want to change the URL for
a particular resource and that will
that's okay
as long as the data format itself
doesn't change clients should be
expected to know how to process 302
redirects and then access the new
resource location so if you need to do
some API maintenance or change the
location of where things reside that's
okay just make sure you don't lose that
link so you can redirect your customers
that's everything
okay thanks for your time take care
enjoy the rest of your evening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>