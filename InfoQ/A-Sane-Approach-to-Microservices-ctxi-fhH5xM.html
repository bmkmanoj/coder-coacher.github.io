<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Sane Approach to (Micro)services | Coder Coacher - Coaching Coders</title><meta content="A Sane Approach to (Micro)services - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Sane Approach to (Micro)services</b></h2><h5 class="post__date">2015-02-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ctxi-fhH5xM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey folks can I one hear me I'm going to
use the mic throughout this experience
so we can make sure the folks in the
back in here a lot of one was able to
make it despite some scarce in the snow
Bostonians you got to teach your
cavities how to drive faster we're much
better than New York at this stuff okay
so today we're going to talk about
microservices I had a sneaking suspicion
when I put this talk title up it was
going to win because it's such a hot
buzzword right now so hopefully the
content lives up to the expectation so
the short intro to this thing we're
saying how a service-oriented
architecture it looks really good when
you draw this on a whiteboard there's
boxes and lines and you know you feel
really good about architecting the
system but how does it work in practice
there's a lot of benefits of flexibility
but then you have a lot of overhead with
administration you have to track more
metrics all sorts of different things
can fail in interesting ways so at a pad
were a scholar shop I built the
framework on top of finagle and that
enables a pretty simple approach to
building and deploying microservices
oops oh I'm Toby already got past that
part ok so sort of it I at a high level
the left side here we have the concept
of a monolithic application gray box as
a server colored boxes or various
internal services the other side we have
the micro service approach where there's
essentially one container per service so
alarm on our initial application started
out as a monolithic service this is much
easier to do but at some point you're
going to hit a scaling problem where it
doesn't make sense to create new
instances of the same application
because all the internal services have
very different traffic patterns
different scaling idiosyncrasies and so
on so if you were to use the monolithic
approach and let's say you want to scale
up the red service you basically make a
clone your same application use memory
for all three services and this other
approach on the side you just
to spend up to one so that's one of the
nice advantages but what is a micro
service to begin with it's a buzzword is
a different than a service-oriented
architecture I don't know is this a
microscope we just that change the type
to return a future does that make it a
micro servers or a service no is also
the answer to that but you are doing
mock bc so you wanted the olive getting
features back and so you have a little
bit more flexibility and then at some
point you can wait for results but you
want to build features kind of fall away
okay so functions are not micro services
and functions that return features are
also non microservices there's lots of
definitions out there this is one that I
think works pretty well just a logically
group set a functionality and it's
deployed independently so the
independent deployment is really the
important part here because logically
group set of functionality is just good
software engineering in general doesn't
need a special word justcode smart think
about what the organization matters so
lines of code don't really matter that's
what I was trying to trying to get out
with the Nano service examples amazon
has a definition of micro services which
is the to pizza concept so if you can
have two pizzas that will feed the team
that works on one service and that
counts as your micro service that's not
a bad description i guess but i think in
practice the number of developers really
doesn't matter at all it's just about
grouping of functionality and being able
to scale up that application independent
of everything else so if that's the case
why do we have a different name to this
all of a sudden we're talking about
micro service instead of SOA so
service-oriented architecture I'm pretty
sure the reason is that survey service
oriented architecture just started
getting a bad name when they became the
clunky monoliths that they were meant to
replace so microservice is a rebranding
of the same
cept it's still a good one if you do it
well just sort of a tautology but it's
also the truth okay should you use them
no unless you need to it's much easier
to work on a monolithic app to start I
mean why deploy three things or ten
things we can deploy one however like I
mentioned before you will hopefully if
you're a company hits a good scaling
problem everything goes up into the
right and things start failing so tap
idea at this point a few years ago where
we had monolithic application doing
everything and we realized at some point
there were seven different applications
in one project basically not even
services really just actual different
implications so we started this process
by breaking the project up and having
independent so event tracking server on
one side the bidding server on the other
side to tap as an ad tech company we do
real-time bidding so that's what the
bidding part is essentially you get HTTP
requests do a little bit of processing
send a response back not important for
the talk but so after we broke up this
monolithic application there's no RBC
between them because remember they're
different apps they really just
communicate via state change in a
database somewhere we take a request put
it onto a data pipeline something else
pulls it off later makes a change of the
database your next application can do a
read and that's all that you need but
now we're in yet another different phase
of our architecture evolution and we
need these microservices the big
distinction is that they're some kind of
shared service you don't want to copy
the functionality around copying pasting
code is terrible but also you don't want
to deploy the same code in process
sometimes because you want build scale
differently so now we use our PC on top
of finagle so when should you use micro
services these are two hints if you have
some code smells in your application for
example you have multiple different
boots so you have you know put a feature
flag in there you start up one
application as the bidding server then
you start up the same application but
with a flag that says this is an
tracking server that's code smell maybe
you need to separate those things into
different applications or maybe
different services if it's some kind of
shared functionality okay so if your
deploys start getting really unwieldy
this is another time you might want to
consider switching it to Mike into a
micro service architecture the classic
example here would be you have a
slightly larger team they're each
branching the codebase adding some
different features the features are
totally independent whether deploying
the same application and this means that
you have to coordinate two independent
features just to get a deploy going and
then if one of them breaks maybe you
need to do a rollback that's awkwardly
coordinated with the other feature that
wasn't breaking I guess a little bit
hairy you can solve this with feature
flags as well so for example you just
have a like a shared state setting music
keeper you switch this thing to on or
off use virgin a or b of the software
but said it's impractical to put
everything behind future flags you end
up just having a large code blocks it
say if feature a is on do all this so
the wacky so if you separate everything
into a micro service then you can do
independent deploys and it'll be much
simpler ok so the advantages of alluded
to here UCL different parts differently
it's not magical but if your application
gets big you have a traffic pattern that
is so wildly different one real world
example from tap add is that we have
this very large binary data file and one
of the applications needs to parse this
thing on boots store it off heap have
some pointers there for doing various
quick lookups but this is not the
fastest process just takes a couple of
minutes that's not bad but if you change
an independent part of that application
and you redeploy and even with automated
you know one click deploy process you
have to wait maybe an extra you know 30
minutes for the whole thing to roll
there's a lot of nodes in this cluster
so by separating that particular part
outs you just have a service that wraps
that's that data file and when you make
a separate change you don't have to do
the slow blew it again
so another advantage is just
organization of your development team
it's simpler in my opinion to have just
one or two maintained errs on a service
who are the ones who kind of the
authoritative pull request of yours and
they don't need to clobber somebody
else's code base of course you can do
this in a monolithic application as well
if you have things nicely organized it's
a good class files and so on the
appropriate packages but I think in
practice it's easier to do that when you
have an entirely separate code base okay
so what about disadvantages this is
obviously not a panacea so there's more
to keep track of if you have one
application that has let's say a hundred
metrics that you want to keep keep
around in graphite and then you have ten
services now you're going to have 10 x
100 metrics to keep track of and
processes you want to keep running RPC
is slower than an in-process function
call this is pretty obvious but maybe
not so obvious when you're drawing
things on the whiteboard so keep that in
mind also you have to choose a protocol
to communicate between the client and
server you can't just use a plain old
Scala object well I guess you could but
if you're also using different code
bases let's see you have a nodejs
service that returns some JSON and then
you have Scala service somewhere else
you need to pick something to
communicate that wire protocol is your
interface that you need to track the
version of and make sure that you're
backwards compatible when you are
rolling clients and servers forwards and
backwards that sounds kind of hairy but
in practice it hasn't been that much of
a pain you just have to be sort of
conscientious about keeping deprecated
fields around just long enough that all
your clients are upgraded then remove
them this is really easy to do using
finagle actually because you just set a
version of your protocol server when it
comes up we'll register that with its
its host import in zookeeper into the
client say hey I'm looking for the food
service version 3 okay here's a couple
servers like
back to no problem you can also have an
old version too sitting there running I
totally independently and then once
things stopped connecting to the version
2 server they're good to go and you can
kill it thank you so even though you
have a wire protocol you can have the
compiler help you know when your client
and server are going to be out of sync
in a moment we're going to get to some
more code in fact okay so you are going
to have a compiler tell you these things
will break if you change the protocol
that can be a sort of tricky thing if
you have a strongly typed interface for
example but if you use thrift or
something like that the compiler will
help out okay so this is the way that
tap add makes services now we use SPT
for all of our plugins and we have an
SPG plug in here called service build
simply expelled extends an SBT project
and you set up a route client embedded
and server and we'll get into a couple
examples of these later but essentially
this makes it very simple to start a new
project because you just include the
plug-in you give your service a name you
automatically have some projects set up
here you can see a certain number of
dependencies here which are pretty
interesting so we decided that i will
put the domain objects and the protocol
into the clients the client is very
lightweight the server is pretty
lightweight and the embedded project is
where all the demand logic happens so II
actually as I was writing this
presentation I noticed that our project
setup looks really similar to the
remotely projects that some folks runar
Paul's some other folks around here made
a similar thing so I guess we're on to
something okay so here we have the
client service definition in thrift so
there's a new domain object called
greeting a very simple example but you
also define a service that takes this
thing
they will eventually generate some Java
code they're sizing Scala code that
gives you the RPC server the client also
contains that version number that i
mentioned before and since the server
depends on the client project that's how
they're able to communicate via
zookeeper so you connect to the correct
version of the service that you care
about ok so there's also a client
bootstrap code this is in this is not in
the SBT plug-in it's just some some
extra of bootstrap code which shows me
how simple it is to make a new client
here pick an execution context and you
call bootstrap and this will just start
up a client and then you have your
methods on here client greet which takes
an option of a string as you can see
looks awfully similar to our service
over here where you have greeting and
then optional string name same types
okay so here we have an example of an
embedded project this is where all the
domain logic goes all the heavy lifting
of the application so the way that this
is supposed to work is you write all
your code in the embedded project you
have the server project depends upon the
embedded project so it gets the
implementation when the server starts up
it basically just does a translation
between some internal demands of plain
old Scala objects basically and then
whatever the wire protocol is we have a
couple instances where the embedded
projects is instantiated inside of some
process this of course throws away all
the benefits of the independent
deployment but all of engineering all
good engineering requires trade-offs and
sometimes you need the speed of just
having a an in-process function call
versus RPC okay so here's an example of
server project and so you can see that
it actually is this physical the folks
in the back looks great on my laptop
screen okay sounds like a else ok so
again the point is that I want emphasize
here is that this is very very simple
you have a server bootstrap which is
this server equivalents of client
bootstrap just give it a type it fires
things up connects2 zookeeper announces
its presence and then just sits there
and waits for someone to connect so the
next slide is going to start going into
some of the operational concerns but I
did want to go back to some of the
disadvantages or rather things to
consider when you're making the
service-oriented architecture there's
there's no magic about it so if for
example you have a service that is in
front of a database and just does some
kind of database call your database is
the that's the bottleneck of your
application you cannot simply spin up
more service instances and get better
performance this is not always super
obvious if you're not thinking about if
you just writing you
in your application code because one of
the boons finagle is that you can
actually just spin up a service and you
will automatically get load balancing
but you cannot afford the fact that
sometimes there is some shared state or
some shared service behind the scenes so
you always have to keep that in mind and
if they just tracked lots of metrics and
see when things start failing ok so for
operations we basically brought in a
bunch of other plugins into the service
build plugin that helped us keep track
of all these different things when you
have one monolithic application so
really just the one version number or
just keep track of master or a
production branch you don't even need to
worry about versions once you start
actually separating things out this is
true of libraries as well as services
you need to track those versions so how
many people here use SVT release not as
many as I thought so less than half but
it's a great great little plugin
basically just wraps a couple common
things that you want to do you run this
with you release it checks that you are
billed as clean runs tests bump
subversion tags the repo pushes all that
back to your upstream and then we have
built server that will figure out we've
got this new release in place which we
do about it so let's run SPT assembly
it's another plug-in that takes all your
files wasn't into one fat jar it's a
little more easy to deploy and less it
and so this is an example of a build
file this is how you make SBT assembly
do its magic the top it is just main
class then name the jar nothing too
special here one of the cool things
about SBT assembly and the reason we use
it as opposed to something like SBT pack
or like a standard SBT native package
your disc function or stage is that you
have control over how you hand
merge conflicts thank you so here's the
very simple example if you've got a
bunch of these different files just
discard them you can also concatenate or
big first last something like that okay
so speaking of spt native packager this
is a newer one in the tapout ecosystem
at least it will take your application
package it up in any number of different
formats the one that we use is rpm
because we're on sent us and we've got
an ops team that likes using all the
established tools so system five init
scripts are generated for you
automatically say sudo service you know
foo start/stop status all those things
are very robust and tried and true that
said SPT native packager is a little bit
complicated to set up there are many
many many different things to configure
and I found myself reading the code more
often than reading the documentation to
figure it out but now things are kind of
tidy and it works very nicely one thing
I want to call out here is just an
example of how you would take some
settings here from SBT assembly and just
merge them right into the native
packager setting so you don't need to
duplicate this coding configuration all
over the place so SPT native packager
and SBT assembly are not designed to
work together natively so that's why
here we have a couple overrides
basically you say that there's just this
one jar instead of a list of jars and
the mappings and universal part here
basically says disregard every single
jar that you think you want to put into
this package except for the one that I
tell you which is the fetcher
okay so this is another one that's we're
on the top side of things we use puppet
to maintain configuration and we don't
want the RPM file to take its own
configuration and then obliterate the
file that puppet put in place so to get
around that we had to figure out how to
basic tweak the RPM file normally you
would use RPM or RPM build rather to run
your bill to like SBT and then package
so you have to jump through a few hoops
with SPT native package are in order to
tweak that RPM script to do what you
want so what this does basically is says
Penedo packager when you make us RPM
take these sample properties files
record that they're going to go in these
locations but do not overwrite them just
give them this user and group and no
replace means when you do upgrade
downgrade whatever it does not clever
the file the puppet was controlling okay
so another plugin SPT build info this
one is great it's super easy to use I
highly recommend everyone to it so this
will just generate some source for you
and on some of our projects now we have
like an internal admin module and you
can curl an endpoint and we'll report
back to you what is the name of this
project this is from your SPT
configuration the version Scala version
SPT version just kind of nice to know
and then you can also put in whatever
else you want so these examples show the
build time that one is just from the
read mains kind of fun shows how long
it's up to compile your application the
build host is useful because we normally
want the CI server to actually do all
the building but if you want to rush out
a hotfix or something like that you
build on your laptop maybe there's
something wacky in your environment
that's different you want to know about
it the built host will record this and
then the get shot especially does the
same thing so you know exactly what
version of your building is running it
makes this process very repeatable
oops
okay so just a couple other points they
didn't really fit into the other high
levels here since we're using finagle by
twitter we also will use twitter servers
admin module to introspect the
application basically it's a few
endpoints again you can sort of curl
them they will profile the application
take samples of running threads and you
can kind of see what's maybe getting
lots we're taking up too much time and
you can optimize that metrics Oh metrics
are really important we use graphite
you'll get a lot of them basically for
free so the general jmx stuff you'll get
for the JVM finagle also attracts what
sort of clients are connecting to it
what methods they're calling and also
load balancing so there's essentially
two ways they had a load balancing
you're either have a smart client that
deals with things or you connect to a
load balancer which then knows about the
services behind it and routes them
there's no need for that extra hop we
have load balancers on the edge of our
services but inside we use finagle to
handle that it's a smart client like I
mentioned before just connects the
zookeeper and figures out what host
serve there and it will connect and do
the load balancing on its own so what's
next for the tap SBT build plugin some
of the things that I showed you are not
in the plug-in yet there's sort of
independent on various applications as
we're figuring out how to make them work
so we're going to consolidate all that
stuff and potentially make an activator
template so it's even easier to start up
a project like this and that's all I
have there are a few minutes available
for questions if anyone hasn't
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>