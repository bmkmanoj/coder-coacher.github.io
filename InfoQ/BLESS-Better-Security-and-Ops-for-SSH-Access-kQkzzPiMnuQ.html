<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BLESS: Better Security and Ops for SSH Access | Coder Coacher - Coaching Coders</title><meta content="BLESS: Better Security and Ops for SSH Access - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BLESS: Better Security and Ops for SSH Access</b></h2><h5 class="post__date">2017-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kQkzzPiMnuQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so a couple logistical things right out
of the bat first actually I haven't done
this talk before so you can just assume
I'm a total newb and all mistakes are
because it's new
we've given parts of this @oz conned
about a year ago when we first released
blessed as an open source project but
when I meet back today to talk about is
sort of what it means to run blessed and
what have we learned about doing that
over over the past year and so the thing
is to get there I need to repeat a
couple slides from last time around
since you guys actually know what Blood
says so we'll spend some time talking
about that and then we'll get into the
other stuff a couple other interesting
words of notice to get started
I put stickers on the tables because I
love stickers so if you guys love
stickers too feel free to grab one we
got blessed logo and I also have a whole
ton of other Netflix sticker so if
anyone's into that come track me down on
chaos monkey and other fun things so um
let's see one other word of note I know
a lot of people sometimes like to take
pictures during the talk totally fine if
you want to do that but just as a fYI
the slides are all available online
they're going to be on the queue come up
site and I also have them off my
personal webpage on a on a speaker deck
page so they're actually there right now
so if you're stabbing ups you can
probably google them and find them off
of my personal page or even to grab them
later so now I need to take you know
pictures and you can add the full res
PDF later on alright with that so
imagine you walk into work one day and
you find this on your computer this was
the case with some people at Sony about
two and a half years ago when the big
Sony hack happened how many of you guys
are familiar with the Sony hack yeah so
I figure I probably don't need to go
into a ton of detail suffice to say some
adversaries got in and there's a lot of
stories online about what people thought
might happen or occurring to the
aftereffect and all the data they got
out but the assumption is that these
adversaries were actually in their
systems for quite some time because they
were able to pull out you know over 100
gigabytes of information and a lot of
the stuff that you saw on the news was
you know movies that got leaked really
sensitive internal corporate emails
financial
those kinds of things because those are
the kinds of things that you would
expect to see on CNN however if you went
over to Reddit you would have seen a
little more information about what got
leaked so the adversary is actually
hosted readme files that indicated
here's all the information here's all
the files that we leaked out and someone
thought it would be interesting to grep
that for things that might indicate
private keys and they found they found
this all right I'm going to be over here
oh sorry good so so lots of private keys
and as you can see some of these appear
to be either SFTP or SSH keys okay so
why would an adversary go after your SSH
keys it's probably pretty obvious if you
want to do movement inside your network
once you get in these are extremely
valuable and it turns out that SSH keys
don't get rotated particularly often a
lot of people tend not to put a password
protection on their private key and in
fact I did a little study a while back
and I found well over 50 percent do not
put a password on their private key
we'll just leave it at that and and so
they're very very useful it's it's like
having a password except usually it's
two even juicier places in your kingdom
and it's not just Sony right there's a
lot of other places where this has been
going on if I just kind of scroll
through a few news articles you'll see
this was last fall a bunch of embedded
devices had their SSH keys leaked so
that people could get into them we had a
company that makes PB X's they didn't
actually have a source code problem per
se but someone came in to their
corporate network and their customer
support personnel had a whole bunch of
SSH keys and other ways to get in to
their customers locations to do customer
support and service and so someone got
into that network got that information
and then of course all their customers
were put in a vulnerable situation
there was a breach at Expedia and while
it's not clear exactly if they used SSH
keys to get around they certainly got
some admin accounts and started walking
around with those and so the discussions
around some of the implications of that
a while back some folks got some SSH
keys from FreeBSD developers and wreak
some havoc on their servers there was
some stolen essence keys around Linux
developers again reckon some havoc
here's some malware that is specifically
going after your SSH keys this was from
a couple years ago but malware today
still does that so you know the point is
there's a lot of these things right and
and this is a very juicy target this is
something that attackers are going to go
after as soon as they get into your
world and and so this is actually from
an RSA blog about how attackers operate
and it's actually kind of nice that I
can see off of the keynote this morning
because there was some discussion around
the threat that attackers provides it's
interesting that RSA has this really
nice graphic for it because of course
they themselves were the victim of such
an attack so there are a really great
place to publish this they know exactly
what it's all about I found this was a
nice overview so I kind of reproduce it
here I mean basically you're going to go
in with a phishing attack which is kind
of like what we heard about this morning
set up some sort of backdoors you can
get into system that can be the web
shell that they were talking about that
can be any other sort of implant on your
system to get in then you start doing
this lateral movement that just means
you're going to go from one system to
another to another to another until you
find all the juicy bits with an
ecosystem sort of a discovery phase but
how do you move laterally well you get
SSH keys you get admin credentials you
get other pieces that allow you to move
between these machines from there you
collect all your data that you want to
get out you do something to package it
up
maybe you encrypt it maybe you compress
it and then you find some way to get it
out typically you're going to take it
from whatever the organization's network
is that you're in and bring it out to
some sort of other compromised machine
maybe take it through a couple hops so
that it's harder to trace it back to you
all right this is this is how it works
and so those SSH keys become a very
important step so that's fine it seems
obvious we all need to protect our SSH
keys
we can all get them now right so
everyone's good with that so what's
really the problem here the problem here
is that we we also need to use these SSH
keys and so we need to sort of balance
the usability around it and the fact
that developers actually have a job that
they need to do with the fact we have to
protect these things so at Netflix we
use a tool called spinnaker for
continuous deployment systems and is
this an example each of these little
rectangles represents an instance in the
cloud and what I'm showing here is
you've got one rectangle that's red so
when you have a scenario like that
sometimes you want to SSH into that
system and figure out what's going on
you know why is that system not healthy
well I'll have a demo later that kind of
walks you through exactly how we do this
but bottom line is when you SSH from
your laptop into that instance you
ideally should be authenticating to
prove that you're someone that's allowed
to do this and how should you do that
maybe LDAP would be interesting you can
integrate that with SSH do any of you
guys do that a couple of hands okay
I actually was expecting to see more
because it's I've heard a lot of people
doing that in the past we tend to avoid
it personally the reason one we don't
like it is because it adds another
dependency in another failure point all
right so if your LDAP service goes down
then craziness ensues and by the way if
you've ever managed and LDAP service
enough said
and if you're not the one that manages
the LDAP service go talk to your elf
administrators and ask them about a
future world where they don't have to do
that anymore and student smile and all
that stuff it's really good
so yeah okay so no LDAP so how do we
actually do this well if you look at two
common recommendations if you go to
eight of us and say hey I need to do SSH
how do you how do you suggest I do this
they're going to show you something
along these lines basically as you
deploy your instances you can just have
them inject an SSH public key on to each
instance and then each of the operators
can SSH n seems reasonable enough the
challenge is if I do that then that
means that there's a private key that
each of those developers has and they
need to use that to get onto those
instances right and so I think you have
a different private key for every
developer
out of how many developers you haven't
realized okay that's probably a good
idea I've had the same private key for
every developer and then you fire
someone and that's not a good idea and
so so this actually doesn't scale very
well it's not work if you have one or
two people but if you get some more you
pretty quickly say we need a layer of
abstraction because that's all we solve
all problems so we add a bastion to the
picture and then the bastion is a great
place to put your private key you have
the operators login to the bastion they
authenticate through some other managed
mechanism maybe in this case it could be
all that but preferably like SSH keys
again or something like that kind of
turtles all the way down but let's talk
about what you do from the Bastion to
the instances right and that scenario on
the Bastion maybe is set up to you super
secure so you put the private key on
there and when people log into the
bastion they can issue some command that
will then get them from there to where
they want to go and assuming that the
bastion is always perfectly secure and
there's no such thing as local privilege
elevation that kind of stuff then we're
good to go the problem here is that at
the end of the day that private key on
the bastion is really hard to protect
and it is really hard to avoid local
privilege elevations and if that were
ever compromised then you're in a
situation we need to go touch every
single one of those instances that you
have deployed to update them to a new
key so that you can then roll out new
keys and the bastions and I don't know
about everyone else's infrastructure but
we've got on the order of a hundred
thousand plus instances in the cloud
even if I have an automated solution to
do that the time window to go through
and just smash the whole system with a
bunch of new keys is going to be longer
than I would prefer to be vulnerable
right and chances are some of those
instances are the old crusty ones it
might not have an association I can't
get it or you know other issues and so
it just becomes the Trail of Tears so we
stepped back when it said well how do we
actually make this better right where do
we go with this and we kind of pushed
everything aside and said okay I need to
figure out what properties I want out of
the system and then I'm going to start
building a system to create those
properties and when we looked at it
first we're from Red Hook so we get
really cool graphics we said one of the
things that we really want is single-use
SSH keys right what if I had a very
short time life on every key that I
issued I used it once and then it
dial it anymore so if I lost that
private key the the scope of that
problem is very very reduced compared to
five lots of private Kansa Bastion it's
a very bad day all right well that would
be great
what if what if every time someone used
that key it left really good clues
behind
right so excellent audit trail nice
logging I always knew what was going on
that'd be pretty nice I'm a security guy
I love lot of trails and finally what if
it offered really really strong
projections in general right I what if I
could protect the system way more than I
can protect the system the head today
that would be great I would feel as a
security guy very comfortable if we
could achieve all those things at once
and so that's what we aim just to do and
I'm going to talk about how we got there
with the system called blessed but but
first it's probably useful to step back
and look at ssh authentication in
general now I'm not going to give you a
master class on protocol security here
and this is intentionally a little bit
small I'm not expecting you to see each
of the lines but the really interesting
point here is that this is basically
what happens when you do a network
connection between a client a server and
there's a public key authentication
happening with open stage right so
you've done ssh-keygen you've got your
T's in place you set up the connection
and it sends a variety of information
back and forth it establishes a key for
your session and then starting down here
messages are now encrypted and we go
down and we can see all those pieces
come together
now there's another mode in SSH is
anyone familiar with SSH certificates
any hands just a couple
okay so SSH certificates work a lot like
the SSH public key mechanism except now
it's a certificate which means some
authority can sign it to indicate that
it's valid and just like you would think
about certificates in the browser world
you can have your SSH service set up to
trust a particular signing Authority and
then any certificate from that authority
is allowed into your system so this
works out pretty well it turns out the
protocol is pretty much exactly the same
there's just a couple of small
differences
and those differences are highlighted
here and that is at the initial set up
instead of doing that public key we
actually have to get a way to create a
certificate and we have to sign that
certificate somehow and on the server
side we actually need to set up a trust
store like a certificate authority file
that says here's the public key of the
certificate we're going to trust this
we're going to report okay and then all
the way down at the place where we
actually validate that the session is
good to go
of course we're checking the certificate
against the certificate authority
instead of the traditional public
keeping and that's it everything else is
identical so this this is a pretty much
battle-tested set up it's not some sort
of esoteric thing right this is this is
something we can trust but the really
cool thing is that now we can take those
operations the signing operations on
those ssh certificates and move them to
a third machine right we can have a
separate certificate authority that its
sole job in life is to sign these
certificates for clients to get into
servers and why I like that so much and
I get so excited as a security guy is
now the private key that is the security
of my entire ecosystem is off in some
corner that has a single purpose in life
right it's not on a bastion where
someone can get to it I can protect it
and defend against it quite a bit better
and so that starts to look really really
nice and that is exactly what blessed
provides for you so bless is one of
these forced acronyms stands for
bastions lambda ephemeral SSH service
let's not worry about that let's just
focus on the logo like I said we have
stickers you can come get them all right
stickers look just like that and what is
this ephemeral piece and what is this
lambda piece well have anyone has anyone
here used eight of us lambda good lots
of hands alright so any of us lambda is
super cool because you don't have to
worry about anything other than the
function that you write then you want to
run right so you don't worry about the
OS underneath or anything like this and
it just runs this you take a small bit
of code and drop it in and they'll run
it for you now the Blessed world
we basically use a lambda as our
certificate authority and then
you have the bastion that makes a call
to that limited function saying here is
the public key I need you to sign it I
need you to turn this into a certificate
and then it returns that certificate
back and then the bastion can then go
use that and that's that's super great
now the problem is the lambdas they
actually don't have any persistent
storage and so you need some place to
store that private key that you're using
to sign everything and you know we're
fortunate enough that AWS also has this
whole kms service so you can store your
keys in there and you get a pretty good
amount of security on it
so all of a sudden I don't have to
maintain this thing in any meaningful
way and I can have a pretty high
confidence that the security of it is
pretty good right so that's pretty
fantastic and then I come full circle
and once I get that certificate back I
can log into my instances with it that's
less than enough she'll rest the talk
we're going to get into a little more
details about how this actually works
but first let's look at SSH certificates
because I think it's it's super cool you
can do a lot of stuff with them this is
an idea of what an SSH certificate looks
like you've got a whole bunch of
information here that you can use to
scope where the certificate could be
used for example right out of the gate
you can decide if this is a certificate
for a user or a host you can control
what information gets logged when
someone logs into your service with the
certificate and that's in this key ID
field now this is super cool because
that means at the time that the that
we're minting this certificate we can
package up a whole bunch of information
like who's this user what bastion are
they coming from
what's the lifespan of the certificate
all sorts of interesting things that you
might care to create an audit trail for
you can just baked right into there and
then it automatically gets logged for
you let's see we've got the ability to
set a time span that these are valid for
right so if you're using it the way that
we use it where you have a bastion and
then you're going to turn right around
and use the certificate to log into your
instance you can make it good for about
five minutes that should be plenty and
then and then you know that even if that
was stolen it would only be useful in
those five minutes but we can actually
even better than that we can say that
when you get on to the instance I'm
going to define a principle and that
principle basically defines what I'm
allowed to do when I get on to that
instance so think of this as mapping to
specific users or specific operations on
the instance that you're going into and
you can pretty arbitrarily do this so
we'll get into some examples of that
later so you can scope it down further
there I can also scope it down further
by saying this certificate is only valid
coming from a particular IP address
right so this will only work if you come
from a bastion well that's pretty cool
so if someone steals it and takes it and
tries to use it from somewhere else it
won't even work at all all right and
finally you can set up all the typical
SSH fund that controls your session
right so you can you can further scope
it there in any way that you see fit so
this is pretty cool you can do a lot of
fun stuff you can scope these things for
a short period of time let's talk a
little bit about how we would use this
there's a couple ways you can imagine
setting this up a very straightforward
way is to say if my developer can access
a particular Bastion then I'm going to
allow them to access any system that
sits behind that bastion so the simplest
possible authorization policy I can
dream up
it's basically wide open you might have
different bastions for different
segments within your world but if you
can get on to the bastion and you're
good to go
so in this case the LES doesn't actually
have a whole lot to do in terms of
deciding additional authorization steps
it's just going to say if you're on the
bastion now I'll go ahead and cut a cert
for you but you might want some dental
final grain and we sort of weave this is
kind of where we started and then we
kind of realized over the time period
that it's useful out a little more and
so the next step could be something like
this all right I'm on the bastion but
maybe I'm only allowed to go to
particular apps now I don't have a big
central repository of every single
permission for every developer in every
app so what I can do is just push this
all the way out to the instances
themselves and they can set a policy and
say you
to be in this group or you have to be
this user or something like that before
you can get into my app turns out to be
very useful construct and that way the
information that blessed puts into the
certificate can get used instant side
and that principle to define who's
actually allowed to come through now
there are some slightly more complicated
apps out there so imagine a use case we
have a bunch of containers on in a
particular instance and those containers
have different developers are allowed to
get into each one right so we have a
little bit of user multiplexing going on
here maybe I don't want to say anyone
that has any container on there can get
on to that host maybe what I want to do
is actually have further scoping and I
want to say well this user can get into
some containers and this user can get
into other containers and so you can
actually start to do those sort of
richer things again using these
principles and multiplexing on the host
side alright so I talked about
principles a lot here's a example of how
we're doing it we've you know and I'll
show this in operation later in a demo
but basically on you can imagine putting
something like your instance user your
abs account your app name we tend to do
like instance ID and a couple other
fields as well to just scope this but
it's an arbitrary string it can be
pretty much whatever you want it to be
and once you have that then you just go
in your sshd on the system that you want
to log into and you can specify the
certificate authority that you're going
to trust so that's going to be like the
blessÃ¨d certificate authority and then
you also specify the authorized
principles and that principles is a file
notice the percent you there that's the
user that you're going to map it to so
in this case if I create a file like
this and I call it bless demo that means
there's a user on your Linux box called
blessed demo and that user is accessible
by people that satisfy the principle
line here so if your principle line says
bless demo instances blah blah blah blah
blah then you can get into the bless
demo user all right so let's talk about
how we actually do this a bit in
operation first of all
is the picture that I showed earlier for
those of you that have actually built
systems does this look about right or
maybe a little bit simple to you who
thinks it looks a little simplistic no
one thinks it looks simplistic all right
you guys are getting way too much credit
this is what it actually looks like
added of course abstracting that a
little bit so let's walk through the
various flows here this is sort of like
the next layer down right so we've got a
variety of things we've got a user on
the left here that can SSH into the
bastion and on the bastion we sort of
break it out into two different setups
so we've got the user space which is the
tooling that a user will use to access a
kernel space daemon and the user space
tool we call pilgrim and the demon on
the kernel side we call shaman I didn't
name them for auditory so basically what
happens is that pilgrim will call to
shaman shaman we'll call it the blessed
and and then blessed will do the
operation that we talked about earlier
so called kmf and gets your certificate
signed and then certificate certificate
comes back and you can log into your
instances now what's super cool about
all this as well as you can see there's
all these things on the right side that
show logging happening and so all that
information can come back in and you can
start to do interesting analytics on
your logs for example one of the things
that we like to do is make sure that no
one's using DSA keys PSA is considered
sort of not a good practice and sh t
anymore everyone should be on RSA and so
this allows us to take all this
information all the ssh logs back
analyze and say who's using DSA keys we
can say who's actually logging into my
service now I've got a strong
authentication trail but the users we
can look for anomalies in those logins
right so hmmm this user Joe they're
always blogging it over here and that's
their cluster but then today they logged
in over here and that's different right
and so maybe we don't need to stop them
from going there maybe they had a
perfectly legitimate reason they were
helping
a colleague or something like that but
it's enough that we can send a notice to
Joe and say hey Joe was that actually
you or or not and then they can just
answer and we can move on with life
but if that if they answer in the
negative oh that actually wasn't me I
don't know where you got that well then
we can figure out what happened there
right great to look into it so there's
all sorts of fun things you can do all
right so some of the other benefits that
we see out of this I talked a little bit
earlier about this idea of the
challenges with everyone having their
own personal keys to get into the
bastions one of the issues there is that
it's really hard to convince people to
update and rotate their keys right and
so this is gets to be sort of the the
human problem of something is
compromised and now I have to walk to a
single person and say I need you to
rotate your key and it's hard to
generally protect them it's hard to
convince people to use good passwords
and all their private key files but just
so many challenges around that that it'd
be nice to just push that aside and not
even have that be a situation we also
talked about the shared key challenges
where it's hard to protect them on the
bastion the other thing that's actually
really nice about this solution is the
expiration so all the keys become very
limited in scope and so you don't have a
lot of worries there we also get some
interesting benefits with key rotation
so typically when we deploy it we don't
have just a single certificate authority
single private key on the certificate or
three side will have multiple
certificate authorities and we bake all
of those public keys into all of our
instances and one of those is offline at
all times so it's in a safe tucked away
on like a USB key and no one touches it
that is very much the
in-case-of-emergency go pull that out
and you can use it because if something
is compromised we can start deprecating
the old one while we start mentioning
with the new one for example so it
allows you to do things like this that
are actually really powerful in ways
that are transparent to the user base we
talked a little about the logging this
is some example of the logs that you're
going to get out of the system when you
use something like
but it's arbitrates whatever you put in
that key ID field so here we have an
example we see the username we see the
IP address that they're coming in from
we see the commands that they're running
which SSH keys they're using what the
validity period is all very useful
information for your for your audit
trails and of course there's some
availability winds you know I talked
earlier about our not liking LDAP for
this for this scenario the reasons why
and in general we also have this break
last mentality where we do have that
offline key where we can get access to
the system if we need it alright so as
with all of the security talks today
there's open-source pieces here and
whenever I start to look at an
open-source projects I tend to go to the
project page and I start to look at a
couple things just understand is this a
healthy project is it something that I'd
actually want to use here's what I you
tend to look at so I thought I'd share
it with you first off you know quite a
few people have started so it's got a
little bit of a following there which is
which is really great that suggests that
maybe there's a good community around it
then I look at things like okay how many
contributors are there are you actually
doing like release management you know
what's your development practice looking
like what's the license on it it's
apache license so it's pretty easy for
people to consume and then I sort of say
well okay that's all fine Danny are they
actually doing continuous integration
that they have a good test coverage is
all just available for me to see okay so
that that looks good and then I say of
course is there documentation and there
is so great so this is relatively easy
for you all to pick up and use if you're
interested we certainly encourage you to
check it out and we have people back on
my team that supports us regularly since
we use it in-house and the the version
that we use in-house is the version that
you see in github we don't have some
sort of magical other version and so
we're right there with you answering
questions and trying to make this thing
better all right so let's talk about how
this works and demo mode first of all
I'm one of these people the demo guys
just never look kindly on me and and I'm
demoing something that is bare
deep within the Netflix ecosystem which
I mean I have to go across a network and
a BPM and like much so I decided you
know what this isn't going to be a good
idea so I've got some videos for you to
demonstrate how this works and that way
hopefully things go but you know videos
can fail too so we'll see how it goes
all right so back to our picture here
this is a whole ecosystem for the first
demo I want to cover just a couple
pieces so this is the user experience
around it this is how a developer
experiences bless I'm going to their
instances or as you'll see in a moment
they basically don't have to experience
too much of it at all all right so we
start now this is going to be really
small all right we start with spinnaker
and we pull that up we go over to one of
the instances that we see there and we
say I want to ssh into that instance so
we click on it and then you go on over
on the right side and you can click to
copy and ssh command drop that into your
terminal type in your private key
password this is going to be the
password for your key to get onto the
bastion itself or however you
authenticate to the ocean and boom you
are on the instance so what does happen
here we did one command and we went from
developer laptop through the bastion
onto the instance a little bit of a
command-line magic but as you can see
they're basically all we're doing is
we're saying that we're ssh gene and
we're running a command on the bastion
to do that next ssh step as well and
that's what our oq ssh is that's a tool
that will activate the lambda key and
get you going on so super easy for
developers to get onto the instances
always step one for me all right so next
let's look at how the Bastion uses bless
so for this we're going to look at the
pieces on the bastion itself primarily
and then how it interfaces back with the
lambda function all right so the left
side of the screen is told remits the
user space on the bastion the right side
of the screen is shaman so that's going
to be the demon on the bastion and what
we did is we spun up shaman on the right
so that we have the daemon running and
now we're going to issue a pilgrim
command and we can provide a variety of
things here that
user role is going to be what goes into
that principle and then we can provide
things like the ASG the instance ID and
other information about what we're
trying to get to when we run that it
actually returns the file location for
the private key that it generated and
inside there you're going to have your
certificate and your private key in the
information that you need to actually
SSH in the system on the certificate has
all the kinds of information that we
talked about before so we're showing
here various request ID information what
the role is that you're coming in as and
the validity dates all sorts of fun
stuff I know this is a little bit small
but if you go check out the slides
online as well even though I don't have
the full videos in there I have the
final version of each video slides you
can actually see the results of all the
commands that that's helpful for folks
later so yeah so we've got the command
that you want to run when you get on to
the to the instance there got the
function that's being run so we've named
our lambda function blessed and so we
know that's what got called to generate
this you can imagine having multiple
lambdas that you might calling that one
in log which one they hit
there's our actual validity period we
put the validity period in the key ID
just to log that information but the one
that actually gets enforced is the one
in the valid field there we have a
principle that will scope it as we
discussed before with all sorts of
information including the instance ID
and and the account ID we believe
instance IDs are unique within an
account we're not confident that
instance IDs are globally unique so we
included both of those fields to make
sure that we had a unique identifier
there also if you go back and look on
the other side once token runs shaman
will log information about what it did
so it's actually going to log that fact
that pilgrim ran who ran it and it
actually pulled information out about
the user on the system that ran that
command so it would have your username
and injects that in it pulls its network
IP address and it injects that in as
well and it puts all that information
together and makes the request to the
lambda function
in this case we're actually logging the
the request body so the whole JSON
payload is here too you could kind of
choose what sort of verbosity you might
want for your logging
it's the classic trade-off of having a
great audit trail versus using up a lot
of space and maybe it depends on on how
often people are SS Aging in your
systems as well alright then we've got
how do we actually setup this on the
instance side okay so the Bashan setup
we saw how it gets to use the instance
setup is actually relatively
straightforward I'm going to look at the
instance itself and some of the log
pieces around that now before I start
this one the way that this demo is going
to run is going to be a little it kind
of is confusing at first I'm going to
set it up for you
we're actually SS aging into the system
that we're on so what we're going to do
is we're going to set up something that
runs across localhost this allowed us to
basically set up something on a on an
isolated system because I didn't want
sorry guys I didn't want to reveal all
of our internal instance IDs and all
sorts of stuff as we as we logged
through so that was a nice way to to
handle that for you
so given that let's see if we can go
there we go
alright so what we've got here is the
SSH configuration this is the
server-side configuration at the very
bottom we're going to drop in an entry
to say I'm going to trust this
certificate authority and here's my
principal file just like I showed
earlier would that percent you to
specify we're going to pass the user as
the file name we saved that out and then
we go actually creates the files for
those certificate authority keys just
drop in the key that we want in there
now typically this is where I said you
might have multiple CAS that you trust
at a given time just for operational
reasons then we're going to step in to
the principal's file
notice again the username there so if
someone comes in with the principle that
we're going to specify they would get
the blessÃ¨d demo user on this
particular host and again we have the
instance ID the account ID the AFG name
all baked into there all right now we
just need to restart the SSH daemon and
we should be good to go
so at this point we're going to start up
shaman and we have an SSH command now
notice I'm passing to minus I which is
saying this is the private key to use a
back ticked command that calls pilgrim
so remember pilgrim actually returns the
file name of the private key this is
what that becomes particularly handy so
we just embedded in a single command and
everything will happen transparently for
us again to the build room command we
can specify all these arguments about
the role that we want to acquire and
sure enough when we run it BAM it logged
us in as the blessed demo user now what
we can see here as well is we can look
at the log output that you would get on
that SSH daemon for that user who just
logged in so let's take a quick look at
that here we go and we're going to see a
log line accepted public key for blessed
demo from the IP address of the bastion
in this case it's localhost and it has
all the information that we put that key
ID field so you get really nice login
information there all right
last thing I wanted to mention is that
there's a lot of other people that are
working in a similar space as we've
worked on this project at some level
they've come out of the woodwork and
it's been really fascinating to see what
other companies are doing lift actually
is using bless but they're using it in a
slightly different way they wrote what
they call blessed client and it runs on
developer laptops and they have separate
tooling that allows a developer laptop
to get AWS keys and then blessed client
goes directly from their laptop to the
lambda function and does the kind of
operations that I showed you straight
off of their system so that's a pretty
cool system and they have a blog post
there that talked to all about their
system and I believe they've open
sourced blessed client as well and they
work nicely together Facebook and IDs
URLs are intentionally small I was
thinking you might go grab the slides
and look at them later if you're
interested because it's a lots of
copyright now Facebook uses the same
idea with these certificates and
principles to scope themselves terms
they'll be extremely powerful when
you're working on large scale and
Wikimedia actually takes a slightly
different approach they have a special
way to use SSH agents to better protect
those private keys on the bastions it's
not might be interested in looking at if
you're not ready to go full lend with
the lambda function and bless and that
kind of a thing and that's all that I
have for today and I'm happy to take
questions
get you any thoughts on actually
protecting not just the the keys and
such but what about the console in
access to the console is that something
you get that about two or sorry which
console do the AWS console and the camps
there oh okay yes yes so I've showed
pictures of spinnaker and pretty much
all of the engineers and Netflix is
actually a few in the room here maybe
they can chime in another heads we don't
really use the abuse console so everyone
goes through spinnaker and so we can
limit the scope on the con who access at
the console quite a bit yeah
other questions for Brian there's one
there's one back here where's the
question I'm sorry I missed it go ahead
there seem to be a few other pieces of
the ecosystem around blessed are those
going to be open source
yeah like pilgrim and shaman and stuff
um so we've been thinking about it the
challenge is that those are like really
really baked into our specific
deployment and and they're relatively
small so so we're trying to figure out
if we can find a good way to sort of
abstract them out so that they would be
meaningful in a more general context
then I'm not against open sourcing them
it's just that we we hadn't quite gotten
around to that yet
I think bless is the the interesting
nugget and it's actually not huge it's
Python it's probably about a thousand
lines of code as the lambda function so
it's not not too big but it's kind of
some nice piece and it's very reasonable
so that was a good one to open source
my question is relative to the developer
a part of the presentation it seems that
the developer is able to access to the
server right away but how can you verify
that for example I still have connection
to that authentication to that like
let's say that the rotation happens and
I'm not aware of it right so somehow I
lost connection is there a way to verify
that and also when the SSH keys are
regenerated I also have other sage keys
for other applications that I need to
have connections with so how is that
organized on my computer to know like
where is the SSH key stored and things
like that sure so I'll try to hit a
couple questions I'll try to add them in
turn and if I don't quite get it come up
and grab me afterwards but in terms of
how do you handle connections as keys
change and get rotated our assumption is
that if a connection is established that
that connection would basically live on
forever so we don't we don't go through
and kill out a whole bunch of old
connections if that's if that sits
around for a wild and that's so be it
but and then we would rotate the keys
and that would be then a requirement
that the next connection that get
started is on the new key system right
does that make sense and then as far as
the keys on the laptop themselves I
didn't really get into it in the
presentation here but I kind of
mentioned Turtles all the way down right
so I talked about how do you get from
the Bastion to an instance there's an
interesting question of how do I get
from my developer laptop to Sebastian in
a world where all the same problems are
going to present themselves and what
we're looking at doing there is we
actually have an in health system that
can basically convert a single sign-on
authentication so like a like a gmail
kind of authentication onto a
certificate that sits on your laptop so
as a certificate or it could actually be
like a mutual TLS client-side
certificate so that system would just
populate your your
cheater with certificates after you've
authenticated and those certificates
would be good for say a day or a month
or something like that depend on your
policy we have some for a couple more
questions anybody else doctors over here
do you use certificate revocation to
have more granular control about the
access time on to know the the idea of a
certificate revocation is typically
associated with long lid certificates
where you put it out there and it's good
for a year or two and then something
goes wonky in that time period and you
need to cut it off
since we're issuing certificates that
are good for like five minutes the value
of a revocation system goes down and it
turns out that I feels basically just
too much complexity to be worth it
explain anyone else one more perfect
all right Brian again thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>