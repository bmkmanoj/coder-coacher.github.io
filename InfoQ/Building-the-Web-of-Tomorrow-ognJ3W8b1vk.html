<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building the Web of Tomorrow | Coder Coacher - Coaching Coders</title><meta content="Building the Web of Tomorrow - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building the Web of Tomorrow</b></h2><h5 class="post__date">2012-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ognJ3W8b1vk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Bear Travis today I'm
going to be talking a little bit about
how web standards are specified and
built using a couple examples of
functionality we're working on at Adobe
it's a little bit about me I'm a
developer um at Adobe on the web engine
team we work on web standards up here
I've posted my Twitter information in
github you can pay me with any questions
you might have about to presentation and
slide to be posted to github afterwards
so you can grab it and check out all the
links so with that about me I figured
that I should get to know a little bit
more about you guys so since you're here
I'm assuming you've heard about kind of
this awesome new thing called html5 and
what I'd like to know is how many of you
have tried out an experimental feature
in css3 one that's still kind of under
active development okay and how many of
you guys have tried out regions and
exclusions hey you guys read the specs
I've got a little couple of Adobe
hecklers over here so they should know
what I'm talking about um so good I
actually have stuff to talk about and
hopefully things that that I can tell
you today so I want to start off just
with an outline of what these features
on our and so regions it's a pretty
simple concept the ideas that you can
take content from your document and put
it into a flow and then you can flow
that content through a series of
containers called regions and so in this
example up here we've actually got two
sets of regions I've got a pointer here
um so one of them is is a numbered flow
that's flowing from region 12 region 22
region 32 region 4 and then we've got
another flow that's flowing from region
to region B and you said some regions
are called region chains if you hear me
mention that later on that's what I'm
talking about as an example of what the
mark-up might look like they're both CSS
features so four regions what you do is
you specify content that you want to put
into your flow and your flow is going to
be what moves through the containers
so up here we've got an article that
we're going to put into flow names the
article flow and then we specify that
regions 1 2 3 &amp;amp; 4 are going to pull
content from that flow and so by using
flow into we put content into a flow and
by using this flow from we pull content
from that flow and the flow from is what
makes containers regions okay so
exclusions are a complement to regions
and what they allow you to do is they
allow you to specify how content should
wrap inside and outside of an element so
in this case we've got a circle and as
you can see content is wrapping inside
of it and then you can also see that to
the right of it content is wrapping
around that same circle shape and as an
example of what this would look like in
CSS we're going to start out with the
gray content on the right here we're
going to specify that content should
flow on the right of that so we're going
to say that the wrap flow should start
at the end and so for a left-to-right
layout and is the right side and it's
important that we use the start and end
terminology for something like a
vertical layout we're to layout from top
to bottom instead of left to right we're
going to specify the shape outside and
in this case I'm going to specify a
circle that pretty much fills up the
entire element it's going to be
positioned in fifty percent fifty
percent and have a 50-percent radius and
then we're going to give it a little bit
of breathing room on the right with this
shape margin and what that'll do is that
will push content slightly outside of
the shape so if you see right here the
lines on the right are not actually
touching that shape for the shape inside
we're going to say that it should
respect the same circle shape so we're
going to say the shape inside should be
the same as the shade out shape outside
and we're going to give that a shape
padding of 10 pixels and that will give
a little bit of breathing space on the
inside as well
and so it turns out the shape that
regions and exclusions are a pretty good
complement to each other regions define
where content can flow and then shape
and then shapes and exclusions can
define basically the way that that
content can flow and the shapes that it
should avoid and while they may sound
kind of shiny and new it turns out that
these ideas have been around for awhile
so up here what you see is you see an
example of a 15th century illuminated
manuscript and you can see that the
content is flowing into two columns from
the left to the right it's just one
continuous stream of content and it's
avoiding this little fish shaped
exclusion there in the middle reaches
and exclusions of course they're still
used today it's one of the reasons we
want to put them on the web and one of
the ways they find kind of their most
expressiveness is currently in newspaper
magazine layouts so in this example you
can see that we've got content flowing
through kind of three separate columns
the columns are all slightly different
sizes and at different offsets and you
can see that they're kind of making
space for other contents so the article
content is flowing from these columns
from left to right you can see that in
the bottom right there it's avoiding a
pull quote and kind of a diagram so you
can think of this as setting up regions
to flow the content through and then
kind of some exclusions down there in
the lower right to avoid
so I figured that I've told you guys
enough about these features that you can
actually see a demo of how they work and
since we're approaching how I figured
some Edgar Allen Poe would be
appropriate so this is an example of a
simple flow created with some regions
and you'll see that there's slightly
different sizes again it's flowing from
left to right and one of the cool things
that we can do is we can adjust the font
size and see the content reflow or we
can kind of just adjust the size of the
regions as well so that's kind of
something that's available in current
builds of chrome the second demo will
show off shape inside which is how we
specify how text should flow how text
should flow inside of an element so
right here we can see the text for
Nevermore by Edgar Allan Poe and we can
see the shape over eight region sorry
the sheet the shape of a raven and if I
turn on shape inside we can see that the
text will just flow within that shape
and I can zoom in a little bit to show
you kind of the text is respecting those
bounds
ok
and so these ideas have obviously been
around for a while in print and while
they haven't been standards until they
haven't been worked on his standards
until recently people have actually been
interested in using them on the web and
so some very ingenious web developers
have been using various kind of tricks
with markup and JavaScript in order to
create these effects so I wanted to talk
a bit about what existed before these
were standards so I want to start off
with a very simple example of just
wrapping text around a circular shape on
the left here so this is kind of similar
to a float with the exception that you
have to respect the bounds of this shape
whereas the float will just give you a
vertical vertical rapping and so Rob
Swan wrote this article on a list apart
a while ago about how to simulate this
shape wrapping behavior by creating a
bunch of very small floats that all
approximate the the widths of the shape
you're trying to avoid and you can go so
far as to make all these floats like one
pixel high and then you basically get
the same shape that you're you're going
for but you know at the same time you're
adding all these extra elements to your
markup so it's a little bit it's a
little bit of a hack so for regions
there were a couple workarounds on the
simplest of which was just you create
these areas that you want to be your
regions and then what you do is you pull
content and put it into these regions
note by note on until it fills up one of
the regions and then you move on to the
next one and then you start pulling
content and putting it into the next
region and so on and so forth and so
this required a lot of Dom manipulation
as you move nodes around and it also
required a lot of layout because you
actually had to figure out how big
things were after you appended content
to it so it's a little bit slow but it
did work there was an alternative
approach to this which was you would
actually duplicate the entire stream of
content for each region and then you
would position it within each region to
simulate that it's actually just laying
out that portion and then you'd clip the
overflow so this is another workaround
still not exactly ideal
so adobe ran into these issues as we
were trying to enable people to build
kind of rich style layouts on the web
and we started off thinking well hey you
know there are these solutions out there
we can we can work with them and then as
we kind of move forward with that it we
thought you know wouldn't it be cool if
this was actually implemented in the
browser so we didn't have to deal with
all of this extra markup and all of kind
of this this headache and making it work
on all the different browsers and so in
order to make a standard happen there
are a couple pieces that you need to
make work and the first of them is like
everybody has to agree upon the behavior
like one browser can't just implement
something and then expect all of a
sudden it to become a standard so
everybody has to agree upon how this
should behave and the next step is of
course you need to be able to use it
across browsers if you can implement it
if you can use this feature only on say
one browser then it's not really a
standard and so there is a formal
process for becoming a standard on one
of the groups that governs this is
called the w3c or the world wide web
consortium and they define kind of this
this technical standard as a w3c
recommendation you'll actually recognize
the pieces that are required for this
w3c recommendation the first is you need
a feature specification which is again
you know saying how this this feature
should behave the next piece is that you
need at least two browser
implementations to become a w3c
recommendation and the reason for this
is that you can specify how a feature
works but you know if browsers aren't
going to implement it you can't know if
you actually can't implement that
feature specification and you don't know
whether or not it's going to move
forward with browser support and then
the third piece that you need is you
need a test suite and the test suite is
is written by the spec authors and it
basically determines what it means for
browser to implement the feature so when
when a browser implementation passed the
test suite it counts as implementing
that that standard
okay so we've got this cool idea we want
to make it a standard we want to get to
that w3c recommendation and you know we
want to move that forward and so we
started off with this first step idea
and it turns out that these ideas have
actually been floating around for a
while so up here you can see um
something that came out as a suggestion
to the w3c a complex layout may have
several areas that are chained when the
first one fills up the rest of the text
flows the second etc for example a
newspaper often has one small column of
a story on the front page and the rest
on other pages and so it turns out that
this was actually in a list of
suggestions to put into the next version
of CSS but it came out a long time ago
it came out in 1998 so we realized that
there's a little bit more work that we
have to do in order to move this
standard forward and so the next step is
that we need to do our we need to do our
homework we need to get this ready to
present to the w3c to start kind of the
review process to get us to
recommendation so what we need to do to
start off with very first is we need to
narrow down the scope of what we're
working on me to come up with a few use
cases that we want to solve with our
standard we also have to come up with a
web appropriate solution so since these
features are both going to be in CSS
it's important that we work well within
the CSS framework you know we could
implement the coolest feature ever but
if it doesn't work with kind of HTML
standards then it's probably not going
to be implemented by browsers and
finally we need browser interest and we
need this because in order to become a
standard again we have to work across
browsers and we need people to be
interested in implementing the
specification in order to move it
forward so after we've done that we're
ready to present our findings to the w3c
and in this case we're going to be
working with a subset of the w3c called
the CSS working group so in the previous
stage oh we came up with with kind of a
draft
for what regions and exclusions would
look like and we talked to some vendors
initially about kind of who would be
interested in implementing this and we
found on a subset of functionality that
Internet Explorer would be interested in
implementing as well and so we kind of
decided like hey this is something that
we can work on with another browser so
we came up with a draft specification on
this kind of just outlines the
functionality again and the reason that
we need this is that the w3c process is
all about public review so you need to
be able to tell people how this feature
is going to work in order for them to
actually review it and the next up is a
functional prototype so when we
presented regions and exclusions to the
CSS working group you wanted to show
them how these features would work
because you know specifications tend to
be a little bit long they tend to be a
little bit dry and so if you can show
people all the cool stuff you can
actually do with regions and solutions
there much they're going to be much more
excited about it so you know in our
initial prototype you could do cool
stuff like this you could use shapes and
you could wrap wrap text around it and
so when the the CSS working group thinks
that this specification is ready what
they'll do is they'll prove it to become
a working draft and the working draft
means that they think it's ready for
public review it's not guaranteed that
the specification is going going to go
on to become an actual recommendation
but they think that it's promising
enough that it's worth publishing and
it's worth people taking a look at
so regions and exclusions are currently
at this stage called the working draft
stage this is where the specifications
developed they're still under active
development and then when they're
finished they go through a process
called last call which is kind of the
last call for comments and then they
move on to become a candidate
recommendation the candidate
recommendation is basically a finalized
version of the spec that is ready for
browser implementation in order to move
out of candidate recommendation a
browser sorry a specification needs at
least two browser implementations and it
needs a test suite that validates that
these browser implementations actually
implement the spec and so this this is
kind of like submitting a paper for
publishing the candidate recommendation
can either be accepted or it can be put
back into working draft status to be
further modified but you don't actually
get to really work on the specification
during the candidate recommendation
stage so after after those two browser
implementations and the test suite are
in place on the candidate recommendation
can go on to become a recommendation
which is what you know browsers can
actually implement and say they support
a feature so in theory at the working
draft stage you don't actually have to
implement any of these features in the
browser but we found is it's really hard
to say whether or not a feature is ready
to be implemented without actually
implementing it in a least one browser
so we found that through cycles of
specification and implementation we can
actually learn a lot about the specs and
you know with Microsoft implement to get
an Internet Explorer and with us in
fluent in gated WebKit we can kind of
compare notes about how these features
are implemented and we can find out
things that we need to work on so areas
is expected need clarification and edge
cases that need a little bit of
polishing out so I wanted to give you a
couple examples of those so if you go
back to shape inside on the content
flowing within the circle in white here
it's pretty simple like you have this
shape you want content to flow inside of
it and we started out implementing this
in WebKit and what we found was that
while the general idea was was pretty
simple to implement we weren't quite
sure what to do with content once it had
overflowed the shape what happened
if you have too much content to fit
there and the spec authors knew that
knew that this was an area that was
going to need to be specified they had
filed a bug against it and they even had
some suggestions for what the behavior
might look like but they hadn't actually
gotten around to writing that section of
the specification yet and so as we were
implementing it we we felt like we kind
of had a handle on you know some how
this might work and so we came up with
three proposals and we wound up
recommending one of them so in the first
proposal here on the left on the idea
was that when content overflows the
shape inside you just push it outside of
the shape and so like that last line
which could potentially overlap the
bottom of the shape inside which is the
Rick rectangular white area here we just
push it outside of the shape so no
content is allowed to sit on the border
of the shape inside and this was a
little bit weird because basically you'd
notice a gap between lines on that last
line of text so the next proposal that
we came up with is since we can't use
the line bottom to determine how wide
this segment of text should be we can
just use the line top and we can allow
that line to sit on on the edge of the
shape inside and so this will have
continuous lines of text it'll flow
pretty nicely but at the same time the
width seems a little bit odd it can kind
of not respect the shape so for example
here you can see that this doesn't
exactly look like a rounded rectangle
and so for our third proposal we said
that you know we can actually use the
width remaining sorry the height
remaining in the shape inside for that
line and so we can actually use the top
of that line and the bottom of the shape
to determine kind of the minimum width
that this line can have and so this is
the one that we wound up on proposing
and the spec authors wound up
incorporating it into specification
as another example of functionality that
we kind of worked on and wound up
refining through on this implementation
process we were making regions
accessible to JavaScript via the
region's object model and the idea was
that we would add a couple attributes
and methods to the element and you
basically be able to query the elements
about whether or not they were regions
and how text was flowing through them
I'm so the first property here called
region / set basically just tells you
how content is flowing through a region
if the region is empty if the region is
filled with content or if content has
overflowed the region without a
subsequent region to go to the flow from
is the name of the flow that you're
pulling content from yet region flow
ranges tells you kind of the offsets
into the content that you're pulling
from and regions can also affect their
elements styles and so it was important
to be able to get the computed style for
content that flows within this region
and what we thought initially was that
since these attributes and methods can
be called on called on elements that may
or may not be regions like we thought
that in the case where these elements
are not regions we should throw an
exception we should tell you that you
know it doesn't really make sense to
call these attributes or methods on an
element that is in a region so we wound
up implementing that but it had a couple
of interesting side effects the first of
which is if you want to do something
like run a simple switch statement on
say the region over setattribute you
have to do your normal processing for
all of the cases where it's the region
and then you also have to surround all
of that code in a try-catch block in the
case that it's not a region and you need
to just make sure that your code
continues to work so you know in the top
you have your handling regions cases in
the bottom you handle your non-region
cases and what we found is you know
developers were generally like to make
this simpler they'd like to just have a
simple undefined or null value for
reaching over set they would like to put
everything in a single switch statement
the other thing we found when we
implemented this behavior is that WebKit
actually has a whole bunch of tests that
basically iterate over element
properties and their values and they
kind of enforce this assumption that
when you do that you're not going to get
exceptions and so as soon as we
implement this implemented this behavior
we wound up breaking a whole bunch of
WebKit tests so we decided that we
should maybe make this interface a bit
simpler so what we did was we removed
those exceptions on the code can now be
cleaner I mean we also found ways to
remove certain attributes like flow from
because it was possible to get those
through other methods like getting the
computed style on a region so if you
remember when I talked about what is
required for becoming a w3c
recommendation I said that there was
feature specification work there was
browser implementation work and then
there's this work with building and test
suite so I've talked a bit about the
feature specification work and I'd like
to talk a bit about how features are
implemented in the browser's next so I'm
going to be using as an example of
getting code into WebKit in this
particular example I'm going to be
talking about the first patch for shape
inside that went into WebKit the reason
for this is just because adobe happens
to work with WebKit so this is where my
expertise is but of course you know it's
going to be different for different
browsers so the first step to
contributing to any project is of course
getting the source code WebKit is an
open source project so anybody can
download the code read it on and
potentially contribute back to it all of
the information on that's available at
this website here if you're interested
in visiting it WebKit also uses a bug
tracker called bugzilla to keep track of
all of the feature work that's being
done there so anything from a bug to a
new feature implementation is going to
be tracked by an item in bugzilla so
here on in order to get this this
feature work happening for shape inside
I filed a bug to enable shape inside for
simple rectangles and all the work
that's done there is going to be tracked
in bugzilla
next step perhaps a given you actually
have to build something so there's work
done to build this feature in this case
this is some code that's going to go
into that shape inside patch and then
it's also important to test it WebKit
has a lot of tests on that they run and
the reason for this is it's an open
source project and since code can come
from anywhere it's important to make
sure that that code continues to run
consistently and so when you contribute
code it's important that your code
passes their tests and also that you
contribute tests to make sure that your
code continues to work
so when the code is finally ready for
review what you can do is you can upload
it as a patch to bugzilla so here's kind
of the first part of the patch that I
uploaded for shape inside and the bug
tracker will actually do a couple
interesting things one of them is there
a bunch of bots they will grab the code
on from the bug tracker they'll build it
and they'll run a bunch of tests against
it and this just make sure that the code
continues to build and run on different
platforms so finally you've done all
this work implementing and posting it to
bugzilla it's ready to get your patch
reviewed and there's kind of there are
two different parts of this this public
feedback the first is just kind of
general feedback when you're
implementing a new feature it's
important to make sure that people in
WebKit know about it I'm so there's this
WebKit mailing list WebKit dev a twist
at WebKit org it's important to kind of
announce big new things that are going
into WebKit there so that people have a
chance to give feedback on it especially
if they think it's going to interfere
with other features in WebKit and so
it's important to be responsive to that
feedback as well but after that you're
actually going to have to get each
individual code submission reviewed by
an expert called a reviewer to get the
code into WebKit and when a reviewer
actually looks at your code on they're
going to look at it in really
excruciating detail they want to make
sure that everything really really works
ama that you're not messing anything up
so you're going to see you know comments
as specific as you know please use full
sentences for your comments make sure
they begin with the capital letter and
end with a period and for this
particular patch it was a it was kind of
a big piece of new architecture and so
the review process actually took a bit
longer than usual on this patch had
about ten rounds of feedback 24 versions
of the patch and took about six weeks to
get in um that's by no means typical
this kind of just layed new foundation
work so it was really important that it
was stable subsequent patches to this
area maybe took anywhere from a day to a
week to get in depending on how big they
were
so there are a couple lessons that I I
took away from this whole process the
first is that patch reviews take time
you know you're getting somebody to
review your patch they're busy they have
other things they need to be doing and
so those reviews can just take time to
come through and it's also it can also
take a lot of time to take their
feedback and incorporate it into your
patch it's important that the pieces of
code you contribute are small and
modular the reviewers want to make sure
that they understand exactly how
everything in your patch is working and
so the smaller you make that patch the
faster it's going to get in because
they're going to be able to wrap their
hand heads around it that much sooner
and finally it's really important to
respect your viewers time and feedback
and that may sound like a get like a
given but there are a couple kind of
Salty's to this one is that you know
when you submit patches and you ask for
a review you should really make sure
that they're as ready as you can
possibly get them I'm you don't want to
get feedback from a reviewer saying you
know please do X when you already knew
you had to do X um so this includes
writing tests for your patches like your
patches should really be as final as you
can make them before you submit them for
review and the other thing is just
reviewers are really busy people they're
reviewing patches from the entire web
community so this is like four or five
hundred active developers and a lot of
times they're being paid just constantly
with request for review okay so it may
sound like a lot of work to get features
into WebKit because the code is always
held to a really high standard but this
actually enables some really cool stuff
so when we get our patch into source
code first of all it's rolled into
nightly builds so Chrome and Safari both
have nightly builds that are publicly
available they're still mainly for
development testing but you can grab
them and try things out and then from
there code eventually moves into
something called an experimental channel
and chrome is one of several browsers
that have different release channels
these different channels release
functionality at different rates
basically depending on how stable that
functionality is so the experimental
channel 4
different browsers which include Chrome
Canary see opera next and Firefox Aurora
they're released in an experimental
stage so if you're willing to kind of
try out features that may wind up
crashing your browser this is where you
can get them and they update
automatically which is really cool so
you can always kind of be on the edge of
the features that are currently under
development and from their code
eventually moves on to the stable
channel like your everyday browser so
for example just chrome and one of the
interesting things about our submissions
to regions and exclusions is that that
code will actually make it into the
stable channel of the browser it's just
hidden behind flag so you have to
manually enable it but anyone who has
the Chrome browser will see this code on
something like a six-week release cycle
so this is really cool because code that
we contribute you know in about a month
and a half will be available to anybody
who's running the Chrome browser and all
of this may sound very kind of WebKit
and in particular chrome specific but
regardless of what browser you're using
um it's pretty much guaranteed that is
going to be releasing experimental
builds with new features in it I have a
link at the end of this slide show that
has basically the development builds to
all of major browsers I mean I encourage
you to check them out
so inevitably the question is you know
when are these features going to be
ready for me to use and you know my
question for you is how ready do you
need them to be so hopefully like
throughout this talk I've shown you that
these features are constantly evolving
their constant motion the other thing is
you know people were using these
features before they were before they
even came up with standards you know
those those float solutions and kind of
the JavaScript ways that people were
getting around regions people were using
those before we mentioned in the
standards so regions are currently
they're pretty functional they're still
experimental in chrome and internet
explorer but if you enable them in
chrome through that flag there's a
pretty substantial amount of
functionality for you to try out there
we've just started getting exclusions
into WebKit so you'll be able to see
them in Chrome Canary and the exclusions
the actual outside part of them is
available for testing and Internet
Explorer 10 so that's a little bit rough
around the edges but you can still try
them out and then the final piece of
functionality that I want to announce is
that we're actually in the process of
implementing your regions polyfill for
about four regions and the idea here is
that you know you can use the
functionality now it's going to be
implemented with client-side
technologies at first and then you know
as browsers implement them you can you
move forward to those browser
implementations so in closing what I'd
like to encourage you is just get
involved with building these standards
like they're very open there are a lot
of different ways you can contribute the
first and biggest part is of course just
building cool stuff you know Adobe found
out that reaches and exclusions might be
worth implementing because people were
building really cool examples of what
you can do with regions and exclusions
like functionality second part grab an
experimental build of your favorite
browser um always going to be new
features to test out you know try them
out see what works what doesn't and let
let them know try out new features as
they become available again see what
breaks and hopefully it's nothing major
and then down here like it would be
great if you're able to read and comment
on a specification and though I talked
about the w3c in this particular talk
the specifications are actually governed
by a couple of different bodies so if
you know some area of work that you're
really interested in finding out what's
going on find the specification read up
on it and comment on it all of these
groups um have you know mailing lists to
talk about the functionality in
particular if you're looking for a place
to start the w3c the what WG an ECMO all
good places to start and finally just
join the conversation on again these
standards bodies have mailing lists you
know WebKit has a mailing list and an
IRC channel just start talking or you
know you can just start listening and
find out what's going on before you
start pitching in
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>