<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Groovy Kind of Java | Coder Coacher - Coaching Coders</title><meta content="A Groovy Kind of Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Groovy Kind of Java</b></h2><h5 class="post__date">2013-01-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oY4S0l4yCPg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">one of the things that I liked in je was
the packaging model and I think one of
the things that was figured out pretty
well at the time was that at application
is built out of different modules and as
part of the fact that they it was built
out of different modules they created
that type of hierarchy and that
hierarchy included the assembly route
the web modules that we all know as a
war and application client model and
some other models and also a description
a meta description that described those
modules and how they relate to one
another now if you look at that
definition that kind of helped to define
pretty well what a java application
looks like what is it comprised of and
that bottle was actually very successful
I think one of the best thing that came
out of JT was was that definition so in
many ways this is the type of I think
one of the first time that there was an
attempt to define an application in a
broader spectrum and that's kind of that
was the interesting experience from that
world now the thing that have changed
that we need to take care of that
experience it's not that that model is
wrong or broken or anything of that line
just that the world have changed since
the definition came out to the world
when the definition came to the world
one of the one of the men assumption is
that the world is very much java centric
everything is going to be in Java that's
how JT was built everything is going to
be Joe and therefore our world is Java
and our definition of application is in
Java and everything is in Java obviously
the world is a little bit different
today it's more heterogeneous and the
one of the assumption was that
everything that is none Java is pretty
much out of scope so for example even in
a java application if we have a lot of a
safe with a database it doesn't fit into
that packaging world right so you
wouldn't be able to put in a war file a
definition of the actual database and
how it is installed oh the same thing
for the for the load bar sir the other
thing is that it doesn't really assume
that
the application change quite a bit in
terms of scale and size and all of those
sort of things a lot of the definition
was fairly static so a lot of the things
that our dynamics are kind of outside of
that meta definition so for example
having met a definition for scaling
doesn't exist in that in that definition
so that's another aspect that when we
move to a cloud kind of world we need to
add to that type of definitions we'll
talk more about it later on so if we
really look at all of those things and
one of the things that have changed as I
mentioned earlier the world is not java
centric we have a world in which we need
to combine Java plus a lot of other
languages and it becomes more common
today than it was in the past cloud in
itself as a data center enforces us to
think of automation as something that is
pretty baked right into the development
we and I think you had this talk of
Gradle how many people here was in this
talk of greater okay so you pretty much
remove that concept of continuous
development so a lot of the concept of
cloud actually now become part of our
development it's not something that is
done by operations in the data center
and we have to think about it earlier
the other thing that we have is a lot of
open source project tons of them that we
want to integrate with to speed up our
development and we don't want to think
about the integration as an embedding
thing right we don't want to embed them
into application and change the war file
or change jar file or change meta
configuration every time that we want to
use a project so want to think about
integration in a more broader spectrum
as a service kind of model and that's
kind of I would say that the few items
that have changed that needs to change
the way we deploy application and we'll
talk more about that again in a second
so that's the other motivation that we
have you so if we really look at the
same packaging model trying to map it to
that d world it would look something
like this so we'll have an application
and below that application will have a
bunch of services services are like Java
files are not necessarily package of
libraries that sits in one file there
would be different files potentially
that could live in different places but
we'll have one definition of how they
relate to one another it's the same
thing that we have in web data XML or
something like that but the difference
is that they don't necessarily need to
be packaged in one file so think about
it in that way and that will help you
and I'll show you what that means in a
second the other definition is that the
package can be an application which is
basically a bunch of processes
interconnected to one another and at and
again it's not java centric very mind
that i mentioned processes and the
process could be mapped to java but it
doesn't have to be job a process on an
operating system could be anything so
once we work at a process level we're
pretty much agnostic on the language by
which it was produced and that's another
thing that gives us the ability to
define the application context if you'd
like without binding it to a particular
language so we have an application f pod
is basically a way to say that we have
services that needs to be inter related
to one another in an affinity model
meaning that they need to sit in the
same machine for example so the services
are decoupled from one another at some
point but in some cases we do want to
say you know that web tier and that
database tier needs to sit on the same
machine because we don't really scale
them separately and you'll allow the
assembly especially in multi-tenant SAS
applications you do build the
application like that so for example
when Salesforce provision a machine they
provision the machine with the database
with a lot of components in that machine
that serves let's say a hundred
customers per machine and that's how the
provision that their sauce operation
it's very common in a SAS world to build
the entire environment like that so you
build stacks combine them together you
know that they're going to save that
amount of load and then you pile them
out and that becomes your application so
we need to have that construct as well
as part of the definition and as I
mentioned the interrelated to
another so there is some dependency the
difference in that in that dependency as
opposed to let's say the spring
definition of injection or as opposed to
the web.xml definition of injection the
difference is that it's going to be
distorted meaning that it's not a
container a single container that's
going to build all those libraries and
wire them up it's going to be a dis
really doctoral deployment so we can
have a web code talking to a dull base
and they're going to be interrelated
meaning that when we launch the database
we need to notify the web container that
this is where the place in which that
database exists when we deploy the
application we don't know where the
database exists we don't even need to
assume where it exists we're just saying
that this web container relates to this
database with that name and once the
provisioning happened this is where the
injection happens but it happens in the
destroyed fashion all that wiring
happens in the truth fashion and the
definition the meta definition needs to
take that into account it doesn't need
to reference to a specific IP for
example needs to reference to the
logical service behind that and as I
mentioned a service could be anything
and not not necessarily Java a process
is actually a lot of that wouldn't be
jello so Java would be just a private
case of those services and this is just
a typical example of how an application
looks like today this is a typical Big
Data application the world typical for
big data is not that could be an exam
Rock simran for some people but but big
data become very common so this is a
true typical environment that I took
from one of the architecture so you can
see for example a Duke memcache my
sequel lot of swimming processing out
there and and what you could see is two
things one of them is it to jealousy but
also the complexity of that thing what
we want in that application context is
the ability to describe that thing okay
not just one component of that which is
the right layer here or the left area
because we have that already what we
want is the ability to define all that
why do you want ability to find all that
because we want to be able to
clone that very easily we want to be
able to maintain that very easy we want
to say take that entire thing deploy it
on amazon take that entire thing
deployed on rackspace if we can define
it in a way that can describe all those
definitions then we can actually do that
and if we can't then we can and that's
the motivation behind so that brings to
the next point is that enough yes so one
aspect is that we're missing some
information so if we only have the
definition of the packaging meaning one
of the tiers of my application I each
individual tier is installed is that
going to be useful enough so let's say
that I'm throwing it out in into some
orchestration layer and it takes all
that definition and operate around that
would that be enough so one point the
dimension is that the operation needs to
have a lot of information about the
dependency so for example if I do that
manually today when I deploy database
it's not just the point a process of a
database and deploying it someone need
to know that the database includes my
data that I can actually query the data
before I'm launching the web tier
because if I launch the web to you just
because just when the process of the
database is there it might actually have
a timing issue I may launch that the web
tier it will connect to the database but
we'll find the data because that I still
being loaded so how do I know that
information how do i define that type of
dependency if I try to map all those
dependencies I'm going to get to a very
chaotic definition or very complex
definition so that's part is is missing
the other part that is missing is the
following thing and in those who have
been in these continuous development
discussions should be very much aware of
that this is another important aspect of
application in your cloud it becomes
actually even more important than the
packaging side of it how we operate the
application ways that information seats
today in many cases in in many places so
you'll find that it's scripts shell
script you'll find out in chef and some
other configuration tools
right yes so the idea is that an
application also had definition of its
operational aspect so when when I want
to describe an application I can't
really describe only the component of
the application or even the
configuration I need to describe the
operational aspect the operational
dependencies and operational diplomacy
have aspects on deployment and
post-deployment on deployment it's
pretty much the life cycle the regular
life sack of installation configuration
setup and start up but the more complex
thing is the post deployment aspect how
do i scale it what happens when
something breaks what is the failover
process when if a tier fails does that
mean what are the dependency that is
going to be broken up and how do you do
that so you know how to do that manually
there is no reasons why you couldn't
really map that there's something more
automatically the other thing that we
need to know in the post deployment
aspect is also or just how we fell over
and scale that that application but also
how we maintain it so for example when
we do an update of a war in a web
container there is usually a process
behind it we do it in a certain order we
do it in a way that wouldn't break the
application that is currently running so
there is a lot of that definition as
well a lot of that knowledge as well
that is outside of any description of
the application so if we want to take
that application and build it from
scratch again without that knowledge
something is going to break so this is
an application so what we basically
trying to do is make what is an
application as it is done today and
there is all those aspects that we need
to take care of and the reason why we
need to take care of that differently
than we used to is because it cloud all
this type of dynamic world in force us
to do that there is almost no way where
we could do that effectively without
having this knowledge of building the
application with that knowledge in in
place the other aspect is the
consistency
now if we talk about heterogeneous world
one of the problems nitrogenous world
and don't get stuck in that picture one
of the problem is that think about just
having a dupe and tongue cut right how
do you install Tonka pretty much know
there's a set of things try to do the
same thing that you do for tomcat form
installation scaling and everything to
do right it's going to be completely
different I try to do that to make up to
my sequel that's going to be another
thing that is completely different how
do you monitor those things that's going
to be also completely different between
all those tears and application so if
it's not consistent across our stack the
complexity becomes exponential of
managing that entire thing so one of the
things that we want to do is make that
consistent consistent not by replacing
the tears but by providing a layer that
will make it consistent and that layer
is going to map into the individual way
of how my sequel do things but from an
operational perspective it would look
the same so we'll call the same thing
behind the scenes it will actually do
different things and in that way we can
actually glue or provide a consistent
layer across all those different things
so the way we're going to install a dupe
is going to be very much different to
the way we installed honker and that's
going to simplify quite a bit the
environment itself so that's the other
bit that we need to keep in mind so we
have a very ambitious goal here okay now
the next thing is how the hell do we do
that okay one of the answers and I think
you those who have been in the radial
discussion they've probably heard that
dsl PSL stands for domain-specific
language and the idea of the men
specific language is to try to map that
problem which is the domain that we're
talking about the domain is the problem
of the orchestration that are described
earlier and now we want to define
something that can describe an
application with all those different
constraints so if we take any language
today whether it's Java groovy will be
whatever
and try to implement it in those
languages we'll find ourselves doing a
lot of variables thing that are not
readable because they are not specific
to our domain again our domain is
orchestration I don't want to see a lot
of code that if I'll you know walk
through that code I may understand what
it actually does I want to see something
that says scale when the Tomcat server
has a latency of 10 seconds or less than
a second with not more than two
instances and if it's less than 10
seconds or less than a second Skelly
down that's how I want to describe
things I don't want to describe with a
code with a lot of variables called that
no one is going to be implemented be
able to maintain or even read I want to
be able to describe that my application
has a tomcat surfers web tier my sequel
as a database and they depend on one
another that's how I want to describe
things and I won't have that description
in a very non verbose way to describe it
so domain-specific language could be a
mean to solve that problem and we'll see
how we can use that and that kind of a
good segue to the rest of the discussion
so a few example just to give you an
idea what is a domain-specific language
you could see that it's not a new
concept we actually implemented that
quite a bit even without the definition
of a domain-specific language a good
example for that is SQL SQL is a
domain-specific language for managing
data and it's a very successful one it's
actually something that we've had for
years another example for
domain-specific language if even a
regular expression for string
manipulation right so we've been using
that concept for years without
necessarily calling it by name and the
idea here is that we could apply that
same rule to the problem that I
described earlier and that's going to be
the mean to a solution now the other
example and this ties to what you
described earlier doesn't chef do the
same thing we actually boring
the idea of how people have done or
solved similar problem and in the
developed world chef world Ruby world
there was a concept that was called
recipe so recipe basically tried to not
create a DSL that defines everything but
use a DSL that provides a framework in
which we could put the definitions our
definitions our specific definitions and
our specific definition can be very
different so we're not going to try and
create a DSL that has now all the
definition that says my sequel as this
and this and the web tier has this in
this because that's going to be an
endless work and it's never going to be
doable because an application world is a
it's a living organism it's always
changing as always there is always new
application new features new versions
there is no way we can map that to one
language that could cover the all so
what we can do from a score perspective
is create enough construct in which we
could put that specific definitions in a
way that is readable but there's going
to be specific definitions pair service
that is outside of the domain of the
specific of the night specific language
but the domain-specific language is
going to give us that framework for
example how to start the server the
implementation of how to start a server
would be different outside of the domain
specific language context but how we
call it and what we call it could be a
standard way and that's the type of
trade-offs that we're trying to map here
so we're not trying to create a language
that will map the world right now these
are the type of things that we need to
have as part of that dsl what components
do here while the dependency between
them how to install the services where
the application and the binaries sit so
where to grab them from is that a a web
container is that a maven repository is
that I get up anything that fits into
that and and then and as I mentioned
earlier the post deployment aspect what
happens in the case of a failure and so
forth and how to monitor each of those
components
so that's the dsl that we want to create
we want to create a DSL that has all
those construct ok let's go on then by
the way when we have that dsl in place
someone need to understand it this is
going to be an orchestration server or
something that can read that an executed
product so we just by creating a DSL
that's not enough we need an engine that
can pass it and understand it and do
something meaningful with that so we
need those two components to solve that
problem ok how chef does that this is an
example of a DSL in chef so what chef
did that's an interesting lesson for us
as Java uses it stuck rubik so basically
said ruby has a lot of contract in the
language in itself that is a good fit
for creating dsl whether the contract it
reduces a lot of verbal things like
columns and semi columns and others and
it can be extendable i'll show you how
you do that in java but that was a
general concept and that what made a lot
of the Ruby guys adopting the concept of
dsl to do a lot of that orchestration so
what we can see here is something that
is more readable I can actually read
that and understand it what we're doing
here is basically trying to change a
configuration of a web server that is in
some cluster so basically doing a search
on a cluster finding the node that feeds
to a certain name and setting up the
configuration of that that's basically
what we do so again try to do that in a
regular scripting you'll find that it's
much more verbose so by using a DSL in
that context we can simplify that
process because we have a lot of more
contract in place and most services in
place to help us do that same task and
the result is less verbose much simpler
to read much simpler to understand but
that doesn't help us we're here in a
Java users group right so I'm not going
to pitch you Ruby right now or even
jruby
so the question is how can we do that in
Java and that's I think the answer is
pretty obvious right from the topic of
this discussion what are we going to use
this is where groovy fits in why groovy
so groovy takes a lot of those ideas of
those other languages like Ruby but do
that same thing in Java the problem with
Ruby for java uses is that it's a
different domain but it's a maybe it can
utilize the same language or the same
jvm but it's a different language you
can really use effectively the same Oh
Jules the same object and and and if
your Java users you'll find that context
which is is very different so what
groovy is trying to do is take a lot of
those keep you within that Java domain
but give you a lot of the features of
those of those dynamic languages one of
the features is reducing the verbosity
what is also referred to as a
syntactical noise so for example if I
look at that code I could see that in
groovy I can reduce a lot of the things
that are not really meaningful to run my
application just by running groovy
without any DSL ok so Reuben itself
gives me power to simplify things just
by the fact that amusing groovy so
that's the first thing the second thing
that it's extendable it's extendable in
the case that I can actually configure
the compiler and add things into that
like imports so I can reduce the calls
to imports I can reduce the calls to for
example i can write something very
readable like that because it's
extendable move left at three kilometers
an hour that's very very readable but in
order to implement that this line would
be actually called that runs we need to
be able to interact with the actual
language engine the compiler they
in another configuration others like
things that are called binding in the
language itself meaning the ability to
provide context to say when you run that
code actually run it without import
before you actually run that when you
run that code use that base cloud for
every class that degenerating for that
particular script so I can hook and talk
to the compiler and do things that will
enable me to extend the language I can
even change the class on the fly and say
well you know what you could actually
add properties into that class
dynamically because i know that for that
domain I need those properties in place
and there is a way to control it so
there is a security model in which I can
say to the compiler what I'm allowed to
do and not allowed to do so that people
wouldn't be able to mess up with the dsl
and do the wrong things as well so the
basic idea in the language that gives me
that power is the ability to interact
with a compiler and and basically
provide the definition on those
different points in the compiler that
otherwise wouldn't be able to do that's
what makes groovy or Ruby for that case
something a tool that is very good for
dsl another example you can see an
example of how the code would look like
without Ruby and how we can look into
the groovy kind of snare it's the
command chaining kind of model so in in
jail if we'll try to write something
like that it would look like the things
at the top and we'll need to do a lot of
work to actually make that code work
returns and other things in groovy that
becomes something that is built into the
language itself so we could call take
which would be a method take and the
second thing that we'll do is we'll pass
a parameter and if you don't pass other
parameters then the second thing would
be another method call on that same
object and then another thing is the
parameters but because we're using the
second parameters you could see that
using this to actually define that these
are two parameters for this method then
if you don't use
that then the second thing becomes
another method this would be the
parameters for that method but the
result of that is very readable like you
as a human I can read it and understand
what it does even if I'm not a coder and
to implement that it's much simpler for
try to implement it in Java I need to
actually write that code in that way so
I could do that chaining so every time
that I'm running that class it needs to
return itself you know that the next
chain in the command would be able to
work in the same instance and so forth
and so forth which becomes more reversed
for development so that's another
property of the language that makes
groovy more useful for building dsl so
we touched on some of those aspects
obviously I didn't cover there is more
aspect to that but I thought but I
thought that the main message is that
we're using groovy because it's
extendable because it gives us the
ability control the compiler and because
we can create dsl as a result of that ok
so now that we talked about the idea the
problem what we try to so I wanted to
give you an example how we solve it and
what I'm saying we I'm the city of Giga
spacer actually didn't introduce myself
so my sit my name is natty Shalom and
I'm the CTO and founder of Giga spaces
and one of the things that we do is we
launch a product an open source project
is called clarified one of the things
that we try to do employ defies actually
solve a lot of those problems and what
I'm going to do in the next slide is
reference to that project and reference
to that in a generic word meaning what
are the lessons that we took what are
the methods with thuy use to address the
question that I mentioned earlier and
hopefully you're going to take that as a
as a lessons and a lot of those ideas
are mentioned earlier our generic so you
could very much take it and implement it
in your own project so let's see how we
address that so first of all when we
created the dsl remember the structure
of an application that we look at so we
said okay we need to map the domain
model of that dsl into that structure so
the constraint or the construct that we
have
is an application the core construct is
an application and a service we also
have a pod we didn't implement it yet
that pod model but that's something that
will come down the line but the main
contract are an application and a
service we'll see how that maps into a
guru base dsl so you'll see what I'm
talking about look at that basically
what we have here is a pet clinic
application that as Java users you've
probably familiar with that it's a
pretty common example that is actually
using not my sequel but using a database
that is a Mongo and mangu itself is
built out of services yeah exactly so
Mongo itself is be a lot of services we
describe them as services as well and
and that's how we construct that so we
can actually take a complete cluster and
map that in that world and there is
dependency between them so you can see
for example that the Tomcat service and
the Mongol service that is dependent one
another actually I omitted the
dependency just to make the snippet here
something that could fit into that slide
but there is also the dependency like in
this case all those other tears that are
missed here so for example what I'm
saying depends on that means that this
one runs after this one
exactly exactly so that's an example of
how I contribute that but you could see
that you could actually read that and
understand what that application does
and how it is comprised and what are the
tears of that application how they
relate to one another without
understanding very much how each tier
works now that's not enough obviously
but it already simplifies our world
quite a bit try to go to anywhere in
your Java code and found how your
application is built in one single file
in a very simple readable way in front
PowerPoint presentations that changes
all the time and ever and documents and
week is but never something that is
binary that is baked into your
application and you know that it works
you know that it actually maps directly
to the application that is running right
now in production because it's part of
the in deployment it's not a definition
that sits outside of it okay so that in
itself is already helpful now you'd ask
ok that's a good start but where is the
definition that's too simplistic where
is the definition of how we actually
start that manga see they are patching
there is a lot of details there how do
we use that and another question that I
would add to that is what if i have
already something that defines that do i
need to build that from scratch now
forget everything that I've done already
and we'll try to address that whether
i'm using chef or whether they are using
shell script let's see how that how we
doing with that so the second element is
a service the service is the more fat
element this is where we'll have more
details actually ninety percent of the
details is baked into that element what
we're seeing is two elements in that dsl
of a service and we'll see more of that
the interesting thing is that it's
modular meaning that a service could be
very simplistic it could include only
the metadata with service and few other
elements and we can extend those other
modules so we don't necessarily need to
have all the component that i'm going to
show you right now as part of a service
why is that important
it's important because when we want to
build an application or poured an
application to that model we don't know
in advanced all that information or we
don't have to know in advance all that
information we don't know in advance for
example how to monitor all the custom
metrics and the SLA s that would define
the application that's fairly advanced
to in the process in which we developing
that application and want to be able to
introduce that in stages we don't
necessarily want to have everything
prefect because that's going to take
much longer process to map the
application into that one so the very
basic element is to define the metadata
the metadata is actually used for the
monitoring less for the actual
orchestration so for example the fact
that we calling it a database is mostly
used by the monitoring side to actually
use an icon that looks like a database
so that when we look at the monitoring
will know what it is but we have that
definition of a metadata that other
services that would be able to query
that information would be able to use
that for other purposes so beyond the
metadata that and by the way the other
piece of metal metadata would be other
things that we want ad for properties
for example what would be the URL for
the application and we can actually add
that it doesn't have to be static it's
something that computed I'll show you
that in a live application the other
element that is important is the life
cycle remember the question that I asked
earlier what if we only have a
definition a script that we're using
right now manually to start and stop my
tomcat server on a Mongo server they'll
need to recreate so the answer is
generally no we can only met them into
that definition and basically say which
script to call in which context so in
this case we're using a groovy script as
a shell script but we could also map a
shell script here adult SH or batch file
in windows or have a definition that has
four windows run that script for linux
run that script I don't have that in
this example but there is another
example so there is different ways in
which I can set the value for a given
properties and that's part of the
definition of the dsl's that I can and
the use of groupies that
can put different values easily into the
same property and that case it could be
an array it could be a string and based
on the value we know how to act a format
that's the core part of a service and by
doing that we can actually map to an
application and we can cover a lot of
things we can cover the consistent
deployment installation configuration
dependencies a lot of things just by
doing that piece but we want to do more
okay so we'll see how we extend it what
other things we want to do for example
remember the scaling things that we
mentioned again you could read that
let's see if you understand what I'm
trying to do Total Request right now try
to do that today without a DSL have you
tried it today even go to Amazon and
user you know the the watch element and
some other services an API that you
using try to define the matrix and the
rules and then what to do with that rule
you get this size of files not kidding
you and if you'll understand what it
does beer on me anyway the idea this is
the in my view a best illustration of
the value of dsl like it actually
condensed things that right now fits in
a very complex and we're both things and
put it in something that is very
readable that's the whole idea I mean
take everything that I said basically
what we want is build readable code that
will work that's in a nutshell the only
thing that we're trying to do all those
bits and bytes are the means to an end
but that's really the end goal so we
really want to be able to say you know
take anyone in our organization and say
tell us what you want to do write it in
a way that you understand it with all
the definition and now we as technician
what what need to take that definition
that credible definition and try to make
it work and we use the language will use
the extensibility of the language and a
lot of features that i'm going to talk
on i'm going to touch on the
the hood things to actually make it
callable to make it something that runs
that's in a nutshell the interface so
for example in what we found out is that
in order to monitor and application the
what we didn't want to do is map the you
know replace the entire monetary aspect
what we wanted to do is monitor only
these things that matters the KPI is
they are called key performance
indicators what we found is that there
is a lot of stuff toys jmx in the Java
world there is SNMP there is tons of
things and if we try to build plug-in
for everything that's going to be
endless process as well and not everyone
for example Mongo doesn't have any any
of those standard api's they have their
own custom API some cases it's a REST
API in some cases just a CLI command
line interface that you called to
actually grab that in some cases you
actually need to call to log files and
grab that information so in order to
make it very simple what we said is
basically per service all we need to do
is have names and values for those key
performance indicators how we grab those
values can be different pair service we
don't need to know the details of that
that details can be in a closure that
details can be some put somewhere else
and you could actually call a call then
we don't really care so in this case
what I'm using is a jmx for example but
I can map that in a case of mongo to
something else the result would be that
every service returns an array or map
file sorry map object of keys and values
that is continuously being updated so
every time that a monetary debt service
i'm getting a list with the updated
values very key then i can apply rules
like that scaling rules so if i have a
composite metric i can map that in that
closure i can write any piece of code
here that says the metrics that i want
to scale for is going to be computed
metric what is the logic of that compute
is not something that I need to map in
the dsl I'm actually giving the power of
the language to do that logic I'll give
you the tools and libraries to do
statistical computations very easily but
I'm not going to get into that layer and
try to map the world here again ok so
that's so there it is that you could put
a closure here
anything that you want in terms of the
logic of that matric ok let's go ahead
another example so at the end of the day
this is how it's going to look like so
for example when I'm taking those key
values what you can see R is that I can
say this value needs to be monitored as
a gouge and another graph and some other
things but the important thing again
think about how application a bill today
is whether we describe the application
I'm also describing the operational
aspect of that application meaning how
to monitor it because I need that
information not just for monitoring
aspect and if that information to keep
their silly of the application what is
their cellar application is part of the
definition of the application the SLA
could be a latency there so they could
be availability SLA and some other
things at once I I map that I can
actually have that information backed
into that same definition ok let's go on
the other thing that I want to do is say
that this script that definition of
application needs to run any work by
anywhere I mean bare metal machine I
mean amazon Rackspace openstack cloud
stack everything I don't want that
script to be different very environment
because once i do that i'm breaking the
entire definition so how do i do that
because each environment is its own api
amazon is its own API its own image
format it's on whatever there is no way
that I can find the least common
denominator for everything so what we
did is we created something that is
called a template a template basically
says this application needs to run on
this type of machine type of machine
small linux the definition of that
machine is going to be different pair
amazon / Rackspace or whatever but we'll
keep that outside of that recipe
somewhere else in a place where we call
it a cloud driver where we keep
everything that is platform or
environment specific at salad recipe and
that's how we can keep our recipe
portable and all those custom definition
outside of that so we don't necessarily
trying to create at least come in the
denominator for everything what we try
to minimize
that change in the areas of change
instead of having them scattered around
our recipes in code pair deployment they
all centralized in one component and
that case the probability becomes much
simpler and there's a different
implementation for a lot of that so we
have a good starting point that in most
cases we don't need to even mess with
that so if we still net standard wall
we'll probably find that the default
plugins fit that and you can see the
difference mapping for each of that
environment one of them is mark space
one of them is in Amazon each one of
them is different but there is a lot of
similarities also between them I believe
that you know over time the differences
would also get lower and the last bit is
as I mentioned air what we don't want to
do is reinvent the wall as we pointed
out there is already technologies not as
early in Java that is doing a lot of
that mapping the definition of how we
install an application so i mentioned
shell script in the ability to call
shell script but there's also places in
which we are already using share for
puppet or some other configuration
management tools to implement a lot of
that logic of how we install or run an
application and what we wanted to do is
not replace that even though technically
we could but map to that and what we did
here in the dsl is we enable to extend a
service definition to say how you run
the application how you started how you
configure it is defined in a chef script
how do we do that we basically extend
that as you could see into a chef so by
extending a service to a chef we inherit
some chef properties into that service
what are those shared properties usually
it means that I can actually tell in
this case qualify what are the cookbooks
what are the recipes that will be called
/ installation and that case I could
inherit or import the chef cookbooks as
part of my service definition and use
the service definition to wrap that with
extra information that is not part of
that cookbook in most cases like the
metrics that are mentioned and some
other properties that are not part of
the chef
recipe so lovely the installation
configuration etc it's something that I
can actually import and use in reuse not
necessary implement we're doing the same
thing for puppet as well so the idea is
that it would be extendable such that i
can plug in those different technologies
into that and not necessarily come yet
with another configuration management
that requires a rewrite of the entire
thing so that's an example of how dsl
look like and that's what we've built to
address a lot of those questions so
hopefully that gives you an idea when
I'm talking about the dsl is a solution
to the problem that I mentioned at the
beginning this is what I meant okay so
hopefully that gives you an idea and
again try to take that in a generic way
so you could implement the same thing
your own environment you don't
necessarily need to use that tool now
this the last part of this discussion I
want to go a little bit under the hood
and show how we implemented that dsl
what are the features a groovy that we
use to implement some of those control
and I'm going to go through a few
examples I'm not going to cover
everything so let's take the service
component that I mentioned earlier as an
interesting case this would be for
example how it would look like if you
would write it in Java obviously I
missed a lot of details below but for
the sake of illustration that should be
good enough what we want to do is get
rid of the imports and this a lot of the
dots that you can see here and make it
more readable like the one that you've
seen at the beginning okay so we're
going to use certain features of the
groovy language to get rid of that noise
to make it more readable let's see which
features were used and hopefully that
will give you an idea so the first thing
that we did is we used constructor with
no parameters so we constructor with no
parameters we can actually pass in a lot
of the properties and value without
doing all this dot dot dot think that in
groove is built in that gives us a way
to already or meet some of those noise
that's the first feature that we using
out of the groovy language the second
thing that we're doing is interacting we
want to get rid of the import closure
right the first import lines how do we
do that in groovy in groovy there is
something that is called compiler
configuration the compiler configuration
is a component in groovy that I can
actually tell the compiler which
libraries which components to import
before it actually compiles my script
and I can tell it what are the libraries
that I wanted to import before that so
in that case the areas meaning that our
code that would run your script would be
able to run it but before we run it we
do the import outside of your script and
the way we do that is we interact the
groovy compiler tell it which classes
which libraries we wanted to import and
only then call it script in that case
the compilers already include the
definition doesn't have to be part of
your script that's the idea here it's
pretty straightforward okay the
component the API that we're using is
called the compiler configuration in
groovy and this is basically how we tell
it which libraries which elements of
information we want to have pre back
before we call a script and that means
that we can omit that information from a
script so a lot of the things that are
generic to our script that are
repeatable it's something that we want
to take away so that the user wouldn't
need to know about that and use that's
what we get rid of the import so we go
to that point where we can have that
service definition without the import
without a lot of the noise so we're only
in a good place but not enough the other
thing that we want to do is extend
further another feature that we use is
that we could tell groovy again through
that same binding and configuration we
can tell groovy which base class it's
going to use it's going to generate for
our script usually what it does by
default is using some sort of a default
script class as a base class what I can
tell the compiler is that when it's
generating my
script it's going to use my classes
which means that I can actually add
properties and any methods in that base
class that by definition is going to be
part of every script so when I'm running
the script i can assume that those
methods exist without actually writing
them or importing them or whatever
that's how i can extend that very easily
so that's another method in which i can
remove a lot of the definition from the
script keep the script simple and fit
all the repeatable work outside of that
script so that's another way sorry
exactly so let me show you an example
and I think that will address so for
example we wanted to say that every
print line every call to print line
would go to a log so we did an override
of the print line method and made it
such that every one that every time that
you call in print line in your groovy
script it would go to a log that's a
that's an example of how you do all
right also for the default
implementation okay so it's the same
groovy script now we extending its
capabilities with other things just by
doing that method so it's another
feature of the language that I used to
implement that again I'm just trying to
work through first of all the dsl and
then how we implement that and what
features of groovy we used to implement
that to give you an idea how you could
extend that yourself there is much more
definition on how you do that so by all
means there is no references than the
one that I'm going to refer to but
hopefully you get the idea the other
thing that we can do is extend the class
definition itself there are different
ways to do that there is a method that
is called monkey patching which
basically means that I can actually
interact with something that is called
meta class in groovy and by interacting
with a metaclass I can extend the class
in runtime i can add properties methods
and other things into the class itself
the advantage of that method is either
do a java p on that class or something
yeah like that on the class itself is in
groovy I can actually see that new
definition in the class itself the
method with we chose to use is slightly
different it basically says that
it is a hook that basically means that
every time that I'm invoking a property
or a method that doesn't that is not
part of the class definition it would
call that method and I can put a logic
around it the advantage of that is to be
very generic I can put one place with
all the definitions so if i have a
generic rule that applies no matter
which properties i'm using which method
I'm using that could be an easy way to
do that because it applies to all the
classes regardless the disadvantage is
that I don't see that in a metaclass so
if I'll go to the matter class I
wouldn't see that logic extended into my
class in our case that was a simpler
solution than extending the matter class
because the rule that we want to do it
is fairly generic the last point is the
binding so for example one of the
requirements that we had we have recipes
that are pre back with a product for
example a cloud driver would be a good
example for that one of the things that
we wanted to do is ship or distribution
of our software into a user which has
its own Prudential to the cloud and its
own properties and whatever so before
that what happened is that every time
that we ship that software and that
libraries you had to go to the
configuration and change it and put your
variables in those scripts obviously
that means that every time that you
change versions and other things that
becomes very person very complex and so
what we wanted is the ability to inject
a lot of those properties as an override
overrides meaning that I can take the
libraries as the back blocks take it
from get up compile it and build it and
we'll have some default implementations
and I can override it from the outside
by injecting my properties into that
without touching the scripts the method
in which you could do that in groovy is
called bindings ok so in bindings I can
actually tell and set variables and set
properties before the compilers runs
your code and that means that when you
run your script those variables will be
available for you with the values that
you provided from the outside and that's
the idea here so you can see an example
how we do that for example we wanted to
have it
definition of an image and a pre-start
message the way we do that is we call
binding in groovy passing the properties
files with those variables and then when
we use our script we can actually use or
refer to those variables even though
they are not the definition of those
variables is not part of the script so
you can see for example in icon and an
image sorry that is part of my script
right now as if it was a verbal but
nothing in the script defines that it's
actually done outside of my script using
that properties file right but I can
refer to that as if it was a variable
that was defining my script and what we
used is we use a naming convention to
say if that script has a property file
under the name of that scrape the
properties then we load it in the
binding and then we know that it it's
available when we write the script so
that was a way to address that problem
hopefully that makes sense that make
sense good ok so we're close to the end
so the end result is that we create a
lot of that generic definition of
application for a lot of things that
exist out there right now so we can use
that different script that right now
existing get-ups and get up repository
and that means that if I want to deploy
and that's the advantage of that if I
want to deploy Mongo if I want to deploy
my sequel a partial answer a lot of
those common stack I don't need to go
through the process of defining it I
just grab it and use it and if I even
want to build my own application in most
cases the areas in which I need to
define all those dsl's is only in areas
that are special so for example the
things that we added to the dsl is
something that is called extent like in
the Java language which means that have
a golden image of how Tom cut is being
defined generically but let's say that I
want to override the x MX or some other
variables of that I can only offer right
that and still extend that gold image or
gold definition without overriding it
and then creating a fork creating a fork
mean that if you know in the github
someone update added more logic added
mometrix
can we inherit it when i'm doing it fork
so i don't want to do that i just want
to do then overwrite that's how we did
that and that's why we can come up with
that set of recipes and because we
extend the chef and puppet we can also
have a lot of those recipes in place
that already gives us the power to grab
a lot of the new information without
doing the actual work ourselves so even
though we have a recipe even though we
have all those definitions we don't want
to do that or so so with that I'll jump
to a short demo that will give you an
idea how that looks like in real life
very very show them okay and the purpose
of this demo is really to map a lot of
those abstract concept into something
real so this case i took an example
which is the pet clinic or the travel
application the spring travel
application if you may well with and i'm
using clarify and chef to deploy it and
we'll see how that looks like and what's
the end result looks like the first
thing that we're doing and clarify is
that i download clarify my desktop and i
configured the basically the cloud
driver for my definition you could see
it somewhere here okay so this is the
CLI so I just started the CLI the first
thing that I did is a command that is
called bootstrap cloud OpenStack and the
OpenStack is actually referring to the
HP OpenStack implementation somewhere in
the network and what I did buy that is
created a server that is going to be my
gateway to that cloud so I'm starting
fresh nothing is installed there is no
qualifying that cloud there is nothing
of my environment the only thing that I
did before I run that is that I set my
credentials as part of the driver
definition of that OpenStack I'm not
going to go through that right now but
there is a way take five minutes to put
all the properties in the right place
and from that point that's not the only
thing that you need is to run that that
thing the end result of that is that
once the boot up process has finished
you basically get to that point where
you have these things up and running and
if I go to the web console I can already
access that environment and what you
could see is the clarified dashboard up
and running and the qualified dashboard
gives me
formation of the application that is
running in some statistics I didn't have
to do any of that let's comes out of
that right out of that and the
definition includes the application that
i deployed and i'll show you what i did
to deploy and also the management of
qualify is also treated as an
application so when we deploy clarified
we deploy the rest gateway and the
management console which is web web
server and everything like that is also
treated as an application so we can
monitor that using clarify itself so
clarify in itself monitor itself so we
can see some agree that value of the
told memory to cpu of all the aggregated
machines that exists out in the network
and i can see some of the aggregated
information about the number of servers
the type of server as the type of
services that are totally running right
now the second thing that I did was the
install the application and I did that
using a single command that is called
install application there is two
commands one of them is installed
application the other one is install
service install service would install
the individual component the database
the Mongo whatever install application
would go to the application definition
it would run the entire thing all those
composite applications composite
services so this case I did install
application which basically goes to the
definition of the application figure out
which elements needs to be running in
this case it's my sequel plus web tier
plus log bouncer and it deploys it and
you could see some of the output in the
console of what happens to do that and I
can actually the end of the day see the
resolve that here if I go to the
application I can see that the apology
of the application that is actually
taken from the definition of the
application dsl I can see the dependency
of which one of them I can see that
there are currently two instances of Tom
cars running right now I can see if I
click on one of them I can see different
views of that tomcat for example I can
see the custom metrics that are part of
the dsl I can actually see that one of
the one of the service takes more load
than the other all that comes out of
that I didn't have to do any of that to
actually get that monitoring one side it
was deployed the application because the
application includes that matrix I can
create that view dynamically because
there is a definition
already that the monitor is understand
which is the dsl i didn't have to go to
the monitoring and say my application is
bill out of those things and those
things and those things it actually
understand it pass it and create a dream
it's all America Lee that's the beauty
of that now the other thing that I can
see is this thing this one is red for
example right now why is that red one of
the common problem on managing clusters
is managing or understanding how the
cluster is balanced everyone that runs
clusters at some point find out that one
customer is taking more load than the
other Twitter for example is a very good
case and usually a lot of the crashes
that we have is because of that because
one of the nodes we didn't partition
well the cluster one of the node takes
most of the load it explode it breaks
and then the entire cluster gets done so
why don't you have a very simple view in
which we can know how our cluster is
doing so the gouge here shows us the
aggregated result of those individual
service remember we have a cluster each
cluster has a different value for that
same metric that we monitoring we could
have you know all those metrics exposed
to that which is going to be very her
boss a lot of a lot of information that
we don't necessarily can press or any
human being can pass easily only thing
that we met that its methods for us is
if something is wrong that's it
something is not wrong we don't really
care about those different metrics so
one I have and pass that information
very quickly so that you know if
something is wrong on out and that's it
that's what we did here so with that
gouge we know if the cluster is balanced
without drilling into the details and
then once it's not balanced then we will
breed down into the details but only
there and we can see the logs and some
other information about the instances
that is running and we can go and see
the details the meta information prayer
service for example on this case i can
say go to and see how the load bounces
in the cluster and it actually sees two
instances running right now it's
actually started with one and I did
something I did a scaling event I
simulated it just takes the process
takes a little bit of time emulated
scaling event that created another
instance and added automatically to the
log browser so again I didn't have to do
anything
only thing that I did here is trigger a
scaling event and that created a new
tomcat server and that Tomcat server
automatically configure that in the log
dancer and everything went up
automatically the same goes with fell
over so if I crash one of those
instances well I'll see is that it will
monitor the SLA say that there needs to
be two instances here to launch any
machine configure that and that's it so
that I think we reach into the end I'll
just show you the examples of how i did
that trigger of event so all I did here
is set instances up to app is the name
of the server so for example I did hear
least services and I can see the name of
the services that are currently being
deployed and then I can interact with
that take into account that I didn't
have to point any IP address any host or
anything like that I interact with the
service using a logical name because of
that I can take that same application
and run it on a bare metal environment
on a cloud environment or any
environment and it will work because we
abstracted a lot of the infrastructure
details out of their recipe</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>