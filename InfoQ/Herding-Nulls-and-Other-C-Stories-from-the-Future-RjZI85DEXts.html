<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Herding Nulls and Other C# Stories from the Future | Coder Coacher - Coaching Coders</title><meta content="Herding Nulls and Other C# Stories from the Future - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Herding Nulls and Other C# Stories from the Future</b></h2><h5 class="post__date">2018-01-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RjZI85DEXts" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I do want it just for the record
c-sharp is a 21st century language I
think we came out in the year 2000 so we
just make it anything and and talking
about my background I was actually
involved in Java generics for a while as
well and one of my co-conspirators is in
the audience today so I'm very very
happy to see that Phil Wadler he's his
parts were more successful than mine
anyway so so quickly moving on to to
c-sharp there's this it's a survey that
stackoverflow do every year and it
probably that probably all sorts of
caveats about you know grains of salt
that you should take the data with but
as long as they're in in my favor I
consider this the ground truth so I just
want to quickly this not so yes it is to
brag a little bit but it's also to say
like c-sharp is sending interesting
situation in the in the market today
it's one of the according again to this
and other sources it's one of those top
five programming languages in terms of
usage and so it has despite having been
mostly on Windows for most of its life
it's it's succeeded in penetrating quite
far into the market and now being
cross-platform in earnest both in terms
of development environment and target
environment that's the certainty the
sky's the limit here
of course Java is still up there that
must be must be those Java wildcards
that are that are keeping it head so but
other than that they also measure the
most loved languages and the way they do
that I think is these they say like the
percentage of users of the language who
would like to keep using it thank you
very much and and so this is sort of a
this is the place for the smaller
languages to get a chance to shine like
the with very devoted followers and the
thing I'm essentially the thing I'm
proud of is that we're even on the top
10 with c-sharp here it's it's it's one
of the most loved languages so we're on
both of those and but it also kind of it
challenges us as the stewards of this
language to to try to keep it that way
like once you get appreciation you hate
loosing it right so we kind of we need
to keep getting that reaffirmation
that fix of appreciation there so not
particularly for that reason but we we
thought about what is what is it that
make people like C sharp and we don't
actually know we don't have hard data
but one of the things that we've always
done that seems to keep working is that
we've we started out looking a little
bit like some other languages that were
around at the time to just be very vague
about it and but we've sort of taken a
very aggressive stance on involving the
language as we went and if anybody was
here for you probably a lot of you were
here for the previous talk about go in a
sense we have sort of the opposite
evolution strategy of go in that we are
very eager to keep the language fresh if
you will to keep it up-to-date with SS
challenges and and the sort of domain of
software development changes we want to
keep C sharp moving along and B and be a
good choice for for those new challenges
as well as when programming languages
around us evolve and come up with new
ideas we want to see we want to borrow
some of those good ideas into the
language and and evolve the the
development experience so that means
that we're there's always a scale
between not doing enough in your
language and eventually you probably
become a dinosaur you become a language
that people are maintaining code in but
they're not starting many new projects
in it and if you add too much to the
language then you might die the the
death of of a thousand cuts like you'll
be some behemoth that people can't
really use anymore either way your
language can just run out of steam
because the foundational principles no
longer apply sorry you know out of
business but we're very much on the
let's evolve aggressively kind of side
let's try to be a state-of-the-art
language for development for for like
professional developers and that's let's
push the envelope and sometimes lets us
be the ones that push the state of the
art not just keep up with it and so
that's sort of to lead into what this
talk is about too
because instead of talking about oh
what's new and c-sharp 7.2 as opposed to
C sharp 7 find one and all that stuff I
assume many of you aren't actually
c-sharp programmers to begin with
actually let's let's do a poll how many
people here are c-sharp developers okay
that was actually a lot but you see like
that's just because you're such a
popular programming languages no there's
no bias in the room I'm sure so ok who
who did not put up their hand before ok
so ok had more than a smattering so I I
kind of wanted to not just do the what's
the next in c-sharp but but give a
little bit of where do we think we're
headed slightly longer to him hopefully
with some things that are interesting
even if you are not about to write your
next t-shirt project or consider
adopting the language just just more
than the fun side so we're looking at
some of those problems that have been
dogging us for years and years and years
and here's one the the null problem that
we all face that's actually you know
let's go and let's go and throw an
exception so um I have a fund with no
program here this program has a bug I am
creating a person with the first name
and a last name I asked for the length
of the middle name the implementation of
that takes the middle name and grabs a
length of it and returns it it's
completely straightforward and yet of
course as you probably suspected if we
if we run this program we will
immediately get an exception and I'll
reference exception because hey the guy
didn't have a middle name was null okay
well that sucks how many people in here
actually like getting retinol reference
exceptions there's one down there is
that because it helps you find your bugs
you I couldn't even hear that but
okay it's alright that's always someone
who wants to be interesting and and you
are sir you are so the the problem is
obvious right but if there's no single
place in the code that's to blame that's
always a problem with that kind of
feature like every reference type in in
the language just like in most other
object going to languages at least every
object type allows nulls and who's to
blame the one who put the null in there
the one who didn't check that it was
there before they took it out that's
that's the kind of problem that that has
been dogging us for years of course
there are there are programming
languages that don't have this kind of
problem so if we go back to the to the
slides here the you know lots of
functional programming languages for
instance they don't have a null problem
they don't have a this concept of null
that can go into every type they have
maybe they have discriminated unions
that describe an option type that can be
either nothing or none or whatever they
call it or it can be it can be some of
tea or tea some type and so they have a
type construct that means that you can
clearly distinguish by by the thing
whether it's null and not but you're
also forced to whenever you want to
consume an option you're forced to do a
pattern match on it or some kind of
check and and go down either one route
or the other depending on whether it's
the summer and all this the language
just by construction does not allow you
to dereference and nothing so so that's
kind of nice unfortunately we already we
already have a language here and we
already have a lot of code we have like
billions of lines of code they're doing
they're dealing with us already and so
we can't just go and say oh let's do
null differently that's not a solution
for c-sharp and honestly in many lands
of languages it probably would be a good
fit anyway so but there's something we
can learn from it which is
that there's an expression of intent
like immediately when you declare a type
you say whether it's a tea or an option
of tea in those discriminated union
terms or you say that you could sort of
imagine expressing whether this
particular thing this variable of this
return type of whatever whether it's
supposed to be NOLA not right express
your intent and you're already sort of
halfway there now you know who to blame
right that's the thing from before if
you have expressed your intent with the
thing then either it's being abused on
the one side or the other side like
either you send a null that wasn't
supposed to be there or you do reference
the null that that wasn't supposed to be
there that you hadn't checked for right
so expression of intent then enforcement
of that intent that those should be the
components of a solution to this and and
yes we have this challenge it has to be
within an existing language there all
these billions of lines of code they're
actually probably millions of those
billions of lines have been actually
probably tested and and are actually
probably null safe and so we don't want
to have a solution that goes over all
your code and says it is all wrong you
have to rewrite everything it has to be
one that is gentle with existing code
and fits well with what people do today
to deal with nulls okay so that's that's
what we're going to try to do so to the
expression of intent thing first there's
one approach you could take to say okay
the the object types in c-sharp
reference types the they're already dead
like too bad man they they just they're
just inherently wrong they're legacy so
we can't get rid of them so let's
introduce two new kinds of types let's
introduce the nut inaudible reference
types and the properly safely nullable
reference types and then there's these
legacy ones in the middle and then you
get some something like this where you
you annotate everything I don't think
the yellow markups and the bold would be
in your in your source but other than
that and and that doesn't really that's
not really feel like a good solution
because it over emphasizes it kind of
leaves the good syntax
the one that doesn't have the one that
doesn't swear at you it leaves that for
the things that you're supposed to no
longer do which is to be unsafely
nullable in the old-fashioned way the
legacy way and it also means that all
existing code you get no help like it's
just existing code is dead in the water
until you go in and start doctoring it
and and swearing all over your code with
punctuation you get nothing from the
future so while this might immediately
feel like the safe route to take it's
also the useless route so we're not
going to do that so what we want to do
instead is to assume that when you don't
say otherwise you don't mean no okay so
yep there's some code out there that
doesn't follow those guidelines and then
when you do me know you put a question
mark on it on the type and now it's a
nullable thing okay express our intent
god we now repurposed existing syntax to
mean something new we now set string
without annotation that means none
nullable string
we like the syntax if we were designing
c-sharp from scratch this is certainly
the kind of syntax we would like but now
the question of enforcement comes up
enforcement has to it has to do things
do two things essentially has to protect
none all types from nulls so you say
it's not null let's not put nulls in
there and it has to protect the nulls
that are there and are allowed to be
there from being the referenced at least
without being checked first that there
weren't actually not okay but because we
repurposing existing syntax this has to
be an optional check like so we
essentially we want some checks that you
can consume turn on and say now start
start enforcing this on my code and see
where it leads me and that should
hopefully be that should hopefully lead
you down a path where if you a few
questions and a patient's later you're
in a good spot and a few fixings of bugs
which is the whole like the whole point
is this has to be useful an existing
code it has to flag things that weren't
flag before so just for backwards
compatibility it has to be something
and you turn on when you're ready to be
told that the code did you have today
isn't good enough also because it's
optional like it can't affect the
semantics of the language in any
significant way can really only be about
giving you warnings must do a good job
with existing code I kind of set that
already and it unfortunately can't be
exhaustive it can't give you guarantees
so this is this is one major concession
like we're saying this is not about
guaranteeing that your code is null bug
free this is about maybe an 80/20 right
you get maybe 80% of your of your null
reference exception bugs you get those
at compile time there'll be some left
and there'll be places where we
deliberately we're either way we just
that we can't do the right thing right
thing in terms of correct or we won't
because it's too inconvenient in terms
of existing code or even in terms of the
new code you have to write and we'll see
examples of that so I'm going to let me
see yes I'm going to go back to that
slide and switch over to a prototype we
have of that's actually the code I was
in before the fun with null a prototype
we have of a compiler that does these
things so let's see it fix our bug there
are warnings in this code but that's
because they're warnings in this code
this is a person class declaration okay
so I I'm starting out I have two
constructors I have one that takes all
three of the first middle and last names
I have one that takes just two of them
because middle name is optional but I'm
getting a warning here so this might be
existing code you have today I'm getting
a warning saying hey you have an
unknowable property called middle name
which is not being initialized oh well I
guess I can initialize it let me in
issue let me Oh interesting I don't get
to write code today as I said a
prototype why don't we just sneak on out
of here and I think of
thing to say well it starts up again
this prototype little secret not too
secret I guess room is big the prototype
goes public couple of days from now and
so you also get to nut type code
there you go see works now just restart
so let's initialize the middle name to
null so you see what the warning was
good right it told you everything that
you declared that is that is supposed to
be none nullable well it's null by
default so if you don't initialize it
somewhere it's going to stay null and
whoever creates you is gonna get
something with a null in it that you'd
say said wasn't gonna be there so okay
I'm gonna initialize it then now of
course I get another error saying you
can't so I help so that one warning went
away but this one says hey you can't put
null in an unknowable thing well guess
what this is probably a point where you
realize if not before okay let's go and
annotate this gate it's actually
supposed to be no I actually want to
advertise to my consumers that they
might risk running into a null here
great I've done that all my warnings
have gone away so happy now no I'm not
happy now because now that I've
entertained my class correctly now I
start getting morning's in the consuming
code saying yo bud you are taking a
nullable thing and assigning it into an
unknowable thing you might want to think
about that okay yo bud your
dereferencing and nullable reference
type you might want to think about that
okay so so here you might go so um what
I need to do here this is where okay so
this way it comes in we're fitting in
with what people do today is important
so the so what I need to do now is to
convince the compiler that this thing is
not actually null when I do reference it
I can't
this right here because it is actually
sometimes null okay so I have to make it
so that it isn't one way to and the
compiler is then going to actually do a
flow analysis on my code and see if it
can figure out that the thing is null
and let me do it so if I say if middle
name is null return zero for instance so
I just have a default implementation
there you see the warning goes away
right flow analysis said yes you're the
referencing a Nile bowl a nullable thing
here but you can't get here if it's null
so I'm fine with it okay so this is code
this is correct code that you might have
written before and so if if your code
was already doing the right thing you
wouldn't get a warning right this is how
we try to make the feature non-intrusive
to existing code if you are already good
nine times nine times out of ten the the
thing won't won't complain of course
there are other ways that you can you
can fix it's pretty pretty much up to
you I could another thing I could do is
I could assign to middle name here I
could assign it the empty string now I
can get down here even if it was null
before but again the compiler can see
it's not null now like regardless of
which path it uses to come down here it
won't be known when it gets here or you
can there are the paths you can take we
can also use the we can use the
questioned operator which is sort of no
conditional it says if that thing is is
not null dereference otherwise make the
whole thing null but now the whole thing
is nullable int so I could go and make
you know I could go push that out to the
to the caller and now give give the
error to them and so on
you know I can push it around the way or
I can say I can use the null coalescing
operator and say if that whole thing
isn't is is null return zero instead
okay so all of these are ways I can fix
the problem that are valid were valid
before a valid today and that the
compiler realizes yeah good job okay so
it helps you'd help me find my bug help
me fix it helped me realize where I
should annotate my types in my API so so
that's that's the that's the purpose of
this thing okay with me so far
so as long as you are not as you don't
mind like getting pushed around a little
bit in your existing code and fixing
some warnings again there are only
warnings you you can you can find a lot
of those bugs before they happen in
production which you know according to
Tony Hoare who who claims who proudly
claims inventor ship of the null pointer
the he calls it his billion dollar
mistake in in talks which you should go
and see and at least here we got some of
those billion dollars back right in that
some of those null references don't
happen now there are ways in which let's
fix this back to having a problem there
ways in which you can fix it that don't
that the compiler can't realize like we
could say if string that is null or
empty
it's a helper method and string takes
the middle name then return zero okay
well first of all that one should
probably be fixed to take a nullable a
noble string itself otherwise asking the
question is kind of dumb but also the
compiler can't see that this actually
doesn't all check for us it's another
function somewhere so we might need to
think about other ways we're not going
to do intro interprocedural analysis
here that's just too crazy but we might
think about some ways that we can tweak
we can like say and a given method
checks give an argument for null
something like that we'll have to think
about whether we can refine it but the
main thing is regardless of how much we
refine it there's going to be times
where you're smarter than the compiler
you know it's not null even though the
compiler knows it doesn't know that it's
not null and so for that ladies and
gentlemen we give you the damnit
operator or that I know what I'm doing
operators it's a nicer version of that
which we haven't decided on a name I
think maybe it's called to sort of the
null absolving of the the null forgiving
operator or something
like that essentially it says if you if
it's a postfix operator you put it on an
expression that might that the compiler
thinks might be no and you essentially
take the warning away saying I know what
I'm doing don't worry so I can do that
here but then I take responsibility
essentially I'm back in the old times
where it was my problem okay so finally
you know that I talked about those
places where we can't help you or we
don't want to help you so an example of
where we probably should help you I'm
taking the let's again go back to the
code from before I'm taking the the
middle name here and I'm putting into a
local variable that's because of some
limitations in the prototype right now
but I should really be able to just say
you do not have a local variable here
and just say if peed on middle name
asked directly Peter if I could spell
here appeared a middle name equals null
and all those things and then just say
Peter the middle name down here as well
I peed middle name so I should be able
to just as I was tracking a local
variable before I should also be able to
track like dotted chains like these
right say I I get out the Piton middle
name was null up here and then I left
out so down here it won't be and so on I
can't do that yet but when I can which
is the intention then there's going to
be this whole thing about what are the
things that invalidate our assumptions
about a dotted chain what if I assigned
one of the things in the dotted chain
assigned something else well then
probably whatever I thought about the
null ability of something further down
the chain is invalidated and I can
easily discover that from the compiler
but if I call a method with P Who am I
to know if that method changes P or not
I can't really know so either I can be
super defensive and then all the code in
the world that does this which is
probably many millions of lines of code
will get warnings all over the place or
I'm forgiving and that means there would
be null bugs that I don't catch but we
generally err on the side of being
forgiving another thing let's say I have
a string array so
actually can I
yeah let's say I have a string or a SS
here that is a new string every time
that thing is going to be full of nulls
I'm creating an array
it's full of nulls yet I said it was an
array of string not an array of string
question mark so and you see I'm not
giving a warning on this that's just
because that will be too inconvenient
right yes I should really want whenever
you create an array of string I should
really give a warning but that'll be
like every array you're creating in the
whole world will now have a warning and
we just don't want to do that to you and
also how would we discover that you've
that you went and overrode all those
nulls like would you some kind of fancy
analysis check that you wrote to all the
indices and like we can't do that
statically like we just not going to go
there we're just going to leave that
alone and I'm sorry you're gonna have to
still deal with those yourself that's
your 10% that we don't fix okay so I
think that was what I had to say about
nulls so this one we are working
actively on it's um
let's go to the let's go to the
projection sorry projection went away
let's project again so I think the next
major version of c-sharp will have this
we're giving it out in prototype now so
people can try it on that code basis and
come and tell us this part is too
annoying this part is too forgiving and
we can kind of fiddle and adjust find
out maybe the top ten refinements that
we need to deal with common scenarios
maybe like the is null or empty or the
first or default or whatever all those
things that have weird behavior to try
pattern there things there where we
might want to help you more and and do
some fiddly things right on the whole
that's kind of where we headed so any of
you pick up that prototype
couple days and and tell us what you
think that'd be great okay so that was
one thing now I want to change gears
completely and happy that Phil is here
today so let's actually go back to the
code before we before well on this slide
I just I did all that work to get back
to the slide and now I'm just going back
let's go back to some different code now
let's go back to the same code let's go
back to the same code okay so you notice
here that I have a half of this in my
declaration of this method here so it
could it could be just a parameter but
this year makes it an extension method
which means that I can call it as an
instance method on Miguel up here I kind
of glossed over this before this has
been in c-sharp for almost a decade
this is extension methods so it's really
great because I can have a declaration
here that extends the type that was over
there that I didn't own pretends that it
has some instance members that it didn't
actually wasn't declared with great
that's actually fabulous from a from a
software engineering perspective it
means that there all kinds of
dependencies that I don't need to have
and it gives me independent
extensibility but in a very limited way
right I can only do it on method methods
I can't do it with properties or
anything else and it's declared with
this awful hack that there's a static
method that has an extra modifier on its
first parameter saying that this first
parameter can actually pretend that it's
a receiver and this syntactic hack if
you will I kind of I we've regretted
that for a long time I think because it
meant that there was no clear syntactic
path to extend the declaration syntax to
have extensions of other kinds of
members could only be done for methods
if you want to do extension properties
well properties don't I get you know
static properties don't have a first a
first parameter that you can annotate
you could invent a syntax for giving
them one but yeah we actually went
pretty far down that path in c-sharp for
and then we had to
all out because it was yucky and so
we've been struggling with this for a
long time and eventually I think the
realist realization comes - yeah okay we
bet we went into a dead end we can't
push through the wall that's at the end
of it let's actually back out and come
up with some other declaration syntax
instead and that's what that's what that
slide was about that's what extension
everything is about so the idea we find
it quite powerful that this piece of
source code here can from the point of
view of sort of scope based from point
of view of the ones who can see the
declarations down here that thing up
there has to sext remembers right its
scope based extension based on the
static scope okay that thing is here
that means I know more about the type
than it they need new so that's very
useful you can imagine static or
instance members of different kinds
methods properties constructors even
just pretty and this this new
declaration syntax here just sort of
makes it look like it's a type
declaration it's sort of like you were
actually creating a derived class a
subclass
but you're not your so you have access
to this to talk about the the person
object itself and and the whole syntax
looks as if it's much it's a much more
full syntax for this stuff but it's a
new kind of declaration that looks like
a type declaration but it's different
so that gives extra expressiveness and
you can imagine that we can rewrite this
under the hood to do the right things
whenever let's actually let's compact
all that declaration take the comments
out and see usage right so now I'm
creating a person match Torgerson using
the extension constructor that makes him
a student of Tony Hoare I wish I really
wish I believed Li become a student of
Tony Hoare in my trying to deal with the
nulls and with your Tony so this is all
dreamland but okay and I can I can
access the property get my supervisor
out which is Tony Hoare I could actually
change my supervisor to be filled water
if I want it and you know access things
in access static members on person as if
they were declared a static members in
person as well they're the whole
collection of students so that's very
nice I think that would be a good
improvement in and of itself I might do
this as soon as the next major release
if we can get all our ducks in a row but
I think part of the interesting thing
here is where could this lead next what
is the bigger thing that this could lead
to now we talked about the software
engineering principle of saying more
about existing types there are actually
other languages that do very interesting
things with that Haskell is one of them
well Haskell has what's called type
classes which lets you essentially say
declare I kind of think of it as an
interface but that's very wobbly I'd say
that that thing up there actually
implements this interface over here as
well and here's how so imagine that we
have an interface I student that's
declared independently a person and
person doesn't know anything about it
maybe it's declared together with
professor right they kind of belong
together and that's an interface that I
can put on different things in the
old-fashioned way but I can also as I'm
extending students with members I could
also say that from my point of view in
this scope over here person implements I
student it implements that interface and
I highlight it two of the two of the
extension methods that help it do so
these are witnesses in in Haskell speak
to the how these explain how person
implements I student right and the third
one the name is actually in person
itself right so that's that's implicitly
implemented by a person itself so now we
took a big step further and we actually
allowed a an existing type to assume a
new type and and also be able to be used
a type that's also able to be used as a
constraint and generics and the old type
being supplied to that as long as we're
in the scope where all this is known so
I think that can
that can give some serious
expressiveness so I want to show a more
type classy example and this one assumes
this one so let's just say that we're
doing this with interfaces it might
actually not be that we might be that we
can't do it with interfaces but well I
think we'll try to push on it
we might need a separate abstraction
mechanism just assume let's say that we
we push on interfaces so they can also
express abstractly the requirement to
have some static members not just
instance ones this is saying that
whichever class implements this has to
have a static property that gives you a
zero value of some T that we're
parameterised over and it has a plus
operation on those so that's a that's a
group in math speak and T what's that do
I need negation in a group as well yeah
you're right what is this M oh no sorry
yeah yeah thank you so it's not a group
but it's close enough yeah for
presentation purposes I deliberately
whatever so now I want to go say that
and that it's the existing hints that
are at the core of the language they're
actually they were sent a mono ID where
the zero value is zero and and the plus
operator is inherited from from int
itself and just means plus okay
but actually you could you could
implement mono in a different way over
int I'm put it on the slide you could
also have int are also a monoid over
multiplication so you could instead have
said you could have rewired may be using
some syntax plus on the on the group to
mean multiplication on the on the actual
int and now we get into like what kind
of shadowing do we want under stuff and
then and then zero would mean one
because that's a zero that's a neutral
element under multiple
so I make something doing this extending
thing again and then I can once I can do
that then we can get to this thing that
all many of us languages have been
struggling with for awhile which is
proper abstraction over numeric over
numeric algorithms right how do you
abstract over numeric Ness in a way
that's expressive enough that you can
write an algorithm using all the
operators and everything beautifully yet
it applies to anything numeric from from
intz all the way up to matrices and and
tensors and all those like bigger things
complex numbers and whatnot and as long
as they have certain operations right
they can be represented by one of these
super interfaces so I think that that in
here also lies the possibility to move
into that kind of expressiveness
essentially the the language was
stealing from here is is ultimately
Haskell and there are several languages
that that are pushing in that direction
one way or another there's some real
expressiveness there and a there the
challenge honestly the two challenges
here one is to massage it all deeply
enough into the language that it feels
natural in c-sharp and let go so many
things we do many things we steal like
pattern matching that we already stole
going to continue to steal more of takes
a lot of massaging a lot of design work
to make it feel like oh that's just so
c-sharp it just really isn't when you
see it in its f sharp for meit's haskell
form or whatever and we'd have to do
something similar here the other thing
is to make sure that this is performant
at runtime like this is efficient
we probably if we want to use interfaces
for this we certainly need to add to the
runtime to be able to express to make
interfaces more expressive if we don't
want to use interfaces then it's
actually a prototype from Microsoft
Research in Cambridge people were
working with there that has a variant
efficient implementation of type classes
on top of the existing CLR runtime which
is
they use some fabulous tricks that I
might share over drinks if you pay the
drinks so so that's extension everything
I think that was ever no that's here's
the last bit of it is call just to bring
it all together right called the generic
method on an array of intz in a place
where we know where we have a witness to
the fact that intz are actually one of
these things and type infer that it's
int that we're talking about and it all
kind of flows through so that would be a
cool place to go I can talk a little bit
about async streams as well that's a
third thing that we're looking at also
probably for the next major release it's
a little less futuristic but hopefully
it's still a little bit interesting too
so let's switch back to code I don't
actually have a I don't have a prototype
of it but I can I feel like can better
explain it you know you know coding
context so where so many of you know
c-sharp and you know about async the the
language support for asynchrony some of
you were here before at the previous
talk where we heard about some of the
clashes between event-driven a callback
based programming on the one hand and
multi-threaded programming on the other
hand and we we kind of at some point we
took a swipe at more like unifying those
two things where we think that the from
it from a software development
perspective the real killer of the event
based side is the callbacks callback
callback suck man they really just
they're really just terrible and and we
can we can remind ourselves why they're
terrible here I have a have an
implementation a very an async
implementation of Fibonacci because it
takes some computing power so they so it
runs it on a separate thread could be
imagine that it's a more realistic
example right and in the old fashioned
way you know I'm calling Fibonacci with
the uber and the argument but also with
a callback to say what to do with the
result when you when you've got it and
this sucks this super sucks because I
have to decide right here where I call
it I have to decide what to do next I
have to pass that along right away and
if I want to do something asynchronous
on top of that result I kind of get
nested lambdas all the way out to the
right side of the screen so there's a
better way of doing that which is to use
JavaScript calls promises what you know
in the literature sometimes called
futures it's not exactly the same but
close enough as long as fuel doesn't
call me out and in for whatever reason
we call them tasks in the.net framework
so this this this first-class
representation of the outcome the
eventual outcome of this thing right so
I have another version of Fibonacci that
just takes a number and returns me a
tasks that represents the result I will
eventually get and then I can go to that
task and I can do things with it
I can have an algebra over tasks I can
have multiple of them and I can I can
call them a helper function to get a
task for when all of these have
completed or when the first completes
and so on so I can do high-level things
with them as a first-class object and
eventually when I want to do other
things than just when I want to get back
out of tasks world I have to do
something with callbacks but I can do it
later so I can say continue with and
then give it a lambda I can and what it
gives me as a task and I can take that
task and and do the right line that I
did before right line of 30 and now I'm
good but I could also instead of if I
want to do something asynchronous
instead of doing it inside and getting
nesting I can also oh sorry I get back
from this continue with I get another
task representing the completion of that
of that follow-up work that I can then
do a continue with and chain things and
many people know this from programming
JavaScript as well so it's better but it
still sucks because it doesn't look like
I'm writing a program it looks like I'm
chaining together call
Bax because i am and that sucks and so
in in c-sharp finally we went and said
you know what that's a better way of
doing this where the compiler rewrites
your code to the callback based code for
you and and you can just wait in syntax
and compiler rewrites that into a state
machine and and signs up the right
callbacks and everything and now because
the thing I didn't get into when I had
the other syntax and one of the big
things there's it's how do you how do
you write structured code right you have
you have a for loop you want to do
things one at a time a synchronously in
the for loop okay well now I have to
turn the for loop inside out and somehow
make call a helper function that can
that can change things together in a for
loop I want to do error handling
actually let's go back to it it's it's
sufficiently hideous so I'm calling
Fibonacci if I call it with a negative
number the maybe the method
catches that and throws an exception
before it spawns the asynchronous work
right so the call to Fibonacci itself
throws an exception if I call it with a
negative number just this argument
checking right there but maybe I call it
with a large number and after it
returned to me it returned attached to
me it runs into an overflow there's
another kind of exception okay so in
that case the exception won't come back
out of the call because the call already
finished but it'll come back out of the
task it's represented in the task the
task might have an it has an exception
in here if if things went wrong or
actually if I get the result I never I
just said 30 there I cheated
that's test a result this would if there
was an exception this would actually
throw so now if you want to handle I
have to both put a try around the big
thing and and I also have to put a try
inside or I need to have some kind of a
special error thing that I do wanna is
it's just a mess and everybody gets
everybody you to sir and madam you get
your error handling wrong when you do
this it's impossible okay
so just do await you
saya wait that thing and all the
exceptions come out here and so I just
need a single triblock what did I do
wrong oh yeah because I'm not in an
async oh yeah that's too bad and we'll
deal with that in a second but I can
catch exception here and do things you
know so I can catch I get back to proper
error handling yes and I need my I need
my main method to be async we can do
that now Asif see sheriff 7-eleven so
acing is good we have five minutes left
right so I will say I probably won't
have much time for questions I won't
have any but this an ask me anything at
I think 255 in waterfront CDE where you
can literally ask me anything I can't
promise I'll answer anything but not
everything but okay so that's good so so
what we did was language integrate and
get things right back to what they
should look like so all that was a long
reminder to say what about asynchronous
streams where you don't you know you
don't have one value coming at you later
but you have a continuous stream like an
event stream or a large set of data that
you're downloading that comes at you and
chunks over time over the network or
whatever people write whole like big
things based on asynchronous streams and
the problem with those is well they're
often written so the really bad ones are
like back to the old call back based
where as soon as you ask for the stream
you immediately have to sign up a
callback to deal with it and then there
are the better ones like I observable
and reactive framework I have I
observable up here which is again a
first-class representation of the stream
right so you have an object you can walk
up to and say hey I'm interested in you
you can subscribe to it and that's a lot
better because you
separating and you can again you have a
first-class object you can do an algebra
on you can you can combine streams in
various ways at the high level and so on
at the end of the day though somebody
has to subscribe to get to do something
actual with the actual things that come
out the other end of your complicated
set of pipes okay and subscribe
subscription means you have to provide
it an I observer and I'm sorry about an
i observer it's still a call back it's a
complex call back in this case it's like
something that implements a method that
or an interface that has three methods
and what do I do when things complete
what do I do when there's an error and
what do I do when I just got the next
one but it's still callback I'm sorry so
there's still callback based you program
still a long way around so could we
eliminate that somehow and in order to
do that we've been looking at simply how
do we language integrate normal like
synchronous streams and collections well
we do that just by what in c-sharp is
called an anion eMobile and in java it's
called an iterable just because we
always try to have different names you
could just do the same really
let's create an eye async and new mobile
that returns an eye a sync enumerate or
and I a sync and numerate or the only oh
sorry about that
there we are I sing a new Maria Torre
the only thing that's different about it
maybe is that the move next method the
thing that gets the next element is
async so let's call it move next async
and wrap it in a task and now we have an
async refine in a mobile pattern the
good thing about the normal pattern as
opposed to the the other one is that
there's no callbacks inside here or
rather there are callbacks but those are
the callbacks that sit on the task and
we know how to deal with those we can
await those right so we push the
callbacks out of the way and now we just
have to make an asynchronous version of
for each I'm not going to do it but an
asynchronous version of for each that
expands just like the foreach today it's
a while loop over the enumerator asking
and waiting move next async instead of
just as
move next and the pattern is exactly the
same so it's actually so this way it
becomes simple to integrate to integrate
asynchronous streams into the language
and then we need to figure out how to
bridge between all the observables out
there and so on but that's a that's a
more complex problem I'm told now to
stop so I want to say to you
thank you very much let's skip that one
if you want to see more go to our github
design site or go to the dotnet blog
which often has language stuff on it and
come ask me at the AMA and go have lunch
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>