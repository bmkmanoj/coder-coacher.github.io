<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Debugging &amp; Testing Your Android Applications | Coder Coacher - Coaching Coders</title><meta content="Debugging &amp; Testing Your Android Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Debugging &amp; Testing Your Android Applications</b></h2><h5 class="post__date">2012-07-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AJVolvNwHL8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what we're gonna talk about today are
two things debugging and testing and so
I'm gonna start with debugging and then
I'm gonna switch over to testing testing
tools in terms of the debugging we're
gonna look at couple of tools that we
currently have at our disposal and these
are the tools that are part of the SDK
so you guys all have them they're free
and they're just already there so law
kept is one of them debug is another one
trace fears another one and then a
hierarchy here so that's roughly what
we're going to talk about so how many of
you used lock-in before all right most
of you all right that's what I thought
so
Lockett is probably the single most
useful tool it universally works I'll
really quickly just bring it up on my
May Eclipse so if this is basically the
graphical version of of Lockett that
shows as part of the part of the Eclipse
edit basically Android development tools
now it's pretty pretty easy to use it in
eclipse you can basically change the
severity level you can filter it out and
so on anybody use this tool command line
you use the command line okay completely
alright so I tend to prefer to use it on
command line I'm just gonna really
quickly show you what I mean by that so
if I so if I do adb logcat I get
everything here and I like it this way
because it's much more agile for me I
can see the results right away but what
is not obvious in a command line is
called to filter the results right so if
you look at the documentation it's gonna
tell you that let me actually let me
pick what you want to filter for I'm
gonna pick something here that is
relatively interesting to us
for example pick Yamba app that's my
application so so if I wanted to filter
based on the number on this tab
the documentation says you can basically
do the tag column and then the severity
like debug for example or you can say I
want I want all the severity I'm gonna
I'm gonna track the tags for all you
know all the all of the above so
according to documentation this should
work but as you can see I still have
very very high noise to signal ratio I'm
still getting a lot of all the other
junk that I may not be interested in so
what they don't tell you is that you
also have to tell adb logcat which you
don't want to know
right so to do that to basically say all
the other tags silence alright so that's
kind of one old track and this gives me
this gives me a pretty good signal to
noise ratio so it's basically just the
things that I care about yeah so that's
a lot cat in a nutshell it's pretty
useful well another thing that I wanted
to point out the logging mechanism in
Android is actually written as a native
library so it's part of the kernel space
and as such it's it's available to all
the parts of the Android so basically C
code is using the same capability for
logging as well as Java code so that
makes it trans you know basically all
encompassing and which is very cool cool
so that's locket and I would expect
mostly it annoyed the debugger anybody
uses the debugger it comes to the
Android okay so it it's it's there it's
available to all of you you can
basically just add the perspective for
debug there and that was switch the
debug perspective it works just like you
would expect it to work just like any
other debugger there's nothing really to
or you knew about it you said
breakpoints you look at the variables
you step through your code so I'm gonna
fast-forward through that trace view
anybody use traceview alright so that's
what I thought so trace view is a really
useful tool for profiling your code
right so you have an application and it
just it's certain cases appear stored
run sluggishly and you don't know why
right so let me show you really quickly
how to use this tool so I have this demo
application that that I've been using
it's actually the one that I use for my
my book as well so it's called Yamba
stands for yet another microblogging app
and essentially what it is it's a it's a
Twitter app so let me show you so
there's me and there's my app I'm going
to start I'm gonna start it and one of
the capabilities of this app is that I
can basically click on here and I can
post something to Twitter or to our
private service I can say hello
afternoon session again click on update
and a problem is type this and it's not
me typing so it's just the emulator so
so this is ultimately gonna end up in
the on the website spelled away this and
so we're gonna see that shortly it takes
some time to post but essentially we
have this site here that is going to
show us that once it's done a mutant in
Windows it's mine so the new after
emulator actually has the support for
GPU acceleration mine doesn't
and in keep in mind that I'm doing a
whole bunch of stuff on my computer
right now including screencasting so all
that that's the slowness so we would see
it eventually here
once it's done loading we also have the
the oh I'm gonna wrong network
altogether so that would be a problem
because if I don't have a network
connection so I'm gonna go throw so
let's do this again okay so this
probably did not work out
because I was on a network that could
not allow for connection in the first
place so this is posting posting posting
and it's gonna tell us via a toast it's
either successful or failure when it's
all said and done
so we'll see that shortly so all along
what I'm curious about is why things
running slow right was this my code was
it the network was it something else I
don't really know I can speculate but I
don't really know until I can measure it
so I am going to just leave this it
doesn't really matter if it worked or
not I'm more concerned about the speed
so let me show you the code what I'm
doing in this case is so the code for
this is the it's a yumbo application
which is available by the way later on
I'll tell you where it is and github if
anybody cares about it but essentially
when I'm posting I'm running this
activity and what i'm doing here is two
things
writing on create i am starting to trace
the execution so this is the very first
time i can actually start doing
something it's right in oncreate it's
right after we call the super so I'm
starting to trace everything that goes
on in my code I refer to this as a point
a you gotta have someplace you start
recording but you also have to have the
point B because you're capturing the
data between those two points
so the point B in my case is right here
and I basically put it in on stop and
the reason why I put it in on stop is
because I am going cause on stop I can
simply leave the screen and you know
that's gonna happen right so basically
point a here right or in oncreate and
then point B is in on stop and
everything between these two points
which is a lot I'm capturing right so
the whatever I capture is gonna be
stored in this file llamado trace so
let's take a look at this file so this
file is located at in our in DDMS so
it's gonna be in our sdcard and there it
is so this is the file that I just
recorded that you know a couple minutes
ago it's called the embedded trace so
I'm going to pull this file I'm gonna
dump it just on my desktop and fill the
pool alright let's see why
DB devices okay hey DB so I'm gonna see
the desktop a DB Paul as the card Yamba
the trace dot right so why is it failing
to port that's why not
so this should be pulling that file and
it says it's Paul right so so now that
presumably have that file locally so
what I'm gonna do isn't going to start
the tool called trace view and I'm gonna
specify that file now so again this is a
tool that ships with wit as the case so
you guys have it it's available to all
of you so this is now launching a tool
and it does take a little while to start
but here it is so this tool is basically
telling me what happened between the
point a on the timeline and point B
collectively the entire point a point B
distance is 95 seconds that's what it
says right here right on here what
you're seeing is you're seeing all the
threads that you kept going on that
you're capable of capturing because of
the you know process that you're running
it now there's certain ones are more
significant with more significant than
others main is your main thread it's
your UI thread it's that's rather by
default everything around so on right I
happen to have an async task which is
what I'm using to post to Twitter which
is what you should be using because you
don't know how long it's gonna take and
there a couple of finalize errs in the
garbage collector and the binder threads
but those are more or less outside of my
control so I'm really mostly concerned
about the main and the async task and
that's what the majority of the work is
so what you can do now is you can zoom
in on certain parts like for example you
can see that there's a little blimp in
here I don't really know what that is
but what I can do is I can select this
and zoom in and then I can click on that
right and that tells me that this is a
call to restore to count and it's doing
a bunch of graphics and that single call
took 1.5 1.4 seconds and you know made
so many calls and zero recursive calls
etc cetera right so you can kind of
click through these kinds of things you
can double click on on the timeline and
zoom out and you can kind of try to
identify certain
so this is the finalizer process ran
here and it was doing vientre dot sleep
so that it did that for you know some
amount of time etc setter so you can
kind of like keep on zooming in and
finding the potential bottle next like
this again this is just a tool so this
is the science part figuring out what's
going wrong with your code is the art
part and but at least this is good to
know that there's a tool that can help
you visualize what's going on and you
can see the execution of those things so
sometimes the problems are very obvious
in this case it seems like it's just the
network so it wasn't like something that
was taking a while to execute so that's
a very useful tool traceview
the next tool that we have on our list
of tools is hierarchy viewer anybody use
that one no okay
so yet another case where the tool ships
with the SDK so you guys all have it so
what the hierarchy viewer does is let me
bring up my my example app hierarchy
viewer is capable of loading the
hierarchy of your screen that's going on
at this moment right so I'm gonna launch
hierarchy viewer and it's gonna take a
little while so identikit had identified
all the processes this is the one that's
currently running or it's in focus and I
say load the view so this is now going
to analyze what's going on on my screen
and it's gonna give us a little bit more
details about that so this is my screen
I have a fairly simple screen you can
you can actually see my screen here
right so this is the structure of that
screen right where I have a piece of
text here a button and a big text area
right that's my screen so you can kind
of see it here this is the big test area
the tag and the counter in the button
right and you can also you know you can
double click on this like if I want to
double click on that and you can see
that this is my button update right
that's that's so so interesting but
what's more interesting is the structure
you can kind of analyze the structure
your UI right and again this is a tool
that allows you to figure out does the
art part of optimizing your UI it tends
to be that UI is where you get the most
bang for the buck optimizing it at least
in Android that's usually the case right
so there's actually a great talk by
Romain ghee the guy who wrote the home
screen and this tool on it's called
turbocharger UI and there was a 2009 IO
but one of the things that he says is
look you don't want this to be super
deep you want it to be shallow you want
it to be like you know flat flat
structure you don't want too many
objects you want to be able to reuse
your objects etc setter so you can kind
of use this tool to identify what are
the things that potentially could be
optimized right where can you use
relative layout as opposed to linear
layout within linear layout within
linear layout for instance right
especially if you're doing that in a
list right so so that's basically how
you use this tool a second or a second
you can also look at the little dots the
little traffic lights right there are
three of them and each means something
and I forget exactly what it's like a
lot I memory amount of memory etcetera
but basically red means bad green means
good right so you would want to look at
you know items like this so this is my
Yamba status update title and there's
something that I am not doing so well
about that so I can kind of zoom out I
can also analyze the properties of that
particular item so you guys know when
you're setting up your UI you get to
specify the width and the height and
their gazillion other properties that
you can put on a button or a piece of
text and so on but you only fill out a
handful two three four five properties
well it doesn't mean that the rest of
the properties are not there they are
they're set at runtime so if you wanted
to for example find out what they are
you can you know you can figure out all
those details here the measures the the
width and the height and the total
length and things of that nature nice
and and this is not just for this is not
just for your screen but for example if
I wanted to analyze how and some other
application was written
I can I can go to the home screen of the
for example home screen if I do that I
can analyze now the the application of
the home screen and how they wrote it I
can learn a little bit about their
design process and so on again this is a
more much more complex piece of us it's
gonna take a little bit of time to to
load up so but in nutshell there's a to
make sense it's to a friend of basically
analyzing the structure of UI at runtime
so such it can be very useful in
analyzing it in figuring it out so while
that's loading just kind of you know
summarize the couple of things that we
talked about so we talked about the law
a lot cat debugger trace view and
hierarchy view so those are the tools
that you already have as standard part
of the of the SDK and next we're going
to talk about testing and let me see if
this is loaded so it hasn't loaded yet
all right so moving on in terms of
testing I'm gonna talk about a couple of
things I'm going to talk about the
androids J unit test framework I'm gonna
talk about monkey runner and monkey and
and maybe mention some other tools
that's about it right so first of all
anybody use J unit on Android with
Android one nobody else no all right
anybody use J unit in general
okay many of you say you're familiar
with what what what the structure of a
of a J of a unit test case is right
so Android basically Android borrowed
from J orange a unit is a is a is a unit
test framework designed by Ken back and
originally for Java but since then it's
been propagating in pretty much every
language so there's PHP unit an HTML
file an HTML unit and you know any unit
on the planet is pretty much there so
it's it's a unit test framework which
means that it's for doing unit tests on
your code which means that it's a white
box that white box testing so you can
see your code you can test your code
it's what the developer does to test his
or her own code so the idea is that
basically
you have test cases so what's
interesting about Android is just the
fact that our tests are running in a
container so they're not it's not just
like I'm testing a library hey here's a
piece of code and I write a little main
program that drives it and tested you
can't really just do that in Android
because your code lives inside of a
container it's managed there's a life
cycle all these other things that need
to be in present so it adds a level of
complexity right
so we basically in Android we have a
process that runs our application right
so that's this application package that
we want to test so what we do is we use
something called instrumentation test
Runner it's a tool that allows us to
test out the other code right
so basically instrumentation test Runner
is the runner that's gonna run our tests
against the code that we're testing
right so you're gonna feed to it a test
package now test package is basically a
j.j unit test so it's basically a whole
bunch of test cases right which are
based on instrumentation and j-unit okay
in addition to that you may need mock
objects so watermark objects well
Android is expecting certain ecosystem
for tests to run in right so for example
you need a context right you may need
the content resolver you may need
certain other things that are normally
there you know live ecosystem but if
you're setting up a test case you need
to mock them up right so so that's
basically what that is and later on you
can automate some of these by using
something called a monkey ronger so
that's in a nutshell what the Android
test framework is and I know there's a
lot of text here I don't expect you to
read it the slides are are available on
Marikana dot-com so you have all that so
don't you know for later reference
so basically what you do is you create a
test project so you have your code you
have your app hello world or whatever
your app is my Yamba app and I will then
create a second app that is testing data
the second app is also gonna be an apk
so it's gonna be an Android app it's
going to use instrumentation test runner
as we
earlier and usually if your app is you
know calm you know my domain my app the
test code would be in calm my domain my
app dot test so basically that's kind of
the usual name inclination so just like
in just like in standard J on it in
style J unit you basically have a unit
framework test case right so that's your
base class for every single test case so
every single test case is a subclass of
that right in Android we we basically
have Android test case that we are using
as a base class for everything now when
it comes to testing specific components
so remember the main components we have
activity services providers and
receivers right they all live in their
own specific own kind of ecosystem in
container so we need special test cases
for to test those guys so that's why we
have activity test case it used to be
activity test case but they weren't
happy with it so they created a new one
called test case two so much for
creativity in naming so just use test
case two don't use the regular one
because it's up too late so so they
basically have the couple of them for
activity to activity instrumentation
test case this is if you know if you're
only gonna launch it once activity in
the test case this is a standard one and
then you have single launch activity
test case that's if you have an
application with just a single activity
there's a service test case provided
test case in application test case so
these are sort of the the the parent the
sub the classes that you would subclass
to test any of those specific activity
services or our providers or application
so in standard J unit you write a test
case code by writing a whole bunch of
asserts you're certain that something is
either true or false or equal or matches
one of those asserts in assert is a
binary yes-or-no it either worked out or
it didn't if it didn't you basically get
an error right if you did work out the
test case passed right so Android does
provide all the stand
j-unit assertions right so they're there
by default so everything that you used
to from before it's there in addition to
that and it adds a whole bunch of new
asserts and these are things that are
not generic to just any other and a java
application so basically that's why we
have things like you know does the group
contain something that is something on a
screen is it visible on the skin is it
off screen above or is it off screen
below so these are things that are
specific to Android views right you
wanna for example verify that the button
is visible or is not visible that sort
of thing right so so those are some
specialized asserts in addition to that
we mentioned the mock objects I
basically said look you know your
application is running inside of an
alive
ecosystem so it expects certain things
it expects so you have the application
object well if it doesn't you may want
to mock it right it expects a content
provider it expends content resolver
context in within which running dialogue
universe package manager is that they're
set up so this allows you to basically
mock or fake certain things that would
normally be there in case of an
application okay so how do you create
this how do you create a test project
you basically in you know in Eclipse you
create another project just like you
would have normally create it but you
basically specify that the test project
okay and so basically we have two
projects one would be testing the other
project so you want is the regular app
the other one is a test app that's
testing the first step I'll walk you
through this shortly so next your test
code needs to basically use the Android
test Runner we need to specify that it's
using a third-party library Android test
runner okay and then it needs to also
specify the instrumentation information
it's to say hey I'm instrumenting some
other application okay so so basically
then what you would do is you would
implement the you know either activity
task is to or unit SK
our single activity lunch you would use
one of those test cases you would write
test cases that you will want to verify
that they're passing or failing so your
task is may look like this so this is an
activity test right so we're extending
test case to around our activity that
we're testing right and then in the
constructor we're initializing it with
the code that we're gonna test
okay now all this may sound a little bit
esoteric at this level let me switch to
the code oh by the way did this server
load yet so this is the structure of the
kilo in the home screen that I promised
you it's much more complex right and you
can like zoom you know double click on
things and find out what it is and so on
but I think I'm not closing so there's a
lot there are many objects but you can
see how it's a pretty flat flat
structure so back to back to this so let
me show you a piece of code because I
think things make all more sense when
they're when they're alive and running
so I have this super simple app it's
called currency converter and guess what
it does it converts currencies so we're
gonna launch it should be launching soon
there it is um so basically you can
specify some number so for example
hundred and I can say I want to convert
from I want to convert from US dollars
to Canadian dollars right and I click on
convert now this is actually going to
the cloud and it's getting the
information straight from Google current
you know whatever exchange rates so this
should be the actual conversion rate at
this point in time right so one or two a
day eight nine nine and so on so I can
copy this number to a clipboard I could
go back here I don't have a page button
but at least we can verify that that's
there so that's basically how what this
does right as an application you can
change the types of currencies etc so I
want to verify that this works I want to
automatically test that this works so I
have so this code this code the currency
converter what's interesting about it is
the UI right so that's because that's
what we're gonna be testing so I have a
UI each element of the UI that I care
about has you know he has a ID so I div
so this is the initial currency that
were that we're converting from this is
US dollars Canadian dollars right I have
the input somewhere so under thumb that
I'm filling in and so on right so I have
the input clear so this is the buttons
etc etc so the point is they got need
IDs now here's the code that's gonna
drive the testing of this code right so
well first of all let me show you the
manifest file so this is my this product
this is the project that's going to be
testing this other project right so
notice that I have the the
instrumentation specified here well
first notice that we have uses library
so we're specifying that we're using a
specific library for testing the tester
honor this is a pretty much standard
copy pasted in your code
then we're saying that we're going to
use the Android instrumentation test
Runner and we're specifying the target
package so this is gonna change
depending on what you're testing right
so so that's basically what that was so
now that I have that setup I can write
my octet on my activity test so this is
now the test code that's testing my
activity so it's gonna test this guy
right so currency converter activity
test is called testing consequence valid
activity right and because of that it's
activity instrumentation test test case
- and I'm specifying that we're testing
currency conversion okay now all the UI
fields that I found in this XML file
that I care about
and again even if you didn't have the
code you can find them out using the
hierarchy viewer right because you can
see them and I am creating an instance
variable for here then I'm creating an
instance of the converted task you know
the constructor here and I'm wrapping it
around the closet I'm testing ok so now
just like in any other unit test case
you have the setup and teardown
functions methods right
so you usually wanna you you know
usually when you're doing a test case
there are certain things you need to
setup like maybe it's a database
connection or a pre-populated data or
something like that right and then you
have a teardown because you want to
reverse back to the original zero state
right so what we're doing here is we're
basically saying load activity so we're
loading the activity and that's why I'm
getting the original activity that I'm
testing and then from that activity I'm
actually getting all the various all the
various UI elements that I want to poke
around right so that's my setup now when
I'm done setting up I can basically go
ahead and write any number of these
tests so this is one test this is
another test etc so they all start with
a test block right so this test is
testing preconditions you basically have
a very simple bunch of
assert not now so these are a standard
assert the basic of just testing hey
that feel that we got from UI is it
existing right and so in some so we
would expect all these to basically pass
right so then we have a is it visible
now this is not a standard assert but
this is android-specific assert it's a
certainly that view that that some view
is on the screen
so we're saying assert on screen you
know this would be the parent and then
this view itself yeah next I'm testing
the conversion from one currency to
another so I'm so I'm selecting I'm
selecting a currency it's equivalent of
you clicking on a radio button in the
pulldown list them so selecting currency
one so I think currency to typing in
some text sent that tax this is actually
as if you entered some number right and
then what we do is we shut down the
activity and then we restart it well and
then we just check hey did it remember
its state it should right so that's
basically what this does does this test
is testing the copy of the results it's
using the clipboard a couple of things
that are interesting here is the send
keys so send keys sends the keys it's
equivalent of you typing something on a
keyboard and sending those keys to our
UI
so basically scripting that then we are
testing conversion so I'm here I'm
actually sending the keys and doing all
that but I'm actually verifying that the
number that we're getting is about the
number that we should be getting given
given what to expect the conversion to
you know to be at the first currency
converter test and so on so that's
basically a whole bunch of test cases
that we have written right so this is
the code this is our set of tests that's
testing the original activity so that's
basic
that making activity lifecycle you can
test the life cycle of activities by
calling on pause on stop when we start
we saw that in this case where we
basically did finish on the activity
where was that yeah so that
so we're yeah thank you so we're testing
like life cycle events they're whole
bunch you can go on pause on start and
restart etc setup and teardown we talked
about there is one thing that I wanted
to mention and that's turning off the
touch mode so basically if you want to
be able to send keys in other words
programmatically appear as if you typing
in the buttons you need to you know to
disable the the touch mode so that the
user is no because this is actually
going to be running on a device okay so
the user is not doing that and we are
actually doing that here we are doing it
right here we're saying set touch mode
false we can then programmatically
influence the the touches by saying
something like send key event right so
send keys for example he's six seven
eight
so generating touch events you can
generate on click drag drag quarter
screen down drag quarter screen up long
press scroll a set etcetera so you can
mock a lot of user you know events right
touch events you can send keys it could
be d-pad keys it could be number of keys
they're whole bunch of different keys
that are pre predefined I'll get back to
this testing on a UI thread let me show
you first call this runs so so now we
care so basically this is the app that
just runs this is the app that's testing
data if I want to run this app I would
say run as and then you would choose
Android J unit test not J unit test but
Android unit test okay so I'm gonna
choose this now I want you to watch
watch two things
so one thing thing number one that's
gonna happen is this is gonna be running
here right so you're gonna be seeing
that thing number two is we're gonna
have an something pop up here which is
actually going to show
what's going on okay so I'm gonna click
on that so you can see that and I'm
gonna open this up so what's going on
right now is we have a scripted
automated test I'm not touching this
right so it's whatever we scripted is at
1 2 3 that's what's going on and we're
seeing the results real time here so our
first test conversion failed for some
reason and we have an error so working
we can explore that later our second
test copy past our third test test
preconditions is you know working out
fine and so on and so on
so this is our final report we basically
know that you know we had we had a now
we had one error not a failure so it's
not that the assert failed but we had an
error that basically said invalid double
so something passed so test conversion
so we passed a empty text for a double
and that raised a an exception somewhere
so we have with six tests one error zero
failures that's exactly the result of
this so when you're testing UI there are
certain specific things that you need to
worry about and for one you guys
probably know that UI runs on UI thread
and you probably know that you're not
allowed to touch you I from a non UI
thread well we have a separate
application separate process testing our
code so obviously there are two not so
many different processes and not only
different processes but different new
threads as well right so if you're just
reading some piece of text it's okay
you can get away with not doing it on a
UI thread but if you're modifying it you
actually have to do it on a UI thread
and Android provides for a couple of
useful ways to do that one is to
basically specify an annotation at UI
thread test and that basically says run
this entire test on a UI thread the
second way is to basically say activity
run on UI thread and then give it to
runnable that's gonna run on that UI
thread okay so I believe we have the
first case somewhere here see this test
we actually specify run on UI thread so
that was the annotation that made it
turn on the UI thread and I don't think
that we had any other anything running
on the other thread but we could have
actually we do
so make selection is actually running
it's just running this and this piece of
code on the UI thread
so we're basically passing around a ball
talked everything we're saying on on UI
thread so that's something that you need
to warrior
but when you're dealing with that so
running tests when eclipsed that's what
you guys just saw right in addition to
that you can actually run tests on
command line as well so for example if
you may want to script this right maybe
maybe your organization runs the battery
of unit tests every night you know when
you when you leave the office so that
you make sure nothing's broken
from that day's work right so you could
basically do something like specify that
you're running you know I can basically
say I want to run that I need to specify
the test package name all right so the
test package name that I'm running and
the name of the class that I'm gonna be
using for running so the test package
mean that we are running in this case
it's gonna be this one so I'm gonna copy
that right BAM and the name of the
closet I'm running is going to be the
standard one so it's kind of like a long
line I totally get it but it's so this
should actually run the same test so now
it's happening outside of Eclipse in
other words you can script it put in a
shell script have it run automatically
and so on and you get the report and you
can then have that report emailed to you
or your boss or maybe not your boss but
somebody like that right so so that's
basically the the idea with the unit
test testing again it's it's it's white
box testing and you have the access to
the source code right those are the
assumptions about it so so six tests
took thirty five minutes man there's
your results right moving on
you can test services very similar way
there's a service test case content
provider test case application test case
I'm not going to go into the details of
that but you'll get this document any
care at all spelled out I wanted to
mention couple of other tools that are
available to you for testing one is
monkey anybody use monkey before again
so monkey is not is a monkey is very
simple it works like this you basically
say adb shell
monkey and you give it some number which
is the number of seconds or milliseconds
more precisely and here's what happens
oops okay I have a monkey spelling so
this simulates you giving a phone to a
monkey for 3,000 milliseconds that's it
it's basically you don't know what's
gonna happen it's just a pseudo random
number of events you know it may change
your language to some language that you
can't pronounce it may make
long-distance phone calls and send SMS
so be careful when you execute this on a
real device right and usually don't
expect to get a device in any usable
state afterwards right so it can totally
mess it up and put you know for one puts
it in a language that you don't
understand
but it's a totally random kind of thing
why would you want to and sometimes a
monkey get stuck because it enters an
application it doesn't know how to get
out of it so then you get reports like
that
oh okay to open my camera so this is
exactly the type of things you don't
necessarily want to have
so so this is a tool that was I believe
it was initially developed for carriers
to do stress testing in the device you
can specify for example if you just want
to test your app you could say - P and
you can say comm dot Maracana dot
Android dot Yamba for example and that's
only gonna test your specific package
right
it's pseudo-random which means that once
you get the application to crash you can
use the same random seed that seed and
you can have the crash reoccur right so
that way you know until you fix your
code yes so this is somewhat useful
right it's more it's fun to watch the
monkey play with it but but that's
that's about it now so that's one tool
it gets a little bit of a use if we
documented that here and there's some
more options for you to control it but
other than that it's so-so
right it's more like I said for carriers
here's another tool that I think it's
quite promising it's called monkey
runner now monkey runner has nothing to
do with the monkey they just happen to
share the same part of the name monkey
runner is actually highly scriptable
it's usually it's intended for
functional testing so when you're
testing functionality of a code meaning
blackbox testing right like you know
here's an app I'm expecting to enter 1 2
3 press the button and get the converted
rate I don't care I don't know the
source code I don't I'm not privy to the
internals of the app I just know what
I'm inputting and what I'm supposed to
get back right it's kind of like your
functional testing so that's what monkey
runner provides and so it's again it's a
tool that you already have in your
toolbox ships with the SDK and what this
tool does is you need to provide it a
script to script the execution right so
that script is a Python script and
here's an example of that script so
again I'm not an expert in Python but
basically this is your standard you know
import statement then you're specifying
this is the device I'm waiting for a
connection so it
gonna sit there and wait for a
connection to to the to the application
then it's going to install your
application it's going to specify a
package ok then it's going to say this
is the activity that we test BAM you can
actually start the activity you can send
keys you can take a snapshot of the
application actual picture you can say
that picture for example is a PNG into
SD card so so it's it's pretty it's a
pretty robust tool the problem is that
not many people know how to use it so
it's just like lots of things in Android
it's a great plumbing but we need to
build things on top of it to make it
usable for developers so there are some
tools emerging or robotium is one of
them that's emerging there's a so it's
it's again it's a black boss black box
feature testing framework there's
another one from pivotal labs I forget
the name
electric sheep or something like that
but they're there but they're a couple
of a couple of tools that are emerging
in this space that are basically taking
advantage of this plumbing yeah so
that's that's about all that I know in
terms of the tools that are available
today that are already plugged in
available or easily available free you
know free of charge I don't really know
any you know tool even that cost money
that I could point and say hey this is a
great tool totally worth it so we're
still kind of in the infancy when it
comes to that and so that's basically
about testing testing tools testing
frameworks and debugging so questions
can you run all these on the live device
absolutely so this is everything that
I've shown you is agnostic on what type
of a device so 812 work over most of
them the common denominators ADB so you
could run it over you know an emulator
or USB or Wi-Fi connection so that's
basically that yeah those are all
included in the SDK yes acceptor about
him I mentioned it but everything else
is part of your your tour chain so so
the debugger the lock at the hierarchy
viewer and the trace view they're all
there and then monkey monkey monkey
runner are actually on your device right
so you're running on the device itself
right so they're not in SDK but they're
on the box itself and and that's yeah
does it and then the Android J unit test
framework is part of you as decay is
wrong that's a library right because
it's part of the android framework yeah
so any other questions on testing
debugging questions about automating the
tests fully automating it from checking
out from a repo to run the test and
sending a report somewhere and then
tearing everything down yeah
so you can do it you have two ways right
the first question is black box versus
white box
do you have code or you don't you don't
have code on so if you have code then
then one access is via the the Android
Jayne unit test framework right the
positives are that the developers
themselves can write unit test case you
know this course of thought that you
know TDD test-driven development etc
cetera that you should write test cases
even before you write any line of code I
think that's fine for Ruby guys but
we're Java people we don't have to do
that right so we have the compiler do
the work for us and that's my argument
to them but but I mean J unit test
framework is pretty you know pretty
powerful you can do a lot of things the
advantage of it is that you can mock the
Armand pretty well on it so so that's
basically what's good about it
the disadvantage is that it's it's
somewhat complex to to write test cases
right so you would do it for in certain
certain things you know but maybe not
just for everything but it's pretty
powerful so the other one is the monkey
runner that I was just talking about and
the monkey runner uses as opposed to
writing unit test cases with the white
box approach it's using a black box
approach and you're writing a Python
script and the Python script so first of
all it's good because a lot of Qi guys
are familiar with Python it's becoming
the de facto standard but you can you
can do things like monkey run or wait
for connection and it's just gonna sit
there until adb comes with you know a
device it's hears automatically
installing your package I believe it's
all package is going to attempt to
install it right away and it would say
no connection you will die yeah
so say yes you can do that you can so
you specify you install your package
you'll launch your package you you get
to handle of your activity now you can
keep doing things to activity for
example you can start it right and you
can send a key keys to to your code so
you can pretend like that you're
clicking on stuff you can take a
snapshot of the results you can write it
to a file so that's what the the monkey
runner does so yeah yes you would
basically as opposed to a start activity
would start a service and then whichever
way you poke your service and test if
it's working right so so yes so that's
so that's basically those are two
different approaches right right now
there are some people you guys familiar
with selenium anybody so selenium is a
tool that was well are you familiar with
loadrunner mercury mercury low donor
it's got like the defect of functional
testing suite
in the industry purchased by HP recently
so the open-source community people from
top works actually they developed a
alternative and open-source alternative
to to mercury loadrunner they called it
selenium nickels why so mercury is a
poison and selenium is the antidote
which is a perfect name for an
open-source project
so so basically they created selenium is
an alternative to to mercury and it's
actually a pretty powerful tool for
testing web applications like you know
if I have a complex web application like
say I'm you know doing a shopping cart
and I'm going through a product list and
in picking a product put in your
shopping cart checking out making sure
taxes everything's calculated properly
blah blah well you can script all that
you can just basically say it it cord
and you're like doing this as a human
right and then you say stop recording
and you say I'm expecting the following
things to have happened right and and
then you could keep running this over
and over and over again automatically
right so that's what selenium does and
there's something called a selenium
driver and you can implement it
inner-tube in java or ruby so you have
choices there's been a lot of discussion
about providing this level the similar
tool for for Android there was a project
on a believer Google code called
positron but that I've been tracking
that project for a while and it seems
like it's kind of dying off all right
now so I don't really know what's going
on with that the guys from sauce labs
which is one of the companies behind
selenium I saw an interview with their
CTO and so these guys are all about
automated testing and they understand
that pretty well is at least in the web
world so I saw the interview with the
the CTO and just for fun is this a fun
project he was curious about how to test
the mobile apps right so yes you know
automating all this stuff that's kind of
cool but you know mobile apps you have
things like swipes and this and that
right so he wanted to write an automated
test case for Angry Birds right how do
you test
Angry Birds right like I mean you have
to like you know take that you know
bird and do the finger movement and so
on
so he ended up just for fun building
this whole device out of like Legos and
things like that that would basically
would put the phone and you would
scripted and it would be like I look
hand and like throw the bird and son
it's kind of you know I mean it looks
interesting and it's it's all you know
fun and games but but that kind of thing
could also emerge in the future
ultimately you know you got a test on
multiple devices this is just testing
kind of the codebase and all that but we
have friends at for example square the
mobile payment company and they are
probably leading the pack when it comes
to UX UI type of efforts and they
basically camera room with like
gazillion devices right and you know
they just sit there and run their apps
one by one and make sure that it works
so gamers do the same thing so that's
kind of setting the standard for the UX
and all that thank you guys appreciate</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>