<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dependent Types: Through The Looking Glass | Coder Coacher - Coaching Coders</title><meta content="Dependent Types: Through The Looking Glass - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dependent Types: Through The Looking Glass</b></h2><h5 class="post__date">2015-03-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jgFAkmnBHwU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Owen Reese I work at medium
math we're going to be sponsoring the
drink and food later on I'm here to talk
about dependent types listed because I I
see a lot of libraries coming out that
don't use them people really aren't sure
about what they are and I'd like to give
like a little introduction and like you
know just show like how you can actually
use these things without being scared
about them so before I even get in like
the context of what this is this is uh
this is what I mean by about path
dependent types or dependent types in
terms of Scala so if you if you actually
take a look there's really just a trade
or an abstract class that you have up
there with with this abstract type
parameter and if you pass it into a
function that function
the return value actually depends upon
the variable that you passed in so it
becomes very context sensitive and when
you start using these things with
implicit since sort of type clashes you
can you can start really doing some
magical things that the type level that
that can really simplify your life or
you want to go really crazy and be some
sort of type astronaut you can really
complicate your life so one of my
favorite children's books has got to be
through the looking-glass and one of the
one of the things that I like about it
and what's so entertaining is that the
author decided to take a lot of the
rules that people are used to and just
throw them out I mean not completely
like not where it was absurd but like
you know you lose your head that's bad
everybody remembers that all for their
head but sort of the kinds of things
that you see that you would you wouldn't
expect but if someone says oh this is my
perspective like okay well I can see why
the way I feel is rather absurd so let's
say that I want to go through and I want
to start doing some of this stuff in
Scala itself and I'm gonna come out and
I'm gonna make this list ops this thing
that's based upon lists that you know
some more sort of pimp my meth or
whatever and I want to come out with
this flat size and I write it like this
well if I try and compile the first
thing I'm going to see is I'm going to
get this this exception it's going to be
saying like hey there's no implicit
there's nothing that tells me or tells
the compiler that the
this type of a that was in lists is
itself a traversable in other words it
can be flattened and we can see this
comes directly from the flatten method
on some lists and a lot of people when
they see this they don't even realize
that first of all that flatten actually
has a type parameter because when
they're working with it a lot of times
they think will list a list of T the
type parameters T but in fact the type
parameters list of T and you need to
tell the compiler like this this
abstract type T needs to be flattened
above so if I if I write out the full
signature and I take a look at what this
really looks like I have flat size with
this implicit but oddly enough I get
this weird type parameter B up there I
mean this this thing there sort of
floats there I'm not really using this
type prime I don't need it doesn't
really add to my understanding of what
flat size should be but it sort of
happens because of this implicit and
that's that's really a shame that's kind
of bad because this these sort of types
that you have these methods start
bleeding up to other calls you get what
I would call type pollution you know
types that really are there but you
don't care about so if I were to rewrite
this and I were to come along and and to
have done this I'd actually use this is
reversible once I come out and it looks
almost exactly the same except that it's
using dependent types as the type to
return in other words it uses this thing
that's actually found in Scala itself
that has this abstract type a that is
the type of the traversable which comes
out so I mean here I only have the type
that I care about and if I actually want
to get to that list and I want to use
the types within it well there it is for
when I want it
so my new signature if I were to have
flattened written like that and I were
to come out and I were to use it well
that B actually disappears and now now
my types are actually telling me exactly
what I want it to be this flat sizer
turns in it I don't care about anything
else here's my list of a there's my is
traversable once and it only depends on
a because that's all that's important
it's just saying a
is what's traversable and this sort of
pattern this this type of thing is
probably if you were to ever start using
a pendant types and putting them into
your libraries and using them to effect
this is what it is it's really a sort of
a compiled time type reification in
other words this is just identity the
way I've defined it
I say it's some type and I'm passing ma
into the apply and I get ma out and the
compilers often smart enough one since
we're running enough time to say well
this isn't really doing anything I can
get rid of this but at the compile time
level you're actually saying that this
abstract type a is a type it's got this
some type if it was a list it could come
out and say like okay you actually have
use of map or flat map or filter of all
the other methods that would be on list
if it was just some abstract type a you
you sort of would use that and you know
that that becomes a very powerful sort
of mechanism for implicit guards and
things of that nature of course flattens
kind of like a trivial example that I
just sort of pulled out because nobody
uses it I mean how many of you have
actually used flatten itself like every
single day of code what weight one hand
came up once a week once a month once a
month okay so yeah why that's because we
have this wonderful method called flat
map flatmap came out because of this
stuff because nobody nobody wants to
deal with some of none that's that's
kind of like taking a cardboard box is
empty wrapping it up and giving it to a
four-year-old for their birthday present
you know like
this is terrible I mean this is there's
there's true/false and file not found or
something like that I mean just no don't
don't do that but the thing is is flat
map requires you to preempt it like you
yourself have to know
so during code reviews you're going to
catch people going up that you mean to
flat map that oh yeah yeah of course a
more intuitive way would be sort of less
mistake calling as if map itself said no
I'm only going to work on things that
can't be flat map and flatmap said well
I'm only going to work on things that
can be flat mapped but this really isn't
isn't far enough as what I'd like to see
or to push it this far so I really don't
want to think about this stuff
like honestly I don't care math flat map
whatever it should just happen
automatically so if I were to make it
happen automatically this Auto magic
ways and actually like map or flat map
in terms of something like this like I
can actually get rid of map and flatmap
if it weren't for them you know for
comprehension syntactic sugar in terms
of this this sort of D map function this
this sort of dependent map function I
take a function T to be some implicit
that pens on be a type class there and I
get out I you know type my M and you
know to say this or talk about this in
sort of an abstract term is not really
helpful so I'm going to actually talk
about this in terms of something like a
continuation monad because this is
probably and also rather unloved monad
here you have map you have flat map I
mean apply is just T to R that returns
in R so the map self UCF and then G
that's a T to R and then you see down a
flat map F of you know a T and put in G
into a continuation of B of our well
that's just T to R and it's lovely and
it composes and it works great so if I
were to rewrite this in terms of this D
map well it kind of looked slightly
different so so the apply that I would
have out sort of vary
looks like what I have in map and
flatmap before of this pass continuation
but now it's in terms of this this tie
thing that takes in this the function of
F of the D map and the parameter G
that's that's this function that comes
in and it's based on some weird crazy
abstract type parameter and this the
supply just just comes in and and it
returns it in R which is exactly what
the continuation says it needs to return
but other than that it's it's not really
not really providing as much context as
you might think so to actually make this
tied to have it come out and see and by
the way this is going to be the most
complicated slide can everybody see the
code yes all right good
I'd actually define it in this this term
so so first of all I'll take a step back
and I'll say like look I'm gonna do a
little hand waving here on this aux
parameter there's a talk that new locks
collar guys you probably have seen if
you attended it next month I'll be
coming up here Boston to give a
dependent type talk that'll go really in
depth on the rest of you you know I I
can probably talk to you later on about
it but what's going on here is actually
type level pattern matching and this is
this is sort of like the the most
advanced kind of weird-ass crazy stuff
that you might put up on the type level
but what you're doing is you're having
this object tie that extends
low-priority tie and you see two
different implicit here so I'm using
implicit resolution order to sort of the
sort of program in like how to do this
pattern matching and say like this
implicit here is takes priority of this
implicit the next thing I have is this
apply that has these two parameters C of
R that is an implicit of ty that returns
this this aux thing what this is doing
is actually as is I'm allowed to shove
anything I want these objects in these
traits and I can just say import ty
instead of import ty dot underscore and
what happens is I can I can not pollute
the rest of my code base with implicit
sore or weird stuff that might happen
it's all going to
kept compartmentalizing here that apply
itself when Scala starts trying to take
a look for a tie of types you are will
hit that apply hit that implicit if it
can be done and returned that time
that's how it had sort of gets it it's
it's this escape hatch or like hole into
into this weird universe you might
construct this aux is that's to help the
compiler do type inferencing I won't get
into it but if you don't have that it it
stops starts losing track of what the
the types are the dependent types it
just it'll compile and say okay these
are the right types but then you go to
use them and it has no idea what type it
is so in this implicit this tie FM I
mean essentially what you see here is a
continuation of B and R and it's just
taking in a continuation and putting the
function in like you would I mean this
is this is exactly the same case as flat
map and this low-priority if you take a
look at this this is taking anything
that is in continuation or well it would
take continuation if you let it and I'm
running it through much like you would
map so obviously the name is tie FM or
tie em and if I take a look at this a
little more closely or or see this in
sort of the context of D map these
applies of tie here this one coming in
this is flat map I mean and this is mat
and the fact of the matter is is I
myself don't have to call whether it's
coming out of map or flat map the types
themselves will actually call into scope
the correct tie and the tie itself will
actually do the map or the flat map and
that's it
I don't have to think about it it just
just sort of won't work and I think this
is this is probably probably half the
time what people would want I mean I
don't know about you but I've I've never
actually written a list of lists of some
tea and gone this yes this is the tight
ground I want I want I want lists of
Lists yes absolutely
no but as helpful and as useful as as
that might be that isn't always like the
be-all end-all I mean sure I could see
people coming through and be like I want
a state monad of a state monad of a
state monad maybe or they'd be like well
you have a state monad transform or
something but sometimes we wouldn't we
wouldn't think about where maps or flat
maps might actually be used or might
want to be used or maybe should be used
so I see a lot of methods like this and
you probably done this in your library
you've written code like this you've
been like well I'm going out to some
database or some API somewhere and I
don't want to to have this blocking code
so this call this a type may actually be
some like result set jdbc resultset or
something like that that comes back I
want to map over it with this function
and I want to do this in a synchronous
manner and we think wow I've done
something really great this is good this
is this is the way we want our code to
be no you don't and that's because you
can get these two things the first one
happens by accident you might have a
method that is synchronous and then
later on as you are enhancing the code
and you know different functionality
comes out someone says well this
actually needs to be a synchronous and
he goes through and he makes sure
everything compiles and then as most of
you probably do because I know we do a
lot you only code review the diffs all
this places people have checked and
because this is returning a unit I mean
it's a side-effect nobody cares they
probably don't even look at the return
type of this do they probably the
function that would produce this
probably returns unit itself the second
one is arguably much much worse on a
conceptual level and it's it's funny
someone was asking Bill like how to work
with future and/or I'm gonna I'm gonna
show one way of potentially do that and
here's here's why future of try is
really
bad look at that third case that says
congratulations you failed
that's no kid to his parent when he's
showing us report card guess what it
came in I failed you're not gonna do
that
even worse is you're you're on failure
is sort of missing half the failure
cases and you're on success has to
handle failure which is really
horrendously bad so you have a future
which has disgust or fail you have tribe
has success or fail you may have other
things that have this sort of concept of
success or fail coming in so I'd
actually rewrite it something like this
by the way this tie and knot and stuff
like that you know I was looking at mind
and I was thinking okay what's sort of
similar I mean you can bind ropes and
stuff so you can tie ropes or you can
knot them and that sort of thing so I'd
actually look at this and just not
awesome great so if you come out with
something like this and you you sort of
structure code like this by the way this
this forces you to do something so it
forces you to separate your synchronous
code from what you would do with the
result of that a synchronous code which
I quite like and if you were to actually
show the implementation it's not going
to be that much different than what we
were doing with D map where again we're
doing sort of pattern matching at the
type level here but we're doing the
first case a future and you're just
gonna flat map so what this would do is
if you are your function itself will
return a future and you'd get a future
future of B what you actually get is
just a future of B and the second case
is if you would get a future of tri of B
you just get a future of our of B and
that's it I'm just I'm just taking flat
mapping as much as I can
I've left off the low priority because
well that's pretty straightforward it's
just Matt and if you were to think about
this in the context of what was going on
up here
you see that this not this does not dot
R is actually it's pulling out is sort
of piecing out and pulling out the type
that would be in our in our nested
future are nested tried so that I don't
ever have to think about this I don't
have to to handle it all right I don't
have to do anything with it it sort of
sort of yeah just sort of pull this
stuff out wow I really raced through
this alright but I raced through this
because I know there's gonna be a lot of
questions generally when I do this stuff
so who's got questions who wants me to
go back and start going over stuff way
in the back alright so yeah alright I'll
go I guess I'll go through that because
we definitely have time yeah alex is
definitely about that so so one of the
big problems is of course I just say
type inferencing if you were to take a
look at like this apply the way it's
defined and I'm returning this tie
anything about how this is defined
itself the actual type if if you think
about in type inferencing is gonna say
hello this is some type of B of R with
an abstract type and I look down here
and I and I see like without that box
going on and I'll tell you exactly how
that aux is working it's going to say
that some type of some abstract type so
even though you could look at the value
of it and the value would be consistent
with what you expect the types lost so
this this type parameter we have done
here the way it's defined is is very
specific and and sort of critical that
this this type of like hey compiler by
the way this is what you need to know
this is if you want to think about it in
mathematical terms like the way this is
defined is is it works this way and it
works this way in other words it's one
to one
and it's on two or it's you know they're
an inverse or an alias of each other and
this is saying like by the way
this third parameter is my dependent
type and if I define it that way the
compiler knows okay this is the type it
must be it will actually do a type check
if you try and put something in to find
it and say like whether this is or isn't
the type you expect the weird thing is
is the way that aux is defined way up
there it's kind of like recursively
defined and the type that I'm actually
going to lose which is kind of odd
but somehow it actually works this this
parameter here ty when it goes ty dot in
it the compiler will actually keep that
type parameter right up until there
after that it will lose it unless I do
this it just it just says well I know
right up to that point now I've
forgotten it I don't know why it just
poof gone so you you do these sort of
aux that you'll see in some of some of
the libraries that use these dependent
types so that that type keeps going
through and propagates at each step
along the way is that an answer your
question anyone else yes
do I have yeah I got I could actually
show you something from from my other
talk but what I'll tell you is is it'll
actually say this it'll say ty CR pound
in that's it that's your type like it's
some type abstract in awesome it won't
actually say like this isn't it or this
is a double another hand I and I can
show you afterwards by the way I have no
problem any other talks
all right questions yes no Wow okay I
got done really quick sorry about that
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>