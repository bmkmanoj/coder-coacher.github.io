<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Let’s Get High (Assurance) - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Let’s Get High (Assurance) - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Let’s Get High (Assurance) - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-10-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jpZJ8B5yVBA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so shall we get started Freddy
so you can see my my name is Justin like
AB and this talk is on high assurance
programming and we'll give some
definitions for that it's it's very much
a different talk than some of the other
discussions that you might have seen to
this conference it's it's not directly
JavaScript but we are going to show a
bunch of different things that compile
to JavaScript right so so we're all used
to languages like coffee script or
closure script they compile into
JavaScript so in that sense everything
that I'm doing is is very directly
related to web development and I'll go
into some of the motivations as well so
essentially what we're we're going to
cover first of all I'm going to start
with the motivation of this talk and
even though this is a topic that is is
often discussed in academia you'll hear
that the the motivations for why I'm
interested in this are very much
practical we're going to define high
assurance and give a little bit of
philosophy about the that we're dealing
with I'm going to do some live coding if
the the live coding gods agree with me
and that's going to be a little bit fun
will code a little bit of a video game
and a programming language called elm
and I'm going to go into something
called dependent types who here has
heard of dependent types
good that's that's actually really good
so this is going to be more of a survey
of a space that I think a lot of you
might not have worked in and at least
for myself the the thing that I really
like about coming to conferences is
seeing something that I haven't seen
before so being exposed to a totally
different topical area and and that's
what I'm going to be going into here at
sounds like so that that'll be really
great and in the end we'll talk about
types and the future of the web so that
really goes into the the motivation of
this talk I assume a bunch of you heard
the the keynote and they started talking
about the the motivation of forward Jas
and the forward really indicates what
what the next 10 or 5 or at the rate
that things change even the next year of
web development is going to look like
and for me I really hope that it follows
the past that I'm going to lay out in
this presentation I don't know exactly
what it's going to be but this is
something that is personally important
to me and and I really hope that the web
web development follows this path so my
background is in the primarily web
development I've been working in the
Ruby language for about nine years and
doing a lot of back-end application
development a little bit of JavaScript
and I give a talk in in 2009 I'm sorry
actually 2012 at a guru Co the the New
York City ruby conference and it was
called sensible testing and I think that
most most people here have done some
kind of unit testing right behavior
testing unit testing and I give a talk
on on best practices because certainly
as we add unit tests we gain a certain
kind of confidence about our code but we
also add a certain kind of way to the
code base right the the test code that
we're adding is also code that we have
to maintain and change as we change the
rest of our system and so I was talking
about things like the the test pyramid
different different patterns to make
sure that the test gave us the
confidence that we wanted without overly
burdening the the code base but in many
ways I wasn't satisfied with the talk I
really felt like I was I was missing
something
and at the point I didn't entirely know
what it was but it was clear to me that
adding unit test is one way of gaining
confidence over a code base but what are
we omitting bye-bye only talking about
testing and and and this is essentially
what what led me into this so what we're
going to be talking about is is high
assurance programming and I think that
high assurance programming is actually a
rather common sense notion this is from
the when when Obama was talking about
the nuclear accord with Iran a couple of
weeks ago and he said that the Accord is
built on verification not on trust so I
think that before he was the President
Obama was doing some kind of high
assurance programming that's my
suspicion at least I don't know that for
a fact so don't quote me but essentially
this is what a lot of high assurance
programming boils down to is it's not
just trusting that our program works but
having different ways of verifying the
program works and so this may be testing
or this may be types as we're going to
delve into in this talk what I'm not
going to talk about is software that we
depend that we put trust in for human
lives and there certainly is a whole
area of high assurance software where
they talk about that kind of thing and
as I said my background is mostly in web
programming so we're going to be talking
about more that side of high assurance
programming and and that's and I think
that this is something that we should
all really be focused on it's not just
something for a couple of people in in
making automatic braking systems for
cars it's not it's not their domain it's
really something that we should all be
dealing with and so we should go to a
definition of high assurance and there's
a paper by Gallo a company based and in
Portland that I think does do a lot of
government contracts and probably a lot
of systems that the people put their
trust for lives in and they say that
high assurance development means
producing compelling evidence that a
system meets specified requirements so
going back to Obama's quote
evidence is is really the key notion and
and as we're continually evolving
systems for web development this is this
is something that's really important to
us too so agile says that we should
always be able to adopt our systems to
current needs and to future requirements
with a predictable amount of
anticipation and so high assurance is is
really relevant to to us in that area as
well so one way as I mentioned that you
can gain assurance that assistant is
working is through tests and so tests
are a form of dynamic analysis and what
we mean by dynamic analysis is that you
have to run the program in order to get
the feedback right so you're writing a
test and that's the input to the program
and you're going to get a specific
output and so that's dynamic analysis
since you're running the program but I
think that we want to go further than
this what we actually want is static
analysis so to me something that is even
more interesting is if we can get
information from the program about
whether its behavior will be correct
before we even run it at compile time
essentially right and and so this is
where types come into the picture and if
your experience in types is something
like Java or C++ I think the best way to
understand the types that I'm going to
be talking about this presentation is to
forget all of that and really so we're
going to go into a very different area
of types and this is actually one that
has a long history that influences Javas
types as well but this actually goes
back to at least 19 10 in the the
principia mathematica so Alfred North
Whitehead and his student Burton Russell
we're trying to find a different
foundation for mathematics that was more
precisely defined than the currently
used set theory and so they started
laying out in a very comprehensive book
the their notation and and their idea
for a type system so this really goes
way back even before you know way before
people started talking about Java or C
or even COBOL and the modern types in
type systems that I'm going to talk
about have a lineage that goes back to
that and there's a paper called the the
triumph of types if you want to get more
information on this by Professor Robert
constable
and I was fortunate enough to be able to
see him present at a conference set of
sessions that I went to over the summer
in Eugene Oregon called the Oregon
programming language summer school and
that was extremely eye-opening for me
was it was a couple of weeks of a very
intensive programming language theory
and mathematics and they really went
into these topics in much much more
detail but that paper is a good place to
start to see how a lot of this really
goes back to that point so what are
types if that's what we're going to be
focusing on and what type systems are
useful now and what do we want in the
future so first of all what are types
and there's a one of the things that you
want to do if you're really getting into
type theory is there's a book with a red
cover called types and programming
languages by Benjamin Pierce and
foremost graduate students in computer
science this is what they use to start
studying programming language theory and
type theory and Benjamin Pierce says
that the the types are a method for
proving the absence of certain program
behaviors and the word proving is really
key here because it really is a proof
that behaviors don't exist so a test is
a good way of asserting that given a
certain value you get a certain output
but types are slightly different in
their emphasis and that they can
verifiably show that a certain behavior
doesn't exist and that's a very
important notion and the you can also
say that static types of static type
systems are the world's most successful
application of formal methods so this is
a formal method for for proving their
system is correct I'm also going to
gloss over this very briefly because I
want to get to the live coding
demonstration there's something called
the the curry howard correspondence that
how many people have heard of the curry
howard correspondence good so some
people in the audience I've heard of
this there's a really good paper called
propositions as types which is another
name for their the curry Howard
correspondence and it gives a much
deeper logical implication for the
notion of types so essentially we can
say that for each proposition in a
logical system there's a corresponding
type so it's actually what we're doing
when we writing programs is creating
mathematical proofs
and when we're simplifying a proof it
corresponds to evaluating a program and
this has really deep implications if you
ever do me a favor if you ever get bored
about programming for a second you say
you know I think that I'm an expert in
using javascript using Ruby start diving
into this area because it's really mind
expanding the way that the types that
we're using in our activity really goes
way beyond sending instructions to a
computer it really goes deeply into into
logic and philosophy and mathematics so
if you're looking to open up a whole
nother world you can spend the rest of
your life and I would suggest going down
this path but really the emphasis that
that I'm going to take in this talk is
very practical it's not a not an
academic one and not a theoretical one
but in our company and i founded a
company stock builders that does
consulting mostly in the Ruby
programming language and our JavaScript
and we recently started going into
Haskell and we've been doing production
projects in Haskell for some clients and
and this is really our experience you
know Ruby is is very popular in
JavaScript to I imagine for doing things
very very quickly so when when Ruby on
Rails became popular there's a
screencast of a demonstration of
creating a blog in like five minutes or
whatever you know whole blogging system
in five minutes but what happens after
that you know you at some point you
reach this inflection point where you
put in more and more effort and the
returns aren't really is great anymore
right and and so we tried to change this
inflection point by different methods
you know following advice from the clean
coder arranging our code structure
different following the Gang of Four
design patterns structuring our test
suite in a certain way but that that
inflection point still exists and I'm
not saying the type systems are a way to
resolve this entirely but I think that
we should be spending more time talking
about them because in Haskell I found
many cases where if a client would would
come to us and many clients have come to
us and said hey we've got this kind of
budget we've got this code base and we
want you to develop features x y and c
and we've said well no there's there's
no way that we can confidently say that
will happen given the current code
business doesn't have a test suite we've
had a different experience going into
projects in haskell where we don't have
a test suite we don't have continuous
integration setup
there are modules with many different
responsibilities which people from an
object-oriented would say is not a good
thing and we're able to go into the code
base and start being productive on the
first day which is really impressive you
know something that with with all these
warning signs we fairly would have
tossed a ruby or JavaScript code this
but with a static type system we can
basically look at the types determine
more or less what the business domain is
and and then start modifying the program
in a productive which is following the
science of the compiler and if you saw
the talk from Steve cloud Nick he
alluded to a similar experience using
Rost which is in many ways similar to
Haskell so again we're not talking about
life and death situation software we're
talking about really concrete
engineering benefits and that's why I'm
interested in this topic and it goes
really into this tweet that I saw a
couple of days ago this this guy is
saying that the fact that I can walk
away from the middle of a massive
refactoring T dinner with my wife shows
the strong typing improves lives you
know some of the toughest stuff that
I've done in Ruby is where you get you
know a mile deep into a refactoring and
usually when you know I've been a
refactoring for a couple hours I'm I've
been doing Ruby for nine years and I'm
still only about twenty-five percent
confident that I'm gonna just not do a
git checkout and blow away the whole
thing you know and start again down down
a different path but but Haskell gives
us this this really quick feedback even
without types even without test about
what the what we should do to satisfy
the compiler I hope the the part that
you're able to get out of the
presentation is that you know doing
statically typed functional programming
is not something that's scary we were
able to do something that was very
productive in a very short amount of
time and and so this goes into the the
increasing type system expressiveness
that I wanted to get to on this in this
presentation as I said before if you've
been using something like Java or C++ we
really want to forget everything that
those type systems give us because for a
very specific reason I'm not just
bashing on them because i don't like
them or anything they're fine but
they're they're limited in a couple of
senses the the type system is not very
expressive so we have Skylar types we
have integers we have strings we have
doubles but they're they're not very
expressive they don't have things like
algebraic data types like the Mario a
structure that we started using in the
last example are
from things like Java and they also are
not very cheap to use because you have
to annotate them all over the place
you've got to say this function Richard
returns a string this function returns
an int whereas in things like elm and in
Haskell you have type inference oh you
get that for free and I believe in Ross
as well as Steve was demonstrating this
morning but we can even do better and
languages like Haskell have something
called kinds and they're they're also
dependent types i'm going to go through
these very very quickly so there's time
for a couple of questions at the end i
already talked about Skylar types those
are the ones that aren't as interesting
for me because really what you want to
do is code as much of your domain into
the the type system as possible so that
there's less of a chance that it'll go
wrong at runtime so algebraic data types
like the type that we use for Mario is
more interesting and there there's
something neat that I saw about rust and
in rust I guess they have about the same
concept using an enum but algebraic data
types are kind of Matthew so when people
heard Oh Haskell's got algebraic data
types are like well that too i used
those four and then they called him
enums and ross and everybody's like oh
yeah of course we use us all over the
place right so we can just kind of call
him enums or something as well those are
very useful and they could be thought of
his some types which combined together a
bunch of different types or a kind of a
record type they can also be used
recursively so you can have a type that
refers to itself to make like a linked
list or a binary tree is something like
that and they can usually be analyzed
using pattern matching which allows us
to pluck apart these types without using
conditional logic and that's something
that I think once you start using in a
language like Pascal it'll be really
tough to go back to a language that
doesn't that pattern matching so here's
a quick example as I was mentioning you
can have types that are that are self
referential as this tree structure is
where it refers to itself here that's a
good example of an algebraic data type
this is also very interesting in in
Haskell you have a type of types so once
you start having types you want to
sometimes a way to reason about types or
a way to construct types and so an
integer is is what we call a concrete
type that's a type in itself but then
you've also got this may be so there may
be in Haskell and in languages like
Scout Scala language like Swift I think
what what they'll let you do is that
they want you to avoid null pointer
exceptions which I believe Anthony hora
said was the he called his
billion-dollar mistake you know this
results in lots and lots of bugs and
computer programming so ideally we want
a way to get away from those and and
Ross has that Haskell has this but once
you have something like this you want to
be able to use it with a bunch of
different types so you want to have
something that maybe contains a boolean
or maybe contains a string so
essentially what this is it's like a
function at the type level that accepts
another type to be a concrete type okay
and that's a really useful thing because
it gives a different abstraction to talk
about and to use the type system so
dependent types are even a step further
than this and you could refer to these
as a type that depends on a term that
might not be known until run time so the
the overused example of something like
this is something like a list that
requires a certain length right and and
so that's really useful because in many
languages you can have a list and then
you brought off the end of it or you try
to pick an element from the front of it
but it's empty in languages with the
dependent types you can actually specify
in the type system that a list must be
of a certain length so that eliminates
another class of errors and so what this
brings to mind with dependent types is
that the the program can be correct by
construction and this is something else
that comes from Benjamin Pierce's type
some programming languages so when I was
doing this presentation or a similar
presentation in Chicago for lambda gem
someone asked well you know this this
does really well if you know what the
program is supposed to do but what if
you're wrong about the specifications
right and that's a very good point
because obviously if you don't have a
good idea about your specifications or
if your assumptions are wrong about the
specifications then it's much tougher to
make correct program it's probably
impossible right so what does this allow
us to do well if we have to pen in types
and if we have extremely expressive
types we're much closer to actually just
including the specifications right in
the type itself right and and
theoretically there's there's almost no
limit to this
however this is a double-edged sword and
as you as you get more and more
expressive types along the lines
independent types the system becomes a
little bit different difficult to use
and and specifically you lose some
properties of type inference but this is
a really interesting experiment in
languages like Idris which is new I
think that might have a JavaScript back
end and agda and as well but also
in in languages like Haskell that we
found to be really practical and Haskell
of course just mentioning this since
this is a JavaScript II crowd a lot of
this stuff you can compile right to
JavaScript so Haskell has a compiler
called GH TJ s which can emit JavaScript
code you can run right in the browser so
Haskell is well there are other
languages that are coming out with
dependent types Haskell is also moving
in the direction of getting more
expressive types itself and I don't have
time to go into these too much but there
is something called liquid Haskell which
is a project from ranchi Jolla and it's
a really interesting way to to get
dependent types that are dependent on
terms inside of a haskell program and
also Stephanie why Rick's academic work
that makes the types in Haskell more
expressive but really to reiterate the
point that I made a while ago this is
really a practical concern you know this
is not awful not all of us write
software that people's lives depend on
but all of us write software that our
weekends depend on right that our
families depend on that our managers and
product owners depend on and and so this
is really an extremely important
engineering concern and as I mentioned
earlier we've had experiences where
programs we would have thrown out in a
language like Ruby we were able to
preserve and extend and use in something
like Haskell and the goal is finding a
sweet spot in this whole spectrum of
expressivity of types you need to find a
sweet spot where you've got a practical
language that gives you expressive
enough types to encode as much of the
domain as you can without really
dragging you down in using these types
and for us right now Haskell is really
fitting that bill very well
there's there's a whole other language
there's something called a web which is
actually a dependently typed language
and it emits JavaScript code as well as
other compiled code for the server side
so that's an interesting way of
expressing warrior domain and in a
dependent type and interestingly her
uses types to ensure to provably ensure
that things like sequel injection
attacks don't occur and so there's a lot
of really cool properties that come out
of this when you start pushing the
boundaries of type systems and I think
that in in the coming years this is
another thing that's that's really going
to to become very important in web
software development there there are
some production sites as well in our and
you can go even further and use systems
like which was one of the original
implementations of dependent types
they're actually earlier once to like
new pearl and and other dependently type
systems but this is a very interesting
system in itself that also helps you to
create mathematical proofs so what are
what are we going for here really the
point that I want to make is that as I
mentioned earlier the the notion of type
systems isn't even something that's
constrained to computers it's something
that comes from trying to create a more
solid foundation for mathematics it just
so happens to be useful for doing
computer programming in a small
subsection of that world so I'm not
saying that types are a silver bullet
they're certainly not and as many people
have said over the years that doesn't
exist in programming and if we look for
that we're probably foolish but it is
something that that comes to us rather
cheaply and that we have the tools to
use right now for practical web
development and it's not a free lunch
economists will tell us that there is no
such thing as a free lunch actually it's
one that we've been paying for since
1910 in really rigorous thinking about
the the structure of ways that we can
classify mathematical systems and we're
able to reap the benefits that today in
creating more robust and more
maintainable web software systems so the
next time that we go to a conference and
all they talk about is the weight of
structure at test Suites you know that's
that's very much where I was several
years ago before getting more of a
theoretical and practical background in
good statically type systems I really
hope that we we start bringing up the
points of how type systems are practical
and how they can help our every the
engineering needs and I hope that this
is the way that web mission earring goes
in the future regardless of exactly
where it falls on the the type spectrum
these are some some references that are
too small to see but i will put these
online the conference will be putting
these online shortly so that's that's
all that i have for the presentation and
we have some looking forward to hearing
what questions you have so i left a few
minutes we have four minutes for
questions so what yes so the question is
what are my thoughts on typescript and
unfortunately I haven't used typescript
myself I feel like from from what I've
heard about it it seems like the the
types are not as expressive as a system
like Haskell and so I'd have to go and
check I mean I didn't from what I heard
about it it didn't seem like it had
things like algebraic data types I don't
know how the type inference is that kind
of thing I guess that's how I would
evaluate it if I went to look deeply at
typescript as I've been saying that the
main benefits for me are where you start
getting types that you can really encode
a lot of your domain and so if all you
have are scalar types that's a major
disadvantage right there from in a
practical engineering perspective I
think and then if it doesn't do great
type inference you've got to annotate
everything all the time then that's all
so that means that the benefits see are
getting minimal is a maybe don't come as
cheaply as they should if you've got a
good type inference engine of course you
know systems like c-sharp are even
though they don't have extremely
expressive types they're they're getting
better at type inference so the the cost
is is going down in languages like that
yes absolutely that's the question the
question was is there a notion of unit
testing in Haskell and Haskell's types
as I was mentioning there they're not
the be-all and end-all in in type
systems there there are systems with
fully dependent types that are much more
expressive than Haskell's so in in
Haskell what we find is that we write
maybe a quarter of the tests or so in
Haskell that we would in a language like
Ruby or Java
script we find that uh you know there
there's a huge engineering benefit and
we probably right about you know 75
percent less tests and Haskell than we
would in other languages but certainly
there there is property based testing in
a library called quick check which is
very popular as well as unit testing and
behavior testing that are really
essential for for quickly testing things
I think in some ways and also for
filling in the gaps where you don't have
types that are as expressive as you'd
want yes how do you apply this to a code
project in another language yeah sure
yeah that's that's a really good
question how do you how do you apply
this to so if you've got an existing
project that's in this in JavaScript or
something can you start applying these
ideas I think that they're there are
still areas that are being worked on in
order to do this I think that languages
like Elm things like GH TJ s the
compiles to JavaScript I think that
those are giving us avenues to do some
programming in these languages and then
interoperate through a foreign function
interface to things like JavaScript and
so I would look for things like that I
guess that the other things that I would
look for just ways that you can think of
the types of your functions because just
because you're working in a dynamically
typed language doesn't mean that you
don't have types a lot of times you
really just have a lot of implicit types
and and so if you start programming and
experience experimenting in a language
like Haskell I found that really changed
the way that I thought about programming
and really that's what you want you know
some people will say well learn a
different language every year you know I
never ended up hitting that mark myself
what I do try to do though is that at
least every couple of years I try
learning a language that really changes
the way that I think about programming
so I'd say don't go from Ruby to python
and expect huge benefits don't go from
Ruby to to JavaScript but do go from
like Ruby to prologue or Ruby or
JavaScript to prologue or JavaScript to
Haskell and what I found is that when I
go back and work in Ruby now I more
clearly see the types in my mind that
were implicit before
and so that's another way even if you're
not going to make the jump for your
whole program or part of the program i
think that there's a cognitive switch
that occurs when when you're using when
you start experiencing a language like
Haskell that the changes the way that
you think and for me I feel like I'm a
better programmer because of it maybe my
colleagues would would disagree so we we
are out of time I'm supposed to wrap up
at two thirty but but thank you very
much and I'll be around if anybody has
questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>