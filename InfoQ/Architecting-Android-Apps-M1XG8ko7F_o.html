<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Architecting Android Apps | Coder Coacher - Coaching Coders</title><meta content="Architecting Android Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Architecting Android Apps</b></h2><h5 class="post__date">2012-05-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M1XG8ko7F_o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're gonna talk about today so we're
gonna talk a little bit about the
designing an Android application
architect in application so basically
I'm going to talk about activities in UI
just to start with things that are
tangible that you can easily relate to
we're gonna talk about intense action
bar when I talk about services things in
captain in the background we're gonna
talk about content providers this is
basically your data we're gonna talk
about lists and adapters
broadcastreceiver so explain what that
is and finally we're gonna wrap up with
something called an app widget which is
basically one of those little things you
can see on a home screen you can touch
it and of course up something so Before
we jump into that anybody wrote and
Android that before I talked to a couple
of people ok so I can full of you have
and was that a native app or was it in
HTML CSS JavaScript at Bob Nathan okay
anybody else native how many native apps
a couple of you perfect cool well
hopefully for you it's another nice
overview of things that you may or may
know so we're gonna talk about I'm gonna
be using an app an application as an
example application in this in this
presentation we call it the Umbra it
stands for yet another microblogging app
because we can't call it Twitter right
it's a trademark but basically what it
is is it's a Twitter like application so
I'll be using this application to
basically explain how things work in
Android this this proved to be a very
good sort of demo app over the years and
and that's what my book is based on and
that's what we do all the training based
on and so on
so Allah quickly show you what the app
looks like so basically it's it's a very
simple learning app I can click on all
you know I have a bunch of tweets from
people statuses right so this is an
emulator amusing so it may not be the
smoothest ever because it's amulet
making pure but you can basically click
on a little you know item and it just
pops it up you can go back you can
change you can for example update the
status you can say hello from building
ten you can click on update that is now
actually trying to go online and post I
don't know if my network connection is
gonna work it says it did I can go back
to the tab I can click on refresh and
there's a background service that's you
know pulling this data and and I think I
just crashed it so but basically this
app is using a back-end service called
Yamba which is running at the upload of
Maracana calm it's basically our global
controlled environment because twitter
wouldn't let us do what we do but if i
click on the refresh here and keep in
mind a lot so that's our post by there
right so that's basically that's
basically the whole application
companies just as an example a way to
make things more tangible
so moving on with with that so what
they're gonna be talking about is the
Yamba app and components in it so
basically Yamba is a what's good about
it is that it's very comprehensive so it
shows you how how all the main
components work so it doesn't focus just
on web services or just a new i but it's
got to make some mix of things so that's
a good thing and we're gonna do it in
small increments they're gonna be seven
increments that we're gonna walk through
in this in building this architect in
this application so think of this is
sort of like your generic applicant if
we're talking about web development I'll
probably walk you through building a
blog site or something like that right
it's one of those generic learning
applications so we're gonna be using
this lots of pictures so this is
basically a design diagram that
eventually is gonna become a full screen
and just to kind of give you an idea
what things are here because it's sort
of a new graphical language that I came
up with because one didn't exist before
but basically this dotted line that
you're seeing sort of go around here
that is the application
that's an entire app and we're gonna be
throwing components into this app so I'm
gonna start with lines and circles so
you can kind of understand its
high-level and then we're gonna possibly
look at a little bit of a cold but I
don't want to go too much into a code
because that you code is easy to figure
out once you understand the concepts and
we only have so much time so so
basically what we're gonna be doing
first is we're gonna create this whole
screen it's a status activity for those
of you in the background but basically
it's gonna let us update our status just
like that I did when I said hello from
building the tank right so it's that
screen in the context of that we're
going to talk about UI so basically this
is that application that you just saw
earlier I'm now showing it in sort of
more of a tablet view if you will so
it's more of a landscape view versus a
portrait so that's why you're seeing
more information that you did initially
I'm gonna actually a view on that
application
here's that we have it actually running
and should be showing up on the screen
you know oh wow so that's that's our app
again and what I'm gonna do is I'm gonna
rotate the screen so that's basically
the view that we're looking at now and
it's kind of hard to so you can kind of
see right so that's the app so basically
what you're seeing on the screen is what
we call an activity it's one of the
first building blocks right so in
Android we have about four main building
blocks and this is what we use as
components to build just about any
application any complexity application
so activitists are your UI write
activities on your screen it's one
activity takes an entire screen at one
point in time what's interesting about
activities is that they can a pretty
complex life cycle so basically the
system manages the life cycle of your
activity so the system is gonna at the
beginning of the day you have your
activity that's not running you can
music hasn't started the app right and
you may click on I want to start the app
and what happens next is there's a bunch
of protocol Paul back methods getting
invoked against your code so there's
something calling your codes it's not
you running your code it's the system
pinging the callback methods
inside of your code and eventually your
activity becomes visible on screen so
it's on the screen right now interacting
with the user there can be only one
activity ever in focus on the screen
interacting with the user at one point
two times this is where Android is sort
of different than maybe some other
systems or systems that you have
experience with at some point the user
may say alright so I'm done you know
viewing this I'm going to go to another
screen so flip to another activity or on
the screen and we quickly go through so
called the pause state only to usually
end up in the stop state so basically
really quickly your activities going to
end up in this state here so basically
you can have many many activities in so
called stop state and what that really
means is that they're still in memory
they're still taking your resources
they're just not on the screen visible
and not in focus interacting with user
so it's basically kind of like a cache
right the point of this mechanism is
that it's very likely that you're going
to want to come back to the running
state so it's just human nature we come
back to the same screens that we used
before and these steps here going from
starting to running basically a cold
start is very expensive it takes a lot
of resources to get started
it can take seconds right because you
need to launch a new virtual machine you
need to allocate a new create a new
Linux process you need to load a bunch
of Java classes there's a lot of stuff
that goes on at that point in time this
tends to be much cheaper much much more
efficient that's why the system keeps
things around and that's why an Android
you do not have a quit button if you
notice that but the system wants to mint
memory manage for you unlike when you
use your Microsoft Windows and you're
done with your Microsoft Word you
usually quit it right because it takes a
lot of resources so what you're doing is
your memory managing the machine right
well Anthony team thought that machines
should be capable doing their own memory
management sort of like you don't change
gears in your car or at least most of us
don't so they kind of took that
approaches well when designing
Android system at some point the system
is going to have some heuristics and
it's going to say alright time to
destroy this stopped activity no long
it's no longer needed and just see
they're taking a lot of resources and
users unlikely to come back to it so the
system basically destroys so that's
that's a little bit about the activity
lifecycle this is probably one of the
most complex components at the PCAT I'll
get back to the questions toward the end
but do draw them down so basically what
they did is I kind of like explored what
happens with an activity you know in
various situations like when you started
first time so we go to that on create on
start on this room stay so if you
remember what we are doing is we're
going through the callback method so
we're basically running so this all bags
which could be empty but they could also
be doing something interesting so that's
basically what happens first time you
started when you click on a bad button
what happens is one of your activities
the one that you're currently in gets
you know the event that says something's
and other activities about to get
started
pauses the current activity stops the
current activity then when we click on
the back button restarts it starts in
and resumes so it's a pretty much go
through the entire cycle to get it back
on the screen when you rotate the screen
we actually dispose of the activity and
recreate it from scratch so the rotation
of the screen by default is putting
expensive lots of things go on to just
rotate that screen that you know people
tend to do all the time so that's why
it's so not as responsive as it could be
that's just a default behavior their
options to do that to do a different
behavior as well when you press a home
button basically are clipped it just
gets paused and stopped and it's
basically sitting in that cache in the
back so that's a little bit about what
goes on and when you click on a star on
a status bar you can restart it started
and resume it so basically you can bring
it back from that pause cache there
that's a little bit about the details I
know it's a lot of small types so they
want to bother with that too much on for
those of your poor familiar with the
code at the end of the day this is what
code looks like but I don't want to get
you too stuck on on the actual Java but
basically what we have going on here is
you know we have a some conductivity
which is extending from a system
activity and then what we are doing is
we are just overriding a bunch of
methods so so that's what I mean by a
callback
which is basically fill in the blanks
you could be doing something interesting
in those blanks or you could just be
doing not implementing them at all so
just really depends on at what stage of
the life cycle you want to do something
so those are the callbacks on pause on
start on you start and destroy I'm sorry
son they're a couple of other things
that they added here and that's mostly
for processing the menus which I'll talk
about later so the callbacks like I said
the main ones are the life cycle ones
that that get called when the activity's
going through different stage in the
life cycle so on create on resume on
pause only start you know destroy and
that's what we just talked about at
which stage which one gets called and
what you usually want to do in any of
those particular stages um on create is
sort of like the universally important
one if if you remember one in the brown
create it's kind of like your
constructor or your enid method that's
we initialize things you're almost
always going to have that one the rest
you may or may not have one regular
basis and there are many other methods I
just kind of mentioned some of the more
common ones that you already saw but one
is for creating the menu to basically
load up the menu system that once you
write your Java code what you typically
need to do is you need to register it as
part of your application so this is kind
of interesting in Android the map itself
is nothing but the collection of these
components right so an application
actually doesn't really exist it doesn't
really do much right so it's really just
a hodgepodge of activities services
providers and receivers is what I call
main building blocks that we're talking
about so don't relatively loosely
coupled so basically what there's a file
that specifies all the components that
you have in your app and that file is
called an Android manifest file it's
sort of the main file describe you
describing your entire app and basically
you would need to just say hey I have an
activity and your main activity sort of
your entry point sort of like a home
page on a website right would have
something called an intent filter which
I'll talk about later but most of the
other activities would simply be usually
a
liners in that file that file is usually
about one or two screens in size
actually kept the Eclipse environment
open up here to see what we've usually
used for Android development and if you
just cared about that but that's
basically that file for young but you
know it's about hundred no it's about
any lines of code or so of XML so it's
not unmanageable
there's a double negative so it's
manageable so what we're going to talk
about next is the user interface so okay
so activity is there to hold your UI
it's got this fancy life cycle that it
goes through to protect the memory
manage memory but ultimately you got to
build new UI and this is where Android
is sort of different than a lot of other
systems that you may be familiar with
I remember in Java we would use
something called a WT or swing to create
UI you may be experienced with HTML CSS
those sorts of things in Android we
actually have a combination of the two
right so basically there are two ways to
do UI you can do UI decoratively and
what that means is that you're
essentially creating UI using XML and
you can that's a really nice way because
you can use some graphical tools to help
you out with that
the other approach is to do it
programmatically basically you write
your job ok so I'll give you an example
if I have a simple old screen so let me
pull up a for example that status
activity that you've seen before and
sometimes Eclipse gets positions with us
but we'll see if it loads up eventually
essentially there we go
so I have my screen that's the screen
you guys saw earlier when I typed in
hello from building time um and and so
this is a very familiar environment that
could like for example you know take
some stars and drag and drop it here
that sort of stuff so you can basically
build your your UI but just doing a drag
and drop but at some point you got the
same with the UI actually does like what
happens when you press that button
update there's gonna be some kind of
logic right so it just happens that XML
is really good
for building drag and drop tools right
think of it as sort of Dreamweaver right
you can really quickly whip together a
web page but then what happens when you
click on a submit button so it's sort of
similar so we whip together the the UI
using XML and tools like that see
ultimately it's just a little bit of XML
it looks like an HTML page more or less
but it's a point together flip over to
Java and actually implement it so the
Java code that kind of relates to this
would be the status activity so it's you
know it's a little more code you want to
go too much into details but the point
is that we're mixing and matching XML
gets us there faster and then in Java we
say what the button actually does when
it's play ok so that sort of the
approach that's sort of unique to
Android and unlike many other platforms
so we start with declaring XML inflated
into Java ultimately it's all Java and
then we finish it by by uh adding
actions in Java programming in Facebook
so for those of you who are familiar
with Java or most of the other UI
frameworks this is where they're all
sort of similar they're not different
they're similar most of them have a
hierarchy that is usually missing like
this basically you can either a
container that contains components like
in Java swing or aw team in Android we
have the same thing we just call it
different names so we call the
containers we call them layouts they're
basically basically are capable
containing other components so you can
have a container within a container or
layout within a layout and then
ultimately you would have a widget like
a button or a piece of text or a text
area or something like that right so
basically for those of you who are
familiar with design patterns this would
be a composite design pattern or for
building a UI so and it does a very
similar sort of approach to building
anyway so at that at this point we have
all right we are done with part one and
part one all it has so far if you
remember this is all we've built we've
built a simple screen where you can type
in something press a button and what it
does is does a web service call and post
to some kind of Twitter service in our
cases llamado Park
um but it's a cloud nonetheless so it
doesn't actually make a web service call
so we cannot see what other people are
saying yet we cannot update our username
and password none of that so what we're
doing in the next iteration is we're
gonna build a so called main activity or
entry point we're gonna add a menu so
that you can specify what buttons you
have at the menu which call now a status
bar or action bar and then we're gonna
add preferences we can update your
username password
server so we're gonna basically go from
one screen add to a three screener
right so basically what we're going to
look at first is how to glue these
screens together so this is where we are
learning another kampala
concept that is sort of unique to
android and it's something called
intents and basically what intents are
are sort of events or messages they're
they're very lightweight and they're a
way to blow together this loosely
coupled building box right so I'll give
you an example let's say I am reading
I'm looking at my Gmail application
right so there's my Gmail app and I'm
looking at the connectivity so a screen
a single screen where I can see a list
of my emails all right so see a whole
bunch of emails and then I want to see a
particular email so I click on that
particular email what happens next is
actually go to another screen now you
know it's an activity and what I can see
there I can see the details of that
email message right who sent it and
attack stencil so what we did here is we
basically fired off an intent right to
send an intent to go from one type of
activity to another all along we were
still in the single app right now inside
I'm reading this email message and it
says oh check out this story about
Android taking over the world or
something so I say fine I click on that
and what that does is actually launches
of all the other app but the inside of
that onio trap it launches an activity
right because you can't see an app you
can see the screen since I'm gonna okay
it's sort of like I use websites and web
pages is an
oh gee you can't see a website but you
can't see if cnn.com you can see a
homepage of CNN a particular story on
cnn.com but you don't see a website the
web set is just a container for a lot of
web pages so it's very similar sort of
in Android you don't see an app you see
a particular activity inside of data
right so we open up a web browser and
more specifically we launch an activity
that's now in that running stage right
so it's visible interacting with the
user so I'm here I'm I'm reading the
story about you know taking over the
world and and I got here because I
clicked on yet another intent fired off
yet another intent
so what you're doing next is in this
story in this web story I see there's a
link to a video so I click on that and
that will launch yet another application
with yet another activity using yet
another intent so you kind of get an
idea car we kind of flip flopped across
multiple apps and the user is not
concerned with that just like when
you're surfing the web you're not
concerned you're going from a website to
a website you're just completing a task
right so Andrew it has the same concept
of a task and we can unroll roll back by
using the back button from this
application stack so that's what intents
are so they are basically growing
components together they they have their
they can they can be implicit explicit
I'm gonna talk about that in a second
but the point is they can be within an
app or they could be across multiple
applications just like HTTP HTML links
or HTTP links in the web right so so
basically what can you do with an intent
I used an example where we just went
from a screen to screen to screen ie
from an activity to activity but this is
not just limited to activity so you can
do a handful of things with intense we
can start an activity you can start to
stop a service or bind to a service or
you can send a broadcast so there are a
couple of things you can do with this
messages not all that many so that's
basically the intense do now briefly
mention intents can be explicit meaning
I spell out how I want to handle a
particular event or they can be implicit
meaning I let the system figure it out
so for example in
if I go back here when I was in Gmail
they're looking at a list of messages
and I said all right I want to see that
particular message this was explicit it
opened up the particular message using
an internal message view activity of
Gmail it wasn't there was no question
about how to handle however when I was
here and I said I want to check out that
story that open up a web browser but
which one we don't know right it could
be that the user has the default browser
it could be Firefox could be Chrome it
could be any number of web browsers that
are available use this device just like
when you download it you know your
Safari or Chrome or your firefox
attached to would you like to become
your default browser so it's a similar
kind of resolution happening in Android
OS as well with the implicit intents so
that's basically what implicit versus
explicit intents are and just from the
implementation standpoint for those of
you familiar with Java when we are doing
explicit intents we actually spell out
the class that's going to handle them so
there's no questions about this whereas
when we are dealing with implicit
intents it's more of a action based and
actually it's basically just a piece of
text right our usual look something like
that but it doesn't have to it could be
you know Mickey Mouse or something
that's a valid action right so that's
what the system gets to figure out or
the best way to resolve it is so the
system resolves it using intent filters
so briefly mentioned then when we talked
about what makes something a home
activity or main activity and that's
basically the intent filter that says I
want to know about that message to get
broadcast system somebody sends the
messages open up a web page or somebody
else is saying I'm capable of opening up
a web page and that's how Firefox
competes with chrome competes with you
know the default web browser because
they all raise their hand and then the
system says all right I got three apps
or activities that can handle this which
one user which one would you like to
handle
actually so so so it works based on
intent filters and that's what the new
intent filter looks like
programmatically so we're basically
saying just in XML in turn filter action
and some named Mickey Mouse so so that's
a little bit about intent filters now
that we have intent filters we can
launch all these things right we can
launch all the remember we want to build
three screens so so what they're gonna
do for that is we're gonna use something
called action bar an action bar is
actually something that's relatively new
in since honeycomb and it's basically
this this thing here it's basically this
thing here goes all the way so it can
care buttons if the buttons can fit you
can press on a menu and then more things
would pop up and so forth if you have a
tablet with no menus there's gonna be a
little dot dot you can click and it's
gonna expand and so on but the action
bar is sort of a more powerful with used
to be just a menu button on the older
pre tablet devices so what we're gonna
look at is how to enable it so basically
if you're using Android that's older
than newer than honeycomb right so I
need tablet based Android which is
basically API level 11 or above it's
gonna be pretty much automatic if you're
using all the ones it may look like
default menu so they're very comparable
they just look different but for the
most part they are very comparable or in
terms of how to implement it but how
they work there's some new features that
we have an action bar Detroit and x4
because we're mostly concerned with with
a newer newer stuff angle so basically
to create a an action bar you again it's
very similar to building a UI you do a
little bit of XML you specify what
buttons you want right so this this is
what it looks like this is like me
saying I should have a menu save button
and show it if there's space with text
and if there is a space that's okay just
put it behind the dot dot dot so the
user can click on the dot a dot and
expand
so it doesn't it doesn't know it doesn't
have to be all that complex so that's
that's what that could look like in Ice
Cream Sandwich there's also a support
for something called a split action bar
so basically if you give a lot of
buttons and you can't feed them on the
top like in this case I can if you
notice in this case I can fit them all
here but in this case if I rotate my
screen on the emulator so I'm going to a
different view
I can't fit up there anymore right so
what I could have done is I could use
the feature of a sandwich to have the
menu button also show up at the bottom I
did I chose to put it behind the usual
menu button because this device has a
card card menu button and you can here
you can click on for example preferences
and you can update user name and
password that sort of thing so that's a
split action bar too you can also enable
certain things to happen when you click
on that little icon there so for example
if you wanted to have this go to at home
you can click on that as opposed to
getting to click on the back button you
can also can have it go one level up so
there are certain avocation things that
are new in in ice cream sandwich that
make it a little easier to use from the
user standpoint so so far we have a so
we have three screens so we have this
screen there's nothing in it so this is
blank right but we have the menus so we
kept this menu and we can click on this
and we can actually type something and
it's gonna show up on the website as we
saw earlier and we also have this screen
where we can go and update our user
name/password so for example I can go
and I can say my user name is Bob for
example but we so we have a way to push
tweets out but we don't have a way to
pull them down and this is where
services become very handy so services
are things that that are basically
running in a background but I want you
to be careful with that word background
because me
different things to different people it
doesn't necessarily mean it's running on
a background thread
it just means you can see it all right
for now so basically what we're doing
here is we now have the action bar and
by the way these blue lines that's my
way of saying it's an intent right so we
are firing it intent to go to this
screen
firing intent to go to this screen and
also firing intent to to run this
refresh service which is gonna go to the
cloud and say are there any new tweets
sort of like put your pop3 email did to
check your email right that's what we're
sort of doing we're gonna talk about
pulling on data so that's that's
basically what it's gonna do
but we need to trigger itself so what
we're gonna look at is called to do
services so services are like I said
things that run in a background became a
much simpler life cycle than activity
and usually don't get just destroyed by
the system and as activities do remember
activities get that complex life cycle
they just get wiped out one system
thinks it needs more memory so good
example to kind of understand a service
would be a music player so say I'm by
I'm writing in your application that's
going to play say it's a Pandora app so
I'm gonna basically pick a station I'm
gonna listen to music right so I
obviously need some kind of user
interface I need somewhere I'm gonna
give it a thumbs-up thumbs-down pick a
station that sort of thing so any DUI
but they also don't wanna on the playing
of the music on that in that activity
because it could just you know if you
get wiped out from the system at any
point so we don't want the music to
abruptly stop playing so what we do
instead is we basically create a service
and our UI simply starts a service it
may go away and that's not a big deal
because the music is running now when
the user comes back to that activity
that activity may get recreated from a
stop state but may actually get created
for nothing right from scratch which is
fine it's gonna take a little longer but
to a user is just gonna work so so
that's why a service is a useful tool to
own background things but now like I
said by default default services
basic services actually run on the same
thread as a UI you got to be really
careful about that because doing network
stuff used to be just a really bad
practice now it's simply illegal you're
not allowed to do that starting from
honeycomb because it's gonna make your
user interface sluggish and you don't
control it so if I don't have a network
capability I may be sitting there for 30
to 60 seconds until the time salt right
that's a really bad idea
you get paying arse up again and
responding and this is what the users
give you one star and you can sell you a
penny more so you know so basically
we're gonna be running into a separate
thread so service life cycle like I said
it's a much simpler you basically say
start service and it goes to a create
start then it's in a running state and
some point is you say destroy service
and it gets destroyed I'm pointing out
that you you say it is opposed to the
system controlling it's it's much more
in under here for twelve what happens in
terms of that so this is a life cycle so
when you click on up when you click on a
so we start it goes to create on start
when you say just start and it's already
running it just goes drone start she
doesn't need to recreate something it's
already create it if you're stopping a
service it destroys it if you I'm gonna
talk about something called intent
services but intent services actually
get started on a separate worker thread
so they just basically start they do
some work in the actual background
thread and then they dispose of
themselves so it's a very useful little
helper type of service so this is a
typical template for a service it's much
simpler for those of you familiar with
Java so just like before with activities
you start by subclassing something from
a system so this is given to you and
then you simply override a bunch of
methods and you typically want to
override something like on create and so
on right so that's basically what what
it looks like so it could be usually
it's relatively simple implementation I
mentioned intent services and what I
like about them is that they solve the
problem of not blocking the
why said so basically anything that you
put in the on handle intent here
automatically happens on a background
thread so it doesn't basically does it
make you you I've sluggish so it's a
very very very useful tool but other
than that looks very similar to a
regular service so these are standard
service callbacks so what if you are
then activity so you can bind on create
so I said this is the good one
universally usually care about on start
command and I'll destroy and intent
service has pretty much the same
callbacks the only difference is there's
a post one start oh man it's called on
handling time so just one tiny little
difference and whatever you put into
this happens on a separate thread just
like activities we need to register your
service so if you're registering it for
an explicit intent all you need to do is
you need to just say one liner this is
my service I have a service through the
name some service a music player for
example if you want to start it using an
action you need to create an intent
filter with that action and give it some
kind of name right so that's the only
slight difference when you so so far we
have the following we have the main
screen right we have a way to post good
twitter we have a way to change our
username and password we have a way to
pull the data from the cloud so we're we
know the data is being pulled because we
can see the dump of the data right in
the console in the log but we don't have
a way to display it to a user so what
we're gonna do next is we're gonna keep
the local copy of that data because you
don't want every single time to go to
the cloud for the data this is where
it's different to program native
applications versus web applications I
usually check my tweets when I'm you
know in the subway or flying summer and
so on and you may not be able to connect
to a cloud in that situation so it's not
that cloud right so it's good to have
sort of a local storage set of a local
cache of your data just like Gmail does
and song
so for that we're going to use something
called status provided or our content
providers so content providers are
basically a way to expose data outside
of your application so I drop and we
might notice that draw applications like
these like sort of silences right and
they're sandbox so basically everything
that's in one application is only
visible within that one application so
nobody else can can touch it it's
actually controlled by the Linux kernel
so it's pretty secure now every once in
a while you do want to explore some data
outside so content providers become a
really nice way to basically provide an
interface to the outside world and it's
very simple it's insert update delete
and query the only four things you can
do with data right usually content
provider is backed by a database but it
doesn't have to be it is it could
actually in itself go out to a cloud and
pull the data right it could be doing
something something else altogether so
it doesn't matter cards call the
difficult of data storage persistence is
implemented system uses this all the
time so for example your contacts are
stored in a context provider and then
you basically have another application
that shows you your context like an
address book your media store is also an
independent content provider so for
example if I if I'm walking down a beach
and take a picture of my daughter that's
a camera right but it's storing that
picture now inside our content provider
so that I could use it in my gmail and
email it to my parents or I can use it
in Facebook and post it as a new update
and so on and so on right so basically
by using something like a media storm I
can share that piece of content with the
universe within my phone right so this
is an example that kinda mentioned
earlier a typical example so basically
your address book is actually not a
single app it's two separate
applications you have one app that
contains your user interface so it's got
an activity or a couple opportunities
but it's got no data if you look at your
contacts you're not gonna find any
people in there right your address book
there's a separate application
altogether which you don't see I
it's there it's running it's a content
provider it's a contact content provider
and it actually runs out there it's got
a database and it's got all your people
in that and basically so that's what
that loose connection comes in so
basically one app is contacting the
other half and asking for data and this
provides for an easy way to remesh an
android device this so that you can do
an android you can't do on many other
things so for example you know HTC is
gonna come up with the sense you can
something called Sense UI which is a
sort of a much nicer experience of
Android right so typical Android is all
about apps and HTC take is more about
people so it's not like I want an SMS
Bob an email Bob but it's more about Bob
right so what that allows HTC is to
basically create another address book
maybe a sexier version of an address
book that also has an activity that can
now tap into the same data source so you
basically can have a single data source
you can have multiple others notes files
up and this is just one example so
that's where a content providers become
very useful again relatively simple
conceptually you only have four methods
you can insert update delete and query
the four things you can do with data
crud right and but the implementation is
somewhat not-so-pleasant and so I kind
of just provided a very rough skeleton
here but don't show you what the pool
implementation of the amber content
provider is for example but basically
you have a lot of those methods insert
update delete and query and they need to
they need to do certain things provide
the data in proper way and so on and
it's all based on your eyes so it can be
kind of like loosely coupled and so on
so that's sort of that's what we get
into Java interfaces so that's why it's
not as much fun in this particular case
but those are the methods so you still
have the oncreate the usual
you can sneak all get type because your
contacts app could be returning
different types of data you have insert
update and delete and query so those are
the four crud methods
the content providers to register it and
just like activities just like services
except there's something a little new
and destiny called authorities so
basically need to specify an authority
for the content providers that can be
found and typically looks like that
reverse of your domain name plus some
kind of provider name but the tunnel
it's not that
unlike activities and services that
we've talked about so far okay so at
this point so up until now we get
everything except we didn't have a way
to see their show tweet we had it so
remember we pulled it by a service we
put it inside of a provider which may
have it inside of a database but that's
not known to the rest your system right
so that's intro internal implementation
at the system level but we don't have a
way to see or the user doesn't have a
way to see the data nor the user can see
the actual content here so what we're
gonna talk about next is how to build
this and it looks like we're talking
about UI but it's actually not just UI
so this is where it gets a little
interesting
so Android provides something called
adapters in lists so I make it a very
large database of content right so for
example you know if you're like me you
may have and you know let's say it's
your Gmail account you may have 10,000
messages in here right in your data
source on your device but your screen if
this was Gmail you can see maybe one two
three maybe 10 different things right so
what our challenge now is how do we glow
a rather large data source to a rather
small screen and this is again I know
some of you are developing using web
frameworks and things like that this
were the native application becomes a
little smarter than a web application
right because it doesn't need to
download all 10,000 email messages
knowing the time can't possibly consume
it you may get the first time maybe 15
and then as I scroll it's gonna
dynamically
the data build the UI but he used the UI
and so on and so so basically the
adapters are what provides for the glue
for that ability to connect a rather
large data set or other small you
endanger it very very efficiently now
one thing that I wanted to mention here
in terms of the upper implementation
something that is called fragments has
nothing to do with fragmentation for
those of you prefer that dirty work
right it's basically a reusable user
interface so remember when we talked
about activities I said an activity
takes an entire screen right well when
they designed the little falls that was
fine because the screen is so small so
why would you not want to take an entire
screen right when they came up with
tablets you actually get a lot more real
estate so they figured well okay so we
got more space how do we put multiple
things onto that screen also they
figured okay so if I'm gonna write an
application yumbo or something else am I
gonna have a different app for a phone
or a different app for a tablet or
different app for a TV right and you
probably do not want to have a different
map so you probably want to have a
single code and you want it to look
great on a phone with a tiny screen on a
tablet on a TV and anything in between
right and keep in mind that we care
about five 600 officially certified
Android devices out there on the market
so talking about many many different
combinations of screen sizes density per
inch all right so so fragments are
basically a way to build reusable user
interface so for example if I had a
tablet my my screen may look like this I
may have an activity but that activity
actually make them consist of two
distinct fragments right so I have a
fragment for time line where I can see
the list of my tweets and I may have
another fragment where I can see the
actual details right now if I'm viewing
the same app on a tiny screen what I
would do is I would just rearrange this
reusable component
and they would basically look like this
so basically I would have one activity
that has just one fragments is
essentially just wrapping it in another
activity that's just wrapping this guy
and basically you would have to click
and you ought to open up another sort of
a traditional experience right so you
want this that look like this right so
basically here is this mode so this is
this mode right where you can see only
the list and then I have to click and
open up another activity right so that
looks like this right so I can click on
a yellow from building ten and well
there's another activity with another
with the actual details and I can click
them back and you can notice that it
kind of flips over it goes back one want
one back on the stack now if I just
rotate my screen to a landscape mode I
kind of pretended that's now I have more
real estate right so that's how I
designed it so if I rotate it it's gonna
redesign itself to take advantage of the
more space it's gonna say oh okay I see
that you know we get more space I'm
gonna show things here and and that's my
tweet that no it's I mean like there is
possible but but basically it shows up
on the other side the actual details so
that's more of a this design yeah so
basically the majority of my UI is being
reused between this took a bus so
fragments um so maybe a little too wordy
but fragments are basically this view
reusable UI components they always must
live inside of an activity but they do
not have to have their show you why you
can actually get fragmented on display
at all they're actually useful for some
background tasks and they they kept
their own life circle they attached
themselves to an activity they
dissidence and so on so that's basically
this is the implementation details that
we have now another thing that's also
new to support the less fragments
adapters and everything else that came
out with honeycomb and now that we use
extensively in ice cream
which is something called loaders and
loaders are there to basically help us
with the fact that that loading data
could take a while because you don't
know how big the data set is and all day
you're in loading just maybe ten items
you may take a while to load it if it's
over the network or some other something
else like that
so basically what loaders are is a way
to to load data asynchronously
it's an implementation of a fan
asynchronous mechanism where you say
start loading when you're done call me
back
and then I'll retrieve my my data so so
that's basically what it does it's not
necessarily a separate thread or it
should typically it should be separate
that but it's more of an asynchronous
implementation like that
like I said we have it since API level
11 which is basically honeycomb so
that's when you appeared first one thing
that I wanted to mention that about the
availability of all these components
like keep mentioning all these new
things like activities you know
fragments loaders and a couple of things
like that that are only available from
Ice Cream Sandwich there's actually a
support for them that goes back to
cupcake which is basically a very old
version of Android so you can do it via
something called a support library so
you just need to throw in a jar into
application so you can you can take
advantage of the latest greatest even
though your app may be designed to run
even on the older devices so that's
that's that's a very good thing than
ever like the backwards compatibility
way backwards compatibility all right so
so we are now at part six of seven so
basically what we have at this point is
we have a we have an activity we that we
can see all the tweets we're using the
fragment layer of reusable UI to see the
list we have details activity that shows
the details fragments remember this
could be one activity if we have enough
real estate but that's not that
important and and everything's working
very well one thing that that I wanted
to introduce here
if something is the final fourth main
building block something called a
broadcast receiver and basically the
reason why we needed here is simply
because a refresh service although I
have a button here to click in and kick
start it so I can press this and it's
gonna go and it's gonna pull but this is
live data so I apologize
so everyone who's reading the book has
the username password a student password
so they're just a lot of people using
that service so just so so basically
what we don't have is we don't have a
way to kick-start our refresh service so
the reefers know the refresh service can
be started by a human but you know when
you turn on your your phone do you kick
start your Facebook and we're gonna
Gmail and all the other apps you don't
write you're just like open it up and
it's like wow my emails are there I
didn't have to start anything it just
ran right so broadcast receivers are
pretty useful for that but basically
what they are is is a way to to send
broadcasts and have something else catch
what's catching the broadcast is a
receiver so let me give you an example
of that so basically for those of you
familiar with design patterns it will be
observer observable pattern or
publish/subscribe pattern but basically
I make it a piece of dormant code right
it's not running unlike a service it's
not actually cranking in the baton it's
actually not in memory at all it's just
registered somewhere so we basically
register it with the system and we say
this piece of code should be
kick-started when something happens and
that something could be for example an
SMS arrived or the battery's running low
or network is not available network is
available system finished booting those
are two things right or it could be our
own broadcasts like you got new tweet
do something about that right so
basically what the block is the receiver
does here is registers itself and when
that something happens the system
triggers it that says hey the thing you
care about happen
or on your call so that's that's
basically their implementation there are
at least design the implementation is
actually very simple
it's probably simplest you just like
everything else you extend a system
inherited class broadcast receiver but
you only have a single method there's no
one create don't start or restart on
pause and stop on this none of them
there's basically a single a method that
says obviously so basically a full code
just gets woken up to do something I
mean there's there also there is all
great and so on but you do not need to
worry about that for the most part so
basically you just implement whatever
you want to do in this block and just
call back so that's a little bit of a
job and when that something happens this
is just our proof that you know we
indeed got that action so we're seeing
this in a lot of pretty secret actions
like everything else it's got callbacks
but it's only the list is very very
short honestly
so registering a callback registering a
broadcast receiver is also done in XP in
Android manifest file that main file the
controls everything in your app and
basically you need to specify and then
filter which we talked about before so
you basically say what kind of action
you care about and like I said those
actions your system actions like new SMS
er battery running low or it could be
your own actions like you get a new
number tweet you can also register it
programmatically but this is a little
bit more Java so in this case what I'm
doing is I'm doing essentially the same
things that I'm doing in XML but I'm
doing it programmatically so I'm saying
hey there's a new intent filter register
it provided action and registering 20
and so on so it's just a little more
verbose and more Java but it's
essentially doing the same thing so the
final
seventh part of Java is gonna be this
party talk bomb right corner
we're basically adding a Appaji
and what an awkward it is
one of those little things that you put
on the home screen that shows you you
know what's going on right like it could
be the little weather widget you have a
new voicemail widget or one of those
things that we have what the pumps going
to put me in just a clock right so so
what we're going to do here is we were
going to implement it and basically app
widgets are surprisingly they're
actually related to broadcast receivers
it doesn't appear that way but they're
basically little pieces of you either
place someone else is somebody else's
process and they get the notification
that says hey there's something new for
you to update so they're they're
basically just like a broadcast receiver
so you use a very similar way of
declaring them there's some other things
that you need to specify in addition
that you do not need to worry about it
notice receivers and that's what the
default sizes and what a default refresh
rate is you know how a certain budgets
are just bigger or smaller for those of
you phone Android phones you know that
sometimes for the same app they're you
know 47 versions of the same which is
just different dimensions so that's
because that's that's what they specify
the specific various sizes and this
would be a refresh period so basically
what I'm saying is look I don't care
more than every 10 seconds about new new
tweets so so that's basically what the
code looks like it's all awardees I'm
not gonna go into the details but some
of the usual suspects we sub we subclass
something from the system we implement
on receive and the new one that we do is
on update so just like a broadcast
receiver you have on is here but with
unlike notice receiver you have on
update so that's an Estonia and finally
that's that's what it looks like so we
basically have a lot of widget that
shows up on the home screen that that
may in this case it's very very simple
about basically I could click on it aim
presumably to open up the app and show
me the details details of data
so forth yeah so that's basically all
the seven components that we have all of
Yamba thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>