<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Breaking Open: Erlang | Coder Coacher - Coaching Coders</title><meta content="Breaking Open: Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Breaking Open: Erlang</b></h2><h5 class="post__date">2013-05-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/m5RWdNBPsTY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Marco garganta and today
we're breaking open our language its
founder Joanne Strunk
welcome thank you so we're pretty glad
to have you here in San Francisco it's
not it's not every day that you come to
a stateside term so what brings you well
it's yelling factory loads of airline
users get together and Richie I wasn't
meant to go but then I saw there were
all these interesting talks and I don't
see what's going on any in a specific
talks and specific infrastructure
application I'm kind of interested in
thinking about large silver forms and
and low energy and if we can turn them
off there's some stuff about that I
don't know about it keep my nose near to
the ground and see what's going on so
basically power does server farms for
the Erlang and yeah I think yes I mean I
think environmental problems I mean with
have actually been doing what you might
call optimally bad things for many years
so if they've they've been doing load
balancing so if you imagine a hello to
service and you know balance over them
you know you choose a server with the
least traffic on it and and then you
never turn the things off but the
biggest power things I've got they've
got by turning service office he
shouldn't be doing no balancing you
should be doing load concentration you
really want to switch the switch around
loads and turn things off I was I was
looking at the actually the lineup of
speakers for Erlang factor a little bit
and it seems like that there's an angle
to the big data for the furling and
certainly big data is becoming really
hot in here you're talking about does
the server farms and there's a whole
buzz about that so do you see our line
be a good solution for solving the
problem of basically you know crunching
numbers across inexpensive hardware big
data well of course you could do that in
any language but the darling was
designed as a parallel program or for
concurrent program so so so much it was
designed to do that kind of thing it was
it wasn't designed for big data but it
was designed for massive concurrency
and and and so it's appropriate for that
yeah and the other thing you have to
think about is is if you go to planetary
scale computations or very very large
scale computations you have to make
these things self repairing and self
configuring your back to Allen case idea
of object-oriented languages where where
things repair themselves I mean I see
computations as a assam widgets of some
of the means of computation you sent
messages they break yelling failure
model is is kind of central to all of
that yeah I I think it's interesting
because uh many other languages you can
also accomplish concurrency and put
things in a parallel and there's so many
solutions for that but the other half of
Erlang is its fault tolerance yeah I
mean suffix it the language it says I
have got airline like semantics means
they've got they mean by that they've
got the message passing and the
mailboxes and things they don't mean
they've got the error handling and the
word the way the errors are sort of
integrated with it you see is error to
handle out-of-band in Erlang you know
you've got you've got the sort of
regular things that should be going on
and then you've got the errors and you
treat them completely separately God
that's a very kind of healthy way to
deal with system I mean that's that's
how we work I mean you don't Tim you
don't repair yourself if I drop over
with a heart attack
I can't repair myself a computer that's
crash can't fix itself somebody else has
to fix it that's the note observe the
fact it's gone wrong and fix it if you
want to do if you want to do fault
tolerant computation you need two
computers
come down one computer I mean how can
you how can you make anything fault
tolerant with one computer because if it
crashes in the story so in fact you
leave two computers this ones doing the
work this one's observing it if it's one
crash it's just this one takes over
alright so if you want to do something
that's fault tolerant you need to do
both concurrent and distributed
programming so that's that's where we
were in 1985 or something like that so
we thought okay so how do we program
this stuff because we were building
highly fault-tolerant systems so that my
interest is in building highly
fault-tolerant systems it's not even
concurrency is natural because of it now
once you've split things into two
machines that's the basis of scalability
you see fault tolerance and scalability
a ultimately connected if you have
thousands of independent elements it's
scalable it's also fault tolerant so
that the architectural things we have to
do to achieve fault tolerance are
exactly the same thing that's the
architectural things you need to achieve
scalability to solve the the fault pause
I was to make photon system wasn't made
it wasn't to make scalable system they
then turned out to be scalable as well
and they also turn out to be easier to
understand because their intellectual
exercise of programming them forces you
to think about small units which in
themselves can detect and recover from
errors
interesting interesting so this is this
is the basis of object-oriented
programming you know telling K said you
know to the notion of an object is
you've got this thing to get it to do
something you send it a message and then
it flies by sending a message they're
like I think is the only object oriented
language and I've been quoted often as
say well I thought it was silly I didn't
think of it or depressed but silly a few
years ago I've changed my mind and now
I've decided it's a good idea but I've
also decided that Airlines the only
object order language garden thinking so
Java and that aren't actually
object-oriented speaking of languages
Erlang has a very unorthodox syntax so
how did that come about now it's very
other languages have got very on also
don't guarded if they're really weird
always strange curly brackets everywhere
I know okay that's one way to look at it
so when it came from Prolog so if you if
you program Prolog familiar with syntax
I mean I can people look me in the face
and say Airlines got a weird syntax on
they can write Perl or something like
that you know this is that's talked
about week you forget syntax okay it's
like English you know you have commerce
between sources dot at the end so so it
is a functional language and there's the
whole rage about yeah functional
languages nowadays so how does it stack
stack up against thing on the other cool
kids on the block
Scala Haskell yes it's perhaps not as
religious as it's a very pragmatic
language to build systems
not the Haskell with wasn't built there
but but I mean that the view of the
world is different the view of air lag
is is the world that's always changing I
mean that we put code into a system and
we run it and then we upgrade it without
stopping it that means it will be
inconsistent it might mean you can't do
type control or things like that and it
also enables a lot of things which you
can't do if you have a strong type
system so so that's what swappable
language right that's that's one of the
buzzwords or so and so far like where
does that land itself well what kind of
applications do you see that's important
to a label thing you never want to take
out a service you know we've seen
there's a bank in in Sweden Kelowna
which which uses it I think they're one
of the only banks that never never
thought of service you know they upgrade
their software without taking out a
service there's not a four-hour period
middle of the night where they turn it
off to update the database it just rolls
around the clock and and of course we
come from and then comes from Ericsson
where we build telephone switches so
it's kind of in the DNA of the
organization to to build for power
distance I I was brought up on them and
you know we we used to have this four
minutes of downtime per year was what's
the spec for the for telecom testament
more than that we paid fines
you know thousand dollar fine if you
were down for more than four minutes
yeah so it's like four minutes per year
oversee the base case and that's for the
99 skim down over that four minutes a
year is about five nine six six nine
so what's heating abouts about six nines
at the moment six days the nine nines
was more a kind of one of our customers
said that British Telecom we thought wow
it's quite quotables excellent it was
their information not ours so it said we
did I mean that was a marketing gimmick
really but I mean what it's not been
wasn't true but it was it you don't want
to take it out of context garden I mean
we're not I mean in my lecture giving
one of my lectures I said whoa where we
got this idea that five nines is
difficult you can have a hundred lines
if you want it you know I mean it's it's
an engineering thing if you have if you
have a thousand systems and the
probability that they all go down it's
10 to the minus 3 the probably they all
go down at the same time is 10 to the
minus 300 sorry how does a a thousand
three
like that one box up yeah I mean yes I
mean independence it makes it yeah I
mean two machines the probability that
both goes down is 10 to the minus 3
probability to both go down same time
it's 10 to the minus 6 I've got three of
them it's 10 to the minus 9 4 of them is
10 to the minus 12 you can make it 10 to
the minus anything you feel like if the
architecture allows them to be
independent so a basically concurrent
systems are always gonna come higher
yeah both honors done anything else bow
or down lower downtown hey well if you
want zero down time you have to make
them independent and you know with their
own power supplies independent spirit is
everything and so it's kind of a good
idea if the semantics of your program
image kind of understands that at a deep
level built into its code so so we've
been building systems like that for
years I mean we know we're doing that so
if there's an open source project but
what kind of an open source project is
it how do you guys manage yourself how
do you govern yourself is it is more
like the Linux type of an open source
project more like an Android type and
Oprah's open source project we're
totally different governance to
internally I think to me the open source
in that sense means it's got an open
source license I mean we haven't really
talked that much about the government's
that's now becoming more interesting I
mean it's be derrickson it's open
sourced it and we've taken in
contributions how it's going to go in
the future is something we're discussing
at the moment okay so do you have
actually a network of contributors
pitching in so it's pretty and and what
about the road map is there is there
like a public road map or is it yeah
whoever needs this there's a formal
procedure there's a proposal but but but
to the extent that which the main
development is funded by Ericsson it's a
hoot Erickson who takes a final decision
on which which of these EPS to implement
themselves and
to concentrate on so I think it would be
nice to kind of open it up and possibly
finance some of these ones which
Erickson might give a low priority to
but but external users might give a
higher priority to I mean we tend to
prioritize the ones which we have
commercial use of so-called does
Erickson fit into the picture now given
today open sourced it but seems like
they're control controlling Narborough
forward well you think we we use it so
much for our internal products I mean
we've we've got hundreds of airline
programmers and we have I don't know the
percentage of the world's mobile
networks that are controlled by if if
you're using an iPhone or an Android
phone in Sweden you know all your data
traffic is controlled by Eric I mean it
just wouldn't work without air like I
don't know about America what what what
market penetration Ericsson has there
but we're controlling about were
controlling 40% of the world's mobile
networks for 3G GPRS GSM edge and we're
controlling 60% of the world's networks
for 4G so every single IP packet is
controlled the most reliable part of the
system it's being controlled by air like
that's the bit that really has to be
fault tolerant otherwise your mobile
data wouldn't work so we're controlling
about 60% of the 4G total world data
networks and that's that's an internal
product so we've got hundreds of
programmers working on that so so the
the OTP group is fundamentally
supporting them so if they said well we
want to change to the language that
moves it in this direction they're going
to get the priority because they're the
people who pay for it and it's not that
we are unwilling or unresponsive to
people on the outside world is just
they're not paying the developers to do
that got it so if we could refund that
and focus it even to those okay so the
economics of the languages are such that
most of the development campus within
Arabs yeah I think yes I mean it's it's
kind of he who pays the piper calls the
tune so they're paying the most amount
of money for development on the other
hand I mean we're probably happy to give
commit rights to people who've shown
themselves to be responsible
that's not an issue there are people
outside Ericsson have commit rights to
baguette to archive some things they
don't need to get approved so it's a
it's a standard sort of Linux you get me
become a communist often is the main
developer I mean he's sort of we welcome
bug reports and often people patch
things themselves but but then B only
looks at it and says mmm well it should
have been done that way instead so I
mean we want to have a good relationship
with and I imagine that's one of the
reasons for Erlang factor you know it
basically to this is just to get
everybody together and also there's a
kind of you to infuse haven't keeps you
going for a few months and it's kind of
like a good so I was looking at the
adoption of Erlang worldwide and it
seems like of course it's big in Sweden
yeah but it's also big in places like
Russia in no damn are you telling me
that and I know that I see a lot of blog
articles in Russian to come translator
it's but I know there's quite a lot of
activity there but I don't many details
it's very they are sort of separate
worlds so do you see it globally growing
and shrinking stead of being steady as a
adoption of the language it gets the
point you don't really know we're seeing
all kind of second wave things happening
now you know stupid questions on the net
and a lot of books now so this I mean I
Francesco wrote that then it's Anna
Reilly boom diplomatic book most largely
yes yeah and then Riley's come out with
another one and just oh yeah that's the
and then there's a second generation but
the books about applications are coming
out and then we've got companies like
that show
during 11 which is what we could tell me
Facebook thinks like that so that kind
of yeah good times yeah I was I was I
was doing a little bit of research I was
and I found that you know Erlang is now
in places like web applications which is
not something I expected to see and in
places like Big Data which I did expect
to see because of this concurrency but
not so much because of the fault
what isn't a surprise to me but is a
surprise to other people is say the
expansion games because a game looks
very much like a telephone exchange to
me I mean it just what's a telephone
exists got you know hundred thousand
people simultaneously connected to one
node that's sort of sending a bit of
signaling then they I mean from the
computers point of view they signal a
bit and then sleep for a long time and
they signal a bit seen in very fast
context switching you need to keep them
all in memory you don't want to go out
to a database or something so your
telephone exchanges we built maybe we'd
I mention for a hundred thousand
sessions in it you know per CPU
something like that and we don't have
stored in RAM and we need to protect all
these hundred thousand users against
each other for software errors so how is
that different to a big multi-user game
it's not it's the same architecture but
it kind of comes as a surprise you know
if you've been doing it a different way
so what were your personal goals when
you study the project well what did you
hope to get out of it other than fault
tolerance I mean impossible I mean it
wasn't the it's like you know there's a
lot of programming language they never
started as projects to build programming
languages this was just actually I got a
job at the labs to to work on just ways
of improving had a program telephony and
and there was a tradition in Ericsson or
building things so so this kind of
duplicated processor fault-tolerant you
got to change the code on the fly it's
never got to go down that's in the DNA
of the organisation so so when we're
designing our lang and talking to it we
had the guys who would there was a guy
at Austin Bell who had done Airy Pascal
that's goal with concurrent processes
and of course he'd learned that from
from
you're in hem doll your own hem doll had
designed the first system sorry I mean I
think your own hem valve could almost I
mean he sort of independently invented I
hope she taunted programming although
he's never credited was that but just
this notion of fault-tolerant blocks of
thinking sending messages to each other
and the million violet so they couldn't
crash each other that was built into
hardware in 1974 by Ericsson and then
you have to remember I mean Eric's has
been building large networked computers
much longer than the Internet the
worldwide telephone networks have been
running for 20 or 30 years before
internet so I think the telecoms guy is
actually new which I sort of called
myself a telecoms guy we actually knew
how to build worldwide networks yes
before the computer people never did we
should kind of rush in and to us were
just reinventing stuff we already knew
about and though we were we were selling
into mass markets with small numbers of
customers so so before the deregulation
of the telecom market a company like
Ericsson would have three or four come
to customers per country well know if
they'd have one the PTT of that country
and then you have then you had
deregulation and have four or five
customers Eric's is big disaster of
course was selling into the consumer
mass consumer market where they were
they made handsets
telephones and they joined with Sony
Ericsson but you see they had a
marketing organization that could only
deal with with large infrastructure
products not with small consumer
products so it's so now it's finally
sold off so you know Eric's is very good
at big infrastructure and underling was
designed for big infrastructure and it
took the kind of history of the
languages before that to growth so as a
paradigm change what do you see is the
kind of like the crown jewel of our line
wouldn't be the message passing the way
of communicating between processes
messaging is the the big thing I mean I
bet to what Alan Kay said you know the
big the big thing about about
object-oriented programming was the
messaging and unfortunately he said you
know people are concentrated on the
lesser idea that's
with the organization into objects and
methods that was a lesser idea the big
idea was the messaging and in fact it's
a big idea in UNIX I mean the notion of
the pipe the host pipe but which
essentially decouples the source and the
destination that's the big idea in UNIX
and in fact why the internet works
they've got all these pipes data flowing
what's on there of course is this all
these RF scenes using text based
languages I mean the the HTTP protocol
for example I mean it goes back to the
simple message Transfer Protocol I mean
it still sends sort of sub I mean SMTP
set subject something and then text
something in it said 200 ok well you can
find that 1700 RFC's later in HTTP it's
much better if you can communicate in
something that's got a generic parser so
if you communicate in in XML or JSON or
something like that you don't need to
have a text specification and it's even
better if you can formally specify
what's in that contract I mean I'm not
saying Jason's a good language but it's
better than text now that you can
language the better than Jason the
world's probably not ready for them yet
so it's message passing in a really
efficient way of processing those
messages right and that's what well I
don't care about efficiency yeah because
I mean all the efficiency has come from
clock speeds and parallelism so so but I
do care about correctness and so I go
back to connect in a plow go you know
they would say make it make it right
before we make it fast and then they say
make it beautiful before you make it
faster and then keep it right when you
make it faster so I think the big
problem that's always interested me and
the problem with all tolerances is
actually how we write software that
works I mean most software doesn't work
it means awful right you know you get
these things you can't connect them
together so in fact I'm proposing models
of software where we're normally just
have a client in a server I think you
need a contract checker in the middle
you know this guy who's independent in
sort of watching all this stuff and
saying are we obey all the invariants we
just don't take black boxes here
I mean I think the trouble with when
when computer science is taught is that
all things aren't equally important you
know if you if you see a set of bulleted
points on it on the blackboard on sides
and they're not all equally important I
think I should have a patent on the idea
of just having a a bigger blob for the
important points you know so I'm always
sitting at lectures visit some guy
sticks up some bulleted points in it
like 12.7 excuse me which is important
one oh it's do you know a number of the
floor how am I expected to know so when
we teach computer science it's very
difficult to know what's important and
what's not important and if I were young
and learning it now I I would be in the
stage of complete confusion I mean I
I've had the privilege of learning this
stuff as it came along so for me you
know learning object oriented
programming or something like that has
not been a big step or a difficult thing
because I've had many years to
assimilate the ideas but if you if
you're just going to learn all that
stuff in the two or three year period
and then be faced with a plethora of
choice and sort of marketing campaign
that's got nothing to do with technology
we wash brighter you do how do you
decide I mean you're right you know
studying Java in college I remember it
was all about basically how the objects
are organized and working here it's from
what and what is you know how they're
related to one another as opposed to how
they actually communicate and then a lot
of things like like the study of
algorithms and you know basic computer
science I perceived as being too
difficult you know the programmers don't
you don't have to kind of decide
graduates I know they dropped the dragon
book from some courses because building
a parser or something from first
principles was too difficult exactly I
mean this is this is the craftsmanship
of programming this is the stuff you
gotta learn now I had the advantage of
being able to learn it over a many
periods I didn't have to do it only two
years which would be so we talked about
you know concurrency and we talked about
fault tolerance the two halves of our
line there's the third have the OTP and
to some people that is a very important
control of the system so tell us a
little bit about
slaying them it's got a perhaps an
unfortunate name because the name Aleppo
yeah I mean it's a kind of funny name I
think you should if you if you thought
of it like C and Unix you know cease the
programming language UNIX is the
operating system so so you've got air
Lang which is the language and you've
got OTP which is a large set of
libraries which give it sort of
middleware properties so so OTP was
actually designed for the building
projects with big teams I mean it was
built for it was a third generation it
had been used twice before and it was
the third rewrite and it was done for
the Ericsson axd 301 project and the
idea where there was if we had about 60
70 programmers in that project so if you
just start off with our like you can
write you could make your own way of
building a client server or you can make
your own way of making it a sort of
rotating log or something like that and
we thought it's not really very good at
60 program has all invent their own way
of building a client-server model so we
said ok so here's sustain bit
client-server model please you know what
everybody kind of go and use this and
here's the standard way of doing errors
and things and we built seven
abstractions for example some provision
trees we build things into trees and
it's a manager work a manager thing you
have a manager he hands out jobs to
workers and if the worker dies the
manager gets informed and can restart
the worker and then we just said okay
there are two types of trees that we
mirror there are independent tasks there
are independent tasks if any one of them
dies it can be restarted independently
and then we got dependent tasks where if
anyone dies it will depend upon each
other so the only thing to do is kill
them all
and restart a more state versus
stateless yeah know who got an trees and
all trees okay one and then we said
something and we realized that well if
something fails and you restart it you
don't want to get into a loop it might
happen that if you restarted a fail for
the same reason again so we added
restart frequencies and things so it
said well if if you've restarted it more
than five times every six minutes or two
times every millisecond or 400 times
every three hours I mean whatever
feel like you put this in and then if
it's if the manager has done that number
of restarts it exceeds up then it itself
dies and then the guy on top of it sort
of a basic rule recursively so finally
if the guy right at the very top dies
he's through no and and these were these
were all very pragmatic I mean when we
started we didn't have these super
vision trees and things we took all that
was a kind of abstraction that's useful
to you and so there's there's a lot of
experience that baked it into them and
there's a lot of products that have been
used building them so if you're starting
your own project and you haven't thought
about it a long time you say wonder well
okay so you see o2b libraries as a first
cast you know it probably better than
the one you would do yourself so it's on
the other hand if you were really expert
at that it's like any I think I noticed
the part about using an abstraction is
you need to know what is being
abstracted and if you if you ever lose
that if you ever go back and say well
I'm using an abstraction but I don't
know what it is that they've abstracted
then you're screwed right and
unfortunate I think we are getting
people are just using abstractions
pulling them off the shelf and using
them but they don't know what it is that
we have abstracted and then if it
doesn't work exactly how they thought
and they have to tinker around then they
go into panic you know it's like open up
the black box oh my god do I have to
open it up and see what's inside
and it should you know if we've done a
good job then we will be able to use
these things as black boxes without
opening them up and if we done a bad job
then they won't so what was it what does
it take for an average C C++ Java
developer to basically adopt and start
working with or lying on a project and
even consider it
yeah non-magic howard is narrowing book
go to that you know turn it out in a
chapter woman start talking the project
I mean that's the only way god there's
no she didn't delonix and carve is steep
or or college compared to other
languages I mean the whole program
you know you're always gonna have it's I
I noticed a shadow just years ago I gave
four prologue course yeah and I was
teaching prologue and we had
question-and-answer sessions and I
decided I would I deliberately wouldn't
solve any of the you know I wouldn't be
like hand out the teachers answers so I
would do them in front of their eyes and
so I was trying to solve these problems
in front of their eyes live coding stuff
and one of the students said something
which I thought was very interesting he
said you make exactly the same mistakes
as I make I mean in logical thinking
uh-huh he says but but it's very
encouraging watching you because what I
noticed that you do is you correct them
much quicker and I noticed that so once
you're good at a language you you you
you you see the errors and you correct
them very quickly
doesn't mean you say you don't make all
the same mistakes have the beginners
don't really see that yeah they they
sort of autistic crashes I mean when I'm
riding air like whoops it crash if I
just meant that correctly quickly that's
just experience but I still make the
same algorithm to get worse as everybody
else does so I don't think I don't think
programming is the difficult bit is is
actually not in learning the language or
its semantics that's pretty
straightforward
it's in knowing the library structures
knowing which libraries to call it and
that's the same in any language we look
at some lights mortal you can known
small talking in afternoon the syntax is
really easy but it takes you like three
months before your head can sort of take
you know which classes are important
it's basically about wrapping your mind
in a new way of thinking about it's also
I mean I talked down angle for that
small talk and say you know can you tell
me which are the important objects in
small talk and he says well it's object
in something that's 45 I mean when when
OTP starts it loads in 62 modules or
something only about four of them
informed you know error handler near to
code I wrote these quite a bit of that
stuff you know so so I know but what
happens if you're a beginner
start it 67 modules come in yeah I got
where do I start looking yes it's
difficult but that's the true in any
language yeah or any system for another
yeah
so i-i've one of my slides of I'm and
talk about this earth this week is about
the complexity of system from what we
can do about it so it's kind of
formulating Lourdes Joe's law was was
the second or third language but all
frameworks grow in complexity to the
point where nobody can use them anymore
that's sure it is you look at these you
know things like Xcode didn't Oh God
they've become beasts another thing
people know I'm not particularly
executor be just it's mostly about it's
just the complexity there and that in
the ambit you said you know have you
read these books on pro my Stevens you
know network programming and TTP no
straight to volume tunes like what
Stevens stated in his book them but I
tried to do my books is is actually
describes small fragments of code you
describing evenly demons you know
there's so five lines of code you know
what you when you glue them together in
different orders right beautiful
software it's like learning cookies
cooking you need to note you know what
salt and sugar what it does to the
flavor of something so same thing for
programming you need to know what these
do but if you're in a hurry you just
Google how do I do this
or you spend behind your woof yeah and
you cut and paste ten lines ago without
understanding what it means
yeah I mean you can see the the kind of
more popular languages the worse the
examples are if you if you I mean not
that I wished but I'm good to be nasty
back PHP but if you look at the that's
not PHP but the examples you see are
terribly formatted
you know they're not really limited you
know they're just kind of cut and paste
me see you know when you start seeing
code that's badly formatted which is out
of context and downright wrong you know
then you know you're becoming popular so
beginning to see that
I think JavaScript is is that level
right now sir javascript is very
I sort of have a love/hate relationship
with jobs lots of people do
I think that's I mean the lack of a
concurrency model is I was writing some
JavaScript just before I came you know
and I thought my god you can't do
synchronous i/o you've got to go read
this and when the read is finished go do
this and when the thing is that so how
the heck if you've got if you think you
don't have processes all the concurrency
has to be put into one thread god knows
what you do if you get an error you know
how do you want wine how do you sort of
uh new tagging all this swinger this
spaghetti stuff yeah I mean it's like
this this I think it's rather funny
because you know some like jQuery you
you see if if you it looks very easy it
looks very nice because you say okay so
I've got a dear vidura div a on click
execute that function hi that's really
easy to understand and click do that
yeah that's really easy does it but the
consequences of putting lots of these
all together become something that's not
easy to understand so you see there's a
relationship between the primitive
things in a language and and the
constructions that you can build in a
complex thing if those primitive it's
not apparent that if you choose the
primitive things incorrectly the big
thing will be difficult to understand
now of course this doesn't hit you in
the face of any building something
that's very simple right but it does get
you in the face when you're building
something complicated right so so so
they say you know like in you know sort
of joking this well you know in PHP or
something it's really easy to do simple
things and it's impossible to do
difficult things or it's very difficult
you say an airline well it's kind of
difficult to do easy things but it's
kind of possible to be really
complicated things you got it so instead
I told for the right job a truck and I
would never recommend using airline food
for something with inappropriate I mean
it's good well it was designed to be
good at which is like most technologies
so so what are your hopes personal hopes
for the language well you see it I'm
going I mean I'm just kind of surprised
it's still there
give it up years ago I didn't oh just
like to influence software
I think it'll whether it's still being
used in 20 years time affiliates done I
have no idea I think it'll be one of
those languages which has influenced a
lot of languages
like small talk yes they needed the
small talk was they sort of had
influence it'll flow thinking that came
after it I think I'm quite pleased
airline has influenced how people think
but I think they haven't got it yet you
see one of the one of the things I go on
about is it accidental an inherent
complexity so accidental complexity is
complexity that comes from the way
you've decided to solve the problem an
inherent complexity that's just the
complexities in the problem itself so if
you have a parallel problem and you
write it in a sequential language then
you introduce accidental complexity now
people don't realize that because if you
it suppose you've got a parallel problem
and you you solve in C++ you're going to
use possibly operating system processing
you semaphores and new texas and a
message channel or something for that to
solve it and SMS Oh make your head hurts
you know as soon as it gets complicated
it's really you know there's horrible
stuff and then you say well okay let's
try and do it in Java but wait a moment
you've got the same abstractions you've
still got synchronized methods and
you've still got mutexes and you've
still so it's a mess as well and then
you write hey let's do it in Ruby okay
so we got synchronized methods and so so
then you say oh all this parallel
programming stuff is tricky everywhere
but it's not those are all accidental
complexities if you do it now hangs
really easy right but you've got to
think differently yeah yeah I can see
that okay and if I'm going to start I'm
giving people from lambda you're not if
you're going to go to lambda jam in in
Chicago don't turn your I've got the
start of my lambda jam lecture where I
play them I'm gonna play the start of
Marla's fifth symphony uh-huh you know
and show the score because this is a
parallel program you know
it's got 16 instruments playing in
parallel so the score is shown this is a
parallel program in the musical score
you've only got the trumpets and the
violins it's also a fault-tolerant score
because you've got the first violin it's
not one violin is ten Lila it's all
playing at once
can you imagine what music would be like
if it was sequential can you imagine
Marla you know how do you write his
symphonies would you go to a concert
where they play all the drums for it
all the Tim you wouldn't write you know
we're losing when you try and describe
things that should be described in
parallel like music in a sequential
language you introduce all this
complexity you
it just becomes impossibly difficult
don't you take a webserver Apache or
something like that says okay the
operating system thinks I've got one
process with 10,000 pieces and Aling web
server isn't acting like that it looks
the same but the abstraction so I've got
10,000 web servers so I mean if you're
thinking about a website in LA so you
use cowboy or something for that people
don't get this you see really as I see
these cowboy system I'm thinking my
machines running ten thousand web
service right but you see they don't see
the difference they just see the
external behavior if it's controlling
ten thousand things actually you look at
it in detail it is actually 10:30 if if
we're an operating system we would see
10,000 little processes inside ailing
you see 10,000 little processes all
independent and that means if it's an
error in any one of them it doesn't
affect the rest look inside Apache it's
not like that
the operating systems one big process
inside Apache one big process and that's
why you only say a PHP plug-in it has to
spawn an operating system process to do
that and that's a very expensive process
I mean operating systems don't handle
thousands of processes they handle a few
hundreds yeah another day hundreds
thousands even tens of thousands were a
bit shaky millions forget it
yeah and so that's what the games
through the longer a games people were
giving a talk about hairlike and they
suddenly said hey wait a moment
the current model they had there was a
we've got the user session and the games
aid is in a database
every time a user does something in the
game they've got to go access the
database so the database became a
bottleneck now wait a mo most of this is
just state data just belong to that game
no other game keep it a memory keeper
didn't the process associated with that
game that's exactly what we would do is
would the telephony transept exactly
it's no different to a telephone call
you know when when I pick up my mobile
and I call somebody else all the
transient state of that in the Ericsson
exchange it's that so that's an
oppressive not database it's not a very
based on disk or something like that
it's in memory you know in a memory
protected region and it's so much faster
that way yeah yeah well thank you so
much for your feedback on on our link
we're glad to have you here in San
Francisco thank you Bob and I hope you
enjoy the airwick factory I just make
sure I'll see you there
yes thank you okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>