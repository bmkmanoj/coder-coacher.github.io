<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stop Using Native HTML5! | Coder Coacher - Coaching Coders</title><meta content="Stop Using Native HTML5! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Stop Using Native HTML5!</b></h2><h5 class="post__date">2012-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uQB4Y7wR51M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name's Kyle Simpson I'm get a PHY
everywhere online github and Twitter and
all the other places that matter so you
can find me there then a number of open
source projects lab j/s is a script
loader that came out a while ago it's
not entirely irrelevant but it was
important for a while so you can check
that out I've also been recently working
a lot in the area of templating I feel
very strongly and passionately about
this and so I've got a templating engine
called grips that I've just kind of
finished and put out there so you're
welcome to take a look at that that's
also on my github you can get the links
to that from there down at the bottom in
the red you'll see links to the slides
that's the part in red is the only part
that you actually have to type into to
get the slides for today there'll also
be some code I'll give that URL in a
minute in a minute but anyway we're
gonna jump in and we're going to talk
about native html5 and why I think you
should stop using it and so let me just
fully say that I understand this title
is entirely linkbait some of you
probably came because you were excited
that I was going to tell you why Mark
Zuckerberg doesn't want to use native
html5 on mobile apps and I'm not going
to talk about that I'm actually gonna
talk about the opposite because I'm
super passionate about javascript and
html5 and kind of a snob about it
actually very excited about this
technology and so we're gonna be talking
about why you should be doing using it
and how you should be doing so
responsibly before I get to that though
let me just do a couple of housecleaning
things I have a book that came out if
you want to have a discount code off be
there that'll give you 50% off of it or
something like that so you're welcome to
grab that if you don't have already have
like 15 other html5 books I will be
writing more in this space to keep an
eye on the HTML quote/unquote 5 space
I'll be writing more about that soon
it's become in vogue for speakers to get
up at conferences especially JavaScript
heavy conferences put a giant slide with
a semicolon on it so they declare where
they
the semicolon debate this is where I
stand on the spaces versus tabs debate
and so if you're interested in where I
stand you can grab this there is
actually a character there but it should
be obvious from my code let me take just
a slight diversion to talk about this
slide this is sort of my Douglas
Crockford iu6 must die slide moment
there's many things that I could have
put in here but I'm now talking about
browser versions and why I think they
need to go away so I believe very
strongly and passionately that our
community our industry has been fed a
lie for 10 or 15 years and that law is
that when we build something using the
web platform technology that that
something should look and act and feel
and behave exactly the same no matter
which browser no matter which version no
matter which settings the user figures
out to set up on their on their system
and that has been the prevailing theme
that clients and boss I've spent the
last dozen years or so in this industry
having clients and bosses tell me it's
got to work you know I had for instance
I had a boss that told me one time that
we could not use rounded corners on a
dialog box even though we wanted to we
were not allowed to use rounded corners
because doing so would have required us
to do the old image fallback for ie6 or
some crap like that so we literally were
not allowed to make anything look cooler
and better in the newer browsers because
we didn't want there to be any kind of
either difference or difference in
technology for the older browsers this
is insane and this is part of what's
holding our industry back I think so the
idea is basically browser versions are
just an arbitrary marketing label they
don't actually mean anything what means
something is feature detection we've had
this really cool concept for a while we
don't use it enough and actually what we
need to do is retrain clients and bosses
from the ground up that that's how the
web works my proof that's how browser
vendors design things they do not design
things to work and act exactly the same
they differentiate we should be
embracing that so enough of that side
note I actually be giving a talk
entitled browser versions must I next
week back here in San Francisco at Jas
everywhere so I just wanted to give a
plug for that okay we're going to talk
about html5
just as a point of trivia how many of
you know what these little symbols below
the html5 logo are anybody know what
those are oh come on now there's eight
separate sort of classes or logos if you
will that define eight separate areas of
html5 technology generally related to
JavaScript I'm just going to refer to
all of this stuff as html5 and friends
the reason being is I don't actually
care which spec body is handling which
particular version of the spec or what
whose umbrella it's under which guy is
you know heading up the group or the
committee or something all that politics
that's crap it doesn't matter what
matters is that we have the technology
we can use it so I'm just going to give
it a friendly label html5 and friends by
the way these four logos they're storage
and performance and graphics and device
api's and those will actually come into
play a little bit later okay so last hmm
I guess back in May I was up here at
html5 Devcon fit was at a different
hotel I think I can't even remember
actually but I gave a talk on html5
JavaScript on crack because anybody at
that talk anybody remember I talked ok
so this will look familiar to you that
that talk the premise of that talk was
here is a game that I wrote the games
called we puzzle it it's a multiplayer
online game where you can go and upload
images it creates these mixed up puzzles
and then you compete against each other
to solve the puzzle as quickly as
possible the whole point of that game
was not to show off how awesome of a
game designer I am because clearly I am
not clearly and I'm not a graphics
person but it was to show off these
html5 api's woven together into a real
application instead of what you
typically see on the web and in every
html5 book that's ever been written
including mine you just see a bunch of
toy examples that don't actually weave
anything together and it's left as an
exercise to the reader so this talk was
conceived basically to explain here's
how we take these api's and weave them
in together into a real-world
application I bring all this up to say
we're not going to rehash that talk
obviously I'm giving a different talk
but it actually provides a really good
basis for what I'm going to talk about
today because I'm gonna bash my own code
so we're gonna just flashback to some of
the code from that particular talk from
that project if you're interested it's
all open source again you can get
those URLs so this this code here is is
a snippet of the code one I'm dealing
with the storage API how many of you
know about session storage and local
storage okay pretty good number of you
these api's are exactly the same the
only difference between the API is is
how long the data keep is kept around
for session storage it's kept around
only for that tab session and no longer
for local storage is kept around forever
longer than ie6 will be around that data
will be sticking there unless you clean
it up because users are not going to go
into their developer tools and you know
check check on local storage and clear
it out stuff like that so you actually
have to be very careful about the data
that you stick in there make sure you're
not just filling that up and leaving it
there forever
so pretty basic I'm setting an item I'm
getting an item that kind of thing
these api's are not rocket science
they're pretty straightforward and for
the most part they're pretty stable so
there's not a huge problem with this
code but it does start to show you that
you can see that I've got peppered
throughout the code a bunch of different
usages of this API that's going to set
us up for what we're talking about later
some more complex code I'm starting to
deal with the canvas API don't be fooled
by the fact that there's some jQuery
mixed in here if you don't like the
dollar sign you know fine whatever you
can drop in a different library if you
want I use jQuery just because it was
simple or whatever but the bottom line
here is I'm making some calls against
the canvas API to do some operations as
part of this game in this case on the
first line it's kind of hard to see the
line numbers there but on that first
line I'm calling context I draw image so
the canvas has both a parent canvas
object and a context that you draw
within and so you have two different
references and the crazy part about the
canvas API is that some of the calls are
on the context and some of them are on
the main one and you have to keep that
straight so in this case you see the
first line I'm calling draw image
against the context but on the that next
line that you see I'm getting a
reference to the actual canvas objects
it called to data URL so it's a little
bit bizarre about why you know why is
one on one API and one or another I'm
sure there's some reason behind that but
this is another example of when you
start using canvas code across here oh
gosh oh no I know a lot of you probably
are already using a canvas wrapper
if you're if you're grabbing code off of
an open-source project or off of a
tutorial and you're just dropping it
into your code which a lot of us do
you're going to start to see a lot of
this code propagate throughout your
codebase so you're going to start to see
a lot of these crazy canvas calls the
next screen shows you even more some of
the things I hate about the canvas API
so here you can see I'm calling context
over and over and over again context I
begin path draw image that restore
setting some global composite operation
who even knows what that stuff means
right so I'm doing all this stuff
against the canvas API actually think
this is a perfect example of why Douglas
Crockford is wrong about the width
operator in JavaScript we still need the
width operator for crap like this
because I don't really want to actually
write code in production that's got
context dot over and over and over again
this is ugly code it's longer it's
harder to maintain but this is an
example of the code and again I'm sort
of dashing my own Kohner this is an
example of code that I put out there six
months ago I stood up on a stage and
told you guys this is awesome code go
use it and this is code that I wrote
another example this is file reader this
actually gives you local file reading
access you can take when somebody gives
you a reference to an image file instead
of uploading it to the server first and
then grabbing that file back now you can
literally directly read those contents
right away and do something with it like
render the image in the page I use that
a bunch in this game so we have this
line create a new file reader and then
read is data URL pretty straightforward
not a very complex API as most things go
it's getting more complex though as we
start to see like file system and some
other things peppering in you're going
to get more and more complex file
operations but file readers not too bad
but again I have several places already
that file reader shows up this slide
shows drag-and-drop how many of you have
done anything with HTML 5s native
drag-and-drop anybody I bet most of you
had to go out drinking after you wrote
that code because some really hard code
to understand it's kind of crazy this is
an example of code that
have in there where when I'm dragging a
file on Mozilla uses a different mind
type for the file that's being dragged
than the other browsers do so I have to
do some code inspection forking crap to
handle this properly this is the kind of
code that I would end up sprinkling out
throughout a lot of my code and guess
what happens when Firefox comes along
and changes that mime type now a whole
bunch of my code is completely broken
all over the place maybe I can do a find
and replace but that's going to be hard
to find some of that stuff like mime
types like X Moz and stuff like that
further down you can see I'm doing
things like getting the data transfer
object and then setting a drop effect
what's interesting about the drop effect
here is that you might think that what
you're actually doing is affecting how
something behaves when it is dropped but
actually you're affecting how it behaves
before it's dropped so it's kind of a
crazy weird named API that they've got
dragon drops got a whole bunch of
problems so I won't bash on it for too
long but again this is code that I wrote
and put out there and said this is an
example of what's awesome about html5
let's all go and do this let's come back
and see if maybe I was wrong
so I've been kind of hinting at some
things but what is so harmful about this
code what are the problems that this
sort of coding practice leads to firstly
I want to point you to this article
again all you need is the stuff that's
in red appoint you to this article
written by Nicolas Degas I don't know if
you guys know who he is or if you follow
him but he is awesome definitely one of
the smartest guys I know in this
industry goes by slick net on Twitter
you definitely should follow him look at
his talks and stuff he is definitely not
harmful so let me just make sure that's
clear he is not harmful but he wrote
this really good interesting article
that I was a tech editor on and it was
talking about the premise of this
particular talk that I'm giving today so
he's the inspiration behind this talk
and behind the code that I'll be showing
you later some things that are harmful
about writing code like the code I've
been showing you writing code against
these native api's for one thing expects
there are a whole bunch of different
specs and just within the last couple of
weeks it got even worse again because
now we've seen a split where there's w3c
and ian's whatever group is he's got
going on and
and now there's a split again and we've
got different committees dealing with
things remember I said earlier I
actually don't care about any of that
stuff that's because I've actually dealt
with those politics and it sucks dealing
with the politics of who's handling what
and who owns what part of what spec and
things like that is terrible for
developers how many of you have ever
opened up the html5 spec and read
through any substantial portion of it
more than I expected probably you know a
dozen or two of you that's more than I
expected I open it up every single night
it's good night reading right before I
go to bed it's boring it hard is
confusing they do have an HTML
developer's edition that's better but
they're but think that's just one of the
versions of the spec and you can
actually read the the other version of
the spec alongside it and see that they
don't always agree on stuff so then
you're like well now what am I supposed
to do there's all kinds of specs and
it's not going to change the specs are
going to continue to morph themselves
they're going to continue to be polished
politics driving these things so one of
the problems with things is that we have
this duality in our industry and and by
industry I mean the browser vendor
industry with this duality that says
sometimes the browser's just decide to
implement something really cool because
they think we should have it and then
they come back later and get the specs
to codify what they've agreed on and
sometimes they sit around and say no
we're paralyzed we can't do anything
until we have a spec body come along and
tell us exactly what it should look like
letter by letter that's usually because
there's been some infighting behind the
scenes on some mailing lists that we're
not on that shows why WebKit and
Microsoft don't agree on something
so we actually can't really put our
finger on what's gonna happen with this
technology based upon what's happening
in the spec sometimes what the spec says
is where we're going and sometimes the
spec says where we're already been and
so it's kind of hard to figure out and
and I worked for Mozilla for like eight
or nine months and I still couldn't
figure it out so this is hard this is
hard and it's really hard for developers
that don't have skin in this game if
you're not participating on these lists
how are you ever going to keep up with
all the politics and stuff specs make
this hard another example there are just
plain bugs there are simply bugs that
happen all over the place and as
unfortunate it is as it is sometimes
those bugs don't get addressed I
actually found a bug that I was really
bothered by had something to do with the
rounded corners and border-radius and
background clip or something like that I
think and this this bug was actually
affecting a piece of code that I wrote
for one of my clients recently and I
found that this bug had been filed back
in 2009 against WebKit and against
Chrome and it had not been addressed
since 2009 and it seemed like such a
stupid simple thing it's very clear that
it's a bug because the spec is very
clear and how it should behave and yet
they didn't address it and for a while
there was even some hemming and hawing
about whether or not that was a valid
bug to address so this is crazy the way
bugs kind of again some of that politics
the way these bugs play out sometimes
you'll file a bug and it'll be fixed in
like 18 seconds by some WebKit developer
and sometimes it can take years to
address these things so another part of
the problem is that we end up writing a
whole bunch of code to get ourselves
around because our clients not going to
sit around and wait for that bug to get
addressed especially if it's going to
take a really long time prefixes how
many of you enjoy are excited about
writing vendor prefixes either in your
CSS or in your javascript is there
anybody I thought maybe I'd get one or
two like gluttons for punishment but for
the rest of the world this sucks
writing all these vendor prefixes let me
give an example of why it really sucks
there was a library that I was dealing
with I won't name them but they're
really popular so you probably know them
they were going the step of adding
automatically do it you would specify
CSS rule that you wanted to apply and
they would automatically go in and add
in all the vendor prefixes and they were
doing some you know feature tests and
stuff sounds really helpful right except
they neglected to realize that there are
some places where you not only have to
prefix the rule name but you also have
to prefix the value and they were not
pre fixing the value and so in those
cases that was completely borked and
broken and I pointed this out to them
and start talking about this stuff and
then they realized wow this is actually
really hard how do we know in what cases
we're gonna have to prefix the value
that's an even harder level of having to
prefix this stuff so this it's a reality
and I don't care where you stand on the
politics of should we have vendor
prefixes or should we not it's
undeniable that it's pushed a lot of
Technology out there fast and it's
gotten a lot of good stuff out there but
you know it does sort of hamper us it
does sort of handcuff us from time to
time
it certainly makes our code harder it's
an argument for why we use things like
sass and less and other things like that
but it's even true in JavaScript we have
vendor prefix thing on a lot of these
API so you have to end the
capitalizations difference you have to
remember if it's Maas request animation
API or WebKit capital are requests in it
it's crazy stuff vendor prefixes are a
reality but they make this really hard
to manage progress progress is a really
good thing but it can also be a really
bad thing and and by that what I mean is
we just found out a couple of weeks ago
that they've changed their mind first
they said that html5 was all that it was
ever going to be and now they've come
around and they said well actually we're
gonna finish html5 the end of 2014 and
that's actually how many seconds from
now it is until the end of 2014 we're
gonna finish HTML 5.0 and then we'll
have HTML 5.1 and so every few weeks
this changes we don't know what it's
called but we're constantly adding in
all this cool stuff so that's the good
side we're constantly adding in all
these new features but then there was
this list of stuff that came out
recently like features that I've
actually written into production apps
that they're not sure if it's gonna make
it into html5 and I'm like it doesn't
matter if it makes it because it's
already in every browser and it's
already in tons of people's code so
again this draw between what's happening
in the real world and what's happening
in the politics of these processes makes
this kind of stuff really hard to deal
with another example I'll pick on canvas
a number of times today so if that hurts
your feelings I'm sorry about that but
verbosity is an example of things that
make coding against these API is really
hard for example requestanimationframe
what a really like it's very descriptive
that's helpful but who on earth once I
mean people alias this stuff all the
time because nobody actually wants to
write requestanimationframe a thousand
times throughout their code and you're
gonna misspell something I for some
reason I always misspell the word
animation something weird with my brain
so I'm gonna misspell it all the time
and I'm gonna miss the capitalization
things like that canvas another example
you have to repeat yourself over and
over again I have this basic theory that
the more times you have to repeat
yourself the more chances there are for
you to screw it up so the more verbose
these api's are the more chain
there are for me to write bad code or
write buggy code sometimes it's easy to
find those and sometimes it's really
hard so what are some answers well the
basic answer that a lot of developers
know in the back of their head but they
have not applied to this particular area
it's the reason why I'm giving this talk
it's the idea of wrapping a very thin
layer of abstraction called a facade
around these api's why do you do that
the reason you do that is because all
those problems that I just talked about
you contain all of the fixing of those
things to one area it's very similar to
why jQuery and in its early days dojo in
its early days they were containing all
of the craziness of cross browser Dom
management into one location so they
were only had to fix bugs once and you
didn't have to go and change your code
whenever they a new browser version came
out or they fixed some new bug that had
been found so it's a similar concept to
that we want to make sure that we give
ourselves a little bit of buffer or a
little bit of space between the code
that we're writing all day every day
throughout all of our code base and this
code that's really susceptible to all
these problems let's give ourselves just
this little safety area this dmz if you
will and that's what we're dealing with
facades so I undertook the idea after
being inspired again by Zaius I
understood the idea that said what we
need is a set of html5 API facades for
all the api's that are there plus all
the dozens more that are coming and
that's actually a pretty daunting list
we'll see that at the end that's a
daunting list of api's that we are going
to have to deal with but we need to
actually have api's on all of that stuff
because every one of them no matter how
stable you think it is xhr has been
around for a really long time guess what
had just changed they added a bunch of
stuff to it so even old stuff that's
really stable is still going to change
it's still subject to change so we need
facades around all these things and I
thought ok I'll write a framework now I
understand fully that when you write a
framework you get into everybody wants
to reinvent everything and I'm actually
the anti framework guy a number of my
talks I get up and say Fran framers a
bad dream works with evil they try to do
too much for you and try to be - Otto
magical and and so forth so so let me
just say I understand that there's a
little bit I renew here in meat and me
saying let's create a singular set of
these API facades
and I want to try to distinguish between
what I would call framework development
and what I'm calling facade development
so let's look a little bit at that first
I love this quote this actually the more
I see this quote the more it permeates
other areas of my life like politics and
religion and all these other things but
definitely inside of coding this this
really informs the way I approach
development perfection is achieved not
when there's nothing left to add but
when there's nothing left to take away
when it's at its simplest the essence of
something that is perfectly essence of
something that's exactly what it should
be no more and no less it's just like
Goldilocks is exactly the right amount
that's what we're going for and I know
that's this mythical thing that sounds
great in theory and it's really hard in
practice but that's what we're going for
with this design so we want not too much
and not too little
with the facades that we're developing
definitely want to make sure that these
things are modular it's really important
that you do not force somebody to
download you know 25 93k worth of code
just because they want to do a Jackson I
know that that was awesome with jQuery
when we came out and everybody just
started loading jQuery but if all you're
doing is HX you're up you're loading a
whole bunch of unnecessary code
thankfully they all of the major
frameworks they're all much more modular
now so that's a good thing but we want
to start from that premise that says no
interdependencies if we can avoid it and
we're going to make sure that you can
choose if I'm only using three of the 50
html5 API I'll just use those modulars
so we'll give you a build tool for this
framework and so forth and we'll let you
choose which modules you need it's okay
to put some sugar into these api's we're
not going to go quite as far and quite
as crazy as creating you know really
complex and esoteric dsls inside of the
language and things like that but I'm
informed by things like chaining in
jQuery I think there's some actually
some really elegant code that that can
produce in used in moderation so
chaining and some other simple sugar
like that maybe combining some
operations there's some value there but
we want to make sure we're doing so in a
very restrained way because the purpose
of the facade is not to show off how
good
we are designing better api's and they
make said again we're not trying to show
off how much better we are than the spec
at designing ap is now I would like to
fancy myself as being okay at that but
I'm that's not the point of this project
so we want to make sure that the sugar
doesn't get in the way it doesn't become
the focus and certainly we don't want
extra weight and code and bloat and
certainly performance problems that bog
things down just because we can make
prettier code out of it so we do want to
do some sugar but not too much oops the
other thing I want to point out is that
in the world of JavaScript there's these
these terms shims and polyfills I'm sure
you guys have heard these things an
example html5 video everybody knows it's
awesome everybody knows it doesn't exist
on a ie 8 and below and so what do we do
we use these really complex media
players that use html5 and then they
fall back to the flash video player and
they try to create you exactly the same
API that's an example of a polyfill or
shim what those things are doing is
taking new functionality that we
currently benefit from and putting it
into places that that functionality does
not currently exist ie the old browsers
the old browsers that are taking forever
to go away and die in a fire so so what
we want to do is make sure that we be
more restrained because the world of
writing polyfills and shims is a world
fraught with all kinds of landmines and
I've actually walked through that world
when I was dealing with script loaders
dealing with lab j/s writing and so
forth trying to make sure that all the
script loading all the weird craziness
that happens there if you're interested
in that you can read there's a whole
bunch of stuff ever written about that
but dealing with old browsers and
dealing with bugs and craziness and
trying to polyfill behavior into old
browsers Eng is really hard and B it's
not something that I should decide how
that works for you I don't want to go
and create a polyfill for you because
the decisions that I make about how that
video experience should happen in the
fallback are my opinions they may not be
your opinions so I'm not going to create
fall backs for you but I will empower
you to go and put in your own fall backs
in your own polyfills and shims on top
of things if you so choose and if you so
choose as I said earlier with browsers
versions maybe you could just leave that
stuff out and just let stuff start to
gradually died away those old plug in
you know fall backs that we used to do
like the fallback for canvas and flash
and all those things maybe we can just
start to let those things die a little
bit this is a really important rule
that's going to inform a whole lot of
things that we do with the design of
these facades we are not going to try to
solve every single piece of every single
API there's a whole bunch of crazy
complexity for instance in canvas like
you know though and you know those
Bezier quadratic curve crap I've never
written Bezier quadratic curve maybe
some of you have but that's an example
of an API that's definitely not in the
80% use case it's definitely one of
those very niche use cases there's no
reason for us to spend our a bunch of
time and effort and create a bunch of
bloat for an API that's way off in those
niche cases so what we're gonna do is
try to identify and this is somewhat
subjective but identify the core area if
you will that is 80% use case and then
the 20% use case will allow you to fall
back to the raw behavior so let me say
that again what we're gonna do is create
a facade that solves or wraps 80% use
case of an API and then those 20% use
cases that are not so common and maybe
are more complicated or more difficult
or more error-prone or even just newer
and there's still a lot of churn
happening with them we'll leave those
things alone for now until such a time
as something like that becomes really
common if people start writing quadratic
Bezier curves all over the place then
maybe we'll put that into the API but
there's a there's actually a reason for
why I want to do it this way because
you'll see if you take a look at the
code I suggest in a moment you'll see
that in the cases where you're falling
back to that old behavior I use they
call it now dunder the underscore
underscore raw is how I expose the
underlying raw API well guess what
happens when you have bugs that show up
in your code what I'm going to do is do
a fine for underscore underscore raw
because it's probably good chance that
it starts there so it makes it actually
easier for you to figure out the places
where you need to go in and inspect your
code that
aren't wrapped by these facades I
mentioned bugs earlier we are going to
try to fix bugs but we are going to
again be restrained in doing so because
bugs can actually take you down a crazy
rabbit trail if you've ever looked at
the jQuery source code you know there's
a whole bunch of things that jQuery is
doing for ie6 that actually bloating and
complicating you know weird stuff about
how attributes versus properties are
handled and and so forth and they're
trying to fix these bugs but then they
end up actually painting themselves into
a corner and making a decision about how
something should work in one particular
case and so you actually end up creating
gotchas for developers
when ie6 is documentation differs from
the way jquery actually normalizes the
behavior of an attribute and property
you've created a foot gun you've created
a landmine that some developer is going
to trip over someday so we want to make
sure if we're going to fix a bug there
needs to be a very clear path it needs
to be clear and obvious that we're
fixing it in a standardized way if we're
getting into sort of arbitrary ways that
we think things should be fixed or you
know polyfilled if you will if we're
getting into that sort of thing we
should walk away from that that's not
the kind of bug that we want to fix with
the facade that's something a higher
level of code can come back and wrap on
top if really necessary same goes for
quarks now there's a fine distinction
between bugs and quirks so I could have
probably just put this on on the same
slide but for example canvas again I'm
picking on canvas canvas has this weird
behavior I don't know if you guys have
ever seen
you know if somebody puts out a blog
post and they draw this really cool
awesome-looking geometric pattern using
canvas and and I got into the habit of
every time I saw one of those I would
open it up in several different browsers
like Chrome Safari and Firefox and so
forth just because I wanted to see that
this was actually happening a lot you'll
notice almost every one of those you'll
open it in two or three browsers and it
looks awesome and then you'll open it in
another browser which is still a very
modern and standards-based browser and
canvas by the way has been around for
more than a decade so we should know
very clearly how canvas should be
working but then it'll be weird there'll
be some crazy line just going diagonally
off the screen like it's the same code
why is it doing that well there's quirks
there because in some cases if you do
not set if you don't move to zero zero
before you draw a line
in some browsers it will assume that you
meant to and in some browsers it won't
is that handled in the spec I don't know
because I don't actually don't care that
much about the canvas spec but in some
cases these things are just quirks were
that it's poorly or under defined and we
don't actually know how it should behave
well in those cases we can actually try
again if we're not creeping too far into
the the proprietary we're deciding how
the world should be if we can fix one of
those quirks like if every single other
browser and every single other
implementation of canvas assumes the
zero zero move and chrome doesn't assume
the zero zero move we can fix that quirk
and I don't have to call it a bug and
then you have to file a bug against it
because they're probably gonna ignore it
for three years but I can smooth out
that court very simple and very easy and
we're not setting too much of a landmine
for ourselves so we do want to make sure
we can smooth out quirks but again being
very restrained in doing so again
picking on canvas but there are other
api's that suffer this to html5
drag-and-drop as one as I mentioned
earlier with the drop effect copy and
all that stuff there are cases where the
API designers for some strangers and I
don't know if they were on some sort of
drug or what but they designed an API
that was opposite of the conceptual
thing that was happening when you called
that API for example inside of canvas
and you've probably seen this whenever
you've gone to any kind of tutorial site
out on the web and you've looked at
something that describes the transforms
that you can do rotating your canvas and
scaling your canvas and so forth and
even in the words that I just use right
there I betrayed exactly what happens on
the web people talk about it as rotating
and scaling your canvas so you think
okay I draw it and then after I've drawn
it then I rotate it and then you start
writing your code and you're saying wait
is it counterclockwise or clockwise
because I can't understand why it
rotates opposite of the way I wanted it
to and the problem is the conceptual
because you're not actually rotating the
canvas you're rotating the coordinate
system before it's drawn and that
creates an opposite effect if you're not
paying attention so when you see all
these tutorials out there and you see
the API for rotating and so forth they
don't make it clear at all nobody makes
it clear that you're actually dealing
with transforming the coordinate system
they talk about transfer
the canvas and that causes developers to
get this stuff backwards all the time so
this is an opportunity where we can fix
those conceptual and make an API that
actually maps to what's happening
another example the state saving state
and and restoring state inside of canvas
how many of you have written much canvas
code and are all familiar with the API
not very many of you okay not surprising
inside of canvas there's a call that you
can make again on the context object
called dot save now how many of you
believe that dot save would do something
like saving out the bitmap data in some
way shape or form like taking a snapshot
of that canvas anybody yeah I I
certainly did for like months I was
writing against this and thinking that
save was like getting a snapshot that's
not what it is
save actually has to deal with saving
the state of what's in your canvas into
a queue into a stack actually and then
you call restore when you want to
restore that state back from this so
there's a conceptual problem here and in
computer science for twenty years or
more we've had a name for this it's
called stack pushing state and popping
state why didn't they call it that I
don't know but this is an example where
it can fix that conceptual we can make
it very clear with the API that what
you're doing is pushing the state and
popping the state and if you know
anything at all about development you'll
understand the concept of pushing and
popping so again very simple changes
that we can make to help clear up some
of the conceptual x' so talk to a whole
lot about some of my design principles
it's ok if you completely disagree with
those design principles that's cool go
start your own project but for my
project let's take a look at some of
this code the code for today if you want
to go and take a look
projects called h5 and this will direct
you to the github repo and you can take
a look at that code but we'll take a
look at several of the api's that have
already started been working on so I
talked about storage earlier I mentioned
that you have the storage API reset
items and get items and delete items and
I said that the primary difference
between the local storage in the system
storage was just how long does that data
stick around this is one of those
examples I think conceptually where we
can make the
API simpler by combining those two into
the same API so that when you
instantiate the API you tell it how long
you want the data to stick around so you
don't see it actually terribly it's
further up in this code and I'm gonna
show you this later at the end of the
talk but when you instantiate an object
here I've called my object session but
when you instantiate it you say I want
it to stick around for the session only
or I want it to stick around for X
number of milliseconds turn to an
expiration date that's something that
the API doesn't directly give you but a
lot of people end up writing their own
wrappers for why not go ahead and codify
that so we've done so and giving you a
way to have very direct and easy control
over how long that data sticks around
hopefully that will lead to more
responsible management of data on the
user end systems I know doesn't seem
like a bad problem but you can actually
start to have some runaway memory usage
conditions in certain browsers if you're
just constantly writing out new keys and
never cleaning those things up so we can
maybe be a little bit more responsible
if we have an API that makes it direct
we can explicitly say how long we want
the data to stick around oh by the way
let me just mention that the way I went
about developing these API so far with
with h5 and the thing that I would
implore the community to help with is I
did what I called example driven
development this is the API that I would
use this was I sat down and said ok an
empty file what would I like for an API
dealing with sessions and dealing with
local storage so or what I would like
for that to look like just created an
API and then I went back and back filled
that with some code to make that work so
we start out with what we want it to
look like and that gives us an
opportunity to examine the problems that
we do want to fix and the ones that we
don't want to fix because they're not
restrained enough so that was the
previous slide was what I wanted to look
like this is just an example of what it
looks like underneath the covers you can
see in this particular example I have
this h5 : data and expires thing that's
my wrapping around the data that you're
storing so that we can provide
expiration dates for it whenever you
read out a value if it's already been
expired it just silently deletes it for
you and returns nothing it's pretty
straightforward this is not rocket
science that I created this concept but
putting it into a nice simple facade
actually helps a lot of people remove
that abstraction from other places in
their code all right let's look at xhr
for a moment
now xhr is an API that has been wrapped
probably a billion times
everybody's written their own I've
written three or four myself I'm not
trying to come along and say I am the
best API designer remember I said that
earlier I'm not trying to show off my
API design skills I just took some cues
from some of the other ones again we
talked about sort of chaining that's
kind of nice and jQuery and it helps us
not to have to repeat the object over
and over so pretty straightforward and
I've got error you know for the error
handler progress and success this API
has a bunch of other stuff that we could
add into it there's a whole bunch of
things that xhr to now does like
handling of uploading of files directly
you can do that you can upload you can
create form data objects and upload
those directly almost exactly like you
had done a normal form post so some
really cool stuff that xhr to now has
and that code is actually really it's
really hard if you go and look look
online right now to try to figure out
how to do that correctly it's actually
really hard to figure that out so be
that's a good candidate for something
that should be wrapped up in this API
definitely need to do more and work with
xhr but you can see the basics are there
right now it's not rocket science as I
said before you can see I'm just calling
xhr dot open and dot set request Center
we're not doing anything really
complicated or or magical here we're
just calling those ap is the way they
were meant to be called but providing a
saner API on top of it and giving
ourselves that sort of buffer of
protection in case something wonky goes
goes wrong canvas okay so I bashed on
canvas for this entire talk here's how I
might approach fixing canvas this is not
again the end-all be-all this isn't
designed to say this is the perfect API
for canvas but a number of the problems
that I complained about with canvas can
be solved chaining does away with the
net the need for all that context dot
are using the width operator you'll
notice that I've got rekked and I'm
providing a parameter called fill that
that's pretty straightforward and simple
conceptual that if I'm drawing a
rectangle I want to draw a solid color
rectangle in canvas you have to do that
as two separate operations you have to
draw the rectangle and then you have to
tell the rectangle to fill why not make
that one operation and in fact why not
make it one operation for you to do both
the filling and the stroking of creating
a border on it it's pretty
straightforward conceptual so this API
allows you to do that
you'll see pop stayed in there I've got
pushed stayed in pomp state again
solving that problem defining segments
and so forth again this is an open
source community project and if you
think I've done a terrible job designing
this API please come in and suggest a
better one but I just started trying to
create something that moves the ball a
little bit forward and gives me a saner
way of working against canvas again some
of the underlying code you'll notice
that there towards the very bottom I'm
just doing I'm calling the context
object and I've got a type of method
that I'm calling against it like our
core line - or whatever and I'm just
applying it and passing in the parameter
so again nothing magical happening this
is another fun one how many of you know
what getusermedia is okay good
get user media is actually one of my my
the api's that I'm most excited about in
all of html5 we actually have direct
access to the webcam and the microphone
from the browser now I think that's
awesome instead of having to rely on all
this crazy weird fallbacks that we had
to deal with flash and so forth and all
the you know floating hovering
transparent buttons and all that other
crap now we have direct access from
JavaScript and it's it couldn't be any
simpler getusermedia we just want to get
a stream of video and then we can attach
it to a video tag or an audio tag or
whatever well we created a very simple
facade because there's not a lot of
complexity here create a very simple
facade where we get the user media we
tell it what kind of string want video
and then we wait for that stream to
finish and then once we have that we can
attach it to a video tag now I did this
on purpose because I don't have a video
module yet but if I had a video module I
wouldn't have to do that document dot
get element by ID crap that I'm doing
there I could just create an instance of
the video module and attach it
I could probably create some really nice
easy ways that you can pass one object
to another without too much
interdependence between the modules and
then again error fall backs are pretty
straightforward
underneath the covers there is actually
some kind of crazy complexity that we do
want to wrap so one of them is all the
nuts vendor prefix thing that's
happening and you can't see that on this
screen I'll show that later but there's
all kinds of weirdness around the vendor
prefixing but you can see here actually
one of the weirdnesses is that G um is
might get user media reference object
that I've you know I've done my
detection against the vendor prefixes
for and then I'm looping through an
option hash and creating a string out of
it or some crazy thing like that why am
i doing that well some browsers require
the parameter to get user media to be a
string that's common delimited and some
of them require an object hash why I
don't know just because they wanted to
screw with us but this is the example
the kind of thing that needs to be
wrapped up in a facade because you
definitely don't want to be doing that
kind of low-level detail code throughout
all of your project and finally
requestanimationframe that's another one
of the modules we've created how many of
you know what requestanimationframe does
more of you could okay so it's the
better set timeout which is sort of the
marketing way of saying it's a it's a
better more performant version of
setting up an asynchronous task to
happen at a very specific interval of
time in this case you don't give it a
number of milliseconds what you do is
you tell the browser I have a set of
tasks that I want to do and I'm telling
you that these tasks have something to
do with changing the visual layout of
the page so what I want you to do
browser is the next time you're about
ready to paint the new page before you
do that call my function so that I can
make some changes before you do that and
that may be 16 milliseconds from now or
32 milliseconds from now or whatever but
on this device the very next time you're
about to draw something to screen do my
stuff first batch it all up together and
make it a nice pretty easy single
efficient operation instead of what
happens now where these kinds of things
can be you know threaded and some of our
batch together and some of them are not
so requestanimationframe actually makes
it's not just about making things run
faster but it's actually making a lot
less stuff have to happen the browser
doesn't have to recalculate it three or
four or fifteen times can just do it
once if you use it properly this is a
great API and there's another sort of
companion one the
ie ten came out with called set
immediate it's got a different set of
used cases but very similar but these
are api's that are we should be using
them across all of our code but you
should not be writing that long
requestanimationframe crop and you
definitely shouldn't be doing it because
as you'll see in just a moment the
vendor prefix thing of this stuff is
horrible but before we go on to that
slide I just want to show this is the
API that I created for it so again I
took an opportunity to fix one of the
conceptual problems of of
requestanimationframe because I'm not
really requesting a frame I think it's a
poorly named API what I'm actually doing
is saying I want you to cue up some
behavior for when the next animation
frame is about ready to paint so I'm
using the cue terminology so I'm cueing
up some functions to happen at certain
times and actually there's another
interesting thing here a lot of people
have not I guess maybe run into this I
run into this in my code all the time
there's the concept of
requestanimationframe which is I want
something to happen at the very next
animation frame but then there are some
cases where you need to have something
happen then and then you need to have
something happen on the next animation
frame after that so you actually need
requestanimationframe and request next
animation frame why for example if
you're making it if you're showing an
element and then having an element slide
along with a transition you can't say
display block and transition at the same
time or guess what will happen it will
just pop up in the new location it
doesn't pop up and move like you want it
to so you have to in one animation frame
show it and in the very next animation
frame as quickly as possible tell it to
go ahead and transition and move itself
so we have Q and Q after to handle that
here's what I'm talking about look at
that vendor prefix incremented ooh that
kind of code to test for these things
but you'll see that in in the second
case for canceled animation frame it's
hard to see off the off the thing but
sometimes in some browsers they called
it canceled animation frame and
sometimes they call that canceled
requestanimationframe why who knows this
is definitely the kind of code that we
want to wrap up okay so what are some of
the things that are left there's
actually a whole bunch of stuff left and
so what I want you to hear from me is a
couple things I really want for help
from the community to make these api's
better and to do some of the stuff I
don't
know about some of these things like
blob URLs I've never used those before
and I don't know how to do some of that
stuff but I know they're developers that
have and I would like help from the
community to develop safe and simple and
sane rapper facades around these api's
but I also want you to this is the
bigger message that I'm getting here I'm
not pitching some project solely what
I'm pitching is the concept that facades
are important and necessary for robust
safe html5 code we say that again they
are necessary for robust html5 code it's
not option if you are writing html5 code
in production right now today I want you
to go home and start using a facade you
can choose to use mine if you'd like or
you can write your own I've shown you
how easy it is to write your own but you
should be wrapping up these abstractions
and using facades don't write another
blog post where you put out there a
whole bunch of native html5 code that
you're using in a whole bunch of code
examples and give people more fodder for
copy and pasting and creating bad code
that's going to hurt our industry that's
going to hold us back it's time that we
get more serious about creating robust
code great question the question is how
do you determine I said members said 80%
versus 20% how do you determine that 80
completely subjective at this point but
that's why I'm asking for the community
to help we need to take a look at what
people are doing what are the common
code patterns and if a case can be made
that something needs to happen in the
API will do so but if the case can be
made that's really kind of a niche
corner case or there's too complex too
much complexity too many landmines then
we'll avoid it great question
yeah so you actually asked two questions
the first one is how do you go about
designing api's and the second one is
how do you avoid the pitfalls that have
already happened with the API designers
first one's a little bit easier because
I've put up some contribution guidelines
if you will I would like for people to
do example driven development so fork
the repository and put up a module where
you are showing nothing but the example
code as you would like for it to work
that's one example of how you can go
about it there's others but you know
that's one example how do we avoid the
pitfalls I think that the community can
be better at this than a committee can
and I know that may be a little bit of a
cop-out but I believe the collective
intelligence the collective experience
that we have just within this room I
think we can design better api's than
some of the browser vendors have come up
with so how do we
those api's we make sure that we keep as
thin as possible as restrained as
possible a smaller surface area for
there to be problems and conflicts as
possible and we make sure that we are
constantly keeping it updated we're
constantly helping do that work for the
betterment of the greater community good
question the question was have I created
any hooks in the library so far that
make it easier for you to provide those
shims and polyfills and fallbacks if you
so choose and I would say the answer to
that is my my goal for the way we
designed these api's is that they are
easily rap about I don't think that
there's a whole lot of need for you to
create in you know deep hooks into these
code if you can make it easily rap level
so my my hope and my goal is that the
people that like to write polyfills and
shims that they could find this code
very easy to wrap around and provide you
know they'll provide their own api's
again I'm not trying to win some kind of
beauty contest about my API it's just
trying to move the ball forward and so I
do think that we can get a lot of that
done by wrapping if there are cases
where we can't and we'll certainly
address that because I'm not trying to
trip people up I do however think that
we should try to avoid some of that
fallback mentality and try to live more
in the present good questions I see
other people filtering in my time is
probably done so thank you guys very
much if you have any questions please
feel free to
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>