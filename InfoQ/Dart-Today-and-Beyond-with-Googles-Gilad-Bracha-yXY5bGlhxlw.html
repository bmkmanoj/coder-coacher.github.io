<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Dart Today and Beyond with Google's Gilad Bracha | Coder Coacher - Coaching Coders</title><meta content="Dart Today and Beyond with Google's Gilad Bracha - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Dart Today and Beyond with Google's Gilad Bracha</b></h2><h5 class="post__date">2012-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXY5bGlhxlw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Gilad bracha and I work for
Google and I'm here to tell you about
dart which I'm sort of hoping you
already heard something about good bad
indifferent at least something and so
dart is a new programming language that
we're working on at Google and we're
doing this because we think web
programming is in desperate need of
improvement we do a modest amount of
such programming at Google and we find
that present methods are costing us a
lot on or rather difficult and so we
embarked on the dark programming
language project to to help improve that
situation now obviously there's more to
it than just programming language
there's tools there's platform there's
libraries there's all kinds of things
but whatever it is language is fairly
central to it and so we want to create a
language that supports what I'd call
civilized programming on the web and if
you wish to infer anything about the
current state and its civilization
you're welcome to do so basically dart
is there to to make it possible to do
web applications that are as good or
better than native applications with as
comparable effort hopefully less effort
current state of affairs every new do
interesting web applications but it's
fairly heroic and it should not be
heroic and so we're trying to create
something that basically makes it easy
and straightforward in a way that's
comparable I mean great applications are
never easy but jumping through insane
hoops is not what you should be doing
you should at least have a tool that is
approximately designed for the purpose
you know you're using it for and so dart
is a language that it's not trying to to
really radically change
the state of Technology in in theory
it's trying to provide you with
something that's workable in practice so
you'll find that it's rather a
familiar-looking language it's it's
designed so that you know most
mainstream developers will not go into
shock seeing it even though I'd argue
that if we had something that put them
into shock it would probably be even
better but I'm sort of in a minority and
from that point of view so yeah
class-based as you'd expect and so
here's of a little piece of dart code as
you can see it isn't very hard to read
we've got a class point it has two
instance variables x and y it has a
constructor there's a bit of sugar there
for the very common situation where all
the constructor is really doing is
taking its parameters and assigning it
to the corresponding instance variables
people do that enough so that there's a
little bit of sugar there we're trying
to make things convenient and cut on
boilerplate without going overboard on
the syntactic sugar which is always a an
issue right every piece of syntactic
sugar you give people results in
requests for more syntactic sugar and
it's a judgment call as to how Ford part
to go but this should be fairly clear
and then we have a method method is name
plus and it takes something and extracts
an x value from it adds it to the
current points x value gets its y value
similarly presumably this is a point but
it really doesn't have to be it could be
anything that has an x and y right and
produces a new point so it basically is
a method for adding points in short you
can look at this and you can get the
idea that this is not going to do
something that'll be very hard for you
to read and understand as it stands but
obviously there's more to that oh so the
other thing is dart is an
object-oriented language it's up which
most languages widely used today are but
it's a purely object-oriented language
that means that everything is an object
which of course has many precedents or
and some some that are fairly widely
used today and some that are catching on
and that has lots of advantages
generally having a uniform model or
makes things easier for everybody for
the programmer and believe it or not is
actually making it easier for the
implementers of
is is run by by my good friend Lars bak
who is the guy who did v8 he's the guy
who did hot spot in Java he's
responsible for much of the high speed
virtual machines that the world is using
today and so there's certainly an
interest in making this perform well and
and there's a lot of expertise on doing
that and having this pure model is
actually a plus so in particular there
are no there's no auto boxing going on
there are no hidden coercion that's a
huge problem in JavaScript by the way in
general is the fact that things get
coerced in different ways and and there
are these these extreme examples where
true becomes false and array is turned
into strings and all these kind of
things and that's a lesson that most of
the world learned oh I'd say 45 years
ago right in the 60s basically there are
a lot of languages that did a lot of
implicit coercion cousin when you think
about it briefly it seems oh yeah that's
a good idea it'll just convert it to
whatever I meant the experience was that
this was an unmitigated disaster and yet
we're back where we were in nineteen
sixty eight or so so dart doesn't do
that everything is an object nothing
ever gets coerced by itself nothing
nothing happens automagically in that
way and rarely needs to be so things are
a lot more predictable and easy to use
another interesting property dart is
optionally typed so what does that mean
you're going to hear more of that term
optionally typed all over because we're
not the only ones doing it it turns out
so optionally typed here's our class
point again but some things happen to it
if you look o chose yellow used to use
red but I learned that projectors don't
like red we have here types on on the
instance variables so we know they're
integers we know that the operator takes
a point and returns a point the plus
operator so what does that do it
basically makes it easier to read it's a
form of documentation that's the main
interest here it's not necessarily about
error checking though it does do that as
well but it's mainly documentation for
you the programmer
and for the machine for the tooling in
particular this program will run just
like the other one does and all kinds of
intermediate States will run to you
don't have to pass the type checker in
order to run a dart program that's very
different from you know you might look
at this and think this is vaguely Java
code but the idea here of optional
typing is that typing is truly optional
it's the type checker in your service
rather than the other way around and
that's that's an approach that you know
as elicited a bit of controversy but we
very strongly believe in it so what this
program will do is exactly what this
code does is exactly what the code I
showed you before without the types the
types do not change behavior ever they
do not introduce hidden cast Soaker or
coercion 'he's they do not affect
overloading and which choice of method
to use they have no semantic effect
there they're primarily so that the code
is more to label that you the programmer
can read it and understand it better and
you know if the implementation can ever
figure out anything more that it could
use this for it can but it has to
preserve the semantics it can't change
what the code does and this is very
different from the type systems used in
something like Java so I've spent hold
talks talking about this but this talk
I'm kind of bored with that so we're
going to give this quick intro of the
highlights of dark and then delve deeper
into a few issues that we're developing
with an eye toward the future so beyond
optional typing single inheritance well
that's not a huge surprise multiple
inheritance is another one of those
things like coercion that got
discredited a long time ago has some
advantages though but overall people
found that it's much more predictable
and easy to deal with when every class
has a single superglass so that's not
very radical and shouldn't surprise
anyone however there are times when this
is a problem which is why we're actually
going to move to mix in based
inheritance I'm not sure if everybody
know here knows what that is but that's
why you know a good section of the talk
will be spent explaining what that is
it's basically a way of keeping the
simplicity of single inheritance both in
the runtime and in the structure but
letting you share code and reuse it
little bit more what else can we say in
terms of buzzwords about dark message
based concurrency right so dart uses a
actor like model we call them isolates
30 you know things with independent
heaps and stacks and they communicate
via message passing so you never have
shared state concurrency you never have
locks you never have deadlocks you know
you know all the good stuff that you
know and love from from the Java world
grabs so that's basically nothing here
is particularly radical but it's it's so
it's a good combination finally mirror
based reflection I'm going to spend some
time on that toward the end of the talk
reflection is what make language it what
makes language is dynamic right it's not
the languages that are really dynamic if
you want to all languages are dynamic in
the sense that they evolve over time
what is dynamic are the programs you
right in the language right those in a
dynamic language you can change that
program can itself change itself over
time and do interesting things and adapt
and that's something that we want to
have at the same time we need to to
control this for purposes of performance
for purposes of security and so we need
a more structured approach that's mirror
based reflection i'll talk a fair amount
about this as we go on so in terms of
what kind of Beast this is in reality we
have two two main implementations of
Dart we have a compiler to compile to
JavaScript and we have a virtual machine
and the virtual machine is a lot nicer
because there we can actually take
advantage of the underlying real machine
which has better primitives for getting
the right semantics getting the right
semantics on top of javascript is really
a challenge because basically the
language often doesn't have the
primitives you want and and it tends to
enforce you know it's it's point of view
on anything that's running on top of
that unless you you do a really really
thorough job of analyze
and a lot of hard compiler work goes
into to making this behave properly on
top of JavaScript but that's crucial
because javascript is everywhere
javascript is in isn't in all the
browsers and while we definitely would
like to see dart VM Xin browsers over
time we don't expect that to happen
overnight and so it's crucial that you
know you can run you can convert it to
JavaScript run it on any modern browser
and so there's there's no barrier to to
deployment and use of dart from that
perspective so on the other hand the
virtual machine is also useful for a
couple of things even now one is of
course on the server you can get better
performance some features will just work
better and you can also take advantage
of it in fact generally people do during
development because one of the problems
with tools that that compile to
JavaScript is that because compiling to
JavaScript is a non-trivial task they
tend to take a fair amount of time if
they're doing anything interesting if
there's semantics deviate in any serious
way from JavaScript and and try to solve
some of the problems you have in
JavaScript then it turns out that you
sit there waiting for a compiler and you
don't want to do that the advantage of
having the dart VM is that we can
actually give you a development
environment with instant to turn around
using vm and then you take that same
program you press a button and choose to
run in JavaScript and see that you know
it runs either way and you can develop
in the browser with the dart VM because
our development environment comes with a
version of Chrome that's been
retrofitted so that it contains a dart
VM and so you can actually test your
working web programs or display HTML all
of that with instant turn around using
dart without going through a long
compile cycle anyway I hope that the
world will eventually become a better
place and and we'll have dart engines in
a lot of places but that's going to take
time and we're not letting it hold us up
at the moment so this is just a picture
of that that same thing basically you
can take dart code and either feed it
into a dart VM or via dart to jsr dart
to JavaScript compiler feed it into
JavaScript and dr. jay s is a pretty
serious beast it's already
the third generation of this compiler
that's been developed and I guess the
past year and a half or so and it it
gives you performance it's very very
similar to to native JavaScript the goal
is essentially a hundred percent of not
not to lose any performance in
compilation it gives you reasonably
small downloads because it does tree
shaking inherently during the
compilation process and puts out
relatively readable JavaScript although
i really think that as we as we move
forward that'll be less of an
interesting concern so uh that's kind of
of just a very short overview of dart in
you know a few minutes and beyond that I
want to talk about some of the things
that we haven't talked about in talks
before there are a lot of overviews of
dart you can get if you if you search
youtube you'll you'll find me and other
is expounding on this in great detail if
you want more more nuts and bolts stuff
can go to our website where we just
announced our m1 release which is a
milestone one that sort of something I
don't know somewhere between an alpha
and beta but it means that we're we're
going to try and steer away from
breaking language changes at this point
and there there's there's videos there's
tutorials there's all kinds of stuff
right so I'm not going to spend a lot of
my time going over that ground again
instead I'll talk about some of the
interesting things that are happening
after the m1 release that will make dart
a better language still so one of them
is mix-ins uh which aren't there yet but
they're going to be in a in a future
milestone at some point before before
this becomes a product we haven't
actually finalized the design though we
we do have a pretty good idea what it
look like a small matter of
implementation but at Google we have
people who are good at that sort of
thing so I expect it all I don't expect
to see many problems we have we have
done mixing based languages before many
times and so it shouldn't be a radical
surprise now I'm not sure everybody here
actually knows what it makes it is so
i'm going to show you here's our old
friend point again now this stuff the
stuff in yellow bold right that is
literally a mixin that's the thing that
follows the class declaration between
curly braces that's the stuff that the
class is adding to its superclass right
that's the Delta the difference between
that and the superclass that's really
what a mixing is it's what that what is
getting added and and you know it's in
tactically you can see it in this
picture and the point of this is that if
you could separate that you could attach
that to multiple class hierarchies and
that can be a really useful thing so if
we want to look at a classical example
of mixing use here is a collection class
well it isn't really a collection class
because it won't fit on a slide but it
is shall we say an extended subset of
darts collection class right and mix in
again will be the stuff in yellow so in
particular the only interesting thing
here is is this map function it's a
classical function on collections right
you give it a function it applies the
function to all the elements in the in
the collection and gives you a new
collection back with the results right
basic building block of functional
programming of object-oriented
programming as well it's been it's been
around in object oriented programs in
Smalltalk up you know 76 or so probably
so it's been around for 36 years and the
problem is that not everything can sit
in the collection hierarchy there are a
lot of collection like things it's a
very useful interface and these pieces
of implementation are very generic and
an independent of a part for the most
part of representation and you'd like to
use them in other hierarchies classical
example are gooeys or for example the
dumb so the Dom has a bunch of stuff
that needs to look like a collection and
behave like a collection in our library
and one way you could do it basically
with the mixin feature is basically mix
in collections because the problem with
these Dom classes is of course that they
have to be part of the Dom hierarchy and
with single inheritance they can't be
part of the Dom hierarchy and the
collection hierarchy at the same time so
what are you going to do you you don't
want to do real multiple inheritance
because then you have you run into a lot
of nasty questions of precedence and you
know conflicts between methods and
things like that what mixing based
inheritance basically preserves a single
inheritance chain but it interjects this
this the functionality of mixing along
the chain so you still have a single
image inheritance chain going in one
path up from your class all the way up
to object but you get more functionality
in there and that's how you can actually
avoid replicating this this code in in
multiple places because that that's
obviously a bad thing because you then
when you maintain it you have to change
it any bug fix you have to if you copy
the code that's a problem if you add
stuff to collection that's a problem
more stuff you have to copy and so forth
of course if it was just this one it
wouldn't be that worthwhile adding a
language construct but of course there
are others and in fact they're about 30
of them I know because I I put that map
thing into our collection library and
discover to my horror how this was set
up so obviously we need to solve that in
a more elegant fashion and that's one of
the things this is a poster child for
mixings it's one of the things we're
going to do we have quite a few other
uses in mind in the library and so we
expect our libraries to change a fair
amount once mix-ins come in so some
caveats and fine print will probably do
this in stages the initial mix-ins will
probably have restrictions about using
fields and all kinds of other stuff and
we will gradually move this in bit by
bit but ultimately our goal is exactly
what i showed you full you know anything
that's in the Delta of the class we
expect to be able to to represent via
mix in and share without replicating
and I think this is a good opportunity
to just to keep people a bit of
background because nowadays people tend
to forget where ideas come from
eventually we end up in ridiculous
patent wars as well over stuff that was
all invented many years ago so mix-ins
originated in Lisp in the
object-oriented dialects of list it was
more or less an idiom that you took
advantage of certain ways of they were
doing things eventually it was
recognized as a language construct I
wrote a paper a long long time ago with
William cook who's now a professor at UT
Austin and if you really want adult you
know deep dive into this it's still out
there and still get cited we implemented
this again many years ago in a small
talk dialect that Lars and I and a few
others worked on called strong talk that
implementation was first time this will
actually put into a virtual machine in
fact it's the only time it's really been
put into a virtual machine all the
implementations you see today are doing
sort of code copying under the covers
and that's kind of unfortunate and
wasteful eventually we'll probably get
the dart VM to do something similar to
what we did in strong talk so that
there's no space overheads to this
either oh you probably you may have
heard of things like traits that's sort
of a lobotomized version of mix-ins with
again restrictions on state and so forth
that has gained some popularity in some
languages you can see a variance of this
idea in ruby and skyline you speak in in
other languages so it's not actually a
radically new idea but you know it's
only starting to hit mainstream I think
at this point next I want to talk a
little bit about the isolates asynchrony
concurrency and so forth as I said we
don't do shared state concurrency or
partly because it's evil and partly
because we're running on the web and you
know we have to compile the JavaScript
so we really can't so that helps keeps
us honest
we built you build your programs out of
isolates there's sort of actor like
things hopefully everybody knows what an
actor is but ultimately this is an
entity with its own logically threat of
control its own heap its own stack and
you can't share anything except by
sending messages and copying things
essentially between these things so you
know it's a bit like for example Erlang
but it's also different right these are
not these things don't block their their
clothes are actually to the original
actor model as proposed back in 1972 bar
Carl Hewitt right that's amazing I mean
people were still programming with the
Bacchus is back then but we're only now
40 years later starting to see this idea
really getting into into real
applications so I so let's communicate
through ports again this is a low-level
plumbing mechanism that lets you you
send messages to a port and the
receiving I so it has a receiver port
that where it gets the message is off of
acts on it and and you may choose to
reply etc so in a way this is this
should be familiar to a lot of people
working with Scala or orange at the
JavaScript world nodejs when you when
you send these messages you get a future
back up and the future is a promise n
chily a promise essentially some result
will be there it's all asynchronous
because this is a completely different
isolate and you can set call backs on
those futures and and have code executes
when when they're actually ready so this
again is not all that radical but having
it you know put into the infrastructure
from day one helps and we intend to to
make that nicer and raise the level of
abstraction exact way we do that we
haven't decided because oh you know
what's what's very clear is that no
Dodge is that that model is far from
perfect what you end up getting is a lot
of nesting of these callbacks on futures
and then you call backs on the resulting
thing and
fourth and it gets a little hard to to
work with it beats threads though it
beats you know shared state and all the
horrible bugs you can get there but it
still gets gets rather tedious fairly
fast so you know if you look at this is
a very very simple example against
something I can fit on a slide assume
you've got these two sources of data
that you call asynchronously one and you
intend to plot them so 11 you're going
to get a list of points from one server
and for the x-axis and a list of points
for the y-axis and to do this you are
actually getting a future back and then
you have to set an exception handler on
the future and then you have to wait on
the future with a callback and when that
callback resolves you have to see if the
other future arrived and future
libraries can make this easier right you
can you can have abstractions that
manage both of these at once but even
here right the nesting is just
syntactically doesn't look good because
these closures inside parameter lists
etc the parentheses kind of multiply it
gets tedious and in real coded it can
get a lot worse so is there anything we
can do about that well we think we can
we're still thinking about this is again
is this is even less this is more
speculative than than the mixing stuff I
talked about because we still haven't
decided on a plan on what constructs we
want to introduce but we're looking at
this because we will really feel that
it's important to to address this issue
and raise the level of abstraction there
so possibilities c-sharp has this thing
called a weight and that involves that
that's that's popular that's kind of
nice and a lot of oils because it lets
you pretend that you're writing
sequential code that's also bad because
it lets you pretend that a writing
sequential code and it isn't and you
know one of the problem with these kind
of illusions that they work great until
they stop working and and then it gets
nasty it's also very complicated
transformation so we we don't know if we
really want to go in that direction
compromises a thing we're looking at
called a sink blocks which is a more
restricted form of this um if you if you
know functional programming you could
think of them as future comprehensions
if you don't just ignore that the
advantage of that is the transformation
it's very local and you you have a much
better handle on what yours you're
getting promised pipelining is a
mechanism where the futures still accept
the method calls so you get a future and
you keep acting on it or they just keep
piling up futures for their results
until something is actually ready this
works nicely until you actually have
control flow or I or something where he
actually really really need the result
and so it's not clear how well this is
going to work for us in a language like
dart which doesn't have first-class
control constructs so these are kind of
things we're looking at here's a again
this example is too simple to really
show off the advantage but this is a one
of these ideas of the async block that
we're talking about where you send off
these two tasks in parallel and then
inside the async block it'll serialize
them it'll wait for the results
essentially and do its thing and you can
set an exception handler very easily on
the whole thing right and in larger
examples is this tends to pay off more
we've looked at for example how the
dart2js compiler which is tens of
thousands of lines of dart code which is
you know opening multiple files and
compiling them and sending off
asynchronous jobs to do that and it
looks like this might help on the other
hand maybe better future libraries will
help enough we're you know this is just
to give you an idea of the sort of
things we're looking at and the fact
that we're we're attuned to this and
we're worrying about it the other thing
is that this thing works through ports
right so you send essentially serialized
data on ports you send these messages
and that again it's like JSON or things
like that lists of lists of primitive
values and things like that oh it's not
necessarily the most attractive way to
do things and it would be much better to
view these actors these isolates as
objects that you basically send a
synchronous method calls on and you can
do that fairly easily
this is again outline of how you can do
it we have we have someone who's
actually working on a more realistic
version of this but basically here we
have a wrapper class the idea is you
send it a port to some ice what you want
to communicate with when you create it
that's what the constructor is doing all
right well you see isolate rapper take
this sin port so it's basically getting
a port in sending in setting its its
send forth field the underbar indicates
that it's private the convention we got
somewhere from python but that we
actually enforce in our libraries and
what it does is it gives you the object
has a no such method method so no such
method is there are similar constructs
in small talk in Ruby basically it's a
handler for what happens when your
object doesn't have a method that was
invoked on it right rather than just you
know dying as a Java object does you can
set a handler that will try to do
something intelligent it basically gets
information about the call or the name
and the arguments it's going to be a
little more elaborate because we have
optional arguments and named arguments
and things but basically you get this
information and you can decide what to
do with it in our case we want to simply
want to send it over the wire to to to
the port right and the port will give us
a future back and that's what we want to
recall on the port will give us a future
and we want to return that so with this
we now have an object that essentially
responds you know to any message any as
you know you send it something with a
message and it will encode it pass it to
a nice let presumably the other side of
this equation is something that picks up
that message translated and uses
reflection to invoke the appropriate
method on on the eye slit give you a
result back eventually and so you up so
you work with objects rather than
worrying about you know lists of stuff
and so forth so it's relatively easy to
do that no such method is a really handy
thing that's you know missing in things
like Java missing in JavaScript though
can with with some pains emulated that's
what our dart2js compiler does for
example but you know it's nice to not
have to worry about this and have a
standard way of doing this thing so that
is you know concludes our whirlwind you
know show lie slits and the rest of the
talk I really wanted to talk about
mirrors because that's one of the things
I really care about so mirror based
reflection again has a significant
history originated in a language called
self where a lot of other things
originated including the kind of you
know modern jits that we see in things
like hot spot though basically the
technology that makes all these
languages fast right comes from their
used it the first class based language
to use it was again the strong
which is a small dog dialect we worked
on eventually in java java book or
reflection does not use mirrors javac or
reflection uses you know the more
classic approach which I'll talk about
in a moment but the Java debugging
interface jdi does use a mirror based
approach as does the annotation
processing tool kit right and they do
that because the classic approach just
breaks down so and of course you see it
now Scala now has as a mirror framework
just came out of some probably six
months ago or so other languages and
we're doing the same in dart now again
caveats this is work in progress we
don't have all this stuff yet and dart
to J's doesn't do this yet the vm does
but you know you can't really bank on
that in the sense that if you wrote an
application using it and the vm you
won't be able to deploy it to javascript
because that's still not there but it
should be over time and again the api is
the details may change so this is more
of a preview but it does actually unlike
the other things i've talked about as
future plans this is already in progress
and i'll be able to demo some of this
for you in a moment so just to make
clear what the difference is so classic
object-oriented reflection as say in
java and of course it doesn't originate
in java almost enough
does it originates in small talk and was
then picked up by the list people and
see loss and so forth but all these
languages have a very very plausible
approach this which is to say you know
I've got an object if I allow you to get
at its class the class is a natural
clearinghouse for all these reflective
queries because really this is where the
data about you know all this stuff is
that it keeps the representation it
knows about what fields I have what
classes I have it cetera it's a natural
place and this is this approach that
people have taken throughout you know
the history of dynamic languages because
the easiest thing to do and in some ways
the simplest and most elegant is simply
to expose your data structures to the
programmer that's what happens your
interpreter or whatever structure you
have in an all language you have the
class you simply throw that out to the
programmer and say here mess with it
you'll be able to do wondrous things
although there's only a slight downside
to this which is that they'll also be
able to do horrible things and the
question is you know how do you balance
this so mirrors are a way of balancing
it mirrors as you can imagine our
objects that reflect other objects if
you don't believe me check out your
bathroom and the beauty of that is like
every problem can be solved with a level
of indirection and mirrors give you a
level of indirection because now I can
control who gets what mirror right it's
a separate object before I had an object
obviously I could call get class on it
the whole reflective thing was there and
and there was no good way to to control
access to it whereas here I actually can
tell you know are you gonna get a mirror
if you don't get a mirror I can make
your program about as dead as a Fortran
program right as completely non
reflective I can I can and that means I
can deploy stuff without reflection if I
want to because I have I'm short of
space or up short of bandwidth which is
what happens on the web right in
embedded situations is more about the
size of the thing you're doing in the
web scenario it's about the size of the
thing you're downloading initially and
things like that so that helps
deployment also helps security because
obvious
i can give you mirrors that won't that
won't do bad stuff I can give you
mirrors that only let you reflect on
yourself and i can give you mirrors that
will not let you reflect on something
else there's all kinds of potential
mechanisms to solve this works well with
distribution as well that was really the
problem for example with java reflection
right because they found while they were
multi-threaded and they found that you
know writing a debugger using reflection
which was one of the initial use cases
fell flat on its face because everything
started a deadlock because they were all
in the same in the same process and so
when they wanted to decided to do out of
process debugging there was this problem
that the core reflection framework in
java just couldn't do that because you
needed these magical class objects that
were only in that vm so you eventually
go to mirrors or separate objects and
you can give different mirror
implementations like proxies and stuff
like that so it solves a whole slew of
issues and that's why more and more
languages are going are using that
framework and in dart in particular we
want the mirrors to allow you to reflect
between isolates right so you would be
able to actually pose reflective queries
to another isolate which means that the
api is is in some places asynchronous
which means that it in some places is a
bit harder to use than it might
otherwise be we're trying to preserve
that property because it does have the
nice thing that anything reflective you
write would actually work in in the
distributed scenario on the other hand
we are trying to structure it so that we
minimize asynchrony so we don't you know
asynchrony so we don't burden you with
this stuff all the time so we're going
to look at this briefly because we
should actually show you some real live
code so this is the dart editor can
people in the back seat us or we can
still kind of
little bit in right and we have this
little program dart programs can be
structured into libraries you don't
necessarily need to declare a library
essentially you can write a script
without a library declaration dart is
designed so that you can get into it
gradually and you don't have to put up a
lot of boilerplate you know to get
started but on the other hand when you
like writing you know substantial code
of software engineering becomes
important so we do have have support for
that so here we have this little library
that just I set up for a demo and the
important part is that we're importing
the mirrors library from you know the
dark core library if we actually zoom
out we can see over here this is dark
mirrors right here this is the the core
library with all kinds of stuff in it
HTML web io isolates JSON support math
etc etc we also have mirrors which is
which is still a work in progress so
we're importing this thing and that'll
let us use the the functionality damier
is obviously in the scope of this little
application and we have again a class
point slightly different a very very
basic last point with two fields that
are just set to zero now we have this
method print fields of object and what
this method does is you give it an
object and it's going to print out the
values of the fields basic introspection
this is this is next to nothing you can
even do this in Java so so we're not
using anything heavy duty yet the way
you do it however with mirrors is a bit
different so reflect ISM is a high top
level function that comes from the
mirrors library right and you give it an
object and it gives you a mirror on that
object an instance mirror instance
mirror as a mirror on a particular
object we have all kinds of mirrors we
have like glass mirrors for looking at
classes if library mirrors for looking
at libraries method mirrors etc for
various purposes we get an instance
mirror on this object now we can get the
class mirror out of that right by doing
essentially OEM type so type is an
access err on
instance mirrors and that'll give us a
class mirror now that we have a class
mirror we can go over this information
and you know loop over and a for loop
and extract the variables right the
class mirror has a method variables
that'll give us a map of names to
variables so it'll basically be
something we can look up the name of any
any field in this class and get a
variable mirror on it calling get values
we get a list of those variable mirrors
back and that's what we're iterating
over in this for loop and with every one
of these we're going to extract its name
we're going to use that name to get the
value of the field out of the original
object so we got the names out of the
class mirror and now we go back to the
object mirror that we started with call
get filled with a field name and that's
going to give us the value back actually
because it's asynchronous it's going to
give us a future for that value and
that's important because we might be
looking at a different eye slit in which
case you know there's no no reason to
believe that it's going to stop
everything it's doing and and pay
attention to us it is is it's not
supposed to do that it just got a
message requesting this which is
somewhere in the message queue so
obviously we're not going to get the
result right away we're going to get a
future we then set a call back on that
that says well when that future is ready
then we're going to get V the actual
value and we're going to print that with
a field name and the value be right and
notice we didn't have to do this
asynchronous stuff on on the other
things because basically the thing is
designed to pull up all this reflective
information on a class once you ask for
a mirror on an object it'll get you the
reflective information for for its
source base so that you don't have to go
every step of the way and keep asking
for for futures and things like that so
once you've done that we should be able
to actually run this thing so we have a
main function every every dart
application basically starts at it's at
its main method main top level function
and if we run it we find that yes it
prints the string and then it called
print fields of object with a new point
and what we found is that point had two
fields x and y and each one of those in
fact i gave us an instance mirror on the
value right a value 0 that's in there
we're actually getting a mirror on that
because the whole mirror system traffics
and mirrors right it's very important
that we do that to preserve those
properties this will work in distributed
settings and we will never be reflecting
on something that that we don't have an
indirection to so that's kind of very
very basic use of mirrors you can as I
said do this in Java let's try and do
something a little bit more elaborate oh
we have time yeah we have a few minutes
oh we're going to construct these
library wrappers which are objects that
are going to reflect on a library
they're going to have a library mirror
in them LMK are you going to give them a
name of a library they're going to ask
the current mirror system which is again
something you get from the mirror
library they're going to ask it for its
libraries which again is a map and again
they're going to look up this library
name in it and we'll get a mirror for
that library back so that's how how this
library wrapper is set up and then what
it does is when anyone that calls it you
know invokes a method on this object it
since it doesn't have any interesting
methods it's going to go to no such
method and I've got to set it up to
print out the name and arguments but
really it's real functionality is that
it is going to call depending on whether
this is a method a Class A a variable
etc it's going to use the mirror system
to actually extract the value and and
give us a mere a result back so we can
actually do this here if we uncomment
this code
comment this out so that it's happy as
you can see the editor is doing its job
complaining about stuff but once we
actually save this this should be happy
again alright and now we should be able
to run this and see what it does so it's
done a whole bunch of things and we
basically gave it a new we asked this
library to called point on it and point
is a class so what we've done is we've
actually returned a class wrapper on
that class over here the arguments would
point and an empty list of arguments
printed that out got an instance of
class wrapper class wrappers a similar
class that we got up here that does the
same thing for classes basically again
obtains a mirror and does no such method
so that you can actually treat the
classes an object and invoke its static
methods as if they were instance methods
so you can abstract over the class pass
it around and and treat it as a real
object and so when you ask the library
for point it gives you that wrapper then
you can call static methods of the class
or what have you doing that and a few
comments on what we're going to do later
this was basically introspection
introspection plus no such method was
just one thing you can't do in Java lets
you already do some interesting things
but obviously you want to be able to do
things like mutate code on the fly oh
and and do you know fixing continue
debugging and all of that the mirror
system should should make that
relatively easy to do in time oh now the
problem is with this stuff is beyond the
fact that we haven't done it yet is that
the web is again such a challenging
environment right what happens when you
minify code right what are you going to
do when you have a string and you look
up a method by string but that method
isn't actually there under that name or
maybe the the tree shaking has actually
eliminated it because your basic code
never called it was only going to be a
reflective call based on say user input
right so it's not actually there now
you could just say okay we use mirrors
and all bets are off we just send you a
big download and we don't worry about
this but that's not likely to be what
you want what you actually want is some
fine grained control over this stuff
right and we have a metadata mechanism
that we plan to use for this so you'll
be able to annotate your coat sanji and
say you know what this method even
though its not being called anywhere
please preserve it so that i can use
reflective functionality on it and that
will you know the the deployment tool
whatever is dart2js or other tools will
look at that annotation information and
that will influence how it packages the
code for you so preserve that stuff so
your reflective calls will work all this
has you know is stuff we're planning to
do to let you do the kind of dynamic
stuff you want to do but do it while
preserving performance security etc if
you want to know more about this stuff
obviously there's you know you can go to
the academic literature and see this
paper on mirrors that i wrote with dave
ungar who did self a few years ago oh
you can read a very short blog post it
kind of gives you the essence of this as
well you can also watch a detailed video
that lecture I gave us a couple years
back that kind of walks you through all
this in great detail and illustrates the
real advantages of mirrors in you know
in less of a world wind fashion finally
again the point of all this is to create
a civilized environment something where
you can do real software engineering
build build really large apps without
you know jumping through through
incredible hoops and dealing with a very
bizarre set of circumstances that the
random evolution of the web has
presented us with and the language is a
key part of that because it supports
tool ability it supports software
engineering and with the dart VM you're
actually going to get better performance
and the advantage of it a language that
that works this way is eventually will
have a much cleaner model for everything
through through good libraries we should
be able to write you know stuff that
works on the server and communicates via
message passing to the client and vice
versa through the isolate mechanism
and not care where that server actually
is Right whether it's a local process or
something not not to have to dance
through all these orifices essentially
that the browser provides so basically
it's all about raising the level of
abstraction back to to something that's
analogous to what you know native code
can do as far as status we had our m1
released today it's all open source
we've been doing open development on
this thing for about a year now every
you know bug reports of every patch
everything is out there in an open
repository and with the mailing list and
forms and it's being followed by by a
core community and if you want to find
out really all the nitty-gritty details
please go to dartlang.org there you'll
find lots of lots of material some of it
more much more detailed and and much
more focused on on your typical web
programming tasks and if you have any
questions I'll take them and if you
could go to the microphone because they
want to record all this stuff so I have
a few questions one regarding the GWT
status versus the dot in Google and the
second question whether you use it
internal and the last question are you
going to do any ramp up regarding the
library like something that you get from
jQuery or other library out there
regarding you I functionality and say ok
so that's a lot of questions so GWT so
GWT is as far as I know alive and well
oh you know there's tons of stuff at
Google that uses it so it still you know
hasn't been thrown under a bus or
anything on the other hand we're focused
on dark and and doing something that's
in our mind better I mean one of the
advantages is that you know because we
have a vm we have a great advantage we
don't have to wait for long compiles dr
j s is a lot faster anyway but it's
really part of that experience with GWT
that is feeding into two
to dart as far as libraries you know
there's a bunch of libraries already all
kinds of people are doing open source
stuff we're focused mainly on core
libraries on basic platform
functionality and you had a question in
the middle but I lost track of it uh
yeah so we do have internal customers
eventually I hope you'll see some of
those results externally right but in
general in Google at Google we don't
comment on on that sort of thing but
yeah we do have we do have people using
it internally hi I know there is a way
to call a javascript from dart but I was
wondering if there was possible to do
the opposite called art from JavaScript
the idea is to be able to implement
something in Dart but still provide an
API in JavaScript so that right so what
you want to take a look at the new
mechanism for talking to two between
them that Vijay has just released its
part of the m1 release there is I think
there's an article on the site that
describes this basically it's a
mechanism for for making it easier for
the two to talk to right there's some
over it and talking to them because
again potentially these could be on
different VMs and and we want to make
sure that that works but it's not nearly
as painful as it was say a few months
ago and would that be supported by a
dart to J's absolutely perfect that's
very much the point yeah I just had a
question about the dart VM that you know
obviously doesn't exist in browsers just
yet but i was wondering does it have an
intermediate form you know obviously you
take dart new trans pilot to javascript
is it something that in the future
possibly that vm would be a common
substrate that people could you know
compile to or is it so it doesn't really
have an intermediate form it works very
much like say v8 does it takes source
code and does its thing with it there is
this notion of snapshots which are a way
of allowing quick startup that works on
the vm and that relies essentially on
on leveraging some of its internal
representation essentially it saves you
the parsing time it has a tokenized
stream and stuff like that but nothing
that I you know is yet a public standard
intermediate representation it's it's
way too early to speculate on that if
the snapshots really caught on its you
could imagine maybe maybe doing
something about that but right now no
okay thank you all right I guess that's
it thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>