<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Javascript Code Analysis with Esprima | Coder Coacher - Coaching Coders</title><meta content="Javascript Code Analysis with Esprima - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Javascript Code Analysis with Esprima</b></h2><h5 class="post__date">2012-12-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ACYZFkvq0Sk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">when you work in a team it's very
important to have the same standard
rules of working and some of this is
pointed in the slide so how many of you
have coding style that you use in your
team standard coding style nobody all
right and robot all right what about the
analysis tools such as Jesslyn and Jason
who who used that how about for example
an active measurement to make sure that
the code doesn't regress so a lot of
unit testing a lot of coverage testing
and so on all right so these are some of
the steps that a team usually take if
you guys want to make sure that the code
is consistent and the code is
high-quality so if you speak about
quality to a lot of engineers there's a
lot of different ways to measure quality
but this is just some of the practical
aspect you don't want to write code that
is ambiguous
you don't write code that's full of
mistakes and of course maintainability
is also very important because you don't
want to have something that you cannot
maintain in the near future so quality
practical aspects can be manifested with
some of these points so speaking about
tools a lot of people says a lot of
experts says oh I don't need an IDE I
can just use my terminal and vim or
whatever editor and then they're happy
with it this is true to some extent but
if you just see my diagrams here on the
left side is the isolines of or the
contour lines of the mistakes so the
lower one is when you see the colder and
then the nice one when you don't have
any problem is when there's the cat over
there so if your skill is very high then
obviously you make less mistake and as
the application grows in complexity you
start to make mistake because no matter
how perfect you are at one point you'll
break down and then start doing
something stupid but if you're you know
average engineer and you're just
startled in the language you're new to
the environment you don't know the API
very well then you tend to start to have
some problems right even when the
application is not very complex so the
propose of the tools is really to reduce
or to change the
lines to be something on the left side
where if you have a high skill then all
the tools would do is to tell you that
hey you tend to make this mistake but
now you're fine and you learn from it
and if you're still new to the
environment you can you can start to
have some meaningful coding quality and
you don't need to get trapped in a
couple of tiptoe mistakes so one of my
philosophy in testing is something I
call multiplayer of defense so basically
instead of trying to solve a problem at
once you put certain protective layers
and and that's typical people develop
application whether it snappy or web
right so for example before you launch
your how many of you guys here use
selenium for cross buster extensive
testing yes before you launch your
selenium based testing you probably want
to see hey is my code correct does it
look okay and you want to do a lot of
smoke testing before you send it to the
cloud or to your extensive QA so with
multiple layers at 1.0 the goal of the
layers in this defense is that the first
one should be the cheapest one to do the
first one should be something that's
built into your workflow and then the
latest stage before you deploy it or
before you ship it to the customers it's
something that's really extensive I'm
going to saw some of the examples in
this presentation so people use tools
because it's boring or it's repetitive
or it's time-consuming if you do it by
hand and this two-way feedback cycle is
very important because sometime we some
time or more often the tool clip as
feedback so most of the time the tools
give you feedback hey you should not do
that or your chest breaks but we also
would like to give feedback to the tools
and I'm gonna show you why that's
important for example in some of the
tools that can analyze your code quality
the way you adjust the tools by you know
changing some dials and some knobs and
then make sure that hey I want this
testing to be done I want to skip this
and this and this if you use Jesslyn or
Jason that's the way you customize the
behavior of the testing to
because you want to match it to whatever
you you have but there is also another
way to give to improve the tools to suit
your workflow which is you give a sample
with the tools and then say hey this is
what I want and then make sure you test
it to the things that I want I have an
example for that so in my opinion the
state of our JavaScript tools right now
is like a spelling checker so if you see
the sentence nothing is wrong with
respect to spelling but dramatically
doesn't remake sense and this is
something that we need to fix in the
next year 2013 so the tools needs we
have a much richer understanding of your
semantics much less than the saying of
your program as an example if you see
this simple snippet of backbone you
define a new road but our router but
because of a typo there
it won't work at runtime this is
something that typical static analysis
this they cannot understand because it
doesn't have the understanding of the
convention that you used in your
application area framework so because
javascript is it's very dynamic you can
do whatever you want somebody can do
something behind your back it's also
very important to both in some some of
the Convention rules now of course some
of you might say but it will not catch
all the problems that doesn't matter
because of the multiplayer defense so
you want to have a first layer of sanity
check that sort of catch all the most
cases all the most common problems that
a team usually make so some of the
basics before we go into a nice analysis
so when JavaScript runs in the browser
just keep engine is just one of the
components you would know about you know
the rendering engine itself such as
WebKit and gecko and they are
responsible for taking the contents of
the webpage and then the sounds on then
create something that's just in screen
basically pixels from your monitor and
there's also networking obviously
because you need to fetch data of the
remote server and if you zoom in
javascript engine basically consists of
this blocks it will consume your coal
and then parse it that's responsible if
the parser the property outcome of the
processor is it's in syntax 3 and then
it will run in
something called virtual machine no
interpreter some of the standard objects
if you use JavaScript string map there
are additional there are runtime objects
and that has to come into the virtual
machine as well
now if you want to try to understand how
your program behaves obviously you need
to implement everything but if you just
want to have a semantic understanding of
the program the parcel will be more than
enough so first step of the parser is to
break your code into tokens in this
examples the the tokenization stage
basically spits down your code so that
it knows that hey this is a keyword this
is an ID fire this number and so on
once you get that it will try to build a
syntax tree and this is basically what
JavaScript engine also does when it
consumes your program syntax tree means
that it's a tree that will present your
syntax in this case it's a verbal
declaration and then get and failure so
and then the values so now once you have
the syntax tree of the entire program
you have all the information necessary
to understand what the program is trying
to do and of course if you want to
implement a junky parser one of the
strictest requirement is that it has to
follow a standard so it has to
understand all the contract that is
defined in the ACMA script specification
how many of you here have ever we echo
script specification it's only 250 eight
pages most people don't need to do that
because I mean you don't learn how to
write an articles by reading a
dictionary or something about but is it
very important to try to make sure that
your code or your parser understand all
the constructs that are specified in
that standards that's includes strict
mode that includes semicolon automatic
semicolon insertion that's also included
unicode and in some cases the syntax
tree that's produced by the parser needs
to have some some some sense so it
should not be completely cryptic one
thing that I implement in esprima is
following the parser API that's
specified by Mozilla
in its JavaScript engine SpiderMonkey so
if you see this very simple line of code
the syntax tree
formatted as jason will look like
and from this you can totally understand
that oh there's an expression there it
declares or it defines in a literal 42
and assign it to a variable call answer
if you want to try it life you can go to
that URL and then you can paste your
code and then it will give you the same
Factory the nice thing about the syntax
tree like this is because it matched the
specification it matches the the grammar
does define the specification and source
code looks like like that well so if we
see the specification definition for a
while statement it looks like that
well then expression in practice and
then statement and if you write an
example program like that and then put
it in the parser demo what will you get
is the tree that looks like on the right
side so it's really similar it's use the
same terminologies and the actual code
that parses this world segment
looks like this this is part of the
parser so having all the specification
the parcel code and the syntax tree they
all use the same terminology really
helps because then it's easier to cross
them cross reference all of this one of
the things that very nice with
SpiderMonkey partial api is the location
information so if you create the syntax
tree you can you can tag location
information that correspond to the
actual tokens in your source code sorry
it's like this you have this impact tree
from the range field there are 0 to 6 I
know that if I want to find that
identifier all I need to do is to go to
the original source code and do it from
location 0 2 exclusive 6 and the same
with literals and so on we're gonna see
why this is very useful if we try to
parse something that is confirmed that's
read possible however sometimes you want
to build a parcel that's suitable for ID
IDE or an editor and in that case you
should make user makes mistakes so
sometimes you want to have behavior that
occurs error tolerance so if you type
using wrong quotes
opening and closing quotes they don't
match
or you put too many dots or stray
characters there or you haven't finished
typing or you do something that doesn't
follow the specification in some cases
the parcel needs to be able to cope with
the situation and doesn't just bail out
and say hello your code is completely
bogus I don't want to do it I don't want
to parse it comments handling is
extremely important for source code how
many of you here generate API source
code or application sort through the
code annotation there's like tools Jess
dock and Jess duck and a lot of other
documentation tools that extracts the
the comments and then probably formatted
as markdown and then producing HTML file
that represent what the code is trying
to do so in some cases construct
contracts can be defined as comments
well because it would be ignored by the
JavaScript engine but you can go tools
that analyze that contracts and then see
if that contracts is fulfilled now
forward looking how many of you here
follow Ahmed skip six that's the next
generation of ECMO scripts right now
we're at 4.1 and the new standard will
define a lot of construct that can be
very beneficial for application
developers everything from the
structuring model classes and block
scope and so on I can talk for another
hour bodies but let's just keep that
code regeneration if you take your code
and then you get the syntax tree and
then you regenerate again the code
that's something that called cultural
generations and then a lot of things you
can do with this how many of you here
minified your JavaScript before you
deploy it you seeing what closer to
Impaler and ugly file jess is not a
popular choice so what did what this
tool does is take your code and then get
the syntax tree and then rewrite it so
that during the execution it still
behaves the same but the actual
generated source will be smaller than
the origin one that's called unification
sometimes it change variable name so
instead of very long descriptive
variable it
Chansey to say a because for for browser
and for JavaScript engine it doesn't
really matter how your variable is
called as long as it's consistent and
say every move code because closer to
compiler for example can remove code
that you don't need or you never call
and this is this is something that is
done through code regeneration now let's
see some of the tools that we can have
if we already build some of the
foundation so I usually categorize all
the tools into four groups code
inspection and static analysis dynamic
analysis and then kind of code
transformation let's see the first thing
inspection so obviously what you can do
is when you have code plug it into this
parser demo you'll get the syntax tree
so for this particular example maybe
it's obvious right even without seeing
the syntax tree you kind of understand
what this code is trying to do but some
cases they're like cryptic code that why
it will return ten in this case and then
of course you can just run it in your
browser or console or node.js or
whatever jobs get interpreter but if you
want to try to understand what the
browser or JavaScript engine understand
from this particular contract then you
can put it in a parser and then see the
output so in this case apparently all
that curly braces block is just defining
a new expression segment that doesn't
affect anything you can also validate
the syntax because a fateful parser will
will tell you if your code is bogus or
in volume so there's a nice demo there
if you want to try life in your browser
you just paste your code and it will
tell you what's wrong with your code
so I've seen syntax validation can be
put in in your continuous integration
system how many of you use Jenkins team
CD
there's also cruise control
and then Hudson and etc so before like I
mentioned in the earlier slide
multi-layer of defense before you even
deploy your apps or running through
extensive QA you might want to check
whether the syntax is valid or not
because it would be really stupid to try
to test some application that is not
valid so a linter is slightly different
than a validator famously interest just
they know Jason's because a linter tries
very hard to make sure that you're not
doing something stupid
where's the validator is just hey if you
pass the validator then the JavaScript
engine will be happy and consume it or
execute the code and sometime winter is
very restrictive in the way you write
the code because if you try to pass a
code that is already minified by a brief
IGS or closer compiler or
CoffeeScript anyone use coffee coffee
strip here
if you pass generated code to a linter
then most likely will complain because
it doesn't follow a good practice in
coding but that code is totally valid so
it will pass the validator value little
easily because technically your browser
can still understand and execute that
code so there are different use cases
validator is fantastic if you put it in
your development workflow how many of
you here use get and use get pre-commit
hook so get freaking my talk is a hook
that gets executed before during your
commit and if it returns nonzero it
block your commits from happening and
this is a perfect chance to inject any
kind of syntax validation because if you
commit something if you try to commit
something and it doesn't pass the
validation it will just exit with one
error code and there won't be anything
committed your working directory will be
dirty so nothing will get committed so
you can even prevent bad code to enter
your source code source code repository
because it will be blocked by the quick
method that's another protective layer
and your multi-layer defense in a
typical IDE
whether it's cloud based or running on
the browser from local server it's
possible to get understanding of your
code by parsing it and then extracting
the information out of the syntax tree
for example for the case of Eclipse
Orion it will be able to display all the
function outline this is a standard
feature in typical smart ID like web
song and the way it works it's really
part of your code and then see for a
function variable from function
variables just look for all the function
declaration and function expression and
deduce the name and then it's placed
there anyone here use eclipse or ion
yeah it is a basically cloud-based
JavaScript editing you can run it in
your browser
so autocomplete is often very useful
because then you don't need to memorize
remember all the function names and
function part variables because
sometimes is very long and again the way
it works is if you already have this
information all the variables name or
the functions then it's made of trying
to match what they hear what the easier
is trying to tie up with whatever choice
available for about particular
situations this is where this is the the
case where error tolerant behavior can
be religious useful because as seen in
my screenshot here
I haven't finished typing anything yet
and that could be just invalid but the
parser needs to see the page the user
hasn't finished anything so it might be
invalid so if something is wrong just
continue ignore it there's another
editor from VMware's last spring source
called scripted oh not really physical
in the slides but index there is
highlighted and then I can see all the
occurrence of of all the variables
they're very useful for code editing
because sometimes you have a function
and then you want to start where the
function arguments is being used life
editing how many of you here have seen
bread Victor's talked about yes talk
about programming and some of this
feature have been implemented in Khan
Academy computer science corner have you
ever seen life editing of JavaScript
code in Khan Academy that's very
impressive
so in this small simple project all
scrummy is probably doing sir
so what when you type a code here every
literal or every constant will be will
be editable like life so I can just drag
this change the song I can change the
color
this is possible because scrubby
rewrites your application code and
change all the literal Stooges and
variables and then as you drag the value
it replaces the value of the variables
and then the code once again taking the
value of the variables so if you want to
experiment with you know certain
prototyping particularly useful when you
draw something you don't need to keep
typing your code and then life you load
your browser or do something else
you can also get some nice statistics of
how certain particular keywords use in
in your code this is not really useful
it's just to give a nice understanding
of the distribution of the popular
keywords upon me I've done this through
two major libraries and seems that this
is the most popular keyword and then
function and if in return it gives you a
nice idea as well for example if the
number of try and catch they don't match
then something is suspicious there
because try supposed to fall be followed
by catch same if case is it's less than
switch then out of this you can happen
so it's probably possible you can check
also the statement so most statements
Jerrica statement is typically
expressional so you assign the values of
some expression to a variables and of
course block statement you can also see
how disability or identifier or variable
names so if if it's very high means that
your code is very long or for both for
example the longest identified that I
can find was in prototype 1.7 it was
really long but from many major
libraries upon me the the mean of
identifier lines is about eight
characters of course there's tons of
things that you can infer from your code
after you get the syntax tree and then
analyze everything's everything from
common density so you can measure like
how many lines of commons can put how
many lines of code because if it's like
zero then your code is totally not
commented that all that's kind of scary
so that's the way tools can inspect your
code and report something quickly but
there also something called static
analysis this is the job that is usually
kind out by jasmine and yes him and code
linting is very popular for example if
your coding style Mendez that you should
never have ever use double equal you
should always use trick equals then you
can do some testing by yourself this way
because all you need to do is well
literally just this 10 lines of code the
parser code and then look for that
particular usage of this double equal
operator and then you can do some you
can display some warning you can also
find boolean traps this is one of my
favorite API Hall of shames can anyone
tell me or guess what will the last line
at the first line that means I mean
false why do I want to put foster any
guess so apparently a slider component
can be horizontal or vertical so the way
you decided if you put true then it will
be this and you put false that will be
the other way one I guess it makes sense
because you haven't seen any diagonal
slider right so there can be only two
choices it's either true or false but
this is a an example of boolean trap
where when you write the code you can
look up a behavior talks and see exactly
oh I want it to be horizontal and the
front put true but when someone refuse
your code or you yourself in 3 months
look at the look again your code and see
what it's actually foster you need to
look you need to search the
documentation and see why is it why did
I choose Club false there is nothing
especially difficult for a non-native
speaker
why would I say components have hidden
false why cannot just say set feasible
true or like said if filter is not case
insensitive does that mean lower case a
equals capital a you will need a few
seconds to realize that oh this is
actually what it does so double negative
can be filtered because you can scan the
code and see some particular keywords
that triggers checkers that behavior
these are all taken from real-world
examples I'm not just making this up
this is one of the one of the biggest
offense is like three items tested true
or false
what does what does it mean why why do I
need to pass two completely opposite
boolean values there so if you look at
the dogs upon me the first is the actual
state with this collapsing or expanding
and the second value defines whether you
want
to be animated or not so in this case I
don't want it to be animated so that's
why I put false but if someone just
stumbled upon the code and then see Oh
what is this it's confusing without
looking the dogs of course the biggest
often still dumb API because if anyone
can tell me what that's true
what's that mean so there's a bunch of
boolean values and variables and other
literals that it's impossible to guess
what this means unless you look at that
documentation so all of this can be
inspected or track easily because it's
rather possible to write code that you
know Co is in fact you can you can just
use the one that I've posted my blog
post look for you know wouldn't litter
all that surface a function for function
arguments or look for words that is
listed in the black list of w- and so on
ternary conditional how many of you
likes to nest all the ternary
conditional flex across that yeah this
is something beautiful because the
example that given here is not too bad
because you can totally follow the logic
and make sense if you dumb the syntax
tree it looks like this and you can just
detect the use of a nested ternary
conditional by seeing which node gets
which one so follow either from the
child to the top or from the parent to
the bottom so if you're coding Sam
Mendes that never ever nest more than
two then you could totally detect that
and then get some warnings a nested
ternary conditional is nice but it's
horrible to debug strict mode check how
many of you use use strict mode always
just take one yes
for those who haven't please do as
there's a lot of goodies there there's a
lot of things that string one can do to
prevent mistakes and in this case is
sometimes you forgot that they already
declare a property name the name equals
to something that you have declared
before in this case is not too bad
because it's like four lines but if you
write back one applique
although all the way to the end you
defined the function that might just you
know be the same with the one that you
define perfect declare at the beginning
of the source line so duplicate property
is not allowed in Sigma if you run this
code in the browser it will immediately
refuse that of course you can run this
through some analysis so a typo can have
a very bad impact if you strict notice
this is called previously because then
you list global what you declare is not
the same as what you use and you can use
a very nice command-line tools that
detects that kind of usage or that kind
of mistakes of course the same mistake
has and the problem we're variable the
high does not actually use and again
it's it's rather tedious to find all
these unused variables manually you
might want to use some tools that scans
for all variable declaration and see
whether it's actually used to know code
complexity how many of you are familiar
with cyclomatic complexity so cyclomatic
complexity is one of the code metrics
that describe how complicated your code
is and in this case oh you can use JS
complexity Dork that's an online tool
you can paste your code and it tells you
maintainable index and logical line of
code I think in this case because
technically you need to break it down to
four lines and not put everything in one
line and then the complexity for this
case I believe because it has four edges
four statements and then for four notes
and then four statements and then we
have one terminals because it doesn't go
anywhere else it has to follow through
all the branches to be n so if the
number goes high and high every time
someone checks in the code you might
want to say something stronger I don't
know anything about maintainable index
so probably look look it up in Wikipedia
so dynamic analysis so static analysis
works by reading your code and then try
to do
Douce what you're trying to do and then
see if there is super stupid and then
warn you about that dynamic analysis
different dynamics this means that it
has to run your code and then see what
happens there
so coverage how many of you here once
your code through code coverage analysis
not a lot of people that needs to
increase as well so coverage means you
want to find out what part of the code
is being executed or not so if you write
complicated code and you write the unit
tests and the unit tests only tests a
trivial part of your code or your
application that doesn't really mean
anything as with respect to the coverage
you want to write code that's tested or
you want to make sure that your tests
actually check something important in
your code so one way to do coverage is
using something instrumentation so in
this case you can use that the node
cover project this just one of the code
coverage out there so if you run this
code and it will say that hey the third
line is actually never gets executed
because it's it's a wrong branch there
it's a false branch and the way it does
is it takes your code and then injects
additional instrumentation and then ask
the browser or whatever JavaScript
engine executed because it gets to know
whether the extra annotation gets
executed or not
so statem statement coverage is very
important unfortunately it presents some
hidden trap and it's actually important
to see what kind of branches is being
executed I'm just going to skip this if
you want to do branch coverage there's a
nice project from the Yui team for
Istanbul and if you see the code if you
just want this true statement coverage
it will say that all those two lines in
that function they are all executed but
if you're ready to prevent coverage it
will say that oh no that particular if
there the house burns is not executed
and of course if you write unit tests
you want your test to exercise all
possible workflow in your application
execution tracing how many of you here
use jQuery Mobile so mobile application
in depth in general mobile web so Mobile
is slightly different than desktop
because of all the limitation of mobile
platforms so it's more important to pay
attention to performance there so one of
the metrics that you can get if you
annotate all your function is how many
function calls are being executed if you
do something for some point if you stop
your application so jQuery Mobile for me
executes 4,000 function just to display
a simple page this is not necessarily
bad per se because most of the function
calls it's a quick one but what you want
to monitor is how does this number
change over the time so if it's $4,000
$4,000
it becomes 20,000 and something is
suspicious there so you could totally
put this into your CI system and kind of
monitor their scalability is another
issues scalability here doesn't always
mean scale your architecture
it also means how would your function
work if the data changes so I say you
create an address book application you
need to be able to sort all the contacts
if your contacts just 10 or 100 even
bubblesort we do it really quickly so
you're in terms that this this book sort
thing it's finished in 10 milliseconds
it's the absolute time to execute the
function doesn't mean anything in the in
the context of scalability because you
need to test whether your best book can
sort 10,000 contacts reasonably well and
the way it works is you can annotate all
the function and then you see how the
function the number of calls as a
function of the different data so in
this case in the case of address book
sorting you won't see how many time
alright slap is called if the contract
if the context is only 10 if the context
is only is reached hundred and then a
thousand ten thousand it's all because
bubble sort can sorts ten addresses read
easily but when it's like a thousand
then you have you start to have problem
and you will not notice this by just
measuring how long does it take to ask
function transformation so I mentioned
what minification closed the compiler
and uglify just that's just one of the
use case of code transformation I have
introduced something that I call I know
it's a lot of buzz word non-destructive
partial source modification which
basically means that it will modify your
code only on particular parts so if it
doesn't interest the tool then it will
just happily ignore that one of the
obvious non-destructive modification is
to change the literal ones who here uses
single quote for string and double
quotes so if you have if you don't
define this or you know strictly men
that this in your coding style some guy
might use single another guy might eww
us and if you want to standardize on
certain things you need to do this
non-destructive modification because you
just want to change all the quotes you
you don't care about anything else
and of course care must be taken if you
change double quoted string that
contains double quote then you need some
escaping style for matter so the
challenge in formatting style is because
sometimes we have to do it manually and
and you need to specify it typical to
say I want four spaces indentation and I
want curly braces in its own line so one
of the stool coat painter that's
differently so you give code painter a
code that you want it to be so it's like
a sample code and that's that's
something that code painter will weep
and then deduce what kind of styling do
you want so if if your sample has four
space indentation then it will assume
that we use four spaces imitation and
then it will apply it to whatever code
that the tools so instead of expectedly
to say to the tools that hey I want the
way I want the curly braces in this
place you just give a sample and then it
will deduce it same case for quads right
if if your entire code uses single quote
and that that is given a sample
whenever it encounters double quote and
it will give you warning usually use
single quote why do you stab it quote
right now we wipe and we generate this
is possible through syntax code
modifications so in this case I parse
the expression and then I can just
change the value of constant there from
42 to something else
and then I can regenerate the code and
this is exactly what code minification
works so in this particular examples I
can show them the internal code using
base because I don't need to use a very
long function arguments as the neighbors
and there's a nice project os mangle
that does all this syntax tree messaging
so that the overall experiment execution
of the program won't change but the code
itself gets much solver that's also
something called tree shaking where if
you read a lot of code and then you
write a function that never gets
executed anywhere then it can remove
that because it looks at all the tree
and then kind of shake it and then at
one point one will drop because it's not
being used
syntax documentation so say you're not
happy with George Gipp you want to use
something else and a lot of people use
CoffeeScript there's dark right now
there's type scrape and the way you
Ackman the syntax of javascript is
through possible scenarios either adding
some new syntax or borrow something from
the future so low leverage or skip
changes the syntax of not changes
introduce a bunch of low-level features
of JavaScript cells which can use say
data types so instead of just you know
aa pack variable type you can define
this is a bit integers this is unsigned
32-bit and so on this is a modular
research project and if you type this it
will compile to JavaScript so this is
what you type and the generated code is
something that you're probably executed
pretty much like CoffeeScript different
syntax there's also sweet jazz another
modular project where you can define
macro and then you can use it later so
in this case you can create a new syntax
for defining function by using death
instead of function something
transportation how many of you familiar
with the concept of transportation
so transportation kind of like
compilation but it's called times
because I probably is just compiled some
flavor of JavaScript to another flavor
of JavaScript so if it's coffee spec is
completely different but translation is
some some JavaScript syntax that's that
doesn't exist right now is something
that you can use for example the next
ration of ACMA skip next special effect
Xmas Cape will introduce the concept of
class and of course you can use it right
now because no browsers you've got class
but you can properly pipe this and then
get it compiled or transpile to the
following contract over there that can
be executed by a processor today and you
can use it right now there's a project
to do that and this is not example of
non-destructive source modification
because if you look at the code here all
your comments are still there so the
tools doesn't modify the Transpower
doesn't touch anything that it doesn't
care about so in this case it only looks
for class syntax and then modify that it
doesn't care about anything else that's
a transparent from Google called tracer
and it does the same but trustor region
is the inside code if you have comma and
safe use for specimen tation if you use
blank lines everything will be gone it
also has ACMA script next we will
support module definitions so you don't
need to use this immediately invoked
function expression that is very cryptic
for beginners and again if I put some
line comments there it will exist in the
transport version so if you want to do
this there's a project called harmonizer
which basically borrows the future so
you can start using harmonii which is
next generation effect mascara by
transplanting it into something that can
be executed a anyone wants class
contract in JavaScript or everyone is
familiar or happy
with only object and prototypes some
people wants itself so let's talk about
the future these are all things that you
can try right now and those project
exists and you can start using it code
reviews so every time someone creates a
batch or submit the pull requests we
need to go through all the details like
hey the coding style is wrong it's not
tested this way in this way in this way
with traffic CI you could totally
automate this you can put in any kind of
analysis that you want right I mentioned
before what if we automatically check
the syntax for a batch because then you
don't need to make sure that it passes
the validator so a lot of things that
people do as part of code review process
that should be automated and I think
that's one of the most ambitious go for
next year meaning that we should not try
to analyze the code manually if you have
done this already couple of times for
example if someone if the coding style
has to follow certain standard then
rather than checking in by hand that
should be one of the tools that is
placed their syntax query so you've seen
a simple code linting example where I
look for double equal but I wish that we
can we could define a way syntax to look
for certain particular control Kaneko
for example using CSS lecture as a model
so if I want to find this assignment
expression then I can just type this and
it will immediately give me all use it
in this location and and then I can then
say that the user or why do you use this
operator in
in a branch condition you might not want
to do that because that's supposed to do
assignment so CSS lecture I'm sure
everyone is familiar with CSS lecture
rather than using the Dom API that you
have to get the first node and then
traverse in the next next neck
you just type simple construction then
it will pick exactly the elements that
you want that match that particular
criteria copy/paste mistake
can someone spot why it's wrong or why
we call this wrong
what did I do or what I didn't do after
I go yes and this is a nice example
because it's simple and I aligned the
code this one is wrong right because you
know it's supposed it has to be why -
because it doesn't make sense to put
that condition again so a lot of tools
in different programming languages exist
to detect that kind of copying
copy/paste mistake and I think it's a
matter of time before we have to have
that as part of our JavaScript
development workflow this really helps
in particular again in the context of
code review because you might look at
the patch and because you know it's 2
a.m. in the night you will not notice
that that one is wrong the factoring a
lot of yes
so the question is what how this works I
haven't implemented this but one of the
things that a lot of other tools like in
Citizen Java works with specimen here is
things so like in this if I have a I
detect that this is actually a
conditional 4m conditional and then you
have two conditions there
it doesn't make mixing so they're all
the same so something must be something
should be different because otherwise I
would not be the last part of the second
line there's also something like code
Coverity where for example if you create
a function and you call it a million
times and you always treat check the
written value and one time you don't
check the written value it will give you
warning because hey all these years all
these days you always check written
value of this function why don't you do
it right now so there might be something
suspicious now refactoring helpful a lot
of IDE like web Stone can do that and I
think if we put a lot of effort
conventions turn that into the post one
day I can just say I I create this
backbone Reuter and then I want the
chest name I don't need to do a search
replace because it understand this is
the web backbone works and many more
semantics live if you commit the code
and we want to check if you do get div
it gives you like x2 or D which is
pretty useless what I want to see is
like did I just suddenly declare new
variable that what kind of block did I
remove and so on
syntax error this is useful for
educational purposes because a lot of
time if you write code and browser the
browser any browser refused to work what
you get is unexpected token semicolon so
it doesn't tell you what's wrong there
why why did I make that mistake so it
tells why the syntax doesn't conform to
the specification to the grammar defined
in specification but it doesn't try to
reduce the construct that causes that
kind of problem symbolic execution is
something better than just dynamic
analysis when you write the unit tests
you have to define your fixtures by hand
right see if I create a function that
adds two numbers and then I write the
unit artist tell-all for try to add
and one and see if it's two two and one
and CF is three and so on is on worse
with symbolic execution it executes your
code and then sees that oh you have a
deficient operator let's try to find a
fixture that trigger divided by zero and
see if your problem behaves remar the
klephts declarative transformation
already mention about the cleric what
was that syntax query where you can ask
hey this is a this is person X and my
expression in an if conditional but we
also once we have decorative
transformations so I can totally change
hey use class syntax from Agnes crypt
six seven I want to transform it to
something that the browser can execute
using translation but not writing any
long code for that and pattern matching
pattern matching is very useful to
detect the copy/paste copy/paste mistake
because I want to be able to find I want
to be able to declare if there's some M
condition please check whether there's a
similar condition in one of those
branches so all this part C
infrastructure enables a lot of
different type of user
anything from tools anything from
unifications to code coverage and the
goal of all these tools of course to try
to analyze something that no tools can
analyze before and hopefully that will
empower new users so that they can make
less mistake and then bring a lot of
features so that power user or someone
that expert on JavaScript can still keep
and still be productive writing
application rejewski thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>