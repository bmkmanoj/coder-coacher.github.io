<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Macros | Coder Coacher - Coaching Coders</title><meta content="Scala Macros - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala Macros</b></h2><h5 class="post__date">2014-05-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ATl4s7XgrcA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it was good for me to write this talk
the Scala macros project began when I
was still at EPFL as a postdoc not a
Scala tech late here typesafe and I
guess I've been kind of living in denial
about macros from a compiler writers
perspective they're really scary because
you get to really poke around into
compiler I never really thought about
that in the last 10 years that my people
might end up doing that for those of you
written a macro before care to raise
your hand maybe you could start like a
club later alright not too many people
so okay great won't be too much
reputation going on then anyway
oh and there it goes to microphone is it
so on No okay that's weird okay well so
without further ado scarlet macros so as
I implied macros are still experimental
they're experimental for a good reason I
think you can do really cool things with
them and I definitely saw a lot of those
examples while preparing this talk and
reading bug reports during the year so
yeah I I just I really want to recommend
to avoid them does anyone have any
questions about that which part of
experimental wasn't clear no okay well
anyway I think there's a lot of really
cool things to be said about macros but
let's start with the beginning it's just
a method it's a method run by the type
checker right so you're writing
something that's running into compilers
domain I first want to give credit where
credit is due
Eugene has done an amazing job at
building a macro community writing
documentation turning something that
wasn't meant to be
programmed into something that is now
being partner but a lot of people
actually if you look around for macros
out there and and Dennis who made
actually pattern matching and create
Scala is T's something that is doesn't
make you want to pull your hair out so
the source is there will be a lot of
links in this talk they're all so this
talk is available on github come see me
later if you can't read the URLs I won't
be clicking nose links during a talk
except if you ask me so that being said
feel free dinner oh I'll be happy to
take any questions or heckling or
whatever during the talk so macros I
said are a method they're really -
there's a macro definition which is what
you see as the user using the macro
calling the macro it just looks like a
normal method except that there's
something funny about its body it has
this red keyword depending on your
editor that says it's a macro and it
says what the implementation is for this
macro when a call is seen to this foo
thingy what actually happens is the
compiler runs the food meta thingy
passes in the context that leads to
macro callin to call back into the
compiler both for analyzing what's
around the macro and for emitting code
and the macro implementation will then
amid code so the first part here this is
this is you'll see this everywhere in
your macros you'll need you'll need that
package I'll talk some more about why
the black box context is for now just
think about it as your hook into the
compiler and this is the result of your
macro which is going to be a tree
representation of a Scala program this
is the universe here is the compiler
itself and you're going to import all of
it and that we're using a quasi quote to
generate the Scala program that consists
of unit the empty block so if I just run
this
having some kind of problem the rapper
will start up and you'll say yep I find
this boo metal thingy for you and oh
yeah so as I told you my crews were
experimental okay your experimental but
we can fix that I just let this
interpret that it's actually a rebel so
there you go so now I have to find a Fuu
macro all this meta talk I don't like
all this you know stuff about I mean I
spend my whole life kind of a career
doing type theory and all that but you
don't really need any of that to
understand what's going on here we're
just writing a program that's analyzing
or generating another program that's it
okay so let's look a little closer at
this meta program I already told you a
lot about it so far so it doesn't matter
what this argument is called of course
it can call it context you do have to
return trees that are dependent on this
context and as I said the macro
implementation well we'll give you an
interview we'll give you a
representation of the program that you
want your macro to expand to everybody
with me so far
this is kind of the boring part I guess
right so this is a this is a dependent
type context is the argument here so
it's a value and it's Golic so it all
types depend on some value it might just
be a package or well I really didn't
sorry about that so in this case it's
the first method or again does that make
sense
I think it'll be done a little clearer
Gary good talk
so what we're really doing is making
sure that you're not mixing up it's not
essential actually for it to understand
to talk but as part of the particle
patters design it's that it's the other
point to the cake Sanibel okay any other
questions or once just yell if I don't
see there's these huge pillars in front
of me
so as I said already
when do we import the universe that's
called global and the compiler
implementation which is what I'm a
little bit more familiar with in the
macro side of things and we're just
importing all the types there to find it
there so it really is an example or a
type or symbol and this is a quasi quote
this is your best friend when you're a
macro idea and so let's you construct
Scala trees and since well I'll talk a
little bit more about them later I don't
want to tell you everything and once
then I'll just go back and read more
people okay so now that we've defined
this macro obviously we want to poke it
and see what happens so I have here our
little friend foo that we're calling in
my typically named class seat with
method M and there we go
define that class and make some room on
the screen and to really show you what's
going on under the hood I'll just run
the Java P commence so this is really no
rebel behind the scenes and it will show
you that the bytecode for the method M
is just returned right does that make
sense to everybody
would you like to experiment with
different quasi quotes or zubedah we can
don't have to
I'd like to someone y'all want something
yes yes I heard yes that's not a valid
Scala expression though would you like
to do something more specific so I
prepared print line but you know there
are other
Brent - good always good all right so
let's print something well I could leave
those Charlie's but let's just so what
do you want to print line hi that's very
great so oh sorry I keep forgetting
there's this microphone in my face I
apologize so oh great Kwasi quotes you
know what I said my crews are
experimental we can't do high now we can
do we can divide no problem I'll do I
will show you interpolation I'm pretty
sure that works this is to be fair this
is because we're running into a pole and
there's all kinds of weird stuff going
on to make this run like interactively
and as soon as you do as you all know
the demo effect things break I just
don't find one I wasn't counting that
someone wanting to brain stream to be
honest yeah well that's okay by me
apparently
all right so now the compiler is happy
we have our implementation of our macro
I promise you this will work when you're
doing it in a real program the rebel
isn't the greatest for this kind of
stuff but that's all that I say hates
and fixes tonight he's in your arms he's
almost awake again it's not good okay so
where was my there so let's redefine our
class and now of course we want to see
our extremely intelligent optimizer in
line that thing so this is what you get
when you call print line on high you
load the constant you and foe well first
of all you get the the utter pointer for
debris def call you invoke the virtual
which is print line and then well you
have to get this unit thinking because
that's the result of your method so
that's gonna be your box to unit as I'm
sure you've all do love when you look at
Java bytecode emitted by the Scala see
this is not running under game
okay so basically what this has shown
you is that approximately macros are
just you know hand rolled in liners
right that's that's what they are
ideally that's kind of the use case I am
comfortable with I find using that you
guys are doing that kind of stuff that's
fine so now we'll look at all the crazy
stuff you can do okay so I promised I
was gonna explain some more about what
the black box context is and I think of
it as a benign context because I have to
fix the bugs that are you know behind
the white box context which is you know
just wild so there's no need to look
inside and what I mean by that is that
someone is reading your code and there's
a macro invocation they know what's
going on it's just a method call they
don't need to understand the
implementation of the macro all I need
to know about it is the signature of
that method of the Foo method they don't
need to look any further than that so
the same holds for the IDE same holds
for any tooling that you've got running
on your code incremental compilation and
all that stuff
blackbox macros are constrained so that
they can't mess with the compiler modulo
bugs so that this dissing variant is
invalidated so whenever you can write a
black bugs macro if you're already
writing a macro make it a black box
please so the nice thing about is is
that you can do cogeneration which I've
shown you which is great for limiting a
lot of boilerplate and you can emit
better error messages because you're
kind of writing a domain-specific
language you know what the error
messages should look like it's not going
to be some random overload that's not
being found so that's great to feel free
to emit error messages and warnings I
think that's a perfectly valid use of
macros any questions so far
yep
is it possible to get the name of the
method that your being in yep it's
called the prefix re median closing
method or the target of your macro call
both are available so I mean and that's
a test that's basically excuse me my
point of the night is that that's the
real challenge in writing your macros
figuring out what the API for the
compiler is and what all those methods
do I've been working on a compiler for
six years now I'm still not entirely
sure about all of them so there's a lot
in there and we've done like we've done
Eugene is on an epic job of kind of
carving out an API that exposes what you
need to know but even during writing
this talk not everything is there yet
and that's why we're calling
experimental it's going to keep changing
during 211 because we don't feel it's
ready yet but yeah we're we're
definitely working on improving that
part you can pass type parameters you
can't pass anything else because of the
meta-level
jump that you're making so whatever your
macro implementation is doing it needs
to know it at compile time yeah
constants are known at compile time I'll
have a bigger example for you later
where we pass in constant but that's
about it it needs to be tracked by the
types and constants are actually we have
types that say this is an int one our
types actually don't know what constant
it is I don't just say oh it's in it and
I don't care like Java I don't know if
Java knows they just don't tell you so
here we get to our white box context and
this is where all the action is really
to be honest with you I'm talking about
bug fixing obviously so and and there's
a couple of things that invalid are
pretty deep invariants that I consider
pretty dear about understanding programs
so first and for all you need to run the
macro just to determine the type of the
macro call so that means IDs that don't
support macros they're out if you as a
human don't support macro execution
you won't understand what
happening in the code because you don't
know what the type is for the next call
on that macro so if you do food at bar
you don't know if that's gonna type
check because you don't know what what
what food does and it's in its
implementation you don't know what the
type is going to be rest with a regular
black box macro you can look at the
signature for food so oh yeah returns a
string string doesn't have a method bar
well made there's an implicit in its
code but you know that's about it that's
also why I don't like implicit so much
so they can guide implicit search
there's an API to said to tell applause
it's hurt hey don't consider this one do
consider that one what are the implicit
sin scope and so on so your macro can do
all of that when it's a white box macro
and full type inference is delayed until
after expansion which allows really neat
tricks and I'll show you one but again
it also hinders understanding of your
program and finally you can use them as
extractors you can use them to kind of
on to fly create extractors which is
really cool because what I did dear
before joining typesafe was rewrite the
pattern matcher and it's really exciting
to see this kind of stuff but yeah you
can have pretty crazy things so as a as
an example of something pretty wacky I
think anyway is you look at the phase of
the moon and you're an int or you're a
string like as I was giving you the
example of food up bar here mu D mu D
dog I'm sorry mu D dog bar is going to
be pretty moody so I'm defining the
macro mu d its implementation is giving
here and it says well if one ought to
return to program one expanded a program
one and the other half expanded program
one but it's spelled a little
differently okay so does that make sense
good because I have a question about
this for you next the extra quotes oh
yeah that's a good question that's how
it would work for the previous slide I
guess the extra quotes aren't necessary
I can I'm pretty sure they're not let's
try it yeah so I defined it the triple
quotes allow you to write anything
inside those triple quotes so you don't
get escape
the normal escaping behavior but we
don't need them here obviously because
there's nothing funny about one okay so
what this what this macro will do when
you call moody the compiler will call
moody Mita through reflection Java
reflection actually and it'll ask for a
random float look at it and decide to
expand into DST one the constant wand or
the AST constant oh and E right so
depending on that it'll have a different
type because all the implementation is
saying I returned a tree which is
representation of the Scala program and
I've kind of left off the implemented
the type here which is bad Adriene patty
do you have to write this always okay
this is actually super the next
milestone if we won't let you anymore
so just to be fair I'll do this I'll
play by the same rules so pop quiz I
mean I've given it away right so who
things this is gonna evaluate to zero no
that's great okay so what what's gonna
happen yeah that's that's exactly the
right question when is a simple well
it's invoked when this expression is
being typed echod right so what you're
really writing is call the method - on
the expression Moody and that's what
I've been harping on about it's like if
you want to understand this program you
need to understand the type of Moody and
in order to understand the type of Moody
you need to run the implementation of
the macro in order to do that you need
to have a bytecode interpreter in your
head or you know we can do some abstract
interpretation or something like that
but you know the approximation is that
this is not really gonna work all the
time I just run it and we'll see oh look
at zero that's great let me turn it
again oh not value one
that coming yeah so it's not even a
string it's just a random bleep bitten
and identifier yeah exactly
so well
yeah the core macros aren't hygienic
there are mechanisms for hygiene but I
chose not to use them yeah good point
so quasi quotes normally yeah no you
know it also doesn't hold so woody woody
equals equals woody will type check
sometimes you know statistically when
you do the math I'm not really good at
intuitions about statistics I know that
much at least
but yeah about 1 and 2 or something
right yeah in the back
no I know it's 1 in 4 but yeah I know
yeah sorry I can't hear you a runtime of
the compiler yes
No
so the more the implementation is
compiled to bytecode it has to be
actually for the compiler to consider it
a macro implementation but every time
the type checker sees Moody
it'll reflectively invoke using the JVM
because we're up to Scala compiler
learning on the JVM it will use Java
reflection to call that implementation
of the macro every time you don't do
that
that's my result no you're not
recompiling it it's been compiled to
bytecode but we're constantly
reflectively invoking it so you're not
actually this is kind of tricking you
into believing something that's not true
the ramble goes through all kinds of
trouble to let you define macros in the
same compilation unit as that you're
using don't actually flamenco is doing
is stacking up a bunch of objects that
let you pretend you're living in this
ideal universe where you're really not
so it needs to be compiled first and
that'll be reflectively involved using
the JVM its reflection capabilities
there there will be bytecode for so let
me show I can think I can show you well
I'd have to run a class I'm too lazy so
if I were to run Java P on the outer
class that the repple has generated for
this method it'll just it'll just be
regular scholar and the compiler doesn't
know anything doesn't need to know
anything about this method that it's a
macro it's just a method that operates
on Scala is T's doesn't do anything
special you're everything you know about
Scala compilation still holds well I'll
come back to your question in a second
so this is just compiled to bytecode
this is also compiled to bytecode but
the compiler remembers that it's a macro
and it'll pickle it'll remember in a
class file annotation which
implementation to reflectively invoke
when type checking moody and since it's
reflectively invoking moon Demeter needs
to have been compiled to bytecode and
it's compiled only wants
doesn't need to be any more but it's
invocation is actually compilation right
you can think of that as compilation
it's like a mini compiler running and
saying the digit 1 identifier
Oh any digit 1o any depending on phase
and mode
yeah sorry a question in the back well
so so the macro is compiled to bytecode
right once and just a regular Java class
with bytecode compiler is just a regular
Java application and it invokes a method
to macro implementation passing in on
the stack a pointer to itself so you're
basically writing a compiler plug-in so
we did our quiz so as I kind of told you
many times now to even just autocomplete
on a white box Mac or not on a black box
macro the IDE must run it must run the
macro implementation and actually the
skyline for Eclipse does this because
it's running a real Scala compiler so it
does it does do it and it sees the
expanded code which then confuses it a
little bit so if you're writing in macro
you might want to try detecting the IDE
and report your errors but don't expand
because it'll it'll not create an ideal
experience for someone using your macro
I'll have more on that later so oh yeah
there it is like I said later so we're
currently working on actually supporting
IDs in the micro API and giving you
better tools for playing nice with both
jetbrains and offerings and a neurone
let me tell you a little bit about a
couple applications that are out there
this is just a very select few apologize
if your macros in there please yell out
and I'll list it as well so as you've
seen a lot of code generation going on
you can generate your own range for each
to be a while loop which is great you
can do your own kind of specialization
like little islands of specialization so
all those links are worth the read I
would say if you have some time leader
you can write fast parallel collections
gala blitz you can scrap some
boilerplate
to do Jason formatting or parsing to do
fast pickling quasi quotes are also just
macros so in order to generate a SDS or
pattern match on them to give you like
the line number functionality that you
missed from C++ and do all kinds of
testing and tracing and asserting and
lots of bells and whistles with really
nice useful stuff most of these are
blackbox macros you can do static checks
like spores that are closures that make
sure that they don't capture anything
accidentally which is great when you're
writing a distributed application or you
know you can be something more mundane
and make sure that your printf format
errors are good you can write D s else
like SBT zero 13 does async is a nicer
way to work with futures also a macro
it's really just a compiler plug-in that
we package as a macro because it's less
of a pain but it's a macro language
virtualization as you may have heard of
and other talk talks and there's lots
more links in these behind these links
so when you're implementing macros and
after this I'll I'll tell you I'll give
you an example of one use quasi quotes
use quasi quotes there great be hygienic
use fresh names and use fully qualified
name starting at underscore root
underscore otherwise you might capture
even scholars and as unique as you might
think so in the ramble there's this
great power mode that lets you
experiment with runtime reflection
there's a toolbox compiler you can also
use to do unit testing of your macros
and avoid reset adders which is
something that undoes type-checking
resets your whole program as if it just
been parsed and then redoes type taking
instead combined type trees is very
technical stuff so I won't really going
to end this talk so to give you a quick
example of runtime reflection maybe I
should check home and doing on time here
No looks like I have some time to go
into this
so there's a whole there's actually two
universes of reflection there is the
universe well there's three really but
we don't want you to know about the
third one so I won't tell you there's
the two universes are the runtime
reflection and the macro reflection api
and the third one is the compiler so
here's an example of how you use the
runtime universe which is great for for
invoking the compiler at runtime really
and then just having to do whatever so
the first couple examples just have a
print line that conveniently has a
number rather than a string and you know
you can you can show that tree to see
what it looks like as a text
representation or you can do a show raw
what you know that's that's pretty cool
let me run it in the meantime I like and
then the next thing is actually you're
running like a little mini compiler that
it's reusing Java reflection to load
class files rather than reading them
from disk I was cool down in a second so
he can do really neat stuff with that
you basically have your own little Scala
so you can write a wrap-up with that or
do whatever
and so the toolbox has an eval method
that is like you know the eval you might
know from those languages who did macros
first so the one that you're seeing
there that's the result of the eval
so I evaluated the tree the ID is called
identity because it I'll just print
whatever I thought that permit was it
has actually gone through a round trip
between his T's and this shows you how
you would actually construct a tree
using to the API that the compiler uses
internally so whenever you're ready
print line it's actually not just print
line there's a whole lot of stuff going
on there you're making a term name
you're making identifiers out of that
and you're applying that to a list of
arguments in this case the literal
constant want but as it's invaluable
when you're when you're not using or
when you can't use quasi quotes for
certain reasons but most of the time you
can just use quasi quotes so this brings
me to my my bigger example I'm sure a
lot of you have wished in the past that
they could just - cliff I that case
class well I have good news for you you
can it's amazing so thanks to Dan
and Jason for helping me out with that
I'm a bit of a mac renew myself actually
so the use case is let's say you have a
bunch of case classes and you want to be
able to kind of squash them down to
their essence which is really a product
or a tuple and so you want to be able to
say you know person to PI and you get a
tuple that has all the case fields of
your of your case class I'm sure at some
point you wanted to do this so I'm gonna
introduce some helpers here to show you
that macro implementations are just
regular programs you write them using
regular Scala constructs so we're
experimenting here so I'm importing
language experimental macros Renda macro
universe for a reflection and we're
running a white bags white box macro so
that's pretty exciting asked you to
please forgive my might crimes against
annotation that can don't slide
otherwise so we have a couple helpers
here the first is an extractor for term
symbols so case field will match the
symbol that represents the field of a
case class and it will tell you if it is
the case that it is a field it will tell
you its turn name I could also just
point here good man
it will tell you its name and its type
so the way it does that is well it looks
at those different symbol sets are you a
value and are your faith clouds are
against accessor if so I'm gonna do some
really nasty stuff to your name you can
ask me why but I won't tell you
otherwise and I will give you the name
it will give you the type of that symbol
right so this is just a regular
extractor definition look at a symbol
give you its name in its type okay and
then the second thing would be your
logic that says hey there's something
wrong here's an error message that
tell you what's wrong while they did
some random vanilla Scala see here so in
this case we were just gonna tell you
huh it's not a case class and it'll use
the macro API so wherever you see
selected on C is part of the macro API
so in this case you'll have your
enclosing position and you can abort
compilation now system exit please we
don't we don't we don't keep you from
doing that but just it's not nice to
your ID although probably it was gee I
will actually do that I don't know so
any questions about like setting the
scene here this is just your arbitrary
data processing happens to be Scala
programs totally not to ask so the way
that Scala is compiled we have multiple
symbols for members of case classes for
the fields you got your private this
field you got your getter you got your
setter and we do some sneaky name
mangling on those so you can't call them
from your Scala program and the name
mangling we have to promise on the tell
anybody because they're always people
will start doing this is the identifier
is suffix with this white space that's
why I call and there's no API method I
look that's why I looked for a long time
there is one and the internal compiler
API obviously we don't do like trims all
over the place
alright come following you for any
problems but there we had a thought to
expose that one and the official macro
API so you can either do as a lot of
macro I mean compiler plugins do like
acing to just cast the universe down to
the compiler universe and then just go
wild or you can just be implement the
functionalities that
I've done here so yeah you just do it to
string in a trim what could possibly go
wrong and I forgot whether I run I
haven't run this yet so let me run that
I went to great pains to make sure that
I could like actually run that stuff all
right great
so now we get to the fun bit so what
we're gonna do is and all use this
screen so you don't feel too
discriminated against on this side we're
gonna implement a taste case class
actually so we're kind of doing like a
poor man's deriving from Haskell so
here's our case class and well Google
says it's a Google but it's actually a
trait asked tuple T of U and it's an
isomorphism that only goes one way if
there's anyone who knows kind of your
theory you can yell what that is I don't
know maybe it's an injection or
something so you know it'll just say I
can to please and it'll be a union after
it's been to blow fide that's how I
think about these things to be honest
okay so we have materialized who fits on
a slide this way which will give you an
essence of this type class usually it'd
be pretty tedious because you have to
write all those right you have to read
it for every case class that you're
right you'd have to do this unless
you're using shapeless or something like
that who's done that before like Mouse's
done all this nasty for you mean
stuff so you know here's the macro
implementation we're using macro bundles
which is nice for writing bigger macros
as we're doing here you know as soon as
it crosses a slide you probably should
consider micro bundles and they're
essentially like methods except that
there's that there's a whole iterate so
you're I made a method of a train as my
background
and the whole train will be instantiated
with its C member of being bound to the
context so you don't have to have the
method dependent type in their dependent
method type of you so if I go like what
this extends for CalPERS and helpers
extensor white-box macros and
whiteboards macros has a field context
called C because that fits on the spine
and you know you write it all the time
even when you don't like so this is your
implementation here we're gonna take a
tee that is passed in from here that is
passed it from there and we actually
want to reify this so we ask for an ID
tag
and since we're your macro
implementation we need to return a truth
in the right universe in the macro
universe so what we're gonna do is
actually where you find us so that just
means make an object out of something so
we'll have as deep object here and it is
representation of this T type argument
there deep type forever and we're gonna
call our first helper method or second
one actually that we defined to validate
that T to check that it's actually a
case class everybody with me so far
okay so what we're doing gonna do is
look at that tired which is this object
here this week type tag then and we're
gonna ask for its declarations so that
will include you know whatever methods
been there but also the case field the
case class fields we're gonna do a
collect just a collection can do
whatever and if it's a kids field
senescent books are extractor that we
defined earlier excuse me so if the
declaration that we're collecting
essentially a case filled with name and
type T P we will yield a pair which will
be the scala program
teto F or F a spliced into as
program so it alleged to be T dot
whatever name was for your free case
class fueled sorry kids cause fuel and T
P whatever type you gave to your field
and when he declared yorkese class great
so this is just doing some data munging
a declaration extracted into field
accessors giving you their names and
their types unzip that and what we're
gonna do now and this is the important
bit is we'll need an instance of our
type class here right we're just this is
kind of the meadow type class that knows
how to generate this for all case
classes and so we generate an instance
of this one so it's like as tuple that's
our that's our type class right there
the type parameter that we already
reified and this will splice in the list
of things so this is the tuple type
constructor you might not see it because
I kind of made it gray but these dot dot
types thingies are in parentheses so
it'll make it into a tuple so a tuple of
cardinality and for n types and the
argument types here because we made a
list right and then it'll implement it
to topple method the to tuple method
I'll say okay well I'm converting
appetit and what I'm going to give you
is end selections that I've generated
here so this t belong corresponds to the
t and the argument here okay so I see
yeah that's it oh yeah that's an
excellent question
it's not an object but a trait well so
as I design kind of hinted at there's
this abstract amber C that is your
context and as part of the macro bundle
translation you will instantiate this
class after mixing in that Val C
so it's an implementation detail off the
backward
as approach so it's you're actually
encoding dependent method types using
traits and value members for either a
dozen pushing the value member down into
recruitment lists and then creating and
using the the depending on the earlier
argument there so just kind of flattens
or pulls out if you will the argument
list and to do member okay more
questions
remarks oh yeah there's a lot of ways to
break this which is why I told you not
to use macros remember right now that's
just the type same side of things okay
but I don't mean the company so if we
run this we'll have completed our macro
implementation very exciting so now I
can show you to pull fine which brings
it all together so I have our good old
person who doesn't know he's going to be
subjected to tupola fication yet but
it's gonna happen so maybe all the stuff
over to the side can it balance it out
so case class any questions about the
case class okay
so we're gonna to plafond as thing and
we'll require evidence it is to profile
indeed and this evidence will be
supplied by our macro then when we get
our hands on that evidence will
immediately use it to call the to tuple
method it's like oh you say you can to
put that little too polite and we call
them the argument here so this is just
your ordinary implicit doesn't know
anything about the macro it doesn't care
where it's an instances come from it'll
use them okay so if I did everything
right there you'll get you know a typed
tool that has its first home in a string
second element an int and the values off
your person know
so any questions about that a or P
actually idea is we've done something
who actually recently done some fun
stuff with AOP I don't really know how
to like do you mean in general macros or
at this example this example I I haven't
used a spec J and like a decade could
you like I don't know do you have a
sense of how you would do it okay maybe
fictive the illness I mean there's
definitely I mean there's definitely use
cases for AOP that are similar to what
you would do with a macro I think as
with anything that you're doing
programming there's something today hope
you can do for you there or that's how
far you there but yeah it's kind of like
that except it doesn't really like get
it's it doesn't really get to do runtime
interception right it's all compiled
time I think that's that's I mean you
could write a spec J with macros I guess
but you'd have to inject the macro
everywhere in your program explicitly we
don't have the cross-cutting right if I
remember it was AP was defined by doing
cross-cutting and yes point cuts yes
point cuts an advice so you can do your
advice but I don't see how you would
quantify over point cuts and the weaving
is I see why you would do that but the
the cross-cutting would be much harder
I mean besides we have traits for that
if you wanted this off of that which is
kind of like a hardness version yes yes
I could say yes
don't do that at home or do only do that
I heard the bathroom and sorry I was so
blown away by your first question and
here to get second one yeah yep well you
want some source maps there won't you
well ask Eugene maybe a little that
you'd have to attach like some kind of
classified annotation or something
reified st and i'm sure they've been
thinking about this but that's not our
priority right now but yeah I mean you
could do it it would be painful you'd
have to get the IDs is important but it
would be I mean I agree would be very
important to have and actually that
reminds me right back to your question I
saw that there's a cool idea plugin that
a student google Summer of Code student
is working on called sprinter it's a so
fun that clearly forgot it's something
with Scala printing or something and
it'll let you print the STS generated by
macros and expand them in line and IDE
so you can you get a refactoring
basically to tell you de macro fie and
or you know just like you get a blessed
expansion already an install ID same
thing for macros so that's so far I
think the best I've seen but yes I agree
once you start using this in production
which is why we recommend you don't home
you will need something like that
besides get rid of them no no I'm just
kidding I actually I'm very impressed by
macros I think that made an amazing
progress you're talking about features
for macros right typesafe isn't working
on macros so it's all EPFL that's doing
the hard work we're using them as a
nicer way to write compiler plugins like
the Scala async stuff that we've done is
a really nice macro you should have a
look at it if you're interested in
really advanced compiler plug-in as
macro thing it doesn t NF transform and
then does a whole state machine
translation it's a lot of really cool
computer science in there and thank God
I didn't have to write the macro
machinery for it first because if you
failed at that for us
I don't really foresee types of getting
closely involved in macro development
but we are constantly working with the
bit file to make sure that they they're
able to do their work you know get the
pull requests through and fondant most
of the work that they're doing is
actually done ironically as a compiler
plugin the macro paradise' compiler
plug-in that is kind of the incubator
for next next generation macro if you
guys like macro annotations and type
macros and untyped macros and all that
crazy stuff you can use that in the 210
compiler and he's striking to 11
milestones as well as far as that ending
up in a real release next question I
don't know I mean it'll depend if we can
get it really stable and I think our
first priority is gonna be blackbox
macros get those nice and solid good API
documentation tool support and then
we'll talk about the next level okay I
think I'm almost done with my slides
actually I just quickly wanted to tell
you something about 211 that's actually
what that's my day job now so we slipped
down the library we're working on
speeding up the compiler it's not we
can't do miracles but it'll be faster
and we're slowing down the change which
kind of goes back to my previous
question because we
it's kinda stable and usable in
production not the crazy language I used
to be when I started working on it and
everybody wants to see pfl is aligned
with this vision and happy to work on
their plugins so we've pretty
aggressively deprecated I think this is
the first scholar release where we've
deprecated as much I don't have
statistics
unfortunately rajala is the standard
library so now you can roll your own
Scott XML support if you wanted the
compiler isn't married to the one that
we have the considerations are outside
now and the letter show shave off about
20% megabyte off of Scala library star
size so the main features to me of 211
or a battery koala compiler by jekyll
zhukovskiy optimizing the compiler
itself Jason comes out and the EPFL side
McCallum and Garcia has been working on
a better new SMB code back-end and
optimizer that's all gonna be
experimental so the nest my stolen is
coming up next year please start testing
your projects I think it's we're
reasonably stable a lot of uptake
already for a mile so anyway a lot of
artifacts out there already an RC
mid-february so time permitting happy to
take more questions an hour later thank
you
I guess we can do one more right because
it's allowed to change the result type
of the materializer so you need to
generate different as tuple for example
person to pair string of int or as tuple
some other case class and so on excuse
me no it's it's more like let me let me
show you real quick so let me get my
bearings if this was a black box macro
well actually this runs afoul of the
type inference restriction when calling
materialized if it was a black box macro
we infer T and you fully before
expanding the macro and what that would
mean is T is equal to person and u
becomes nothing because we don't know
anything about it to do the actual
inference we need to do the expansion
and see the tuple that comes out here
and then we do typing offensive that
compare that to you and that's how you
infer you but nor do that you need to
expand first we don't let black box do
that excellent question thank you should
have explained that all right that's a
great way to end the question doesn't
I'll be around Thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>