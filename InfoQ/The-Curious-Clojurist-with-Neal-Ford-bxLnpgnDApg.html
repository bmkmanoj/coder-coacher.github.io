<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Curious Clojurist with Neal Ford | Coder Coacher - Coaching Coders</title><meta content="The Curious Clojurist with Neal Ford - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Curious Clojurist with Neal Ford</b></h2><h5 class="post__date">2012-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bxLnpgnDApg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">just out of curiosity how many of you
have actually touched closure before now
anybody touched it at all okay that's
fine I don't assume any pre knowledge of
closure for this talk that's why it's
called a curious closure and I'm here to
talk about closure and the things I want
to talk about are what I'm calling the
four elevators of closure the thing that
really elevated above all the other
languages on the JVM and here are the
four elevators Java Interop Lisp
functional programming and closures
unique State on a unique take on State
and concurrency there are lots of
languages on the JVM now they might know
how many languages on the JVM now just
out of curiosity anybody anybody take a
guess I'll bet you an order of magnitude
off to guess 20 so they're more than 200
so I was right you were all more than
order of magnitude off they're more than
200 languages in JVM right now so why
should you choose one like closure
versus all the other ones and that's
what I'm going to attempt to answer
during this talk so here's the one line
elevator pitch for closure closure is a
dynamic strongly typed functional
high-performance implementation of a
lisp and the JVM so let's talk about a
few those characteristics closure is
dynamic meaning that it is dynamically
typed like Ruby and groovy or
dynamically typed meaning that you don't
predefined the type of a variable but
once you assign something to a variable
it is strongly typed that retains
knowledge of that you can do reflection
on that thing you can do any kind of
activity you want based on the type so
it is dynamic strongly typed so in that
way it is like groovy and Ruby both of
which are dynamic strongly typed
languages a difference though between
Ruby and groovy and closure is that
closure is heavily functional and this
is a really big difference between
closure and a language for example like
Scala which is also a functional
language on the JVM but they are
actually very very different in their
approaches because one of the
that Scala is trying to do is build a
bridge from the object-oriented
imperative world to where it thinks you
should be which is the more immutable
functional world but the way that
they're doing that is supporting both
paradigms which is a really nice
characteristic for bridge but it's also
a dangerous language to program in
because you have to have extreme
discipline to do the right thing same
thing happened in C++ which is also a
multi paradigm language people had a
mishmash of C and C++ and objects and
procedures and functions the same thing
is true in Scala which is a multi
paradigm language closure is not a multi
paradigm language closer to a functional
language first and foremost now it can
interact with all the imperative Java
world but you don't really write
imperative code in closure you write
functional code and so it has a much
stronger opinion about the way that you
can do things correctly and in fact
closures taken over a few things from
you but by doing that they've greatly
simplified some really really tricky
things in the JVM so for example closure
does for concurrency what Java did for
memory management you can write thread
safe code and closure without thinking
once about threading and everything is
automatically concurrent and thread safe
and I'll show you what that looks like
so it's a very functional language and a
single paradigm language versus a multi
paradigm language it's also very high
performance one of the goals in closure
this is actually I think Rich's fifth
Lisp implementation he knows how to do
efficient Lisp implementations and one
of his goals was to make a really
high-performance language on the JVM and
he has managed to do that in fact done
so in some ways they're a little bit
controversial in this world because the
traditional way that you build Lisp
programming languages as a particular
structure called a console rich decided
not to do that so he could make a higher
performance version in Java and so the
the surface characteristic going to
language or unchanged but the internal
implementation is different so he can
get really good high performance and the
last thing here is that it is a lisp on
the JVM so isn't list the one with all
the crazy parentheses yes it is which
brings up kind of an interesting point
people don't like to read Lisp
code because it looks like it comes to
another planet and so you would have to
be to build a brand new language and use
list in tax on the JVM you've either got
to be a crazy person or you've got some
really cool ulterior motives and I've
met rich he's not a crazy person he's
got a really cool ulterior motive
because lisps have a characteristic that
other languages just don't have and
though the way that that's captured is
is by saying that Lisp is a homo iconic
language which means that Lisp programs
are actually also legal Lisp data
structures which doesn't sound like that
big a deal it turns out it's a huge deal
when you get to really really complex
things that you need to attack in our
language this makes all the difference
in the world so lists programs actually
consists of Lisp data structures and
this is all kinds of useful and I'll
show you
implementing macros and why this is all
kinds of useful and why it is worthwhile
enduring the pain of learning to deal
with the parentheses and the pain goes
away really fast trust me it looks like
it'd be painful for a long time it's not
at all there are some really compelling
reasons to fight through that and adopt
this language so let's talk briefly
about the ecosystem I'm not going to
spend a lot of time here but if you have
any language you need to be able to do
stuff with it so the language itself is
on closure dot-org it's an open source
language project it is maintained by
closure core and so if one of the things
that you strongly desire when you pick
up a new language is to have a throat to
strangle if things go wrong and closure
core will it sell you a throat to
strangle if something goes wrong if you
want support for closure or things
around closure so there's an ecosystem a
lot of the spring ecosystem has grown up
around closure there a variety of
different ways to edit closure code if
you're a typical Java developer you're
probably in Eclipse and so there is a
Eclipse plug-in called counterclockwise
that gives you syntax highlighting and
Red Bull and a bunch of other nice
things if you want to go more
traditional old-school and Emacs there's
an eMac starter kit for closure that
gives you all the bits and pieces to get
closure up and running inside Emacs
there's also really nice IntelliJ
plug-in that does a closure
the build tool there are several in the
closure world the most popular one is
line again which is this is actually
based on a poem about this guy fighting
an army of ants which is where the name
of this tool came from there's also a
tool called cake which is rake enclosure
but this is the most popular one this
actually does translate dependency
management kind of like maven but
without the evilness of maven so it does
the transitive dependency management for
you but the syntax of course is all
closure code instead of XML and it has
the usual complement there's a web
framework there's several the most
popular web framework install composure
it's a very lightweight basically just
router framework Allah Sinatra and Ruby
on Rails or Rat Pack and groovy there is
also several different ways to talk to
relational databases there CLG record
which is a partial port of the Ruby
active record stuff that's in rails
under the excuse me a closure stack
there's also a closure QL which is
relational algebra to sequel as a DSL
there's also closure script which is
closure implemented in JavaScript so
they've actually written a closure
interpreter in JavaScript and you can
run closure code on top of JavaScript
using a couple of key libraries like the
closure library from from Google but you
can now it doesn't support everything
because there's some things that Java
can't support like the software
transactional memory stuff but all the
syntax is supported so there's a really
nice opportunity here people write the
same code on the back end and the same
mentor in the front end and past data
structures back and forth because you've
got closure on both the browser and the
server side so this being here code
let's look at and see what some closure
code looks like closure has the typical
kind of data types you would expect on a
JVM based languages we have strings
which are double strings limited we have
characters which are doing two with the
slash in front of them we have regular
expressions as well and this is a good
example of some of the nice things in
closure the regular expression here maps
directly down to the pattern class in
Java so this is really just a wrapper on
the pattern class in Java you can also
get to the matcher butt closure doesn't
like matter because matcher is mutable
in Java which is an evil thing for Mac
to be mutable and so closures
implemented their own implementation of
matcher that's not mutable I was just a
good thing we have precision integers
and you'll notice that these can be
represented as an inch-long Zoar big
integers you never have to think about
this in the closure world it
automatically escalates the Kreg
datatype for you so if you do something
it's gonna overflow and energy will just
roll over too long for you automatically
we have doubles and we have precision
doubles which represented by big
decimals underneath we have billions
which are represented by billions
underneath we have nil which is closures
version of no we also have a symbol type
a symbols or basically strings that
represent things like operators or
function names there's also a
specialized symbol called a key word
this is not like a keyword in Java where
if and while or keywords these are
basically from an implementation
standpoint in turn constant strings but
this keyword foo will always represent
this value of food and so it's useful to
use these for efficiency sake because
rather than use strings and there are
several data structures in here that
that kind of expect keywords like a Maps
a key words are frequently the key part
of the key value store so let's look at
some data literals we have lists which
are singly linked and insert it front
and the example is it's just within
parentheses that's a legal list in
closure but rich actually added a new
kind of sequence data structure to
closure called a vector and this is
indexed insert at rear these two exist
because they have different performance
characteristics in some cases you want
to use a singly linked list in some
cases you would like to use an indexed
vector he also introduced vector and and
with a square brace in tax to clean up
the the syntax for defining functions he
uses a vector instead of a list and that
actually gets rid of a really nasty set
of internal parentheses that you'd like
to get rid of I'll show you an example
of that in a second we also have maps
which are key value pairs keywords are
frequently used here but any closure
class can be used here as a key you
don't have to worry about the same thing
you have to worry about
Java because everything here in
enclosure is immutable and so that
everything makes good mat keys because
that's the thing you have to be careful
in Java
don't let mutable things be mat keys
because if you mutate it then you won't
be able to find your entry anymore
that's not a problem here enclosure
because everything is immutable and we
also have sets which have this syntax
with a pound sign and curly braces this
is a closures very characteristic of a
lot of functional programming languages
in that it has very few data structures
but a lot of operations that understand
those data structures a lot of
imperative object-oriented languages
have a lot of data structures and a lot
of operations most functional
programming languages have a very small
number of data structures but a lot of
things that operate on those data
structures so let's talk about function
calls here's what a function call looks
like in the closure world all you're
really doing here is taking the prin
which you normally put right here in
front of hello and just scooting it out
to be in front of the in front of the
opening print and so that's a function
call and it's argument as a single
string called a hello world but you also
notice that this function call is a
legal closure data structure because
it's just a list it's a list that has
two elements in it it's a list that has
two symbols in it this is part of that
homo iconicity that I was talking about
before here's how you can define a
function deff in a greet you can put a
doc string there if you want which is a
string that comes back closure has a
tool called the repple the read eval
print loop where you can start it up and
play around with closure code one of the
functions you can call as doc for
something to get documentation for it
which returns you the doc string that's
optional but you can put it in there and
you can also do more elaborate kind of
Java doc style documentation if you want
the arguments in closure end up in a
vector so it's function name and then
this is a comma delimited list of
arguments actually comma or space
delimited and this is a vector instead
of an embedded list which lets the
function definition stand out a little
more and then this is a function body
which is going to be a series of a
function calls
but again this homo icon Missy property
pops up notice that all these things are
just the data structures we've already
seen it's a list that has a bunch of
symbols in it there's a vector and then
there's another list with a bunch of
symbols in it
at the end of the day is all just data
and the reason that's important will
come up in a bit yeah no there's no
spaces significant in fact a comma
enclosure is also white space so you can
put commas anywhere you want to make it
look prettier
I said comma delimited list here but it
doesn't matter it can be a space
delimited because it doesn't matter
spaces here over here in fact even less
than in a lot of languages and that's
part of this all the parentheses stuff
you can also for some Interop scenarios
you want to be able to prefix function
metadata like types on here and so you
can do that if you want that can either
be a type or an arbitrary map that has a
value in it so you can add type Imps
here particularly for java Interop if
you have an overloaded java function and
you want to make sure that you call a
specific one that has a particular type
signature you can by applying function
metadata but that that's never really
used in the closure world so speaking of
java Interop one of the things that
you're obviously going to need to do and
you know jvm languages interoperate with
java so let's to look at java
interrupted what that looks like
you have syntax extensions to reach all
of java so there's no part of java that
you can't get to in closure closure also
compiles to bytecode so this is not an
interpreted language it compiles down to
bytecode so which means it's fast and
you can also call closure from java if
you want because at the end of the day
it's all bytecode the thing you run into
is that java or sorry closure is
expecting some characteristics of the
things that it deals with like it
assumes and mutability and if you pass
mutable things over you can still
interact with them but it's not it's not
a natural kind of thing to do and
calling closure from java makes a lot of
assumptions about interfaces it's
implementing a lot of other things that
make it difficult so if if you want to
see a good example of that
then cat Subramanyam has a new
book out on concurrency on the JVM and
he shows an example of calling into
closure software transactional memory
from Java so it is possible to do that
but there's a long checklist of things
you have to make sure because closures
have much more restrictive language than
Java in terms of some of the things that
a lot it will allow so if you want to
construct a new widget you would fire
the constructor like this in Java in
closure everything is function based and
there's syntactic sugar in the language
to say if you want to fire the
constructor on something just do class
name dot and then argument argument list
constructor parameter list you can also
get the static members in Java you would
do class dot in closure you do class or
namespace slash and one of the constant
is you can also get two instance members
so if I want to get to random number
next int the way to do that in closure
is dot next int for round a random so
notice that instead of being object
function its function object everywhere
and then any additional parameters would
go after the the object is there so any
dotted method you can call like this in
the Java world although but there's a
really common idiom in the Java world I
like to call the law of Demeter
violation where you say this dot this
not this or this I get this I get this
and this long series of things and that
would be really ugly and closure because
it would have to be inside out and so
there's syntactic sugar in closure - I a
to do chained access and so if you're
calling person not get address not get
zip code you can just put dot dot there
and then anything you put in here
there's an assumed dot in between all
those guys so this can be as long as you
want
dot dot handles all the intermediate
dots there yeah
well this does this does not produce
Java code this produces Java bytecode
when you compile this this pretty spike
code just like Java yeah this is not
doing code gin in Java this is pure Java
bytecode so well I groovy doesn't do
that anymore either yeah they all
compiled to bytecode now some of them
are interpreted so Ruby JRuby for
example is interpreted but closures not
interpreted it compiles straight down to
bytecode you must have been using groovy
pre 1.0 because that was that would have
been ancient times because I mean not in
that not unless you've got some weird
bill - groovy because groovy has been a
first-class language for a long time but
I mean there may be some sort of
translation tool that's doing that or
something but this one does not
translate to Java code at all this is
straight to bytecode so very high
performance yeah it's always - das no
matter how many you want that's just
that just basically says put dots
between every one of these things I'm
about to chain across here so in fact
one of the things that terrifies people
about Lisp is the number of parentheses
but from the java code we've seen so far
let's count them up and so in the java
version of the code that we've seen so
far we've got eight parenthesis in the
closure version we've only got six so
their closure realizes that the
parentheses can be a cumbersome and so
they have a lot of syntactic sugar in
the language to get rid of situations
where you'd have to go nuts with
parentheses things like dot dot to
simplify some of those strings so this
actually line has fewer parentheses than
that line so as I said you can get to
all the pieces of Java so for example
let's say you wanted to implement an
interface from the Java world that's
easy there's a function in there called
reify you give it a Java interface and
now you can have method bodies down here
what is the what does runnable look like
it takes a single run method that takes
no parameters there's a single run
method with no parameters there's the
body of the method if this interface to
find multiple method signatures then I
can have
multiple bodies down here with multiple
methods each one with parameter
signatures certainly using closure
changes the shape of your code so I want
to do is take a common piece of code
that probably exists in your code base
right now Apache Commons is blank method
and convert that over into closure kind
of one step at a time
deconstructing it from one language
together I'll do this a couple of times
here's the first time so there's this
blank this is from Apache comments what
this does you pass a string and it tries
to figure out if it's blank or not the
way that it does that is check to see is
it null or is it length of 0 that it
returns true otherwise it goes there
every character and looks to see if it's
a it's white space or not let's convert
that over to closure the first thing
we'll do is this closure is dynamically
typed we'll get rid of all the type
informations we'll strip out all the
types looks like that
we're definitely in pseudocode now we're
between Java and a closure now we can
get rid of the class because they don't
need classes here everything's function
based the next thing we're going to do
is use a higher order function so this
thing right here this for loop basically
I'm going to replace it with an every
function that says for every character
in string then tell me if it's
whitespace or not that's a higher-order
function now I'm going to come in and
get rid of the corner cases it turns out
that my every handles null and zero
linked strings correctly so I don't need
that special guard condition to handle
that case so I can get rid of that
corner case which leaves me there and
now I can Elizabeth I it there's what is
blank looks like enclosure and that one
is a lot easier to read than the Java
version even if you're not a closure
developer I think that one's way easier
to read because even even if you're an
experienced Java developer if I didn't
show you the name of that method it
would take you 30 seconds 45 seconds to
figure out what that method does whereas
here blank is that every character is
whitespace that's almost English that's
actually one of the goals in closure is
to be able to write code that is very
very readable code
this is very readable compared to this
stuff because that stuff's a bunch of
loops and other other Arcana this is a
pretty clean version of his bike it's a
naming I'm glad you brought that up it's
a naming convention in the closure world
that suggests that this returns true or
false in the traditional list world you
put a P at the end for predicate because
the languages wouldn't let's use
punctuation for function names but you
can use question mark as punctuation for
the function name it is part of the name
and that's a clue that it probably
returns true or false it's not a
requirement but it's a convention that's
a good question as well so this is
actually a syntactic sugar for anonymous
function so what every does every takes
in a function to apply to each element
and so this is a shorthand for saying
I've got a function but it only takes
one parameter so I'm not actually going
to create function with one parameter
and give that parameter name and then
call it so this is the the placeholder
for the single parameter this thing
takes so if you have a function that
just takes a single parameter you can
write it like this as an anonymous
function yep exactly
you can also if you have a function that
has a bunch of arguments and you don't
care about some of them you can use
underscore to basically say I skipped
those I don't care about this so what's
so special about Lisp I've been bragging
about how special Lisp is this is a
chart that Paul Graham came up with now
Paul Graham is a big advocate in the
list world and he wrote a book called
hackers and painters and one of the the
articles and hackers and painters is a
call to beating the averages where he
talks about the relative strengths and
weaknesses of various programming
languages and this is this chart where
the industry norm languages like Java
and c-sharp etc have conditionals
variables garbage collection and
recursion no big deal there the kind of
cool kid languages the Rubies the
Groovy's of the world have added some
more stuff a function type a symbol type
the whole language there all the time
which means you have the ability to do
meta programming and control the runtime
characteristics of your language
everything's an expression but this last
ones homo iconicity only close
end up with this one let's talk about
that one a little bit more and I need to
talk a little bit about special forms
special forms are the syntactic
scaffolding for your language so these
are all the key words that you know from
a language like Java so the if is a
special form so this while import scopes
protection control flow anything using a
keyword as a special form and that's
what you do when you learn a new
programming languages you learn the
rules for the special forms when you
learn Java you learn about the if
statement you learn about the boolean
short-circuit option you learn about the
else you learn about the dangling else
problem those are all characteristics of
that if special form in Java an outside
Lisp in languages like Java special
forms are limited to a specific use you
can only use the if statement to do
decisions about things and that's it
they look different from other things
you can't build something that looks
like the if statement in fact you can't
build new statements in Java you can
build functions and methods but you
can't build new statements some of the
special forms have special semantics
that are not available to you like the
if statement in the way it does
short-circuit boolean evaluation that
facilities just not available to use a
developer and because of that they end
up hampering reuse in a lot of
situations now I'll talk more about that
in a second so what's so special about
Lists special forms in Lisp they look
like everything else because it's just a
list remember everything is just a list
data structure and special forms and
lists may have special semantics
available only to you as a developer so
the language designer is actually giving
you more power than they've taken for
themselves and the really nice thing is
they could be augmented with macros and
that's where the real power comes from
and I'll show you an example of macro
just a second and so here are the forms
enclosure functions are actually lists
operators are actually list method calls
are lists and boy you get the idea here
everything is a list it's all the same
kind of thing so why is this so
important why do I keep ranting about
this special forms are easier to
understand individually that's why they
were created in programming languages
because they're easy to understand
there's a concrete set of rules about
how if works
but then you get a whole bunch of things
that have concrete rules and you mix
them all in together and to have them
start interacting with one another and
you get combinatorial complexity when
you have a lot of special forms and to
deal with that complexity you start
categorizing things and when you start
categorizing things you end up with
things like design patterns which does
not exist in the cliffs or closure world
so what's the alternative to that
because what design patterns do for us
in Java is help us build reusable code
and help us isolate and get rid of
duplications and things like that the
alternative in the list world are macros
let me show you this now this works so
for example let's say that I want to
build a swing application enclosure and
I've got a frame I want to add a pound
to it I want to pack the frame and I
want to set its visible property that's
true that's how you'd write that code
enclosure but it's annoying that that
frame thing keeps showing up over and
over again that duplication is annoying
and so we can stamp that out I'll create
a do two frame and then do all these
things to it say it once and then that
do two actually returns an expression so
you can do some other stuff to it so
we've used a macro there to eliminate
this duplication and got it down to just
one of them and now we have a better
context for doing that due to is that
built-in macro in the closure world
they're actually a bunch of macros built
in the closure world a lot of the
features in closure implemented with
macros how can you tell which ones they
are
you can't and that's the point let me
show you an example of a simple macro so
let's say that I want to say when X is
true then print this stuff turns out
that win does not exist in the language
yet so I can build it by creating a
macro this def macro says take in a test
and an optional body that's what the
prin means is the the rest of this is
optional so I can take in an optional
body and the return of this macro
returns a list that says if test then
construct a list that consists of the
body that's what cons does construct a
list but you'll notice the little tick
in front of if and do there because what
I actually expand this macro what it's
going to expand to is if X then do
print line X is true but notice what
translation has happened there basically
when it gets into this macro it takes in
tests okay it's going to return a list
what is this this is a list it's going
to return a list that has if as the
first element and then the tests
that's my parameter and then it's going
to construct a list with the word do and
then the body
notice that metaprogramming enclosure is
just programming in languages like Ruby
or groovy you have to switch to a
different syntax to do meta programming
you have to learn about the expanded
metaclass or in Ruby you have to learn
about the eigen class in the scala world
you have to learn about implicit casts
and all that other stuff you don't have
to learn any of that in closure because
there is no metaprogramming closure
programming is meta programming in
closure because closure programs our
closure data structures for example
there is only one mechanism in all a
closure that does decisions about things
and it's called if every other boolean
thing in the closure universe our macros
built on top of F one place to make sure
that truthiness is understood and it
built every other facility in the
language on top of that one trusted
thing that happens all over the place in
closure so a lot of the the what you
look at as keywords in closure actually
macros so that double dot thing I showed
you is a macro syntactic sugar anytime
in closure you have something that's
ugly
you can macro it away and make it pretty
again and that's really important
because what we have been doing for the
past 30 40 years is taking some kind of
problem some kind of business problem
and translating that problem into Java
and sometimes that's not a friendly
translation you try to do the opposite
enclosure enclosure because the language
is so bendable you actually bend the
language toward the problem not the
problem toward the language so it's
really characteristic and closure to
actually build up towards your problem
using macros and other sorts of syntax
in the language rather than just purely
try to translate your
problem into the only building blocks
you have so here's the analogy I'm
working on I may be hampered by my age
so we'll try this out so Java is like a
porcelain doll where you can't move any
of the limbs it's just a porcelain doll
groovy and Ruby are like the superhero
figures where you can bend some of the
joints like the elbows and the wrists
and closures like Gumby do you know what
Gumby is this is my problem is a lot of
people don't know Gumby is Gumby is this
this plastic doll that just has wires
anything Bend him in any shape that you
want
that's why closure is this is going to
be compared to a porcelain doll and
that's why this is so important this is
in fact people ask me what kind of
projects would you would you use closure
for and the answer is the nastiest
hardest toughest kind of projects
possible because it's those projects
where you need the ability to mold your
language towards your problem not
vice-versa so actually the two most
sophisticated project we have going on
in the world right now both closure
projects on purpose because we think
that that's the only way those project
could be done so that's why you endure
all these parentheses the parentheses
make this possible to do this kind of
meta programming they also make a lot of
other handy things possible so one of
the things that you learn when you learn
Java you know there's a chart that has
operator precedence where the pulse
plication happens for plus etc that
chart doesn't exist in closure because
everything is in prefix notation you are
writing it in the abstract syntax tree
you're not having to translate it
anywhere and so for example plus you can
say plus with two numbers but you can
also plus and have forty numbers there
because you're just adding them all
together so another thing that's
interesting about closure is a strongly
functional language so how is that
different from what you're used to in
the object-oriented world the way that
we achieve reuse is we create a network
of classes that communicate one another
with messages we find a piece of this
that works really nicely and so we
isolate that off and packaged up and
package that as a reusable class it's
not coincidental
that in the Gang of Four design patterns
book every single design pattern has a
class diagram that's just the way you
saw things and imperative auditory
languages functional languages are not
after that functional languages take a
different approach to this what
functional languages have done is taken
a few data structures remember I said
that functional languages prefer a small
number of data structures a lot of
operations on them what they do is build
machinery that understands those few
core data structures and what you're
expected to do is take data plus
customization in the form of a
higher-order function and pass into this
machinery and have it work on that and
do transformations for you this is an
example of what I call coarse grain
machinery to get stuff done so what
they've done is taken really common
abstractions for things that you do for
things like lists and maps and written
generic versions of operations on them
so for example if you have something
like a list one of the operations is you
might want to do on that list is say I
want to be able to convert this list
into a single element so let's say for
example I wanted to sum this list one of
the ways to sum this list is to say take
the first element add the second element
on to it and make that the new first
element and then do the same again over
and over and if the operation using to
do that is plus then what you're left
with is the sum of that list that's
known as a fold or reduce in the
functional programming world you're
reducing that down or folding it down to
a single value another one of these
transformations common transformations
is take a list and return me a subset in
it list which is a filtering operation
another one of these operations is take
some existing list that has values in it
and then map a function onto each one of
those yielding a brand new list of items
these are really common things that pop
up all the time and of course they have
optimized versions of these in closure
this will also change the structure of
your code so I want to do another one of
these transformation exercises and this
one's actually little more sophisticated
this is Apache Commons index of Eenie
what
supposed to do is you give this a string
and some characters and it will tell you
the beginning index of where those
characters start so for example here b
and y it looks like B is in the three
position so that's the first one of the
two that show up it's in the third
position so that's what this thing is
supposed to do and here's the
implementation for it and so let's
collapse this down to a lisp first thing
we'll do is simplify the corner cases
the corner cases up at the top or the is
empty
both those empties actually are handled
by my whim or will be handled by my list
comprehension in a second so we can get
rid of the edge cases we can also now
strip out all the type information
because we're not we don't need type
declarations anymore we will now come in
and replace that for loop the internal
for loop with a win clause that
basically says when you find one of
these search characters then just return
it now I'm going to add a list
comprehension to get rid of this for
loop now I'm gonna replace it with
something that says 4 which is just a
poorly named in my opinion because it's
not a for loop it's actually a list
comprehension which is kind of the Swiss
Army chainsaw of doing things with lists
what you can do with a list
comprehension is basically say for a
collection here's an input format and
some values and and what you want it to
return and so I'm going to say for each
index and character and index then in my
index string then return the index when
I find that character and now Elizabeth
I this guy this is now index filter it
takes in a predicate and a collection
the predicate is a higher-order function
it tells how to decide if it's in the
collection or not when that predicate is
true then it's going to look at each
index an element in the index collection
and when that element is true it's going
to return that index but now that we've
done that okay sorry
oh you can't read list code that fast
yes shocking the list comprehension is
the trickiest thing here basically what
that saying is what I want is an input
pattern is an index in an element and
the collection I'm doing this for is it
in the index collection when is a flag
you can put when or if or if not or some
of those things to determine when those
things end up getting filtered in or not
and then the return value that you'll to
me one of those thing is the index this
is actually doing a filtering for me
this is doing a filtering operation when
this is basically a predicate that's
that's when this is true then I want
that to to execute so it's not it's not
actually a for loop at all it's a list
comprehension is basically a way to
apply a bunch of logic to a list in bits
and pieces but now that we've got that
which version is simpler the imperative
version has 18 moving parts the
functional closure version has four
moving parts so the closure version is
actually simpler in terms of amount of
code and number of characters and yet
it's more general the java version only
works on strings this works on any
sequence so if I want to say index
filter give me the number of heads out
of a string of head and tail flips it
looks like the heads all show up at two
four eight and nine here I'm saying is
give me the first Fibonacci number
that's greater than a thousand so give
me the root of the first Fibonacci
number that's greater than a thousand
turns out at 1717 is comes out Fibonacci
of seventeen is a little over a thousand
so the imperative version searches only
strings whereas the functional version
searches any sequence imperative version
matches only characters whereas the
functional version matches any predicate
you pass the predicate function in to
determine what it what the match
criteria is the imperative version
returns only the first match the
functional version returns a lazy
sequences of all the matches so it's
another thing you get from most of the
sequences and closures they're all lazy
meaning that they evaluate the first
element and then don't evaluate the rest
of them till you ask for them so it's as
efficient as possible it
it generates as few values as it needs
to but then you can ask for more and
it'll lazily generate those values for
you as you need them and so here for my
my index what I'm doing here is saying
well give me the first one but then I
can say okay will give me the next one
and the next one the next one so it's
actually more general and more powerful
than the imperative version and this is
true in a lot of functional code in
particularly in the closure world you
really want to get to general solutions
to things and having dynamic typing and
higher-order functions allows you to do
that so before we get too deep into this
let's start talking about state and
concurrency because that's one of the
reasons you came here is because you
heard closure had this really wicked
cool stuff around concurrency and it's
true it does but let's talk about data
structures for a second in the closure
world data structures in the closure
world are immutable which may make you
frightened for performance because
you're used to a language like Java
where immutability is a second or third
class citizen at best so in Java if you
have something like a mutable data
structure and you want to change it you
have to create a brand new immutable
data structure with all the same values
and there's a few separate values but
that's not true here because if you can
assume everything's immutable you can
share the common parts of those data
structures when you create new ones
everything in closure is immutable you
change things by applying a function to
it to to move it from one state to
another all of the persistent data
structures maintain performance
guarantees in closure so there are all
very very high performance you also get
full fidelity old versions closure never
delete anything because everything is
immutable you can't delete things if
they're immutable and so closure doesn't
delete things so how would that work
with a link list so if I have my list
and you have your list and they happen
to share some common terms this is
perfectly okay because neither one of us
can change you need things we point to
it's perfectly safe to share this data
structure if you can assume that every
one of these elements is immutable and
can never be changed or deleted so that
works perfectly great with lists what
about more calm
things like trees you didn't exact same
things with trees in fact there's some
really deep computer science and closure
based on some studies of red black
balance trees that's how this is
implemented underneath so if you have
your part of a tree and there's another
part of a tree you can actually share a
lot of that data structure because all
the values are immutable this is an
example bit partition tries this is an
example of doing two bit partition tries
which is too slow for practical purposes
what closure actually implements
underneath is a 32 bit red black balance
tree to store all these data structures
and log 32 is fast enough that basically
means that you get two results really
fast because it's a really flat data
structure rather than a really deep data
structure so that's the trade-off as
flat versus deep this is all internal
details you never have to carry anything
about this but this is how he can
maintain performance guarantees and have
immutable data structures internally as
well he's determined that log 32 n is
fast enough to be able to find things as
you traverse through this tree so the
other interesting thing that closure is
done around state is identified what
makes concurrency so hard in Java it's
actually surprising the the core the
root of the problem if you go all the
way down and find the criminal that
makes threading so hard in Java its
variables because when they created
variables in Java they weren't thinking
about concurrency in multi-threaded
situations they were always thinking
about this variable owns this for all of
time and nobody else will ever interfere
with this value the problem is its
convoluting several different important
concepts basically this idea of identity
and state because a variable in Java
holds on to the identity and whatever
value happens to be there as well and
it's hard to predict when that's going
to change and it's hard to logic about
that over time what closure is done is
said you know what we can fix this so
what closure is done is says everything
is immutable save one thing there's one
thing in closure that you can mutate and
it's a
reference you can have a variable that
points to a reference that is its
identity that reference is identity and
at some point in time it points to some
value at some snapshot in time that is
its state it the identities value at a
point in time is its state but what
closure is done is said you know what if
I can take over that if you'll let
closure manage that for you then closure
can manage all of threading for you this
is the core this is the the central
place or if you'll let close your handle
assignment for you
using its functions that it'll handle
all concurrency issues for you that's
the way that this works so what they've
done is kind of remap the idea of
variables a value is an immutable data
and some persistent data structure
somewhere identity is a series of
causally related values over time state
is identity at some point in time and
time is relative it's before it's
simultaneous it's after but ultimately
and this is a campaign that rich has
been on we've got to start adding time
awareness into our code we just we can't
ignore time anymore because if you talk
about some value it's meaningless unless
you talk about when that value is is
applicable because values identities
change over time they point to different
values over time and so you have to know
the time to know what value that
identity has and that's what he's really
done is created explicit semantics
around that enclosure and so what
happens in closure is identity is a
succession of states you move from one
state to the other you'll you change
from one state to another by applying a
mutating function that moves the
reference from one value to another
value it doesn't change the identity it
just moves what it it points to you from
one place to another then at any point
in time observers or perception memory
can look at the state of that thing
which is the identity and the value at
this point in time and and see what it
is
so this is this society of a unified
update model so what you do is you have
a function that changes the state from a
reference using that anonymous function
for its value snapshots are always
available no user locking and no dead
locks riders never impede readers never
a dead lock never a concurrency problem
never a collision in fact you can also
with software transactional memory say I
want all four of these valuable
variables to get mutated or none of them
but you can't do it all in Java now
there's no transactional semantics
around variables at all but there is
enclosure and that's really software
transactional memory which is the next
thing I'm going to talk about because in
software transactional memory what
happens is moving that pointer from a
reference to reference one value to
another closure does that within a
transaction which means it can do many
variables if you want within the same
transaction because it's managing all
that that's exactly what this image is
showing is that you can actually tie
several variables together and have them
work in lockstep closure will go back
and retry things that it can't achieve
you can set retry limits and other kinds
of things just like a transaction engine
would this is the syntax for doing this
and the syntax is actually kind of
anticlimactic because it's just pretty
simple and straightforward so here I'm
defining messages who's a variable that
points to a ref and that ref is
currently empty it's pointing to an
empty list so I now have messages which
points to an empty list if I want to
find out what's in messages at any point
in time I can call the D ref function on
messages and see what's in there this is
such a common operation there's a
special syntactic sugar if you just put
AK messages in front of it it will
dereference that message for you so
let's talk about altering a message you
can use the alter function like this
where I have a reference and an update
function what that's going to do is take
the old value and then I use that apply
method to update that to the new value
so this is what that looks like let's
say you want to update a message
you got a messaging application or
something like that here's a define
function add messages taking a new
message and what I'm going to do is
alter messages that's my reference to my
list can join this message onto the end
of it so add another message on to the
my list but you'll notice do sink right
here if do sink is not their closure
won't execute this code you'll get a
runtime error saying you're trying to
mutate something outside of transaction
I won't let you you have to have do sink
there that's what kicks off the
transaction but that's it now you've got
software transactional memory questions
about that it's a really simple
mechanism when you see it the underlying
implementation details are horrific Lee
complex but you never see that just like
a garbage collection algorithms in Java
or horrific a complex and you never see
that either because you're working on a
higher level of abstraction
it's a runtime message yep you get
everything but D so you get atomic
consistent isolated but no D because
it's memory but you do get of the four
transaction characteristics acid atomic
consistent isolated and durable you get
all but durable because it's all
happening in memory but it is a
completely acid except for the D in
memory very super powerful mechanism in
closure world so let's look for a little
bit about what data looks like in the
closure world because closure really
likes things that are in maps and really
very lightweight data structures but you
can map back and forth between this
world and the Java world so let's say
for example I wanted something that
looked like a class the data parts of a
class this is basically creates a name
type of slots so I can now have a define
a foo and construct a new food object
there with a positional constructor I
can now if I want to get values out of F
I can just use the keyword against the
data structure and it'll return the
value this is true in maps as well I can
also ask it what class you aren't it'll
tell me what class it is I can also ask
it what its super classes are and here
are a bunch of things that rich has
automatically added to things classes
you create enclosure to make it much
easier to deal with like persistent
collections and other things like that
but you can also do this in maps and
this is a kind of a more typical way to
do this in the list
world so here for example is some
information about Stu Halloway he wrote
into one of the first the very first
closure book where I'm creating this map
there's a basically nested structure
what does this look a lot like looks a
lot like JSON doesn't it this is a
really powerful transport mechanism back
and forth particularly if you have
closure and closure script on either
side because you're actually passing
real code back and forth without having
to serialize and deserialize into JSON
it's the real data structure which is
kinda nice but it's easy to map between
this and something like JSON you can get
keyword access so if I have stew I can
say give me the last name of stew a
keyword becomes a function on the
collection this is just syntactic sugar
in the closure world I can also get
nested access with this the syntactic
sugar will arrow guy here that says give
me ste you address city so that's
actually digging into this collection if
I want to do an update here I can say do
an update first you and I create a new
giving a new first name Stewart
introduced to you when I do this update
notice I'm not doing this in a
transaction what is doing is returning
me a new data structure so this is
immutable just like you'd expect
immutable it's sharing all the common
parts but it is returning a brand new
data structure and the old one is still
there because nothing ever goes away and
you can also do nested updates as well
if you want you can do the exact same
thing on top of records if you want
which are basically classes so here's
the same thing constructed in an
object-oriented fashion but even if you
have this object structure you can still
use the same keyword access to get
things out of maps you can still use the
same nested access thing to get things
out of deeply-held collections and you
can also do the update the exact same
way you did it before and this is part
of this easy mapping between Java and
closure closure likes Maps Java locks
classes you know what we'll just map
them back and forth between each other
and let them be a seamlessly move back
and forth
yep so we you can't add methods to it
well actually can in here but you're
actually then creating a class so you
create a new class you create a bunch of
functions that are associated that class
but that's actually pretty rare thing
because you're not really creating the
only reason to do that's to pass that
back over to Java because it wanted a
class for something and you could
actually build as a map and then as you
pass it it'll it'll coerce it into a
class but you're right there are no
methods on this this is just the data
part of it so closures Navy is a
functional function based language
everything is function so the idea in
closure is you have a collection of
functions you can also have namespaces
so you can think of a namespace almost
like a package there's a main collection
of functions within the namespace you
can actually have functions that are
private to that namespace if you do
death in - its private just to that
namespace you can also have this thing
called a protocol which is very much
like an interface so the idea in closure
is instead of doing classes what you do
is define a namespace that has a
protocol in it that defines the
semantics of how you're gonna call
functions that's actually implemented by
functions underneath inside that
namespace and so you have these kind of
coarse-grain collections of functions
that are named spaced that you can
execute and do things with that's the
way a closure program looks like that's
the structure of closure code it's kind
of like packages classes and methods in
Java except that we just eliminated the
classes part and and you pass around
data as parameters instead of being
passed around as part of the object so
what's cool about closure it's a really
highly expressive language once you get
used to learn to reading Lisp and it
doesn't take that long in fact if you
want a fun way to kind of get hooked on
writing closure code go and download the
closure cones
it's koat NS a lot of languages have
these cones now which are these little
Zen puzzles that basically are just ways
to exercise syntax so if you download
the closure cones you run it and it'll
give you a little puzzle and you fill in
with with the code to make it work and
then it'll run and automatically pick
that up and then give you the next one
so this is the closure equivalent of
potato chips because you
aren't doing it's like okay just one
more okay I'll just do what I can get
that would work one more and then before
you know it it's 2:00 a.m. and you've
eaten a whole bag of closure really
super expressive language once you get
used to reading the syntax and it really
doesn't take much time at all really
good seamless Java Interop that's one of
the goals of closures really really good
Java Interop heavily functional of
course and a really advanced concurrency
story the other thing that I would point
you to as a kind of a mind-bending
exercise is so rich Hickey is the guy
who created closure he's here wandering
he's doing keynote tomorrow the the
project the big top secret project he's
been working on for like two years is
this thing called a Tomic which is a
comic with a done in front of it de
Tomic is an immutable database
think about that for a second it uses
all this closure stuff in software
transactional memory but when you put
stuff in de Tomic it doesn't go away
which may scare you because it's like
walled then it's just going to grow
forever but I've got a question for you
how many times is the number nine appear
in your relational database that's a
stupid waste of space when you could
just store one nine and then have every
nine that needs it point to it because
mine never changes minds a fact so
that's how they Tomic can store
basically an infinite amount of
information and never throw anything
away
because it's immutable and you can rely
on immutability to do this so but
thinking about that so in de Tomic
schema and data use the same syntax so
one of the really nasty problems in the
continuous delivery world is let's say
you got your code and you got this
database schema and now you want to roll
back to a previous version of your
database schema we have all these
migrations and other crazy mechanisms do
that and they Tomic you just point it to
an older version of the database because
every version that's ever been is still
there
there's no migrating back and forth it's
just there it's just it's always been
there it will always be there that's the
point now you're going to have to start
answering this question at your company
why when you're using that relational
database are you destroying valuable
company data every
you're doing the destructive update the
reason you're doing that is because hard
drive space is really expensive and
really critical resource and we want to
do as much as we can to maximize that oh
wait a minute that's not true at all a
lot of our architectural assumptions are
based on 20-year old ideas like we need
to maximize storage space as much as
possible so reuse that space well that's
a dumb idea too now when we have as much
space as we want and there's huge value
to keeping that historical data that's
happening in that database so that's a
good example of the kind of radical
rethinking that becomes possible when
you have a language that has really
really advanced capabilities and has
some really core key changes implemented
down at the very bottom once you listen
to rich talk a lot you realize that
closure is not so much a programming
language as a vision for how to write
software that you could only implement
by writing a new programming language
called closure that's exactly what
closure is so I'm out of time actually
five minutes over I apologize for that
if you got other questions I'll be happy
to answer them and of course rich is
here he's the source of all knowledge in
this universe he can chase him down and
congratulate him on closure and ask him
some questions as well thanks very much
for coming and hope you enjoyed it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>