<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Macros vs Types | Coder Coacher - Coaching Coders</title><meta content="Macros vs Types - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Macros vs Types</b></h2><h5 class="post__date">2014-03-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rwAIAugTSHY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">as large said an epic battle is coming
and here's what we are going to be
talking about so well types have been
with scallop for 10 years just as long
as skull exists and they have been
successfully used to metal program
scholar well just write in normals
normal type annotations can be thought
of as meta programming and yeah this is
this is the tradition and macro is the
new contender with macros we can do a
lot of compile-time stuff and people
debate on twitter on IRC i'm actually
subscribed to this sketch scholar and
has shapeless and hash scholars ear see
thing and my my body tells me every time
when macro gets gets no well mentioned
this is quite fun so now we're going to
solve this dispute one once and for all
so that yeah no more flames sorry guys
so how we're going to do that actually
it's going to be in more or less
structured fashion so following the
following my target skull exchange water
macros good for we will rank the
competitors according to their
performances in three disciplines while
cogeneration static checks and dsl's so
all right let the battle begin so
starting with cogeneration actually
every language ecosystem has it and yeah
I would even dare to say that every
language has some some limit to their
well to their abstractions and beyond
this limit you actually need the wealth
of the cogeneration and even even high
school even in Haskell there's a lot of
use cases that people solve with
metaprogramming say they generate lenses
there's the whole web framework that's
quite centered around the idea of
compile time at a program in with
template Haskell and well you know even
Haskell so it's not like we're doing
something really wrong so how do we do
take a cogeneration what immediately
comes to mind is textual cogeneration
some some stuff like this where we
process one file and another file in
another file and then do some stuff well
of course I I couldn't I couldn't help
myself but
to mention the shortcomings of textual
cogeneration well obviously when you
manipulate strings things are not funny
this closing parenthesis thus commas
quotes whatever it's quite easy to mess
up and secondly code generators they
have little knowledge about the
structure of the proud of the program
they're very compelling about the types
about well declared classes and things
like that and finally well as we've seen
on this diagram on this very funny
diagram this has to be hooked up into
the build process and this can be either
easy or quite daunting task so how can
we remedy this with with the high-tech
solution well first of all types
scholars type system is Turing complete
and in steering completing multiple and
sometimes disturbing ways so we can do
we can do everything that that we want
and this this in itself enables some
form of cogeneration though it can be
quite as at Eric and well so we we won't
cover that part just yet so what can
what can macros offer us well since
macros are just scalar functions that
are run at compile time well essentially
they can do whatever and they can do
this whatever in a very straightforward
fashion you just separate on data
structures that provide it to you by the
compiler for instance types or trees and
well you produce more trees so here's
your cogeneration step and since you are
working with asds it's actually
structured it's not string so it's quite
hard to well there are you always have
ways to mess up but with macro seats is
just harder so just the final remark all
this it's not some theoretical stuff it
actually works and a lot of popular web
reason both well some are used in
production some are used in research
well they do use macros so what what
does this bring us to and how can types
help how do they fit in this picture
oops oh actually yeah I'm going I'm
going to do a little demo and afterwards
I'll give this clicker to Lars so
speaking of macros and how you
cogeneration this is this is a great
example that they took from Eric's
article to type level and how we do
things in Scala so this particular this
particular nice function that does some
addition and then multiplication it's a
great illustration of how very
high-level abstractions work in Scala so
with Scully's it's easy to write pretty
code pretty generic polymorphic code but
well unfortunately this is the how it
compiles down to to something that's not
very efficient in a lot of cases so for
instance here we have a lot of object
creations that are completely
unnecessary just to wrap some existing
functionality and well this ends up
being slow if you run these millions and
millions of time x well apparently
there's always a fast and ugly looking
solution just like this so we can just
just call these functions x + + directly
but it's not going to be very pretty who
wants to do that but well so previously
before macros that was a sad choice that
we had to make but with macros in a lot
of situations we can actually combine
the strengths of both worlds so with
macros we can have a pretty front end
but given that plus and multiply are
implemented those macros they can
generate exactly the cyclic code that we
see below while defeating the
performance problem so now as I promised
I'm going to give this clicker large and
let's see what he has to say yeah so
thanks to macros a cogeneration became
accessible and there it is anecdotal
evidence by that because everyone and
their dog is writing macros so
apparently they are somewhat accessible
and also somewhat fun I guess at least
and the problem is that macros are
essentially a pact to human so if you
really want to understand what's going
on in macro you basically have to look
at the source code of this of its
implementation because s Eugene already
said you can do pretty much anything in
the macro and I can be kind of odd if
you have just it's something looks like
a normal function call I mean
that'sthat's good for users but it looks
like a normal function call so you
sometimes don't expect
something interesting going on there and
then you look at it as with macro doing
all sorts of contractions to do
something so this is this is unfortunate
but luckily we can combine macros with
with strong types to alleviate these
problems here's an example for that
another use case so we've already heard
about it today materialization so what's
actually materialized asian what we want
to have our default implementations for
some very common type classes for
example a semi-group which performs
appointed position so if you have a
point class with two elements you want
to do if you want in addition you want
to add both axes and both wise and for
example ordering so you just pick the
lexicographic ordering or binary service
agents use your realization but the
thing is you don't want to write it all
over again because it's pretty mechanic
I mean you all know exactly how to
implement the same a group for a case
class where all the elements are
semigroups but it's very repetitive and
you usually copy paste that and that
introduces bugs so you have three
elements hence three times two bugs yeah
and three we really don't want to do
that so skala see already synthesized is
some of the boilerplate for us if you
put a case in front of your class
keyword and then you get for example
equals or two string for free and those
are also completely mechanical
implementations and yeah case classes
are pretty common in code bases so
that's actually something which is being
used by programmers a problem here is
that it is the synthesis ation of equals
and two string and an other methods like
hash code and stuff this is not
extensible so if you want to generate
more than that you would actually need
to have the compiler or at a compiler
plugin or something like that and you
don't want to do that I mean we are
already talking about type classes and
the whole idea of type classes said it's
extensible so you can just add instances
or type classes at any point in your
program and it should just work and this
is not actually what what what we can do
with the with Scott with this mechanism
I mean we can't just say I'll at this
compiler plugin to generate that stuff
so the solution here
is to use the materialization mechanism
which is itself based on on type classes
so you have a type class called type
class and yes this is actually a type
class in in shape laws which basically
describes how to derive those instances
and this is implement these are
implemented in plain scholar and then it
those are getting picked up by an
inclusive macro and it kind of puts
these together in certain race and then
you get your instance so why does it
actually work you know like in languages
like Haskell type classes and instances
are a different syntactic categories you
have you have a keyword class and you
keyword instance and it's it has a
special case in the type interference in
Scala on the other hand typed eyes are
just first class traits and instance are
first-class value so you can do pretty
much anything what the language allows
you to do so for example for traits you
can fall for type classes you can embed
other trades injured for example if you
want to embed the loss of the type class
in there you can do that or four
instances you can obviously use macros
derive them so we have two full power of
the language at our fingertips so so
what does actually look like so this is
not actually the code in chapters but
it's similar so we have yes the other
macaronis just look have a look at the
return type you have a sea of tea and so
what does you see see is actually some
type class and T is any type and this
was actually what's going on here I mean
this is a macro which is a which is has
a potential to generate arbitrary
instances for not all types but a
certain subtype of a subset of case
classes and it requires this this type
class annotation here to make sure that
it's actually that we can actually
derive something for it and yeah that's
that's implemented with versa macro yeah
so as I already said it has been first
introduced in shapeless and it closely
follows what's possible in high school
by writing deriving EQ or deriving show
or something like that the mechanisms
are pretty similar and
the advantage is that this mechanism is
actually extensible without modifying
the macro so if you want if your library
also and you wrote an awesome type class
and want to have instances for generated
you just implement where is how to
combine instances in certain ways and
then you can just import it and this
macro will pick it up and produce
instances for your awesome type class
for you so there are obviously downsides
here compared compare these two variants
this is this is what I've shown you in
the earth on the other earlier slide and
this is with this constraint he removed
and the upper one is bad because this
actually is completely unconstrained so
this from just by looking at the type it
would look like this is able to produce
almost anything for example an implicit
list of in but this obviously makes no
sense I mean you just macros not pot its
not able to produce a list of info you
it is able to produce like for example
an ordering 4.2 d or something like that
for you but not some concrete Williams
so this should be kept in mind now
here's here's the bottom line our advice
is macros are great but are essentially
OPEC to humans so what you should do is
you should try to document what's going
on the macro using types and type
classes and other techniques really help
here so you should try to constrain as
much as possible so that a human user
can actually have a look at the type
signature and make sense of what a macro
does and doesn't have to look too
closely at the implementation of what's
going on yeah and and only the cogent
should only apply to the moving parts so
if you can put something in regular
Scala in planes gala you should do it
even if it incurs a little bit of more
little bit more overhead boilerplate but
you get more predictability out of it so
that's a plus one point which is still
open is that we don't have best
practices on documentation and testing
yet so basically what we have to do is
we have to write unit tests for our
macros for example this for this year so
we have just to plug in
different case class in here and test
where the actually something sensible
comes out of that and the same goes for
documentation we have to be pretty
specific about what's going on and we as
a community need to elaborate a bit on
what we expect from macro documentation
and macro testing okay so that's the
first discipline and here's to the
second one static checks and we have
seen that phrase today already in a
slightly different phrasing and the
really important sentence in here is to
proving the absence of certain program
behaviors and there's another quote I
don't know from Richard wall that is
said something like type systems are the
most most used of a kind of form of
verification by two orders of magnitude
or something like that what Peyton Jones
I'm not sure about that anyway so type
system allow you to prove the absence of
certain program behavior so a certain
class of errors can't even occur and
that's what that's what static type
systems are route and as we've already
heard in the first talk today Scala has
a sophisticated type system with
multiple interesting features here and
they are at least two turing machines
lying in there so we should leverage
that and we can do type computations
with it the mechanism we are choosing
here for this talk are implicit and type
computation using implicit scan solve
quite a number of interesting problems
for example high order unification does
anybody know 2712 the ticket so it's a
very long-standing ticket which
basically says if you have a function
which operates on functors for example
so it expects a type constructor with
just one type argument but you put an
either/or validation or something with
into it with two type argumentative
Scala compiler cannot make heads or
tails of it you have a type construct
was one argument here and was to type
with to type arguments there and it's
just like it can't do that there's a
trick called uh apply which is employed
heavily in scala set which uses implicit
look up to alleviate that problem also
implicit can enable generate
computations
on topples so on this for example
everybody takes reverse function for
granted I mean that's sort of the point
of list that you can also reverse them
and have all sorts of operation but
imagine I tell you right give me give me
a generic function which reverses any n
topple yeah that doesn't exist and with
implicit you can do all those of
computations in that direction also you
can have extensible records or or
statically size check collections and
yeah there's a library which makes all
that accessible and it's it's it's
called shapeless and shapeless is really
like enterprise-grade type computation
so it contains pretty much everything
you will ever need and I think miles
once said that he writes the boilerplate
so that you don't have to and that's a
pretty enterprise-grade so what does it
look like actually let's have a look at
the size collections so what's going on
here basically what you have are lists
or sequences or whatever but not only
it's not only the type of the list but
it has also an annotation and this
underscore to is kind of a type level
natural number let's let's not go into
details about how they are encoded but
the takeaway here is that the type
system actually knows that this list
here has two elements and yeah you can
also combine that with with you can
obviously build a list out of that stuff
again and it all works pretty well and
let's have a quick demo here at this
point I'm just going to define that that
list here let's say any Scala and as you
can see it has this this underscore to
hear in the type and now we can
obviously do something like tail a head
and here the head function is completely
safe because the compiler knows that
there at least that they are exactly two
elements in the list so head is
completely safe on the other hand if you
were trying to say like
the headers dot tail the tail dot head
it will tell you that there's something
wrong i would say could not find
implicit value for blah blah and then
your f to less than zero and zero so by
taking the tail twice you get exactly
what few elements and if you're trying
to take now the head of it you don't
have any element left and this is
exactly what the what does implicates do
here they are trying to prove that the
element you want to access is actually
in the list so this was pretty it is
pretty awesome and can help you know
sort of situation when when dealing with
when dealing with vectors or matrices or
yeah some data you read from anywhere
and to make really make sure that you at
any point in time you know what ex what
what is in your list so yeah computing
with implicit sometimes called pro men's
prologue and this this pro mens refers
to the fact that increases you can't or
you can't really do backtracking so once
you've picked an implicit you can't go
back and choose another one that's where
the pro men's come from so it has less
power than prologue but despite this
connotation of poor man's you can do a
pretty impressive things and who of you
knows what these are yeah so so there's
a talk by a Jorge launcher from the sky
lights changed last year and he actually
demonstrated that you can solve the
towers of Hanoi in scholars type system
and it's this it's this it uses like
functions with multiple implicit
parameters and doing stuff so you can
also some point try to searching for F
and hipster Alex and and see what you
find there though there are quite a
number of examples what you can do with
bush with implicit and I'm not going to
show that here because I I don't want my
laptop to grow burst up in flames but
you can kind of imagine what's going on
it's just like computing what this have
to be moved and stuff like that and it
takes ages to come five anyway it's just
like a proof-of-concept it works
if you want to so um let's go back to
macros why why why don't we always want
to do it with implicit them because the
problem is that those type computations
are very hard to debug once you have a
certain amount of complexity and there
are a couple of parameters you can give
to the Scala compiler like x log
implicit or a type of debug or something
like that and then you get either not no
output or screen loads of output
depending on which option you pass but
it's it's usually pretty hard to track
that sort of thing and sometimes you're
even run into corners where does just a
plain old compiler bug and you can't do
anything with it so and also he said it
slows down the compiler so last year it
and any scholar miles was doing a
demonstration where he said like where
he did some multiplication with type
level natural numbers and it pretty much
available until 22 but once he reached
23 like what you would see a slowdown
which wasn't it which wasn't feasible
anymore and also types don't cover
everything and sometimes we just need a
little bit of more pro at least in the
types of stew bri have some scholar at
the moment so why not just like throw
all types away and because macros can
just do anything and types have certain
shortcomings and for example you all
know this type signature and is you
assume you all love that type signature
and that's terrible I mean who does
under who understands what's going on
there can do from every seriously what
is going on so we propose this we just
say like oh let's sit just weary just do
our type checking in itself and we do
our implicit locket lookup itself and
now the macro has full control what is
going on and that is way better because
now you don't have this complex type
computers even matter is that you know
the this thing with Jen traversable like
and can build from it's something that's
work around it's in Scala doc with this
use case and stuff so we actually fix
all these problems by writing this as a
macro so users say they don't have to
care about this complexities you just
write a macro which does all the job for
them so they just go map and don't worry
when they see you it we are there are
messages so yeah we definitely recommend
them yeah awesome right
yeah so in all seriousness though there
are some reasonable use cases for
additional static checks in it was using
macros and here's another example from
spire again it's about check arithmetics
and this macro actually checks where the
computation produces an overflow at
runtime so we can this is kind of like a
safe wrapper around around this
computation X plus y lesson set and this
version of the macro will return and
none if it detected an overflow at some
point and obviously we could also do
that which was a much richer integer
type in Scala but then again you would
have to do the computations of adding
type level 32-bit numbers and this would
be horribly slow so yeah that's in our
opinion a good use case and another one
is for example the work remover by a
very mckenna and it basically it just it
boils down to that you have you have you
have a macro which takes some block and
then you can wrap something into that
block and it will tell you if you're
doing something completely unreasonable
like null or i mean you can all imagine
that there are some stuff which can be
prevented like mutating global state or
something like that so here's our bottom
line again for static checks use types
whenever practical and macros instead if
impossible or heavy weight or it would
just take too long to compute or
something and try to document an exit
encapsulate the magick using types just
like in the last discipline if there's a
way to constrain your macro using type
classes or something else then please do
it and there is no law preventing you
from not using across and ties together
all right so just uh just the final
third part of our talk and it's going to
be about these cells so well dear cells
a according to this well-known book they
can be classified in a lot of ways so
this particular classification it says
that dsl's can be either embedded into
the language or external to the language
plus we have some weird stuff like
graphing dsl's right so it's a lot of
ground to cover in this in this talk so
we'll focus on just one single use case
of embedded yourself and this use case
we will we will study an example from
sleek so sleek we it's essentially well
the part that were interested in today
is isn't embedded yourself for data
access and well so you can you can write
your sequel queries you can write your
database code in sicu and what slick
does it enables you doing that in normal
Scala code so these things are just just
made equivalent so how do we do that
actually and there's there's multiple
ways and we have exactly three ways
which is really good for our
presentation that i'm so excited to take
this as a case study so well first of
all we have lifted embedding that's
based solely on and right then we have
direct embed in something experimental
that actually was the direct motivator
for the scala macros project believe it
or not and finally we have a much more
later development from my colleagues
from EPFL i'm your invoice who did this
so-called shadow embedding which
combines both approaches and we'll see
how how it all goes so well first of all
let's let's take a look at lifted in
baton so we've lifted embedding you
essentially in called the domain things
for instance the fact that you have
columns so the fact that tables are
essentially well a collection of columns
in some sense you you express this in an
extra layer of types and so quite well
in the as large mentioned the scholars
type system is very very rich and you
you can state amazingly precise facts
about this stuff but well unfortunately
at times this gets heavy weight so if we
take a look at this example query and if
we try to print out at the types that we
use you do this using minus X print
column type or minus X print- types of
course then you'll discover that the
types here are not exactly what what you
think probably so we we don't operate
with normal values we operate them with
values lifted well what one level up
essentially
here's the guitar player and well this
this in itself is not a disadvantage
sure or what not ah it it contributes to
the too well to this heavyweight feeling
that we get from from from looking at
say this this definition and when it
when it really blows up and this is
something that large very quickly
mentioned is at error messages so
sometimes if you do something really
really unexpected then what happens you
get errors like this and you of course
cannot make any sense of it so what's
going on here I didn't realize this
myself when I mirror do the presentation
of his master's thesis in our lab and
and then Stefan commented that this this
all happens because sky lifted in bed
and doesn't support ifs so can you
imagine that so try connecting this fact
so yeah this is a this is just an
overall feeling of afflicted in bed and
it works quite well and it has well it
has a huge history that goes way back to
scala queria Stefan's original project
that became sleek but well there are
some downsides to that so enter macros
so what macros can can do for us here
well with macros we don't need the extra
machinery to virtualize Scala code I
mean take queries and transform them to
sequel with macros we just automatically
virtualized everything that's an
argument of a macro and therefore it all
it all happens naturally and well all
these types they're just normal types if
you operate on integers and on strings
here we go just come in some strings and
therefore well error messages they're
really going to make sense but here's
another problem and this is a this is
going to be a recurring theme that bars
has has cowards over and over again in
his part which is since macros can do
whatever we have to be really careful to
make sure that this whatever is what we
need and this is this is how this
listing manifests itself in direct in
bed and well so so here we go imagine
that we call to double which is a
function that's apparently unsupported
by slick so this is going to compile
just fine and it will explode at runtime
because macro is not smart enough to
check the two doubles I should not
support it and here's what you get when
you try to re-implement type systems so
when you try to reinvent something
here's what you get and we've already
seen that today and this is what what we
would like to avoid so how do we do that
actually this is why I'm super happy to
demonstrate this use case in this talk
because it's so it suits the theme
perfectly so we can combine strengths of
both macros and types into an ultimate
solution so here we have this thing
shadow in bed and development by my
colleagues at the pfl and it's based on
this union dsl framework that's that's
itself based on macros and therefore we
get all this lightweight well we get the
overall lightweight feeling from this
solution because well we're using normal
types but on the other hand we bring the
types into the mix oh thanks to union
dsl author can well can precisely
specify what what functions what classes
are allowed in the dsl with the well
normal means that are available in Scala
but traits with methods and stuff like
this so here we we can i omit the
details actually because we don't have
that much time but here we can exclude
to double from methods on int in this
particular dsl and well here we go we
get the best of two worlds we get a
lightweight solution that has really
comprehensive and comprehensible error
messages so it's all fine but there is
one caveat which is an implementation
detail essentially of our macro system
I'll beat an unfortunate one so the
thing is that that macros they don't see
a ste is this abstract syntax trees of
the entire program they only look into
the structure of their arguments and
therefore if you try to define a
function somewhere else and then you use
it inside inside the sleep block well
nothing good will happen so that's an
unfortunate limitation of the current of
the current macro engine
that you have to keep in mind so anyway
just to sum it up our advice here about
building dsl's is that well types they
provide a really well working solution
that can do a lot and it can do a lot in
the dsl department however macros have
pruned themselves as a good way to make
this to get a lot of traditional
ceremony away which makes life easier
both for dsl authors that is you have to
write less boilerplate to design it
yourself and for dsl users because well
you get comprehensive comprehensible
error messages and this is quite nice
but just just keep that in mind that
with macros there are some problems and
but actually these problems are not
fundamental to the whole concept of
compile-time meta programming and well
actually we are working on this and this
is something that hopefully I'll get to
present in tomorrow during the
unconference so anyway just just to sum
it up again and again if you go with the
compile time at a program in route with
macros please try to document your
interns at any point so types are
amazing at documentation and providing a
static method data that the compiler can
then validate that your users can
eyeball and make sense of so try to
write type scriptions as much as
possible if you're using macros alright
this brings us to the conclusion of our
talk and just just to sum it up what
we've heard today so well types are
there declarative but they they get this
declarative pneus at the expense of some
power loss and sometimes you do need
this extra power to pull off some some
really complex stuff and here we go
since scholar 210 you have macros and
macros are amazing they give you as much
power as you need and even more and so
you can literally shape the language to
your will and that's quite nice but
unfortunately this comes at the price of
being opaque and been volatile in a
sense so this is the initial dilemma
that well gave rise to this talk and
here's where we started so what's what's
the bottom line well the bottom line is
as we've seen both macros and types they
have their strong points and viewers
well program designers you have to be
aware of them and you have to make st.
choices so essentially embrace reason
and use whatever works best for you
whatever simpler right but also another
takeaway from this talk is that it's
possible to combine this this
declarative pneus and this understand
ability of types together with raw power
of macros to achieve ultimate glory and
I think this is quite nice that Scala
provides us a way of doing that that our
macro system is actually so nicely
integrated into the language that it can
make use of type system in multiple ways
I guess so this is it and thanks a lot
we've we're a bit early so yeah please
ask questions all of them thanks
well this is actually a fusion reactor
so here we have types magnets and here
we have a thermonuclear explosion but
here it's all taken under control so now
the question was about performance
implications of well the choices that
you make when you design these cells
whether you do a purely type based
solution the macro based solution well
as we've seen before in the cogeneration
section with macros you essentially can
produce whatever well you can decide on
the level of code that you produce it
can be high level it can be low level
whatever works best for you so just an
intuition is that with macros
performance shouldn't be a particular
problem but well type based solutions
depending on the implementation strategy
that you choose for instance if you if
you use a lot of implicit that are then
carried that the runtime and you call
well methods on those in places this
might incur some performance penalties
because well you have to create these
instances but on the other hand some
type based solutions they're just purely
static and that stuff is erased at
compile time and at runtime we get very
fast code so the answer is it depends
yes sorry another example here with
people would be the computation for
natural numbers in the type level so if
you have if you would if you write would
write it within the with implicit and
you have tried saying that the type n
and the type em together give give give
you some what happens is that that you
actually get a runtime representation of
that even if you don't need it so that's
why sometimes implicit are called
evidence because you can actually help
you actually have approved that
something hold for example that the
reverse of a tapa list if other tuples
so you can actually use this to reverse
reverse at Apple and you will you will
get that even if you don't need the
evidence in the end for example if you
just if you're just witnessing the the
sum of two type letter natural
but you don't really need something with
to do with it in the end but
nevertheless you will get this whole
chain of implicit to be to be compiled
and potentially evaluated and obviously
you don't have that problem with macro
so you can a light that whole
computation if you want to ah well I
guess it's too much to actually sum it
up in a couple words so essentially we
are experimenting with a new macro
engine that would well that would
provide more introspective capabilities
and would fix a number of one standing
problems that are fundamental to the
current implementation for instance
separate compilation which will be gone
but more details really if I get chance
to talk tomorrow I have a whole set of
slides that are going to present
something so the question is experience
about debugging macro code and the short
answer is probably there's a compiler
switch for macro debug and it will dump
the code generated by the by Damac
portfolio and in some cases you are
really doing if you really want to know
where you code very generated code burns
wrong you just have to what you
basically includes you can copy paste it
in some way because it's pretty printed
and put it into extra salsa and then
debug that and yeah so yeah that's you
what do you have a longer answer well
essentially speaking of debugging we
have two aspects of that the first
aspect is how do you debug well the code
generator logic and the second answer
how do you debug generated code so the
first question has an easy answer you
just use whatever means of debugging
that you have so macros are normal
functions that that are executed by the
compiler so you fire up the compiler and
your debugger or use prints or whatnot
and yeah you you get this a new debug
this as a usual JVM program but speaking
of generated code yeah this is stuff
because well no one actually gets to see
it and well this is also something that
we're working on in this
bigger project with r engineering of our
macro engine all right but you don't see
the source code so therefore for
instance where do you put a breakpoint
on and so what what should your ID
display so of course it can display JVM
bytecode but that that's probably going
to be low level so you have any when you
have a macro invocation every in the in
the compiled source code all the
generated code would have the same line
number and it were just like if you're
fired and I'll be dubs in the debugger
it will just be that one line and this
is the macro call and not the expanded
called by the macro yeah that's right so
please go ahead okay okay so thanks a
lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>