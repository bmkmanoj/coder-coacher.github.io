<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>02 - The Android Stack: Android Bootcamp Series 2012 | Coder Coacher - Coaching Coders</title><meta content="02 - The Android Stack: Android Bootcamp Series 2012 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>02 - The Android Stack: Android Bootcamp Series 2012</b></h2><h5 class="post__date">2012-02-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1iaQAzt5FyM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so so that's a little bit about the
versions so we're gonna talk about the
stack next so and write a stack so any
questions have done this so far
inversions everything makes sense yeah
okay so let's talk about the stack what
we've got going on here so basically you
guys probably saw a picture that looks
similar to this this is essentially the
high level what the entire Android
operating system is like now let's talk
about each piece separately and we're
gonna but just by the way we're gonna
sort of do it this way
so we're gonna go bottom-up so at the
bottom of it all we have the Linux
kernel right so angeles-based is built
around Linux kernel now it's not it's
not Linux it's an external right so a
lot of people you know think oh it's
it's another flavor of Linux possible
like Ubuntu is there something or one of
those basically handled is built around
the kernel itself so you know that 1.5
megabyte file out of you know a couple
of hundred megabytes that we have as
part of the entire platform so it's it's
a very small piece of the whole puzzle
now the question is why Linux kernel why
why did it pick this is a sort of the
basis any ideas the cost the price is
good right price is right it's open
source yeah although I'll double click
on that because open source means many
many things any other any other
suggestions so remember one of the
things that I pointed out was this
vision right and we said we want to
create a platform that's gonna run on
many many different devices so one thing
that that Linux is really good at is the
amount of the driver model for Linux is
pretty well understood
we actually know how to pour clinics to
many different platforms right so that's
a big benefit of Linux but we can easily
make it thrown on Qualcomm chipset or
you know Intel chipset or MEPS chipset
or and different things like that so
that's that's a good thing um secondly
Linux is very secure so basically it's
an operating system that's been in very
harsh environments over the years and we
know quite a bit about the security
model so that's a good thing as well for
fer endureth and I know some of you are
involved with the government work so you
probably consume about security just an
extension so that that can actually it
has some really strong plumbing for
being a very secure platform and
although there's a lot of shortcomings
today but there's a thing you know we
would predict are gonna be cashed out
unlike unlike for example a blackberry
which most enterprise folks would
consider you know the gold standard for
mobile security and Blackberry trusts is
security to Java it uses Java security
model the model Andrew it doesn't and it
actually passes a security down to
kernel so it's Linux kernel that is the
because the final say in terms of who
can do what and that actually is very
significant because it allows us to do
some really cool things in Android that
I'm never gonna be possible on
blackberry right up until the next
version right so for example you could
not have native code as part of your
BlackBerry app ever because that would
break this dollar security model um in
Android you can so for example if you if
you want to create another angle Birds
game right you can do that physics
calculation that you know physical
physics engine you could do that in in
CC examples pose and make it run really
fast right and still make it part of
your application and still distribute it
for the market and still have everything
be super secure
so so inconsistent super-secure what's
the why is it bootable and so forth so
the plumbing for Android is really good
in terms of the Hogs design there's some
there's some other shortcomings one has
to do with the the fact that we the apps
are distributed so so a couple of things
that are sort of problems one is the end
has do most malware spyware things like
that the bad stuff right out of any
market and that has to do with the lack
of curation on part of the stores so
Google's Android Market for example
doesn't do any curation so basically
anything is a lot even gonna be bad apps
that's a problem number one problem
number 2 with respect to routing and
stuff that's just because it's an open
system so a lot of other people are
creating alternative versions of Android
like a bootleg versions of Android so
basically you can buy a phone but you
can re image it with another image that
then gives you for example access yes ok
so so Kindle Fire is based on Android
but it's not a Android compatible device
alright so whatever it does is you know
it's kind of like it's just a modified
version of Android altogether and yeah
that's that's just called it designed it
it really has to do you know to route
the device you have to basically get
readwrite access to the system partition
which we'll talk about later on and to
do that it's usually it's usually the
bootloader that's the weak link so
getting the alternative bootloader you
know it makes it makes it easy so in
certain companies like HTC for example
they're now just providing that unlock
they're like hey you should be able to
California if you want to its just
philosophical difference right whereas
other platforms like you know Blackberry
or iOS where things are sort of like
very vertically integrated they
just don't want you to yourself in
a foot right so that that has a little
bit to do with that so you do not need
to worry about that too much as an app
developer this is you would care about
this more as a platform developer so
basically when it comes to Android you
know you guys can wear two hats right
you can be an app developer a developing
apps that's your final shippable is an
app you could be a platform developer
your final shippable in that case is an
Android system so I can modify the
Android system like a signage anything
like that or I know Qualcomm there's a
lot of internal stuff and actually
Qualcomm now is the gold standard for
build systems so it's not even Google
anymore but it's a lot of carriers now
go directly to welcome to build stuff
right so got some stuff really down well
so so yes it is based on UID sim GI this
but no you do not as an app developer
you don't care about it too much but
back to back to Linux like like I said
it's not your standard Linux so instead
of Linux you would expect to be able to
create users right on Android you can't
do that there's no et Cie password file
right now so you user user management is
done dynamically it's actually a C file
that's compiled into the platform it's
kind of weird you don't have a fast app
you don't care your standard like you
know you don't have windowing toolkit
there's no x11 there's no one even Lipsy
library technically so there's there's a
lot of things that are stripped out that
you would expect in a typical Linux so
so that's a little bit about Linux
Android trusts it uses it a lot for like
things like networking drivers radio
drivers things of that nature so on top
of that we have native libraries and
native libraries are basically things
that came from the other well we usually
came from the other open source products
so for example you guys who did phone
stuff PhoneGap is based on WebKit which
is basically just an open-source project
to be copy pasted into Android platform
media codecs OpenGL SS open SSL all
those sorts of things have copy paste
board one sort of notable difference is
Bionic so for those of you who did see
C++ you may know that there's something
called Lib C library right that's kind
of like your core C library well Android
doesn't have it it uses something called
Bionic which is basically a rewritten
version of Lipsy from comes from BSD
project and has to do with licensing so
so that's that's like a slight
difference in terms of that by the way
do you guys know much about open source
in licensing in general so this is the
talk that they did and what it means to
be open and as part of that I kind of
broke down the open source licenses
basically we have about in open source
world you have hundreds of different
licenses right there maybe like a dozen
that are more commonly used but
essentially you can break them into two
buckets in terms of what we care about
and it breaks down like this I basically
put it all based on you know does the
derivative work fall under the same
license or not right so that's the
biggest question is if you if you derive
some work does that work you have to be
part of that license or it could be
something else so if it's yes that that
means that you know it's ultimately your
code is gonna fall under one of these
major licenses either LGPL or GPL right
if it's no okay then your work is gonna
fall under one of these licenses Apache
MIT or BSD okay so if you think about if
you if you go back to that vision that
that we cared for for Android which is
basically you have many you know you
have a mobile platform or the terms for
many many different devices that means
you're going to have to have
other companies work on this project as
well right so that that will basically
mean that you would want companies like
Qualcomm or HTC or Samsung Motorola to
be innovating on top of Android gaming
they're engineers working stuff so for
that to be feasible presumably those
companies wanna retain the rights to the
stuff that they do so basically in
Android we try to do most of the things
under this room to be friendly to those
entities right so that's sort of the
goal in terms of Licensing and if you
look at the entire stack right so the
apps most of them are open Apache 2
license so that's in terms of the
absence of shifted android framework is
all open it's also patchy to license now
libraries are pretty much all open it
was some kept they've different licenses
depending on if they come from other
open-source projects but usually don't
derive work there so it doesn't really
matter the most problematic is basically
the bottom stack and it's problematic
because we have two extremes right on
one extremely cap overly open of the
source license which is like Linux right
which is GPL god so anything that you do
on top of Lennox you have to push back
to the links Linux community that you
don't get to keep it
so it's overly open on the other hand we
have proprietary stuff like drivers
right so for example if I want to modify
a create an android that ran some new
Samsung phone
well I'm likely not gonna be able to get
them some pieces that they're key pieces
like to drivers for Adia to drivers for
GPS the drivers for screen setter subtle
that tends to be a proprietary code
number release so so those are some
doesn't that that's sort of the part of
the stack that's slightly problematic
caps licensing so so that's kind of good
to know that explains why we have Bionic
one of the main reasons is the licensing
to basically bypass the LGPL nests of of
the of websi library there's a
apparently
it's kind of like a gray area there's
not a lot of sort of lots of cases out
there but if you statically link against
LGPL code your code should also become
LGPL code so that doesn't work for
Android very well so that's why they
kind of change that that's a little bit
about native native libraries any
questions from the other Oh
so one of the things that we have there
is a in that stack is something called
dalvik a pelvic is basically the
replacement for the Java Virtual Machine
yeah
now most of you does anybody not know
what Java VM is mostly you have some job
experiences right okay so so you guys
know what Java VM is so why would they
replace a java virtual machine
what's wrong with the standard Java but
they're basically two things two good
reasons one is the business reason one
is the technical reason so from the
business standpoint Java VM costs money
don't buy Oracle if you want to license
it you would have to go and line up
around the Oracles building and you know
kind of have them take you to the
explainers together licensing in place
and so on and so if that was the case
that do not work very well with the with
the mission of Android to run on many
many different devices and the family
had to go to Oracle for licensing that
would not be a very good friend
so dalvik is freezing of Apache 2
license you we don't have to worry about
that but more importantly it's the
technical differences okay
so Java Java was designed to be sort of
one size fits on all VM so you have it
in tiny old blackberries and then you
have it in new super computers right
well over the years most of the
optimization has actually been in the
supercomputer arm right and the what
your web far and web servers things like
that so it's been optimized for that now
when it comes to optimization Java is
being designed to work on mostly Intel
based computers right that's what you
got in the data center
the problem with that is that in today's
computers tend to be designed for
devices that are that can have as much
power as they want so when it comes to
mobile one of the constraints that we
have is the battery it's actually a
single biggest constraint it's gonna be
the so Intel chips tend to run warmer
use more energy than ARM based chips
so a dogging sting designed to run
register based chips as opposed to stack
based chip chips
so which run tend to run cooler right
that's why your phone doesn't heat up as
much it doesn't use it as much battery
so that's one of the reasons why why we
have the call it's been it's been
optimized on secondly if you think about
the standard computer you guys may know
this but in Java what happens is when
you want to instantiate an object right
what you do is you or not you but the
virtual machine go to the file system
finds the class file then loads it up
into memory right and then it creates
that object which makes sense because
your hard disk is slow right your hard
disk is spinning it whatever 5700 rpm or
so that's it's relatively a slow medium
and you want to lock it up in RAM which
is much faster and you have a lot of it
right the problem with mobile is that we
don't have a hard disk so there's
nothing spinning in here hopefully right
so we have RAM and we have you know
flash and it's about the same speed
right so and we don't have a lot so
there's no point in actually doing that
copying right so topic does some
interesting things where it only copies
on right when it actually changes stuff
right so if you want to actually
instantiate an object you can just point
to it on a disk and say there it is so
it's kind of it does some interesting
thing things to say cut down on on on
memory consumption and so forth so it's
Boston but mostly battery and memory
optimized for mobile devices
a little bit of trivia the name dalvik
is
dalvik is named after this village in
Iceland it's actually a fisherman
village in Iceland and that's what it
looks like it's got a church that's
about it
and it's actually designed by
coincidentally by my neighbor Dan
Bornstein we are in the same five-unit
building in San Francisco and so he
works for or worked for Google and he
built dalvik from the start he named it
and everything he's no longer there and
this is all tribute to that I got this
license plate but it's on Sasha's car so
if you see a little bit of golf with
dalvik that's our license plate
yeah and also public is the centerpiece
of the of the lawsuit between Google and
Oracle which I'm sure you guys yeah so
Google TV does run on on intel-based on
x86 chips because a we don't have a
battery constraint right so these these
are devices that are plugged into a wall
so Intel's they've been working with
Intel to basically port and read to to
dalvik to code to Intel and dalvik is
written in such a way that it's fairly
straightforward to do a basic porting so
most of it is actually an SE C so
there's a version that you can just
easily pre-compile cross compile for
different architecture so it's running
on mips it's running on Intel it's
running on arm five and seven and so on
there is a version that's then optimized
I think it mostly has to do with reading
how it works so so if you want to do
optimization you can but that's that's
the main type of stuff that they do
optimization the if you just care what
chipset like I was when I was involved
in a Maps project you know just to get
it going it's relatively straightforward
but then the optimization is something
anything keep on going for a while so
compared to the java vm what are the
cons of dalvik well for for
so Java VM is gonna use more more juice
more memory let me let me let me show
you a picture and then we'll talk about
that so so so in standard Java this what
you guys do you you write Java code
right you compile it using Java C
compiler you get your class file and
then you run your class file on top of
JVM right I'm in Android you do
something very similar you write the
very same Java code you compile it to
the very same compiler you run it you
get a very same class file then you
recompile it once again with something
called Dex compiler okay and then you
get something called the dot d de X dot
Dex file
that's your dalvik executable right so
you put the dalvik executable on top of
dalvik VM and you run it there so these
steps are sort of new now they keep in
mind when you guys do app develop and
you're not gonna care about any of this
because it just magically happens right
but it's just more FYI that's really
what goes on behind the scenes so a
couple of things that that are different
so for example in Java when you get this
file the class file what you do is you
collect all your class files into a jar
right and then you apply zip to it so
you have a compressed jar well in so in
Android we don't do that because of
remember we only do copy and write in
other words we can do that thing where
we just point to the file system to load
the class right so that's why I sip
wouldn't work very well so we keep this
uncompressed but even uncompressed
bytecode dalvik code is smaller than
Java bytecode why is that
well Java is very verbose so when Java
compiles you can actually decompile it
and you get back
like everything you including the the
class there everything said the comments
I think you get back like all the
variable names and all that right
so dalvik compiler one of the things
that it does is optimizes the code to be
much smaller so it essentially does
obfuscation but not intentionally so
makes it much smaller so that's why even
uncompressed it's it's smaller
compressed Java right so that's one
thing so that that is much harder to go
back to decompile it so does that sort
of make so can people break into your
Dex file they to a certain extent it's
not as easy as Java but yes it's the
compiler bore yeah so that's why since
recently we the Android tools introduced
a ProGuard which is turned on by default
so basically whenever you do a build
it's gonna do a certain level of actual
obfuscation of code so that your code
becomes less legible ultimately
everything is reverse engineer all right
like it just the question is how hard it
gets right you can take C code and D
compile it you just get gibberish and
it's really hard to assemble it back
together job is really easy to assemble
back together so dalvik is now making it
harder even harder with ProGuard yeah
I'll show you ProGuard tool when we get
to actual in the world yeah um so those
are a couple of things with us now what
was interesting about this architecture
I was wondering why didn't they just do
this I mean why wasn't Java source code
compiled directly down to dalvik
bytecode like why do this extra step
right because this is really a
disposable piece of code right well what
I thought was really cool is that they
basically took a took word Java compiler
and it does well and then they built on
top of that so didn't really reinvent
the wheel so this is relatively small so
that's a good thing but what I thought
was even cooler was that the fact that
you
can basically you don't have to write
Java code you can write in anything else
that compiles down to two by two Java
class following Java binary code right
so that's where I fight on biotin and
Ruby and things like that becomes very
interesting in Scala as well right so
any VM based called should run on
Android right which sounds great
yeah the scarring from efficient is 3x
slower I'm not sure I did not know that
it's that that slower so I'm not kind of
percent sure about that so yeah so you
also wanting to keep in mind is what
what it means to be slow and where it is
slow so for example dalvik did not have
a just-in-time compiler for a very long
time right up until optical friable
and I - their team and I was like well
you know how come right I mean it's it's
an old technology right the implement
thing adjusting thank compiler and why
not just be CAC something together and
Kevin there wasn't it like sort of on a
must-have list they're like actually no
most of the time your app is just
sitting there it's actually not running
right like you know if your standard
application right you're just waiting
for you to enter something and you enter
something it does something like quickly
and and so on so actual execution time
doesn't really matter for most
applications now where it does matter
our games right so games are our sort of
the actual code is the execution is is
important so that's why you you things
that need to run really really fast you
can do them in C C++ via something
called NDK again native development kit
so for example you know your Angry Birds
you're gonna do the calculations your
physics engine in C C++ and character
and really fast
now dalvik did get eventually
just-in-time compiler and it's based on
and in the code now around two to five
times faster but there doesn't again
doesn't mean much so because most of the
apps you don't have a lot of code it
actually does and then there's some
really interesting ways how they
implemented dalvik just-in-time compiler
it's quite different than for example
Java code and so forth like you guys
heard of hot spot a hot spot engine the
Java doesn't time compiler so things
that Java does it are optimized for code
that is like for example web server code
right so in a web server code you know
you can't first of all you have plenty
of disk space so Java for example uses
something called a method based
just-in-time compiler so basically it
each method that you touch like a
function then it converts to native code
the entire method right so that takes a
lot of memory right well that's not a
problem many hard drives are cheap right
the other problem with that is that you
need to run your code a while to
actually get a substantial amount of it
be converted to native but that's fine
on a web server you just open up a web
server right you have bunch of people
use your you know ecommerce app or
whatever and very quickly you ran it a
lot of times right well on these things
it's quite different experience right
imagine that I had an app that they
download it that I need to run use it
many many times before it actually gets
substantial very compilation right so
that doesn't that doesn't fit on on a
tiny phone because I'm the only user I
don't have hundreds of what users giving
my app I'm the only user so that doesn't
work and we don't have a ton of disk
space right so dalvik for example is a
totally different approach it uses
something called trace based jet so
those are some fundamental differences
again between Java and dalvik in terms
of other work cool so so that's that's a
little bit about this by the way what I
wanted to point out here also is that if
you guys are job
developers Androids job is based on Java
standard edition so basically you have
everything you have in standard Java
right so you know you probably how do
you do you know Android
I am input/output just same way is you
do it in instead of Java how do you
threading same way you do it instantly
job so a lot of these things are
identical right the biggest difference
what its gonna be from standard Java is
that we yanked out anything that has to
do with UI so there's no AWT there's no
swing again and then we added a whole
bunch of new things but the point is you
have everything almost everything that
we have expenditure plus more so so back
to this so that plus more is usually
this round here application framework
right so this is that you know keep in
mind so far this stuff here was mostly
legacy stuff right I mean some new stuff
I guess this was new but a lot of these
things are copy pasted from other proto
code and it's a lot of legacy projects
and so forth this stuff here's brand new
right purpose-built rendered so as part
of that we have the application
framework an application framework is
basically exposing the capabilities of
the platform to the apps so remember
that API level 1 2 3 14 that essentially
communicates what is possible here so if
we say we this yellow line is at API
level 14 that means I can expect certain
you know pin soon you know things that I
can use that my app can can run again
that's what that means
yeah it spelled out there's there's an
XML file that says at the API level 14
these are the classes and these are the
methods on essentially the FBI yeah if
it's deprecated API I mean still gonna
be there it's just that it's one of
those like you should not be using it in
the future so that when the API is
deprecated that usually means
that there's a newer alternative to it
so your new your code should be using
the new alternative the problem is that
what if you didn't make a business
decision that you are going to support
the older code so you find yourself in
this interesting place where you
actually have to use the applicated code
so eclipse is gonna give you keep giving
you warnings things like that but you're
like look I know I'm using deprecated
code I mind you know I made a mindful
decision to do so because I wanna my
minimum has the support of them
projecting back is you know requires it
so as long as you know but if you if if
you're not if you're you know say for
example the minimum you're gonna go back
is like 2.0 right version of Android yes
exactly so then it's not deprecated
stuff is not gonna go away it's just
that so you know pretty much guaranteed
it's gonna be there for a very very long
time possibly indefinitely but there's
usually means there's a better
alternative so unless you have to
support at older version you should use
the better alternative and sometimes I
mean it's not the cleanest API in the
world like sometimes they're just kind
of like don't like a certain class and
now because they have to support it for
a long time they can't really rip it
apart and change it so so you're gonna
find things like you know for example
test case there's a J unit testing
there's test case but then they didn't
like it so there's test case too so you
care a lot of this like - why why -
because the one wasn't good good enough
but they can't because of the backwards
compatibility they can't just rip it
apart
what the expected expected length of
time your app there isn't really a
there's no such metric per se do you
only think well time kind of matters is
it's actually there next slide is for
the applications apps must be signed
right so you must sign your application
and actually most stores are gonna ask
you for 28 key that's good for 25 plus
years right so that's sort of one of the
best practices when you sign your app
which I'll show you how to do later on
you should sign it with a key
that's law a good screen for 25 plus
years and plus you should sign all your
apps from your organization with the
same key right so in other words that
key is really important so if you lose
it you know you're in trouble
right you know I'm going to be able to
prove that the app stores so yeah so at
the end of the day we have apps and so
what roughly what an application is it's
gonna be some dalvik code some resources
so basically resources are things that
are not code all right so your app is
gonna have some executable but then your
app also needs things that are not
called what kind of things do you have
any nap that's not code icons media XML
strings yeah those are all things that
are not code we'll talk about that quite
a bit yeah so so that's that's another
thing and then you may or this is
optional you may have some native
libraries like in an Angry Birds app you
may have your physics engine as a secret
right
so all that ends up being bundled in a
file called apk that's your final
shippable it's actually a zip file you
can unzip it and see all the moving
parts inside so that's essentially what
that is so that's a little bit about the
the apps ultimately apps you can you can
distribute them once your item you can
distribute them in many different ways
one of the main ways is to put it in a
store so you can sign up for for example
Google Android Market pay 25 bucks and
you can
go and put your app up there and it's
available right away
no it's not free to sign up for Google
but you just pay 25 bucks and once and
it has many apps as you want then you
can you know do all that stuff so so
right from the get-go Android was
designed to be a ecosystem in which you
don't have a single store but you have
many many different stores which is
really cool right it's very unlike iOS
with an app store or blackberry world
and so on but in reality in practice you
know you only have the Google and market
right Google's Android Market so that
wasn't so good for the ecosystem up
until recently Amazon has been making
some progress for their market so it's
actually there's now a second big one
but what we're seeing is a whole bunch
of small stores emerge right so I'm
seeing this in the enterprise world a
lot right like for example cisco has
their tablet you'll see s tablet well
they're not gonna allow it just to go to
market and download Angry Birds or some
other malware right so what they want is
they want to create sort of a highly
curated enterprise-grade app market
right so they would do some manga so a
lot to mentor even smaller companies
could do something like that internally
so we're seeing a lot of sort of
boutique stores emerge that's that's a
good that's a cool thing so you can do
that so those are the markets
sideloading is basically a process of
taking that apk this is that file and
somehow putting it into the into you
into your device it doesn't really
matter you know if you put it on a
website you email it to somebody or you
simply do you do it by a USB cable right
so you can just be walking the cable and
push an apple so that's that's called
site loading or you can create your own
app directory basically your own
application so that's a little bit about
the the stack that we can at this point
so any questions about the stack sort of
the big picture what the under the
operating system looks like so far yeah
so if you're gonna develop a game do it
in C or gel what I'm seeing is I'm
seeing a lot of game developers do as
much as possible in C I went to some
talks that you know yeah I mean I think
it's a majority of the code is written
in C like something like a 90 plus
percent right so one reason for that is
speed but I think them the other more
pragmatic reason is that that's what
they're familiar with all to this game
developer some more of a C type of
developers any con so you know speed is
sort of like I would say a second reason
not not not in everything and not always
is C gonna be faster it has its
advantages
you know certain computational things
and so on cuz remember dalvik does get
compiling to make it as well so at some
point the difference becomes really
minimal one thing we we do one of the
exercises we do for NDK for writing
native apps is we create this Fibonacci
example and what I like about some
through notch it's that it's super small
little examples it's very small
algorithm it's exponential in terms of
the output wave goes and in its
recursive so we actually implemented
recursively first and you actually get C
code outperforming Java about two one
order of magnitude so about 10 to 20
times faster 10 to 20 times faster but
the reason it's mostly the recursion if
you do it iteratively you know you can
any recursive algorithm could be written
ism as a look right so if you do it
iteratively it's actually sometimes even
slower to do to do it in C because
there's assertive doing the bridge the
J&amp;amp;I bridge the bridge from java to see
and back
so for smaller jobs it's more actually
cost cost effective to just keep them in
java than to out sort of the same but
gingerbread brought into the mix
something
native apps are no native activity which
is basically a way to write most of your
Android code in C or natively and that's
mainly to support in gamers so if you
write C code it's more portable as well
you're right and it's actually kind of
funny because I mean Java was supposed
to be that write once run anywhere a
code right I mean that was the whole
selling point of Java was that
portability portability and now we're
back like 10-15 years later you know
you're writing brand new code in in C
right why would you do that
one reason for C's like I said
performance that's way the main reason
the second reason is gonna be legacy
code like you have some you know you
know I worked with a company that did
wrote a DRM solution and you know they
voted like over the last ten years so
they have this big chunk of code that
they just don't have time to rewrite to
drop so they just want to wrap it in you
know J&amp;amp;I and expose it to hundred but
the third reason which I thought was
funny was the portability and there's a
company called my lookout you guys may
use it it's it's kind of like a virus
protection on your phone you know I'm
talking about so it's it's a free app
and it's pretty popular for protection
it's actually company here in the city
and so their CTO actually spoke at SF
Android our local years ago and so they
do all their brand new code in C for
portability reasons so it's interesting
back at square one so any other
questions from this so far okay so with
that let's do this so what you're gonna
talk about next is we're going to talk
about the kilo world example</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>