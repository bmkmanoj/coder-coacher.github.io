<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>No More Tools | Coder Coacher - Coaching Coders</title><meta content="No More Tools - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>No More Tools</b></h2><h5 class="post__date">2016-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gpjmo8Khyzo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hello is everyone awake because
i'm not i'm super jet lag and for me
it's 10pm or later right now so i'm
basically falling asleep because i've
been awake since free am but um we're
going to talk about tooling um just a
little bit of a check out who's doing
front-end development as in like HTML
and CSS without JavaScript so to say
okay cool cool okay so you might have
seen me in the morning opening the
conferences and I didn't really
introduce myself because I really like
to to do so but i'm currently not I came
from Poland I work at a digital console
cincy cold and yet and you might have
heard about as because of lift security
talkie which is a WebRTC vice
alternative to hangouts or ever Sanjay s
so we're here to talk about tooling and
if you think about tools in general
without the software context first tools
are dated four million years ago which
if you think about objectively it's a
lot of history and since I really like
definitions let's define what what a
tool is so a tool is usually a physical
item that can be used to achieve a
certain goal and I think that in our
software software engineering contexts
is it's a process or procedure that is
serving the specific propose so when we
think about the world we're living in
right now in the context of software
engineering we are living in a separate
abundance of tools and they are bound to
make our lives easier and tasks
completed faster but is that really
always the case how do we determine
which ones are good for us how do we
determine
which ones are making us more productive
and which which are in we have so many
options per frame where with so many
options for for tools so many
technologies that are coming up hearing
every single day and frameworks that are
peeing on github I feel like a lot of
people are assigning empowerment two
choice of our tools bless you but it's
not the tool that actually makes us a
great developer or a great designer but
our skill um and I really love this
quote from from paul jarvis from his
book to get creative if a carbonyl loses
has nail gun and has to use a hammer he
doesn't become less skilled a programmer
doesn't forget how to code if she
switches computers or even programming
out applications a writer stories are
nil is valid because he changed from
black to blue ink creatives aren't good
at their art because of their tools
their talents stems from the skills and
knowledge they've acquired while using
their holes so of course why do you
think when we think about tooling dara
dara very helpful and there's a decent
amount of influence over our speed of
work and the quality of our operations
but still the question remains how do we
find which ones are very helpful or us
and in which which can bring potential
harm so i want to i want to ship our
gears a little bit and talk about
simplicity because when we are trying to
define this subjectively right tool kit
for ourselves and our teams i think is
very important to think about simplicity
and complexity as well and suppose it
keeps appearing in the discussions about
design and software in engineering but
what is simplicity what what does it
even mean i think that a lot of people
are not understanding simplicity right
and they didn't pay attention to the
fact that simplicity is kind of
misleading why because there are two
types of simplicity one of one of which
is visual so it's me looking at things
and in determining which is which
whether this tool is
I'm simple to use but not really using
it so kind of looking okay this looks
simple but it's not necessarily very
simple and operational so when we
actually try to use something and and we
know for a fact whether it's simple or
not so when we're trying to define
simplicity we could kind of say that
simplicity equals sanity in especially
when thinking about technology at the
end of the day technology is supposed to
be helping us in any way possible but on
the other hand when you think about the
amount of toiling and information that's
available for us every single day online
it kind of makes us uncomfortably full
in in a way so we live in a super
abundance of information and the most
crucial skill is not multitasking as it
is advertised usually but single
threading our attention so we said that
simplicity appears and discussions about
software and design as well quite often
but this right for simplicity is kind of
superficial and the cry for simplicity
misses the point why because we want
simplicity but we don't really have a
deeper understanding what suppose it
means and we think that by default if we
simplify things it will makes make stuff
easier our life was it will be easier we
won't be confused anymore our problems
will be solved and it will get rid of
all our possible frustrations that we
might have but we fail to notice that
complexity is necessary and it's an
essential ingredient for for our rich
and eventful lives talking about
software or just just in general
complexity is the fact of the world
simplicity is the end of mine so we want
to be more capable we want to be more
empowered by devices and by hardware by
tooling but but we fail to understand
that simplicity correlates to complexity
and they live together at the same level
so we define simplicity but we haven't
defined complexity yet complexity can be
defined by determining how much time it
takes to
learn a certain item or how to how much
time it takes to complete in action so
basically complexity resides in our
understanding of how things work because
humans create conceptual mental models
of how physical objects operate and when
we think about complexity we tend to
forget that we accept complex solutions
in our lives every single day all the
time which is we are just not paying
attention to that so complexity is the
constant and whenever thing about
software when we decrease user-facing
complexity it always rises somewhere on
on the back end which is why I'm
bringing out Tesla's law of conservation
of simplicity every application has an
inherent amount of irreducible
complexity the only question is who will
have to deal with it you as a developer
or the user so tools are bound to save
time that's what we want in savings and
time feel like simplicity which is why
in my opinion technologies like node are
very appealing because they dare
everything is fast that makes me save
time so I can use that time for for
something else so there's an implicit
benefit in good tooling because we can
use that time for for something else so
we jumped through some simplicity and
complexity as well so let's shift our
gears from the super abstract talk to
something more more tangible related to
two different and background where I'm
coming from so when we think about
front-end friend systems we we think SAS
less stylist and preprocessors and post
processors templating in just like jade
or ham depending on whether you're
working in node or Ruby whatever else
but when I think about those
technologies we are forced to watch
files in run Bell tasks and bolts and in
most cases we are also forced to run
performance related tasks such as
minification kannada
image optimization so we we have a lot
of process that we have to manage which
is when automation comes comes pumps up
I really like this this this quote from
Rachel aren't you it may be due to my my
being old but as as I look at the modern
CSS tool chain I feel like we are very
good at making simple things complicated
and Jeffrey Zeldin replies are not all
your your voice I think it's worse than
when things become some herbs so
abstracted and still relying on tools
that the core line which isn't probably
used in attitude and I think that's
that's a very valid concern but still I
think there are some basic tools that
might be very helpful for for all of us
but definitely we need some sanity to
determine which ones are bringing ask
Morgan or more harm so that being said
we need to automate tasks to stay
productive and focus on problem solving
that cannot be delegated because that's
what we should be doing as humans
solving problems and the competition
part or optimization part should be just
run by machines that's what they are
here for so I want to talk about some
very basic tools that should be used in
front end maybe not by every single one
of you and maybe you know most of them
but I feel like it's some important to
mention him first of all for fixing most
of you probably are using CSS
preprocessors so how do I not worry
about vendor prefixing well I don't want
to go and check for every single rule
that I'm writing and see what our role
dis spec was already implemented or do I
have to use bender prefixes so so using
other / fixer basically makes us not
worry about vendor prefixes why because
it checks can i use com which is in my
opinion the best resource for for vendor
prefixes and the stability of features
it automatically applies necessary
products is based on on can I use data
if you're interested of any of those
tools the first part is actually the
name of the name of the gate abuser and
the other when they are part is the name
of the repo so it's kind of like a
shortened github link after after
prefixing another thing that we could do
is CSS linting which is especially
helpful when you're maybe trying to
introduce new people to your code base
and you're trying to enforce rules
without I don't know maybe revealing to
call it every single time that someone
is commenting CSS led was written by
Nicole Sullivan and nicole jacques and
it checks for bad patterns and possible
marker bearers for me linters are kind
of a little bit a thing that it's not
necessarily something that every single
person should is because I feel like
they're a little bit opinionated so um
they're a good thing but if you if you
optimize them for your own set of rules
that you want to be enforcing and then
media optimizations that we we already
mentioned we should be optimizing our
media for delivery on so many devices so
image optimum which probably has the
best algorithms available SVG OMG
written by jake archival is an awesome
you I that also works offline based on
SVG o in addy Osmani word awesome
command-line tool called TMI that will
basically run and notify you where dirt
and images that you could be possibly
optimizing more and then students we are
talking about swinging unnecessary bytes
and minification which also minify our
CSS there are so many options out there
I think my favorite are clean CSS and no
CSS men because i work in note
environments but there are many more
available so you can find whatever that
suits your stack in your preferences and
since we are still in the topic of
reducing the amount of unnecessary data
there are two other tools that might but
or might not be very useful on CSS and
helium CSS these are not super
straightforward to use because they
require some amount of customizations
basically the cleanup style sheets based
on query and dom for selectors and
checking against the side street so it's
actually quite time consuming to set up
so so again it might be very helpful if
you are using very big CSS frameworks
that you want to get rid of unnecessary
unnecessary code and have a very small
CSS file and since we mentioned all
those tools that can lead to better
performance we want to test that
performance and while all of those tools
where Mosley's con line tools though
those tools that i'm mentioning our perp
and stress CSS perform app is it
something that you just install as a
chrome bookmarklet and it will show you
a visual map of elements performance so
we can very easily determine which ones
are not performing very well and stress
CSS that will check which classes are
about the affecting our performance
which is also not a command line tools
so it's something that you just kind of
right radica chromis extension i'm not
sure if there are extensions for for
firefox as well and testing performance
and why slow chrome developer tools are
de Google PageSpeed I sent our friend
but that's kind of not a part of common
line tool chain that that you're setting
up for for builds and one of my absolute
favorite tools that whispering by Adam
Morris pesticide pesticide i/o which
does the simplest thing of outlining all
the Dom elements and that's all it does
but it it makes debugging eliab issues
so easy and it's especially helpful for
for people who are not very comfortable
with CSS yet and with layout because it
makes it very obvious what what's wrong
in it and how to fix that and for those
of you that are not very comfortable
with common line but I would assume that
most of you are
you're not there are so many UI UI based
applications that will help you with
concatenation and with magnification and
basic bill framing hammer format code
kid and life reload are possibly the
most popular ones okay so we rushed over
some basic tools / for the front and
architectures but how do we actually how
do we actually add those tools to our
process what'swhat's when do we read
those texts we like just go to the
terminal and type like run bill whatever
no that's not what one do because we are
still wasting time for me one of the
most straightforward ways to run
automation scripts that using NPM and I
feel like a lot of people who are
working within a front-end less with
JavaScript are not aware of that but NPM
is pretty pretty damn powerful so you
can run you can run scripts of NPM from
pirate Jason you can you basically have
a native ecosystem for task outer
mission at hand when using NPM and uh
and just defining stuff in fact Jason um
in I've heard from a lot of people that
NPM is something that is for back end
developers so I I'm a foreign person so
I shouldn't be touching that it's so
scary but it's not people people who are
working a 10pm are very keen on
improving stuff for from front of people
and making it a package manager for
forever female and JavaScript but also
for managing partner resources and even
quoting through their blog posts about
front packaging into current support an
NPM forefront of packaging is not good
and NPM loves you front enters and we
care about your use cases which is like
the most awesome thing to say probably
in a very simple example of running npm
scripts is just defining those scripts
in package jason and having npm start
that's actually an example from leveldb
website which is open source and github
so you can you can go and see it and i
will share a link in a second um so all
of those free lines do is just
compile Jade compile stylist in run a
server in the meantime that's all it is
in three lines of code and maybe it
doesn't do optimization media
optimization our file concatenation but
it does the very basic things so for
small projects sets that's great so you
can use NPM scripts and you can you can
pipe the output from month ago another
you can run a comment after previous
task is completed and you can run tests
concurrently which is pretty awesome and
pretty powerful in my opinion so if you
want to see that example which is of
course a little bit longer than that
snippet go to bit ly little to be
example in and read awesome subsec
article and PM task automation that
explains it really in an early clear and
concise way okay so that's a native to
note environment way of running those
tasks but there are two other tools that
are very popular which is gulp and grin
and they are both alternatives to make
and they rely on not only defining
dependencies in package.json but also
having a recipe file which is called
Greg file and Gulf file respectively
they both have awesome communities
surrounding them there's of course and
I'm going to be discussion whether
culpas bear or grant is better in my
opinion they're just different and they
serve kind of the same purpose but they
have a little bit different
architectures gopis maybe a little bit
more straightforward for people who are
working with node because it's based on
streams and I think it aligns with with
node node way of doing things in and
grunt is a little bit more verbose in
terms of setup if eyes are a little bit
bigger and need to write a little bit
more code and there are some people who
are saying oh grandma you know like it's
kind of an overkill is trying to do more
more than but again I think it's a
preference choice in terms of a platform
you're willing to want to choose simple
gulp file for a task or of Jess hunting
it's just so so easy to use so we said
npm grunt gulp but there is something
that we are forgetting about which is
make and for some people make is in like
ancient technology that we shouldn't be
using anymore or it's just so scary oh
my god make us so complicated but I'm a
friend of person and I'm not writing a
lot of JavaScript and I think make is
actually pretty empowering but the
reason being a tenia tree have a custom
custom setup for running our building in
automation tasks for the front and which
is we have a custom model module that
was written by Phillip Roberts that is
called building static server and that
is paired with make so the way that
works is but an excited site server is
running a server so and make is doing
the devel part the reason why we're not
using MAPE on its own which is of course
possible is because make is not really
great at running long processes and
building static server is making sure
that builds are run at the appropriate
time that you don't see cached styles
you don't see outdated information
basically and this is a most of our make
file which looks pretty straightforward
even for a person that haven't haven't
been using make or haven't seen a make
file it just builds CSS from from
stylist of course that's that's our own
preference and that's what works for our
our architecture with with node but
that's another option that people forget
about because they're like oh there's
Brandon gulp so I will just use that but
there are simple solutions than that and
and that's the link for for building
site except where that it's of course
open source and you can look around and
see if maybe you would like to be
inspired by it or maybe you would like
to use it to solve your own automation
processes
so the question that appears now is when
do I actually run those tasks like when
do I concatenate files when do I minify
files well I I've learned from
collaborating and then being in a team
that it's kind of disempowering to be
running builds and oh maybe not bills
but minification locally and then
committing those files to github the
reason being is I collaborate with a lot
of marketing key with marketing people
with people who are not necessary super
front or back and savvy and their
workflow of commenting minifying
minified files to the repo basically
assumes that someone has to be able to
run a built and what if that person is
using only get house you I what what if
they don't have everything set up on
their laptop like they can't contribute
anymore because you are making an
assumption that they have to run a belt
because you have to run a build every
single time you change something another
reason to not to not be commenting
minified files is because of course
conflicts I mean for people who are
savvy with get an inversion control it's
like it's no biggie like complex
whatever I don't even care but for
people who are who are not is again
pretty pretty disempowering which which
is why we never we never commit those
files to our repos and that's something
that's completely delegated to two
people who are doing DevOps and it's not
even a concern for for usual developers
and people who are contributing to
projects so we rushed over tools we
rushed over how to bundle up those tools
when to run those tasks but they thin
right now we are getting it the most
important part of all of that and the
whole idea behind this talk which is
collaboration because what we want to do
with those tools is empower ourselves
and the members of our team were being
at work or the source project or
whatever to build things better and
faster so one of the key ingredients of
teamwork and is getting rid of
our personal preferences and and stop
fighting over them and getting rid of an
ego as well and try to figure out
something that's good for everyone that
often means negotiation that often means
not using your favorite tools but it
really creates a true space for
collaboration to happen technologies are
mean to an end but it will fail
miserably if people can work together
feel empowered and conquer you to grow
if you think about it every single
person that's hired or joints an open
source project they have their own
preferences they they have their own set
of biases and prepositions in
collaboration happens only when those
preferences that are mine or whoever
else this won't cloud our say in
judgment about what's the best for the
team so the good of the team the good of
the team is way more important that kind
of like individual preference knowledge
makes everything simpler when you talk
about process or if you mention
formality or documentation most of
people get really sad or really angry
because we hate process and we hate dogs
and don't really want to deal with that
but when when you're gradually inviting
more and more people especially to open
source projects you start to value the
importance of good to come in
documentation and it is crucial in
general in software and also in creating
and implementing a mission as well
because if you if you think about it you
let's say we we have a small team of 15
people and you're a person that created
this process for I don't know let's say
optimizing CSS and but you didn't really
pay attention to writing dogs so now we
have to explain this process to every
single person on this 15 to this 15
people and let's say it takes 30 minutes
per person so that basically ruins your
day and again thinking about being
empowering and
working in an environment that's not
necessarily consisting of only front of
people are back in people but also
people who are only working on content
and our people were maybe more marketing
like for them documentation is essential
and I know that that sometimes mean like
run install node from no J's website
then run I don't know insulin p.m. and
installed that thing and then run this
in your terminal and then get back to
your browser and it seems a little bit
silly but it is very empowering for
every single person that will be
potentially contributing to two-year
repository another thing that it's also
kind of such associated with node as a
node philosophy by this actually UNIX
philosophy but that is a mayor is
breaking down data and modules which
makes it more digestible and more
controllable people mostly tend to do it
in a back end at least I've noticed that
but it's also really important to do
that in the front and with with CSS why
because modularity provides that
basically ensures that it's way more
digestible and it's easier to find
things it's easier to remove stuff and
it makes it makes things simpler because
small things appear simpler and we often
hear about people going like oh my god
just crazy monadic library or this
project is so big I just hate working on
it and the reason might be okay the
project is just really bad and the code
is bad but it might be just bad
structures so having a really good
organization my time is a little bit
pedantic but it brings a lot of value to
collaboration as well and since we were
talking mostly about command-line
tooling I think it's very important that
good tools especially the command line
base don't fail or succeed silently and
I know it might seem a little bit
straightforward it's something that is
very obvious but I've seen many tools
that will give you an error but won't
give you a message about
succeeding with the process whatever
they were doing which is again very
disempowering for people who are not a
very super common line busy safety
because they don't they don't know what
happened and they don't know how to find
out whether something succeeded or not
so having an option of having
communication from from a tool if you're
writing command line tools of having
both success and failure and having that
be very audible it's a very important
option and you can always silence it in
in a way the aim to build pelipper of
software is profound but almost
impossible to achieve and I think is
really hard to come to terms with that
because probably most of you are a
perfectionist and we kind of don't want
to acknowledge that progress against
alone with complexity is again another
constant so we kind of try to over
engineer our solutions without having in
mind that aspect of of collaboration so
it's relatively easy but over
complicated solutions but it's hard to
maintain them often one can sit down and
be like okay I have this amazing idea
for this tool and I'm going to write it
in such a beautiful way that everyone on
github will love it and I'll get so many
stars but that doesn't that that's not
really collaboration that's not really
something that's empowering at all
there's a lot of pressure on writing
smart so to cite code but what's very
important at the end of the day is
something that just gets the job done
like and you don't have to even
certainly be a person who is writing it
there are so many tools that are
available maybe there's something that's
already doing that for you so the most
sophisticated way it's not necessarily
something that that would be good and
understandable for for your team at at
all so it's easy to introduce
unnecessary complexity by adding tools
that manage on it
and the reason why I'm bringing that up
is because since we talked about tooling
and a little bit about package manager
management with NPM especially in the
front and there's a lot of confusion
surrounding package man it's like should
we use NPM but NPM is for JavaScript or
should we use power or should we use
that other thing and I've seen a lot of
friendly developers who are confused
they are not sure where to put their
modules or where to which which one to
use so it's very very confusing for him
and that did um yeah so brew install
piden is innocent piven sub are instant
installed my name is deepak you and
you is actual module so it's not me
being mean and it's a quote from Lewis
Cooper who said that to me when we were
discussing package management so there
there are a lot of package managers for
probably every single program language
there is and it's very easy to introduce
complexity with those package managers
tools because why would I use why would
I use Bower why would I should I use NPM
which one is native for us but the point
being is we have to remember which tool
is being helpful reverse which school is
empowering for our team how many
dependencies is going to bring and is
going to bring us technical debt or some
technical advancements the right set of
tools or a lector offsets apart a
craftsman from an operator so I think
that in this super brief rushing about
tolling for forefront and package
manager and learning running tests as
well what what's important is that
foreign technologies are advancing very
fast and there are so many tools
available every single day that is very
tempting for us to try them all and add
them all but in those limitless
possibilities we we tend to forget
what's actually
it's actually empowering and what's
actually going to work well in our team
scenario and we just get excited about
yourself so we try to add everything up
just to try it up so wrapping up I hope
this is going to work I have a video and
I know it looks like a shameless
marketing plug but it's not um I think
that this will wrap up the round above
collaboration in and how to build
empowering frontal systems in how to I
guess be a better human being we'll see
high five and yet is where people come
to do what they love every single day
and yet is a group of creative people
who are set out on making not only the
web but the world better place and yet
is about building trusting people and
yet is a collection of people a club
really where we get to do things that we
enjoy doing and it is a place where we
pin fail where we can grow really can
move Talon celebrate each other and it's
me is do trust in freedom to do and yeah
is that for companies with the goal of
making the world a better place one
person at a time the only way to honor
their expire what people are doing and
what everybody does is so diverse but
it's hard to come to a C or
please any other the place to be
supported and entrusted without
exception what is it and yet and yet as
a place where when people are together
trying to grow together can I go I'm
seriously married to no thank you tip
this thing off anja oh you ready so
anyhow that was a shameless plug but I i
think that defines collaboration pretty
well so apart from some tools that I've
mentioned that you might have heard or
might not have heard about it I think
that that would be a pretty good wrap up
for you to remember when choosing
technologies and when trying to work
together we're being an open source or
or at your draw so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>