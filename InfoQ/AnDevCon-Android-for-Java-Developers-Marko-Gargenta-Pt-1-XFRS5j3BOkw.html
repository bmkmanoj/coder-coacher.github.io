<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon: Android for Java Developers - Marko Gargenta, Pt. 1 | Coder Coacher - Coaching Coders</title><meta content="AnDevCon: Android for Java Developers - Marko Gargenta, Pt. 1 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon: Android for Java Developers - Marko Gargenta, Pt. 1</b></h2><h5 class="post__date">2011-03-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XFRS5j3BOkw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let me tell you a little bit about
myself and then I'll tell you about what
we're gonna do today so basically my
name is Marco and I've been I've been
doing a lot of Android training for the
past couple of years before I started
doing Android training I was been
jealous since before it was really Java
since about 94 95 when he was a little
project at Sun back in the day and back
then I was really interested in embedded
systems that's why I kind of got
interested in job in the first place but
as we know Java sort of took off more as
the platform for web apps and enterprise
applications other than embedded
software so that's what I was doing for
the last decade and a half or so until
Android came out so for the past couple
of years have been extensively do in
Android mostly Android training going
around the world doing classes for
companies such as Qualcomm Motorola
Department of Defense and so on and so
on and I'm also author of a book called
learning Android that's coming out this
month by O'Reilly so look out for that
and I frequently speak at conferences
such as Osborn I Triple E ACM and now
and I've gone so that's that's a little
bit about my background I also started
the a organization called Cisco Android
users group
it's a San Francisco based Android users
group and we so we put together a lot of
great learning events in the evenings
once a month you zone so with that let
me tell you a little bit about what we
are going to do today so we're gonna
talk a little bit about the stack it
sounds like some of you may know some of
these things here so we may fast-forward
through that we're gonna do a hello
world the purpose of this is going to be
a to test that you guys have your
environment set up if anybody has any
questions about the environment but B
I'm also going to go a little into the
details of the application sort of dice
right it's sort of like open it up and
and point out what is what and how it
all kind of gets put together into an
application and then we're gonna talk
about a topic to tokens that are
important and that's the main building
blocks or Android components these are
things that they're sort of very
specific to Android these are sort of
Android constructs and and are new to a
lot of you know Java developers so we're
going to talk about that but we're going
to talk about that in a context of an
actual application so once we do that
we're going to look at what it takes to
design an application so this is gonna
be lines and circles sort of our
conversation so it's gonna be very much
about the architecture of an application
more so than just just coding it and
then we're going to talk about UI a
little bit because I find that that's
usually a an area that a lot of people
have issues with and and then we're
gonna talk a little bit about some
operating systems I'm sure some
debugging tools and and so on but keep
in mind that this is a not so scripted
this presentation so if you guys have
questions if you want to kind of drive
it in certain direction if you want to
move it faster or slower it's really
it's really up to you so I'll be asking
you for you know any questions or any
any feedback as we can keep on going so
we can adjust this we go through the day
so with that let's start with the stack
so I just want to give you a high-level
overview of what the Android operating
system is and how many of you have seen
this picture or similar picture a couple
you alright so we're just gonna look at
the very big picture of Android we're
gonna sort of start looking at from the
bottom up and kind of understanding what
is what so the very the very bottom of
of everything is Linux as you know
Android is built on top of Linux kernel
so we bought Linux kernel and we laid
out many many layers on top of it the
reasons for Linux are multifold one of
the main reasons is that it's really
easy to port it to many different
platforms so that was the goal of
Android project right from the
Gattaca right it wasn't about a single
phone a single gizmo it was more about
being able to run on many many different
partners and in that sort of business
decision trickles down into a lot of
technical decisions later on so many
different platforms right in Linux is
fairly portable so mixed fairly easy to
do that provides that abstraction layer
there's certain other things that
clinics provide such as memory
management user management power
management networking radio etc so those
are very low-level things as app
developers we typically don't care about
this too much as platform developers we
do but that's a different story so on
top of Linux we basically have a whole
bunch of native libraries and the native
libraries are things that are more or
less copy-paste from other open source
projects so these are things that were
needed to complete the the big picture
right so for example we needed a
database so we got sequel Lite database
we needed a way to render HTML so we
borrowed the WebKit library and and plug
it into the Android OS we needed open
SSL Open GL things of that nature right
so these are C C++ libraries that are
there to make the whole stack complete
right Bionic is a minor exception which
is basically a rewrite of standard Lib C
library and one of the reasons for that
is the license so keep in mind that the
goal of the Android project is to make
it easy for for app developers to make
changes in any part of the system and
keep those changes right so most of this
stack is basically licensed under MIT
Apache Eliza's so that's one of the
reasons why Bionic is a different
version of Lib C so going forward with
that the next thing that we have sort of
in that stack is Dalek dalvik is
basically a replacement virtual machine
that replaces Java Virtual Machine
so all you guys are Java developers you
know what I'm talking about
so there's no Java Virtual Machine
basically in Android all your code all
your Java code is going to run on dalvik
VM
so why why develop Dalek in the first
place why not go where Java there are a
couple of reasons for that one is sort
of the you know there's a couple of
business reasons there a couple of
technical reasons from technical
standpoint Java Virtual Machine was one
size fits all VM that works the trans
job on anything from a tiny little phone
to a supercomputer right so as such you
can only optimize it to a certain degree
right because you gotta sort of have the
same VM across the board so that the
Android team felt that they can do a
much better job optimizing the virtual
machine and that's that's the technical
reason for for Daleks so dalvik is
highly optimized for small devices what
that means it's technically it's it's
registry based as opposed to stack based
because a lot of these small devices are
based on registers as opposed to getting
a lot of memory to run stack of stack
based applications so that's from a
technical standpoint from business
standpoint again it's the license issue
right so dalvik is open source as in
apache license which means you don't
have to deal with oracle or anything
like that in terms of Licensing in Java
so dalvik is pretty fast as well it
comes with a just-in-time compiler and
so forth any any idea why I put this
picture here looks nice yes yes dalvik
Dalek is the name of a fisherman village
in Iceland that's what it looks like
it's got a church and that's about it so
yeah cool so that's that's dalvik we'll
talk a little bit more about dalvik in
how it relates to Java once we wants to
talk about Java so that's coming up so
we'll double click on that just on top
of that we have the app framework so
this is the layer that is very rich in
functionality it's very well documented
and this is the part of the stack that
you guys' application developers
interact with right so this this is
where this is where we program against
it when we
right applications application framework
provides all those nice features such as
figuring out what your location is
playing various media types connecting
to internet etc cetera so anything that
you want to do from application
standpoint is provided to you here in a
nice package way
so beyond application framework we
basically have applications so lots of
lots of different applications let's
take a look at roughly what an
application is so an application at the
end of the day is gonna be a single file
it's going to be an apk file application
package right it's essentially a zip
file and what it consists of is
essentially your Java code that's now
made into a dalvik executable right so
you're gonna have some compiled Java
code and it also consists of resources
so resources are things that are not
code ok so what would be the things that
you have in your application that are
not code images constants sound clips
layouts or the text or your English
right all that stuff is not cold
so Android actually Android application
development sort of forces you to to
think in terms of separating those two
concerns right so having code be just
code just be just the business logic and
then having everything else be outside
of the code bits right so we're
separating those two that's that's an
important thing we'll talk about this
more as we keep on going now another
thing optional thing here that I put in
is native libraries we're not gonna talk
about that in this presentation we'll
talk a little bit more about that
tomorrow but me you can basically have
some C C++ code as part of your
application as well sometimes the
performance is the reason for that so
that's essentially what an application
is it's usually these two things your
dog executable and your resources and
I'll show you this you know deeper in
how this actually plays out on a file
system as well
as we keep on going this is very high
level at this point a couple other
things that I wanted to point out in
terms of applications that you guys
probably already know so applications
must be signed so you get a sign your
application before you distribute it but
you can self sign it you basically self
signing it
you can either self sign it with your
with your private key if you can bond or
you can create one or you we typically
sign it to the debug key when you're
just in the developing mode okay so
we're not gonna be seeing the actual
process of signing because it just
happens magically behind the scenes
using the debug key but I just want to
let you know that the applications are
typically signed and they must be signed
before the distributed and as you know
that there are many different markets
unlike some other ecosystems such as you
know iPhone and such there are many many
different markets Google being probably
the biggest and best-known one but it's
not but the only one at all so they're
just a little bit about the applications
any any questions from the stacks so far
is there any trouble of interfacing
dalvik code word Java code right the
existing Java code right yeah so the the
the answer is gonna be on the next slide
but essentially you're not gonna have
then the Java code Java code is gonna
get compiled to knowledge as well so
it's going to be really Dalek
interfacing with dalvik so but let's
let's double click on that on the next
slide so I'll show you how that actually
works any other questions on on this
yeah any comparison done between dalvik
and in Java in terms of performance
virtual machine to virtual machine I
don't really know I'm not sure of that
so I I know that basically one of the
things that we didn't care for a long
time is just-in-time compiler which
basically makes the Java code run much
faster because you're not interpreting
it and we got it final with fryi in the
couple of reasons why they felt it's ok
to wait that long one of the reasons is
most of them
so with just-in-time compiler you get
speed boost when the application is
actually running but a lot of mobile
apps are not really running they're just
sitting there you know waiting for user
input so they're very very much idle
right so as such having a much faster
implementation it's not gonna show you
give you a lot of noticeable difference
right so that's that's one of the
reasons for for that now
Daleks when they design dalvik back to
this they looked at they looked at the
constraints that we're dealing with in a
mobile environment specifically right so
they looked at mobile and they said okay
what are the things that are not gonna
change for anytime soon well what caused
marble different than anything else
right how is it different than you're
connected you see that you have on your
on your desks right the battery is the
biggest difference right so the battery
is something that's gonna be a
constraint for a very long time right
we're seeing an evolution in batteries
but we're not predicting any revolution
in in batters anytime soon so a lot of a
lot of things that went into optimizing
dalvik you have to do with battery
performance and also the memory now
consumption because what happens is the
the device itself is very small so the
amount of memory that we have available
to us is always going to be limited by
the sheer size right so there's some
very smart things that dalvik does in
terms of in terms of using less memory
I'm going to talk about that next as
well yeah
any other questions what are the
implications for the app developers for
register-based
versus tag based VMs so all this stuff
about what happens underneath the hood
with dalvik and all that it's it's it's
just interesting but there's an app
developer you pretty much don't care
about all that it just happens it's just
magic right
and so that's basically that's basically
that now in my experience I ran some
tests that recursive and that's
something that typically requires a lot
of stack and that's why I see dalvik
take a huge performance kit but so that
I've been comparing Wow
I've been comparing Dalek recursive code
to see the recursive code and the
difference is order of magnitude so it's
about 10 to 20 times but for the most
part is an app developer you don't
really care that it's running on dolly
yeah it just got all that stuck up and
stuff behind the scenes yeah the
question is all right so let me since
you guys are so interesting that so
let's move on to to how Java and in
Android are are different
Jolyon dalek are different so let me let
me start with the with this comparison
here so as you guys know in standard in
standard Java your I Java code right
this is your dot Java file you compile
that file using Java C compiler and you
get Java class file right dot class file
that's your binary code and that what we
do next is then we put that Java
bytecode on top of the java virtual
machine right so this is where it
executes the JVM running our dot class
file essentially so this is what this is
this is called standard Java works this
is how dalek works we still write the
very same Java source code right it's
the very same Java source code we still
use the very same Java compiler Java C
we get the very same bytecode this is
tell the dot class file now what's
different is we take the byte code then
we compile it once again right so we use
DX or Dex compiler to recompile the dot
class file and get a Dalek bytecode dot
DX file right and then we take that
dalvik bytecode and we execute it on top
of the dalvik virtual machine right so
these steps are different does it make
sense so so a couple of couple of things
that are interesting here couple of
things that are interesting here is that
for example one person that they usually
ask people is why the
and do this why not just go from Java
source code straight to dalvik bytecode
why why create this intermediary step
and then toss that away I mean yeah
exactly you may have some Java libraries
that you don't have a source code for so
you just want to bring them in so that's
back to the question about the
interfacing with existing Java code
right so you would basically just take
existing Java code and we compile it
using dalvik right so so that's that's a
good reason to to base it on the
bytecode
another good reason is that Java
compiler actually does useful stuff so
there's no real reason to reinvent the
wheel right so that's why we we
basically we start where Java C left off
right so that's that's another good
reason for this and another good reason
that I like about this is that a lot of
other languages also compile down to
Java bytecode so what that means is that
you do not need Java to write Android
apps right you can use Ruby for example
and with JRuby or python with J Python
right there's I think a presentation on
specifically on Ruby and writing Android
apps using Ruby so this is how it would
work
you would just basically compile it down
to JavaScript
so those are all all the good reasons
why it is architected the way the way it
is pragmatically the reason why they
went they based dalvik on the bytecode
is because when they started working on
dalvik in 2005 Java was going through
the major language change right that's
when Java 5 came out so that's why they
felt that they didn't want to base the
the compiler on something that's in flux
so they based it on the on the class
file which was more about setting stone
standard every time so so that's a
little bit about how that works any
questions on this part of the picture
yeah is it possible to pre-compiled
libraries and link them in so it's
basically that week loads the libraries
the same way Java loads the libraries
right so you wouldn't you would need to
have that that class file compiled in
the dot DX file at some point so you
will need a diatomic executable
somewhere how you get it is not
important but it's dynamically linked
right just like in Java so it's not like
linked in to statically does that
connect so at the end of the day you're
gonna have a zip file with your your
Dalek version of binary code as opposed
to jar file with Java version of binary
code so any other questions on that okay
so with respect to so that's how the
dalvik works now it may sound like this
is a lot of extra work but all the all
these steps basically happen
automatically by by tools right so we
don't really need to worry about any of
this this is just FYI now a couple of
other things that I wanted to point out
as you guys know Java ships in a couple
packages so Java standard edition Java
Enterprise Edition job Mobile Edition
right so androids Java Android subset of
Java libraries is essentially Java
standard edition right so that's that's
the starting point we started with Java
standard edition but one of the big
differences is that anything that gets
do with the UI namely aw aw tea and
swing libraries are gone right so this
is this is sort of a big departure
between Android Java and standard Java
so the UI libraries are totally
different the principles are very
similar but the libraries themselves are
different right so we're gonna we're
gonna see this later on but more more or
less everything else is there right so
when it comes to networking file i/o any
or any of that sort of stuff that's
basically the same as this in standard
Java right so that's just that's good to
know because you don't need to worry
about any of them
so that and on top of that we add some
specific Android API so let's go Android
is different enter his job is different
than the regular job any questions on
that
oh my god cool so with that we're gonna
now talk a little bit about the hello
world program and and see how things
work behind the scenes before we do that
how many of you is does everyone cab
environment setup or does anybody need
any help with any you have any questions
about the environment setup how many of
you have a SDK in Eclipse installed
alright pretty much our code all right
so then I'm let's let me just run
through this really quick so what the
money I'm gonna start my eclipse in the
meantime but what I just wanted to point
out this couple of things so so so as
you guys know when you download when you
download the SDK you're basically just
getting a shell into which you need to
plug in various platforms various
add-ons so add-ons and platforms they go
into their respective directories right
those are the essentially the versions
of Android that we're using and then you
also need to make sure that your tools
and platform tools these two directories
are part of your path right and then
you're set and so in the meantime I'm
starting my Eclipse actually I don't
want to start this one Julius is not as
good as Galileo so I'm gonna quit this
and restart at it just uses way more
memory for some reason okay
cool so what we're gonna do what they're
gonna peel right now is I'm gonna I'm
gonna do a little it just create a
little hello world application so file
new Android project assuming that you
I'm assuming that you guys gave your
environment set up and all that and most
of you have done this I don't really
expect you to follow hello world by
doing it but I just wanted to talk a
little bit about what happens and how
things work and what the anatomy of an
application is before we get into
anything more complex so project name
again it's an eclipse construct so hello
hello world just gonna zoom in so you
can see in the back I think that's the
other version of Eclipse they just
really that's the three point six so
don't worry about that as you guys know
eclipse is fairly flimsy sometimes buggy
and so on but prices right so cancer
like employment all right so these are
the various targets right these are the
various possible targets that I have
installed on my my my laptop and in my
SDK so that's essentially saying what
you're targeting with your application
so you typically want to target you know
the lower the better because you have
the wider audience for your application
right but you can also say something
like this along
for example I'm gonna target to point to
Android so this is the open source
version of Android 2.2 so I'm not
expecting any bells and whistles on the
actual phone right but later on what I
can do is I can specify what the minimum
requirements for an application is right
so that's we're going to see that in a
second some targeting to point to
application name is just a arbitrary
name so hello comma space and and
exclamation marks now package name is
important this is your standard Java
package name right and the reason why
it's important is because a lot of
things are later on keyed off of this
package name right so security is based
on the package name
signatures are based on a package name
file system is determined on a pack of
based on a package name so that's why
the Java package name itself is fairly
important and it adheres to standard
java name package name conventions right
so come example 4 for example yellow
right so that would be my package
now optionally it's asking us to create
an activity you know in a nutshell
activities the screen it's gonna
represent a piece of UI that we're gonna
see on the on the in the application
when it's all said and done and also if
we do choose to have it it's gonna be a
class it's gonna be a Java class so as
such it needs to adhere to the Java
naming conventions so I'm gonna name it
hello world right actually let me change
the to hello activity it's a capital H
capital a finally it's asking for the
minimum SDK version in the past this
number would automatically get copied
from here so whatever we chose here as
our target he has the API number level 8
right would basically just get copied in
here they don't understands what the API
numbers are and all that stuff right ok
so that's basically the capability of
the of the kernel of the framework so in
the past this was the standard standard
procedure on now the best practice is
basically to really think about what is
the minimum SDK that you require so for
example your application may be using
some latest bells and whistles from you
know the latest versions of Android but
you also want to be able to to help
users with all the versions of Android
use it as well right
so you may for example say we are
targeting Android 2.2 but we're gonna
work on as low as cupcake or donut right
and what that means is that maybe your
application uses some features but it
can gracefully scale down those features
in case it's running on older
order all the platform right you you're
going to have to do this
programmatically but at least you have
the information available to you at the
wrong time
so for example I'm Bluetooth it wasn't
available in the in the API until 2 X
right so maybe my application takes
advantage of Bluetooth right so what I
can do is I can say yes I'm using this
API but if the user is running on an
older version of Android we're just
gonna gray out that feature we're just
gonna make that feature not available
the app is still going around so that's
what the point of the minimum SDK
version numbers they're on gotta cool so
with that so this is we now created a
little killer world and what we're gonna
do is I'm gonna open it up here I just
want to really briefly talk about how
this these files come together and what
everything is so this is our hello world
application here remember how I said an
application is it essentially a
combination of two things your dalvik
code and your resources so this is sort
of car that breaks down right so this is
your Java right and these are your
resources here right so these are your
resources so together they make that apk
file right that's your apk file or
application package right so well and
then in addition to that we also have a
file that's important and that's the
manifest file the manifest file
essentially says what the big picture
about the whole application is so what
version it's using what its name is its
various components permissions that it's
using etc cetera so that sort of
information goes into the manifest file
so what I'm gonna do is I'm gonna open
up a couple of these files just to kind
of show you what they look like and and
then we're gonna see how they relate to
each other let's open this one up and
hello Java so I'm gonna start from I'm
gonna start this way so we're gonna
start with the manifest file
so what Eclipse does it tries to provide
hand-holding when it comes to dealing
with any XML file in Android that it's
aware of right so as long as you're
working with Android specific XML
Eclipse provides the scanned holding in
a form of a forms right so it tries to
help you manage the file by providing a
view like this and you can you can flip
through multiple tabs at the bottom of
this file so this is my manifest file
this is my applicant the components
inside of my manifest file remember
that's our activities right there these
are various permissions if we had any
instrumentation it's about many testing
if we get any but ultimately you can
press the last tab in the picture and
you get the actual raw XML so this is
what what that file looks like now don't
worry about the details of this file too
much at this point at all roughly what
it's saying is that we have a manifest
file and it's got an application inside
of it and that application has one
component called an activity ok so so
that's that's that that main father that
outlines the entire app the next file
that we have here is strings strings is
basically one of the resource type files
that is used to - for all your text so
essentially all your English text should
go into this file right and you can see
that we have two pieces of text right
now there's a cello so this is our
yellow piece of text hello world hello
activity and this is our act name hello
and DEFCON right you can also see that
this is again just in our raw XML file
that looks like that so it's basically
just named Elliot there's nothing really
too exciting about that now as I said
the best practice is to separate text
from separate resources from your Java
as a matter of fact if your application
is to be included into the inter
customer
into a build of Android platform you
must separate or take all your text out
of the applications and put them into
resources which we'll see later on so
the next file that we have here that I'm
opening up is this file called main.xml
and it's basically a layout what layouts
are our screens they correspond to
screens that you have in your
application this is the screen that
corresponds to our activity and it
basically just says hello world hello
activity and we have various widgets
here I can for example I'm going to
downgrade this to 2.3 so that we have a
nor the latest stuff but close enough so
I can for example grab a widget from
this palette they can just drag and drop
it and there's a button now on my screen
and so on so it makes it relatively easy
to to develop your your UI your user
interface again you can flip over to the
XML view I'm gonna reformat it so you
can actually see it on the screen but
that's basically what what that looks
like so it's just a little bit of an
accent ah yeah so the question is about
the minimum plat minimum SDK version so
they do not get that doesn't happen
automatically so you as a developer you
have the you have the information and
you will have to check it what the
available version on the platform is in
downgrade specific things the only thing
that gets checked is that if your
application specifies in its manifest
file that it's minimum as decay required
is for example for right don't doughnut
the application is not going to get
installed on anything that isn't at
least less than donut right so that's
the only the only thing that gets
checked so it's a install time
does that answer okay so back to this
file so this is the the XML file that
corresponds to the screen the layout
itself in that file lives here in this
directory layouts now the next part that
we have is our file and this is a file
that people sometimes run into a lot of
issues with but let me just kind of
explain it so this file is first of all
auto-generated and you do not get to
modify there's a matter of fact I don't
like you to even have it open you should
not be looking at this file at all the
information in this file is not that
important it's basically a whole bunch
of pointers right so we're not gonna be
looking at this file but we're gonna be
using this file a lot okay the goal of
this file the purpose of this file is so
this file lives here the goal this file
is to basically glue the world of Java
so this is the world of Java right put
the world of resources so essentially
our provides a pointer or reference from
Java right to resources right so these
are our resources here make sense so
basically provides a hook from Java to
XML so it the actual pointer will show
you that later on but what happens is
all your resources actually get
quote-unquote compiled into a single
file right and and so this is a
reference to a location in that single
file and I'll show you that in a second
when we look at the actual binary side
of things for this app that's what that
is
but again the actual number is not
important to us like I said we're gonna
be using our but we're not gonna be
we're not gonna be referring we're not
gonna be looking inside of our at all
essentially whenever you change anything
in your resource folder okay art gets
updated so there's something watching
are okay so whenever there's a change it
gets automatic automatic the update
finally let me show you the yellow
activity the actual Java file and that's
the file here right so at the end of the
day it's all job job is really driving
everything and XML is just there to help
salt so this is how it works here's our
class yellow activity as you can see it
extends activity this is fairly typical
in Android you're not going to be
writing a lot of Java code from scratch
you're gonna be basically subclassing
system classes and you're gonna be
overriding specific methods that that's
how we do a lot of coding so it's not so
much it's not so much starting from
scratch but it's rather sub classing
inheriting from the framework and making
changes in this case what we're
overriding is something called oncreate
and I'll explain what this callback is
later on when we see the actual
lifecycle of the activity but as you can
see so we're overriding oncreate we're
calling it super so so far we're back at
square one we haven't done anything
useful right so up to top to line 10 we
haven't done anything useful we're just
basically created the template to start
doing something useful so the only the
first thing the only line of useful code
is this line 11 right so what this line
basically does it says set a content for
this view the view for the view of how
many of you are familiar with AWT in
swing or swing okay so most of you
alright so of view is what in Java would
call a component right so everything is
a view anything that's kind of visual
with any widget sort of a sort of thing
is a view
so we're saying set the content of this
component to our layout main so this is
where we're using our let me explain
this in a second
so what we're doing here we're basically
saying set a content for this activity
to our layout main right so what what
we're doing is we're using that our file
which I said we're gonna use a lot but
we're not gonna look at that's how we
use it right and what that's doing
it's basically referring to resources
right layout main.xml right so this is
essentially a pointer to that file here
ok so what we're saying is set the
content of this activity to that XML
file
and we'll cap is behind the scenes as
this XML file gets read and it gets
inflated into Java and I'll talk about
that in a second but but essentially
after this line 11 we have a whole bunch
of new Java objects in our memory space
that got magically created by processing
the taxon alpha and we're gonna talk
about that because that's sort of where
Android is unique with respect to Java
in the UI does that make sense how this
gets how this works so the only thing I
wanted to show you behind the scenes is
what happens with the with this
application so I'm gonna look at the
actual hello world here and the only
father that haven't the only folder we
can seen is that so interest is this
folder bin right that's what the binary
output is and as you can see this is
where our apk got built so it got built
magically by eclipse because we have in
in Eclipse we have as you know we have
project built automatically track Dom so
whenever you save a file
everything gets recompiled right that's
why it's very very important as you're
developing to keep saving your files
right and especially because files
depend on each other right so if I make
a changes in my strings file that
effects right because it's in resources
that effects are which effects Java so
you want to keep your files changed
saved otherwise things get out of sync
and that's where you run into compile
problems so back to this file so this is
our this is our final product that's our
application that's what we ship right
here apk file right on in that file is
really the sum of the resources and the
dalvik remember how we said apk file is
you combine the dalek code and the
resource pool resources right so all our
resources are essentially quote unquote
compiled in this file here resources dot
AP underscore right so all those images
layouts graphics sound clips English
text all that stuff gets combined
together into the single
that's what it is right all the dalvik
code isn't this far
that's the dot Dex is stands for dalvik
executable it's kind of this is
comparable toward our right now here's
our Java so all our Java files are right
here the compiled version so basically
what happened magically is Java got
compiled right this is the class files
then dad got three compiled into this
file here the class is dubbed X right
remember we were talking about how that
happens so although it's an extra step
you don't really care other than it's
interesting that's what that's what
happens but but that's that's at the end
of the day we just have this Dalek
executable here right so first again all
right so now let's talk about running
yeah question yeah so in you so first of
all package Explorer hides bin folder
from you it's it's just it it's supposed
to be a binary output such is not
interesting so you gotta look it up in
the file system so go to places and then
and go if you're using my VM I think
there's already a link to your work
workspace so yeah but it's not the file
system it's just not in the it doesn't
get shown in the package Explorer any
other questions on this so far
hello world dissecting kilo world so
what we've talked about so far is
creating a new project sort of what's
important in this thing
anatomy of an app so what bits and
pieces of an application are we talked
about the manifest file the resource
file the Java file and now we're gonna
talk about running it just a quick
question does anybody not use eclipse
does anybody care about Ronnie using a
different environment notepad VI I don't
really care but something else now it
means NetBeans I don't know a lot of
people using NetBeans honestly you know
it is one of the supported IntelliJ and
NetBeans are also supported but it's it
just happens that it seems like
everyone's kind of standardizing in
Eclipse that that I know of so yeah you
do not need eclipse you can run on a
command line as well yes
Emacs or something some people do so let
me let me just show you if I forget the
clips for a second if I want to run
everything on a command line in in that
case it doesn't matter if it's VI or or
whatever you use so I'm gonna see the
into my my workspace and I'm gonna go to
your low world project and so if I
wanted to make this project if I wanted
to create a brand new project I would do
something like and draw it create
project right and Android is one of the
tools that's part of your tools
directory in the SDK right now society
habbo project as opposed to create
project I'm gonna say Android update
project and I'm gonna say - - path the
current working directory right then I
can say - - name if I want to kill our
world so what this is doing is now
analyzing the existing project and it's
saying alright what would it take for
this project to be command-line a bowl
in other words not require fancy Eclipse
tool and essentially the only thing
that's really needed is the build.xml
for ant made so at this point I have a
project that I can compile on a command
line so I can do and debug for
debuggable version of the code and
that's not going to compile it on a
command line I can use VI or you know I
use text made for example so I can make
you know this directory so in other
words you do not need a fancy Eclipse if
you if you didn't if you didn't want to
use it so this would be for example me
working in text made as opposed to
eclipse all together but Eclipse while
it gets some shortcomings it's actually
a pretty good tool for a lot of things
Java
anything sound good so we'll talk about
that any other questions song on this
alright so let's talk about running this
did you guys bring your phones yeah ok
I'm just joking about that you do not
need it it's gonna be if you carry
that's great but
but we're going to be running it on the
emulator so let me let me actually
create the emulator first and then I'm
gonna explain what an emulator is so
there's a tool called Android and you
can start it from a command line by
typing Android like you saw earlier or
anything you can do on a command
anything you can do on a command line
you can usually do an eclipse and it's
usually this button here right so I'm
gonna click on that and that starts this
tour and I already have a I'm gonna
delete this one so typically you would
not have a an Android virtual device so
basically we can create this multiple
virtual devices right we call them a VDS
Android virtual devices so what I'm
gonna do is I'm gonna create one really
quickly and I'm gonna explain what is
what so I'm gonna call mine ginger bread
you can call it whatever you want make
it Tommy anything's good this is the
this is now the target of the device
this is what's installed on the device
the capabilities of the device so I'm
gonna say this one is capable of let's
say Android 2.0 level 9 right so this
would be gingerbread next what it's
asking me is is there an SD card in
visited by since fairly typical to have
an SD card and I'm gonna put a
relatively small 120 megabyte card next
it's asking me for the skin of the this
device so how big is the screen what
what's the skin of it and by the way
these skins are fairly simple to create
they're essentially image maps you can
create your own skin if you want and
rittle your device to look like some
something totally different like for
example a car navigation dashboard or
you know a tablet or something like that
you can make them quite easily so I'm
going to choose the default w VG 800 and
or I can even do a custom resolution and
these are some hardware properties that
you can specify so for example you can
say my particular virtual device does or
does not have accelerometer battery as
the car GPS etc so you can kind of
configure some of the capabilities of
the device I'm not gonna do anything
special about it I'm just going to click
create
what this now does is it creates a new a
VD abt is then essentially as a virtual
device it just explains some data about
the device yeah that's that's what so
the question is about the twenty Meg as
SD card so that is the size of the
filesystem I just allocated for TSB card
let me show you I'm gonna start started
you take some time to start so I'm going
to start and because of the the
resolution of the screen I'm gonna
resize it to fit but you guys on it
usually have to do this it fits on your
it should fit the size is right yeah
sighs it's perfect otherwise it gets
chopped off so while this is bullying a
couple of things I'll get back to the
question couple of things do you guys
get the difference between a simulator
and an emulator sounds the same it's
fundamentally different so a simulator
simulates behavior of something right it
basically behaves the same as the real
thing but it's not the real thing right
emulator on the other cane emulates the
low level hardware
so essentially what they're starting up
is a virtual machine right so the code
that I'm pulling up right now is ARM
based binary code so everything that I'm
booting up right now is one percent
identical to a to a physical device so
it's the same binary code down to ones
and zeros right the only exception is
certain drivers such as you know radio
for example and things like that right
because obviously there's some
limitations running you know in a VM so
certain things we can fake such as GPS
but some things we just can't fake such
as sensors right I tried shaking the
laptop it didn't work so just so you
know so that's an important thing to
understand yeah can you set the CPU
speed the network bandwidth yes you can
do all that stuff but I would do that as
part of the platform so in other words
you can build a custom Android and then
you can you can do all these sorts of
things there's in it dot RC file that
specifies a lot of these settings and
but that's a that's a different
conversation that's about building a
custom ROM
and when you do that you're God you can
do whatever you want right but on on the
actual emulator on the out-of-the-box as
an app developer things that you can
control about this emulator are
available to you via this perspective
called DDMS so so you guys should help
the DDMS perspective if you don't go
under window show perspectives go under
other or find it but you should have a
DDMS perspective so let me just pop it
up here so DDMS perspective is stands
for dalvik debug monitoring services and
it basically is sort of the perspective
that you use when you run code so Java
perspective is what I use when I write
code DDMS when I run it and as you can
see I have my emulator here it's
registered on the devices and I can also
control certain things about the
emulator so there are certain controls
such as I can I can specify the
telephony speeds right I can say that we
only have GPRS or GSM for for speed and
the latency is set to edge and that we
are roaming and etc etc right I can even
make phone calls to my device right so I
can say let's let's call let's pretend
we're making a call to our device and
you're gonna see that there's gonna be
an incoming phone call from five five
five one two one two
well I can say send an SMS
and no you just need to specify a number
so this is one of the examples where
Eclipse may may or may not work
perfectly but there's always a plan B
and the plan B is always to drop down
command lines so let me show you what
you can do on a command line you can
basically talent to your device to your
amulet you can take a left localhost and
then the port that you want to hit is
the port that says here right so in this
case it's five five five four
so I'm gonna tell it 5 5 5 4 and you say
help and it tells you you know various
things here so for example I can say
help GSM ok so I can make a call right
so help GSM call right and so this phone
number so I should be able to do GSM
call five five five one two one two and
it says okay so I'm not sure why it's
not connecting but that that's how you
would control with control the the the
emulator from from from a command line
right which is useful because you can do
a lot of auto automation that way back
to your question about the SD card so
when you guys create an emulator behind
the scenes what happens is there's a
directory in your off of your home right
so that's called dot Android so on Linux
UNIX systems it's going to be hidden but
it's it's called dot Android and this is
true also for Windows users right so
it's gonna be in your Documents the
setting sold you whatever the passwords
and wonders look for a directory called
dot Android and in this directory
there's going to be a subdirectory
called a BD and that's where your
virtual device is so and that's that's
where our devices right so I'm gonna
show you really quickly that if I cat
the gingerbread ini file it's basically
just saying you know where what is based
on so it's based on android 9i 2.3 and
it says that the actual data is in this
directory so I'm gonna see the into
gingerbread DT LS and this is where the
filesystem
images for this device are so in other
words the SD card is right here this is
that 20 Meg file that's that's the
equivalent of the log you know plastic
thing that you stick into the into the
physical device
right this is the user image which
corresponds to everything that user is
changing so that's why when you download
the apps that's what it goes when you
add Bob it to your contact list that's
what the data is saved so that's
basically they use a specific data yeah
yeah so you back to the SD card so when
you're creating the the AVD you're asked
about SD card so you actually gotta give
it either size for it to be created
otherwise it's gonna be non-existent or
you can point to existing SD card which
you can create using a tool called MK SD
card which is also part of your SDK
tools directory yeah so you can create
it and add it into the into the things
but but this is these are the basic just
behind the scenes what goes on in tune
with the emulator and those
specifications that we specified about
the capabilities of the Android the
aspect of the AVD
are here so this is what's basically
saying you know a little bit about the
this so with that what I'm gonna do is
I'm gonna run our application so now
that we have it running so I'm going to
go back to Java and I'm gonna click on
run Android the application and I'm
gonna basically what we're doing is be
installing that apk file onto the files
onto the device and launching it at the
same time so so there's there's our
application it's got to see but it says
hello world and all that stuff there's a
little button that does nothing but you
know nonetheless we we got it installed
now just back to you know everything you
can do eclipse you can do command line
as well so if you are doing this on a
command line remember we built it
successfully on a command line right so
we did we built it we ran and to build
it
and if I go to my bin folder there's my
there's my apk as a matter of fact I
have a couple of them but let's say it's
a hello hello world or they became so
how would I own a command line push this
from the laptop onto the device keep in
mind that this this virtual device is
for all purposes equivalent to having a
physical phone connected to the USB USB
cable right so it's totally separate
machines totally separate computer so
how do we bridge from my Mac to my
gingerbread a video and the tool for
that is a tool called ad beam Android
device bridge okay it's a very important
tool and you end up using it on a
command line or what because it's very
powerful and so just you know you want
to get familiar with it
but basically what I can do is I can say
ADB install write hello world dot apk
and what this is gonna do is it's going
to push this 80k across the wire
although in this case the wire is
virtual right onto the device and in
this case it's gonna fail because I
already have it installed so what you
can do is you can say install - are and
now it's going to reinstall the
application onto the device does that
make sense what happens so I know we
only looked at the kilo world but we
kind of like are looking a little bit
more sort of inside what happens in
behind the scenes of all this stuff
right any questions or comments on that
yeah
are there any tools in Android to help
you scale between different screen
resolutions of what of the DSL device
yeah so when you're creating the device
you get to say what the density of the
screen is right so back to the screen so
if I was creating a new device I get to
say the first of all let me let me pick
let me pick a target for example I think
I get to specify the resolution here or
skin I like it for example say look 1024
by 768 ok so this is the resolution now
I also get to specify the density of the
screen right almost of the new-new
displace of 240 dpi and most of the old
which is known as the the high the HDPE
our high density per inch as opposed to
medium density per inch which is a 160
dpi right so you can configure it here
yeah yes so when you're starting a
device you can say start but you can
scale it down so but this is just
literally just shrinking it zooming it
down so I do this because on the
projector my resolution is just slightly
smaller and in the bottom it gets
chopped off so essentially I just scaled
it by a factor of 85 but that's it it's
no big deal just cows it 85 percent yeah
so what's the strategy if you want to
target many devices and actually I think
Mark Murphy is getting a talk right now
next or tomorrow on on specifically this
and how to deal with the fragmentation
and all that but basically you want to
you you want to talk you want to be able
to when you say it your target right you
may shoot for the latest greatest device
but when it comes to the minimum SDK
required you want to be able to specify
as as all the device as possible and
then gracefully scale scale down your
feature set right what we were talking
about earlier so for example I may want
to take advantage of Near Field
Communication in my app right so I'm
gonna target you know Gingerbread right
but near field communication is barely
available on on only one device right so
not many people have it so if I want to
check if the device actually has that
and if it doesn't I want to disable that
particular feature so far so good
all right so so moving on from this
let's talk about the main building
blocks we're gonna basically start with
this and this is a section that's in my
mind very important as I said because
it's very specific to Android so there
are aspects of it that are you know you
can't seen anywhere else more or less
everything else is Java but this is
something that's new and before we start
I'm gonna do a little I'm gonna run a
little application that they have
hopefully it's gonna work I'm not sure
about this internet proxy that we have
but the application is basically it's
called the AMA it's yet another
microblogging app ie it's a Twitter app
so let me let me just execute it here so
I'm installing it a no brainier device
so it says please enter username and
password because it's the first time
we're log we are starting this
application so we don't have user name
and password so I'm gonna click on user
name the user name is student have you
ever noticed that when you start typing
and it's all characters you don't know
so the reason for that is is that for
some reason the default on our device is
to enable the I believe it's a Japanese
keyboard so what you want to do is you
know going to language and keyboard and
you want to turn off anything you can't
pronounce okay so let's try this again
of course I could have specified there's
much better I could have specified word
specific keyboard to use in this case
but I didn't so user name student
password is a believed password okay
server so let me just explain this we're
not using
whether per se because Twitter the
multiple reasons for that for one it
banned us because too many people at the
same time with the same username
password you get it gets denial of
service attack kind of considerations
and disables it but also so that's one
of the reasons so we have our own server
that's using the same API so it's the
same Twitter API it just hosted on a
different place so it's Yamba Maracana
comm slash api so with that i should now
be able to go to a to to my application
and it doesn't have anything so there's
no data right now what I'm gonna do is
I'm gonna go and I'm gonna say update
our status and by the way so this is
connecting to a server that looks like
this so you know boom are kind of calm
and so this is what it's on it right now
okay
alright so we'll have to deal with that
but um so if I say hello from click on
update this is now gonna be trying to
connect to ok so it failed but at least
told us that it's it's failing so it
could've failed from many different
reasons but network connection is
probably that's fine well we're gonna
work around that but but yeah that's
basically what he does so my point about
about this is here's a medium-sized you
know app it's got a couple of screens so
this is screen when you send your update
there's a screen where you can see what
your friends are doing there's not a lot
of data here right now because we can
connect there's a screen where you can
update your preferences right so that's
what the app looks like there's also a
service behind the scenes that is
updating the day
that recipe so with that in mind right
with this is a sort of a moderation for
the following conversation let's start
by talking about activities really
briefly so activities is one of the main
components that you use to build an app
it's the UI right so roughly one
activity is one screen right your
application may have multiple activities
just like a website has multiple web
pages they make you know multiple web
pages make a web site so you usually
have an entry point so usually have the
home page the main activity write the
activity to get started when you start
your application now what's interesting
about activities is that they can
activities give a fairly involved life
cycle so the life cycle of an activity
is fairly managed and this is where I
find programming for Android may be
different than what you guys are used in
programming in in standard Java so in
Android we are sort of programming in a
container environment right sort of like
if you have experience with applets or
servlets that's what I'm talking about
since you're basically writing code that
is responding to the callbacks from the
container right just like in a servlet
or an applet environment you're
responding to create you know in it
start stop and so on so here what we
have is we basically have a activity at
the beginning of the day does not exist
so we're in this starting state and the
user goes and clicks on the app says I
want to start your application and the
initial activity of that application
gets started so through the startup
process the following callback methods
gets get called on create on start on
resume right and ultimately we get into
this running state or visible state this
is when your activity is visible on
screen you can only have one activity
ever visible on screen right now the
goal of the system is to make user
experience as zippy as possible so this
is the active
the activity that gets all the
preference in the world gets all the
memory all the resources everything so
so basically so that's that that's what
happens with running activity the one
that's in focus now the user may jump
from one screen to the next and what
happens in that case is the activity
gets paused really quickly and then
stopped okay
so past eight is certainly not very
common to stay in pause basically means
that your activity is partially visible
but not in focus right so in a typical
small device you don't have this
happening a lot that would be equivalent
of like having sort of a dialog box or
something in front of your screen so
your screen is still visible right but
it's not nobody can touch it it's not in
focus so it doesn't happen that often
but we always run through our state and
route to being stopped now stopped
activity is very common so we have many
many activities in this state hanging
out just being stopped at some point
system may simply decide to kill the
activity right so you as a developer do
not have a say in this
right as a matter of fact you use
developer don't have a say in any in
what state your activity is in the only
thing you have a say in is what happens
on the transitions from a state to a
state so if we control these right
that's what we control but we do not
control the state that it's in right so
we're in a container environment so at
some point system may decide we are know
this activity no longer needed once to
free up memory kills it destroys it
right or a user may say oh I want to get
back to that's me all right the screen
that I was just on I want to flip back
to that screen we press a back button or
some other way navigate back to it maybe
some activity that you use a couple of
minutes ago it's still in memory right
so in that case this is what happens we
bring it back into the running state
yeah
on say fiscal state so so those methods
are also here I did so basically what
happens is there's a one additional
method here called own saving stone
state and there's an additional method
right here called on on restart when you
are restarting loading this mistake yeah
so the question is what happens if
you're like in the middle of typing
something and the phone call comes in
and now your charity for example goes
from running to stopped but you don't
want to have the users start typing from
scratch you want to kind of save that
information right or another good
example in the past was just rotating a
screener maybe I'm typing like my long
tweet and accidentally rotate the screen
and what happens we actually do this
whole thing you know sort of again we
restart it so we go here and then we
restart it over again so when you with
the rotation of the screen the entire
life cycle actually recycles the app by
default you can control that behavior so
so what happens is there's there's a way
to save and restore the state so you get
something called a bundle or bundle is
basically a data structure whose name
value pairs and you get to leave
information for yourself for the next
incarnation if you want so that's that's
what on saving under store are now that
used to be a much bigger deal around
around the cupcake release but later on
they actually improve the the frameworks
so a lot of widgets are actually smart
enough to do that themselves so in other
words a piece of text is going to let me
show you a piece of text if I'm typing
something here let me go back to the
screen and I'm typing yellow from so yes
so control ctrl f11 is going to rotate
it and there it says itself and this is
just a standard UI widget called that
it's X so I didn't do anything special
to preserve that piece of text yes
this green yeah so in back to the
previous question there are more
lifecycle methods I kind of pulled you
know I'm trying to keep this like as
little confusing as possible so I only
told the more important ones in here
trying to keep it sort of for
educational purposes simpler so that's
why I only kind of focus on the main
methods but there are more methods for
sure so why do we have three here as
opposed to just one let me get back to
that question in a second you just want
to kind of explained why do we have so
many states in the first place right
because for example iPhone just does
this you start you're going to running
you're running and then you go and you
get this choice so why why not keep
things simple why didn't we do the same
thing so the reason for that is that
this part here is quite involved there's
a lot when you're starting in an
application in starting an activity a
lot of things get you need to create a
brand new Linux process for it you need
to load the virtual machine into it
because in Android we have sort of a
sandbox in each application runs in its
own process with its own dalvik VM
totally isolated from anything else for
security reasons and such so we need to
start all this in allocate memory all
that stuff we then need to parse our
entire XML layout and we need to inflate
it into Java so a lot of Java object
creation which is you guys know it's one
of the most expensive things you can do
in Java then we need to draw that on the
screen in other words these steps here
are quite pricey right in terms of the
memory and in the CPU cycle so now user
is now in this state user is likely
gonna you know leave that screen but
just as likely is that the user is going
to come back to that screen at some
point so that's why stop state is sort
of a cached version of the application
so that if we want to come back to it
there
is much cheaper comparatively than
studying it from scratch so first of all
that's the reason why we have such a
comparatively complex life cycle yeah
okay yes I'm talking about an activity
okay - and that's a very confused those
two things right so assuming that we
never that you're it's a brand you're
just starting an application so
typically if you're starting an activity
I just stopped powered up my phone I'm
starting that cool new app that actually
if the application doesn't exist the
application it's good to get started as
well but you're right for subsequent
activities within the same application
you would intend to start the
application yeah so now why do we have
so that's why the life cycle is the way
it is now why do we have so many
different methods well because you may
want to do certain things in certain
places so let me give you an example for
so I'm like developing for you know web
or developing for desktop one of the
things that we care about in Android a
lot is battery right that's one of our
main concerns right you know like when I
was programming for the web I was
concerned about concurrency and
fault-tolerance all these crazy things
right we don't care about that here
we can't much more about the battery so
for example using things like GPS is
fairly expensive right GPS just sucks
the battery drive very quickly so if I
have an app that uses GPS when do I want
to start listening to GPS and when do I
want to want to stop listening to GPS
right so I have all this different
placeholders where I could do that for
instance I could say I want to start it
here right you don't create but that
means that I'm gonna be listening to GPS
for an undetermined amount of time
because I do not control when it's gonna
get destroyed and what am I gonna stop
it right so let's assume that I'm smart
about this and I wanna listen to GPS
only in this state in other words while
we're visible in other words when we
actually have the actual use for
the information that's how it's
typically done so what I would do in
that case is I would say all right let's
let's register for listening to GPS in
onresume
okay and because all the roads into
running lead to sorry this one but all
the roads to to running lead to on
resume okay
there's on resume there's on resume
right and there's on resume okay and
let's unregister in on pause because all
the roads out of running later on pause
right so that's how I would accomplish
that thing so that's why you have
multiple methods here back to your
question right so for example I may say
no no I want to actually listen to the
thing while in these states even what I
mean the background so in that case I
may say okay let's do it in on start and
let's undo it you know stop right you
may say I want to do it on restart right
which that would which only happens here
right and so on so you basically have
this different placeholders for so you
can accomplish what you what you're
doing what you're trying to do is that
sort of does that answer that in terms
of the life cycle so this is a this is a
very important thing from I find coming
back to this picture many many times
it's kind of like layers layers you know
killing an onion right there's many
layers of understanding called the life
cycle works and if I you should be using
it but just back to back to the code in
our little yellow world basically what
you're saying here is we're saying we're
gonna subclass activity that's our
yellow activity movin over I don't
create so that's our entry point in this
line here that is that expensive work
that we do of logo you know loading up
the XML parsing it and drawing it on the
screen right so in this particular
activity we do not do anything else so
on create is something that you almost
universally overwrite when you work on
any particular activity right it's
sort of like your init method or
constructor yeah yeah so so the fact
that I don't override the other methods
they're simply there by the fact that
were extending activity right so I'm
just not overriding them but but they
are there and they do something useful
so that's why you when every override
one of these on methods you have to call
the super of it and basically do
whatever the parent was gonna do anyhow
because it's not just a blank method
right yeah yeah is it possible for an
activity to start a night another
activity in path name value pairs yes it
is but not to a bundle so basically an
activity starts another activity via
intents which is our next conversation
and an intent is sort of like a URL with
a get you know you can put dollar sign
I'd equals 47 so yes you can pass some
primitive data types and we call them
extras in that case but it's just a name
value pairs so so yes it is possible so
the system may pass the data so this
typically first time around even when
when you just start an activity this is
gonna be now okay but if an activity is
going through just a quick configuration
change such as the screen rotated so
when you rotate the screen by default
the the activity is going to the whole
reincarnation you know of itself right
and in that case the system is going to
preserve some of the data in saving in
that bundle yeah so we are we're at 10
o'clock so we're gonna do a break now
but before we do a break I just want to
quickly check in with you is this new
stuff for you guys so old stuff is it
going fast slow about right good ok all
right ok let me know so we can adjust
call sauce I'll see in 15 minutes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>