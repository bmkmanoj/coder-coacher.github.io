<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon IV: Programming Android for the Enterprise | Coder Coacher - Coaching Coders</title><meta content="AnDevCon IV: Programming Android for the Enterprise - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon IV: Programming Android for the Enterprise</b></h2><h5 class="post__date">2012-12-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r0cgNtn_Ypw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">if you believe that if you believe what
you hear if you believe what everybody
is saying enterprise Android is just
about tap okay so so yeah you know the
days when when when you went out and
made a hundred thousand dollars writing
an iOS app you know an iOS game or
something like that are probably behind
us um and what's ahead though is is
things like this I mean this is just a
random sample of a random collection of
stuff that I found just by querying for
enterprise mobile it seems that the all
sorts of people are predicting that
that's just though it's sort of an advil
inevitable that's the way it's going and
I've always said that the big the big
place for android is not or a huge place
for Android it's not so much your phone
I mean that's nice at all but the place
that you're going to see Android all
over the place is these OEM devices when
the fedex guy shows up at your door and
you have to sign something that's going
to be an Android tablet and when a
waiter comes over to your table and
wants to run a card through something
that's going to be an Android device and
they're going to be all over the place
all the quiet things all the ones that
you don't talk to so much those are
going to be Android devices and Android
in the enterprise is making people
nervous so there are all sorts of
reasons at just mobile just mobile stuff
in business makes people nervous there's
the whole bring-your-own-device problem
as I say here let's not even talk about
security people are scared to death
about security um decentralizing the
business this one is huge of course is
that the load on IT if you can bring
your own device than I T is going to
have to at least either support it or
figure out how to tell you that they're
not supporting it or something like that
okay
so it's a big deal I think it's
developers though we have an additional
problem I think that as we asked the
mobile crew meets the the back-end
service crew there's going to be a clash
there's going to be a style issue okay
which I sort of tried to express here
with you know this guy who has a
master's degree in science and our
skateboard Punk over there mobile looks
at the world differently the mobile
mobile developers have a different
experience even java mobile developers
and even now that mobile has been tamed
to the point that it is tamed in android
how many of you had to work on j2me you
know I'm really sorry it just told me
apologize to you guys I mean that was
awful right and and there were worse
things around ok Android is fairly tame
compared to that stuff so here are some
things that web service developers take
for granted an incredibly rich source of
open-source frameworks okay we've got
everybody it seems to me that Julie
everybody who's ever written a web
service has written a web service
framework right there are a million web
service frameworks out there there are
great things like spring and hibernate
there's all this stuff sitting around
that that as a Java developer your main
job isn't to know a language or even the
library that belongs to Java anymore
your main job is to understand that the
environment of frameworks what
frameworks there are and how to use them
nearly every web web service developer
takes for granted an R DBMS and that's a
big deal because it means that for
instance there's such a thing as a
global singleton there's a way to lock
there's a way to say
across all of the instances that power
your your web UI there's a way to grab a
single walk okay because it's the
database that in the reel in the big
things the things amazon and Twitter
Google and people like that that's not
necessarily the case okay there they
outgrow Oracle or something like that
but a lot of us still think in terms of
it's possible to grab put a lock on that
row in the table and all of the
instances no matter how many there are
believe that that thing is locked unit
testing okay the unit testing is just
part of the of developing now it's just
part of the deal and this one is kind of
fun if you've got a rack if you've got a
rack mounted server back in your offbeat
back in your your somewhere what you
want is you want that thing running it
100% CPU all the time that's what it
means to be optimally used right god
forbid optimally used for my phone is
that the CPU never runs okay if the CPU
never executed a cycle it would be best
because the most expensive thing on
there is the battery things mobile
developers take for granted so first of
all networks are unreliable we're pretty
much used to believing a lot of us are
pretty much used to believing that a
network is just sort of extension of
your computer okay the stuff on on the
network is just always there okay and
and mobile developers know that's not
the case you can start to do something
just as you go through a tunnel and
that's that furthermore the OS is
unreliable and finally the hardware is
unreliable a mobile developers are
mobile developers work in an environment
where you can't count on anything where
everything is about details it's about
this works this time on this device that
works that time on that device right
there is actually some common ground i
believe so for us android developers and
activity is a servlet it really is it is
exactly a servlet it has the same life
cycle it has the same responsibilities
it's just a servlet we can talk to each
other about this an activity fills that
role developers on both sides have to
deal with the life cycles of manojob
managed objects objects come and go one
of the biggest problems in the Android
one of the things that's hardest for
people to get used to is that that there
they don't have an application they have
an activity or a service or something
like that and that service can go away
without without much notification well
anybody who's dealt with j2ee is totally
familiar with that okay so that's a
something that we share concurrency is
in your face in both environments and
testing is painful in both environments
any place where you have a container
where you have to work in a container
testing is a pain so what I'd like to do
for the rest of this talk as I'd liked
it I'd like to pick a couple of things
that have appeared that have that
challenged me when I started doing this
I took the wrong path right and i ended
up doubling back and and doing it a
different way right and maybe I can save
you some time there's it what is it I
the friend of mine once told me and I
don't know if this is a factor not that
there's a sign on the wall of Carleton
College and the gates to Carleton
College it says learn from the mistakes
of others you can't possibly live long
enough to make them all yourself right
for what it's worth so what I'd like to
do here is I'd like to pick these three
things and I'd like to do I'd like to do
deep dives in just a couple of places in
each of them okay I'm not
present either an overview of any of
them or detailed implementations of any
of them I'm going to pick and choose the
things that I thought were in either
painful or interesting okay so if this
seems like a hodgepodge it's because it
is so my first suggestion is that you
just get over it and embrace cursors
okay so if you come from web services
the first thing you're going to do is
and you hear that you have to deal with
data the first thing you're going to
look for is some kind of ORM some kind
of object relational mapping software
hibernate or something like that the
baddest there are a bunch of them around
they exist for Android my advice pay no
attention just use the cursor so here
are some reasons here's some reasons
that I suggest this first of all it's
the simplest thing to do okay a cursor
is already there the cursor cursor is
already sitting there it's already um
pretty amazing it works across processes
and things like that just use it the
second argument is the cursor loader the
cursor loader is a man is a fantastic
way to get data into your application
quickly and easily okay it works you
don't have to worry about managing it
and stuff like that it just works a
cursor loader depends will return you I
cursor okay won't return you some it
won't return you some you know orm tool
it will return you a cursor use it a
listview puts the cursor right up
against the glass okay you hand a
listview you hand its adapter a cursor
adapter a simple simple cursor adapter
you hand it the cursor it's right up at
the glass that means does that is to say
that all the way from the back end all
the way from the database cleared
the glass android is already thinking in
terms of cursors content observers
content observers make life really
simple when you use when you want to get
updates when you use this second
technique I'll describe in a minute
especially when the data set underneath
a cursor updates you can get
notifications really really simply using
content a Content observer on a cursor
and finally the cursor works across
process boundaries exactly the same code
the code that you write in your activity
to load information from a database
works whether that database is part of
your process are part of somebody else's
the big arguments against the cursor are
that the mutable row pointer okay it's
it's a pain in the neck that somebody
can move the pointer around on you if
you if you ever want to see really
really interesting bugs in your view
binder which is part of a list view in
the view binder move the row pointer
okay move that you have access to the
cursor just move the road pointer boy is
that awful okay so you need you need
some sort of protocol for managing that
row pointer the second problem with with
cursors is that they're not thread-safe
okay so so if you're going to pass them
around across threads you need to do
something
I have a suggestion here this isn't the
first of my deep ties I have a
suggestion I suggest that you that that
if you need it in the in those
circumstances where you are not passing
the cursor directly to a list view and
simply viewing it which is mostly what
you will probably do in those cases
where you need to do some calculation or
you know you need to do computation on
stuff that's in the cursor that you wrap
the cursor with a really simple wrapper
that that provides you with getter
semantics and restricts access to the to
the RO pointer and the cursor so I'm not
saying that this is a solution this is a
general solution okay in particular it
doesn't handle and too many
relationships okay it doesn't handle the
case where you wear an ORM would return
a list okay it doesn't do that and it's
still not thread-safe but it is kind of
neat so here's an example this is this
is how you would use this this tool to
wrap a cursor the constructor takes as
arguments it takes the cursor that
you're going to wrap as its argument to
the super constructor it passes that
cursor and a list of the names of
columns that that cursor might contain
in this particular case what you see
here is these are are all of the column
names from the contract ok so the
content provider publishes a contract
that contract has the names of a bunch
of columns in it you simply put all
those columns here in the constructor
and then you write your getters and
together simply get back the value from
those columns in use it this is um
unnecessarily sparse I think but the
point is that if
if the top if the container if the
outside the top layer holds access to
the cursor and it's the only one that
fiddles with the cursor pointer and you
use the wrapper to manage the cursor
everywhere else most things that you do
are safe okay it's still not thread-safe
but most of the things that will happen
inside there are safe because nobody can
get at that role pointer nobody is
actually looking at the cursor and
they're using standard getter and getter
semantics to get stuff out and here's
the base class all it does is it it
builds it builds a map so it walks
through the cursor so it has to do this
at at runtime it has to each cursor
contains different things and may
contain the columns in different orders
and so on so it has to take the cursor
walk through it and for each of the
arguments that you passed here it has to
see if that column is in the is in the
cursor and then it just provides a way
to ask for the index that corresponds to
a column name you probably have to do
that anyway this doesn't cost anything
you have to compute that column index
you have to compute the column index for
the cursor name anyway so you might so
this may be excessive in that it cut it
computes more column name indices that
you actually need but it's two or three
the only real expense is getting the
thing out of the map I suggested I
suggested
so my I've just shown one way to sort of
ease the to make cursor access a little
prettier and I suggest that that the
point of one of the reasons for da OS
and so on is too abstract cursors away
okay in your in in your web services
people wrote programs and they want to
abstract the idea that you're dealing
with a sequel database they want to
abstract it away so they decided so that
I mean the direction that they took was
say okay we'll hide the cursors cursors
are inherently database objects let's
hide them my suggestion is that you take
a different tack on this and you think
of a cursor as a relation okay relations
are well-defined there well understood
they're easy to explain and they're good
abstraction for data a cursor is a
relation use it as your abstraction just
go ahead and use it and what's next well
next is that networks are data if you're
going to do Enterprise Android you
really owe it to yourself to look at
this 2010 talk I think his name is dope
dobzhansky it's a brilliant talk
although it might take two or three
times through it to understand it um and
what I hope to do in the next 15 minutes
is is help it is how about with that
okay so when you go back and look at his
talk it might be a little bit easier to
understand after listening to this if
there's a key to this to what I'm saying
here today it is this ok this is the
heart of enterprise Android this is the
thing you have to do right
so the point here is that it's a figure
eight is that the you I never ever ever
talks to the network the UI only talks
to a local cache which is a combination
of a service and a content provider and
then this thing is synced up with the
network here's what outbound processing
looks like so the user changes state for
example consider contacts or something
contacts that are synced to the to the
network right so the user changes
somebody's phone number okay and trying
not to say async task here because I'm
going to be all over them in a minute
but but the state changes so what
happens next so they hate the activity
is the thing that's responsible it's the
controller it handles the station and
what does it do it calls the service
helper calls down to the service offer
it makes a method call like change
contact telephone number okay it's a
perfectly standard method call nothing
nothing tricky right it doesn't have to
think about an async task doesn't have
to think about any of that stuff it
makes a straightforward method call to
do what it wants done the service helper
converts that method call into an intent
now there's a really straightforward way
to do that and I'll show you in a minute
what that is but an intent simply exit
if you look at an intent you can see it
as a method call it's got a name which
is the operation that you want performed
and that a way to add parameters to it
and a way to get back a response which
that's the trickiest part but all this
does all the service helper does is
convert from the method call
to an intent it's a very simple piece of
code it fires that intent off to this
service the service is there because it
is the context in which everything
beneath runs that is to say it is the
context in which all of this stuff
happens the processor is the hard part
the processor does two things the first
marks the record marks the corresponding
record in the content provider as dirty
and then fires off a request that will
sync it up synchronize it up one of the
great things about this is that that
means that the dirty marker is in the
content provider you can reflect the
complete state to your user at any time
your list view for whatever is in this
content provider for instance your
contact can ship for instance show this
guy in italic saying this guy is dirty
okay your state is different than the
network state and that can persist for
months right you can show because
because the dirtiness because the state
is is in the content provider you can
reflect it to the user finally the rest
method is an analog of the service
helper the rest method simply translates
a method call by the processor which
says update the telephone number on the
network into a rest call that does that
inbound processing works nearly the same
way so the network data changes state
and that can be a number of
possibilities either the request that
the processor sent out gets a response
I've updated that record or you get a
GCM call or worst of all you have to
pull now if you don't control the server
you might have to pull there are good
ways to pull and bad ways to Paul all
waste always whole are better than
getting push but sometimes you have to
do it so the rest method calls the
processor with the state change the
processor updates the content provider
and if that caused a real change your
app finds out about it the UI finds out
about it because it has registered
content observer is that is that pretty
clear so one of the things that that mr.
John ski says in his presentation is
that he's not going to show you code and
he's hope he hopes you're glad about
that so i'm going to show you code and I
hope you're glad about that um so the
case for this architecture it's
dramatically simple that dramatically
simpler I I spent I spent maybe a year
working on developing researching async
tasks in how to make them work and what
to do with them and they get they get
bizarrely complex they can get bizarrely
complex and not only that but but stuff
that stuff that should be stuff that
applies to all of your async tasks gets
distributed across each of them okay
it's hard it's hard to build async task
frameworks it's hard to build a
framework that underlies your async task
okay it's hard to abstract things out of
your async tasks you end up with these
tremendously complex async tasks that do
such things as retries right which is
it's just horrible or when they fail
they try to post a toast or put
something in the status bar or something
like that right it's it's awful this
architecture almost gets rid of it gets
rid of a sink tasks it basically gets
rid of acing tests they're hidden in an
intense service yeah he's not because
he's on his cousin ray sometimes I mean
I've had closer yes so how do i refresh
my you I don't I think toss so you would
need to register content observer you
it's very easy registering a Content
observer on a cursor is really simple
and not only that if you do so what I'm
saying is it just makes it easier okay
loaders know how to handle cursors
cursors know how to handle content
observers okay if you if you aren't
going to use that that really easy path
all you have to do is read up on content
observers and v1 all you have to do is
handle the change um so the downsides of
this architecture is that the content
provider can be complex in the processor
is complex current it's tricky so as I
said just dumping async tasks is a major
win the async tasks now live in in the
intent service okay this is this is this
is a very good thing um who can tell me
who knows the two big problems with
async task what are the two big problems
with async tasks the first one is
leaking them the first one is that if
you have a pointer to an activity from
your async task then the activity can't
be garbage collected for the life cycle
of the async task
okay that means that any time that this
async task has a different life cycle
than your activity if the if the async
task has a reference to the activity the
activity has been leaked okay you've
leaked an activity activities are big
ugly objects you don't want to leak them
the second yeah by the way exactly
that's exactly correct on the other hand
if you destroy an async task that easy
in the middle of handling a retry you've
got a problem the second problem with
this is is that is it is that when it
fails it may have nobody to talk to at
worst it will still have a reference to
this activity which has been destroyed
and it will try to use it and it will
crash at best it won't have a reference
to anything at all and the failure just
goes away my claim is my claim is that
it's really hard to implement acing
tasks correctly okay so in particular
one of the things that you can do and i
actually have code up on github that'll
do this is you can drop the reference to
this activity and pick up the reference
to this one that's a perfectly legit
thing to do but it makes your async task
this incredibly stateful thing you can
do that you know godspeed if you do what
I'm suggesting is that there are simpler
wasted that that this architecture puts
that complexity in one spot and it makes
it really clear how it works yes update
yes yes that's that's that's a very
that's a great idea yes it's not what
I'm doing here but that's a great idea
yes and and there is an async task here
there is an async task in this
implementation and I'll show you where
it is in a minute so um walking down
stack the service helper although one of
the things that one of the things that's
kind of hard about Doug Jin skis talk is
that he draws this architecture in which
all the boxes are the same size okay and
the thing is that the service helper the
second piece down the stand really is
incredibly simple it's an incredibly he
is separating these things by separated
into their concerns he is separating
them architectural II but just because
he separates the market textually
doesn't mean there's a huge amount of
code that that comprises each one some
of them are very simple in particular
this one and this one are very simple
the rest method and the service helper
so let's walk through this service
helper and see what it does so there
there are a bunch of output of ways to
implement this service helper the
service helpers responsibility is to
hand this task it's it gets a method
call from the activity that says for
instance update this contacts telephone
number and what it wants to do is it
wants to pass that off to a service okay
there are a bunch of ways to do that one
is you can make that you could bind the
service so when the activity wakes up it
could bind the service it when it does
when it binds the service it gets back
in interface and it uses that interface
to make calls okay that's perfectly
legit another possibility much less
legit is that that it can use some kind
of communication mechanism that involves
broadcast intents okay that's that's
entirely possible and it might be useful
in a case where you want to do pub/sub
okay where when when the service replies
or something like that you want lots of
pieces of your UI to update right that
it would make sense to do a broadcast
there but when i'm going to show you
is the one that is newest to me and the
one that I think is sort of simplest and
easiest to grasp is doing it with a
pending intent this is kind of cool so
here's the code I hope you can see it so
this is that this is the UM this is the
method in the service helper okay so
that the activity calls this service
helper the service alper is a singleton
that the that that the activity knows
how to find it calls send my request
with a bunch of arguments and the
current context at the end itself right
so all that this all of this guy does is
build an intent this part is pretty much
straightforward the only tricky part
here is this thing this create ending
result create pending result is a method
on activity that creates a pending
intent which when it is sent will call
the activities on handle something on
activity result okay so this this method
creates a pending intent it creates a
little object which when it's send
method what is called will first of all
even if it is in a different process let
alone different thread from a different
process it will change to this
activities it that intent will be fired
from this activities process and it will
call it's on activity result method okay
so what we're going to do is we're going
to pass this intent as one of the
arguments we're going to send it off to
the service
here's the service so we're walking down
the stack that's the service out where
the service helper calls the service
here's the service this by the way is
where the async task is hit a normal
service doesn't have an unhandled intent
method it's got a non start method the
on start method of an intent service
spawns essentially spawns a new say sync
task and hands at the intent that async
task calls on handle intent with the
intent so this method runs on a
background thread hey you've gotten this
thing so so it is a common
misunderstanding probably not in this
room that service is run on a different
thread services in fact run on the UI
thread in general a service runs on the
UI thread in order to get things off the
UI thread you can use this intent
service which gets things run exactly
the way you want them it gets them run
in order and on a on a thread in a
thread pool so this guy process request
is the local method that does whatever
it needs to do ok this is the brains of
this operation it's you know it's an
implementation it's your business logic
but it is past all of the arguments this
guy put all those arguments in here
added them as extras with their with
their names this guy now gets them out
and uses process to process them
whatever this thing returns is put into
the response with the tag returned
and then we just send that we said we
pried the call back out here right so we
put the we put this pending intent in
with the name call back here we get it
back out so this thing is the pending
intent and now we just send the pending
intent this response is this intent with
these extras with with this return value
put into it so now we have an intent
with the return value in it this does it
an intent Fillion that is it copies all
that all this stuff from this into the
response the pending intent response and
this sends it off and now we're back at
the service helper so this is the return
to this into the service helper the
service helpers on activity result
method is called as a result of this
send causes this method to be called
inside that method we caught we use the
service helper we just invoke the
service help helpers handle response
method it gets the result status and
pulls the return value of actually this
probably should be personable this is
really this is um this is really neat
it's sweet and simple okay there's no
binding services there's no worrying
about about broadcast intents flying all
over the place okay it's really
straightforward it's really simple and
it's um it's framework of all
and it's on github so moving down the
stack the processor is that the
processor is the part of this that's
hard okay the processor is the thing
that has to handle what happens if there
are multiple requests outstanding at the
same time and so on it has to handle all
of that stuff I assert though that it's
practically impossible to handle that
stuff with an async task if you have an
async task and the guy hits the button
the guy matches the button and you
launch a bunch of these async tasks I
mean I found that hard to take care of I
found that to be a real pain this it's
real easy to handle the processor knows
processor simply records weather weather
um there's a pending request out to sink
this data or not and if there is doesn't
do anything if there isn't it marks it
dirty and starts one you do have to
manage concurrency there is you know
there's all sorts of concurrent stuff
happening there's stuff coming in from
the top that's concurrent there's stuff
coming in from the bottom that's
concurrent use transactions liberally
watch your database the database it is
possible to corrupt the sequel light
database with concurrent transactions be
careful and finally there's the rest
method it's not always appropriate but
if you're if you're actually going to do
this stuff once again I recommend have a
look at using a sync adapter a sync
adapter isn't always the answer but it's
often the answer especially if you have
to log in okay especially if
synchronizing implies logging in first
and then synchronizing the syncadapter
might be just the right thing and
finally this note um
this is hard to find when I for instance
when I had to find it for this lecture I
knew it existed but it's hard to dig up
it is in the it is in the documentation
for default HTTP client it says that if
you're using old Android use the Apache
client but despite everything you hear
everything that you hear to the contrary
post gingerbread use the HTTP URL
connection yeah it's in the in the docs
for default HTTP client edita android
com dubbed in ski for instance says
exactly the opposite but that's because
he's on fri oh so the point here is that
in the long run async tasks are are
flawed in that they hide they hide state
transition in objects that are ephemeral
okay they wrap the entire state
transition in something that is going to
go away better is a better idea is to
put that kind of put the state
transition where it belongs put it in
something persistent put it in the
database and finally let's talk about
embracing content providers I I have a
harder time making this Lizzie I will I
will argue the preceding two things I
will argue about with you i will stand
my ground on those this one not so much
this one I can imagine that just you
know taste dictates that you want to do
it differently my my belief after i
started out what let's see one of the
first things that I saw was
documentation in um in the in the
description of content providers that
says when you
content provided the first thing you
need to think is as it says here first
thing you need to consider is that if
you're not going to share your data you
may not need a content provider at all
so I spent I wrote 7 10 applications
each one of which had its little dao
that hung in the hung in the application
okay just take the dao hang it in the
application anybody who wants it can get
it from there okay it's a singleton I
end up thinking that's the wrong thing
to do I end up thinking that any Android
a content provider is the dao just use
it my reasoning all the arguments for
cursor apply all of the things that I
said about cursor apply in particular if
you look at a cursor loader it works if
you look at an async if you look at an
async loader you will find that it
doesn't ok there's an there's been a bug
outstanding for the sense Oh version 8
well no obviously not since honeycombs
over since version 11 there's been a bug
that causes that that requires you to
write a little boolean to step to make
sure that your cursor loads ok that's
not in cursor loader cursor loader just
works if you write your own subclasses
of async task loader you have to there
they don't necessarily work you're going
to have to track down that bug and make
sure you fix them right and the last
thing is that a content provider allows
you to publish your data to other tasks
rather to other things and my suggestion
is that that's that in the long run
that's the Android way right in the
Android way is is make your stuff public
is let other people use it let other
people use it in ways you didn't expect
right I think you're going to want to do
that so do it now
the problem is that the API is
constrained it's a REST API it means you
have to get used to the idea that your
activities are going to do rest you're
the back end of your activity is going
to be rest okay the other thing the
thing that I find most annoying about it
is that batch operations are harder
batch operations are tricky trying to do
something a lot of things in one
transaction is kind of a pain and as I
said I admit that this case it's harder
to make this case than it is to make the
previous two on the other hand it's a
chance for me to talk about the query
builder which is really cool so if you
build a content provider your contract
publishes the names of virtual tables
with virtual columns in them don't make
those the real columns don't make them
the real tables that's its exposing too
much information people obviously if you
do that people will depend on it and
when you change when you change your
database structure they'll break okay
make sure that they can't ever see the
real tables make sure that they can't
really see the real column names and the
query builder is exactly how to do that
so first of all when you get it when the
when the content provider gets a request
it's going to get the retread request
through a URI that URI determines the
name of the virtual table so you can use
any table you want in fact what you will
commonly do or what you may very well do
is build a virtual table out of for
instance a joint of multiple tables okay
so you will build a virtual table in
response to this query which and you can
pick any table you name you want it's
not specified in the query all you get
is the URL on the other hand the
projection is part of the query API so
your your clients are going to tell you
what columns they want to see and it's
tricky to make that work
the query builder supports something
called a projection map the projection
map so if the way you come on a query
builder is because you want to build
complex sequel queries it appears to be
the only way in Android to build for
instance a join query okay but if that's
the way you come on it you're going to
see this projection map and you're going
to wonder what the heck is that thing
for and my my guess is that the
projection that is that query builder
was originally written to support
content providers the query that's why
the projection map is in there and it
happens to do some other things as well
right it happens to do joins as well but
it was written to support the content
provider so the projection map is simply
a map of virtual column names to the
names that you actually want to use a
naive mapping won't work okay and this
this query is an example of why so if
you naively map your virtual column name
to the actual column name right so so
your projection map simply contains the
virtual column name is the key and the
real column name as the value what
happens is that for instance it will say
it will end up mapping ID it will it
will say select real column name because
it will replace the virtual column name
with the real column name from my cable
order by virtual column okay it did so
this is nothing anyone knows anything
about okay that query will fail you see
why this query will fail I didn't make
it clear here but what you've done is
you've replaced virtual column in the
projection with real column which is the
name of the real column in the table but
you didn't do it out here you didn't do
it anywhere else in this query so if
it's in the if it's in the where clause
it won't work if it's in the order by
Clause it won't work on the other hand
there is something you can do which is
in your
in your projection map map the virtual
column name to real column as virtual
column to the string real column as
virtual column okay and this works great
so for instance all sequel light
databases have a column a virtual column
called roll ID which turns out to be an
integer primary key in order to see
something in a listview you need an
integer primary key called underscore ID
well what if your table doesn't have one
well it does now so you just map row ID
as ID and real column and its virtual
column now this virtual column works I
think I think that this works pretty
well and and that means they're going to
have to parse everything I and not only
that but but the sequel light is going
to parse it again it seems that it seems
like this is sort of the best way to do
it so this is what you get you get this
is the virtual name this is the virtual
name and you map it to the virtual name
or the real name as the virtual name and
one of the things that you can do here
that's pretty cool is this is a
completely virtual column this is this
is completely made up right but you can
I have this case that I then map as the
virtual column name
um this is important I didn't mention
this but this is important if you are
normally the query builder will throw an
exception if there is no key map
matching the name of a column unless
unless the key contains the word as so
if the projection says select you know
foo as bar that will pass through but if
it just says foo and you don't have any
column name foo you'll get an exception
instead I know it's the key it looks for
the key so it walks it looks at these
things and matches them as keys in that
table right so if it can't find this as
a key in your table it's going to throw
it out unless it looks like this in
strict mode it doesn't care even if it
has an AZ in it this makes you very safe
this means that that even even people
who guess your implementation can't get
through your query builder right they
can't pass the real names of your
columns through and the query gets dead
simple the query gets just completely
trivial set strict this by the way this
method only this method appears in maybe
13 so it's not available or older
versions of the of the API set the
projection map set the table run the
query it's safe and easy as I say I have
a harder time making this argument I I
sort of I admit that I even sort of
sidestepped it I haven't really made a
strong argument for using
content providers I think it's the right
thing to do though I think the strongest
argument for me was that was the cursor
loader so what do I want you to take
away from this so on a high level when
you're working with people so you will
when you're building enterprise
applications it's half yours if you're
working in Android it's going to be half
yours and have somebody else's okay and
not only that but you're going to get
into each other spaces and you're going
to start talking about each other's
designs be prepared to stand your ground
be prepared to know what you're talking
about and convince other people to try a
new way okay there are things there are
things on mobile platforms that honest
that God don't look like the back you
know look like server servers be
prepared to make that case on the other
hand also be prepared to try something
new yourself android is not standard
mobile Android works differently android
is the similarities between Android and
j2ee are astounding right all the way
from from you know life cycles to the
difficulty to debug difficulty to test
in debug there are things that that
people who have done back-end
development for years will know about if
you come from strictly mobile space be
prepared to learn from them don't fear
the cursor just go ahead and use it
right go ahead use cursors all over the
place invent nice ways to wrap them up
but but go ahead and use them in only
use async tasks locally don't ever try
and do something over the network with
an async task it's possible but it's
just a bad idea and then some other
things that I hope you take away from
this or at least have access to the code
to do um I proposed a way to wrap a
cursor that I think is pretty clever and
pretty you
full I use it a lot depending into using
a pending intent for a service call back
is very simple it doesn't require
binding it doesn't require a IDL it's
very simple very easy to implement I
recommend it to your attention and
finally using the query builder for
mapping to map virtual tables to to real
tables inside your content provider
thanks a lot slides in code soon at at
github be Mike and it will probably be
an end I haven't put it there yet so I
can't be sure of this but it will
probably be in and F come for if it's
not it'll be nearby alright thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>