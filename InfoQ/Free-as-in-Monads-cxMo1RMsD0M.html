<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Free as in Monads | Coder Coacher - Coaching Coders</title><meta content="Free as in Monads - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Free as in Monads</b></h2><h5 class="post__date">2018-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cxMo1RMsD0M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is a talk that I gave that at any
Scala and I finished the important part
of the talk in about 15 minutes so if
you guys don't have any interactions
that all this will be really boring and
we'll just finish in 15 minutes but if
you guys have a lot of questions which I
hope you do then we'll we'll run on sort
of longer than that so sort of audience
audience driven development this is all
going to be live coded I'm gonna sort of
do things in an editor over here think
hello world line hi all right this is
your last chance to tell me that the
font is unreadable or the color is
unreadable because otherwise we're just
basically and go with this my name is
Daniel speak for those of you who don't
know I work at a company called slam
data yeah that's basically me I've
talked about a lot of stuff and today
we're really talking about the free
monad so how many people here have heard
of the free Mona cool like basically
most of everybody now honest question
and no aspersions how many people here
like really really understand it
awesome this talk is for you like I
really I I really really want this to be
a like come in with not understanding
come out with like yeah I get it like a
hundred percent we're good right you may
not you may not like it at the end of it
but like you'll you'll understand it and
if you don't understand it
maiya culpa and the way we're gonna do
this is the way that I learned to
understand it because like honestly I I
even used the free monad for years
before I really really got it and the
way I got it was just implementing it
myself like just from scratch from an
empty editor buffer so what we're gonna
do is command a delete we are gonna
implement the free monad starting right
now cool all right so now what we're
gonna do so what the free monad is is a
monad for any type constructor so for
any type constructor F takes a single
type parameter we're gonna implement
pure and flatmap so now remember pure is
is that thing that takes an A and gives
you you know an F of a where F is a
monad and then flatmap is that sort of
complicated thing that takes an F of a
you know function a to f of B and gives
you an F of B right so you've got you
lift something into the monad and then
sequentially by the way
so our goal is to provide this
functionality for any type constructor
and buy any type constructor I mean it's
not just like option or list or like you
know easy things like that I mean like
my random completely unconstrained thing
that doesn't even have a x' inside of it
of a right so like just completely
random stuff so can can we actually do
this well let's see what we can do so
we're gonna start off with you know
sealed trade sealed treat sealed tape
free of F I'm gonna give us another line
there so sealed trade free of F of a
okay so it's gonna be the free monad for
any type constructor F and it's a monad
so it has an A inside of it right so
we're gonna have to do that and we're
gonna have a flat map okay so that this
is just part of what it means to be a
monad right we take an A to a free of F
of B and we give a free of F of B right
everybody following me so far this is
this is exactly what we have to do and
we'll just like triple question mark
that out for now and I'll create a
companion object here and on this
companion object well we already talked
about how we need pure right so pure
takes an A and it returns a free of f of
a okay so this is the this is the return
function from Haskell scholars ed calls
this point like I I don't know like
whatever you want to call it it's it's
pure right okay so we have to define
that function and I'm gonna add a third
function to this mix here just because I
know the future and I know what's
actually useful here which is okay we're
gonna we're gonna call it lifts M okay
and it's Oh actually Simba D correct me
on type signatures here all right so we
have to have enough obey that right by
the way because I'm a coward we're not
actually compiling this for real we're
just using the compiler of my mind
because that way my talk can't like
flame out and like randomly fail so if
you see me like makes them sort of like
Scala salep system like tell me because
otherwise I just won't notice
all right so lift down is gonna take an
F of a and and put that into a free of F
of a okay
this seems like a reasonable function to
have right so maybe maybe we don't
already we already
something that's in you know f of a we
want to put it into the Fremont we want
to get a monad for our arbitrary type
constructor right so these are the
functions that we are trying to
implement so let's see if we can do this
right let's start with pure okay
pure seems like it's probably the
easiest thing to do right so what can we
do now we will notice that free
currently doesn't actually have any
structure right we haven't implemented
any constructors for the free ADT so so
presumably we're gonna have like you
know down here here be case classes
right so stuff stuff is gonna be down
here okay
so pure well we don't have any structure
we don't have anything that we can do
with our a that turns it into a free so
probably the easiest thing we could do
maybe is just you know add a case class
pure of a contains an a and it is a free
of that fact okay so if we've got that
then this is really easy right pure of a
done cool so okay we've implemented one
of our three functions 30% done what
else are we gonna do well let's what
about lift down okay
so lift em well here here's the first
question we should ask right so we are
we've got some structure now right free
free actually means something
can we take an F of a and put it into a
free FA can we actually do that given
the structure that we have and the
answer to that is no right because if we
tried to do something like you know pure
of FA this would actually end up being
like free of F of like f of a or
something like that right that's that's
completely not what we want so so we
need to do something about this so well
what can we do well we can't do it with
the structure we have so let's let's
just add another case class right lift
underscore a fa fa extends free fa okay
lift fa all right sweet okay we're
two-thirds of the way done guys
cool does anybody object to what I've
done so far it seems pretty
uncontroversial right flatmap okay so
can we can we amble my flat map for this
thing well we could probably implement
it if we only had pure
right so like pure we get the a out of
that we probably find some way to like
turn it back into like a free free of
FFA but the thing is that we also have
this lift thing right and so we can't
you know that this the the signature of
flat map right requires us to provide it
with an A but if if the if the free that
is represented by this is just like you
know is a lift then that lift contains
an F of a well we don't know anything
about f we don't even even we wouldn't
even know if it contains an A so how are
we going to get that a to give it to the
function well answer is we can't and and
there's you know sort of very elegant
proof that we can't so I'm gonna learn
how to type and import things so so what
can we do here well we can basically do
what we've been doing so far and we can
cheat case class flat map uh I'm going
to call it e and you know self is going
to be free F of E and then we're gonna
have some function e to free F of a and
that is a free F of a cool so now we go
up here flat map this and F right that
works and we won't say because we're not
actually saving and that is the free
monad applause oh yeah ok this is super
confusing right because we didn't
actually do anything like nothing
nothing is actually implemented here
right we just like wrote a bunch of data
and then you know called a day but
honestly like I'm not actually lying to
you this is the free monad this is all
there is to it so obviously this is not
useful sort of in its current form right
so maybe maybe it might be nice to write
a function that actually maybe does
something with this data something
that's that's something other than been
a type constructor oh by the way just
because I'm paranoid about the JVM with
that final all right so so so what's
another sort of function we could write
here because we've already satisfied all
the constraints to be a monad and by the
way this is a lawful monad hilariously
right like this this is actually like
completely valid no one will complain
about this so anyway a function that's
that's traditionally put on the free
monad is something called full map
okay now the full map function is a
little bit tricky and there's a reason
for its name that we'll get back to in a
second but the full map function says
okay given some type constructor G
they're completely different than F and
that G that is a monad okay so we have a
monad for G and a a function called a
natural transformation that maps from F
to G and we'll loop back to what this
actually means in a second
give us a G of a okay so so there's a
lot to unpack in this time signature but
what this is saying is we've got this
free monad structure thing that has some
stuff inside of it maybe a bunch of flat
maps maybe some lifts and things like
that so start what where is the a from
the a yeah we're we're inside of free
right now yeah so the a is in scope okay
so we've got we've got this free that
has like some structure and things and
and you know it represents all these
operations and we've got this other
completely unrelated type constructor G
that happens to be a monad so we know
that G is a mod F is not a monad G is a
monad and we want to sort of convert our
free structure and sort of interpret it
into G and and you know given a way of
actually converting the individual
thunks and what this allows us to do is
allows us to sort of defer the notion of
interpretation we'll get back to that in
a second but this is the function that
actually does things right because you
know we're not we're not just gonna like
run you know create a new case called
full map and call it a day right and
we're actually gonna we're actually
gonna write this function so before I do
that though I want to be clear about
what natural transformation is right so
this this funny squiggly arrow thing
here this is Scala Zed syntax if I write
this in terms of cats it looks like it
looks like this right so that's that's
maybe a little bit more familiar
so what function K is is it's it's a
function that takes to type construct or
it's a trait that takes to type
constructors and it has just as a this
this like a a can't type apply apply
function that takes an F of a and
returns a G of a
so a function k is just basically this
notion of mapping between two type
constructors right so for any F of a or
F of B or F of C or like f of anything
right F of anything we can get G of that
same thing
that's what function K says it's
literally a function on type
constructors as opposed to a function
right on types okay
so this is a really useful thing so
we're saying is given this natural
transformation you know function K up to
G and the fact that you use a monad we
can do this so so how are we actually
going to do this alright so we're gonna
we're at a pattern match on ourself and
start implementing things right so pure
of a so what do we what do we have right
we've got an A something of type a and
we need to return a G of a right because
that's what the type says we have to
return so how do we get our a into a G
of a well we know that G is a monad
right and remember from earlier one of
the functions that monads have is pure
which takes an a and puts it in you know
Emma Bay so we can take an A and put it
in G of a because we have monad for G
right pure of a and this returns a G of
a right everybody everybody agree with
that seem seem satisfactory cool all
right so another case that we could have
here is lift right so lift I mean this
is an F of a inside of here right so so
we've got a lift what are we gonna do
with that well we have an F of a and
we're trying to get to a G of a and we
have this function K thing sort of
handily here which says for any F of a I
can give you a G of a so so we just call
natural transformation on F of a and
this will return G of a right cool so
far so good
nothing terribly complicated all right
flat map this seems like it'll be scary
right so inner and add F okay so how are
we gonna do this right
well inner inner is of type like free
you know f of E right where E is like
use something complicated I made it
lowercase for reason it and then f is
like e to free of f of F ok so we've got
it we've got to turn this
in a G&amp;amp;A how are we gonna do that well
we can't do anything with F just yet
because we don't have an e write this e
is like this mysterious thing that comes
from somewhere the only place it can
possibly come from his inner so let's
let's do something with inner right well
what can we do with inner
well we can flatten a pit but that's
probably not going to help us but
because you know if we if we just flat
map it right we're essentially back
where we started but the other thing we
can do with it is we can fold map it
okay so if we fold map inner sorry
internet fold map natural transformation
this is gonna return to us a G of E
right everybody agree that those types
work out and I'm not that's not a
rhetorical question by the way I might
have just like simply made a mistake
so keep keep an eye out this is the
dangers of not compiling your live
coding so so full map natural
transformation that gives us a G of E
but can we take that E and like sort of
do anything with it well we know that G
is a Moana and the two functions that
monent have are pure which we already
used in flat map right so maybe we can
just like monad G flat map right I just
put my computer to sleep and that is
fantastic ladies and gentlemen the touch
bar let's see if that comes back out
cool all right note to self disable that
button all right a flat map this okay
and this is gonna give us an e okay so
there's we've got this lambda now that
that will take an e from the flat
mapping on on G using moto G right so
now we've got an e what can we do with
it what we can call f okay that's that's
actually literally the only thing we can
do with e because there's only one
operation on it so
so we've now passed this into our
function we're making some forward
progress here right because we've now
used at least both of our parameters but
this is not going to type check because
flat map on G wants a wants the months
the function that we passed to it to
return a G so this doesn't return a G
this this inner thing right this returns
like free of of f of a I guess right
yeah free of f of a so if only there
were a way that we could turn free
F of a into G of a and of course there
is right so we just like take this thing
and fold map it again and now it works
so that's cool so so we so we actually
have it so this is this is a little
dense right but like it's because it
clear what's going on here right so
we're taking we're transforming the
structure of our free monad the
structure of our like yo so three things
right pure lift and flat map we're
transforming that and we're interpreting
it into some other monad G and then
we're running that monad and that's all
that we're doing here so so this is the
free monad this is the whole structure
of the free monad and everything else
that people traditionally do with the
free monad is just built on top of this
we have now implemented the whole thing
from scratch and the cool thing is like
this F there's no constraints on this F
whatsoever we can put anything we want
into this type constructor and it or or
nothing into this type constructor and
this will work there's nothing wrong
with this trick so that's really cool
right
are there any other any questions about
this it doesn't make sense does it not
make sense did I actually type it
correctly E flat map what are you asking
about inner has an e type parameter
that's correct
so yeah so inner yeah inner is this
thing of type free f of e so the reason
so I'm being tricky here right but like
this ething here right the reason I call
the e is because it's existential okay
so yeah okay you can also see this on
the screen so e so you notice that e
like it's on the left hand side here
it's like in this flat map thing but I
don't actually put it in sort of the
extends right it extends free of a so
this is actually kind of this weird
thing right we're like you know your
your a is sort of trapped inside of the
subtype and then you sort of threw it
away right in Haskell we call this a
phantom type or I get it right
so you actually need a language
extension to do this elegantly in in
Haskell in Scala we just sort of call it
object orientation something I don't
know but yeah so the reason we need this
is because we might have we met have an
instance of our free monads say like
free of F of int right and then we
flatmap on it and now we've got a free
of F of string right so we can sort of
flat map things together right because
there's no constraint cuz flat map is
there's sort of a - f of B right so it's
sort of like you're changing your type
as you go along but that's building up
this free monad this free structure
right and we remember inside the free
structure all we're doing is like
putting things inside of case classes
right so we're not actually we're not
actually interpreting anything yet so we
have to hold on to all of those like
individual types if you will so we hide
them off and these existential a things
and then when we come along to fold map
we're like well okay we've got this e we
don't have any idea what it is because
we threw it out like three hours ago but
we can we know that it's the same thing
as this other Yi over here so we can put
them together so the type system
actually holds us together there was um
there was a bunch of bugs in you know
and Scala until very very recently with
respect to this particular language
feature and this didn't work until like
about eight months ago so it's actually
really nice that it compiles now good
question really good question anybody
else okay
so we'll move forward because we have
now it has been 20 minutes
so five minutes longer than I expected
and we have completely defined the free
monad and everything there is to know
about it so what we're gonna do instead
of just sort of hanging out is we're
gonna see how you use it because the
thing is that now now that you actually
like see what the free monad is and
really honestly like how all of it works
there's no magic here the examples of
what you do with it kind of make a
little bit more sense so new editor
buffers Scala all right here is a very
common use case for the free mode app
right so let's say that we have some
part of our code that's doing something
with a file system
okay and like all good programmers
who've been bitten by unit testing and
you know integration testing in the past
we know that you don't really want to
deal with the file system directly you
want to build some sort of virtual file
system layer so you can actually test
the thing and you know not have your CI
randomly you know muddling up the file
system and there are frameworks out this
for out there for doing this like
Commons VFS and stuff like that and they
all more or less varyingly work horrific
Lee poorly it's and they also like I
really specialized on like this notion
of a file system right and so like if
you if you don't have a file system but
instead have like my cool micro service
number seven and you know there's
certainly no mocking framework out there
that will help you with my cool muck you
know micro service number seven you're
kind of up a creek so it's really cool
to have like a general technique for
this and this is what it turns out the
freeman ad gives us so what we do what
we would do with this file system thing
is we would express an algebra of the
operations that we want to perform on
the file system so here's what I mean by
that
CL trait file system all right well it's
colored disk right disk and we say disk
of a I have no idea what a is but disk
disk of a no object disk all right so
one of the operations each of the
operations is going to become like a
constructor on the disk algebra so one
obvious operation is reading okay we
might want to like you know read read a
particular file off the disk and when we
read it the result is going to be an
array of bytes okay so this is kind of a
pattern that you use you define you or
you define your operations it's
individual cases of this algebra and the
algebra is like you know something of a
and for each of the operations the
result type the output of the operation
is what you put in the egg okay so the
read operation is a disk operation of a
what about the write operation alright
so actually I'm just gonna like right so
right so this is presumably gonna also
take a file name right
basically everything's gonna take a
filename and you know so it's gonna take
some bytes and in this case we were
writing to disk what are we running a
return well probably something like
boolean but you know we're gonna be
we're gonna be dirty and just say unit
right so what all of our write
operations always succeed this is a very
optimistic virtual file system right and
then you know maybe you might have some
other some other some other operation
that's like delete or look something
like that right you know thinking okay
extends yes cool yeah I don't know
something I thought okay this is really
not that dissimilar from what we used to
do with you know service mocking right
so where we used to where we used to say
okay I'm gonna have like you know a disk
service and I'm gonna have like a way of
reading from it it's gonna return an
array of byte and a way of writing file
string right you see what you see what
I'm doing here so this is sort of like
this is sort of like the old-school way
of doing it where you you define an
interface and then you know you're gonna
have different implementations of those
interfaces and then some sort of magical
framework from the devil is gonna inject
them into your code so rather than doing
that there's there's some advantages if
we do it this way and I'll get to that
in a second but this is sort of like
this is sort of like the be that the
object-oriented equivalent of what we
just did everybody following me anything
doesn't make sense at all
cool all right I see a lot of confused
stares but I'm assuming you're just like
in awe of how cool this is
all right so right so we've got we've
got our disk algebra okay but we can't
actually do anything with it
okay we've described the operations but
we haven't actually described like how
you use the operations all we've said is
like there are things in it's a very
philosophical way so the thing though is
that we did by describing the disk
algebra in this way we can get some
things for free so disk is a type
constructor right
you know the disk takes a type parameter
it is an F of a right so we have this
cool little Thema doodle that will allow
us to get
Monad for any type constructor so for
any type constructor that takes a single
type parameter we can now get them on it
and it doesn't matter what's inside that
type constructor we can get a monad for
it
so that's kind of cool right so disk
disk am of a is like free of disk of a
right so disk M has a monad cool but
what does that actually buy us right I
mean we just we just finished seeing how
the free monad basically has nothing
inside of it so like why why would we
care right well it turns out that it
allows us to write programs because what
a monad is is nothing more than just
sequential computation right this idea
that well first I do this thing and then
it gives me some result and then I do
this other thing and it gives me some
result and then I keep you know doing
things right that's literally all a
monad is and we now have that structure
for free so what does it look like maybe
we might want to write a program so a
program is gonna be like I'll use the
full rather than using the type alias
because I think it's hard to keep track
of that stuff so we're gonna say free of
disk of a okay and we're gonna use for
comprehensions for this and we're gonna
say the first thing we're going to do is
like read the contents of a file so I'm
gonna say contents right so read read
the file and the file is gonna be like
hi text ok now read of course like this
is this is a disk of array of byte and
what we actually need is a free of disk
of array of byte that's like really easy
to get right free dot lift and I think
we called it cool right so now now we
have a flat map function so for
comprehensions will work and then maybe
we might want to do something like free
lift um like right hi to that text
contents I don't know plus well plus
array 1 2 3 ok that doesn't make any
sense but we're gonna do it anyway ok so
we can write we can write some disk on
tens and we also want to like we also
want to write like a log of fact that we
did stuff right some logs text
did a thing to get bytes right cool
and then I guess will yield it well
yield 42 so or some status code status
code 0 cool that makes sense that
actually does make any sense but we're
doing it anyway so so we've written
we've written a program here okay and
this program does does three things well
does in a relative sense it reads a text
file or purports to read a text file and
it gets some contents out of that we
have no idea where these contents are
coming from but you know this this is
totally like contents is really like
legitimately of type array of byte and
we can like use it to do things with so
presumably it's coming from somewhere
right so we get the contents from this
file from somewhere and then we keep
like using it and we write to two files
and then we're done okay
that is our program but of course it's
not actually like doing anything right
so just like the free monad there isn't
actually any anything happening here we
just put some stuff in like data
constructors and then you know claim to
be writing code but but in reality like
nothing has actually happened so how do
we how do we make stuff happen well the
trick is in that full map function okay
and by the way I'm just gonna call this
I'm gonna make this a valve because you
know there's no reason for that to be a
death yes do I have to yield more than
zero shouldn't I be yelling a 3-mile ad
didn't mean to cut you off that was
technical edge okay no I can actually
yield whatever I want here so so the
yield I don't know how familiar you are
with scholars for comprehensions but
like yield yield basically is like map
it's not like flat map so so we can just
like put whatever we want in here as
long as it matches up with this type so
there's actually no reason that we're
yielding and I mean really if you were
actually writing this program you would
probably yield unit so we can do
whatever we want if we needed to yield
something that was inside of free like
maybe let's actually make this more
complicated right so so like delete has
to like delete something right so like
maybe
back right Freda lift lift
delete like badness write or delete evil
right and we could yield this and now
it's gonna be like this is gonna be a
program that yields boolean that's
probably a lot more useful good good
excellent question anybody else okay
moving on so we've got a we've got our
program here it's not actually doing
anything like I said but we presumably
want to make it do something so how can
we how can we make it do something well
we've got this full map function right
so the full map function says if we can
tell Scala
how we how we can turn a disk into some
other type that has a monad I'm just
gonna like do that because this is
getting absurd if we can tell Scala how
we can turn disk into some other type
that is a monad then full map can run
our program inside that monad and we'll
get the results that kind of sounds like
more or less like we might want like
something we might want so can we find a
monad that makes sense to turn disk into
it English grammar is terrible so it
turns out that probably the most useful
mouna that we could do that we could use
this with in production is a monad that
actually I don't know manipulates the
file system right like something that
actually runs our program and whenever
we're talking about like manipulating
file systems or like you know reading
from network sockets or launching
missiles you should be thinking at that
point of the i/o monad okay so the i/o
monad like the name comes from Haskell
but like this exists and you know
various libraries and I actually I
opened I opened up a project literally
this morning to add it to the cat's
library so like IO is basically
everywhere right so il is it is a monad
and it's like IO of a that sort of the
result but it returns so can we find a
way to maybe turn disk into so any disk
of a into an i elevate well it turns out
that this is pretty easy so what we're
gonna do is we're gonna represent this
a natural transformation write a
function k from disk to i/o
okay equals new function k disk IO I
actually I actually want the like the
Java 7 you know sort of thing syntax
it's sort of unfortunate that Scala
can't always type in for this
alright so death apply right and this is
gonna give a so we need to take a disk
of a and we need to return an Iowa vein
okay for any for whatever a the disk
decides to give us this is the type that
we have to define alright so how are we
gonna do this well let's pattern match
okay so disk of a well what could we
possibly be looking at well possibility
number one is a read read this file name
okay and so given this we have to return
an IO of you know array of bytes right
cool
so that's actually not all that
difficult to do right we just literally
write the function so like file new file
input stream okay actually this is kind
of difficult to do we're just gonna
pretend we did all of that so pretend
pretend that we just did like messy IO
stuff and and it went into this like IO
thing if we return denial by it's cool
all right we're done so what about right
okay I'm right we take a file and some
bytes and now we have to return so right
remember right is a disk of as a disk of
unit right so we have to return an IO of
unit here so this is gonna be like you
know new file output stream okay this is
actually kind of hard to basically
anything dealing with Java IO is very
unnecessarily hard cool alright so
delete delete file I think this one will
actually be somewhat easier alright so
here here now we have to return an Iowa
boolean right so however you do this
well this is literally gonna be like I
think new file and file dot to leave
right there finally a function that we
can actually implement I really I hope
that we can actually implement that
alright cool
and that's all there is we don't have to
write anything else because these are
the only three possibilities for disk
right if someone hands you a disk it has
to be one of these three things so that
was actually pretty easy we just
basically defined how this
implementation was going to get
if you sort of rewind this back into
object-oriented terms right and remember
with like our sort of magic spring
injection service thing that we were
talking about right this is sort of like
the concrete implementation of your
interface right so this is your
production implementation this is the
one that you're actually gonna run run
your program with so now we've got this
natural transformation we now know how
to turn a disk into an IO and IO is a
monad which means we can take our
program and full map with our natural
transformation and that's going to
return an IO a boolean and we can run
that and magically sort of out of the
blue we've somehow gotten a running
program something that we can actually
do that that I don't know feeds our
family that's pretty cool like just sort
of like not and not doing anything at
all so programming is hard guys yeah so
anyway are there any questions about
what we've seen like what we've done so
far nothing ok cool because we're about
to gonna get to this we're about to get
to the part where this gets really
really really cool because the thing is
that the whole point all of this is
testing ok the whole point I mean
arguably I would I would honestly argue
I would stand up here and argue that the
whole point of functional programming in
general is testing yes
is there any syntactic sugar for
abstracting away the free lift M
repetitive madness stuff yes so what
people generally do is they'll do
something like this and they'll create a
smart constructor so we'll say like read
with a lowercase R and that will return
you know free of disk array byte right
and then you do normally do like free
lift read file and then if you go down
here it becomes like a lot easier
because you just well I did the wrong
one but you just usually be like read
write okay
that's usually what you end up doing
there's various libraries that have
tried to make that even a little bit
better where they'll just like derive
that function for you so then like I
wrote a library once where you could
actually do this and it just like
magically inferred everything and it was
super cool and it like crashed half the
time but it was cool it was like it was
exciting and nobody actually liked that
for some reason but it but it was cool
yeah no it is the boilerplate can be
annoying if you're not careful yeah
implicit def where's what line 6 this is
a def yes so let me I'll just base that
out so it's a little easier to read that
clear
Oh implicit def no it's not it's not an
implicit that would be that would be a
little strange because so anytime you
see implicit def alarm bells should be
ringing because it's like well shoot am
i actually accidentally getting an
implicit conversion right because you
don't want implicit conversions and this
will in fact be an implicit conversion
from string to like free of disk array
byte and that that doesn't make any
sense right because anytime you have an
implicit conversion from A to B what
you're actually saying is well a is sort
of secretly a subtype of B but like
Liskov substitution principle doesn't
make any sense here so so we definitely
don't want that ya know we want we want
to death there are some cool things we
can do with implicit so just not in in a
one-hour talk
so is it necessary to have an ADT and
could we hmm it's not it's not at all
necessary to have an ADT I'm just not
sure what else you would do like so we
could I mean so I guess I guess for
example like oh yeah yeah so if this
were not your code and and you didn't
know that disk was sealed and you just
wanted to like use the free money to do
cool things you can do that and in fact
you could use the free moon end to do a
lot of things that have nothing to do
with monads or programming so this is
actually where things get really really
really crazy so like I said I work at
slam data slam data like one of the
employees of slam data builds a library
called matroyshka which is I'd like to
Russian doll right and and matroyshka
provides some tools for abstracting over
recursions games which are like
hilariously mind-bending things so
basically like I I know very very little
about them but these mysterious things
that I have to work with every day and I
just sort of go in and I'm like I don't
know how this code works please help me
but one of the things you can do is you
can use the free monad to abstract over
sort of injecting things into holes in
data structures right so we have these
like trees and graphs but rather than
actually representing them as a
recursive data we represent them as very
flat data where each like piece of the
data has a hole in it and in the Freeman
IDE we'll just sort of inject things
into there and so when we sort of like
expand it outright it actually becomes a
graph at runtime but we don't see it as
a graph and we just manipulate it as a
flat structure so it's actually cool we
don't write recursive recursive
structures or recursive functions
anymore we just like have recursion
schemes it's really bizarre
I don't actually understand it so please
don't ask me about it but I'm still like
I am very much still trying to learn
that but hopefully hopefully someday
I'll be able to give a talk about it and
you know sound cool good
question anyone else okay we're not
gonna go that much longer all right but
I wanted to talk about testing because
testing is like I the reason that we do
all of this stuff it's the reason that
the Freeman add exists it's really the
reason that functional programming
exists because like functional
programming is basically a response to
the fact that all of us are really
stupid like I am not smart enough to
understand like software at all like I
can't I can't be a programmer and so
because because I'm so stupid
I have to like restrict the domain of
things that my code can do to like these
immutable things that I can actually
reason about because my mind is sort of
that tiny and in order to do that like
functional programming helps me and
reasoning about code is basically the
same thing as testing it right because
if you can reason about something you
can express that reasoning as a test or
as a property or as Allah and then we
have tools that can verify all of these
things for us so it helps us write safer
software so the free monad helps us do
this but it helps us do this on things
that are not pure functions right my my
complicated business logic that talks to
seven different micro services and like
bring some data back and like jumbles it
up and then compares whether or not it's
less than or equal to seven because like
some sales person was like seven is a
cool number like that is not a pure
function in any sense of any universe
right but the reality is that's where
most of our bugs are because the
salesperson was crazy so like how do we
how do we test that right the free monad
is the answer so you write you write
that complicated logic in the middle in
terms of the free monad right so all of
these different services that you talk
to you represent them as algebras that
are like this this this service you know
supports these operations and I can I
can get a free of that so the question
is how do we take this and how do we
test it okay and the answer is well we
can just write a different natural
transformation and there are actually
better tools for doing this they're just
not open source right now and I really
really hope they're open source soon but
I promise you they exist but right now
what you do is you write in natural
transformation so so rather than
interpreting too IO which is like this
everything that manipulates the disk
maybe we could interpret to like you
know Val Mach sort of an odd name but we
can use it function K disk to like well
now we're getting hints like strange
land but like you know some some like
thing that's like there we go right
question mark I know I'm miss associated
bad question mark okay do these question
marks make sense I just realized that I
did not at all explain that syntax like
in any sense of the word
the question mark here this is uh oh no
I did to it I did do it right the first
time
alright this is this is a compiler
plugin called kind projector and it
basically avoids the need to do like
crazy you know sort of like question
mark bracket type lambda you know alpha
equals like this craziness right you
know hash Tambe right you know one wants
to see that in their code so kind
projector your limits that all right so
so we can write we can write a function
K that interprets from disk to the state
monad where the thing that's inside of
our state monad is just like a map from
string to array of bytes right so this
is this notion of like an in-memory file
system right we can define what that
means and then we can run our tests like
in memory just by saying well use the
mock natural transformation don't use
the real one okay so this is like you
can think of this again like you can
think of this a lot like a form of
dependency injection that doesn't
involve any magic and actually just uses
monads rather than spring spring greater
than monads less than moments so anyway
but like that's really cool and there's
a lot of more powerful tools that you
can build on this because inside of free
like fundamentally remember the
implementation of free is really really
really dirt simple and it's data it's
not like complicated you know sort of
constructor injection inside of class
loaders with sort of JVM agents or
anything like that but we can't
understand it's actually data we have it
in our hands we can introspect it we can
write other functions other than full
map right these constructors are open so
we can just like sort of go into them
and lunge around and see what's here and
fundamentally all we have is like just a
list of actions right sort of a sequence
of actions that
to perform a sequence of flat maps we
could go in there and we could pull it
apart and we could say well I want my
function to say a read followed by a
right followed by another right followed
by a read and we could write that test
so for example on a previous job I wrote
a I wrote a test for a service that was
talking to a database that shall not be
named Cassandra that has
compare-and-swap operations right and
like atomic operations for some reason
and I wanted to make sure that my
complicated compare-and-swap
semantics were actually correct right
has anybody ever written a unit test for
a caste loop like a compare-and-swap
thing that is like murder like how the
heck - unit test that your unit testing
or race condition that doesn't even make
sense but with the Freeman and I could
do it because I said well I'm gonna set
up this situation where it's like I want
to say I want to see my function read
from the database first right so get
some data out and then I want to see my
a function compute some value - right
and then I want to see it try to write
it and then I want to see that write
fail and I want to see my function read
from the database again to figure out
the race condition and I want to see you
to try to write again I want to see it
fail a second time and I can actually
set that whole thing up and I can test
it and the function was bulletproof like
I had a compare and swap like race
condition test function that was
bulletproof indeterministic
that's fantastic right that's how you
write good software and the free monad
allowed me to do that so anyway we're
we're very much we're very much running
out of time at least if I we take my
artificial limit of like not an hour so
are there any questions about things I
know I didn't I know I sort of hand-wave
past the testing thing really really
really fast
but any questions at all anything you
want to see again any like stuff do you
want me to explain why a monad is a
model in the category of endo functors
because we could do that too
yes hi so I'm very confused in a good
way
sweet I'm coming from a closure
background I don't know Scala at all so
I'm probably not the right audience for
this but I'm just so confused I don't
know like my brain is still trying to
figure it out
sweet that's great so if I had one
question it would just be like explain
more of what the free Monette does can
you give me just some more concrete
examples of the free mode ad in use okay
so let's let's let's do another really
really quick concrete example right
so rather than disk let's imagine that I
had like some some service right
that was like weather you know and my
weather my weather service and I'm just
creating I'm just creating an algebra
for this right my weather service has
the ability to like you know get weather
for you know some zip code and that you
know returns whether it's the old
temperature or something right I'm just
like describing the operation so I'm not
actually implementing here I'm just
describing it's sort of like writing an
interface except instead of writing an
interface I'm producing data okay I'm
describing what data could be here right
we have get weather and like get
forecasts and this is like you know five
day or something like that like I can
sort of produce these operations right
so
yeah each one of these case kids classes
is like an endpoint on a theoretical API
and that is actually very common thing
to do when you're writing some messy
business logic here and you've got like
six microservices that you're talking to
just write an algebra for each
microservice right and that describes
how you can get them into Data now the
thing and what the free monad does and
all that the free monad does is it
allows you to write sequential programs
with that data okay because this is all
that monads are right there just
sequential ization sequential
computation right so the free mail that
gives you sequential computation for any
data at all and so that way we can just
describe our dsl x' like are our
operations in terms of data and the free
monad gives us the computation stuff
it's like basically factoring out
boilerplate in a way okay
so does that help a little bit I'm gonna
have to not do more of the example
because like if I if I sort of keep
going down that rabbit hole we'll have
to be typing for a lot longer but I can
I can show you more if you want to come
up with too much later yeah cool cool
confusion is good
anybody else confused yes okay
multiple people come up and I will show
you I show you examples there maybe this
is just like a terrible talk and like
the whole room shuffles forward it's
like you didn't explain anything Daniel
yes
wait there's a microphone in Scala today
is there any way to combine this with
software transactional memory or
something like Haskell atomically yeah
so there's some people who've played
around with that and actually there was
a discussion the cats channel like an
hour ago
about that idea software transactional
memory is really interesting and you
could very definitely describe
operations on it using the free monad
that might make a lot of sense generally
speaking I find though that STM doesn't
make sense
like I just just in practice like it
doesn't actually get used all that much
which is really kind of weird like it
seems like this cool thing but I've
never actually seen someone do something
useful with it if you are someone who
has done something useful with STM
please come and show me because I'd like
love to see it but I've never actually
seen someone do anything with it but
yeah you could I've actually seen people
do things like use the free monad
with something that's already a monad
just so they can get like sequential
ization but not sequenced inside of the
inner mode ad and then sort of delay
their computation
I can't kind of be cool thing that's
kind of interesting to me is that it
seems that these are mechanisms to
basically allow you to have arbitrary
arbitrary sequential arbitrary
sequential computation basically encoded
as data and interpreted the way you want
to so it feels like you could take an
arbitrary procedural program and write
it this way or even a translator to
translate it into this functional stuff
right so yeah that's like the lambdas
the ultimate go-to type thing it's kinda
like you can basically go ahead and
mimic go tooth with the continuations
and all these other things so is there a
sense among people using this that this
is not the first thing you reach for
because it seems like you're at least at
the you know if you can end up having
functional code looks exactly like
procedural what's the advantage really
yes okay
so the reason the reason so the there's
a couple of things packed up in there
that's a really fantastic series of
thoughts right and like your initial
description of what the Freeman is
that's exactly what it is right so why
would you do this rather than just
procedural code right well the thing is
that like a procedural yeah well well
what is it more functional solution
right
I mean function oh so functional right
is just like you know immutable so this
the whole the whole idea behind it is
trying to get something that's easier to
test easier to reason about and what
this does like all the different does is
it gives us the ability to sort of peel
apart sequential computation sequential
programs and see them as data right
whereas when you have something that's
sequentialized but not inside of a
structure like this where it's all as
data then you can't see what's happening
right so if you just have function
composition for example you can't go in
the middle of that and see well I really
want to be sure that F has been before G
you can't actually like say that you
have to look at the end point and say
well I guess the answer is 42 so maybe
maybe that's right so that becomes
harder used to work with like Haskell
and like lazy and stuff like this and
you're kind of like there are many
things that don't have to be sequential
right it's just you know when you're
doing with the outside world quite often
you wanna have sequential computation so
right that's the place where you just
don't reach for this until you really
need it yes so this is an important
question right it's like where where
does the free monad make sense because
in in the small in in functions like
taking the absolute value of a number
right there's no reason whatsoever to
put that in the free monad that makes no
sense right do it doing some sort of
computation something that's actually
like already pure why would you put that
in the free monad and at the other end
of the spectrum maybe you might have
something like something complicated
like I'm I'm running this on a web
server or I'm setting up some sort of
like asynchronous socket poll or
something like that why would you put
that in the free mode that doesn't make
any sense I mean maybe it does make
sense but like probably not like you're
dealing with like concurrency you're
dealing with IO you're dealing with like
really like raw bits like I don't know
but like that middle that middle part of
your your software stack where you're
doing things like like the crazy
business logic they're talking to seven
services and like stuff underneath it
maybe that's pure functions or like some
sort of messy IO thing but like your
middle stuff here is complicated logic
but it's like middleware stuff and you
want to be able to write tests about
that middle stuff as easily as possible
because honestly like that's what bugs
in software are cuz that's where all
your edge cases are so the free monad
like without the free monad you would
have to write that stuff in IO because
you're like doing service calls and
stuff like that but I oh you can't test
like that's an integration test Freeman
ad you can test so that's the advantage
yeah excellent great question basically
out of time I think almost out of time I
don't know no one's pulled me at the
stage last question no last questions
cool thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>