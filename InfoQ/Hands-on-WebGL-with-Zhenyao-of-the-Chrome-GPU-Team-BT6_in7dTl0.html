<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hands on WebGL with Zhenyao of the Chrome GPU Team | Coder Coacher - Coaching Coders</title><meta content="Hands on WebGL with Zhenyao of the Chrome GPU Team - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hands on WebGL with Zhenyao of the Chrome GPU Team</b></h2><h5 class="post__date">2012-05-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BT6_in7dTl0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to my talk my name is Chen
llamo and I working for google currently
I'm on the chrome gpo team for the past
two and a half years I'm spending my
most efforts implementing WebGL for
Chrome so before I start I want to show
you some magic of what WebGL can do in
just simply of your lines
so can see this is a very shiny teapot
in a 3d this is in WebGL so I want to
make it a cartoon style and it only
takes you three lines to do that so this
is this is the source code I already
added the lines now I just need to UM
uncomment those lines and save
see so this is Katherine style only five
lines and with original fixed pipeline
it takes way more effort to achieve that
but with shaders that's what you can do
this is processing is per pixel and with
this you can easily have our kind of
very fun very exciting or even weird
effects on your screen and that's what
WebGL can offer with the current
pipeline current design so I'll explain
to you later what those few lines do but
now let's start from the beginning so
feel free to interrupt me if you don't
understand anything so first I want to
explain what is web jar in a few words
WebGL is graphics 3d graphics library
for the web so it's based on opengl es
2.0 standard why is that because then we
can run the same provide the same API on
desktop on laptop and also our mobile
devices because opengl es 2.0 is widely
implemented in most mobile devices and
this is a little bit different from any
other JavaScript standards because it's
too language it's combining of
JavaScript interface and also shading
language which is the language for GPU
but it's not as scary as it sounds I'll
show you how shooters can be very simple
and easy to understand and is it right
so web show right now it's implemented
in Firefox Chrome Opera and it's also
because chrome and safari share the
WebKit so it's also implementing WebKit
so in Safari if you turn on the switch
then you also have WebKit but it's not
on by default the only main browser
that's
implementing WebGL is Microsoft ie but
again we have a solution for that if you
install google chrome google chrome
frame which is a plugin for IE then you
then the browser where looks like IE but
all the rendering is done by chrome so
then you can have all the cool features
chrome provide including WebGL so that's
our solution basically with this chrome
chrome frame in place then our main
browsers should have WebGL available but
again because it's a graphics lab really
so it also depends on your graphics
hardware if you have a really odd GPU
have tons of bugs in your drivers then
it's not it's not only unpleasant to
wrong some graphics content on it
because what you see is not what they
expect it can be literally like dark
triangles something popping out of the
geometry those kind of weird things but
also it can be unsafe because there are
my be security bugs in the driver so we
try to walk around many of those but the
some of them just not possible so what
our solution is we black list some very
bad drivers and GPUs and for right now I
just get this data yesterday for today's
talk and this is purely I get a data
from chrome but I assume firefox should
have about the same percentage so on
windows right now we have sixty-eight
percent of users that have WebGL and
that the rest thirty percent mostly they
are XP users they have really old
hardware Yuri out driver for example
like my dad and my mom you cannot expect
them to update their graphics drivers
its way to complete it complicated for
them so they they basically they cannot
have WebGL but again we provide another
solution we provide a software renderer
which is called to swiftly shader so if
your hardware GPU driver is pretty bad
but then you can download this
optionals with Sue officiator then you
can have WebGL only that the frame rate
may not be that great but the for many
applications they don't require a 60
frames per second frame rate then then
then you can still enjoy WebGL on a
little old computer with old GPUs and on
Mac we almost have our max and recently
we have some Luke rushing sound Mac and
the 10-point 7.3 they have many bugs in
their drivers but we are working with
approach I to solve that quickly and but
before basically a Mac you can safely
long web show no problem and on linux we
currently only have three four percent
but we are working hardly with nvidia
with intel and with AMD so i think
they're good drivers are in line they
are going to be released pretty song and
if you'll grab those la new drivers then
you can have WebGL so basically the good
news is in I think just in a few months
like you can have like maybe ninety
percent of the users of the whole web
will have WebGL that's a good part so
now I want to explain a little bit about
what is how gpo works this did I don't
count mobile users because currently
very few browsers provide WebGL a WebGL
is good enough on a mobile but that's I
think basically the hardware needs to
catching up yeah chrome dance about
WebGL at the moment I'm mobile
so this is what the general a very rough
illustration of how the gpo pipeline
works basically you input data streams
to basically there are two parts why is
the vertex shader which is basically
processing data on a per vertex basis
then the fragment shader is processing
the data on the per pixel basis so you
input data into the vertex shader those
data is like like vertex properties like
their coordinates there are normals
there are texture coordinates are there
are colors those vertex attributes your
input to the vertex shader then do some
computation then I'll put something out
put some data those output will be the
input of the fragment shader then
fragment shader will again processing
those data and what they were output is
the color for each pixel then that's
what you see on the screen and that's
how the GPU works and the vertex shader
and the fragment shader the one good
thing about them is they can they can
run in parallel pretty fast so you can
process like hundreds thousands tens of
thousands even millions of vertex are
pixels seem at the same time so that
gives you a high performance so shaders
what I shooters shooters are programs
running on GPU so usually will write
programs that's running on CP you but
shooters are programs for GPU and they
are pretty small and they're stateless
that means they take they wrong for each
pixel independent independent of each
other and they don't save state so each
one is independent and then they have a
high degree of parallelism that's what
makes the GPU a great processor and
vertex as I said vertex shader applies
to each vertex
and fragment shader applies to each
pixel because we know the output of
vertex shader is applied is the input of
fragment shader so I'll put our hands
sugar is per vertex and then then the
GPU will automatically figure out like I
for a given pixel if if a fragment
shader is running for one pixel then
basically it will automatically figure
out what which vertex which vertices
will affect this pixel basically this
pixel is belong to which triangle then
it will automatically do blending of all
the output of the corresponding vertices
then get the data then to some
computation than will output the color
of that pixel so now I'm going to work
you through a concrete example of a very
simple WebGL example which will
basically draw a color triangle on the
screen using WebGL and this is the link
for the for the original demo
so this is a very simple vertex shader
looks like it's only a few lines so
first this you can see it starts with a
tribute and that means those are the
input string so they basically this give
you the attribute attribute of each
vertex they can be colored they can be
position they can be normal they can be
texture coordinates that's the that's
the attribute of each vertex and this
you can see those variables start with
varying that means though add those will
be the output of the vertex shader but
then they will be the input of the
fragment shader there will be the input
of the next stage in the pipeline and
the code is very simple is basically
because this attribute position is the
input so each vertex we already know the
position and here we don't apply any
transformation so there's no matrix
operation so we basically just take XYZ
as it is and the W is just 1 point 0 so
this give you the this will be the final
position of each vertex and this GL
position is the reserved keyword so
basically when you sign valued assign
value to this property that's the final
value of final position of that vertex
and then we then we assign the color
input the color directly to the V color
which will be passing down to the next
stage so this is what a simple fragment
shader looks like so first you need to
declare the precision of the operation
of the variable you want to operate down
so basically here I say precision medium
p fruit that means are the fruit will
use median precision but that can vary
from device to device but the spec will
specify what's the minimum requirement
for medium
for high then at least you can you can
expect some of the you can have some
guarantee of how precise the data can be
then you can see this again you see this
in the in the vertex trailer but now you
see it here again because the output of
the vertex shader will be the input of
the fragment shader so you get the color
from vertex shader then basically you
just assign the color to the final as
the car final color of the of the
fragment shader but here you need to
know that vertex shader is per vertex
and here is per pixel so basically
before you even enter here the gpo
poplin already automatically do the
blending so if you have select a pixel
inside a triangle then it will then it
worth taking to consideration the three
three vertices and their colors then
depending on the position of the pixel
to the position of the story versus it
will do some linear combination then
that's the input V color you get it's
not directly from from vertex shader but
a blending of related vertices then you
can directly assigned color to this
fragment color and if you just want pure
red on your screen then you basically
you can just say GL frag color is is is
red like 100 then you get the whole
screen were just be red it's as simple
as that no magic here but you can you
can do quite you can also do some very
complicated things here to get some very
cool effects so here are some difference
between basically you can calculate the
final Cadillac like in previous example
we calculated the color in the vertex
shader then the courage is passing down
to the fragment shader but sometimes we
can calculate the color on a4a pixel
basis so this gives you a more accurate
color model as you can see from the two
example the left is rendered basically
computer the color on
per vertex spaces then just do some
interpret and the second is computer the
color on the right is computed the
coloring up per pixel basis so you can
see you you see the one the left the
right side you don't have the highlights
but the the right side you have because
it's a finer model because per pixel in
most cases a triangle is more than 1
pixel so if you compute the color on per
pixel basis it's more accurate so give
you more details and that's a choice
sometimes you want to make whether how
how good the rendering you want it to be
so then this is this is just regular
JavaScript so you can you can you can
put the sugar source code as a script
and then you can you can give it some
type and type is basically as far as
this different from text then that's
fine you can you can just specify
anything but you the one thing is you
need to separate basically you need to
let the the code know like give you the
ID for example then then then you can
know which this text is about for here
we only have we have only have two so we
say one is vs that's vertex shader one
is FS so later you can use this ID or
use the type then you can basically you
can know which is which so now the first
step to to build our web Joe program is
to gather web show context so that's
very simple you have a canvas object in
your HTML file then then you use this
canvas to get a context and what kind of
context then it's a string your pass
down and here we want WebGL so we see
experimental WebGL because we can only
claim WebGL once it's fully passing the
conformance test so right now we use the
word experimental WebGL but once we are
fully expect conformant then you
just say get context WebGL that's then
you will have WebGL context to do other
stuff Webb Joe allows you to do but here
you can also get them now that's
basically if the card is driver is
blacklisted then you will get now then
you can basically you can pop up a
warning box to a user that upgrade your
driver get a better GPU or whatever you
want to do with that and for canvas you
can also get the 2d context so basically
if you say get contacts 2d that will
give you a 2d context then you can do
tons of like jawline your circle those
kind of to the operation so now we have
a GL context and we have the opengl
source embedded in the HTML file so now
we need to load the shader because
basically we need to let the GPU know
what which program you are supposed to
run so for each gpo program they consist
of one fragment shader and the one
vertex shader so this is a code how you
upload the shader you get the shader so
this is basically you get the element by
ID the ID and here we basically use the
type to distinguish whether it's a
vertex shader or fragment shader but for
our example you can are actually you can
also use the ID because one ID is VX vs
what an odd ID is FS so basically they
are good enough to tell you which one is
which then you create that sugar based
on the type whether it's a vertex shader
or a fragment shader then this resource
is basically you upload the source code
to the GPU then you can power it's just
like any CPU program use you'll write
some source code then you compile then
see if we succeed on not so
so this is the stage basically you check
whether compiler succeeded if not
actually you can car another function
then you can get some information about
why it fails compelling then it were
indicates give you some hints what's
wrong with your program with your shader
source code then you can do some
modification so now we compile the
shader and then we need to load the
program to the GPO so GPO can run and
can render so this is the source code
how to build the program so first you
need to create a program that's very
simple then we use the the function in
the previous page the gal shader so we
we we create shader and compile the
shader then what do we need to do is we
need to let the program know this is the
vertex shader you are supposed to use so
we say attached shader basically with
attached the vertex shader to the
program and then we do the same for the
fragment shader so now we have a program
with one vertex shader one fragment
shader so the program is complete now we
can compile we can link it's just like
the CPU program we compiled and we link
then after link we check whether links
succeeded or not and again here I didn't
have this code but if the link fails
then you can get some log information
will tell you why it fails hopefully the
information is good enough so you can
you can immediately know what's wrong
with your program so now we link the
program if we succeeded we have a valid
program to run on GPU but we need to
tell the GPU this is the program yeah
you should use so that's that's the line
of code just doing that say use program
so set this program as the current
program for the GPU
then those those lines is basically
prepare the vertex attributes for later
use because we know as we see in the
vertex shader we have we have position
we have attributed position we have
attributed color and the program is
basically tell you how to what to do
with those attributes but again then you
need to link some data to the program so
say this is where you put the where you
give the data to the to the GPO and so
those are the location you get the
location of those attributes then later
you can bind data bind vertex data to
the vertex attribute location and bind
the color data to the color vertex
location location so that's what this is
about give you the location later you
can bonding data to them so now now we
set up the GPO we set up a program set
up shaders and the next is we have the
program now we need the data because
that there are two parts one is program
what to do with the data now we need to
get the data to the program so we can
draw blender blender that stuff on the
screen so the data here in in in WebGL
is what we call data buffer so first we
need to create a buffer and and say this
is banned buffer is basically saying
this is the current buffer and are the
are the future operations on the buffers
are made to this buffer until I find it
another buffer to as the current so this
is the buffer data for the triangle it's
it's quite simple you can see it's uh
it's XYZ and rgba it's 77 throats for
each vertex then we have three vertices
so we totally have 7 21 fruits that's
the data we have
then this buffer data is basically
saying upload this data to the GPU
so now we have the data we have the
program we have the program on the GPU
we have the data on the GPU and then we
need to only send a simple command to
the through WebGL say now Joe something
for me that that's the last missing part
of this simple program so viewport clear
is basically say this is the region our
jar and provide your clear the region
first of course you can you can set here
I didn't set the clear color so
basically use the default color to clear
the scene but you can actually say what
kind of background color you want then
you can say clear color set up the color
then do the clear then you have a region
with a given background color so this is
basically binding the data the data is
already on the GPU and the program is
also on the GPU so now basically you
need to connect to the data feed the
data to the shader programs so this is
what exactly this is doing so in the
sugar vertex program we have to
attribute one is producing another is
color here I also charged the surface
novel but in our own program we don't
have no Mose so we have positions we
have colors and so those lines is
basically just finding the data to the
to the location so you can see the
program dot position attribute so say
bind those data to those position and
three is saying for the this is for
position so we have three data XYZ and
the type is float and force is basically
normalized or not you don't have to
worry about that here is and the strata
is basically because for each vertex we
have we have seven we have seven throats
so we say basically for each vertex you
you jump another seven roads to the next
vertex
and 0 is because for the position we put
position first then color so the last
parameter is offset so we c0 is in those
seven fruits would read from 0 1 2 as
XYZ and so the second example the color
you see the the offset is 3 so basically
it's saying start from three four five
six as our GPA that's the offset and the
four because the there's 44 is basically
saying the data is rgba it's for fruits
the tapis fruits and it's it's if you
read the API the meaning of all those
parameters will be very clear now we
have the data we have the program and we
connect to the data to the program
program then the last thing we need to
do is say jaw so we draw a triangle and
start from 0 0 is sometimes if we have a
large data and we only want to draw a
part so we can can start from anywhere
draw only partial part of the are the
triangles but here we only have three so
we shall start from beginning and the
three is saying we have three vertices
so this is this is only one charango and
that's all this is our decoder you need
to draw a triangle I mean it's it's way
more lines than just hollow word in C or
Java but it's still very simple stuff so
any questions so far do you feel
confident now you you can call yourself
a WebGL expert I I when I started
working for google I I started from this
example so that's how I learned WebGL
and no matter how complicated the scene
looks like this is the foundation it you
can do like you can do some physical
simulation or kind of stuff but that's
not related to graphics the part to
graphics is just this is the car this is
everything you need to know actually the
only
missing is the texture how you deal with
texture but once you you said if you
look if you learn how to assign the
texture to the triangle that's
everything you need to know about how to
draw 3d graphics so this is not bad
actually you can call yourself WebGL
expert if you fully understand what this
is about so now I want to talk about
after the basics I want to talk about a
little bit about how to make good web
job applications so here are some rules
because WebGL is fundamentally graphics
library opengl so so whatever rules for
OpenGL to make it good it also applies
to hear so first basically we need to
minimize a few things first try to
minimize the job cause so for example if
you want to draw a million triangles you
can combine all the triangles say JA and
got a meaning jungle or instead you can
make a million jaw cause each time you
just Joanne jungle and the latter case
is extremely bad so basically you try to
combine your geometry and try to make a
single Joker that's the best but if you
cannot I that's too complicated to you
for you to manage the data for example
you have a human a dog then you'll have
to make to cause that's fine but if you
make a milling call for a milling jungle
that's not good for WebGL and then you
also try to minimize the binding of
buffers texture program so basically as
as I should before if you say band
buffer basically you said the buffer as
the current then or the future
operations is is applied to that buffer
until you say band buffer again so
basically you try to make as minimal as
possible the switch between buffers
between textures so basically if you
want to do something for one buffer just
you bind this buffer and do them all
then you switch to the next buffer
instead of you do something here switch
to another buffer then switch back
this is will make the web show from this
pad and the same is uniform variables
which I didn't explain what it is here
and also there are state switches just
like enabling for example depth testing
and enable vertex attributes those kind
of things basically basically make sure
you know what you want what do you want
what do you have to do then basically
make as minimal states which as possible
that's will make your OpenGL web job
from it's pretty good and then for WebGL
because WebGL is JavaScript prosecutor
so javascript is running on CPU and the
shader run runs down GPU so basically
for browsers you try to off load as much
work to do feel as possible so then on
the cpu side it can be very fast very
smooth because CPU will handle or the
user interaction like user wants to
click play games interact with the
singing all those kind of things is
happening on cpu so if you do tons of
WebGL stuff on the cpu side that will be
bad if we better if you upload them to
GPU then the CPU side can be saved to do
all the browser your eye and browser
stuff so that's WebGL big rule the
second is because what I show before is
just example just draw something but
many times to make application
interesting you have to interact with
the scene so you have to for example you
have to click pic pic is a common
interact interaction between user and
that game because for example you you
you click on the screen then basically
the the program needs to tell you did
you click on the object or did you click
on nothing that's what that's that's
picking so in the early days we have
google body which
basically it has a human body with
different organs and different bones
with names and with information and our
building WebGL and then you can you can
click on a part of the body then it will
tell you some information about it
unfortunately this google body is no
longer available from google but the
technique they used in google body is
pretty still pretty amazing so because
Google one Google body has about
1,000,000 two angles and still you can
achieve real time interaction you can
locate you can you can pick in real time
so this is how how WebGL can do what's
the performance can be like and the
selection basically you click then the
program needs to tell which part you
click because there's a milling triangle
on the thing so you have to do something
wise otherwise if you just try to
compute whether this click interact with
a mailing jungle that's going to take
forever to to finish so one technique
which is not used by Google body is you
can do ray tracing basically your clique
is like you should array to the scene
then you can compute how this ray is
interact with all the triangles which
can go interact first which interact
next then then then the triangle closest
to you will be the triangle you hit
that's the general technique you can you
use in graphics to decide which which
sing your hit should i click and and of
course you can do some optimization like
you can do bounding box so so detect
whether the the ray hits this part of
the body can be fast because if it it's
outside the box then you don't have to
compare with each triangle inside the
box but still this is still a lot of
mathematics going on on the JavaScript
side because like the body can be
located so the bounding box are so you
have to also apply all the
transformation to the geometry and
everything and for each for each click
so those are a lot of mess on the cpu
side and so what do we want to do is we
want to offload those kind of
computation to GPU side so the CPU side
can-can saved for something else yes
yeah you can you can do it on the server
side if you are willing to to provide
our surface service like that but it
will be pretty heavy GPU right most most
currently most servers are more CPU
heavy and do they even have a GPU yeah
yes so basically you are doing gpo work
on Scipio in the server which may not be
very fast right now I see I know some
game companies they are using web-based
gaming so they provide the servers to do
rendering but I don't know however they
are but this is definitely could be a
future option
so what do we do is in Google body what
do we do is how we use GPU to to decide
which body part you you select is when
we load the body load the model we see
this is the heart this is the kidney
each each part we assign different color
then we char the body in not on the
screen but in an off-screen frame buffer
in an off-screen canvas we toyed with
those color instead of with like
lighting with the texture but we joy it
with those assign colors so then what do
you see is something like this on the
left side so basically it's basically
this is just a 2d canvas with a bunch of
pixels with different colors then then
when you must click you basically you
decide which pixel you click then this
pixel will be corresponding to which
organ your click and this is how you do
picking through GPU you'll render
different parts on with different color
then based on which color you get then
you can know which body part you pick
and of course you can do it on different
scales for example if you want to select
a charango instead of a heart then
basically you assign different assign
colors to different triangles then based
on the based on the color then you can
know which angle you get so I think of
this is a very smart trick to do and
which allows you to interact with a
milling two angles in the lower time and
it proved it's proved to be very
effective because Google body is already
launched before and people came to write
with it no problem
so then I want to talk about a little
bit about particle system this is one
demo of particle system
so here's another example different kind
of particles so each particle will have
a is moving around according to time as
time passed by the each particle will be
moving so what do we do we can do there
are two ways again one way is we can
check the position of the particle at in
JavaScript basically at each time frame
we can compute the position of each
particle then the GPU is only to render
is only to draw that particle in the
given position but again in this demo
what do we do is we put all the
computation the motion equation
averaging evaluation to the gpo side
okay so this this the demo that the
second moi co it animates about 2,000
particles at 60 frames per second and
the animation mathematics is down on GPU
so here's how it's implemented so each
particle demotion the current position
is defined by a set of parameters and
those parameters including initial
position velocity acceleration and spin
and those parameters are set up in the
initialization time so they can be
uploaded to the GPU and then at each
frame there's another parameter we need
to provide which is the time so on on
the vertex shader basically we can we
can apply the mathematics for the for
the motion equation then we can based on
the time given at each frame then we can
we will know what's the exact position
of each vertex and that's that's how we
can we can we can get the particle
system to work at 60 frames per second
because the GPU is doing most of the
competition instead of CPU
so then then there's a physical
simulation and here's one cool demo I
like very much up bad because I switched
again
this is the water tank you can see that
the lighting and everything
I wish this is done by me but no it's
someone else this is really cool demo oh
yeah that's what you can do with WebGL
yeah it's render life
how to make it a job I have to manually
chocolate okay so yeah so that's the
kind of stuff you can do is I'll just
stick with this instead of bring it up
so I have to go through all the slides
that yet so physical simulation can also
be down on GPU and so basically we need
to start the state of the physical
simulation on the GPU then then the
property whether we can do it on GPU or
not depends on if each step of
computation relies on the nearby
neighbors because if each simulation of
each it's a global thing then because
GPU is supposed to be parallel
computation so if it's very global then
you cannot utilize the property that the
parallel parallel ilysm of GPU then it
may not be fast so that's one property
it relies only on the nearby neighbors
so if you have a simulation like this
then maybe you can think of a way to to
simulate the physics using GPU and of
course to do physical simulation you
need to you need to you need accuracy so
floating-point textures which is very
important in those physical simulation
they are not the core part of WebGL but
they are provided through what Jay
extensions and I think it's already
implemented impose chrome and firefox so
there are several other examples and
this is the link you can check a few
other cool demos out
so here is the the part I show you in
the beginning of that talk is the
non-photorealistic rendering so now
let's let me explain what this 3 a few
lines of magical to do those lines
basically changes a rendering from a
shiny teapot to a cartoon style as you
can see the first line is basically this
is actually not exactly intensity of the
color because basically I just take the
norm tool of the color but basically
this will give you a rough idea of how
bright this color is then I say compare
this value with threshold if its larger
than 0.95 that means this color is very
bright so I use the highlight color
which is white which is close to white
here then if it's in the middle then i
use the brown color but if it's really
low this this brightness is really low
then i use the dark color so basically
you are your segment segment thing the
colors into three parts and then you
transform those continuous color realm
into only three colors that's that's
what the first example I assure you is
about basically if you comment those
lines then you see a shiny spot but if
you add those lines that's let's
processed on a per pixel basis basically
you already computer pixel then you just
do some post operation on them then you
get those kind of cut and style render
any news outs and here's another example
example so you can choose how many times
you want two or three or even eight then
you can pick pick colors and everything
and this is
this is done by my colleague crack so
this is another example of what kind of
cool things you can do with WebGL so
here is but some basically what I do is
basically if regular rendering is
basically a computer the color of the
current pixel and then you just set it
and for the novel holder istics
rendering is your computer color but
before you set it to send it to the to
the GAO flag color then basically you do
some conditioning if it's if it's bright
then use a brighter color if it's dark
then using a darker color that's how you
segment the the results into two shades
so last i want to show you some resource
resources you can find if you are going
to explore more about WebGL and there
are many libraries already exists and
make it much easier to build WebGL
applications and here are few
recommendations
then then here are some talks and demos
you can find online which will give you
so today what I talk is really the basic
basic of WebGL and there are more
advanced techniques that you can use to
build complicated WebGL demos and you
can check out Greg's talk and a few
other talks and this chrome experiments
provides tons of very cool web GL demos
then this is the WebGL official wiki
page on the Kronos and then there's
public WebGL mailing list which is
basically discussing about WebGL spec
for example if you try to develop
something and you'll realize it's not
possible oh it's very inconvenient with
the current spec then you if you have
some idea then you can propose the stuff
on those lists and the last list is that
the very first list is you can advertise
whether you have done or if you're a
newbie to WebGL you can ask questions or
even if I some from time to time I see
people just post a segment of code and
ask what's wrong with my code and
there's always very very nice people to
help you out so those are the very
useful resources then of course this is
Web API so the the the fundamental the
ultimate resource of WebGL is the web
because whatever whatever cool WebGL
demo you see their source code is
available to you it's not like C++ or
Java they compile then you cannot see
what's going on in JavaScript the beauty
of javascript is whatever they do it's
available you can just click tools and
reveal source then you can see
everything of course some people will
some post processing make the variable
like we're names are make the lines are
come together make it very difficult to
read but if you have patience you still
can't understand what they are doing and
that's the beauty of the web yeah so
there's one last example I want to show
I think that's the trademark example
demo for WebGL in the very beginning
that's the fish tank and you can select
how many fishes you want and then you
can see the frame rate per second but
for me this is a pretty not very good
GPU it's only a low-end Intel but it's
already with with such a large thing
it's it's it's still pretty good frame
rate okay so basically the idea of WebGL
is WebGL is supposed to make your
program wrong anywhere the same behavior
so that's why we choose opengl es 2.0 as
a foundation of web now instead of more
advanced opengl a more like like more
open G always like more featured coffee
features that's because we try to make
it the experience the same so as for
your question right now we don't have a
benchmark building with the browser so
we don't know how fast the rendering is
we only know that hopefully if we allow
the WebGL to run on a certain GPA on
certain driver at least they render
correctly that's what we can guarantee
but for the speed right now we don't
have a mechanism to say this will be on
30 frames per second guaranteed we don't
have that what you can do is like Maps
gel before they start
like the google map they have a version
of WebGL map called maps gel what they
do is before they launch maps gel they
run a few small benchmark to get
together the speed the few features the
a few measurements they want from you
and if it's literally bad then maybe
they were it not even wrong so that's
currently how people do things but uh I
think we are we're trying to do
something on the browser side so see if
we can provide some pre computed
evaluation after the GPO performance so
then maybe you don't have to build
benchmarks on your own and joint before
user launches it basically you can just
carry the browser say how fast the GPU
is and hopefully we already drawing it
when the GPU when the browser is either
we don't have to wait until your
launcher GPU by the launch of your
application but beforehand when the user
is not doing anything we already run the
benchmark and collected data so when you
query it will be immediately available
telling you how well your GP 0 is how
good it is then then you can decide what
you want to do whether you want to run
on not even launch or sometimes people
have far back if the 3d graphics is not
good enough maybe they have a GPO side
implementation so basically use the CPU
or even for example like Angry Bird they
have a WebGL version and they have a 2d
canvas version because for the angry
bird is basically not much 3d so they
can also do it in kemah study so then
maybe those kind of fall back solution
so but that's in the future not right
now it's not available ok that's a very
good question so the question is do we
have our standards to to send 3d data
for the for the web job application the
answer is no currently we don't have
such a standards
so it is up to the developers to define
their own standards but we do have like
if you want to use some standard if you
want to use some standards like for
example CRADA then if your search web
you can find available tools for you two
to send and two we were to interpret and
unpack those kind of data and make it
more convenient for you to use okay
thank you very much for your time time
and now let's enjoy lunch</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>