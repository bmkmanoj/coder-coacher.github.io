<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>REST API Design with Brian Sletten | Coder Coacher - Coaching Coders</title><meta content="REST API Design with Brian Sletten - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>REST API Design with Brian Sletten</b></h2><h5 class="post__date">2012-09-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HW9wWZHWhnI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today I'm gonna motivate the discussion
a little bit because a lot of people
bring some preconceived notions about
rest and rest design to the table and I
want to lay the position where I am and
my understanding of sort of what the
consensus is amongst the rest community
and then we'll spend some time talking
about your eyes and the names that we
give things a little very very short
introduction on error handling mostly
because it's kind of easy to do
something really stupid and I want to
make sure you don't and then we'll go
through some some ideas about
representation design and versioning all
right
so this is kind of what our our idea of
a REST API is it's really just sort of
like this glue that maps between a use
of an application and the code that we
use to service it and different
applications may exercise different
portions of the API but we tend not to
think of it as its own thing and that's
the first step that I want you to take
away from this is we absolutely have to
start thinking about the REST API as its
own thing
a lot of the tools and the frameworks
and the things that we use are designed
to make it easy to produce and consume
resources in languages like Java and
other programming languages but if you
take the code to REST API binding a
little too literally then your API is
going to become exceptionally fragile
and that's what we want to get away from
so the real idea is a properly designed
REST API whether you're using XML or
JSON or some other representation form
is largely independent of the
implementation that you use to produce
it and if you do it well you should be
able to take the same API and move it to
another implementation and clients
shouldn't know the difference just like
if your webpage shifts from apache to
tomcat to websphere to whatever right
your your clients the browser's don't
care and they're they're broken they're
not broken when this happens so we bring
our experiences with Java
API development when we talk about REST
API s and we end up writing
documentation that says like if you
invoke this and then this and then
listen and this something will happen
and that's also kind of the wrong
approach because that will give you
systems at work that will give you
systems with certain amount of
flexibility but it also means that the
clients are a little too tightly coupled
to your particular implementation and
we'll talk about that in a minute as
well a really really really good sanity
check as you're designing these things
is to ask the question wwbd
what would browser do okay and you will
find yourself recoiling
in the realization that you're doing
some silly stuff when you think all
right if a browser hits a new website
does it stop and say hold on I have to
go read the API documentation before I
can learn how to interact with this
thing it does not write so why are we
building restful api s that require the
same kind of knowledge on the client to
understand how to interact with the
backend system it's not that you don't
know things it's that the coupling is to
the expected representation that comes
back not necessarily the layout on the
server and the goal of a proper fully
level 3 hypermedia design that we'll
talk about is to allow the clients to
learn what's what's available from the
representation that comes back just like
your browser you point it at something
it's never seen before and it says mmm I
don't know they said all you can do is
login so then the client interacts with
the representation logs in and then the
browser goes oh well now it says that
you can access your account a lot of
people go yeah it's great for user
driven things but not api's and the
reality is that's kind of a red herring
right a-agent or a spider can act as a
user and look for links with certain
types and find them and discover them
and interact with the restful api just
like a person can but that really sort
of hides the fact that we could have in
these different clients browser-based
clients phone apps you know any kind of
even another system interacting with our
api's and it should work exactly the
same way so we have this framework that
Leonard Richardson gave us called the
Richardson maturity model not
necessarily as a measure of where you
have to go but more as a way of
discussing the level of of the number of
web technologies that a solution uses
and how it sort of conforms to the
vision of rest keep in mind the goal
here is not to be restful I don't want
that to be the the takeaway the goal
here is to build systems that display
certain characteristics and the
constraints and the choices and the
design considerations that go into a
REST API are designed to elicit those
properties
so when Resta firings get all that's not
rest they mean well right what they're
trying to say is you're making a
shortcut here that may seem expedient
now but you'll pay for it later in some
way so you know cut them a little slack
they do mean well and they're generally
right but that's not to say you have to
go all the way to level three right now
and I never encourage people to have
that be the goal but at least to
understand what that goal brings so when
we look at a system and we decide what
is it attitude towards information
resources what is this attitude towards
HTTP as an application protocol not a
straw like soup generally treats HTTP as
a straw to send messages across and what
is it support for hypermedia
so those are the three counts that we
have and we if we look at soap itself
it's know know and know which doesn't
mean that it's a soap as a bad
technology it still has its uses but
it's not rest and then these rest verses
so religious wars just are kind of
stupid
like most religious wars so a lot of
people come to rest and go okay I get it
I can put a URL in something and invoke
it through my browser that's cool it's
marginally cool and certainly not the
goal
and the problem with that is if you rely
on only what the browser allows you to
do then you're going to build a subpar
system because the browser's don't allow
direct item potent requests for you know
using puts and deletes because the
people on the html5 working group
decided you guys don't need that when
they actually serve very interesting
purposes so the goal is not to make it
easy to invoke things through your
browser the goal is to build systems
that have certain characteristics just
simply slapping a URL on something
generally does not do much for you
most ap is that are restful that we'll
see on the web and that most people
build are really only level two they
respect information resources they treat
HTTP as an application protocol for
manipulating those information resources
and they might even support some notion
of content negotiation but we know that
our level two because when they make
changes their clients break or they put
versioning numbers in the URI as a means
of preventing the client from breaking
and neither one of those is how the web
works right if you go to a news source
and you say show me the headlines you
get back some results and then tomorrow
you come back you say show me the
headlines you get back some results if
we had to bookmark and sort of say look
I'm only gonna see this as my head my
headline URL and then you change what
comes back I will never see that I will
never see the news of the future because
I'm tied to the identity of the past and
so this notion of versioning being
important has more to do with the
coupling in the API than it has to do
with you know any kind of requirement
and a lot of the things that we we think
required versioning changes really don't
if we get our clients to build systems
that ignore things they're not expecting
then the server can roll out new
capabilities but the client simply won't
take advantage of but any client who
wants to take advantage of the new
capabilities will roll out in the new
future but what we've done is we've
separated the simultaneous deployment of
both clients and servers because again
what would browser do it would have
failed the web never would have worked
if
every time we had a new web server or a
new layout we needed new browsers as
well so we want that amount of
flexibility and a big part about what
resk brings to us is predictability
about how the system works
regardless of what you're doing and this
is the final of what would browser do
question I want you to take away is does
the browser care if you're hitting a
financial website or a new site or a
chat board or some kind of game system
and the answer's no it doesn't care
about any of these things so this idea
that our domains are so much more
interesting and complicated is again
nonsense right we have capacity to
manage the the gradual rolling out of
new capabilities but it does require
commitment to some of the larger
principles here so then finally
hypermedia is is the the level 3 notion
here and this confuses people but it's
kind of strange that it does because
everybody understands it you understand
how your browser work you understand
that you learn about HTML you discover
new capabilities your browser can
download JavaScript and run it in a
client and sort of extend itself on the
behavior that it has but what it's doing
is it's not really caring about where
you point it it's caring about what
comes back when you point to it so the
browser reacts to what it's learns it's
not saying I'm a super sneaky
intelligent browser and I know what's
gonna come back if I hit this website
and that's the difference we write
applications that behave like the latter
but we want to write applications that
behave more like a former because they
will be more resilient now there are
trade-offs in this right there are there
are abstractions and their flexibility
and this means that not every system is
going to fit nicely into a REST API if
the cost of creating tcp/ip connections
is too high for what you're doing then
you're gonna want to build some kind of
high transaction messaging system or
something like that but for the most
part we can apply these ideas very very
generally just like the web and browser
technology can be applied very generally
as well so what about the names
everybody thinks that the name of the
thing is so important and as all of this
sort of folklore oh it's gotta be a noun
it's been you know you can't be verbs
and that's generally good advice but
people kind of misunderstand or
overstate the importance of that and
we'll see that in some design decisions
a little bit later the point is I don't
want to have to care about the structure
of a particular URL I don't want to have
to care too much about what this one
thing does I just want it to behave
predictably if I asked for it if I try
to mutate it if I try to remove it so
the characteristics of a good long-term
identifier is that it is global scope it
will resolve the same in any context it
means the same thing in any context and
what this ends up doing for us is this
allows you to create your own website
you need to create your own website and
you to create your own website and we
just don't worry about conflict because
we are protected by the authority that
the domain names that we're publishing
in to protects us from so we get
completely interoperable identifier when
we use global names and we get the the
the sameness the thing that comes back
is is the same we also want to
disambiguate your your eyes for my you
are eyes easily and so part of the
reason why these are character based is
because we can just do simple string
comparisons and we can write them down
and we can print them on walls and
napkins and business cards and things
like that and it's very easy for us to
very quickly decide is this the same one
as that one but the thing that I think
we don't give enough credit to is the
fact that these identifiers that are
global and it's ambiguous
are also resolvable the name of the
thing is how we interact with it and
this is a compelling property when we
start applying it to the information
more arbitrarily if you think about like
an ISBN number or something like that it
does have global scope because you've
gone through the registration process
you paid the the fee so the ISBN system
can make sure you're not going to have
the same number as somebody else but
it's not resolvable you don't know what
to do with it you have to find a service
that knows how to interact with it and
that's kind of a drag
being given a name and saying here
here's the thing I'm referring to and
allowing you to just pull on it that's
pretty cool so what we actually have is
a naming scheme scheme the URI scheme is
a scheme for naming schemes and it was
actually reverse engineered from where
we started which was on the resolvable
names the web emerged with a certain
view of making documents available on
the web and then people that were
involved started to say you know what we
want to refer to things that don't live
on the web as well things that aren't
documents I want to give names to people
and concepts and things like that so the
reverse engineered a lot of the ideas
from URLs into your eyes but defined a
scheme that was extensible and yet
consistent what this does for us is this
gives us the ability to introduce new
naming schemes down the road and to map
existing naming schemes into those
naming schemes but it all parses the
same so we don't have to have custom
parsing for the structure of names
because we have this naming scheme
scheme but the problem is we suck at
naming things right we produce systems
that have things like CGI bin and that
Doon dot PHP in dot who cares right the
name of the technology should not be
used to identify the resource why
because you guys go to conferences and
learn about new technologies and go home
and run off after the new shiny object
and there's nothing wrong with that but
if you don't then curate the stuff that
you had then those URLs become less
interesting and the value of good
long-lived URLs is that they will draw
attention they will be like flypaper and
get people interested in the things that
you're doing and I hope I have network
connectivity back here
I'll give that a chance to resolve so
people in like the library space people
that deal with long term ideas about
information who aren't susceptible to
the constant flux of Technology change
like we are so like forget you guys we
need a good naming scheme that's stable
and so librarians people like that like
to have have names that five years from
now or ten years from now fifty years
from now we'll still be good stable
names but what do they give up in the
process they were gave up resolved
ability so now I not have to go look up
that thing so your homework assignment
your what I'm asking you to do is to
create URLs that behave like your ends
good
long live stable identifiers so this
site that I want to take you to here is
called retriever and it's a good example
of what happens when there's stability
in your information much better thank
you so if you go to Flickr and you use
their organization scheme towards their
resources you'll say find me pictures of
with blue sky and if people happen to
tagged it with blue sky you'll find
pictures of blue sky but if they don't
happen to tag it you will not find those
pictures if however I come up and I say
look I want pictures that look like this
then they could come back and find
pictures that look like that now what's
going on here is that these guys are
some Austrian researchers who spidered
Flickr and found references to the
images and downloaded them and then ran
them through a series of algorithms that
identified color histograms and it did
edge detection and use that for indexing
the images but they don't have copies of
the image they don't keep copies of that
stuff around they keep references back
to where it came from so when I present
something similar it says all right well
let me find things that are sort of
similar to what you provided look in my
index and then go back to where the
information came from that is what we
want to do with our stuff as well we
want to have information that's useful
outside of the context in which we
create it and the only way we're going
to do that is if we have some thought
and consideration given to the
identifiers of the things that we're
creating
so they have longevity beyond our
immediate need and one way to do that is
to build URLs that behave more like your
ends what this gives us also then is the
ability to have address ability of all
of our stuff right not just documents
not just static documents but static
documents dynamic documents arbitrary
data and in this case rest is just
another type of thing that we can
address and it's about the information
that it produces or consumes not the
fact that it's a service in general we
don't care about services which is a
weird thing to say after a decade or
more of service oriented architectures
what we care is that a service produces
something or consume something and the
resource abstraction subsumes that
notion so I really don't care about the
distinction between invoking a service
and what it produces I can give it a
name I can map it into some kind of
behavior and I can produce a result
that's what I care about we're not going
to spend much time talking about today
but one of the things that the Semantic
Web does for us then is to introduce
this idea of names for non network
addressable things I can give myself an
identifier and then I can connect myself
to a document or to a data set as the
the person who created it and in doing
so I can use standard global
disambiguated enta fires for my entities
as well as my relationships which opens
up a whole new world for us but we don't
have time to talk about that right now
so I go through and I want to create a
web service for finding the employees in
a company produce a URL like this what
do we think
good URL bad URL will it produce the
data yeah okay so it's at least some
notion of a good URL it does something
what's what why would a rest afar en get
cranky about this so I agree with you
I'm just playing devil's advocate here
hey the reason they would get cranky is
because this is now a special URL this
is a special URL that only does one
thing and I would not imagine using this
URL to update employees or to delete
them or to remove them so I would have
to set up another endpoint to do that
and another endpoint to do that and
suddenly the client is coupled to too
much knowledge about what this specific
URL does and that's the problem so if
instead we think of this as slash server
slash employee as the set of all
employees I now have the way a way to
identify and resolve our entire employee
base now if you work for a very large
company you may want to have pagination
in there but that's something the server
can drive as well it can say here's the
first ten the first hundred and then you
just ask for that thing you don't even
have to know what the pagination scheme
is but you can then go back through them
come up with your own schemes as well
now the question is once we have the set
of everybody then we want to introduce
arbitrary partitions of that set to talk
about classifications based on status or
individual employees or employees with
degrees or employees who have children
or employees who participate in
intramural sports programs whatever
right anybody you can imagine wanting to
carve up that set into an interesting
business concept giving it an identifier
and allowing people to just pull on it
what's the distinction between these two
URLs
okay so what's well they return
different results probably probably the
same results the difference between them
is this URL terminate or the identity of
the resource terminates at the question
mark and we only have one resource
depending on however many queries and
attributes and things that were we're
going to ask of it so the set of all the
set of all hourly employees and the set
of all full-time employees and the set
of all regions or seasonal employees
isn't really model using this approach
because the difference between how we
interpret that URL inside the handler
and outside the handler is driven by the
fact that the resource is terminated by
the question mark if I asked what is the
resource that's being asked for its
employee now it's a subtle distinction
but if instead I take the second
approach this now is an identifier that
will behave the same it is a partition
of the set of all employees based on
status and it will be treated the same
both inside and outside of the handler
but we like this arbitrary ad-hoc query
incapability we don't have to give that
up and in fact there are times where
that key value pair filtering is
preferable to something like this
because not everything represents a
hierarchical relationship and people
shove non-article relationships into
things like you know slash lat slash
long and there's no relationship between
latitude and longitude like that so
we'll come back to that in a second all
right so obviously I want to partition
on various subsets but I also want to
talk about specific employees and it
would be perfectly legitimate to have
one group of people working on a restful
service that produces this kind of
partition and somebody else working on
URLs like this and is this a good URL
sure it's it's a perfectly reasonable
URL on its own in in
with no larger context is this a good
URL given the fact that somebody has
already done this partitioning no
because now we have this accidental
conflict right what comes after employee
is it a status designator or is it an
identifier certainly we can in our
configuration say all right if it's
slash status then go here if it's not
then go somewhere else so it's not that
we can't solve the problem it's that we
don't want to think that hard about it
we don't want to accidentally back up
into this kind of ambiguity and we don't
want to prevent Stephane tatis from
working at our organization because she
might really rock and if we have this
this ambiguity then we have this problem
so if we think about these as sets and
set identifiers and vectors and vectors
through information spaces then we can
introduce a new partition scheme by
introducing a new vector component and
so the vector component here is identity
I'm going to spin off this way to talk
about identity I'm going to spin off
this way to talk about status and now
it's much less likely that I'm going to
produce URLs that are going to
accidentally conflict accidentally be
ambiguous now there's a form of URI that
timber Tim berners-lee has been
popularizing called the matrix your eye
and it allows us to mix and match the
hierarchical and non hierarchical
components with potentially ad hoc
queries I can talk about the set of all
color maps at a particular latitude and
longitude at a particular scale but
unlike the question mark query parameter
approach that is a single identifier and
it is an ad hoc potentially identifier
that identifies the set of all maps at
that location and what's funny is what
we think of as ad hoc queries at scale
aren't really ad hoc queries right
somebody wanting to know like what are
good restaurants in this zip code or
find me good Indian food within 10 feet
from where I am or 10 blocks of where I
am in a place like San Francisco or Los
Angeles or New York write that question
probably gets asked an awful lot and so
our potential for caching and reuse and
these sorts of things are also
empowered by this now I still don't
necessarily want clients to have to know
how to build these things up i we will
allow them to do ad hoc query but I
probably want to introduce a new concept
like the set of all new maps that some
will be somebody starting point and then
from there they'll get back some kind of
representation that will link them into
our naming scheme and they will discover
the links there and then they can
bookmark the information and come back
to it so that's our goal is to have
these things be discoverable and I'll
talk about some consequences of that in
just a second
but the take take home message here is
think of these things as information
spaces think of a URL as a vector
through an information space and you'll
realize that one path might get us the
answer but another path might also get
us to the same answer if I asked you to
design an API and ask for what time it
is based on the times on your end
you'd say time zone / PDT everybody
knows what time zone they're in but if I
ask you what time it was in Hawaii based
on time zone hmm I don't know Hawaii's
time zone I can't simply ask for that
information but if I give you another
path to say like time done / state /
Hawaii I'll end up with the same result
but I now will learn what the time zone
is and I will learn what the link the
canonical link is based on time zone but
we can give people multiple paths to the
same answer based on what it is that
they do know now because Tim is
responsible for the long term longevity
of the web he's got to get a little
Debbie Downer on us and say stop trying
to parse these things stop trying to
look at a URL and assume that you
understand what the structure means but
Roy says yeah but there's interesting
serendipity if we treat these things as
meaningful hierarchical partitions we
can discover connections between things
by popping up a level and getting back a
collections of things a thing or
discovering what options are
available below and if the hierarchical
scheme is meaningful and memorable we
like the idea of bookmarking and
remembering something is just a weak
form of bookmarking so if we make these
things make sense and we made each
element makes sense then these things
become memorable and then people can
just ask for the information that they
want now I don't again this is not
clients building them up but if you are
interacting with something and you
remember what the scheme is you can just
say hey let's go to the starting point
and ask for it directly so Tim's point
is these could just as well be the same
URL to the same thing Roy's point is one
of these is easier to remember than the
other and no credit for guessing which
one so when we start thinking about
hierarchical decomposition and
partitioning of our systems if I wanted
to provide information about the talks
and the articles and the white papers
and code samples and things like that I
give that's a meaningful decomposition
that's unlikely to change so I can start
there if I want to introduce the talks
that I gave at this conference versus
the semantic technology conference
versus the museums on the web conference
right that's another interesting
partition underneath the set of all
talks and then from there the talks that
I gave this year at Jack's versus the
talks that he gave last year at Jack's
also a meaningful decomposition people
often ask me well how come you didn't
specify that as talks year conference or
conference that could be another
interesting partition like if you wanted
to know which talks did I give over the
last several years that's the driving
motivation not what talks did you give
at a particular conference over a series
of period of years
either one is legitimate it's just a
question of what's your purpose so if I
asked you two to read and interpret this
URL just for the hell of it you'd say oh
the rest talk that you gave at Jack's in
2012 but there's not only one Jack's
conference right if I spoke at a
different one then I might decide oh I
no longer want to talk about just the
Jack's rest conference I want talk about
the rest of the rest talks that I rest
that I gave in San Francisco and if you
just like slap another element on this
URL you've now changed that thing from
being a leaf node to a non leaf node and
that's the kind of thing where it's if
you're not careful you will change the
interpretation of something and if
people have bookmarks to it you might
break them so one way that we can get
around this is to to mint your eyes that
are meaningful in different rate ways so
I can have a canonical one that says all
right this is the link to my rest talk
and it changes over time it changes you
know talking to people what they like
what they don't like new frameworks new
new thinking so if you bookmark that you
might get something back every single
different every single time but it
represents my latest thinking whereas
this is a stable historical identifier
that will give you back you know one
specific snapshot of the information and
therefore is less likely to change so
that's a quick walk through of names and
names are important but they're
important because we want them to be
stable they're not important because the
client needs to know how to build them
up very very quick diversion on error
handling mostly because it's easy to get
this wrong one of the things about the
uniform interface in rest is that a lot
of interaction can happen below the
application level we don't have to write
separate code when we're talking to
information about an account versus
information about an order versus
information about a library book and we
have the ability to express certain kind
of errors in a predictable reusable way
so you've issued a bad request don't try
again until you fix it you've you're not
allowed to see that unless you log in
you're not allowed to see that even if
you do login I don't know what you're
asking for we're having some problems
come back later we can have a very rich
conversation in an application
independent way but we still want to
have some idea of how we're going to
design our application level error
handling so I encourage you to think
about some sort of representation and I
don't care what it is right whether it's
JSON or XML or a document or something
right but have some way of expressing
one or more errors to allow
the client to know what went wrong now
you may have clients that don't know how
to interpret the response of what you
give them so you can come up with a
fairly lightweight way of saying here's
a link to an explanation of what went
wrong so clients can discover new error
handling that they they weren't aware of
hey this is a new policy or hey this is
no longer allowed those kinds of things
can happen but just if you're if you're
heading in this direction get some
consistency to how you handle
application level errors just so your
API doesn't behave differently than this
other departments API and at nauseam but
the main thing I want you to do is not
return a 200 response code in an error
condition and that's a lot easier to do
than you would think a lot of these
annotation based frameworks where you
say the default response is a 200 if you
happen to catch an application-level
exception that's thrown and sort of say
okay well now I'm going to set the
response to be this error message and
forget to set the response code to be
something other than 200 then you've
just told the client that they can catch
the error message and don't it's not
even worth bothering trying to fix it
because you may not see the the proper
response so not a huge point but just
make sure you're deliberate about how
you how you test these things another
thing that a lot of people don't
necessarily spend a lot of time thinking
about is what does it mean to introduce
suffix based type selection again
through the browser hey look I get HTML
look I get XML by just tagging a suffix
on to this I'm not telling you not to do
this and when I build systems I support
this mode because a lot of people like
it if you know that you want the XML or
the JSON version of something just ask
for it that's fine but what you're doing
if you then commit to this specific
format of the thing and pass it on as
part of some orchestration is
potentially stealing somebody else's
freedom to make a different choice if
you pass around a logical reference and
allow people to negotiate it into XML or
JSON or an Excel spreadsheet or
something like that then their tools
their workflows those kinds of things
can absolutely vary from consumer to
consumer even with
in the same orchestration but if you
pass around a reference to a particular
format and that's not the one that they
want then they're gonna have to work
harder to get it into the form that they
do want and there may not be like a
discoverable way of getting from HTML to
the Excel spreadsheet rendering of this
not as important in the rest space but
once we start thinking about information
resources and describing them with
metadata we've also just forked the
identity of this resource and if I have
access control policies and authorship
and licensing and things like that
associated with a particular resource
then I now have to come up with a
mechanism of tying it all together and
we have ways of doing that it just
starts to get harder so what we can do
is we can have the same named thing and
it's a conversation clients can say I
would like to see this report back as
XML I'm gonna do some programmatic
negotiation of the data I want to get it
back as Jason I want to get it back as
an excel spreadsheet or I just want to
render the form and what we start to
realize is there really isn't that much
of a distinction between a webpage about
information and a REST API and the
browser is going to ask for it back as
HTML and so if your handler just says if
anybody asks for the account information
is HTML then just give give a Mac this
web page and we can then start to
realize that the same endpoint can serve
up the different forms not that you have
to do all at once you can pick a couple
you can pick whatever your clients most
gonna want and then in the future
somebody can come to you and say I like
to add support for this and that becomes
an incremental extension not well I got
to go set up a new endpoint that means I
need to get to the data that means I
need a new handler I need to you know
now I'm forking the paths towards the
information which then starts to hit us
down into some circle of hell I don't
know which one the way we do this is
when we ask the request when we issue an
HTTP GET we can have an accept header
that says please give it to me in this
preferred form and you have the freedom
to give it a couple of options although
in general you're gonna say I want it in
this form and the servers are they gonna
say
you know you can also ask for particular
language encodings so give me back a
German version of this give me back a
French version of this and you don't
have to have separate end points for
that if it's the same information just
rendered into a different language
that may not be a distinction worth
exporting as separate URLs you also have
the ability to ask for various
compressed forms too if bandwidth is an
issue to you but what you don't have to
do is make everybody else care about
these decisions if nobody else in the
enterprise really cares about compressed
forms of this but you're building a
phone app and you need to be more
careful about how you consume this
information that support can be added
without impacting the enterprise
developers at all and if they decide
that they want to use it
knock yourself out doesn't this nothing
stopping you now there is an issue if
you do vary the response based on the
mime type or the accept language or
something like that you need to tell the
world that that's what you're doing
because if you don't then you ask for
something as HTML and I give it back to
you but I'm a caching intermediate proxy
you asked for it as XML I'm like oh well
here here you go here's the thing and I
give you back HTML like that's not what
I asked for
so when you use the very response header
and you tell intermediate proxies I vary
based on the language I vary based on
the mime type then they will build a
compound key for their caching index to
say all right I'm gonna put the HTML 1
here I'm gonna put the JSON one here I'm
gonna put the XML 1 there and I won't
get confused if somebody asks me for a
different version so this is this is a
very important step towards having your
resources be extensible over time and to
give people information in the form that
they want all right so I want to talk
about some some general guidance these
are not hard rule Arden fast rules these
are just things that I've run into I I
tend to design things first in XML and
then add Jason and other kinds of
support most of these ideas translate
any particular representation expression
so I'm not trying to buy a see you
towards XML
so in this commerce domain that we're
gonna talk about I want resources that
have to do with users and items and
orders and I want to have some kind of
workflow expressed in the representation
themselves again you point yourself you
browser at a server that you've never
seen before
and it requires authentication or a
sign-up process it will tell you know
dude you got to sign up first so we want
to be able to control you can't place
this order yet because you haven't told
me how you want to pay for it so some
kind of means of controlling the
workflow in the representation in a way
that doesn't couple the client too
closely to the server's layout and what
we end up seeing remember when I talked
about the API is a thing unto itself and
we want to separate it from the code
that implements it this is about
establishing a conversation in the
language of the domain we are modeling
the main in this sort of beautiful pure
notion and we're gonna hide all of the
crap that's in our back-end systems
which there always is because if we
don't do that and then we fix things and
they just automatically bleed through
into the API then you interests you've
accidentally introduced a potentially
breaking change and you don't want to do
that and this is why I don't generally
like the automatic object to JSON object
to XML serializers because they just
vomit out key value pairs and if you
refactor things then that's gonna change
how they come out and you want to be
deliberate about that so representation
design when I when I build an API is a
deliberate act in and of itself in the
language of the domain and then I worry
about how to map it in and if I have to
write custom serialization I have to
write custom serialization that's not my
consumers problem that's my problem but
I want my thing to be stable so I'm
gonna take the choice so I talked about
some of this if you're going to use some
kind of validation scheme I would wait
until you kind of understand
what we're the representation wants to
go if you start like schema validating
from day one it's just gonna be Mitch
Hedberg has had this joke that a
turtleneck is like having a midget
hanging around your neck trying to
strangle you all day long and I that's
what my attitude towards premature
constraint validation it's like it's
just gonna slow you down it's not gonna
do all that much for you if you then
start to change how you want to
represent things and you have to change
the schema and that just becomes a slow
painful process so spend some time
getting it right and you don't even have
to rely on obnoxious things like XS D
you can have instance documents
converted into like the relaxing format
through the style sheets at example Tron
org so you can take instance documents
and run it through a style sheet
transformation and produce a human
friendly schema there are such things
and if you need to go from that into XS
D for tooling then that could be an
automated process but humans should not
be editing XML schema documents even
through fancy user interfaces it's just
you've got better things to do with your
life all right so as a first cut at a
representation of say an account I might
give it an identifier like this I might
talk about the type of the account the
name the address we want to send emails
to people you know on first blush it
seems reasonable and you might produce
something like this but I want to change
just about everything number one as
we've talked about an identifier or URL
as an identifier has the potential to be
reused in different contexts and if I
just say slash account then adding
support for things like all the new
accounts all the top accounts becomes a
potential conflict so we want to
introduce this identity vector component
to separate specific accounts from
partitions of accounts and then we want
to identify the resource in the body of
the response and if your attitude
towards this is hey my application is
talking to my restful api I just went
there I know what it is then you're
missing the point that if I do
of some partition like all the top
accounts or all the new accounts I might
get back a collection of pointers that
says here's where the actual account is
go get it and this isn't just about
point-to-point you know remote procedure
calls it's like you're discovering the
relationships of links to arbitrary
information let people find it and not
just as a link the link is important but
we want this to be easy for the
consuming developers as well so having
some kind of identity attribute on the
outer element that our JSON object is is
an important thing that's well so as I
said the team that I worked with did a
great job phenomenal job they they had
never tackled rest spring agile
test-driven development griffie behavior
driven development and cucumber before
and yet they incrementally adopted all
of it and roll out the first version in
six months but what I couldn't get them
to do is to think about deliberate
choices about the structure of the
representations so I designed the
representations they started mimicking
my designs I went away and did other
stuff it came back and I saw in
production something like this type
equals three why is it say type equal
three well because that's the service
gave us what is type equal three mean
priority okay you know that how is the
client gonna know that
oh they'd read the documentation why
don't you just tell me means priority
right and if you change your backend
implementation and three no longer means
priority then things break so they
deliberate choices that are meaningful
to the consumer they're meaningful to
the the domain don't just let these
little details slip in because over time
this will make things very very fragile
and you don't want to do that as I said
I don't like these serializers that just
vomit out key value pairs I like to
cluster things based on relation and
I'll become more obvious in a second but
as an example
things like contact information or names
or you know those sorts of things I like
putting into its own thing this is in
part to keep things manageable so we're
not just looking at a thousand different
key value pairs but we want this to
actually be more readable like wait a
minute
I thought this is about software it is
but the more time you spend designing
the representation the more you're
documenting the representation not the
URLs the more time developers are going
to spend looking at these
representations so they should be
readable they should be you know easy
for people to understand and sort of
figure out what's going on now in agile
we have this little angel that sits on
our shoulder and keeps us from over
engineering things and her name is yang
knee and she's like but if you're not
careful and you stick too close to her
advice you can cause some problems for
yourself one example is we knew that we
were ultimately going to support
multiple addresses but we knew that for
the first several releases we weren't
going to write shipping address and
billing address we're gonna have to be
the same thing so if we built the
representation just with an embedded
address element or something like that
and then move to an addresses block that
had multiple addresses in it that would
have been a breaking change and so just
trying to spend some time anticipating
even if the story that you're tackling
is not you know you're not gonna tackle
it for many months you can imagine just
having an address is blocked with a
single element in it and then describing
a scheme for looking at attributes
you're looking at key value pairs on on
an adjacent object to say here's how you
identify their billing address here's
how you're done if I the shipping
address and then the client code will
work the same whether there's one or
multiple addresses in there so I like
you to listen to the Agni but look to
the future as well because the decisions
you make now can keep you from having to
handle breaking changes in the future so
when we talk about being able to contact
accounts the goal is not to have the
email address the goal is to be able to
contact them so that's the functional
decomposition of the means by which we
can contact somebody
and if that's how we structure it then
it becomes easy to say oh well do you
want me to Twitter you when you can pick
up your your TV that you just bought at
the store and it's ready to be picked up
do you want me to SMS you do you want me
to come up with whatever this new and
fancy next year as the messaging scheme
so we can extend and introduce new
contact types in the future and again if
clients aren't looking for whatever
comes next then they continue to work
but anybody who wants to look for that
because they know it's there because
we've published you know the update to
our API we'll be able to take advantage
of it but we get this ability to roll
things out separately and if we make
functional decomposition choices that
becomes easier to do so our cleaned-up
resource looks a little bit like this
slightly more verbose but not terribly
so and you know now that it's kind of
complete and I understand the structure
I might take this and then map it into a
JSON representation again not
necessarily automatically the the idioms
and the expression might be cleaner
slightly differently but now I hacked I
can represent the same thing in
different ways and support people for
the ability to just ask for them alright
so we learned some lessons from
designing the accounts now we want to
design information about items so we got
our vector components we're breaking
things up based on status and what's
interesting about this kind of API is
that I can give you a read-only HTML
rendering of this as a bookmarkable
thing and if your job in the
organization is to know what what's new
what we're selling to be on top of these
sorts of things then this is an
interesting business concept for you to
just bookmark and come back to whenever
you want hey what's new what's new
what's new what's on sale and you can
either present it as it as its own thing
or you could say give it me give it back
to me as Jason and render it into some
kind of gallery in your browser but it's
one data source it's one identity it's a
meaningful business concept made
available to us and yet we also have our
identity for individuals so we have good
URLs we encode and identify the link we
have some other stuff in here what do we
get wrong now
you may if you need to support multiple
languages think about tagging text
descriptions at an element level but
don't go crazy right you really want to
solve this at the document level and as
I as I showed with accept language you
can just automatically tell the server
give me a Japanese give me a German give
me a French rendering of this thing
that's probably the more appropriate
place to do it but there are times where
you may want to have multiple language
and coatings for a description of
something make sure to identify them so
people can select accordingly you know
if you're targeting Quebec or Los
Angeles or something like that you may
you know 50/50 French English English
Spanish but don't go crazy on sending
down a hundred different language and
coatings for the same element you're
just wasting bandwidth at that point and
we have better ways of handling that so
another thing that slipped in when I
wasn't looking I was looking through
some some traffic and some log dumps and
I thought what the hell is a dollar sign
doing in the price element oh well the
service gave it back to us number one
right now clients have to parse
character symbols to know here's what it
is in Euros here's what it is and
dollars and that's really just metadata
about a value it shouldn't be part of
the value so we want to represent things
like currency as attributes on the value
but because this slipped into production
you hope you have smart clients because
the smart client will say if the first
character is a dollar sign then skip
over it if you don't have smart clients
they'll just say skip over the first
character and then when you fix it they
think everything went on sale and you
have problems on your hand so be very
very careful about letting these sorts
of things slip into production now we
talked about identity as a vector
component
but we may not have thought enough about
this because different communities can
know things by different names a product
SKU is generally an internal identifier
a products UPC or ein is an external
identifier and they both point to the
same thing you may need to have both of
them so you may need to have multiple
vector components within even say the
identity space here's the set of all
SKUs here's the set of all you pcs and
taking the time to do this right will
keep you from accidentally running into
a case where this identifier and this
identifier might conflict now obviously
SKUs and you pcs probably won't but it
doesn't take you any time to start
developing these habits and once you do
you'll save yourself problems in the
future now somebody might say alright
well I need the ability to look up ask
you and then find its UPC oh we need a
service for that no ask for it as a SKU
and in the representation provide a link
to it as a UPC you don't need to write
custom services to do that kind of thing
when the information is already there
okay so we learned about items we made
some choices now we have all of our new
orders all of our open orders I may
refer to a particular order I may refer
to an order for a particular customer
you know for that last one that's
probably how I would model it I'm
partitioning the set of all orders
through the customer view other people
might want to say I want to talk about a
particular customers orders my
preference is consistency in the
leftmost thing will tell you what it is
just from an expectation you'll either
get back one of these or a collection of
these depending on where it is that you
start getting in a subjective things
right and my opinion doesn't really
matter there but this is just how I
would do it so now I can have an order
representation I can have links I have
items I have addresses and clients can
know to look for these things not based
on the URL but based on the identity of
the
that comes back and this is where just
tagging something as application Jason
or application XML starts to get a
little problematic because no longer is
this any old XML or any old Jason it's a
very specific thing and the clients have
no reason to go looking for these links
or these these things that we're putting
in there if you just say by the way this
is just Jason now this is not
universally loved in the rest of Orion
community the Orthodox rest of Orion
Church does not like this at all and
they're like only use standard mime
types but the the reformed Rastafarians
the ones who actually have to build
stuff until there is a generalized
reusable hypermedia form this is a
solution and it's a solution that will
be forward compatible if we if we decide
in the future that we've standardized
around there are several things being
considered and they're all very
interesting but there's no we haven't
standardized on them yet in the future
if there is a standard generalized
hypermedia form then absolutely that
will be the right thing to do but until
then if I hit a URL and I get back the
fact that this is one of our accounts
encoded in XML or one of our accounts
encoded in Jason then I know how to
respond just like your browser goes oh
you gave me a byte streaming but called
it a ping image I know how to parse that
I know how to respond to it so the same
thing can be done here I can tell you
what it is and how to interpret it in
the identity of the mime type that comes
back we react to what we come across we
don't know because knowing is a form of
coupling we can then decide all right an
incomplete order should not make it you
know oh hey here's here's where you
should submit the result because the
server is just gonna reject it it's just
gonna say nope you need to tell me how
it where it's going you need to tell me
how you're gonna pay for it and to avoid
that we can control workflow by the
presence or absence of links with
certain rel types and say alright if
it's not a complete order and you ask
for a resource then I'm not gonna give
you the option to submit it
because I'm just gonna reject it now you
may want to have some kind of validation
service some way of conveying what needs
to be done but in general the presence
or absence of these links just like the
presence of the absence of a login
mechanism or a form to fill something
out is how the browser responds we want
to give that kind of affordance
discovery as the term the rest community
uses for this to to decide what it is
you're allowed to do and then if I say
all right well now I know what you I
have something in my cart I know where
you want it to go I know how you want to
pay for it then I will provide a link
with a rail type of submit the client
doesn't care where it is doesn't care
where it's pointing it just asks it just
doesn't post or report or whatever you
just decide to that thing as a way of
then finalizing the order and shifting
it into a submitted state in which case
I will actually charge your credit card
but we can control workflow by
controlling the presence or absence of
those kinds of links there all right so
just wrapping up quickly because I'm
running out of time I can also start to
identify resources sub resources not
necessarily the resource for the item
but the resource for the item in the
order or the address in the order or the
payment type in the order why would I do
this
if I want to add a new credit card I can
find the tender section I can find the
link to the the thing that knows how to
accept the tenders and I can just post a
new one to it I've just added a new
credit card I've added a new item I've
added a new address this doesn't have to
work any differently than any other kind
of resource manipulation why stop there
I can also add identity for the items
within these collections so item number
two address number one tender number one
why would I do this I want to change
credit card I can issue a delete request
to that thing I don't have to know
exactly how this is handled I don't have
to write custom software for doing what
is really just an information resource
manipulation obviously I have to write
the behavior in the backend that
responds to a delete request to that
thing but from the clients perspective
it's not behaving any differently than
anything else and if I want to change
the order or the quantity of something I
can post a new quantity to it as well so
very quickly just to wrap up with
versioning a lot of people build level-2
restful api Zanden code versioning into
it because if they don't and they make
changes the clients break and we don't
want to do that so we can reflect
versioning in the mimetype as well it's
just a question of whether you need to
if you rolled out and did not have this
kind of versioning represented then you
can't change the default behavior but if
somebody asks for a new version you can
be like okay here's the new version if
you roll out with people asking for the
version one then you can change the
default type because the version one
people will still be getting the version
one of the representation now this
doesn't just say that this is an easy
problem but it gives us tools for
managing and it gives us tools for
deciding a breaking change requires a
new version and that's when we will
reflect that but if we don't have
breaking changes we don't necessarily
need to rev the version number and
things should continue to work like I
should be able to add a link that
connects an order back to its account
and nobody who's anybody's are not
looking for that will just ignore it but
anybody who wants to do that connection
that's a very useful piece of
information they will roll out a new
version of the client to
to accept that if I change an address to
an addresses block however that's a
breaking change and I need to be careful
about that
so John's famous law of being
conservative of what you send in liberal
and what you accept can help you make
choices on how to respond to these
things when I designed this these
representations I called everything that
was askew askew six months later when I
wasn't looking out comes this thing that
talks about SKU ID why did you call the
SKU ID oh it was the attribute name on
the thing that I got back from the
service have we not discussed this so
now our representation is reflecting
things differently in different
representations and that kind of sucks
but because this is something coming
from the client I can be liberal in what
I accept I will accept either a SKU ID
or ask you and then exert some kind of
pressure out-of-band to say by the way
next time you roll something out can you
drop that use of that attribute so
they'll be like sure no problem I don't
want to make them do that I want to ask
them to do that and when I detect that
nobody's providing this anymore than I
can deprecated it and invalidate
subsequent requests if however it's
something that we send down and we get
it wrong then we may have to send both
forms of it down until we can also get
this pressure because simply picking one
may break somebody who's expecting the
other one and this sucks
but it's a tool for doing these sorts of
things so try not to break things good
rule versioning as needed and as needed
as defined as when you have breaking
changes and plan ahead so I'm happy to
answer any questions but we also run out
of time my email address in Twitter
handle there are there if you want to
contact me I hope you enjoyed this and I
hope you enjoy the rest of your week as
well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>