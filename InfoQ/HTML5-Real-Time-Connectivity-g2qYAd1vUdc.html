<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 Real Time &amp; Connectivity | Coder Coacher - Coaching Coders</title><meta content="HTML5 Real Time &amp; Connectivity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 Real Time &amp; Connectivity</b></h2><h5 class="post__date">2012-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g2qYAd1vUdc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a little bit about myself I think most
of you know me the guy with the html5
license plate the author of the pro
html5 programming book basically html5
is all i do and i work at cousin
focusing on technical training in the
html5 area all right so quick agenda I
want to talk about all of the different
API is that make up html5 communication
and there's quite a few and a couple of
concepts in there that are important so
I'll sprinkle those in there and one
more technology that's not really part
of html5 I don't want to put it under
html5 but I think it'll be interesting
because it's so closely related which is
speedy so we'll talk about these in in
disorder and basically I want to just
point out for those of your new 2805
html5 is pretty large and there's many
different feature areas from mark up to
the connectivity will be talking about
to the canvas and other areas and video
and audio and so on so as Remy's sharp
pointed out html5 is not something you
it's not an all-or-nothing approach you
just you pick the feature you want then
I would like to add something like well
the typical process would be you
prototype with that feature you want
then you realize okay well that doesn't
work in all the browsers maybe then you
use something like moderniser that we
talked about a few months ago and say
okay which browsers have it find a good
polyfill library so in this presentation
I'll also point out a few of those that
that are related for example there's
libraries and servers that provides
ambulation for some of the features
we're going to be talking about so I
started working on this map of all of
the different html5 features it's
nowhere near complete I think but it
gives you an idea of any one of those
areas blown out to be you know any one
of those is an explosion of new features
if you think about local storage and
session storage and database storage
whereas in the past we had maybe just
cookies right there's just a lot there
in all of the different area
and we're going to be focusing on just
one of those areas which is that
connectivity in real time all right so
one of the main things about html5 is in
its design goal has been to keep things
simple and it also one of the sort of
the ways that this is described is
paving the cow paths for example if you
have a form with an input that you have
to detect whether that's an email
address and it used to be a crapload of
JavaScript you at the right or pulling a
library and now it's you know input type
equals email very simple now the
connectivity area is is definitely one
of those areas where paving the cow
palace was really a welcome change
because that was one area where you had
to use the craziest hacks to get things
done and so everyone that has some
experience in that will really like the
simplicity of these api's it's actually
sometimes it's like oh that's that's all
there is to web socket I mean it's
really that easy it really is so the
first concept they wanted to sort of
talk about a little bit is the the
origin concept some new just in LA last
december two thousand eleven a new RFC
was published for the web origin concept
right that the origin itself has been
around for a long time it's the
combination of a scheme host and port
and all of those components the scheme
host and port need to be the same or
communication will typically fail
because of a same origin policy in the
browser and that's quite literal and pay
attention because I will be asking a few
quiz questions here there and this is
going to be one of the subjects so the
origin is used to model a trust
relationship on the web so everything
has a URL part of that is the origin
scheme host and port so scheme would be
HTTP or WS or a website
it's the host is the fully qualified
hostname and the port 80 or 443 are the
default ports but there could be some
somewhat airport now typically the
browsers enforce a same origin policy
and that's for your protection right
that was introduced a long time ago but
as we're moving to more client-side rich
applications that's becoming a little
bit too restricted so we need something
else or we need something a little bit
more relaxed but at the same time we
don't want to lose that thatthat's
security right that's the number one
thing you don't want to be opening it up
for vulnerabilities so here's a quiz
question for you the first person to
raise their hand and have the right
answer can win a book copy of my pro
html5 book which of these URLs and I'll
give you a hint yes perfect excellent so
what I wanted to point out here is that
one and six are the only ones that have
the same scheme host and port right so
it's the exact match for example the the
IP address that actually resolves
through that same hostname it is not the
same the browser sees that as a
different a different origin and that's
kind of important you can run into a lot
of small issues with that also
subdomains are not on the same origin
alright so the first feat you want to
talk about is the cross document
messaging you'll see that origin concept
coming in over and over especially when
we start talking about the cross-origin
resource sharing so cross document
messaging and the reason why I picked it
from cross document messaging to xhr to
WebSocket in that order is because it
sort of you could say from small to
large whereas cross document messaging
is intra page or in the browser it
doesn't communicate with the server it's
just from let's say a page to an iframe
or another tab where then server sent
events and xhr
municate with the server web sockets is
bi-directional communication with the
server so that it sort of gets bigger
and bigger and cross document messaging
also known as the the postmessage API
allows you to pass messages back and
forth not just between the same origin
but even cross origin and we'll show you
a little bit how that works so first a
little bit a bit of a demo here so
there's a lot of html5 slides show you
know applications and one of them was
created by a guy from Mozilla Paul bouge
from France and he created what is
called easy slides if you look at what
is happening here if I click around then
you notice that I'm controlling from a
page I'm controlling up another page in
an iframe and that sort of communication
is pretty typical for a cross document
messaging and it's actually he's using
the postmessage API to send a small
message to that page that's on the
iframe and it doesn't have to be on the
same origin so that's that's a powerful
thing that you can you can open things
up cross-domain so that's just one
example and a lot of other things are
especially in what we talked about
earlier in Moby specialty that
advertising that's where you start
seeing a lot of when third-party content
it comes into your page and an iframe
social like buttons and things like that
that becomes then they're usually hosted
on different domains that you start
running into these same origin policies
and this is a good way around that so
the post missed its architecture is you
use post message to send a message now
on the receiving end you need to add
what is known as an event listener for
messages that are coming in there's a
couple of gotchas there but when you
send the message in JavaScript you use
the postmessage API you send the message
and you pass
in the target origin as you can see
there and then the receiving end let's
say the either to page I mean it works
in the same way in both directions the
receiving end has an event listener it
receives a message object it detects to
see it checks to see which origin that
came from and then it makes a decision
on whether to parse that or not so
that's the the high level architecture
so in JavaScript that would look like
this you send a message or use post
message passing in the actual message
that could be an object it could be text
and then you can also send the or you
have to provide the the target origin
that's an extra security feature but
what's important here is that the
browser tax on as you can see in this
here the browser adds your origin and
that's something that can't really be
spoofed unless you write your own evil
browser but let's say that normally that
cannot be messed with so in that sense
it's secure so you're not actually
passing in the your origin but you're
passing the target origin then the
receiving end adds an event listener for
the message that's a named event it
listens for that passes that through a
message hand passes it off to a message
handler which checks to see the origin
if it's one of the list of trusted
origins then it goes ahead and does
something with that message so that's
really the key thing and you do that on
both sides of course and anyone knowing
another API that uses post message this
is not for a book that's just web
workers right exactly so web workers is
always on the same origin the difference
there is you use post message and you
just pass the message in you don't have
to pass the target origin because it's
assumed it's the same origin because you
cannot start a web worker on from a
different origin has to be same word now
there's a really
important detail here you may have
already seen that there's a pretty big
vulnerability or a possible
vulnerability in here if I go back to
this add event listener if I just said
look I'll listen for messages and I
don't check as you can see here I don't
check the origin but I immediately start
processing it well that could be a real
problem and the specification has the
first line of the spec is a giant the
red warning because you're using an
event listener that cannot really be
changed it's effectively you need to
write that code yourself and it's quite
important and there's actually quite a
few examples out there on the web that
don't do this at all they just you know
take the message parse it and then you
could open yourself up to quite a
vulnerability so this is quite an
important detail what you should be
doing is using a white list of allowed
origins okay so this is actually a
feature that supported in IE 8 right so
this is something you should really be
able to use this has been around for a
long time you can use that and so there
are emulations for older browsers a
couple of them one of them is a pretty
wide widespread adoption is called easy
XDM another one is the causing WebSocket
gateway that actually has a an emulation
for that all the way back to ie6 and and
for those of you that don't know this
there is a great website and I've put
links in here and I'll hand out the
presentation afterwards so I'll put it
on SlideShare can I use com that's your
one place to go to to see all of the
browser support and it will tell you
exactly which browser support it ok I'm
going to move on to the next section
which is a course so course stands for
cross-origin resource sharing there's a
great site that I recommend all of you
to look at if you're interested in that
and basically when you start moving away
from the intra browse or interrupt page
communication like we just talked about
the cross document messaging then you're
very soon going to talk to a server so
you have a maybe an xml httprequest that
you're making to a remote site well
there's a potential problem because if
that's on a different origin you can't
you can't do that right with the same
origin policy so people have found even
there a nice way around it jsonp jsonp
can be kind of kind of danger this is
jason with padding effectively what
you're doing is you're taking a script
you're basically sending a message and
you're you're you're saying here you
decide what script you're going to run
on my page so that's if that doesn't
sound dangerous to you then we probably
weren't listening so that's that's
really not a great architecture now
html5 defines a new API which is the or
not an API a new standard for allowing
access to resources on a server but by
doing that by allowing that through a
white list of allowed origins so there's
a standard that's now built around that
that makes it easier to share resources
from different places with each other
and so basically the big difference with
xhr and coors using the course
architecture instead of JSON p is that
you're no longer getting code but you're
getting the data that you want it in a
in a safe way so what we'll take a look
look at that so the the core standard
defines a set of headers because right
now you're moving from the the page to
another origin that is on another server
right in this server you need to
communicate effectively that same origin
property that we were talking about in
cross document messaging you need to
communicate that to the server so how do
you do that over the web well you send
an HTTP header and the server responds
with one soda on the one side there is
the origin header that's different from
the reefer
header a famous misspelling in HTTP and
that is just that origin concept we
talked about earlier the scheme host
port on the return the server will allow
you it will say to sort of display which
origins are allowed for that particular
service so what this really allows you
this is pretty powerful it doesn't sound
like much perhaps but in the past there
was a lot of there were a lot of
problems with server-side aggregation
being a necessity because of that same
origin policy for example you have a
page that has a stock portlet in a news
portlet well if they come from different
origins the browser would first need to
talk to some sort of application server
which aggregates everything and then
serves it up from a single origin now
the browser can go to a page make
cross-domain connections send cross
domain let's say xmlhttprequest by using
that course standard it can if it
communicates like i'm on this origin and
the server says okay on that origin you
have access to this content go for it so
now you can open it wide up and still in
a secure way so it's really protecting
the server's resources and if you look
at the the HTTP headers that are come
with this and again I'll make the slides
available online later it sends the
browsers that support this they send an
Origin header and on the way back the
server will pass in different access
control allow origin credentials methods
and so on so it sends it back access
control headers this is defined in that
core specification something similar to
this would be in canvas when you display
an image on a canvas the canvas becomes
tainted if that images from a different
origin so now similarly on canvas you
can define a
cross origin attribute that you know
when you communicate and you get it from
a server that does allow that you can
use that and get the image data from
that canvas image right so this the core
standard itself is supported in all
these browsers I eight has something
called cross domain request xdr that
does a lot of what this is doing so it
it's not an identical standard but it's
close enough in many cases and you do
need for this server that supports that
standard now xmlhttprequest is where
really where we use this and also in web
sockets we will use this cross domain
capability so xhr is the Ajax API if you
will there were a couple of things
lacking that have been fixed in xhr
level two and their progress events
support for binary and also cross domain
using the core standard now in the past
the progress events were very hard to to
get like in some some browsers they
wouldn't fire properly the different
ready states where numeric properties
that you could get and it was a bit bit
of a hack so now there are these named
progress events that are supported by
the different browsers that support the
standard and you can build very nice
progress bars there's even a new HTML
progress element that ties in nicely
with this standard so these ready state
and ready state change in typical html5
so are retained for backward
compatibility now you the way you would
use them would be something like
building a status bar of how much you
have uploaded or how much you have
downloaded so if you do an xhr get or
post you can monitor how much of that
data has come to you and compute how
much is already has been loaded I have
an example of that later so the cross
domain xhr you
can't really tell that that's across
domain unless you know the origin that
you're making that request from so
that's something you can't really see
that the API call itself hasn't been
changed but you know that you just have
to know different origins are now
possible so if this server that you're
talking to actually supports that
communication if it supports your origin
in an access control policy now binary
data is also supported you can have
either blobs or typed arrays this is
really good for if you want to upload
let's say files or there's a new file
API that you can start using you can
make an xhr get or post and you can
start working with binary data for you
know like audio and things like we
talked about in the last event so that's
another thing you can do there's a nice
little demo see here
right
that Eric bidelman put together so yeah
like this is basically using well
actually see
I just uploading a PDF and there so it
did the binary support a binary post it
also did a progress tracking using a
progress element so quite a few things
at once at play there but really the
main thing here is that that this is a
much better standard for cross domain
communication than the variety of hacks
that have been used in the past and so
this is supportive pretty well like I
mentioned in ie8 there's something so
just the as a note here Internet
Explorer was the first one that came out
with xml httprequest so then everyone
else like that idea a lot and they
followed so Internet Explorer already
has had XD are the cross domain request
which is not exactly the same it doesn't
have the same support according to the
spec but it does the cross domain part
really well and many times if that's
what you need you can you know fall back
if you will to that so that's a good way
to do that okay you do also need some
server support so on the server side
this is not really hard but I can give
you an example of it
okay so
alright so that this is a night if
you're familiar with Python there's a
simple HTTP server so Python house the
simple a secures are basically a web
server in Python and in about 30 see 39
or 37 lines of code it's been extended
to be a core server how to do it well
it's just all that needs to do is
understand the origin header coming in
and advertise the right access control
allow headers it basically needs to have
a course implementation on the server is
it very easy you can do this and you can
set this up again one of the things
that's going out is out there in the
wild is that it would want to warn you
about and some examples have this is
where the default policy as you can see
here let make it a little bit bigger
right I'm saying access control allow
origin and I've put in a particular
origin that's something I have running
on my machine but many people will put
the default to be star and again that's
not a good idea just like the the cross
document messaging just by opening it up
wide the best possible way you can do
this is to start with a default deny
policy and then open it up slowly that's
quite important and there's tons of
examples out there on the web that dude
is just by like quick prototype with a
star I'm sure some of that will have
made it already into production which
would be which is a real shame
but yeah so in essence is not very hard
to build a course compliant server and
an Apache there are some boilerplate
project has a couple of good sections in
the documentation where you can take
basically the Apache configuration and
extended okay so on talk about web
socket web sockets if you want to build
an application let's say a financial
trading application or social networking
application or there any one of these
application gaming system monitoring
anything but sort of a real-time
component but also what you can tell
here is sort of a bi-directional
component so web sockets really good
because it opens a socket where
bi-directional full-duplex communication
can take place so it's not just one way
server side push but bi-directional
traffic and there were many approaches
that were used in the past that you've
probably heard about the comet and
reverse Ajax are some of those those
were pretty clever hacks on top of HTTP
letting HTTP do what socket connection
would do but with some pretty
fundamental problems and the reason for
that is that it was all based on HTTP
HTTP sits on top of TCP and it basically
trims it down to a half duplex
connection half duplex meaning you can
only speak in one direction at a time to
think of it like a walkie-talkie where I
press a button I hold open the channel I
speak now I'll have to let it go and
they can talk back to me all right so
take a look at this example I'm sure
you've used this use this every day
right you go to Google you type in a few
letters and actually what's happening is
so just to take a step back here the
original idea like the original idea
about HTTP there's nothing wrong
fundamentally with HTTP for what the web
was designed for
you know 20-plus years ago and so to
retrieve an object you send some headers
to the server you say what you want you
get that object done and that's the
static web that's how the web was
designed but now with Ajax calls left
and right and then very dynamic websites
and constant updates you have to
constantly get new data into your page
or either refresh the page or get
partial refresh now just just take a
look at this very simple example is an
AJAX call that's going out to the server
with the letters that you've typed so I
very quickly type in html5 it takes that
it sends it to the google search server
comes back and just that xml httprequest
that that sort of post or you know get
some data from the server resulted in a
1500 round about 1500 characters being
sent to the server and coming back so
about I don't know a thousand going to
the server and 500 coming back just that
one HTTP request because it's still
using HTTP as a foundation and the
equivalent would be something like this
let's say I wanted to talk to you
there's actually pretty cool library not
sure how well this will be done all
right so make it a little bit louder
when it comes html5 evil okay this is
what I want to tell you right instead
you're talking to the server HTTP /
levels were both html5 please calm user
agent Phil / hypoxia or Macintosh
observe text HTML accept land with ever
met accept-encoding TV deflated
connection keep-alive code a lot more
days cache-control max is equal to zero
hello there exactly right so the problem
with all of that overhead is if you need
to get a big file a large HTML document
or PDF frame whatever doesn't matter did
you have some overhead it's minimal
compared to the size of what you're
downloading instead in most applications
today it's not the main page that were
so worried about it is what's happening
inside the page all of the Ajax requests
all of the things that are happening
that's where you start running into some
problems right so for example from the
client to the server a typical request
can be anywhere from anywhere from 500
to 2500 characters of overhead of extra
HTTP overhead unnecessary network
traffic from the server to the client
there's it's usually a little bit less
right so the ratio is usually heavily in
the on the on the request now there's no
exact number on this right there's no
like it's so many bytes it depends on
how the server is configured your
cookies and all of that and if you
really want to tune this that's an area
where you can do some quite a bit of
good work you can do a cookie less
domain and all of those crazy things but
you can trim it down but you can't trim
it down that much and if you think about
what it actually means if you make a
request and you get a response the
request is actually
upload and in most people's cases the
upload versus download ratio is in the
neighborhood of like 4 to 1 so you have
the most traffic on the slowest possible
connection so you start making a lot of
those requests that's I mean that's why
a lot of the performance tuning classes
always teach you know like minimize the
number of requests and so on so there's
just no way around it though if you have
to do that to get your real-time data
and that's where WebSocket comes in so
it's a new a completely new protocol so
it's no longer HTTP it starts out as
you'll see later as an eight with an
HTTP handshake and but it's also so it's
a new protocol but it's also an API at
javascript api so there's the w3c api
that will take a look at first and then
there's the protocol that that's what
happens under the covers you don't as a
developer you don't have to worry about
that too much a nice thing about it is
actually sharing the same port with HTTP
and HTTPS and there are new schemes for
this protocol WS and WS s we talked
about steam host port this is where that
comes in again and it gives you a full
duplex socket connection to a back-end
server that's actually one of the first
lines in the specification that's
important it allows browsers to talk to
a remote host and I'll come back to that
in a little bit now the API is actually
as I mentioned earlier pretty simple you
create a new web socket and you do that
you create this new web socket object
and you pass in the ws based URL so this
is not an HTTP replacement you still
have an HTTP based page and you request
the page the page in JavaScript makes a
connection to a WebSocket server all
right so it's a part of the page that's
communicating opening up that socket for
direct connection and then it's an
asynchronous programming paradigm where
you add these listeners
all of the events that can happen open
closed and so on but the first the most
important one is that one the on message
on message is when you receive a message
so so far that's one way of traffic
right you you receive messages you can
receive lots of messages very quickly
but that's only one half of it the other
half is you at at will can start sending
messages so you can send and receive at
the same time something that is not
possible with HTTP because of its half
duplex nature so you can check support
in your browser for this you can do that
I recommend using fabrics modernizer but
you can also check window WebSocket
that's actually fairly straightforward
but typically these things are better
done with a whole team of developers
working for you so window dot WebSocket
will tell you then alright so a little
bit of actually let me just jump in here
a second and give you a quick little
demo all right so just a step step
through that a little bit in the code
here all right so here's my very simple
page have some script in it and here
this is a very basic example so you
check if WebSocket of support it now in
Firefox up until recently and I think
it's the production version of Firefox
still has this you have to check for
ma's WebSocket so it's prefixed and I
believe version 12 or 13 will remove
this prefix and we'll be in production
then but it's not yet so you want to
check WebSocket most browsers have
implemented this as WebSocket unpressed
maza WebSocket then the next step is you
let me make it a little bit bigger
you can create a web socket then it's
handy to wrap that in that maas web
socket as well like I did here and at
that point I add the listener so with a
few lines of code I you know flush out
all the listeners and I have a send
websockets end with an input message so
if I look at that here this is my page
simple page when I open it I connect so
I'm now connected to a WebSocket server
that have hosted somewhere on the cloud
and now i can simply use the well of
course i can try to use the speech input
but there was a problem always something
and here so this is a pretty standard
like it's an echo server that basically
echoes back messages to me now that's
that's the basic yes yeah you know thank
you yeah so how is this different from
HX well in ajax i would be able to take
the input send it to the server and a
server let's say i did the same exact
thing it would echo it back to me so the
biggest difference there is sheer
overhead right i make a connection I've
established the persistent connection to
that server now I sent this message and
i'm going to show you that in a little
bit i'm only wrapping that message that
protocol is only wrapping that message
in two to six bytes if you do it in ajax
you're going to be sending 1500 bytes
back and forth over the network now
that's the may be fine in something like
this this is kind of like a chat idea
right where other people could connect
to this and we could the echo servers
would distribute it to everyone so the
problem there is as soon as they're
doing a lot of messaging that becomes a
lot of overhead on your server if you
start having real time data then you're
basically constantly making a pole right
here you're not actually
sending the data when it comes in
because you've timed your Ajax call on
some sort of timer there are many
systems where that called long polling
or hanging get pending post so there's
many problems there because you don't
have you don't have messages as it
happens or more latency and a lot more
overheads I'll talk about that in a
little bit right right yes now this is
this would be over TCP so it's reusing
actually the same underlying TCP
connection and I'll come and come back
to that I'm going to have more on that
in a little bit right okay so give you a
little bit more an exciting demo this
was not so exciting Peter get away
nope right so when so what I've done
before so I'm connecting to a server
right so I make a WebSocket connection
now have persistent connection open and
I can send messages and the server can
send them back now what if I connected
to that with a mobile device which has a
possibility to detect the device
orientation right and take that data
from that regular API call to get that
data or like geolocation or anything
like that and take that data and
actually send it to that WebSocket
server to do something so in this case
we've taken an existing 3d WebGL canvas
and well I can control it I think no
that's fine I can control it with the
mouse right that's from this browser but
actually what's much more interesting as
peter is now controlling this with his
iphone over the 3g network and so it's
it's it's sending the device orientation
details over we're using a like a
messaging API on top of web socket in
this case but we'll come back to that a
little bit later but we're basically
sending that data it could be just Jason
over WebSocket right it doesn't have to
be very much it's sending it to a server
that can then control this car so we're
communicating I don't know how many hops
but this is pretty respond to this is 3g
even yeah just a few things to add you
go to demo
Oh anything it's that on phone all I'm
doing is honoring around a lot so these
sensitive from my browser the phone our
thanks to the left a cupcake way and
that that gateway cannot sit back to the
desktop so this is not something that
you know you go to a different page yeah
so well basically if you go to the demo
peso the demo so you open a demo on one
browser and then you then on the bottom
of the screen it will tell you the pass
code to enter from that other URL so
tell you a URL to go to so you can try
this on later and i'll i'll point out
the URL for okay no no it'll work
anything right yeah it doesn't matter
right it's actually on an East Coast
server so for for what is worth right
okay so a little bit of history the
original idea behind the specification
it was added to this html5
communications section believe in
2007-2008 i believe and it was out of
this tcp connection it was Ian Hickson's
idea to control a model train from a
browser he was starting to think about
that today why don't we just have a TCP
connection so I can run a train protocol
in a browser that was sort of one of the
ideas that that that sparked this that
was behind it and then very soon that
companies like cussing and other people
started contributing to the
specification actually here's a picture
of the white board at the causing office
where we pitched the name WebSocket the
net that seemed to stick so that was a
pretty cool little picture there and it
went through many iterations of that
same protocol so it actually started out
with a one in one working group
and went through 76 iterations there but
only 75 and 76 were ever in production
browser so they the first browser was
chrome late 2009 and was added to Safari
and then it changed working group so it
started again at zero so 76 equals 0 and
then it certainly started working again
on new features and the most important
one there wasn't up that's the part that
was saying now we're a we have an
official RFC since December so that's
great but also it's added a lot of new
features like binary support there was
at a certain point a vulnerability that
existed in flash and java sockets they
try it out to see if they could do that
in WebSocket they figured yes they that
is possible so let's stop shipping these
older versions of the protocol let's fix
that and a good example of how html5 how
is a community with a lot of momentum
behind it things can really happen was
that in about six months time the entire
protocol was updated and secure so that
that same what they call the proxy
poisoning attack I can go into that
offline is not there anymore in the
current versions of WebSocket but it's
still there in flash and java so good
reason to to move forward with html5 now
when you make that connection under the
covers and you don't have to worry too
much about this but under the covers the
WebSocket handshake is an HTTP handshake
this is kind of important when sting
things start breaking you'll see later
why that might happen and what the way
around that is so if you make a
connection you actually send your
browser sent some HTTP headers to the
server it asks for an upgrade to web
socket and then the server responds and
says ok upgrade 101 switching protocols
now it strips off the HTTP part and it
continues on using web socket on the
same underlying TCP connection that's
important so it's not opening a separate
connection it's using port 80 and 443 so
you don't actually
that gets sort of piggybacking in a way
on existing infrastructure which is kind
of important then you start sending
messages or receiving them well I
mentioned earlier how these these were
very minimal overhead messages there's
only a few bites there's two bites from
the server to the client about six by
it's going with this masking to avoid
that proxy poisoning attack is only a
few bites around each message and that's
the powerful thing that's what really
sets it apart from Ajax now if you
compare and this is right following up
with that exam example the Ajax calls
when you start doing that and you start
doing a hundred thousand message or a
hundred thousand connected clients all
polling the same site right and it all
sent a thousand bytes of header traffic
pretty soon your servers are going to be
knocked over because it just doesn't
scale now here's a really exempt
interesting example I'll have bundled a
link here I'm not going to spend too
much time on this but there's something
for you to look at this is coming from a
company that wasn't originally very
excited about web sockets from there
early comments but eventually added it
this is part of jetty and they did some
recent benchmarking about the latency of
web socket connections versus comment
and it's pretty shocking if you look at
this the details and it's I know it's
hard to see even here it's hard to see
but if you go to that URL you'll see all
the details this on the left side is
comet the Ajax calls right and this is
measured in milliseconds of latency with
the band's being a hundred milliseconds
at a time the top here is 50,000
connections and up until about 20,000
connections is doing pretty well polling
the server it gets really it spikes up
to in like this seven hundred
milliseconds for it's a kind of round
trip with that many connections with
50,000 on the right side is WebSocket
and what's interesting is they've added
another band this is 200,000 connections
that bands
r 1 milli seconds each so it's a hundred
times less per line here so this entire
thing doesn't you can't even see it on
the comet scale right so it's that much
of a difference this is a fairly recent
study that was done pretty interesting
benchmark and if you're interested just
take a look at our can talk to you more
about it later and the browser support
is good there are many browsers that
support it I 10 is actually i would say
out of old the company's adding
WebSocket support microsoft is on
fantastic job they're putting it in the
browser the IAS server the basically the
whole windows core foundation libraries
are going to have just three ways of
connecting in general tcp UDP and web
sockets so it's really moving forward in
a huge way there's also a lot of
emulation projects out there the causing
WebSocket gateway has a full emulation
in javascript all the way back to ie6
there are some some plug-in based
architectures like the WebSocket jess is
a flash-based emulation that may be okay
it gets a little problematic when you
start doing flash secure web socket over
flash because flash then requires you to
have a policy file hosted on some other
port one of the big benefits here was
that you can connect with a WebSocket
over port 80 this is actually very very
powerful concept if you think about what
may be typically blocked in corporate
environments the port's that you might
want to have open they are not going to
be open and now with WebSocket you can
just come right out right so 80 and 443
are the default ports so there are a
whole bunch of web sockets projects and
servers and client libraries I've just
this is just a list is not even the
complete list I'm sure just an idea of
different servers that are out there and
different and these range from robust
servers to you know prototypes but you
can see I mean this is really hitting
the mainstream in
big way once you have the website once
you have that communication pipe open
this is where it gets interesting right
you you can start doing something with
that this is I think what is really
meant to be done and if you look at the
the protocol the way it's been designed
is that you can already start adding
protocols on top of that so typically
with TCP you would do the same thing you
you don't you speak a certain protocol
like XMPP or jabber two and back end
that that's or a messaging a messaging
protocol having that same socket at that
same WebSocket now allows you to do the
same thing that a desktop application
could do for many many years already and
now you have that same power you can use
different libraries for example there's
many already many open-source projects
like stomp over WebSocket XMPP over
WebSocket JMS style java messaging
service like you know protocol libraries
you can basically plug in and you speak
the higher level protocol similarly you
wouldn't probably write a pure canvas
game with you know move to and line to
and stroke you probably want to use a
higher level library if you're building
a game you're not going to go at that
debt load close to the metal and that's
precisely what what is starting to
happen on the WebSocket front there's a
lot of these different libraries out
there that you can start using so right
now the real world has a lot of brings
in a couple of interesting things and
intermediaries I would say actually boil
it down to just one which is proxy
servers and to get around that problem
and I'll show you why that's a problem
in a minute the typical best practices
to use web sockets secure now the first
thing is the the dreaded proxy servers
and these are not the proxy servers that
you may have configured in your browser
those are what we call explicit proxy
servers you configure your browser your
browser effectively when it makes a
connect
so issues a connect header to the server
and side hit proxy server I know you're
there past me to the real endpoint and
many corporations have firewalls and and
proxy servers that are a central choke
point and for caching reasons and so on
now the real problem is what are called
transparent proxy servers transparent
proxy servers are there you don't know
about them but they mess with the header
traffic if you paid close attention that
you know that part of the headers to
upgrade to WebSocket this is an HTTP
header that's added well surprise the
proxy server specification actually says
strip that off don't pass that on to the
endpoint well you can kind of figure out
what happens then right so I connect
through the proxy server that I'm not
even aware of proxy server strips off a
bunch of headers and it passed on to the
server but it doesn't know I want the
WebSocket connection now a lot of proxy
servers out there are illegally
quote-unquote configured to not strip
anything off but they're still expecting
HTTP traffic so as soon as you have
upgraded to web socket and you start
sending WebSocket frames it's going to
probably choke on that so Google did a
lot of research on this and only about I
think sixty-five percent of regular
unencrypted web socket connections make
it right so that's not very good so what
is the answer well use WebSocket secure
web sockets secure you have to kind of
think of it as it's not a different
protocol similar to https being HTTP
inside of an encrypted tunnel TLS stands
for transport layer security also known
as SSL once you have that certificate
based end-to-end encrypted tunnel you
can still start sending your HTTP
headers over it like the the initial
handshake can succeed because the proxy
server can't inspect can't look into
that that's quite important and so using
WebSockets
here is the answer for most and I think
they got the same connectivity with up
to over ninety-five percent in real life
when you use HTTPS there are obviously
some cases where if you can't get there
an HTTP s you're probably not going to
get there with WSS it's not magic but it
it follows in a way that's sort of a you
could say well that's that's kind of
cheap you know it's piggybacking on
existing behavior but it does mean that
you can actually deploy these things
today and you don't have to wait for the
entire world to upgrade their servers or
use different ports and open all kinds
of other things so there's pros and cons
to that but that is for better or worse
how you can get mass adoption quickly so
what this really allows us is to change
traditional architectures that are like
application server based where an
application server is building the UI
and is giving you a page there's simply
just the something that's built on the
server may be some sort of application
server that is creating a whole bunch of
things on the server side and then
pushing it out to the client I've sort
of a an end result of what's done on the
server you now can change that to a more
dynamic web socket architecture where
you use any device any browser that is
now a much smarter client like a lot of
the logic not all of the logic but a lot
of the client side you can use all the
html5 features to build an application
that is as powerful as a desktop
application and basically you can do
that with having web socket connectivity
directly into these backends and again
this is this works well with the Korres
model that we talked about earlier where
you can make connections that can allow
certain origins from other origin so
it's not replacing HTTP as the way to
get the page to the browser but once
that page is there it can make
many different connections using web
sockets and have dynamic data one of the
big advantages over Ajax's do not have
you don't have to re-advertise all of
your data every time because you have a
persistent connection and you can have
asynchronous messaging in these
applications so chat gaming bedding all
of that it makes perfect sense to use
web sockets for okay so one quick aside
here the server sent events is another
API that you can use for it's basically
a standardization of half of a web
socket it's a one-way stream from the
server to the client and what's
interesting about that is it does
support a few things like you you could
say well I could just write a small
wrapper in web socket to do that because
web socket has bi-directional
communication low overhead server sent
events has automatic reconnection event
IDs in the case you lose the connection
that you can pick up where you left off
very good for broadcast good could be a
good way to take for example news feeds
and data sources that are maybe UDP
based and make make them available over
the web right so there's multicast
networks that that's it pretty well
behind a server sent events server that
basically just once the client is
connected just pushes data down to the
client and you don't talk back and it is
a little bit more overhead than
WebSocket but not much we're talking
about maybe from two to six to twenty
bytes of overhead on each message so
it's still very very low low Network
unnecessary network over the API is very
simple it's just like I said it's about
half of a web socket to create a
connection this is http-based you create
a connection then you add listeners for
open when you receive a message and
errors and that's basically there's
nothing there's no nothing to send so
there's no no other parts to the api's
again very simple standardizes a lot of
very hard work you have to do to get
streaming data into your pages a good
example would be this news feed got
example right here
and you can this is a page with lots of
different web socket then also like the
sse newsfeed where basically you just
connect to a server sent the event
server that just as they come in news
items come in and you can you can just
display them on a page that takes just a
few lines of code to write them okay so
this is supported in not not as many
browsers actually the kind of surprising
right that's in a way a simpler feature
but not as many browsers have picked it
up as as WebSocket but the good news is
in web socket is pretty easy to write a
rapper that will do SSE for you so you
could use web socket to do it but then
again you may as well use all of it okay
and the final part I wanted to talk
about this speedy now this is not an
html5 feature and I'm not trying to kind
of combine it but I think it's
interesting because there's been a lot
of movement on speedy and it's pretty
closely related if you look at it so
speedy is actually not an acronym it's
the sort of a play on words like they
they wanted to speed the web up and do
that in a large part as you'll see later
through compression so they took the to
ease out speedy and that was the how did
I came up with that the original name
for it was flip so you may see some of
that in the documentation so this is a
new protocol and it's not an HTTP
replacement but it it enhances HTTP so
you it's basically an effort to make the
web faster we already saw a lot of the
problems that lead to things slowing
down and slow page loads like if it
normal pages 30 to 40 assets images and
CSS and JavaScript they all need to be
downloaded right and there's many issues
that come into play for example you can
only make so many connections to one
origin at one time and so there's the
connection count and all these other
things that
that slowed things down and HTTP as
we've seen is not perfect but once you
start doing some of the things that
they've done on top of it you can really
make a pretty dramatic improvement in
fact you can use web socket over speedy
so it's like I said it's not really an
HTTP replacement but it is more along
those lines with the way you can best
picture it is it always runs over TLS
right the ssl connection so you you have
the same basic infrastructure except
you're in a in another layer speedy
protocol layer that encapsulate sat HTTP
but also compresses HTTP using data
dictionaries because you could see a lot
of the headers that you're sending that
you that I showed you in a couple of
cases already there's a lot of
similarities right there's a lot of
stuff that can be shrunk down and they
were able to compress 85 eighty-eight
percent remember what I mentioned how
the upload usually as the majority of
the bytes this is a problem right for
that your page load time will be a lot
better if you can have avoid sending
that much data now of course that does
set up an encrypted tunnel so that's not
free either but the general feeling
right now is that that's where things
are heading anyway not a little bit more
on that later so it it does other things
too so it uses what is called NPN or
next protocol negotiation to very
quickly it doesn't use the upgrade that
WebSocket uses but it uses a basically
it tells with the initial request say
hey I want to speak speedy over SSL so
it sets that up in one shot and that
saves another round trip time which is
expensive it allows you also to do some
server push so there's a bunch of
extension and experiments that are being
worked on still multiplexing is the big
thing because you can multiplex the same
connection and get many many resources
over that same connection you're
basically creating a tunnel and you
you want to get as many as you can and
what's nice about that is a lot of
things we're doing today to improve
performance things like using data URIs
for images they really don't need that
as much anymore using speedy because
it's already all compressed you have the
same there's not that additional
overhead making 90 connections for all
of your images it's all already
multiplexed and you can use a lot of
that in that way so some of those things
will start shifting so there is
something called HTTP pipelining is not
really the same it's definitely not very
standard and many browsers don't have
that well no browser that I know of has
it turned on by default so in reality
that's been difficult to put out there
and so right now you have basically at
that TCP connection a lot of the things
are multiplexed over and at that point
some of the things like the subdomains
for spreading the number of concurrent
connections become less of an issue but
of course are not a problem now you
might say well isn't that a lot of
overhead to create that ssl connection
first and it's actually less than then
was expected so there was an extensive
research done again at Google this is a
by the way a google project that is
being proposed as an official standard
so it's an open standard they're open
sourcing everything but it was developed
by google too and it's already deployed
if you're using google today I sorry if
you're using Chrome then in ninety five
percent of the cases you're actually
using speedy when you connect to Google
backends I'll show you that in a second
so there are some some big advantages to
that one you don't want to send any data
unencrypted that is sensitive of course
also it wasn't like with today's
processors and so on it's not nearly as
bad as people had expected it to be and
in some cases with the next protocol
negotiation it can actually speed things
up also one of the things is again the
same
idea that was behind what I was just
talking about the websocket it's sort of
piggybacking on existing web
architecture and you know this roberto p
on the other nights i have a link to his
presentation at the end he said it
pretty well we want to have some chance
of getting this protocol out in our
lifetime right because it you want to
use existing web architecture you don't
want to have to say well okay to do this
you need to set up new servers open new
ports and all of that that's just not
going to happen very quickly so this is
one of the reasons besides the fact that
there is a general trend if you've ever
been in a you know internet cafe and
you've used firesheep it's pretty scary
you want to definitely use HTTPS or WSS
in many cases so speedy by the way is
not a new scheme it still has that
initial HTTP handler gets you would
never see the speedy URL it's always
starts out at ATP and then it just
upgrades that creates that tunnel for
you right so if you use chrome
ninety-five percent of the time at
startup it's randomized and because they
want to do a test to compare it with
people are not using speedy the results
are pretty pretty impressive already
there's also a WebSocket / speedy that
you can turn on right now in the low
level settings and if you go to Chrome
colon slash light net internals there's
a whole page and you can look you
probably have this already you have
multiple speedy connections one of the
nice things about speedy it doesn't
require anything on the client side to
it's just a drop in thing if your server
you have to have a server that supports
it but once you do there's nothing else
that the client needs to do to make any
API calls or anything like that Firefox
now supports it as well since version 11
it will be the deep on by default in
version 13 you can turn it on right now
and already experiment it it's a
noticeable difference if you're using
gmail or something like that it's
definitely something you can really you
can really tell I have like my personal
gmail and in my work is also on
email so I used like opera or Firefox in
the past for my personal mail and it's
like it's so slow all right questions so
the question was what's the support on
mobile devices there are two really good
white websites can i use you just type
in a couple of letters web sockets need
another one okay there we go so that
tells you the support on different
mobile browsers it's not as good as it
could be well it is on Safari well okay
so okay the light green there is
actually an older version of the
protocol so that's version 75 76 that
our previous versions that are supported
says it like what what Peter was showing
us it actually working on the iphone
surprisingly so it has just recently
landed in chrome on Android including
the binary support but yeah so that
those are the support so in many cases
you will need some sort of fall back
system to make sure that it works and
goes through everything so when can you
use it in production where where's the
spec at so one of the slides they had in
there was showing the history of it and
since December last year it's an
official RFC everything sort of the API
is in candidate recommendation so it's
it's done now it's a matter of time that
browsers catch up so that they have the
latest version that's happening pretty
quickly firefox and chrome already do
fire safari for example needs to update
to the latest version and then of course
on the server side servers need to
implement it so it's a little period
right now some stabilization i think a
couple months and then we'll see you
know that is pretty much final yeah that
was pretty good ya know so the question
was will you get a speed difference or
an increase in speed if you use another
port so the default ports are 8443 if
you could use another port I don't think
the port of anything to do with it so
you wouldn't as far as I know you don't
get any
provement what why do you think you
would okay right yeah I mean if there's
other congestion on that same then yeah
i mean but it but there's no nothing
specifically to pour it right now there
was a question there or come back yes
this is a question was what happens when
you have this long lasting connection
maybe Im rephrasing it but tell me if
i'm wrong and what happened like how
does it think it's a persistent
connection when does it close that's
mostly up that's mostly a server
implementation so there can be some some
configuration on the server that's a
terrible but it is kind of meant to be a
long-lasting persistent connection so
it's not timing out after nine seconds
necessarily but then also a lot of
things and this is specifically left up
to the higher level protocols to
implement because some protocols may
have some something to do there others
don't there was a lot of work put into
making it really as close to like tcp as
possible just not implementing any
protocol specific features because they
might not work for all protocols so
that's it's a server implementation
right if i understood you correctly it
was about the reconnect automatically
get so automatic reconnect is not part
of WebSocket there's actually i think
wanessa send me a link to it just a
couple of weeks ago somebody has
implemented and automatically
reconnecting WebSocket because that's
something you would think you would want
to do but again websocket doesn't want
to get in the middle of defining what a
protocol shooter shouldn't do so in some
cases it's fine to just disconnect and
leave it disconnected so it's pretty
easy because you can listen for errors
and close events and based on that you
can very quickly reconnect and then
based on that actually a lot of higher
level protocols are implementing
failover systems like it causing we've
done a pretty interesting thing with a
load balancing we call peer load
balancing so we set up a low
balancer that you go to basically just
to get an address to a server that you
want to connect to directly once you
have that and you disconnect it detects
all of that and then it reconnects again
to where it started like a tree connects
to the load balancer it says oh you go
to know to done right so it's it's sort
of the load balancer getting out of the
way of that direct traffic but that's
probably more than you wanted to know so
a lot of different programming languages
have their own socket frameworks so for
example Python has a twisted socket
framework what what you're looking at
here is you're moving away from connect
like request response so you have a lot
of sockets open so you need a different
architecture on the server to handle
lots like for example if you assigned a
thread to every connection then very
soon you would be out of business so you
need a socket framework a modern socket
framework so Java has java niÃ±o python
has twisted some node has what is called
socket i/o and socket i/o is basically
that same framework you're looking at so
if every one of those and the nice thing
about socket i/o is like I mean you
would not think that node which is
basically running JavaScript on the
server would be could be as fast and it
can't be as fast as things like Java and
C++ it will never be that but it's
actually pretty amazing how much they've
gotten out of that and already sort of
as far as I know already faster than
Python which is compiled so pretty
pretty interesting and if you have so
first of all it's like what are you most
familiar with language wise and then you
grab one of the servers like nodejs
cousin has a complete developer bundle
ready that you can just play around with
see how how it works in action there's
like I mentioned on that slide there's
about 25
different server project if you want one
in Python it's out there Apache has a
module that you can plug in to do the
WebSocket support jetty having dates the
list goes on alright so thank you and
now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>