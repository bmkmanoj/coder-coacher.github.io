<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Different.js | Coder Coacher - Coaching Coders</title><meta content="Different.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Different.js</b></h2><h5 class="post__date">2014-09-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n9qzwI4Krmo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is not about a new cutting-edge
framework called
you can leave if that's what you're
expecting I want to talk about how we
get better at things over time and I
think some of us maybe have this
perception that this is kind of how it
works you kind of you start learning
something you practice it practice makes
perfect over time you get better and
better kind of at a steady rate I don't
think that's actually how it works I
think it's more like this so you start
learning something so you start learning
node or jQuery or whatever and you have
this like initial like super rush of
information right like every 10 minutes
you're kind of WTF thing and learning
things and and like upping your game
really quickly and then over time you
start getting more comfortable you start
getting familiar and your rate of
productivity probably increases your
rate of learning probably decreases and
at some point you kind of start
plateauing you're not really learning
much and then something happens and kind
of kicks you out of your rut and you
start learning again you start trying
out some new library or you read some
awesome blog posts that kind of exploded
your brain a little bit or you went to
an awesome conference talk that kind of
thing and but then again you start
plateauing and then kind of rinse and
repeat right this this process happens
over and over again this is definitely
resonates with me is how I feel like I
learn I I plateau and then I something
kicks me out of my of my rut and I start
learning again so this is kind of
leveling up right this is I think in my
mind this is where this this fits with
that kind of concept of like ending
leveling up to the next level
so I want to get better at stuff over
time I'm sure all you guys do how do we
get better at stuff how do we get better
at getting better at stuff over time I
say that one way of doing that is to
look for more opportunities to kick
yourself out of a rut and level up so
this talk is is going to be about how to
kick yourself out of that rut more often
so a really common way of doing this one
that's kind of pretty well known is like
Oh learn a new language you know you
should be learning a new programming
language every year and I think it's
definitely true right if you're a
JavaScript programmer day to day and you
go
learn program or like play with Haskell
for a couple of days or whatever I think
this is a great way of kicking you out
of your rut because it by going
somewhere else when you look back at
where you were it looks different you
get again you you you gain a new
perspective of the thing that you were
standing next to the day before another
kind of analogy maybe as you kind of you
stretch your brain a little bit like a
rubber band when you let go it's it
snaps back but it doesn't snap back all
the way so you're kind of your brain has
expanded a little bit so you take the
things that you learn over here and you
can now apply them in your day to day
job so I think that's very true I
definitely recommend learning more
programming languages but I want to talk
a little bit about how I think we can
find opportunities manufacture
opportunities to level up as JavaScript
developers without leaving JavaScript
for all its warts it's a pretty cool
language and it's what we use day-to-day
so how do we level up without leaving
JavaScript they're going to talk more
about that talked about kind of
introducing artificial constraints so
even though we don't have to do
something a certain way let's try doing
it so a certain way anyway
to try and kind of form more of these
opportunities to to level up my name is
Pete like I said I mean are we going
really fast so if if you want to argue
with me about this later I'm on Twitter
ph1 that's my cell phone number
moving on and also if you wanna talk to
me about footworks obligatory plug we're
hiring so I want to talk about the this
keyword this is how I feel about this
quite often I feel like this about this
because of things like this so if things
like this make me a little bit
embarrassed to be a JavaScript developer
and a little bit sad inside so we're
taking out this and then we have to
rebind it to self because inside of the
context of the button plain blur of
course this is bound to something else
makes perfect sense right
we all have Stockholm Syndrome if we
think that this is okay
so so yeah I I really really actually
have kind of a love-hate relationship
more of a hate relationship with this
and maybe you guys find it less annoying
and frustrating than I do but I think we
can all agree it's not a perfect feature
of the language the confusion around
lexical scoping and binding rules is a
little bit of odds with the rest of the
language and so given that fact it's not
perfect and given the fact that we're
looking to artificially kind of
introduce opportunities to level up
let's try writing JavaScript without
this this might not be something we want
to do in production code maybe it is but
it will give us an opportunity to look
at just what we do today in a different
light so wonderful about this and
getting rid of this in order to talk
about this when you talk about wise used
talk about why it's used when you talk
about oo to talk about our
object-oriented programming we need some
kind of definition this is my working
definition oo is about kind of state and
behavior traveling together through time
sounds pretty impressive right so what
do I mean by that here's George George
has two abilities he can eat cake this
person type can eat cake and we can ask
it if it's still hungry so that's our
API and this is how our API kind of
works in in the world we we create an
instance of George and then our program
runs and at some point later on George
eats a cake
and then some point later on in the
program we asked George if he's still
hungry
so pretty standard stuff but what's I
think implied here but maybe we've
internalized so much that we've
forgotten about it is like these are all
kind of joined together in time even
though they're all joined together even
though they're there at distinct points
in time and so that's what I mean when I
say state and behavior so when when
George eats cake up there
he's modifying his state and then that
behavior that I called are still hungry
behavior that function method I call
knows about the state so the state and
the behavior traveling together in this
object so this is kind of a classical
approach typical way of implementing
this API or this interface in in
JavaScript we in our constructor we
create a property set up to zero we eat
some cake and bump up that property and
then when we want to know if we're still
hungry we check the value of that of
that property on the object pretty
straightforward
lots of uses of this and I remember our
goal here is to get rid of this at least
with the context of learning stretching
our brains so how could we do this a
different way so here's a implementation
will work almost exactly the same but
it's not using this and it's not using
prototypes it's using closures instead
so again have a kind of a constructor
function type thing that creates object
literals in this case and I have a
closed over cakes eaten variable and
when I want to eat a cake I bump that
variable up and when I want to check if
I'm hungry I look at the state at that
variable so in the previous example what
was binding things together through
space and time was was was this and
prototypes in this case closures what
you used to kind of bind the behavior of
still hungry with the state of cakes
eaten and and the behavior of each cake
so that's how that's how we're achieving
the same the same goals but through a
different means so I it's not really
relevant to the talk this whole thing is
space in time but I didn't really ever
realized this until I tried to do it a
different way and I kind of had this
weird insight about ro through trying to
use use JavaScript we've this artificial
constraint so this is this is what I'm
getting out of kind of expanding our
minds a little bit and leveling up you
know even if we're not necessarily using
it in a standard way I'm going to take a
slight detour to rail against this
here's George we want George to eat a
lot of cake so we're going to take these
four cakes and we're going to pass them
into George's eat cake method of course
after we've done this George George
shouldn't still be hungry because that's
for cakes that's a lot of cake but no
still hungry we'll return true if we ask
George how many cakes he's eaten it will
say zero how many of you or can someone
tell me why this is doesn't work
the way we want it to yes yeah so of
course we didn't bind this to the right
thing in in the for each loop so how
many this is a is a mean question to us
but how many people understand that
right so a lot of us do not all of us do
I don't think we should have to
understand that this this is why I don't
like this as an aside if we use the
closure based approach it just works
I don't need to understand binding and
lexical scoping and all that stuff it
just works the way I'd expect it to work
so I could go on you can implement
pretty much everything that you do with
prototypes and this using closures
inheritance and mix-ins there's a few
warts as a few things that you can't do
there's a few things that are better
like you're not exposing your privates
ask me later
so what's but what have we what have we
learnt we've we've learnt that I guess
we've learnt two things I've we've
learned that this is annoying
or at least I already knew that um but
we've also kind of started thinking
about things in a different way so if we
don't need prototypes and we don't need
this do we actually need types there
isn't really a type there it's just
object literals and the object literals
happen to have methods on them but do we
need those methods maybe we could start
just calling functions and passing State
around not attached to behavior so this
comes down to two tools by looking at
things a different way I now have a new
tool in my toolbox before whenever
someone asked me to solve a problem I
would reach for prototypes and this
because that was the tool I had
available to me when you have a hammer
everything looks like a nail
right now I have options I've got a new
tool in my toolbox that doesn't mean I
have to use it all the time just cuz I
learn about screwdrivers doesn't mean I
have to use a screwdriver when a nail is
the right thing to hammer is the right
thing to use but I've got the option
I've expanded my my abilities I've
leveled up as a programmer and I don't
have to use this new technique but
I've got it in my back pocket now so
this is what I mean by introducing
artificial constraints to understand
what tools are out there to understand
what you don't know that's a really
really big thing to embrace as a
programmer you're you there's loads of
stuff you don't know about and being
getting to the point that you know that
you don't know something is like 90% of
the battle because then you just need to
google it and find this Stack Overflow
answer and I really like the full stack
overflow developer idea and so what
other things can you do to level up so
here's here's kind of a random list I
came up with
there's loads of loads of things apart
from this but this is lots of stuff you
could do in JavaScript without leaving
your language to kind of stretch your
brain so try writing JavaScript where
you never return anything and I do
really mean that so this is called tell
don't ask you can do this it's kind of
mathematically proven and it will hurt
your brain a little bit I only use one
parameter and don't allow more than one
parameter don't allow functions less
than less than five lines long do
everything test test first do TDD 100
Center time don't do any test at all if
you do do tests try writing immutable
JavaScript where you're not allowed to
mutate any state and you only make
copies of things like I alluded to
earlier don't don't have methods just
just use functions and don't have
behavior and state traveling together
instead use a functional style and and
the last one plug I actually really
wanted to give like a an hour-long talk
on this is look into functional reactive
programming streams of magical
wonderfulness building your UI yeah I'd
like to do an hour on that but I think
there's lots this is not an exhaustive
list there's loads of artificial
constraints you can introduce in not
necessarily in your day-to-day
programming in production code but
though the fun side projects you do or
for the one little project you're
working on at work to stretch your brain
a little bit and do more than just
learning the next trendy framework right
like you're not going to level up as a
programmer by learning the different
well you'll level up a bit by learning
less if you know sass or vice-versa but
you're going to get a lot more if you
intentionally find constraints and apply
them to the way you work and you'll come
out of it a better programmer thanks and
I've amazed that I actually do have time
for some questions or general hiking and
so I so that's a very good question why
the question is why shouldn't we be
doing more of this kind of functional
stuff in production I absolutely think
we should but I don't want to freak
people out right like I don't like and I
don't want to sound like you know like a
dogmatic kind of zealot of functional
programming there's cases where it
doesn't make sense there's lots of
there's lots of reasons why it might not
make sense to your boss doesn't like it
your team pushes back on it you're very
very concerned about performance a lot
lots of different reasons but I actually
I actually really really think that
there's loads of stuff you can do in in
a functional style that's but it's very
very valid for production but the first
step is just to try it out and see yeah
yeah so the question is is there
performance implications to the kind of
object factory closure approach so yes
there are in in two ways and I'm gonna
be intentionally annoying it is slower
for the computer and it might be faster
for the development team I know which
one I want to optimize for so it might
be it definitely is actually slow if you
put side-by-side prototypes versus
versus closure it's slow a bit a big
reason is because the browser makers the
v8 developers are optimizing for the
code that's in the wild that's a big
that's a part of it but I don't think it
actually matters because most of the
time my one of the other the performance
one of the performance talks earlier
earlier on in in the conference was
saying if it's if it's just JavaScript
code that's not where your performance
metal my bottleneck is your performance
bottleneck is talking to the Dom waiting
on a network call waiting for a user to
interact all of that kind of stuff like
if you drew a graph of object
object-oriented versus or sorry
prototypes versus closure and then like
this is the the difference that any of
that other stuff makes so almost all the
time it doesn't matter
Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>