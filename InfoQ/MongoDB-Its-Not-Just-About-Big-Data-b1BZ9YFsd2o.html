<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>MongoDB: It's Not Just About Big Data | Coder Coacher - Coaching Coders</title><meta content="MongoDB: It's Not Just About Big Data - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>MongoDB: It's Not Just About Big Data</b></h2><h5 class="post__date">2011-09-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/b1BZ9YFsd2o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">actually this quick question just to for
my own to gauge the audience how many
people have used MongoDB or currently
using my gonna be okay great so this
won't be all new for folks so you know
as Bruno spoke about in the beginning I
think everyone would agree that the main
driving force behind no sequel and the
reason a lot of these new database
technologies came about was to solve the
big data problem the horizontal
scalability problem that relational
databases ran into it's scale but what I
wanted to talk about today even though
Mongo you know is like all those other
no sequel solutions in that it does have
a big data story that's what the Mongo
and long ago DBS for but I wanted to
convince you all today that MongoDB is a
great database even if you don't have
big data if you don't have a big data
problem so what is MongoDB MongoDB is a
scalable open source high performance
document oriented database and and
that's a mouthful but hopefully by the
time I'm done with this talk all of
those will make sense but first before I
you know talk about you know why MongoDB
is good for just any size of data I just
want to give a little background on what
MongoDB is so you can have a mental
model of what we're talking about so
first thing is the storage model MongoDB
is really not all that different at a
high level from a traditional relational
database in the sense that you've got
these things called databases inside
databases there are collections and
that's the term that represents what in
a sequel world you think of as a table
and then where is in the sequel world
you have rows in MongoDB you have what
are called documents or objects and
really documents objects are
I have an example here that I like to go
through it's a big block of JSON and so
JSON is the JavaScript object notation
it's become really popular you know
first it was you know part of the
JavaScript language it became very
popular as an API data exchange format
and you know fast forward a little bit
the document oriented databases like
MongoDB CouchDB they use JSON also as a
storage format and so this example here
is a little example of a blog post and
what you can see is an ID and everything
in MongoDB has an ID or an underscore ID
that's one of the main tenants of how
documents are stored and then here we've
represented an author as a as a nested
object so it's got a name and an email
you got the body of the of the blog post
a date a location so the reason I
included this in there is one of the
cool things about MongoDB is it
understands latitude and longitude
natively and so I'll explain a little
bit later you can do all sorts of cool
Geographic searches with Mongo you don't
have to sidecar on another technology
new your database to do geo geo search
and this here we show whoops sorry about
that so how you know if you've a blog
post you might want to store comments to
the blog post here we show an array of
nested objects each one has user up
votes down votes and one of the cool
things about MongoDB is you know let's
say you implemented your blog system and
this is what your data model looks like
when you launched and then product
manager comes rolling in and says hey
you know I I need to have tagging we
need to be able to tag these blog posts
it's a new feature well you know Mongo
doesn't enforce schema your data has
schema but Mongo doesn't enforce it so
if you need to go and add the tags field
which is an array of in this case you
know
or rear strings representing topics that
the blog post is about you can go add
that you don't have to do an update
schema which you know for those of you
who've updated big schemas and sequel
can take forever
and so this is basically the storage
model of MongoDB and it's very different
than a lot of the other no sequel
solutions it's really you know the term
optic database is not what we like to
use but it really is a database that
stores very rich objects it's not just
key value pairs where the values or
numbers or strings the values themselves
can be other objects arrays arrays of
objects and it's infinitely recursive as
deep as you want to go you can represent
data in a very rich way in MongoDB so
okay so I talked about the storage model
how do you access data in Mongo
so another thing Mongo I think borrowed
correctly from the relational world is
it has the idea of a query language and
a lot of the no sequel solutions
actually do not have a query language
you look up data by indexing it and you
look it up by ID structure in a certain
way MongoDB likes the idea of you can
query your data however you want to and
you know some examples here actually
this is really cool the query language
is also clearly there's also in JSON so
this is an example here and a lot of
post you can see you know there's an
author field and it's got a nested name
so you can say things like author name
is Mike and the next one might find all
blog posts where the weighting is
greater than 2 another cool thing is if
you notice tags wasn't just a single
value tags was an array but if you want
to find all blog posts where the tag
software appears as one of the tags you
can do that and I can tell it handles
multi indexing really well and then
things like sorting pagination or
cursors that sliding windows through
your data
Margeaux does that really well the query
language like I mentioned really
mathematically complete it's got a whole
list of predicate operators like in not
in nor not and or it supports regular
expressions in the query language so if
you want to search for Strings with a
regular expression matching search you
can do that
it also supports embedded JavaScript for
where clauses that really don't fit with
the query language so if you want to
write a little little snippet of
JavaScript that you use to troll over
every document in the collection and
return all those that match and reject
all this that don't because you know
natively its JSON the JavaScript works
really well there
it's got a group operator which I won't
go into the details but allows you to do
aggregations one big thing about MongoDB
though and I think you know this was
mentioned with Bruno no joints so well
you have a very expressive query
language one of the ways MongoDB solves
the horizontal scalability problem is by
not allowing joins and we'll talk about
why when when I talk about the
clustering and charting and then also
like the relational world no MongoDB
says ok the query language is something
we give you two very richly Express how
you want to find a subset of all your
documents in the database if those are
slow we have the concept of indexes like
in the relational world so this is an
example where if I know I'm looking up
by the author's name all the time I can
specify an index on that field and then
the queries will go quickly and so we
just quickly go back to this here you
can index on anything so you can index
not only on nested values but you can
index multi values you can index
latitude and longitude so like I
mentioned before geospatial is built-in
so we had a look feel on that sample I
gave you guys before
we can do things like look for all
points within a rectangle so bounding
box type searches searches with a
bounding circle so so one on the bottom
is a point in a radius so all things
within 10 units of the point forty forty
and it's actually cool you don't need to
just use it for geospatial indexing I
think there's one really pretty
well-known MongoDB app which is an
infinite Scrabble board or maybe not
infinite but incredibly large and it
uses the the Mongo geospatial
capabilities to represent that that
plane that all the tiles are on so in
addition to querying it's got a really
rich language for doing atomic updates
to documents so oh the question again
selects so the concept of a select is
really a sequel concept but in essence
you know a select statement is a is a
query right so so these all here these
all of these are examples of how you
query in MongoDB so instead of the
language being kind of a syntax where
it's select from where this is saying
find in the posts collection says that D
be dumb posts that's representing the
actual table the collection you're
searching in so that's all it's almost
like the from this is the where closet
and maybe this is what you're getting at
the projection part which is where you
strip out in sequel you say you know
what you might have this big object here
but I only want to see a subset I only
want to see ID and author and actually
the answer is yes it does do that I
didn't show that in the example but
there is the idea of a field mask that
you can use to yeah you know
for the wild card you would just you
just would you would not specify
constrain at all
so so for example if you want to say
what the name could be anything then you
want yes you used the regular
expressions so it's got the full regular
expression capability built-in so I
didn't use an example of regular
expressions here but instead of saying
Mike in this example I could put a
regular expression like Star Mike star
or Mike star L or anything that the
standard regular expression syntax
supports and you can do that so getting
to update operators so obviously you
know you can create these documents in
your programming language you can insert
them you can save them but you can also
atomically modify them so this is an
example where if you if you remember
back here we had a comments field that
was a list of these objects that
represented the comments I could say to
the system push I can make a new comment
this is an example I'm using JavaScript
server-side JavaScript but this could be
any programming language I make a new
comment and then I can tell
MongoDB to push this comment on to the
comments list and it will do that
atomically it'll guarantee that only
that will either all happen or it won't
happen and if there are multiple threads
trying to do the same thing they will
happen atomically each one of them and
so there's a whole bunch of atomic
operators like for example increments
another good one let's say you're
tracking votes actually in this example
we did we had one of the one of the
fields on a comment was a was a vote
field you could use the increment
operator to atomically incremented by
one versus dealing with a race condition
that you might have if you were to pull
the object out look it and say oh it's
for I want to make it five and then save
it back so it's really useful and then
there's a whole set of them so there's
unset increment push pull pull all and
so you know the whole crud story here is
really good with mug
be very very rich query language you've
got indexes for making your queries fast
you've got insert and save operations
and then you've got atomic update
operators which allow you to atomically
modify your objects and I'm not going to
go into too much detail with it here but
in addition to all the stuff I just
talked about there is an aggregation
language so I was showing you queries
that are mostly about selecting a subset
of your data there's also all sorts of
cool aggregations you can do and the two
ways you do aggregations in MongoDB are
either a with the aggregation framework
the aggregation framework and the 1x
code line is somewhat limited
functionality the two o code line coming
out really really soon one of the big
big features of it is a whole bunch more
aggregation functionality and it's
actually really cool and then there's
MapReduce so MongoDB does have a
MapReduce engine where you can specify
map functions and reduce functions and
then it runs over your data and computes
the result and it saves that in another
collection not sophisticated as Hadoop's
MapReduce system in fact people have
hooked up Hadoop to MongoDB but for
simple MapReduce style jobs it's it's
really convenient and works really well
the other thing I should say about Mongo
that really you know is a subtle point
that but shouldn't be overlooked is that
10gen has gone through the trouble of
actually creating a driver in every
programming language for job not for
tougher for MongoDB so Java JavaScript
Python Ruby whatever programming
language you use there is an officially
supported driver from the makers of the
database and I can't tell you how
convenient that is compared to a lot of
other database technologies I've used
where there's either some protocol
interface that you have to implement or
or you know you really only have one
programming language that you have to
use to be able to interface with it and
so you know I'm sure I'm sure most of
you have played around with some of
these drivers
and then the other thing about MongoDB
which you know like all the no sequel
solutions which I'll touch upon briefly
but is not the main thrust of my talk is
that it was built with reliability and
scalability from the ground up like all
the no sequel solutions I think the
horizontal scalability problem like I
mentioned before something that really
drove this whole Renaissance and
database technologies that we're seeing
now so let me talk a little bit about
the scaling and reliability in the
clustering story with Mongo and how that
all works so when you talk about MongoDB
clusters there are two main concepts
that MongoDB introduces one is the idea
of replication and replica sets replica
sets are groups of MongoDB databases and
actually if you can see right here this
this this is an example of a big sharded
cluster but I wanted to focus on the
gray box first so if you have a
deployment where you know you care about
high availability the story with Mongo
is you create a cluster with with
replicas each replica has a copy of your
data and you can put a bullet in one of
those those set members and all of your
reads and writes will failover to
another member of the cluster and
there's an interesting voting algorithm
that goes underneath the covers for the
cluster to decide who should be promoted
from a secondary to a primary so for
high availability use the replica set
feature the other reason you use the
replica set feature is this is how
MongoDB talks about read scaling so if
you have a scaling if you have a scaling
problem where it's about read throughput
what you do is is you have your driver
read evenly across all of the members of
the replica set cluster that spreads the
read load across it could be two three
five twenty nodes that's how you do read
scalability and then write scalability
is handled with sharding in the auto
sharding future
so this is where you start to partition
your data and you know folks have been
doing charting in sequel for years but
mostly manually the cool thing about
Mongo sharding is that it automatically
balances data across the charts so each
one of these vertical columns here on
this diagram represents a shard so you
can imagine a scenario where you have a
user collection that is just for
whatever reason too big to handle the
write load with one MongoDB node what
you do is you say okay you know I know
some of you know what charting is but
maybe some of you don't you say that you
know let's say users a through C or on
this chart and then users see through F
or on this shard you actually partition
the data set into a bunch of different
buckets and then each bucket consists of
a replica set because you don't want any
node in that bucket to be able to go
dark because you want to have high
availability so each shard consists of a
little cluster of replicas and then the
entire cluster is a cluster of shards
and that's how long ago DB handles you
know the most badass of scaling
situations so you know examples of folks
who really scale big with MongoDB
Foursquare is a really famous example
they've got a cluster set up like this
where they handle an enormous amount of
write throughput so you can imagine
having to handle every check-in for
every mobile device running Foursquare
on the planet that's a lot of Rights and
so they're an example where they use
charting and there are others that you
can look up online
MongoDB has a really good and public
list of all of their deployments okay
but scaling aside the main thing I want
to talk to you today everyone about
today is the fact that you know most
people don't realize that while MongoDB
you know really got popular because it
has a great story around scaling data
it's really not just about big data in
fact what I want to talk about is why
it's it's really good for for almost any
sized data set
and to do that let me bring up an
example of what we used to look at the
old world so I'm gonna continue with my
blogpost example this is an example of
how we might store that blog post that I
was talking about in a relational world
and I've abbreviated a little bit for
making the diagram simple but as you can
see we've got our main table which
represents the blog post the author
being another structured object is is
normalized out into into another table
within this example I just put a name
and email in there but then you know you
look at the comments for example and the
comments because it's a list of comments
this is a menu to one relationship where
you have the comment details but they
have a pointer back up to the blog post
and then if you wanted to get all
comments related to a blog post you'd
look up from that table with this ID or
if you wanted to get all the comments
with the blog post you do a join between
those two tables to get all the data
back related to a blog post or to get a
set of blog posts back with all the data
you'd actually do a join with these four
tables
and then when you're done with that join
you're not done with your work because
you're probably programming in a
language like Java or Python or
something that's object-oriented and you
probably are representing those comments
and those tags in your code as an array
or a list or some sort of data structure
like that and so after you do your big
ass join you've then got to go and go
through all of that data and now reshape
it so that you have a parent blog post
object and that you take all those other
pieces and shove them into the array
values this is what's called object
relational mapping I'm sure a lot of you
have played with things like hibernate
active record and Ruby things like that
and you know for those of you who've
done it
it sucks I don't know how many of you
guys know Ted new word but he's a famous
author and programmer in the industry
and and he had it rights it's the the
Vietnam of our industry the amount of
time firstly I can tell you the amount
of time in the late 90s and an early
part of the 2000s I personally spent as
a programmer changing the shape of my
data from the relational world to the
object world both for inserting the data
updating the data expressing queries
about the data you know either we've
written out the correlational mappers or
we've used optic relational mappers and
if you use them they're still not easy
to use especially if you want to get
them to be performant and then there's
some things where you're like you know
what screw it I've just got a you know
bypassed the object relational mapper
because it's not doing what I want to do
I mean how many people have you know
probably felt really guilty about doing
it but you know put a comma-separated
list of strings in a column in a DB and
felt super guilty about it right but
said like okay I'm not really gonna
search by this so when I pull it out
I'll just do a spring string split on
the comma and I'll and I'll get into my
object and the reason you did that is
because frankly relational model was not
the right model for what you were trying
to do so you think about all that mess
and then you you know you look at this
right you say wow this this looks like
the way I represent this stuff in my
code like if you're a Python programmer
or a JavaScript programmer it looks
exactly like this if you're a Ruby
programmer it looks almost like this
where the columns are separated with you
know that equal greater than if you're a
PHP programmer this is almost like what
you'd use except everything's arrays and
so you know it's a raise of arrays and
nested arrays which is still a very
expressive data structure this in my
opinion is a more subtle reason as to
why you should think about using MongoDB
even if you do not have a big Mongo data
problem it's really great as a
general-purpose database actually so
some examples you know in my travels
where I've seen it really good so using
it for accounts and user profiles right
so you have your account object
everyone has this every website consumer
enterprise everyone has their accounts
and their users probably no reason why
you really need a relational database
for that you're probably not doing any
interesting Cartesian products between
tables you're just looking up the
account by ID you may be following the
account - it's to have a pointer to its
user the user as a pointer back to
account there's a few different ways of
modeling it really good for user form
data so you have user forms you just
want to store that data back in the
database you might change the form often
so the flexible schema of Mugabe's
really great because you can add fields
remove fields it's not going to impact
things content management systems also
place where this shines CMS systems are
where you'll often see the table
inheritance problem so how many people
have seen where you know you have a
parent table representing a certain type
of thing and then you have all these
children tables that point up to the
parent table so the parent table might
be like the content item and then you
might have you know blog post news
article you know offer of the day might
be another subclass and in your in your
programming languages this really is a
hierarchy and then you go into your
relational modeling exercise and you
create a parent table and all the sub
tables of the pointers up and then you
know you do the joins between them to
get all the attributes and then if you
want to you know if you want to find out
information across all of those
different subtypes then you're doing all
sorts of interesting Union things and
all that type of stuff whereas a Mongo
you know you would just maybe you'd put
a field in there the represent of the
type so you could you know discriminate
based on that but you would just put the
things that represent blog posts in the
blog post type and you'd put the things
represent the tip of the day or the deal
of the day or the coupon of the day and
that you could have them all in one
collection they don't all have to be
exactly the same
great great use case for MongoDB storing
geo data so anything that's geo based
like location based apps mobile apps
really great because MongoDB understands
geo data natively so that's a that's a
big win
app configuration really good so
you know everything from you know you
know ports and you know connection info
to you know really complex IOC kind of
dependency injection type stuff right
that really you know all the stuff you
want to use to configure your
application you know stick and date
stick and JSON data structures it's it's
very convenient and then application
logging a lot of people use MongoDB for
app log instead of log files MongoDB is
famous for its write performance and a
lot of people just
fire-and-forget into Mongo one big
collection then they can search it later
as a database collection instead of
trolling to log files it's really
convenient ok well that one quicker than
I thought
that's CUNY that's a great question so
the question is what's a MongoDB
technique for normalization when you do
want to normalize your data so let me
just quickly go back so the one thing I
did not show here is there actually is
syntax for references to items in other
collections so there it's I won't draw
it here but you have a little syntax
where it's a it's a tuple where you name
the collection and the ID of the other
thing in the other collection and it's a
pointer to something so you could take
the author out and put it in another
collection and point to it and you can
model your data that way if it's if it's
makes sense for what you're doing so
first of all I probably I need right we
did not meet before this did we
okay so I I'm with mongolab and we are a
host of a matter
but yeah so we host on ec2 and Rackspace
we can we can talk afterwards I don't
want this to be a pinch session but yeah
there are there are hosting and we're
not the only one so great question so
the question is is there support for
constraints on the data ways of
specifying for example that a certain
field cannot be no in general not really
I will say that when you specify indexes
on things you can specify that they have
to be unique and there are a few
constraints like that but really that's
not really truly what you're asking and
so the answer your question is no you're
doing your application I will say that
in the community a lot of open source
projects have cropped up that rap the
MongoDB drivers that come from 10 gens
little mapping layers and most of those
I know of do add some sort of constraint
language or constraint system but it's
handled the application tier question
how does Mongo DB handle concurrent
reads and writes is there a locking
mechanism on the database the answer is
yes there is a server wide right look
that basically when you write it blocks
other writes and it blocks reads for the
duration of that lock for every database
for every collection on that database
server it is it is something that's
being worked on actively its first going
to go down to database level and then
it's going to be at even finer grain of
collection level and then even
filesystem extent and document level so
that's going to that's going to get
better right so the question is is there
any support for dealing with concurrent
access to documents you know and one
example is a read of modified flag or
some sort of mechanism like that so the
main mechanism MongoDB handles that is
with the atomic operators I was
mentioning so all of those operators one
in one of them the most simple one is is
called set where you set a field to a
specific value if you update your
database with one of those operators it
is guaranteed guaranteed to be atomic
and you
can set multiple fields at once so in
the example I gave before that this is
the example I gave before where is this
atomically push this new comment under
the list of comments I could have also
said they're not only push the comments
but then increment a number so I can
actually do a modification of multiple
fields at the same time atomically and
it's guaranteed that all of those will
update at once got it got it so I think
what you're asking is is there also a
way to specify a query constraint along
with that update to say push this on
only where the ID is 55 or only where
this thing is not null or set it to 7 if
it's not null or set it to 12 if it's
less than 10 but if it's more than 10 to
nothing that kind of thing okay so if
the first part of this update operator
is a query constraint so that query and
the update happened together yes sorry I
was not clear no so okay so the question
is you can get an atomic operators on a
single object but what about across
objects so one of the place one of the
things that MongoDB is not well-suited
for our applications we need multi
operation transactions right so the idea
is saying insert insert insert update
update delete delete Oh roll all that
back or commit all that together the
kind of two phase commit stuff MongoDB
does not support that what is the
support for querying nested arrays is it
would that be correct
so one Operator I did not show it's
called LM match and you can look this up
on the docs online but it's actually
particularly for matching those things
that have arrays with elements that
match a query that you specify and that
should work fine I've never personally
done it on arrays of arrays but in
principle it should work sorry the
question is is there a way to substitute
the way you compute geo searches the way
you compute distances between
I think is what you're getting at not
not that I'm aware of I think it's
really just spherical coordinate
computations and that's it or spherical
I think there might be spiracle and
Cartesian but no but nothing where you
can kind of plug in your own version of
the distance formula that I that I'm
aware of
oh great yeah so the question is how do
you back up these databases there are a
variety of techniques so you can use
okay so the main ways folks do it are a
there are some built-in commands that
come with MongoDB one is called Mongo
export one it's called Mongo dump Mongo
export exports
it's Warbeck human-friendly export
exports into either CSV S or JSON files
Mongo dump is a binary dump format the
technique you use with Mongo dump
depending on if you have journaling and
replication on is either you run mugga
dump and it'll actually properly backup
the database and you can have it do a
point-in-time backup without having to
stop it in other scenarios you can do
what's called an F sync and lock where
you basically tell the database to flush
everything to disk you suspend writes to
the database and then you dump the data
or you can alternately copy it's also
depending if you have a small data set
you can copy the database files one nice
thing is it's very clear what's going on
under the hood there's a directory with
files and for your database and you can
copy those over and you can be sure that
you copy those over that represents the
whole thing if you're on something that
supports journaled snapshotting so you
have a journal file system you know EPS
supports this there are other journal
file systems you can do incremental
snapshots and let me think with some of
the other ways those are the main
techniques and in there and they're
pretty well documented on the MongoDB
site and you tend to one thing I'll say
also replication is often often used for
doing backups so one thing that's
typical is instead of doing backups off
of a master
and affecting the performance of that
node you will have you can have a slave
that's devoted for as a backup slave so
you replicate that slave and then you
take backups off that slave and you're
not affecting the actual primaries that
are that are serving your application
okay so thank you very much guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>