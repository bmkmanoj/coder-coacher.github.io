<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Dive into Android Security (Presentation from AnDevCon II) | Coder Coacher - Coaching Coders</title><meta content="Deep Dive into Android Security (Presentation from AnDevCon II) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Dive into Android Security (Presentation from AnDevCon II)</b></h2><h5 class="post__date">2011-11-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tKJiSjVk8NA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everyone I guess we're about to get
started good morning this is an amazing
turnout 8:30 in the morning I don't
think that anyone would make it so this
is really amazing I guess you guys do
care about security this is good um just
you know some of you I saw him yesterday
downloaded my slides I had actually
updated him since several times and the
new version or the latest version of
slides that I'll be presenting is
available at this URL
HTTP colon slash slash m RK n dot co
slash I guess and SEC I'm also recording
this entire talk and I'll be posting the
video from this afterwards and it will
be available under the same URL
you
minutes to go through Android security
there may be some demos we get to do I
do encourage you to ask questions
I normally these talk something's range
from is as short as 40 minutes - I guess
75 minutes so this time around
I think we actually have time for
questions so do feel free to interrupt
me if you have some specific questions
what you do get through otherwise I also
plan for having at least 5 to 10 minutes
worth of time at the end for questions
so that said let me just introduce
myself so my name is Alexander Gargant I
also go by a nickname of Sasha I've been
doing Java since against long long time
most in the server side actually and
then switch to Android I've been doing
Android since 98 I've been teaching
Android actually since 2009 I've been I
run happy - I'm somewhat local I live in
Walnut Creek but I actually run an
Android user group here in San Francisco
well north of here I also run the Java
user group in fact we have an event
tonight which I invite you to attend as
a Java the tour I also work at company
called Americana we focus on open source
or training or open source software so
hence they have been exposed to Android
quite a bit through the my work that
said this talk is on Android security
kind of all-encompassing from what we as
developers me to do or what the platform
is doing or could be doing better what
the users potentially need to worry
about so we're gonna attack it from the
different angles so we're gonna go
through the security model the
permissions on Android are they work
encryption device admin I'm sure
hopefully some of these things ring a
bell the routing and kind of what that
entails why is it done how is it done
why shouldn't be done anti routing so
what are the things that we could do if
we were platform developers to prevent
routing or try to mitigate it
tap jacking what are some of the issues
that you should know office developers
some of the best practices and then some
of the other concerns that's the general
idea for this talk so why care ok I
guess you know set up let's set up the
motivation for this
so ultimately Android has has grown to
you know latest statistics are gonna put
it somewhere at million activations a
day has it reached that point yet
probably but it'll will soon enough
and so as you could imagine the more
important and more you know prevalent
the platform is the more interest there
will be in the hacker community the the
not so good hacker community to try to
take advantage of users running these
these devices whether for just monetary
gain or corporate espionage or some
other reasons also what we all don't may
may not realize is that Android is also
heavily used in enterprise in you know
and so it has access to corporate data
but also it's modified and customized
for specific enterprise applications
whether it's specific tablets or set-top
boxes or even in you know areas like you
know cars and you know flights like in
own flights for example in planes you
could have Android potentially powering
your entertainment center so of course
in all those different areas security is
important to the degree that you know
enterprises are really paying attention
to these sorts of security threats and
this is just a list that you know I
compiled a month ago
if you just go google android security
I'm pretty sure you'll find other things
that should be on this list but you know
this is all I could put a fit on one
slide including my little pretty graphic
so what are the foundations of Android
security so it comes down to to the
different aspects that the platform
provides to us the developers but also
us the users in order to provide us with
them as a secure environment as possible
of course without impacting the user
experience to to a large degree so what
we're going to discuss essentially are
things like application isolation so
permission control I'm pretty sure
you've guys have heard of permission so
to what extent you've actually been able
to take advantage of something we'll see
so we want to discuss how you know why
is it that applications cannot you know
go and damage the rest of our system why
what are the sorts of bonds and checks
that are in there how can we prevent
misbehaving you know apps from affecting
you know as the user us the or the
system or other apps obligation
provenance so we'll talk about you know
idea of trust give me trust the author
of the app can we make our apps more be
more tamper resistant data encryption or
better yet just how do we you know take
care of our data how do we make sure
data is essentially kept safe and then
access control as a way of you know what
are the sorts of things that Android has
in place that you know help essentially
control access to the physical access to
the device and of course there's going
to be some other security related
concerns that we discuss so before we go
into these details though one thing I
like to do is just go over the stack now
how many of you have seen this picture
before okay so that's that's awesome so
at least I would say about a half so
what what this is essentially this
captures my version of it and we do
resilient different versions of the same
picture and what an Android OS really
looks like right at the very bottom we
have the Linux kernel which is modified
for Android it's Android that you know
one thing I want to make clear is that
Android is not an Linux operating system
the way we think of a Linux operating
systems it is not doesn't have password
file at least not the way we envision it
doesn't have su command at least not by
default doesn't have a lot of you know
x11 or G libs or you know other sorts of
things that we kind of come to assume
are part of standard Linux distributions
so what's the purpose of the Lynx kernel
it is mostly there for several things
several reasons one is to provide
isolation from app to app so to enforce
if you if you will the security model
and then we'll talk about next and then
of course the other is to provide a
driver model and a huge you know
assortment of existing drivers they've
been already written for Linux and
things like you know threading you know
CPU scheduling memory management that
sort of thing right so that's what the
Linux kernel is doing a very bottom we
have this native layer which itself is
kind of composed of multiple layers like
the Bionic library that you might have
heard of which is the list
equivalent of Lipsy the native Damon's
that essentially provides services some
which run is route and that's the sort
of thing that we worry about the how the
user space hardware abstraction layer
that essentially abstracts away the the
device drivers from the rest of platform
exporting heck of a lot easier then
native libraries like for example lib
wet core which is equivalent to WebKit
which was at one point hacked on Android
for example you know sequel Lite OpenSSL
even things like you know media
framework like stage fright and so on
and so on like open or the tacky videos
open core which was also a source of
some of the security issues in the past
so there's a lot of native stuff in it
of course in the native layer that we've
come to trust there's also this dalvik
virtual machine on top of most of our
apps around right some of you may be
writing apps natively in which case you
don't really care much about dalvik but
most applications are in fact written to
to run on top of the Dalek virtual
machine you don't have to see the dalvik
is actually great in that it doesn't
play a role in the Android security okay
it's left up to the virtual two to the
Linux kernel to take care of it
the application framework is where our
services live or platform services live
like you know location manager vibrator
you know sensor manager and so on and so
on so these are the things that
essentially give us the developers
access to the lower levels of the of the
platform and then of course the big
sorry at the very top are our
applications that take advantage of not
only the application framework services
but also potentially of components of
other applications and this is important
because even those applications are very
top become part of the stack so they've
become part of the api's so the first
thing we wanna discuss is this idea of
application isolation so if any of you
did adb shell to an android device or an
android emulator you would have seen
essentially something that looked like
this of course you wouldn't necessarily
see the kernel you would assume that
it's there but essentially you would see
a bunch of if you type PS of course a
bunch of processes so you may encounter
process called Baldy netd installed II
and you may notice that those actually
run as root so something we'll come back
to later on you may know what is there
something called service manager also
ours is ruined it's a kind of important
for discovery of services zygote which
is this kind of half-baked dalvik
virtual machine that gets worked into
are essentially dalvik virtual machines
that power our devices or our apps the
system server which is the home for all
of the system services so all that all
that application framework services like
location service and whatnot activity
manager service package manager service
that's where they live and then at the
far right you see our apps right notice
how our apps are essentially a stack on
their own right they are each and every
app long it runs in a separate process
so they don't share any memory there are
share any resources of course they share
the underlying resources but they don't
directly share anything whether the
filesystem so they don't have access to
the same files excluding the SD card and
they don't really have access to each
other's files and there are heavy direct
access to each other's components they
can talk to each other through different
means we will talk about but talk about
in a moment but they basically don't
really have anything in common and this
is important it's the Linux kernel that
provides isolation because each and
every app runs in a separate process the
process management is essentially the
job of the Linux kernel and notice of
course one other thing I wanted to
mention is that you know each app has a
dalvik virtual machine of its own so
this is actually very interesting and
important for Android so by default at
the time of installation each app is
assigned a unique user ID when any time
it is started whether whichever
component of the app is started it is
run in a separate process now it is
possible for for multiple apps to share
the same process and/or user ID but only
if they're signed with the same
essentially key so if you share the same
public certificate and better than the
app then they can essentially take
advantage of it it's not a very common
use case though what's really really
important and good about this is that
this isolation is based on essentially
that
it's all old UNIX security models so
this is not Android trying to
essentially you know build something
from scratch and hope that it works but
rather they're basically you riding on
top of something's been out there for
years and years and something we can
trust the application framework as we
saw the system server also runs in a
separate process and not as route at
that so well that's something we'll
discuss as well so on Android the Linux
kernel as I mentioned before is the sole
mechanism of essentially enforcement of
the site of application isolation and
the dalvik virtual machine plays no role
and this is important because back in
the Java and Eve model yeah I don't know
how many of you have ax you know have
done work on Dre j2me where multiple
apps share the same virtual machine
it was the virtual machine that
essentially had a security manager in
place and his job was to essentially
ensure that apps don't step over to
others balance but that meant that apps
were no longer able to talk to native
libraries they couldn't take advantage
of anything beyond what was in the
essentially the profile of that
particular device they were there was no
mechanism for them to escape the
security the sandbox of the security
manager and so that essentially led to
crap experience I mean j2me apps were
never considered first-class citizens on
any of the devices that essentially
party and so you know we we wanted
something different so the Android team
decided to make dalvik essentially
oblivious to this whole idea of security
so now the native code as well as java
code or dalvik code at runtime is where
ah is subject to exactly the same
security restrictions there's no
benefits no advantages from the security
point of view from writing code natively
or in job yet you get to take advantage
essentially of all the platform features
should you want to you know if you want
to essentially drop down to a native
level and again same rules apply even to
system apps so this is not this idea of
app isolation doesn't just apply to
third party apps there are apps but also
applies to the built in apps there's
some minor differences in what the
system apps can do that we cannot take
advantage of
but for the most part the rules are
pretty much the same now this is kind of
what you end up with this is this is
this is a default scenario right so if
we had some app call it at one that
wanted to talk to native Damon's they
wanted to talk to the other apps they
wanted to talk to zygote or system
services by default for the most part
the answer is no so by default each and
every app is essentially is not able to
escape its own sandbox so no app can not
can essentially do anything they roll
vertically affect the system affect
other apps or affect the user so for
example you cannot take advantage of API
as it cost use your money unless user
has given explicit permission to do so
you cannot for example shut down other
apps you cannot vibrate the device you
cannot keep the device away things that
essentially would affect the usability
of the device or other apps is
explicitly forbidden unless the user or
the app has being essentially granted a
permission to do so so how do we get
there
- how do we escape the sandbox so
basically what we do in in as the
Android developers is we declare there
are apps use permissions by adding as
you will see in a moment a user's
permission essentially at an element to
our manifest file we are asking the
end-user to grant us permission for us
to make use of the restricted API okay
if we don't do that if we don't actually
add this users permission and we're not
essentially granted permission the are
our we can still make invocations of the
API but those limitations will fail at
runtime right so essentially we will end
up most likely with the security
exception now one thing I wanted to
mention is that apps can in fact talk to
each other through intense so you've
probably you know hopefully a lot of you
here Android developers so you you've
you know started one activity can for
example start another activity and it
does so through intent so you can pass
it data through intent so they can
essentially talk to each other to
intents they can also talk to each other
through binder which is the androids IPC
mechanism
okay and this doesn't require any
permissions by default and of course
they can change data through content
providers this is actually interesting
because one of the things that it
becomes somewhat of a problem with
Android is how do we know if two
different apps are in fact talking to
each other
yeah and does that affect us or the
security of our device so we'll come
back come to our back to data point in a
moment now as far as the built-in
permissions the list is huge I mean this
is just to give you an idea for
something that have not worked with
permissions extensively so access the
file location you know access Wi-Fi call
you know use the call phone use camera
access the logging like you know it's a
weed from logs for example use wake
locks to keep the device away vibrate
right you know write contacts and SMS
receive SMS these are the sorts of
things that we would need permission for
for the full list you can of course go
to this URL down at the bottom and
you'll see it to see the list now one
thing I wanted to make clear is that not
all the permissions that are on this
list or on the list below and in the URL
are actually accessible to us some of
these permissions like for example
install packages we cannot use and
explain later on why so the fact that
are listed there doesn't mean that
necessarily you know something we can
take advantage of so for example let's
say we're building some sort of an app
that vibrates anytime you come close to
I don't know one year of buddies write
some so the app would need access to
your current location it would need
access to the Internet in order to
basically you know provide this you know
or register your location some central
central server and that central server
uses its broadcast mechanism to other
body you know friends of yours to tell
them where they are like the latitude so
what you would need essentially are
permissions to access the fine location
that's how you essentially get access to
GPS access their Android permission
internet which essentially enables you
to talk to the or take advantage of the
tcp/ip stack and then vibrate permission
if you want to be able to actually
vibrate the phone I don't know when you
you know approach approach some buddy of
yours can or come close whatever
close may mean so this is
this is the syntax and I'm hoping that
at least some of you here have used this
in the past in fact you cannot really
get really very far these days without
using permissions now how are the
permissions generally enforced by the
system so this is this is essentially
how most services work on Android right
let's assume we have some sort of a
device over here you know we can call it
you know Deb foo imagine it's on some
important device like a scanner camera
something that we care about right we
could potentially you know have an write
an application they will try to directly
go over here and use that device right
but that's generally hard so instead
what what we typically have on Android
systems is we have this whole idea of a
holo model which is essentially a
hardware abstraction model right so what
we do is we or what the device
manufacturers do our OEMs they provide
us with something called Lin phoo
generally let's assume that's what it's
called essentially is user space library
shared library that knows how to talk to
drive ok we could load it right we could
actually load that library and try to
access a car now this library is written
in C we may prefer to quote in Java so
what the OMA also do is provide us with
some sort of a j'ni bridge or wrapper so
think of it and some sort of a who
native it's a java class that
essentially defines some native methods
and those native methods are implemented
to say something called Lib foo Jana and
we could load both this and this into
into essentially our process and we
could try to use it right nice clean
easy to use API but where we would
generally fail is right here when we
basically try to open up this driver the
driver itself tends to be protected
through simple file system permissions
so the point being is that the libraries
are not they don't have to be
essentially security aware these
libraries all this stuff essentially
doesn't care about security nor does
dull bit it's really whether or not we
have physical
to the file in this case the driver so
what we do instead and what Android does
is that is that most of these services
right most of these say to call it
drivers in Android happy to have
basically some sort of a service that is
persistent and it's stored or loaded
into the system server resistant server
don't forget is the home for all of the
system services and this call it full
service would register itself with that
service manager right under if you
remember which is another daemon that
sits there in the in the background runs
at all times
ok so what is the purpose of the full
service well of course in top of you
know being able to to kind of aggregate
or provide a stateful access to the
underlying hardware and provide some
additional potentially you know value
add on top of it one of the big jobs of
the food service is to also essentially
right here at a point of somebody trying
to use it so think of it kind of right
here do a permission check how does it
do a permission track well when we want
to use the service
we don't actually access the service
directly instead we use something called
foo management right so what I mean by
this if you're any of you use let's say
the the location service right you
actually don't get access to the
location service well you do you will
you get access when you go systems or
get system service and you say location
where you get back to something called
location manager location manager is
essentially a client side component it
runs in your virtual machine in your
gothic virtual machine and the whole
purpose of the location manager is to
essentially bridge to the service to
essentially hide the fact that you are
talking to the service in another
process to abstract this idea of IPC the
inter process communication away from
you right so you think you're talking to
some service somewhere you're really
talking to a local manager which is then
bridging or proxy your requested service
now what's what's going on in addition
to this is when we actually make this
call we don't actually make the call
directly instead we actually talk
through something called binder so we
kind of go like this binder is the
kernel
driver that among other taming its job
is to provide this you know IPC bus but
in addition to that it actually also
provides the the information about the
caller to the callee can so the calling
being the service knows now about the
UID and the PID of the calling process
so what is the purpose of that well once
we have that information the service can
actually go to the to the package
manager or package manager services it's
called
and say hey for this UID MP ID does the
calling process had a particular
permission like access file location or
vibrate the device and at that point you
get CNA either does or doesn't and then
decides what to do and most likely if
you don't actually have the required
permission essentially end up with a
security exception okay
so this is how most not all but a large
percentage of the services in Android or
I should say restricted API is in
Android are enforced to this ad of
services wrapping essentially these
native libraries and then also in
addition to that providing this
essentially security track before we can
get access to them okay in fact if you
kind of want to take a look at it just
using vibrator as an example if I were
to do an LS for all the vibrator driver
you will notice that it is owned by
system system and you'll notice that
only the system user can write to this
droid okay so that means that our apps
if you remember the previous slide or
couple slides back we did we don't run
with system user so therefore if we try
to write to this driver in order to tell
it to vibrate the device good luck you
won't happen so what do we do we want we
then use something called vibrator
instead of viber manager for some reason
they call it vibrator and vibrator is
really just nothing more than a client
through this thing vibrator service what
does the vibrator service do well let's
take a look at it the actual method
vibrate method that we invoke to vibrate
the device the very first thing that it
does it goes to its own internal
context and says hey check the calling
or self permission and essentially says
does the calling process have the
permission library if it's not been
granted so if it hasn't been granted we
then end up with essentially over here
as you can see the security exception
okay and that's how most of the services
are enforced essentially the security
concerns again no colonel permission
enforcement okay so what we already know
that kernel contributes to the isolation
of apps we also know that the kernel you
know helps enforce essentially or
prevent us from directly accessing
mostly drivers but there's more to this
so colonel in some areas plays a more
direct role so for example for internet
like how do we actually get access to
the internet well it just so happens
that the Android's kernels it's been
modified with something called paranoid
network security okay so what is that
essentially it's a little thicker is an
if statement around the tcp/ip stack
right the network stack that says does
the calling process belong to group 3003
why that group that is something that
came up with can they call it the island
group okay if it doesn't if the if the
process does not belong to that group it
doesn't get access to the internet okay
it tails so how did how do we actually
think yet accident right well we use the
remember the Android permission internet
over here that's what we use what does
that give us
that gives us essentially access to the
inode group which itself is mapped to
that 3003 you know group ID so we
essentially so by using a permission at
runtime we get this group membership and
then the kernel does the enforcement of
whether we love belong to this group or
not so are essentially our logical
permission becomes a specific group ID
at runtime again another way to enforce
it is through essentially more again
more of file permissions so for example
camera or read logs or write to external
storage the way these things were
is that these again are map to specific
group IDs and B by being mapped to
specific group IDs that gives us write
access
or in some cases read access all those
specific drivers for the most part we're
talking about drivers in some cases we
do directly talk to drivers we don't go
through these system services we don't
go this roundabout way through IPC we
can't talk to them directly but again
for us to be able to do that we need
access to or we need the appropriate
permission the permissions are granted
to us by this by the virtue of mapping
logical permissions to group IDs Ken
permission granted okay so now that we
know that our apps are subject to these
restrictions or you know when we need
permissions in order to access career it
with restricted api's how do we get
there well the permissions are granted
once at the app installation time again
this is very interesting for Android so
we this is not like you know Microsoft
Vista where cost would be mac to approve
of you know whether you want to do the
next thing the next thing the next thing
it's essentially at the time and
installation you as the end user either
grander permissions or you don't granted
permissions if you don't grant the
permissions the app doesn't get
installed there's no provision for you
to dynamically later on grant or
undrained permissions and there's no
provision for you to partially grant
permissions it's all-or-nothing
whether you like it or not there's some
exceptions that basically URI
permissions are kind of like paths from
an application to application but and
USB permissions or at you know an end in
essentially API twelve there was a
Android added support for the USB
accessing USB devices and also for
accessories for accessor API and
essentially for that you need you know
you need these USB permissions they're
kind of grant to dynamically but that's
that's that's an exception it's really
it's really you know they're granted
statically now the question though
becomes is can a any user essentially
make intelligent decision as to whether
the collection of all these permissions
they're granting a safe or not so
essentially Google's or Android teams
you know jacked it was let you know more
power to the user let's give the user
all the power in the world let's have
the end-user decide on what
and what they're comfortable with or not
comfortable with but most users it turns
out are not very well equipped to deal
with this so what do they do they
basically you know are conditioned to
say yes yes yes for the most part not
you guys but you know a lot of users out
there so another little feature of
Android is the certain permissions like
wake up on boot are not considered
dangerous enough so the user in order
for the user to grant these permissions
they actually have to click on this
thing called see all and then they'll
see that they're actually in addition to
all the other dangerous permissions
granting those as well the one thing
that somewhat kind of scary is this idea
of Cobo permissions so for example let's
say we have two applications that we
install on a device one that essentially
you know let's say wants access to our
email so you can like maybe has some the
super duper you know voice search for
for email and we granted access to our
email and then we have this game that
wants access to the Internet because you
know these days everything's
ad-supported so it needs to talk to its
ad servers right so we say fine but what
we don't know is that these app to apps
can in fact talk to each other right
they can discover each other they can
exchange data with each other and so the
app that has access to the to read your
email that app can leech that email and
send that and essentially send it to the
app that has access to the Internet then
app can send your email out you know to
whatever your competitor or who you know
who knows well so the point is you know
you we may think of these apps as being
isolated from one another but we don't
know whether whether and if they do take
advantage of the and androids IPC
mechanism to essentially circumvent that
fact and this is what you know grant the
screen looks like okay so they're
granting permissions now the question
that becomes is what are the
alternatives so you know do we
dynamically grant permissions every time
an app starts do we grant permissions on
use well Google's you know or Android
scheme essentially perspective on that
is that it's annoying you know if we
were to implement that approach it's
hard to provide seamless app switching
one of the real cool features of Android
is that you go from app to app to app
without really thinking it's called a
user
it's what you want to do it's about the
user it's not about applications but if
now you were constantly nagged to prove
of specific permissions of you know when
going from app to app that that would
essentially break that illusion that
you're essentially just using whatever
you know the system has and not
specifically focusing on a particular
app and of course the other end problem
is that over prompting the user leads to
essentially you know condition response
they just say yes yes yes like people
you know ended up doing on Vista and you
know that does that really really leads
to good security and of course you know
if the users already committed to the
app on the time installation then he is
happy I provide all this personal info
and then all of a sudden they see the
app what's wants permission for
something that are like well at that
point they mean granted even though you
know if they were prompted for the same
thing or earnings and install time they
may not so the other problem with
respect to you know on in for like our
users well-equipped to know what to
grant what not to grant well you know
Google responses well Alette operating
xand comments from the more
sophisticated users influence more
novices users decisions as to what what
install would not install the only
problem with that is that you know users
then become like sheep they basically
just look at that number of installs you
know essentially figure and then go by
that like if it's a large number then
it's fine otherwise who knows right but
in the past there were in fact apps like
you know live live wallpapers that
essentially had you know compromise in
them or had you know uh security
exploits where they were leaking
information from your device to some
servers in who knows where you know some
site competitor countries and you know
the app looked cool and most people just
yes yes yes you know installed it and
enough people installed it initially
that other people just came who came
later and there's like Oh 200 installs
or 200,000 installs this must be safe
when they go install it as well right so
at least one good feature of the Android
Market or at least the Android
distribution mechanism for apps is the
Google does how ability to pull apps
essentially has a remote kill ability to
to to pool apps off of your devices if
they're found to be you know malicious
in nature but it's more reactive than
proactive right you're still
you know you're the one who's ultimately
responsible for what goes on to your
device
now application prominence so this is a
term that I you know I guess I saw in
one of the Symantec reports on Android
security which you should read it to
cares about security and Android
can we trust that the author of the
application is really who they say they
are that's really the question we want
answer especially on the first install
so that's something we need to discuss
can we trust that our apps are tamper
resistant so they cannot be changed once
installed and so one of the ways you
know Android tries to deal with this is
that developers are required to sign up
for a developer account with you know a
valid credit card which is then tied to
their account and so if the developers
are found to be malicious right
Google can go after them so the idea is
as you will see that and requires apps
to be signed and the idea is that
through this idea or through the
signatures
you know this trust that exists between
developers and Google can then be passed
on to you like so then now if you trust
Google then hopefully you can also trust
these developers one thing to note
though is that applications can be
installed through alternative means like
they don't have to be installed through
Google Market they can be side-loaded
or come from other and markets as well
so well how does this assigning thing
work
I already mentioned all apps have to be
signed so this is not a this is not up
to us some of you might have just you
know Donna Killough world and you click
the run application and you see it works
but you don't really even haven't done
any signing so you're like well what's
signing well if you try to upload an app
to market you actually are required to
first sign this app with something other
than the debug key so the signatures are
based on this public private you know
encryption algorithm where basically you
have a private key that it's used to
digitally sign the app and then the
public key in form of a certificate and
the signatures of the app resources are
bundled together in the apps apk okay
the question is what is this good for
right why the heck do we need sign well
I already mentioned like the idea is
for this you know for the trust that
exists between Google and the developers
to be passed on to we know us well
unfortunately the issue is that these
certificates that are embedded these
applications can and in fact are
encouraged to be self signed what does
that mean essentially the private key
that is used to generate the signatures
is they also use to sign the public key
in to generate a certificate right and
this is great from the point of view
they don't have to go to like their site
or something like that to essentially
pay however many hundreds of dollars to
essentially get a stamp of approval that
your legitimate but it also creates a
problem in that we don't really know
that what we're getting has really come
from a particular developer since the
keys can be self signed there's no one
to vouch that said there wasn't someone
else who potentially stole that
application added some malicious content
to it and then re-sign it with their own
key and of course since it can be self
signed they can trust themselves who
wouldn't and upload it to market right
so so on the first install there's
really in the current system no real way
for us to trust the author of the
application so in that regard you know
and especially given the the fairly
relaxed review process or non-existent
review process for for Android apps
which is great because means no friction
but it's not so great with respect to
security they could the combination of
these two things do mean they were more
exposed to essentially you know
malicious apps then we would on other
ecosystems now in terms of updates so
that's where the signatures do come into
play right so if the the signature or
better yet the certificate doesn't
change from the original app to the
updating app then we can trust that they
came from the same author so in that in
that case it doesn't matter whether
there's a CA or not as long as they're
the same that's good so at least for
updates okay
the signatures do play a significant
role we now know that someone can't just
impersonate some other author out there
of a popular app and essentially have
you know their app you know replace our
legitimate
and then the other reason is that it
does help establish the signatures or
certificates do help establish a trust
relationship between multiple apps from
the same vendor so if a single vendor
actually signs multiple apps with the
same private key that means that the
same certificate will be embedded in
these apks then one of the things that
these apps can take advantage of is that
they can basically share UID
so they can run with the same user ID
they can actually running the same
process and they can share signatures so
this is interesting they can actually
that's right they can share permissions
based on signature so I'll come back to
that idea later on now it is also
possible for ions for single apk to be
some with multiple keys well that's not
very common now the other thing that I
just mentioned this the other thing that
is also a possible or the other reason
why we have signatures is they help make
our apps more tamper resistant so the
idea is you know our apps since they're
signed they cannot be modified by
someone without breaking essentially
this is the signature that said apps you
know due to file system permissions that
we have on the device once the app is on
the device we don't really care much
about it having been signed because if
essentially someone can modify the apps
components that means they probably have
root and they have root then all bets
are off
who cares about signatures at that point
so this is really more important in form
of distribute distribute distribution of
apps you know as they are you know
before they make it onto our device you
had a question no there's there's no I
mean first of all you know when you
install you don't see the package name
you don't really see the the fingerprint
of the other of the public key there's
nothing for you there's the end user
that you can go on to say hey this
actually came from a trusted source at
least not in the group containing the
current I mean you know market
application that we have as Google
I I think they should that's a very good
idea so that's the sort of thing that
you know we've seen in the open source
world where the football you know the
signature is essentially a fingerprint
of the key in you know in a webpage or
in this case D of the form and then you
can check it against some webpage
somewhere if you're really paranoid and
then they'll give you an idea of whether
or not it's been tampered with yeah
exactly so that is the problem like so
one of the things we'll talk about later
is what if for example somebody let's
say Angry Birds right I go in and
download or an Angry Birds onto a rooted
phone then extract the apk off of the
rooted phone maybe add some malicious
content to it Reese if change the name
from calling Angry Birds to calling
Angry Birds Burlingame right and then
reuploading it back to markets well you
know Google catch that most likely not I
mean somebody else will and and sure
enough the app will be pulled for market
but it may not be fast enough to prevent
some some users for potentially getting
that app onto their system thinking that
it's the latest version of the Angry
Birds you know app or in this case the
game exactly and and what do users know
like they can see Rovio systems inc or
go rogue your entertainment thing well
they know that that's not the original
Rovia right which is the maker of the
order of the of the authentic Angry
Birds there's no mechanism to
essentially at least I mean so there are
some checks and bounds that Google does
have in play for specifically that
reason for like some of the more popular
apps so I'm sure they do search for
these sorts of things but how and what
they do is not known to us so so what
I'm saying is that it's something that
it's not
you know bulletproof that a question oh
you see you're asking can you can you
take a nap value no extract it
essentially change the permission well
so so so yes except that if you are able
to get at the apk from your phone that
means that you have a rooted phone if
you have a rooted phone that you can
actually go directly modify this large
data slanted slash system slash packages
that XML file and take away the
permissions the problem though is when
that app tries to take use the
functionality it will fail with a secure
exception will not expect it so it will
you know crash and burn now it is that
is
good point like for example one point
you know Angry Birds required what you
know send SMS permission and people are
like what you know why the heck wouldn't
need it
but it turns out that in some European
countries they used the s n SMS to pay
for premium content to download more
content into Angry Birds but to us here
that made no sense
you know thankful in that case the
actual online comments and feedback you
know did help persuade Rovio into taking
that away and reuploading them yeah
right so anytime an app is updated if
the permissions modify whether they're
added or removed essentially Android
requires the user to we approve
essentially the update and that's even
if you have that automatic updates
enabled you will get prompted it'll say
manual update required it will not do an
automatic update whenever you change
permissions okay so let's uh let's move
on thanks for all the questions but
let's actually try to move a few slides
forward and then we'll hopefully get two
more questions so this idea of signing
you know there's some problems with it
right so what if you lose or your your
key or your keys expires for whatever
reason you're gonna read the dog that
said your key should be valid for at
least 25 years well there's no real way
to update your apps then so that sucks
you end up having to essentially issue a
new app so your app will not be able to
read the previous apps data so you'll
end up having two options system yeah so
don't ever lose your private key on the
indoor that don't have it expired now if
your he does expire the app will still
continue to work that's already in store
but you will not be able to up there if
your keys stolen there's no real way to
revoke the key okay I mean you can go
talk to Google but there's no official
mechanism for you to do that so that's
also problem and I can mention you know
how do we trust the author in the first
install you know is this a real author
is this an imposter how can we can we
get access to the search can we check
the cert has this app I've been vetted
we know if someone actually use this app
that you can contain some malicious data
content um should we go by the number of
installs which is kind of like follow
the Sheep you know that's where those
those are sorts of questions you want to
ask yourself so they're what are the
results so the results are
these are some of the kind of
essentially viruses or Trojans that have
you know popped up in the Android
ecosystem they've been identified by the
you know semantic or Norton security and
also the law might look out guys
essentially what these are are our apps
that are legitimate looking apps they
were downloaded unpacked malicious
content was added to them including
additional permissions or sometimes
rootkits we'd already actually don't
require permissions they will repackage
three sign the reuploaded and they're
due defer name or redistribute it
through these unofficial markets and
people essentially got them on their
devices and infected their devices so
some of these things would you know they
range from just leaking your personal
information somewhere but it they also
in some countries like Russia but these
some of these stations do this they send
premium SMS messages or SMS to premium
numbers and essentially incur you you
know charges on your own your mobile
account so they all took advantage of
the week trust relationship these are
the steps like you take an existing app
you you get it you pirate it right you
inject malicious code you repackage it
we are we sign it to be uploaded and
then just wait for the ship to come yeah
now safeguarding our apps data so we're
we're now moving to the kind of the data
section when you know so hopefully we're
done with this idea of provenance I
hopefully understand that there's some
real issues for I think Google to
address in this in this place so by
default because our apps have distinct
user IDs all the apps files so all of
our apps files are private by default so
they cannot be read written but in any
way shape or form manipulated by other
apps directly unless we specifically
make the files be world readable or
world writable or if we for example go
and put our files on the SD card where's
the card essentially the Wild West if
it's there you know you can assume that
some other app will modify your data and
you should not trust the data there so
you should be very very careful in how
you read and parse the data in terms of
like if you want to make sure it is that
doesn't get you know if there's some
private data your own or leaked then you
may want to do encryption of the data
yourself there is a so of API 9
something called Storage Manager which
has this idea of opaque binary blobs
which allow you to essentially create
these virtual file systems on the SD
card and that are romantically
on-the-fly encrypted at the beginning it
didn't quite work I'm not sure actually
how does what's the state of it today
but I know that initially when when you
know gingerbread rolled out that wasn't
actually available for what it was there
but it didn't work properly
now other apps if there's sign we the
same key they can in fact get access to
the same bios so so you can you can
request a wrong with the same user ID so
thereby they can get access to the same
class although that's not very common
most the time if you want to share you
know content between apps you share it
through content provider now in terms of
data encryption so what do we have today
so we have VPN built in with you know
IPSec and three day you know three
Triple DES and AES encryption including
certificate authentication in Ice Cream
Sandwich Google added support for a VPN
API
so essentially custom VPN clients can be
provided through association happy stall
so you don't have to create a custom ROM
just to get a computer or a VPN client
it's compatible with your enterprises
VPN system we also have 802 11 of course
that supports you know WPA you know to
which it's both you know password as
well as certificate authentication we
have open SSL that's again it's all
built in
we have jce or Java cryptography
extensions which in Android or bar or
basis we called bouncy castle and this
provides us with you know support for
all the common encryption algorithms
both public private you know public
encryption as well as symmetric
encryption as far as communication goes
the HTTP client the Apache HTTP client
built-in supports SSL out of the box
SSO slash TLS as well as the HTTPS you
know the URL connection in kind of the
Javas library also supports excuse me as
a cell one of the problems though is
that the actual s
CEL see a store so the store actually
where the trusted certificate
certificate authorities are stored on
the device is something that we cannot
change
in at least up until gingerbread well
including I think honeycomb that said
encryption using encryption beyond SSL
for your reasons let just encrypt stuff
and sent over the network is not trivial
a lot of people get it wrong like for
example they don't properly use
initialization vectors which essentially
use it's a way of adding a little bit of
randomness to the key for each message
that you sign and you send over
somewhere else because if you don't do
this if your resilence is using the same
key over and over and over again to sign
different content after a while that key
becomes weaker and weaker it becomes
easier through analysis static analysis
of the data to recover the key so if you
don't properly use initialization
vectors for example of properly use
encryption and believe me those
encryption API is for the most part suck
you all run into problems one other
thing is that encryption of data on the
device a lot of people get good kind of
confused with or they think well all the
data on the device has to be encrypted
okay fine but if you store the
encryption key on the device as love
then it's just a moot point doesn't buy
anything right because by default due to
the isolation of the of the apps it's
the only way for some other app to get
access to your data is if the device is
rooted or that a has root privileged one
it once again root privileges assume
that he has access to her the entire
system including the file that you use
to for example where your spoiler
encryption key right so the only time it
makes sense to really encrypt data on
the device is if the encryption key is
stored on some server somewhere all the
device or in the users head never on the
device as well right and in Ice Cream
Sandwich they also added support for
something called keychain API that
allows
essentially user apps to to man
manipulate certificates is well
including certificate authorities so
this is something I know it's there I
don't know how it actually works and I
can see that a chance to play with it of
course and then in honeycomb they added
support for whole disk encryption so I
just mentioned this quickly
a virtual device right that's kind of
what the Storage Manager the Oh Kobe
beard your big binary blobs so that's
kind of what it is so take a look at
that so just look at the storage manager
in read an opaque binary blobs that's
exactly what you're asking for so hold
this contraption so basically this is
something that's only available as a
honeycomb what that is is you can go to
settings location security encryption
and then saying crypt tablets at some
point I guess they'll call it encrypt
device it requires that you setup an
on-screen password doesn't work with a
pattern so the same password you used to
unlock the device is also used for for
to to enable this disk encryption it
encrypts the entire data partition
everything okay entirely the partition
with AES 128 bit encryption it uses
basically your password is you know you
know salted and you know digested
multiple times through through sha-1 and
then that's the password that's actually
used to encrypt the files there's some
problems with us though is that the
actual password that is used is is
directly essentially used to encrypt the
files through this manipulation or
through this salting so if you want to
ever change the past we have to re
encrypt everything okay then actually
use the password to encrypt some other
file that has the actual encryption
password they use the password more
directly also if you want to go and
disable encryption once you do this you
have to essentially master reset the
entire device okay this also happened to
me when I try to upgrade from 3.0 to 301
you know it required for some stupid
reason the reset of the entire device I
was extremely unhappy this is based on
the DM crypt feature of the Linux kernel
at least the kernel part the user space
binaries through main men manage all
this are actually part of baldie which
is a daemon in android they're not
essentially they re implemented that
simply because of licensing reasons one
problem though is that this is not safe
from the point sorry this is not very
performant at the moment
there's no hardware acceleration here at
least the Robbins that I've seen on the
my Tegra 2 Samsung Galaxy Tab basically
you Lu you know it read performance goes
down by about 54% again once this
encryption is enabled at least you know
for for like large files one of the one
other problem is that this is still
vulnerable to so-called evil made the
maze attack which basically means if you
ever leave your device somewhere and
someone to sup with someone your quarter
core trust if the entire boot process
from the very time your CPU is powered
on all the way to when your device
becomes decrypted is not controlled
right so if everything along the way is
also not encrypted or attend
authenticated essentially someone can
install a key logger or think of it as a
password logger and thereby they can
recover your password so that's a
problem it's also prone to or subject to
call boot attacks what does that mean
essentially if and this is sounds like
you know science fiction but it really
in reality is possible if somebody were
able to get a hold of your device when
it's powered on with the password
entered even if it's locked they could
essentially turn off the device hold
down the RAM take out the RAM from the
device somehow and I'm not saying it's
easy but it's doable put it in some
other device boot it up and there are
utilities they will take the contents of
their RAM and essentially you know flush
it out to say some durable storage right
now you may think well hold on oh if you
take out RAM from one machine put it
there the other doesn't all the data
disappeared well no actually Rams retain
you know some of the data for you know
seconds to minutes depending on the
temperature and other other reasons so
basically as long as the password is in
memory it's potentially recoverable so I
know this requires more considerable
resources but nevertheless is doable
right so there are some you know efforts
to to essentially only keep the password
encryption password in in CPU registers
so it never really makes its way to the
rack that said this is pretty pretty if
you know easy you know we don't care
about it as developers we just assume
everything is encrypted we just you know
the entire data partition is encrypted
but to us all the i/o operations remain
exactly the same because the day
partitioning still data partitions is
that it's now mounted as an encrypted
device now in API 11 Android also added
support for DRM I have not actually
worked with it myself but it's an API
that allows om so device manufacturers
to plug in the different eight you know
essentially provide different DRM
plugins they call them you know schemes
to it which essentially is able to
authenticate and verify you know the
user rights to particular content and so
the idea is that your applications can
interact with the DRM framework which
then itself talks to this underlying DRM
infrastructure which you know with these
plugins and through that is able to
provide users access to you know
essentially content that's this you know
digitally protected or or rights to this
content of digitally protected so how
who uses this I'm not I don't think that
Netflix and Satori uses this especially
in the pre you know API 11 devices
because of gingerbread devices do have
it but nevertheless it's a step in the
right direction I haven't seen too many
you know compromises Obed nor I have
seen too many uses of it but
nevertheless it's there okay physical
access control so basically in Android
you know we have the screen unlock
pattern we have the you know the pin we
have the password and you know with
divisive men will talk about it we can
actually you know do more but
essentially through these mechanisms we
can at least restrict access to the
device with respect to as the card and
SIM card
you know while we can try to restrict
access to dos by essentially not giving
user access to the device right or to
you know to to use the device and see
what's in the SD card unfortunately
these things can always be taken out of
the device so less they're also
encrypted and most the time they're not
you can assume that the content on the
SD card and potentially SIM card is
vulnerable okay so that's that's such a
we don't control physically well over
there anything there now low-level
access to SIM card is not available to
apps so this is not something that's
available to ops anyways device admit so
devices min is basically an idea that
was added in or framework I should say
that was added to to API eight so Froyo
we're basically the an application can
request privileges on the device that
essentially make applications be a semi
administrator of the device so what
exactly is that for well assume you have
an enterprise that you know wants to
enable users to bring their devices to
work their personal devices to work and
the users that want to be able to use
their devices to access corporate data
well the enterprise may say sure we'll
give you access to the corporate data
but in return we want control over your
phone so what they do is they
essentially provide you an app that act
requests essentially to become a device
administrator so you ask the system or
the user to become a vice administrator
and if the user says yes the app now is
able to do things like wipe the device a
lot of device require the apps the
device lock password be set monitor
device unlock attempts and for example
if there are too many attempts unlock
attempts automatically wipe the device
as a honeycomb require the device being
cryptid and as though of Ice Cream
Sandwich also disable the devices camera
so you can say well I'm sure if you want
to be able to do this app you won't be
able to use your camera that sort of
thing for again security privacy reasons
that enterprises have why would the user
do this well if they want to be able to
get access to their corporate data if
they don't want it they say cancel here
they basically they just don't do the
app with you know then choose what to do
but most of the apps would simply go and
say well you know no tough what you just
don't get you don't get to use it
essentially act we can can ask the
system to uninstall itself that's sort
of nice right train this is not from
monitoring other applications this is
really for it really has to do with
protecting data right so if the device
for example is stolen the enterprise can
send usually via something like c2dm
a code to this device and say wipe
yourself or if the user changes their
password in for example the enterprise
you know the this I they can again
through some sort of push mechanism
with this app and this app can now
change the password a lot faster of the
device right or they can ask they can
say well we acquired your password be us
a particular strength and then they can
enforce that policy on the device so
it's really about controlling access to
the enterprise data that now makes its
way onto the words that's really what
this is for please so you mean in terms
of how many times they wipe in and so on
and so on it's not something that's been
very publicly disguised and I'm not
seeing it I know a flash is a
particularly problematic in essentially
medium because it hasn't called you know
we're leveling mechanism whereby whereby
all the rights get distributed across
the entire medium in order to kind of
wear it down evenly so when you think
you're overriding something you're not
really truly overriding unless you've
already entire medium and and when you
do that you have to override it several
times alright so no I don't know
specifically how Android does it I
believe that they did it it is
essentially a full wipe how good it is
how it compares it's a good question Ken
routing so finally we get to the juicy
topic so routing so what's why routing
right or wihout
well access custom roms you know it's
one week people bought one thing that
you know people say when when they want
to route reuse old hardware you know
remove offending system apps like you
know how many of you actually use that
NASCAR application on your Verizon phone
you know get more speed if you want to
get rid of some of the bloatware right
um give better looks you know cyanogen
minam's arguably better-looking as some
of the other mods out there you know
like official mods um because it's cool
some people just like the idea of you
know having a gruta device you know jail
your jail jailbroken devices are cool
these days or you know you maybe not
want to root your device but there may
be a rootkit that Druce your device
anyway okay all this comes at a price so
we'll talk about let's talk about
routing so how to can so typically we
exploit some so there's multiple ways
okay one ways we exploit the weakness of
the system or the existing wrong right
all the system to gain route that
usually involves either
exploiting the kernel and they're
exploiting something that runs with root
privileges to give us essentially
ability to run some code our code as
root and then thereby getting once we do
that one thing we do is usually we flash
the recovery partition with a custom
recovery like clockwork clockwork mod we
then download an alternate wallet it's
already rooted most of the time although
we don't have to let's say cyanogen we
then reboot the recovery into read into
this new recovery essentially partition
usually through some special key
combination like power plus volume down
or something like that and then you
brought into the ROM and then one
usually ends up having something called
an su file which is essentially a binary
that has it it has a set UID bit enabled
and it that binary talks to this
application called super user
so what super user Super User
essentially let me let me grow back the
way this works the way you kind of get
root on these real devices is some app
requests route by running as you okay
that binary goes and grabs the PID and
the UID of that app and it goes and
checks in some local database sequel
database whether or not that app should
in fact we have ruined let's say that
app has never been you know prompted or
the user has never been prompted to
grant route to that app so what happens
is that the this su fires the super
users activity by the am command which
is some binary command exists on all
Android devices and starts that activity
and that activity now comes up and says
hey user do you want to grant such as
such application root privileges and and
you can say yes you know once always or
never and so whatever selection you
provide that it gets stored into
essentially the database your activity
terminates the add the su command checks
again the databases says oh so now I
know what the users you know select it
and then essentially goes in yeah you
know switches or set the set UID bit and
you know off it goes now that a process
rules okay let's go how you you
essentially control who gets through it
once your device is rooted now how do
you get root in the first place by the
way one thing I should mention is that
some devices like Nexus S Nexus One like
devices they are already unlocked
meaning that their their bootloaders are
unlocked or if they're not you can type
in something called fastboot OEM unlock
which usually wipes the data partition
and your your essentially the the blue
border now permits the fastboot to flash
an entire new ROM the rectum to device
you don't actually need to exploit any
weakness of the system it was designed
to allow you to install an alternate OS
just like your local PC at home is
designed to well up until now is
designed to give you access to the you
know 2000s okay now getting ruined
so these are some of the exploits from
the past so exploit D is basically that
was that was an idea where Android or
this exploit essentially took advantage
of the weakness in the androids init
process which is actually you have been
D on Android which is is what what it
does or what it did is that it allowed a
messages these this net' this net' link
key event you event messages that are
normally supposed to come from the
kernel anytime a new device is plugged
into or discovered in a system to this
you have nd these are allowed to those
messages or didn't check that they are
those messages in fact did come from the
kernel and that allowed our code to
inject essentially arbitrary
quote-unquote firmware to get executed
inside of this init process okay or you
have ND and essentially we would fake
and you device being connected to the
system and the device having some custom
firmware that there needed to be
executed in the routes or with the root
privileges and that DES I should give
this route we then go and flush the
recovery and we're done
yeah that's one way another one was the
rage against the cage exploit which
essentially took advantage of a weakness
in the ad PD which is this Android debug
bridge daemon that actually allows us to
talk to a DB or a talkie DB with with a
real assistant and what it did
essentially it created thousands of
thousands of adb processes and at any
time an ADB process would run it would
normally run as root and at the end of
its execution its fork itself
we handle the connection and/or to
handle the incoming requests from the
from the client and what it would need
do just before it handles the connector
of the lead request it would actually
change its effective user ID to the
shell user well the export here is that
you will essentially exhaust all the
available processes in the system so
that last step when you're supposed to
essentially switch to a non root user
which fails so the last essentially
command this last ad command you that
org last a TBD process that will run
would end up being running as root will
be left running as root and so then
you'll get root okay they'll require
that you as the end user essentially do
this willingly the last exploit though
this soft break slash gentle break is a
little more sinister in that it actually
takes advantage of a memory weakness
inside or I should say buffer over our
weakness in the baldy and so the idea is
and this was by the way available in
ginger break so it may still be on some
devices so essentially a specially
crafted command would full of all the in
executing arbitrary called code as root
so that's essentially how you get
through now the dot the danger with this
last one is essentially that you get
these root kits so the AE you know if
you download some malicious app from the
from the net that you don't know there
again you can't vouch it's also tonicity
that app essentially can have a this
exploit built into it it doesn't have to
prompt you to run it you can just run it
itself you know without shell privileges
and essentially it can get access or can
get root itself without you knowing
the problem with rooting ok so the
issues of routing is all of these things
like app isolation permissions data say
safeguards even encryption you know end
of this ideal device administration all
that falls apart when the device is
rooted
when something runs with root privileges
essentially can circumvent all of these
protections right it can change your
entire kernel it can we reflash the
entire device so that's essentially the
problem with routing you while it's cool
to have your device runs route if you
give a route to malicious app you can
it's game over
yeah you have to essentially
/ your entire device and hope for the
best that you know that you can still
recover your device essentially if you
want to get it back into a clean state
so when they should get through the
story I'll get to your question in the
end we have a couple more minutes left
and then I know people will want to make
it to the you know Romain geez and
that says talk so I want to finish this
up and then we'll take questions
afterwards how about that okay so so
what things Android is doing to prevent
or to protect against routing so memory
protections that are in place like no
executes to prevent code being executed
this is a hardware essentially a feature
that prevents code from being executed
on the heap or on the stack there's this
pro-police that prevents Wow helps
prevent buffer overruns or stack
walk-arounds safe IO produced in integer
overflows you know some special
essentially additions that Android adds
to play in places or to help manage
memory in a more sane way so that they
can avoid common essentially a memory
corruption issues that leads to to
buffer overrun weaknesses now one
problem though is that Android is this
this problem of shared libraries so in
Android shared libraries don't take
advantage at least up until Ice Cream
Sandwich all of this randomization they
can be applied to them called a SLR
which is an you know address space
layout randomization they can move
libraries anywhere on in the memory so
if some code is able to get a buffer
over an or induce a bar over it becomes
extremely hard for it to know where to
jump to in order to execute itself right
and so the way a traditional operating
systems deal with this is they
essentially randomize where you file
these libraries are loaded and Android
these libraries are pre linked meaning
their addresses are prefixed
so they can't be really randomized and
that is their prefix for performance
reasons so there are some you know
there's you know there's this is just a
proposal on how to deal with this
problem and I suggest you read the PDF
to get a full scope of it if you're
interested but while this was just a
proposal back then in Ice Cream Sandwich
this is finally reality so in Ice Cream
Sandwich we're actually going to get
true randomization of our libraries
loaded to become extremely hard to take
advantage of
advantage of the salt of this you know
known addresses in the library let me
just have a few more slides and we're
done
su Linux or Android this is basically
something that's again more of a you
know research slash you know pet project
in couple of you know IT shops but
essentially if we if you were to become
a reality it would enable us to run
almost everything in Android we not Ruth
villages so if any one of the androids
subsystems were if I compromise the
compromise would be more localized and
it would not be able to you would not
get fooled with privileges unfortunately
SEO Alex is not the the mode of you know
the most frugal thing on system
resources and it's not the easiest thing
to set up so it's something that you
know he taught you for example
experimented with but it's not it has
not become a reality or Android but it's
something it could in fact one day
happen because it is based on Linux tap
jacking when you mention this tap
tracking basically on Android is a
something that you should be aware of it
as developers so I'm sure most of you
know what toasts are on Android
well one of the things about toasts is
that they can in fact cover the entire
screen so one of the things that develop
malicious the app developers can do is
they can have an app that starts let's
say a system setting that say you know
changes some you know I don't know
security security setting on your system
and this the launch lesson activity and
then they launch this game like app that
essentially covers the entire screen in
a custom notification and maybe there
they'd actually their own application is
like a game actually bouncy ball going
around and the user is supposed to click
on the ball but what they don't know is
that those clicks actually go right
through the ball to the up to the
activity underneath right and though and
that activity didn't take those clicks
and if those clicks for example change
the behavior of the underlying system
that can tell potentially two
compromises there is something called
filter touches when obscured attribute
that you can add to all your sensitive
activities or UI widgets that
essentially will will prevent those
touches from being registered by the
underlying activity if there's a
customer to vacation on top of it which
is what your container should take
advantage of
and I guess the last thing is with
respect to best practices you know do
not or are void apps to require root
because root can then lead to problems
with you know your users experience if
you are using encryption be sure to you
know know what you're doing you know
otherwise ask someone who does make sure
your your particular components are not
exported or if they are exported which
means there can be used by other compare
you know other components make sure you
test for the inputs and/or use
permissions custom permissions so what
I'm gonna skip these slides and the
custom permissions something that you
should look into it's well documented in
Android and you know you can see how to
do this fairly easily if you can read
the documentation also consider is users
installing anti-malware applications
because they can scan apps being
installed for signs of malicious content
whether by checking their package like
these or checking their signatures
against some blacklist or whitelist and
they said you know give you hints and
want should or should not be on your
device so if you want it you can build
one yourself through package manager you
can get access to the install apps and
through package manager you know intent
you can get access to apps being
installed and you can then query them
for for whatever you want to signature
or names or some whatever and then
basically decide whether or not it
should be installed or uninstalled these
are the conservative security concerns
are minor I think we should be wrapping
up we're out of time
I will be say uploading this entire
presentation to our to our server or
later on and make it available just go
to this URL that I had initially so and
this NMR can that's the CEO slash and
sec and you'll get access to the latest
slides as well as the precision thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>