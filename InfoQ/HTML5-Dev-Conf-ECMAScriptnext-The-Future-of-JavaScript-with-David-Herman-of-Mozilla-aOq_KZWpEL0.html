<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 Dev Conf: ECMAScript.next - The Future of JavaScript with David Herman of Mozilla | Coder Coacher - Coaching Coders</title><meta content="HTML5 Dev Conf: ECMAScript.next - The Future of JavaScript with David Herman of Mozilla - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 Dev Conf: ECMAScript.next - The Future of JavaScript with David Herman of Mozilla</b></h2><h5 class="post__date">2011-10-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aOq_KZWpEL0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there's so much to talk about I can't
possibly fit everything into this one
talk so this isn't even going to be
complete but it'll give you a taste of
what's coming so I should introduce
myself I'm Dave Herman a lot of my
colleagues call me D Herman that's my
github ID my IRC Nick my twitter ID is a
little calculus which is a long story
you don't want to know and I love
JavaScript I've loved JavaScript for a
long time even when I was a teenager in
high school and was completely baffled
by it there was something addicting
about it and I've spent long enough with
it that like Doug I I know not just the
good parts but all of its warts and I
can see the little per level language or
jam of a language inside that's that's
struggling to get out so I love
JavaScript for the language that it
almost is so that's why part of my job
is to work on the ACMA tc39 which is the
exciting name of the standards body that
is working on the next version of java
script working on the future of
JavaScript and I represent Mozilla on
that committee so partly I'm here to
talk about new powers that we're
bringing to JavaScript there's a there's
a couple themes there's there's so many
features you have to start grouping them
and matically so the first set of
features i'll talk about are really
about doing things with javascript that
really you just can't do or maybe you
could do it but you couldn't possibly do
it efficiently enough to work in
practice and one of those things is
binary data there are so many things
that you need to do in a full-featured
platform that involve reading binary
files or communicating with binary
network protocols and JavaScript really
doesn't have any good data structures
for handling that so there was there was
some work by the Khronos group on a
typed arrays spec and I've now become a
co-editor of the type to respect but
we're working on sort of expanding out
the
kind of convenience and power of what
you can even do with typed arrays so the
kinds of things that you can do with our
new binary data spec are you can define
new binary data types that look a lot
like structs from languages like c
except that this isn't a static type
system here what I'm doing is a runtime
I'm constructing an object that's sort
of like a data descriptor so this point
2d here is actually a JavaScript object
it's a JavaScript object that describes
the structure of binary data so in this
case it's a struct with two fields
called x and y both of which are going
to be 32 bit unsigned integers here's a
color type that is a triple of unsigned
bytes so what can you do with that well
you can combine those into more struck
types you can you can mix and match
these you can define your own data types
that now describe the structure of
compact binary data so i can describe a
pixel as a pair of a point in a color
and i can describe a triangle as a three
element array of pixels and i can use
that triangle data structure to create
or sorry that the triangle type to
create a new triangle struct and the
cool thing about this is that actually
in memory this is going to be
represented compactly so all that data
is going to be laid out in a very
compact manner so even if you're not
doing any kind of i/o whatsoever the
binary data spec lets you describe data
structures in JavaScript where you
actually have control over the exact
layout in memory so that can be nice for
efficiency that could be useful for like
cryptographic protocols or algorithms
that operate over a lot of data they're
very data intensive intensive and you'd
like to have data locality but it can
also be then used for things like files
and network protocols okay so another
power that you really don't have in
JavaScript right now is the ability to
create private properties of of an
object and thanks to Doug Crockford we
all know that there is at least a design
that we can use this is sometimes known
as the objects as closures design
pattern and Doug really taught the world
how to do this so this actually comes
straight off of his tutorial we have a
container class here where we want to
have a secret property that's not
actually accessible to anyone outside
but maybe we want to have a method that
can actually refer to that in the way
that we do that is we create the method
inside the lexical scope of that
variable so that works but there's a
real downside to this which is that
every single time you create an instance
of container it's going to get a fresh
closure a new allocation of a new
function there's no way if we wanted to
have one single definition of this
service method to put that on the
prototype if we try to put that on the
prototype it suddenly no longer has
access to secret so it's kind of a rough
choice you're stuck with in JavaScript
if I if I don't care about having
private properties I can put things on
prototypes I get a nice sharing a lot of
the JavaScript engines heavily optimized
prototype look up in fact all of them
heavily optimized prototype look up so
you get really good performance you get
a really good memory usage but you don't
have private properties so in one of the
proposals for the next version of Java
Script we've introduced in the notion of
a private name or a private key so here
at the top I can create this key data
structure which is a special property
name that's not a string so it's not for
jable you can't guess it so somebody
else who doesn't have access to this key
has no way of knowing what the key is
you can decide who to give it to if you
want to but if you want to keep it
private you just keep it to yourself so
now so now what you do is simply assign
to the property based on that key
whatever you want and now you can
happily put your methods inside the
prototype so if there's anybody here
who's familiar with some of the security
patterns that have been catching on on
the web like object capabilities this
actually is very similar to that but
it's not just about security I've
that when I program the more I leave
things just sort of out there in the
open the more I accidentally trip over
them so sometimes it's nice to just hide
something and that way I know that
somebody who's not supposed to be even
accidentally using it isn't going to
trip over it there's some new data
structures that we're introducing so the
week map actually this one I believe is
already yeah it's it's already shipping
in Firefox I think it's in progress in
Chrome so weak map gives you a kind of
hash table where the keys can actually
be objects they're keyed on the identity
of the objects but but those keys are
held weekly so you can do things like I
just concocted a simple example here you
might have a tile-based map program like
google maps or yahoo maps and each one
of those tiles might want to be evicted
at some point if you're starting to load
too many tiles and at the same time you
might also occasionally have search
results that are dropping little markers
on top of the tiles and maybe you don't
want those markers to actually be
members of the objects themselves maybe
you want them to be a separate data
structure but you'd still like the
lifetime of the markers to be tied to
the tiles so if I have some tile that's
way out of view and I haven't used it in
a long time and I just want to let that
tile go the markers associated with that
tile are just as useless so those should
be able to be garbage collected as well
and the cool thing about week maps is
when you have this association as soon
as the key disappears the the value
disappears from the table as well this
isn't necessarily something you would
use all the time but it's a power
feature and I think frameworks are going
to start finding a lot of interesting
uses for this another one that I
probably don't have time to go into in
great detail but is really cool and
another sort of low-level power feature
that I think people are going to do a
lot with or what we call proxies so
these are meta programmable objects
these lets you create objects where
every single aspect of the semantics of
that object every operation you can do
with the object getting setting deleting
its
is actually under the control of the
program so you can define a callback
that handles every possible object event
that can happen to this object so
there's already we already have some
projects at Mozilla that we're doing
with proxies they've been shipping since
Firefox for I believe so one of the
things that we're doing is we're trying
to re-implement the entire Dom as a pure
JavaScript library but the Dom was
designed back in the day where it was
assumed that it was going to be written
in C++ and so Dom objects have some
really strange behavior that don't act
like normal JavaScript objects but
proxies give you the power to give your
own custom behavior to objects the
proxies can do more than just sort of
reimplement the Dom you can kind of
invent your own object semantics you
could do things like invent a new kind
of inheritance mechanism so again I
think this is a low level feature that
might take a while for people to start
finding cool uses for but I think
they're going to experiment with it and
they're going to find really amazing
things that they can do with them okay
so those may look a little abstruse this
one I think is a problem that everyone
I'm be willing to bet that just about
everyone in this room deals with this
all the time we all know that JavaScript
has this sequential run to completion
semantics and anytime we want to do some
sort of i/o we're forced to register a
call back that will be invoked later on
when the i/o happens and and I like to
imagine that sometimes JavaScript
programs look like trying to make
recipes where every single step in the
recipe involves flipping to another page
so if you imagine after you you pour a
half a cup of water into the pan you
have to go to the next index card and so
like how many times have you written a
JavaScript program that looks like this
I think the best name I've heard for
this is the Pyramid of doom
so the future that we're working on to
address this is a kind of interruptin
these are known as generators if your
Python programmer they'll look very
familiar to you they're originally
designed actually to be almost exactly
like the semantics of Python generators
some you could also call them co
routines there's some slight differences
with co routines so a generator looks
something like this it's a function with
this special star sigil that says okay
this is a different kind of function and
inside of a generator function you're
actually allowed to use this new keyword
yield and what yield means is I'm
actually going to stop the execution of
this function here and I'm going to
return to whoever was using the
generator and give them whatever
argument was passed to yield but I'm
going to save where I was in the middle
of the function so that you can resume
it later this is maybe not obvious when
you first look at it so here in this
example we have to yield statements and
it's when the the caller calls the next
method that we keep resuming it might
not be immediately obvious what you can
do with this but there's actually really
powerful idioms you can do when you have
the power to stop what you're doing in
the middle so one of the things that
I've been experimenting with is a new
library called task j/s test jeaious
gives you something like a sort of
lightweight threading in javascript but
with none of the painful walking or
anything like that from java but what it
lets you do is the kinds of i/o that we
do in javascript all the time where you
can say i need to stop what I was doing
right now and don't restart me until the
event that i'm waiting for has occurred
and then just pick up where I left off
so here you can see i'll do an xml
httprequest and ask for a file and then
stop I'll call yield wait for the result
to come back in a string find that to
the text variable and now i can continue
and i can do a timeout and i can say
wait a thousand milliseconds and stop
don't resume me till
that time out has happened and then
start me up again so all of a sudden
there's no more pyramid of doom we're
actually writing what looks like
sequential code again but you can still
tell that it's a run to completion
semantics because you never stop what
you're doing unless you explicitly say
the keyword yield so this gives you a
nice compromise between not having the
kinds of preemption semantics you get in
a multi-threaded language where at any
point anybody could could stop you and
mess with your program state it's only
when you decide you want to interrupt
your program but it lets you write in a
much more natural style so task jess is
a really fun project i'm experimenting
with different scheduling policies and
invite you to check it out on github and
if anybody's interested i'd love to have
more collaborators alright the next
feature is maybe the single most
important feature in my opinion that's
coming in JavaScript and that is the
module system so in my mind one of the
great one of the big motivations for
modules is that javascript still has a
lot of catch-up to do in terms of
building a huge repository of useful
reusable libraries we're getting there
nodejs has made great strides they're
using common j/s because of that they've
got the NPM package manager so you're
starting to see already just with the
creation of that one repository
thousands of JavaScript libraries are
showing up but we don't really have the
same thing for browser-based JavaScript
we really don't have the you know the
great repository of JavaScript libraries
and I think a big part of that is
there's friction created by the fact
there's no module system built into the
language there's no one standard way
that you can package up your code and
ship it to somebody else to reuse one
way of looking at this is when you start
up a JavaScript environment the
environment just sort of hands you this
really malleable ball of clay so that's
the browser and that's your empty script
tag and there's a lot you can do with a
ball of clay especially when you have
Doug Crockford to teach you all the tips
and techniques for sculpting but
sometimes it's nice to just have a
little bit of
structure come out of the box so what is
Doug taught us he's taught us the module
pattern and the modular pattern works
pretty well and it you know it could be
worse but it's a lot of boilerplate that
you have to write just to create a
simple simple module in JavaScript so
this is probably familiar to everybody
the idea of the module pattern is you
wrap your code in an immediately invoked
function expression in that way you're
guaranteed that you've got a fresh scope
you're not going to pollute the global
namespace and then you represent the
result of creating the module as an
object whose exports are the properties
of the object so this is doable but
there's a lot of variations on it
there's no standard way of doing it and
you really don't get any help from the
language so as a language nerd whenever
IC design patterns I think of those as a
sort of crying out for help from the
language its programmers saying this was
something that was missing from the
language we figured out a workaround but
we really would have been happier if you
had built it in to the language in the
first place there's a quote from Paul
Graham that says whenever IC design
patterns I wonder if these are not
evidence of the human compiler at work
and as a language nerd again I don't
like being a compiler I'd prefer the
compiler to be a compiler so the model
system in acma script next just lets you
say exactly what you meant you can
define a module you can give it a name
and you can say what the exports are
simply by labeling them as exports
there's actually a lot more to it and I
could do I have done entire talks just
about the module system one of the
really nice new powers of this module
system is that you no longer have to use
the script tag to get external files so
when you import some of the exports from
a module that came from an external file
the semantics guarantees that this is
loaded once so you can you can import
from the same file multiple times and
it'll only be invoked once
and notice that it's doing I oh but we
don't have the pyramid of doom so it's
actually doing all of the loading before
execution starts so there's no danger
that your code just starts blocking
arbitrarily in the middle okay so
another theme of of JavaScript feature
of the next version of java script is
features that add expressiveness to the
language and one way of thinking about
expressiveness is it's about helping
with the the problem of the death of a
thousand cuts there's all the little
paper cuts that we suffer through every
day as we're writing JavaScript code the
fact that the arguments array is not
actually an array so we can't use any of
the array methods on it the hosting of
our the the function scoping that that
Doug talked about this morning typeof
null that's just kind of weird so we're
just adding a lot of new conveniences to
the language that probably should have
been there in the first place instead of
having this this arguments variable that
you can refer to that has the entire
array of arguments well sometimes you
only wanted the rest of the arguments
but you want to name some of the other
ones and the simple syntax of three dots
followed by a variable name just lets
you do exactly that you can you can bind
the remaining arguments and this time it
will be a real array you can actually
use all of the array methods on it and
furthermore you can actually use the the
dot syntax to splice in actual arguments
when you do a function call or when you
do cuz when you call a constructor for
the language lawyers out there this
bottom one actually was impossible to
express in es3 and there's one little
detail of es5 that accidentally gave you
the power to express this and that's a
function dot prototype top bind anyway
another one is default arguments default
values for optional arguments this one's
just you know you can you can write it
but it's
pain to write it and you'd really rather
just be able to write it like this so
we'll just have that work out of the box
this one again Doug talked about this
this morning the the let construct as
opposed to VAR so you can just think let
is the new VAR anywhere you would have
used bar in the past replace it with let
and chances are your program is going to
work better unless of course you know if
you've always followed crocs rules and
you put your bars at the top of the
functions your programs going to act
exactly the same but now you can
actually bind things in a local block
and get the semantics that you expect
destructuring this one is in a lot of
other languages but for people who
haven't seen it it looks kind of
surprising at first and then once you
start using it you wonder how you ever
lived without it this saves you so much
typing so here we have pink color as an
object that has r g and b properties and
instead of having to write three
statements that say VAR r equals thing
color r VAR g equals think RG we get to
just automatically unpack the contents
of that object in one single operation
same thing with arrays this makes it
nicer to write functions that just
return to pools and you can just unpack
them in one in one go you can also use
it for cute idioms like swapping so here
without actually naming a temporary
variable you can swap the variables a
and b and anywhere you do a variable
binding or a variable initialization you
can use destructuring ok how are we
doing uh we've got a lot of new
conveniences for object literals so the
first line is the syntax everyone's from
the first line inside the object is
syntax everyone's familiar with but the
second one is just a convenience for
defining methods so you don't have to
write f unc tion you can just write the
name the / ends and the arguments and
the body this is something to this day i
accidentally type it without even
thinking
it's just sort of my fingers I've always
wished that feature were there and now
it will be there and then the third one
is is really nice this is something that
you can't do without doing an extra
assignment outside of the object literal
you can actually dynamically compute the
name of a property that will also be
useful for private names so you can
define a private key outside and then
you can inside the declarative object
literal you can refer to that key
alright just a few more everybody knows
that for in only does what you want
about half the time it's got all sorts
of problems with prototype leaks and one
of the most common bugs is people do a
foreign loop over an array expecting to
get the elements of the array and
instead they get the indices of the
array originally we were thinking about
actually extending the for in loop and
sort of reforming it but most people
felt that that was going to be too deep
of a change to the language it was going
to be too difficult to migrate existing
code so we introduced a new syntax the
four of loop so a mnemonic you can think
of is the keys are in the object and the
values are of the object so if you do a
four of loop over an array you'll get
the values that's that's what you expect
in fact if you do the four of loop over
any object you're going to get the
values instead of the keys of the object
but will also give you some sort of
batteries included some built-in
functions that lets you create that lets
you describe custom arrays that you want
to iterate over our custom sequences you
want to iterate over so you can say 4x
of the keys for X of the values for K
and V of the items so that'll be a
sequence of pairs this code is just a
little bit easier to communicate exactly
what your intent was wherefore in is is
pretty hard to unpack and in fact the
four of loop we're going
to make extensible so you can define
your own custom sequences by defining
what's called an iterator object so if
you add the iterate property to any
object and this is going to be a special
shared name object iterate instead of
polluting the public namespace you can
create your own custom iterator object
and now you can do a four of loop over
that object with whatever custom
behavior you want once you have custom
sequences then it's really nice to add a
sort of syntactic sugar or syntactic
convenience for what are known as
comprehensions in languages like Python
and Haskell so here we're very concisely
describing an array whose elements are x
times y for each value X of object 1 and
for each value Y of object to and this
syntax actually goes back to math this
comes from the set comprehension syntax
in math but it turns out that it's
pretty easy to give it a straightforward
semantics in a programming language and
it turns out to be really concise and
convenient to use ok tangled up in
strings so much of web programming
involves hacking on strings we're
embedding we're embedding bits of
fragments of HTML we're embedding
fragments of various kinds of languages
and all you get in JavaScript the only
syntax you get in JavaScript to string
literals and Plus this is a obviously a
pain I think that Doug has left so he
won't hear what I'm about to tell you
we will give you multi-line string
literals there's no backslash at the end
of the line you just write it as long as
you want if you don't mind the
indentation thing like he does this will
just work as you expect but without the
hazards of whitespace following the
backslash notice that this is using back
tix instead of the normal string but we
also have string interpolation like you
get in so many other languages in shell
scripting and PHP and Perl this is this
is a very often requested feature in
JavaScript and it just makes it so much
nicer to read the code but we're
actually going to take it one further
there's an optional prefix that you can
add to one of these literals and what
that prefix actually does is it
basically says you can refer to any
function here and this function is going
to get the contents of this string sort
of nicely organized into the literal
parts and the interpolated parts and you
can write your own sanitizers so it
makes it really really easy to write
sanitizers for things like HTML to
prevent injection attacks so in addition
to getting some of the convenience of
nicer string literals you also get a
very convenient way of writing
security-conscious code okay so that was
sort of my whirlwind tour of a lot of
the features it's not a by no stretch is
that all of the features that we're
considering and I'm happy to answer any
questions if people have been following
on yes discuss or on the web but I just
want to address the number one question
that we always get which is well that
all sounds fine but it takes years for
these things to roll out how long do I
have to wait before this is actually in
the hands of enough of my users that I
can really use these features and that's
a fair question and here are my answers
first of all it's our job on this
committee to work as fast as we can to
get this stuff out as soon as we can so
the next edition of the spec is targeted
for 2013 which is coming sooner than you
might think but as vendors like at
Mozilla we don't have to wait for the
spec to be
finalized before we start shipping
features so for example proxies and week
maps are features that are fairly stable
in the spec and we've already shipped
preliminary versions of them in the
browsers it's always a guessing game to
know exactly you know what might be more
likely to change by the time the spec
comes out but this is just it's
important to remember that the due date
for the spec is not the same as the date
at which the features are getting in the
hands of users that said we're still
talking about bleeding edge browsers
worse you know we still have a laggy
market so I think there's one other
approach that well there's an approach
that I'm hoping will help and we're
starting to work on this Brendan Eich
has talked about this in several of his
recent talks and this is the idea of a
transpiler so transpiler is just a kind
of compiler that goes from sort of a
high-level language to another
high-level language or that does a very
lightweight compilation coffeescript is
the canonical example Google already has
a transpiler for what they'd like to see
as the next version of of akma script
it's not exactly what's in this FAQ and
the spec is still ongoing we also have a
javascript in javascript implementation
called narcissus and we're working on
doing a language sim ourselves just as
an experiment but it's my hope that we
can actually get to a point where just
like doing CoffeeScript development you
could write in the new version of the
language but then compile it down to a
more backwards compatible web compatible
version of acma script so what we're
hoping is this will let people start
using the language before it's actually
shipping in the browsers and as a
stopgap they can compile down to the the
version of equi script that is in the
browsers but in time when there's native
support for more and more of the
features they can use less and less of
that compilation and get better
performance and possibly a better
debugging experience okay so that's our
little tour of the future of JavaScript
I'm happy to take as many questions as
people have and I'll try to stick around
a little bit but then I will have to
rush off back to
my Master's back in the room full of
futuristic language nerds so thanks very
much for your time and attention so the
question is are there any features from
the old version that have been removed
this is a subtle question because in one
sense you can't ever remove anything
from the web or you there's very little
that you can remove but the new version
of the language is going to have an
opt-in language type so you'll actually
be opting into the new version that
means we do have some flexibility to
break some compatibility and remove some
features so we are doing that in fact
even acma script five strict mode
already did that so for example the
width statement is kaput it's gone we
will do a little bit of removal but we
want to keep the migration costs as low
as possible we want people to be able to
take their existing code and start
moving it into the new version of acma
script so we're going to be very careful
about what we were so that's a very
astute comment the the way that you
create the struck types is assuming that
they're in order and the answer to that
is in practice on the web if you have
alphabetically named properties they
actually are ordered so for now we've
been going with this because it's the
nicest syntax but if we can't actually
nail down the semantics of some amount
of property order will be forced to make
a more verbose syntax it's my hope that
we can have this nice pretty syntax but
we'll have to that's still an open
question we have to nail that down so is
the question what's the future of
classes and inheritance in JavaScript
yeah that's one that's conspicuously
missing on my slides it's one of the
more controversial pieces in its we've
started working really in earnest on
classes fairly late in the cycle so
there's still a lot of discussion going
on in fact that's the topic of this
morning that I'm missing right now is
classes we've come to a lot of agreement
about a lot of pieces and and we've
talked a lot with the community
and most people say I don't want
anything that even smells remotely of
Java that that is the message we hear
loud and clear but what we're talking
about when we're talking about classes
is something much more like coffeescript
it's a nice syntax that gives you a
convenient way of expressing the
patterns that people already use in
JavaScript so it's a constructor
function that has a prototype object and
it would be totally interoperable with
existing constructor functions with
prototype objects this turns out to be
one of the ones where the semantics is
not really the hard part we know the
semantics should be do what JavaScript
already does the syntax is just really
tricky so the this is a sort of like UI
design it's getting the the layout of
the syntax just right is really tough
but we're working on it and it is still
I mean it hasn't been cut from the set
of features but the discussions are
still ongoing the question is is
Microsoft on board with this microsoft
works actively on the committee and only
they could tell you what their company
strategy is I there's there's there's no
way that I I don't have a divination rod
here I can't guess great question so the
question is can I can an existing object
be turned into a proxy the currents
proxy spec only lets you create a new
proxy from whole cloth it doesn't let
you go around and muck with the sort of
meta semantics or the the underlying
behavior of an existing object there's a
lot of things though that would be
really nice to be able to do like you
already can add getters and setters to
an existing object it would be nice if
you could add prox evil behavior to
existing objects there are proxies are
something that hook in at the very
lowest level of the language semantics
and so it's a very delicate thing to
design each piece we are having ongoing
discussions about which parts of the
proxy API would work would make sense to
let you add to an existing object
there's a good chance that that won't be
ready in time for the next version of
the language but one use case that
Microsoft actually brought up on the
committee was if you want to do data
binding so if you want to have objects
that you can listen in on think changes
that happen to them you don't want to
have to force them to have created them
as proxies in the first place you'd like
to be able to take some existing object
and say hey I want to listen in on these
different events so there are definitely
strong use cases for being able to add
proxy behavior to existing objects but
the first version of the API doesn't let
you do that okay I don't wanna keep
anybody from lunch so thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>