<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Simplicity In Scala Design | Coder Coacher - Coaching Coders</title><meta content="Simplicity In Scala Design - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Simplicity In Scala Design</b></h2><h5 class="post__date">2013-03-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Pqh_QFFzIlI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Bill manners i'm going to
talk about simplicity in scala design
and what i want to do is give you 10
rules of thumb that you can hopefully
take away and use and make your users
lives more simple and the focus is
really not simplifying your library
design but simplifying your users life
when they use your library and you can
you can actually make your library too
simple and end up complicating your
users lives but you can of course also
make your library way more complicated
it needs to be and also complicate their
life so so the the main idea is that
programmers are people and so when you
design libraries you're designing them
for people and you have to consider
human factors so the first guideline is
designed for busy teams so the two key
words there are busy and teams
interesting software is written by teams
not by individual so you it's not enough
to just think about how the users are
going to do something you need to think
about how are people going to kind of
gather around your library and use it
together to do something so for example
there'll be different kinds of different
levels of people and so how are they
going to read each other's code that's
the kind of thing you need to think
about and busy is basically you don't
want to assume that all your users are
going to be experts in your library a
lot of them will be casual they're
focused on something else not you or
your library and the way I like to think
about it is renting a car so when I go
on a business trip a lot of times I'll
run a car and I want to get in that car
I have never actually driven that kind
of car before and usually well there's
always I think a manual in the glove
compartment but I've never read it I
always can just kind of look around and
figure out how to drive off the car and
I go off to my hotel right so it's a lot
of users will actually it's good to have
documentation but you want them to be
able to use your library without
actually reading the documentation that
to actually make it simpler for them and
I think if when we bought a car i
actually did read the owners manual but
I've never read one at a rental car and
so this is sort of idea that not every
user wants to buy your library they just
want to rent it for a while to do
something and what the really focus on
is what they're trying to get to using
your library as a vehicle to get there
so i wanted to show some counter
examples of bad RL design problems that
are mistakes that I made so this is
something in Scala test that you can say
both of these things and they'll both
compile so what what happens if you say
21 should be 20 plus or minus five I
will hit return there whoops well that's
right again 21 should be put 20 plus or
minus five is it accepts that if you
change that to equal basically by not
throwing exception it says that it is it
actually complains that 21 did not equal
intolerance 25 right so this I did that
on purpose because I thought it was
important in in mattress to have a way
to always call double equals so I
thought well be well have these special
cases if you pass this kind of type 2
it'll do something special eat will
always call double equals but over the
years a couple users reported this as a
bug is this is not working right and I
pointed them to the documentation
because in the documentation it says it
works this way I mean this is working as
specified so technically it's a user
error but really i think is my fault and
the reason is my fault is not because it
isn't it reasonable to actually do that
it's not unreasonable to say i want some
matcher that always calls double equals
and it was also documented right so that
wasn't the problem the problem is that
because it looks like it should work to
actually know that this won't work you
have to read the documentation so that's
like if I get in a rental car I have to
actually read the manual before I can
drive off right so that's an example
okay so one of the things that Scala is
a good
that is you can really make client code
look however you want so it's very
flexible very powerful and to help teams
work together what I think is good to
keep in mind is use it to make code
clear so the way I try to make code
clear at first I try to make it drop
dead stupid obvious so when someone
looks at they know exactly what it means
they don't have to look it up right
sometimes that's hard to do so the
second the fallback is make a guessable
so that when you look at it they'll say
well I'm not sure what that means but I
think it might mean this and whatever
that is that is what it means all right
so they can guess what it means and move
on and then if sometimes that's hard to
do so the third fall back is to make it
easy to remember so they're going to
have to look it up the first time I see
it but it's nice if they can actually
look it up once and remember it after
that but you don't want is every time
they see it in the code they have look
it up again at the end it again right
okay ah yes sorry this is um when I
actually wrote plus or minus out
longhand like that really long hand the
reason I did that was I wanted it to be
obvious right so when you read plus or
minus you know it means plus or minus I
considered a couple of different
operators and I didn't choose him
because I weren't sure they were
actually going to be guessable but over
the years I did decide that you know I
did some informal surveys and found that
people would guess when you see a plus
minus that it means plus or minus so I'm
actually changing that to to the plus
minus operator but it's really it's I
think it's good to be very conservative
about making code really obvious ok so
both readers and writers are important
code is read and written I think it's
read more than it's written so what I
think is good to do is try and make both
readers and writers happy if you can and
sometimes their intention like you know
plus or minus is very long-winded it's
really obvious to the reader but it's
kind of pain to type right so it's good
to try and find something that solves
that tension and makes them both happy
but when you can't sometimes it's hard
to do I think it's good to favor the
reader so an example of that where I
didn't actually make this
steak but I considered it there's a way
in Scala test to invoke private methods
to test private methods I think it
should be rare that you do that most
times you don't need to but occasionally
it's useful and so I put this syntax in
there and the way it it looks if you
said object decorate one you to get a
compiler error because decorate is a
private method so you replace that dot
with this thing this thing that says in
both private and it's very long-winded
but I think it actually when you're
reading the code you don't know what it
means it kind of says in both private
and then you see a method well it looks
like it's invoking a private method
right the thing I considered was this
you know it seems like a good good use
for a symbol right symbolic operator and
I want to consider was his lightning
bolt because it's kind of its like
lightning strikes the object and a
private method gets invoked right so I
considered it but I decided for readers
it's too non-obvious right and
especially because I'd expected to be
used rarely the the method name is very
long-winded invoke private so another
thing I could have done is make a
shorthand for it like prive and the
reason I didn't do that as simply
because this is rarely used are expected
to be rarely used in fact I want to
discourage from being used a lot
but if it was used a lot I would
probably do something like see which is
a shorthand it's easy to remember right
when she would learn looked it up ok so
the other thing about people is they
make mistakes right so one of the things
that it's important to do i think is to
imagine or kind of figure out what you
think what kind of mistakes people can
make and make them either impossible if
you can or if you can't make them
impossible to make them difficult to
make and so most times your users aren't
sitting in a room with classical music
playing and sipping tea and using your
library you know they've got deadlines
they're crawling through the mud they've
got bullets whizzing past their heads
and they're going to screw up so if they
can screw up they will over time so an
example of how I I think i did make
something less well air resistance
it is on the way test this is test
framework tests should be run in
parallel because they're embarrassingly
parallel I zabal CPU species aren't
going up right you getting more cores
and so on so but the problem is that it
basically if you're running your tests
in parallel it's a concurrent program
and people don't have time to make it
work make it thread safe and make it you
know make sure you don't have any
concurrency bugs so the first thing I
did was made sequential a default so you
only get parallel if you ask for it the
second thing then if you ask for it is
it doesn't actually run tests in
parallel in a class it just runs the
test classes in parallel and that's
usually going to be enough speed up but
occasionally you do need to run tests in
parallel and then you mix in this trait
to get it and that's where I think the
most of the danger is because even
though I try to encourage people to not
use shared mutable state in their test
classes with examples and occupation and
whatnot people will do it right and so
now if you're running those tests in
parallel you've got shared mental state
you've got a synchronized access to it
right so what I did with parallel test
execution is when you mix that in it
runs each test in its own instance so
that each test gets its own copy of that
potentially shared mutable state so it
is not impossible to screw up but it's
hopefully difficult that's just kind of
the trying to prevent errors by how you
design it but the other thing Scala has
that is this very rich type system and
so a great way to prevent errors is to
make it a type error all right when they
do it so an example of that is this
parallel test execution is a a trait
that you can mix into most style traits
but not all so it actually doesn't work
in j unit suite j unit sweet it doesn't
work in j in a suite because where's my
Scala prompt there it is it doesn't work
in j unit sweet because Janet this this
style trait actually delegate CJ Yoona
do everything so you got to do it Jay
units way so it just doesn't work but
that's an easy mistake to make right I
mean you wouldn't know that without
looking at the documentation but when
you try to mix parallel test execution
into J units week you actually get a
compiler error and it's a type error
because parallel test execution is not a
valid subtype of J and it's sweet
because
trying to override a method its final NJ
unit sweet so that I mean it's really a
great type system and you can use it for
preventing errors if you think about it
that way so okay so another I think the
main reason I can get in a rental car
and just drive off is because i'm
familiar with cars and so you can
exploit that in your design to make it
easy for people but it's a two-edged
sword because a lot of times you may
actually be designing a library because
you want people you think people doing
things the wrong way and you want to do
them better way right so if you only do
what's familiar you can't do that right
but what you can do in that case is is
leave the stuff that you don't care
about that you think is okay that
they're doing the same or similar so
that they're comfortable and then just
change the things that you think they
should do differently so an example of
that is java the java language itself on
several occasions i saw james gosling
say that he kind of fooled seat
programmers by his design of java and
one time he called it a job a
well-orchestrated fraud that's what he
called it and what he thought his
opinion was that C programmers are
spending too much time doing memory
management right chasing down memory
bugs and they should use a garbage
collector but C programmers myself
included were we didn't trust garbage
collectors are going to take too long
right this time to be too slow so what
he did is he made this language Java
that looks a lot like see them while
loops the for loops you know a lot of it
looks the same the semicolons the curly
braces but there was no way to free
memory right so he makes us feel
comfortable but he didn't give us a way
to free memory so now we did change that
behavior and that worked so so in when I
first started writing tests I wrote them
like this and this was the way people
wrote them this was way back when j unit
first came out what you would do is
you'd write one test class per class
under test I should have say extends
test case up there and then then you
write one test method / method you're
testing so I'm here I'm testing the size
method that I'm testing the head method
right so behavior and Velma came out
there a lot of ideas kind of mixed in
under that umbrella but one
them was that you should write you
should focus these tests on one bit of
behavior and write a descriptive test
name and a good way to do that is to
make it sound like you're specifying the
behavior so I thought that was a good
idea and when I made this fun sweet
class fun sweet looks a lot like xunit I
mean everything is pretty much the same
with xunit accept it encourages focus
tests with descriptive name so the one
thing I changed was the way you you know
the test name is a string now so it says
test test test just like j unit 32 just
like you see at testing j unit 4 so it's
similar but that one thing is changed
and so that that's an example of just
changing the one thing you think people
should how you know change their
behavior the other thing is there's a
lot of stuff in the Scala library that
you can extend and then people will be
familiar with that library construct in
sort of your incarnation of it so the
way for example you compose mattresses
on top it's just function composition
match your in Scala test is just a
function one it has a composed method so
if you are familiar with function
composition from Scala you know how to
already compose matters and if you're
not you actually have to learn something
about Scala that's generally useful
right so so I think that's a that's sort
of exploiting familiarity and the other
thing is this table the way you do table
driven stuff in Scala test is you make
you say table and then you have a bunch
of tuples the first one is a tuple of
strings and that's the column headings
like this is column in and this is
column D and you have the tuple of the
data and then you can say for all
examples in should not equal D that's a
sort of contrived stupid property check
but that's the syntax right but you can
also say examples for each print line
because which comes back when you say
table is in this case because there's
two columns you get a table for two
right and if you have three columns get
a table for three and that extends table
for two extends seek of tuple to an tint
in this case alright so it is a Sikh and
you already know how to use a Sikh so if
you want for example let's say you got a
bunch of columns in the CSV file and you
want to pull them in and put them into a
table and they do a property check on it
you already know how to do that because
you already know how to use a Sikh right
so anyway reusing things in the Scala
library because you know exploits
familiarity in a good way so I I think
people do want documentation definitely
and they want documentation that
actually matches what the thing does but
they don't really want to read it
because they're in a hurry right but
they really like examples and that's
because they can do this so they can
control C control V right and then i'll
just see new sets back execute basically
people want to copy and paste because
it's fast so when you do documentation I
think it's good to try to include a lot
of examples and that really helps people
get moving and it's also an opportunity
to influence their behavior because if
you think they're doing it the wrong way
and they should do it a different way if
all your examples show that different
way that's how they're going to do it
because it's easier right okay so
another thing I think you should do is
get rid of sorry it was too easy so it
is to get rid of redundancy right
there's uh there's a this notion of
surface area your design has it library
has a surface area and to find something
you need the more stuff that's in there
the more you gotta traipse over right
but there is a certain kind of
redundancy i think is good and this is
actually from the Python community I
wanted to pull this up because there's
something called pep 20 which is like a
sip for Python and it's the Zen of
Python pep maybe we should have a Zen of
Scala sip but in there buried in there
says this sentence there should be one
and preferably only one obvious way to
do it I think it's actually a good idea
right because then that's the way to do
it right but there isn't a kind of
redundancy that I think is useful and
that's this so this is the screwed I
took a picture of my screwdrivers and
what happened about three years ago we
had to had some work done our house and
all my tools disappeared so i had no
tools and i decided i would just only by
a tool when I needed one so this is how
many screwdrivers I have so far but my
toolbox be simpler if I just had one
screwdriver well actually it would be
simpler right it'd be easier to choose
which screwed i'm going to use but my
life would not necessarily
be simpler my life might be more
complicated right because if I if I need
to have a screw if I have a screwing job
that doesn't really fit my by one
screwdriver then it's you know hard my
life is more complicated right so it's
okay to have some redundancy like this
where each one is focused on a different
task so like there's a bunch of
collections in Scala but each one has
different performance characteristics
right what you want to avoid is this
kind where you got a bunch of a bunch of
choice where all you get is like I feel
like a blue handle today so I think in
Scala test there is there is a lot of
choice the one that's like this there's
really only one thing I think is like
this which is should vs. must so I think
it was a mistake in retrospect to have
both of those I really should have
picked one but there is like several
style traits about that many style
traits to choose from they are actually
each one focused on a different job but
what was what i learned that i made the
mistake I made was in explaining them I
didn't really summarize what each one
was for so it was hard for people to
figure out what they were for without
reading all the type of the details so
if you do have redundancy like this you
should you should try to make it easy
for people to figure out which one they
need because the skreet or i can just
look at and figure out which I need
right but fun sweet for fun spec who
knows what that means right so I added
these little call-outs at the top of
Java dog or the Scala doc sorry you know
it says just real quick what each one is
for right and then I also added a table
in the user guide that sound of gives
you a summary right so there's there's a
table in the Scala book and online that
shows all the different collection types
and whether performance characters sorry
that helps people pick ok all right so
another thing that's useful for people
is if you if things are consistent right
so if they are used to doing it this way
and they've learned to do it this way
over here it should work that way over
here and
I have a phone call that's this a really
good time I should answer it should I I
know um I was hearing this buzzing noise
like what the heck is I think somebody's
phones ringing at least I had it on on
buzz but it is somewhat distracting uh
okay so basically consistency so when I
show you example in a mistake I made
which was not my fault but I made this
mistake so in in Scala set if you just
say set you get an immutable set if you
just say map you get an immutable now
what do you say seek you get a general
one that could be mutable or immutable
and at one point I wanted to change into
todo into in one dead oh this was back
in 2007-2008 and list was the rage right
and so now vector is the new black right
so i thought it was wrong to have lists
of being returned because because it's
easy to to actually use it in an
inefficient way and i talked to josh
sure if about it and he sees I didn't
want to return Victor I thought that was
too specific he said you should return
immutable index seek and I agreed right
so that was my plan so what did I right
in Mike wrote I wrote index seek because
doesn't that mean immutable index seek
so actually release that in a milestone
really so I screwed that up and it's not
a big deal but I found out and I change
it but that because of that and there's
actually good reasons that it's like
that but because that's inconsistent
people will screw that up so you got to
try to stamp out the inconsistency so
symbolic operators i think is probably
one of the most important ones that i
have to talk about today so the
guideline is used simples when your
users are already experts in them so i
think this is an example of what they're
good for so the first line of code is
when you use java math beginner from
Scotland you say a squared plus B
squared the second line is Scala math
begin at your a squared plus B squared
and the second line is better and the
reason I think it's better is because
we're all experts in those operators
those symbols all right so that's why
it's better but what happens is that
this is just very tempting to use and so
I think when I look around at libraries
in the
in the community I think that's sort of
like the biggest crime or not crying but
you know the biggest problem with them
is they over use symbols and i myself am
guilty of it so way back when I was
trying what I wanted to do was get rid
of make it so you can write anything in
a specification so if Eric tour bar who
does specs to he had the same goal so he
and I did the same thing we both made a
bunch of non-obvious operators that you
connect text with right so I did this
back in two thousand seven or eight and
what the way it worked is I put two
dashes after a stack and that means I'm
opening a scope and i'll be talking
about a stack and then one dash after
another string that means i'm
introducing a test right or an example
and i actually put that in the you know
checked it in and it was going to do it
then I realized later that probably is a
bad idea but the problem is i had
actually sent the programming and scala
book to the printer in the meantime and
it had one of these examples in it so
one of our goals was that every bit of
code in that book would compile all
right so I was like oh man I have to
release this so I released it in 09 for
deprecated already and and I said don't
use this and and 095 I removed it right
but the problem is is this there's just
too cryptic right i mean it's really
going to be confusing what dash dash
means what single dash means and it
doesn't look like it so a couple years
later I did actually solve it by using
in to introduce the test so that's
consistent with word spec and flat spec
and inspects one expects to so
everybody's used to seeing that to
introduce a test and then I can just use
one dash up there and that's a
non-obvious operator indeed but it i
think is guessable from the context
right and when there's just one of them
i think it works so so another thing
that i wanted to talk about is that what
sometimes people will do is when they
make a non-obvious operator they say
well i know i'll make a word that's a an
alternate if that's more verbose but
spells out what it is so people have a
choice right I think the problem with
that is it's the writer that has the
choice in the reader doesn't have
choice right so if you use / colon then
I have to read that and remember what
that means so too so I don't think that
actually is a good way to do it and I'm
going to try to illustrate that with
this so this is a and B or ends I can
now in in Scala 210 say a star B plus B
star be a star a plus B soiree to say a
squared plus B squared but I don't have
a way to do it with words right should
we add that in Scala to 11 so that
people have a choice all right they can
either use the operator the symbols or
if they don't like those they can use
the word right that seems pretty stupid
clearly the first one is better because
we're already experts so in that kind of
situation you should use a symbol and
not have a word otherwise maybe you
should word use a word and not have a
simple right so the only other thing I
would say about that is one of the
reasons people use symbols is to get rid
of parentheses and and I like to get rid
of parentheses to but I think most users
who are in a hurry would rather have
some parentheses around code that they
can actually guess what it means then no
parentheses around code that's cryptic
that they have to look up what it means
okay so the last one is minimize the
magic and the compared to like Java
Scala gives you a not just a magic wand
it's like a magic baseball bat I mean
it's you can really slather on a lot of
magic and I think definitely you should
use sufficient magic to to sort of make
your users lives better but then you got
to stop because I think the more magic
that's in there they can actually make
part of the reason belt and also makes
code slower to compile so I wanted to
give you guys since it's a very touchy
feely talk I want to give you something
that actually can measure so what we've
been doing is measuring a compile-time
of different kinds of magic so I'm going
to show you a few things of what we did
and this is a github project called
compile time that I actually want to
look at tomorrow if some people are
interested it's it's basically a bunch
of scripts that will generate different
kinds of tests and if accounts of styles
and then just compile them and measure
it edge profile time and then we do it
over and over over and you can graph it
so the this first one is going to show
the difference between assertions and
match or
and mattress or more magical thin
assertions which one compiles faster
right and all does it say ask Allah can
increment one it says assert one plus
one equals two Scala can you commit to
assert two plus one equals three and it
goes all the way down to 100 then this
one and then there's one where I mix in
should mattress and I just do the same
thing with mattress and then there's one
where I import should mattress right so
when you run that one it looks like this
what you can see here is like this is uh
this is like 10 test 20 test 30 tests in
the file this is this one goes up to a
thousand tests in one test class just so
you can kind of see what it does it's
very consistently the assertions
compiles faster than mattress and that's
the difference the difference there is
it how many implicit SAR in scope this
is also shows that as a point to second
improvement if you import mattress
rather than mixing in so there is a cost
of mixing in a trade because the Scala
compiler has to stick a bunch of methods
in that trade right and it kind of
depends on how many methods has to do
that with but so what the reason we
actually got started on this was because
I'd heard people complaining about specs
to compile time and and I wouldn't
understand what the problem was and so
this one actually compares j unit here's
j unit it says dana doesn't extend
anything so you say test test test
there's a testing g one same kind of
thing and this is the fastest scala test
that i can get its extends trade spec
and test our methods that you use this
little backtick notation and it's a test
method if it has a space in it but i'm
using an assertion there because that's
fastest the fastest i could get specs to
to go it they don't have assertions and
he doesn't have test methods so this is
actually how it comes out if you look at
this guy this is a thousand tested one
test class j unit is the fastest testing
Jesus second fastest it's almost the
same
Scott test spec is actually right here
and it is a half a second slower and i'm
going to show you the only difference is
where is that one fastest Scala test is
this thing right here is that I'm
extending spec whereas the j unit one
doesn't extend anything so what's one of
things i want to try to figure out or
maybe get some help tomorrow with is why
what is the compiler doing that cost a
half a second just to expend a class
this the specs to one is is slower
because it has a more implicit sand more
by name so every test is a by name so
every lambda has a cost compile time
cost so this one is actually like seven
times slower then j unit testing g and
this fast scala test whoop so what the
third one I want to show is is is you
can what I try to do is actually isolate
the differences so this one here isn't
very informative because it's got a
bunch of differences so what you can do
with this guy this one is there's a
hundred classes in the directory and
each one is a test class and they look
the same they could have a different
class name here's where there's ten
testing these class here's where there's
20 tests in each classes where there's
30 so this is actually 10 x 100 there's
a thousand tests here being compiled and
all the way over here there's a hundred
test in each of 100 classes that's
10,000 tests right so the difference
between this spec trade and the Scala
test word spec trade these both mix in
matters so to make it more of a fair
comparison to specs to the only
difference between those two is the
difference of there's one test class per
test there's one function protesters 1
by name protests in words backwards this
is methods so you can see test methods
compile faster and you can see that down
to how many files are generated word
spec generates more more tests tests you
have in it the more class files show up
so it there is a cost when you I mean
you can actually see that it the compile
time follows the file class file
generation count but it's it's not
writing the files it's actually doing
something in memory
that's causing that but this guy is so
this is where its specs so this is a
semi almost identical with this one and
the difference between these two is how
many implicit SAR in scope so and how
many by names are used sex to uses more
by names and more implicit so just a
compile slower and then this one this is
the the really interesting one it goes
out to lunch it goes way up here it
doesn't scale if kind of goes
exponential the compile time when you
add a bunch of classes this is the
immutable style inspects too and the
reason is in this case is it's not that
the number of class files is linear but
the size of them is not the size of the
class files generated just starts going
exploding so if you give it more memory
you can get it to go farther but it
actually takes that you know
exponentially longer so the moral is so
there's a bunch of them here one of the
things I learned by the way is the test
if you extend a class that compiles
faster than if you extend a trade so I
think actually in Scala tests i should
change trait fun sweet to class fun
sweet and probably eric should do the
same thing in specs too and so this is i
did actually you can see the yellow and
red one hopping down this one that's a
little faster is when you this extend
specification and this is extending a
class that extends specifications only
have to pay the mixing cost once so
anyway i want to close with this quote
from dick walls father's dick told me a
story a couple weeks ago which really
fit in which he had run into a walked in
the garage and his dad was using a hand
drill to drill a hole into piece of wood
and he knew his dad had this really
fancy power drill and so he asked his
dad why are you drilling a hole with his
hand drill when he had the fancy drill
and what he said is remember what tools
are for their for solving problems not
for finding problems to solve so I think
you know we're all early adopters and
we're very excited about this language
and we want to touch all the knobs in
and twist them but really I think the
what you want to do is minimize try to
figure out how you can get the maximum
product user productivity out of the
minimum magic ok that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>