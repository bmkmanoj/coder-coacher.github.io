<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>We've got a website for that: The FT Web App and the future of the mobile web | Coder Coacher - Coaching Coders</title><meta content="We've got a website for that: The FT Web App and the future of the mobile web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>We've got a website for that: The FT Web App and the future of the mobile web</b></h2><h5 class="post__date">2012-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iZA4t5MmRBY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">only everyone my name is Andrew bets I
worked for the Financial Times i founded
a company called a sign co about eight
years ago and we in conjunction with the
FT produced their html5 app the FTT web
app and about four months ago my company
was acquired by the FT so I'm now
director of F to your labs which is the
same group of people who continue to try
to push the boundaries of what we can do
with new web technologies to bring ft
content to people on new platforms and
through new channels so the talk today
is there's a little bit marketing gloss
beginning which I apologize for in
advance mostly I want to talk about the
technical challenges that we addressed
in the year that we spent developing the
application and a few thoughts about why
you want to use html5 rather than
building out a number of native apps for
different platforms so I was paying
attention Douglas Crockford earlier on
today and you know just to be safe this
is a JavaScript talk I thought I should
start with a semicolon and I'm going to
give you a brief overview of the FT
whether in fact can I have a show of
hands who has actually used the FT web
app on their tablet or phone okay so
there's a small number of people bits of
minority so I'll give you a quick quick
demo video and walk you through the
application so everything you see in
this video is actually in a browser so a
lot of the stuff is just native to the
browser but we also use touch events to
allow you to swipe between sections we
have a header menu that allows you to
jump quickly from one section to another
all of the updates are done using Ajax
so you remain in the same page all the
time and it is the same codebase the
same application on every platform that
you see in this demo so including some
of the more defunct ones
this is a slightly older video so on
Android you can see that the the UI is
very slightly different but all we're
doing there is making a few
customizations to the size of the screen
and also a few based on interface
concepts that will be more familiar to
those kind of users we can also go
offline and the content which we've not
yet viewed has already been cached so we
can go and view articles that we haven't
seen before and they will still load
even though we have no network
connection even these really big images
in our life in arts section we
proactively download and store in
offline storage and that includes
markets data as well so this is this is
markets data which has been downloaded
and cash before we lost our signal so we
were on a playbook now go online the app
will detect that it now has a network
connection and will update itself so
that's all been large screen we also
support a small screen and it's the same
codebase it's just adapting to the
different environment and different
screen size so with this project our aim
throughout has been to have a single
solution a single ft experience which is
the same across all devices and
delivered using the same technology and
we call this welcome back to the web
because we think that the native app
concept is a diversion and the long term
we need to be investing in open web
technologies for this kind of publishing
and content distribution so I'm going to
expand on that a little bit to start
with the principle that we started with
when we set out on this project was
pretty much this we think the web's
transformed virtually everything we do
in our lives and so we now need that
kind of thing available wherever we are
and that and solutions to that problem
have been preoccupying the industry for
a long time so you know way back in
nineteen ninety nine for example you
know the first attempts at producing the
mobile web were
rudimentary who here uses what or used
to use whap on a regular basis goodness
I do feel for you so the first major
advance that we got along this path was
in 2001 where blackberry made the genius
decision to drop everything except email
and thought we'll just do email really
well because the hardware and the
software is not yet up to the challenge
of delivering the full mobile web
experience to to use it on the move so
we'll produce devices that just do email
really well and that tide is so very
nicely for about five years until Apple
effectively solved the mobile web
problem and the reason I said I
introduced it like this is because I
think it's interesting to look at the
fact that we've spent quite a long time
pursuing the goal of making the web
mobile and yet it only took us about a
year from that point to discover native
apps and then to effectively forget the
mobile web as a publishing platform so
the next thing that comes to mind for me
is to think well what exactly it is an
app the FT web app we call a nap but it
doesn't contain any native code at all
is just a website so what how can we
define this word app strictly speaking a
computer application is something that
we've had for about 30 years so we can't
really define it using its strict def
dictionary definition we can kind of
extrapolate a definition that Apple may
have come up with something to do with
it being an installable computer program
for a specific mobile platform
distributed via an app store and touch
optimized but that's not what people
popularly think of as a nap the popular
definition of an app is something more
like this it's designed for touch it can
be launched from the home screen and it
has a native feel by which we mean it
feels like it was designed for your
device and your device only it doesn't
feel like you're getting a kind of
second-rate experience because you're
choosing to use a device which is not
the device that the person who created
the application was testing on
however effectively for practical
purposes the word app is generally
meaningless so I think the best
definition is something like this it's a
distributed to computer software
application which we is designed for a
combination of two things a number of
specific screen sizes and particular
interface technologies so until until
three years ago the only interface
technologies we really cared about were
keyboard and mouse and then we suddenly
started caring about touch as well but
those are not the only ways that we
could potentially interact with a
computer with a web site and publishers
like that the FT take a much more
long-term view of this kind of thing we
like to think that actually in the
future we might interact with FD content
in lots of different ways we might talk
to it point remote controls at it
gesture towards it we might even in in
the distant future just think about it
and the screen sizes as well have the
the range of screen sizes has has
increased from just the sort of 640 by
480 which we started out with in the
infancy of the web it's got bigger and
bigger and bigger and then suddenly it's
got smaller again so now the range has
increased dramatically so on both of
these points we need to start producing
either a very large number of
combinations of solutions so that
everybody feels like they're getting a
solution that's designed for them or we
need something that can adapt so if we
look at the native or hybrid app recipe
we're actually not covering very many of
these combinations at all we're just
covering effectively two different
screen sizes and one interface technique
the traditional web actually does
slightly better it can handle three or
four different screen sizes and two
interface technologies which typically
go together so because there isn't very
much overlap between the traditional web
and native and hybrid apps the the
native APIs has effectively emerged
because it is filling an empty set
it's allowing people to create a
solution to something which the
traditional web was not able to deal
with because their website people were
building websites that weren't adaptive
to those new sizes and those new
interfaces a native app solved that
problem quite effectively but today we
can solve this problem with the web as
well today the web but quite happily
combines all of these ingredients
together and potentially in a single
solution so we can take the traditional
web and we can upgrade it to to handle
this new era of adaptive design so let's
take it a traditional web and add new
sizes so you know the Boston Globe for
example has a well-respected responsive
design to its site which will adapt the
size and layout of content automatically
to the size of your screen which makes
it perfectly fit whatever screen you use
to view it but it's still not a nap
because if I touch those links i have to
really precisely hit the actual text and
it will do a page reload so it doesn't
feel like a nap so people won't think
it's now so we need to add something
else we need to add the add up the
adaptiveness to the new interface style
I mean we can look at examples like
Twitter where they have created a mobile
website which is effectively a clone of
their native app which supports things
like over scroll to reload which is a
interaction concept which is completely
alien outside of touch and if this
interface although it does perfectly fit
this iphone screen if it were to not fit
the screen well and I had to pinch and
zoom to see it like I might a desktop
website that would also not feel like a
nap so it's the two together and a
number of other more minor things like
being able to launch it from the home
screen having it work offline that make
people feel like your solution is an app
so
we feel that we can make that perfect
recipe which people identify as an app
which is designed for them and delivers
the user experience they like using web
technologies alone and in fact if we
look into the future the future of web
technologies looks really really
promising as well because we can start
to add new ways of interacting with our
applications in fact at the FT we have a
hack day coming up this week where
there's a project to add connect support
to the FT web app so that you can
control it by gesturing towards it and
I'm quite looking forward to seeing the
results of that so let's talk about some
of the challenges that we've had to date
and I split them into a number of areas
where we found we had the greatest
challenge so in terms of the layout
because we have to give the user and
experience which looks as though it was
designed for them on their particular
screen the layout needs to be adaptive
and it also needs to look as though it
was actually designed for that
particular device navigation and
interaction brings in these new
interaction styles that are touch
optimized and specific to touch allowing
the application to be launched offline
and be used offline just like a native
app word because it has installed code
rethinking our back into architecture
with almost all our code running in the
browser the architectural backing
application needs to be completely
different and analytics is also very
interesting challenge for a organization
that puts a lot of focus on the value or
analytics and in looking at what I users
are looking at and the path they take
through our application if the user is
offline we can't collect those analytics
in real time so we need to find out new
salute we need to find new solutions to
that and advertising is very much the
same kind of problem so we look at these
internally the first I'll look at as an
example of a layout problem is flowed
columns on the desktop web typically
content is displayed in a single
scrollable column when
we move to touch that metaphor is not so
ingrained and people don't expect
content to be in a single vertically
scrollable Colin people are quite happy
to swipe any virtually any direction so
this is a great moment for us to
reconsider layout and rethink whether we
should look at other ways of displaying
our content now as a print publisher the
company i work for has been in existence
throughout 130 years and for most of
that time we've been displaying content
on paper very much like this and it's a
it's a kind of layout which is evolved
over a long period of time that people
actually like they like to use they like
to read content that's laid out like
this in there are columns now the reason
that we've never done this really using
the web is is twofold one one reason is
because people don't expect content to
be laid out like this and the tools that
they use like mice with scroll wheels
that interact with their computers don't
really expect content to want to be
moved around like that and the second
reason is because it's technically very
very difficult if you look at the actual
technical challenge we're trying to
solve here we we want to create three
columns with text flowing from one
column to the other all three columns
are of different heights we have some
fixed elements we have some elements
that span multiple columns you simply
can't do this even with very latest css3
properties and even if they were
supported universally across all
browsers so to solve this problem we've
actually created our own JavaScript
library which can implement these kind
of column layouts it can do them
completely flexibly and it can reflow
the text if you're your font size
changes or if your screen size or
container size changes and this is one
of a number of open source projects that
we have created and are sponsoring and
will be launching in the next month or
so this one is called Ettie colon flow
another layout another input into our
layout challenge is looking at the huge
variety of different screen sizes that
we will have to
cope with and on desktop we typically
solve this problem by simply defining a
fixed size and saying okay well if
you're wider than that will just give
you some gutters and if you're narrower
will give you some horizontal scroll
bars so this is no longer acceptable in
a nap we can't do that it has to fit the
screen so to achieve this we we created
for kind of default sizes and then we we
massage the content within those sizes
so you will never see for example a
video midriff as we call it which is a
bar across the center of the app that
contains a number of video thumbnails
you'll never see one of those with half
a video at the end it will always
contain a precise number of thumbnails
and it will do that by choosing the
layout that is closest to the size of
the screen and then changing the white
space and the margins and so on to
ensure that you see something that's
coherent for that particular viewport
size but starting from kind of key frame
layouts helps us to produce something
that still looks good in terms of
interaction one of the biggest
challenges is swiping between sections
you saw in the video earlier on the user
swiping from the front page on to the UK
section well they're actually doing
there is taking 33 divs and
repositioning them as the finger tracks
across the screen we use css3
transitions to do that because we can
take advantage of hardware acceleration
on platforms that support it versus just
setting like a margin offset which
wouldn't wouldn't be hard to accelerated
and you would actually see quite a
jagged experience there so this we've
also created our own library for we call
it ft scroller it's another open source
project we launched your github in the
next month or so going offline is
probably our biggest challenge and it
requires the biggest change in our
strategy for how we build web
applications we have to have a web
application that can completely load
render content and display the finished
page with no request to the server at
all
so to achieve this we have three sorry
for offline storage technologies one of
which obviously is is cookies is tried
and trusted very old technology but
three new html5 technologies which allow
us to store content offline in the
browser now why do we have three new
technologies why can't we just have one
technology that allows us to do
everything we want offline that would be
great but unfortunately none of these
three technologies does everything that
we want so in practice we have to use
all of them and you leave you a quick
walkthrough of how an offline
application would actually start up and
how it would leverage all of these
technologies together so let's assume
that we have a site with say five or ten
million articles now it's not it's not
practical to assume that any specific
article URL that the user might type in
will be in their cash so let's assume
it's not so the html5 application cache
gives us the ability to serve a full
back page so this is a feature that it
has that is very different to the
standard browser cache in that if the
user types in a URL which is not in the
cache it can still serve something it
can serve a fallback so in our full bag
we include a number of things to help us
get the user to a page which resembles
the URL that they actually originally
wanted in which we can't serve because
they're offline so we start by serving a
full back page that contains a splash
screen which we can show you elsewhere
whilst we're thinking some basic CSS to
render the splash screen will also
deliver some error messages and some
support information so that if
ultimately we are unable to give them
what they wanted we can at least give
them some help some helpful advice and
some numbers to call and finally most
importantly the full back page will
contain some boot code which is some
JavaScript that's intended to
essentially become a client side front
controller and routes that that uses
requests to generate the necessary data
and composite the page that they want
and then display it
so having loaded this fall that page
from the app cache we now need to get
some additional resources what we what
we like to do is put as many of our
resources possible in local storage
rather than in the app cache because the
app cache is very inflexible technology
so we put our main application
JavaScript which is some 750k of code
plus our main application CSS and our
HTML templates in local storage and then
when our boot code runs which is very
very small amount of JavaScript it will
pull the main application JavaScript out
of local storage any valid that gives us
the opportunity to update that main
application JavaScript without touching
up all that page in the app cache you
should think of the app cache is like
your installed application this is
something which you want to update no
more often than you would typically
release a new application through the
App Store so you don't want to be
updating the app cache that March so we
put our main application JavaScript and
local storage we can update it all the
time and the user won't notice so if
that if that main application javascript
is able to run successfully it can then
examine the URL because we're still not
showing the user anything and it can try
and find that content now in this
example I'm saying that it could find
that content in web SQL it could also
use a cookie to try and authenticate the
user and provide a more personalized
experience and it could also use index
DB for a platform that supports that so
we're using all of these html5 storage
technologies together to eventually
render the page that the user would
otherwise have got if they had sent that
URL request directly to the server sorry
I thought I was looking at that slide so
we can check the authentication we can
also remove the redundant content from
the from the full back page so the
things in the full backpage that we've
got from the app cache things like the
splash screen those error messages and
support information which we no longer
need because the app is started
successfully we can now remove that
content and we can add in the additional
content which we're pulling from other
html5 storage technologies so that's all
very well but there are other things
that we may
want to store which are much more
difficult so content images are a big
challenge these these are this is binary
data which we want to store somewhere
offline so that we can render those
images when the user is offline and we
can't realistically put those images in
the app cache we can't rely on the
browser cache so we only have the only
things we have left a local storage web
SQL index DB and all of those
technologies are string bass JavaScript
API s so the only way that we can store
image data in those is to represent it
as a string to represent an image as a
string you typically base64 encode that
image so that's what we do on the server
we base64 encode all our images we send
them down to the client in a JSON array
and we store them in local storage or
local database there are a couple of
interesting side effects of doing this
one of which is that mobile operators
will quite often recompress your images
in an attempt to reduce the amount of
data that their users are using them we
don't want them to do that because our
images are perfectly optimized for the
use of screen but by base64 encoding the
images images the operator doesn't know
it's an image it just looks like text so
they won't interfere with it and it's
just slightly ironic that we have to
increase the size of the image by thirty
percent to do that once we've got that
basics if your data in local storage we
can then take it out we can prepend a
mime type and we can put it into the Dom
as a data URI data your eyes effectively
allow you to embed to the actual image
data into the URL so that you can
display an image in a web page without
an HTTP request for that image so we're
storing all our texts with storing all
our articles all our content images
we're inflating the content images by
thirty percent using basic 64 we are
going to run out of space and that is
what happens so there's anyone want to
figure I wasn't able to get in time for
this presentation but I have
in consultation with a number of the
developer relations people at the
browsers and also looking at
documentation and doing some experiments
myself I produce this table of the
limits that we actually face when
developing on the web in terms of how
much data we can store offline and this
is really this is really crippling web
development and when put up against
native app development because native
apps can store as much data as they like
and we not only have to contend with
these very restrictive quotas but we
also have to face OS native prompt
asking the user for permission to store
that data in the first place
nevertheless you know we have to work
with what we've got and there are some
ways that we can use this media storage
allowance more efficiently and one of
the things which is a particular problem
is that JavaScript uses internally
utf-16 for its text encoding this is
actually a really good idea in in in a
lot of ways because utf-16 allows
javascript to be fully unicode compliant
and it also makes string operations
pretty fast because you have a
predictable number of bytes per
character where it is a really bad idea
is for storing English text because
English text typically comprises you
know 99 percent characters which are
also present in the ASCII character set
in which in utf-8 or a ski would just
require one buys in utf-16 they take up
two bytes so the phrase hello world has
a null byte in every other every other
bite in in the word hello worlds and all
right when stored is utf-16 so what we
what was a really restrictive 50
megabyte quota is now an even more
restrictive 25 megabyte quota so there
are things we can do to try and try and
fix this and you know we we don't have a
choice about you know just storing less
content we want to store a significant
amount of content and we simply cannot
give the user a decent experience of the
ft in 25 megabytes we need more content
in order to give them a decent chunk of
offline reading
so the solution that we adopted was to
pack a ski into utf-16 and convince
javascripts that it is a utf-16 string
now we do this by taking pairs of ASCII
characters bit shifting the first one by
eight bits adding the second one and
then telling JavaScript that that
resulting character code is one single
character so the result is if you look
in devtools and actually inspect the
contents of your database you'll see
something like this which is Jewish but
every one of those characters is
effectively to ASCII characters
masquerading as one utf-16 character so
there are other things we can do as well
like we could we could go even more
complicated we could use utf-8 now utf-8
is a variable length encoding so in the
case of this example of the word Roy's
are a twat apostrophe s where the
apostrophe is a curly quotes the first
three characters are single byte
characters so they are in the oh we can
encode into one utf-16 character we can
take the y in the first third of the
apostrophe and put it into the second
character and the other two-thirds of
the apostrophe will put into the third
character and this is terribly
complicated it's also a lot of code we
have to code in JavaScript the app be
the logic for performing utf-8 encoding
and we find that the encoding and
decoding process is too expensive we can
encode and decode around 100 kilobytes a
second using this technique whereas
using the ASCII technique we were able
to encode and decode around a megabyte a
second we can go further in terms of
compression a lot of our content is just
base64 because we're storing a lot of
content images offline now if we just
look at the base64 rather than the the
content of our articles then we only
have a maximum 64 possible characters in
our data if you only have 64 characters
then you only need six bits to represent
each character so if you're you only
using six bit
out of every eight bits then that's a
waste of space so we could take each
character assign it an index value
between 0 and 63 and then take the 6th
bit representation of that and take
every 16 bits in the resulting stream
and tell JavaScript that that is a
utf-16 character so you you would end up
encoding roughly sixty-three percent you
would end up getting sixty-three percent
less storage required for the same input
data rather than fifty percent less
which is what you would get with with a
ski and because six does not divided
into 16 we have to encode in units of
eight characters so eight base 64
characters equals three utf-16
characters this we find is just as quick
as the ASCII approach you'll martin lee
slower but not noticeably we don't do it
simply because it just seems overly
complicated and we don't currently need
quite that degree of storage efficiency
one thing I think is quite interesting
is how you deal with users running old
code and users with old storage when you
want to upgrade your website it's quite
easy if you have an online-only website
to just roll out new code you can change
your site completely and it doesn't
matter everyone would just start
experiencing the new code immediately
but if your users of relying on a very
large amount of data that you've stored
offline in a particular format using a
particular schema and you're also
storing your JavaScript code offline
then not only do they dis your new code
have to be compatible with the data that
your users may have already stored but
it also has to be compatible with the
JavaScript code which they may still be
running and the HTML that they may still
be using in their in their browser so we
find that the the effort we have to go
to ensure the backwards compatibility is
is very very high so one of the things
we do we did when we produce this new
way of encoding text is to introduce
this idea of snow man sniffing
which is to say that when a string is
encoded and so it's packed with to ASCII
characters / utf-16 character we prefix
it with a Unicode snowman character to
indicate that decoding needs to take
place otherwise the user will just see a
whole load of Chinese and Japanese and
Korean characters jumbled up on the
screen obviously older users that have
not yet got the new code will still have
uncompressed content in their database
won't be prefixed with the Snowman so
we'll know not to uncompress it we chose
the Snowman because he looks cute and we
don't think that it's likely that the
average ft journalist will use a snowman
in their journalism there are few other
things i thought i would i would mention
one of the biggest challenges of html5
development when you introduce offline
capabilities into your applications is
debugging when you turn on the
application cache you rapidly realize
that refresh doesn't work anymore and
that you you really struggle with layers
upon layers of caching so as another
example we have a lot of image on the
fly resizing and resampling because our
images have to be delivered at exactly
the right size for whatever screen the
user has so if we if we have the ability
to clear different layers of caches then
we can experiment with changes to that
to the code that does that resampling
but if we don't then we can change the
code that does the resampling but
because we've already cashed the
resulting image we won't see that result
in that batch of result change in the
browser so one of the things that we've
created to try and help us get around
this is QA flags so we have a cookie
that we can set which can contain a
combination of a number of toggle
options which we can turn on and off and
these apply just as much in the live
environment as they do in our dev
environment so if somebody reports a
problem on the live server we can easily
toggle a number of QA options on
and we can then we can then get a lot
more debug information out of the app so
for example we can turn profiling on in
life environment we can enable
unsupported browsers so normally if you
for example goes to try a view our app
in Firefox it will direct you to a
marketing page and tell you supply an
iPad that's because we don't yet support
Firefox but if we were to toggle a QA
flag on then it would allow me to use
the app in Firefox it would break but it
would allow me to use it because I might
be trying to make it work in firefox and
that is a great way of doing that what
we used to do and what we dislike doing
is is putting switches through our code
that say if we're on a dev environment
do this if run a live environment do
that because you end up doing so many of
those in that endeavor you're never
actually using the code that your your
end users are using in life so another
thing we do with the QA flags is to set
an expiry time of 24 hours on all our QA
flags so if a developer decides to turn
up to turn off caching for example they
can only do that for 24 hours before
they have to revisit that decision and
and make that same decision again
there's a few useful tools that I would
recommend to you and to anyone building
html5 applications Charles is one of my
favorite pieces of software it's a web
debugging proxy what you can do is take
your mobile device set up an HTTP proxy
in your Wi-Fi settings and point it at
your desktop computer we're on Charles
on your desktop computer and it will
show you every request every HTTP
request that your device is making in
real time it will show you all the
headers both the request headers the
response headers the request body
response body all the timing metrics
associated with the request the order in
which the requests were made and it will
also give you nice waterfall graphs so
you can see where there were synchronous
operations that you know where one
request had to end before another one
started and so on Charles will also give
you the ability to do things like
blocking and modifying with West using
rules so if you want to test your app
how your app behaves when
on a constraint Network you can throttle
your network connection and you can tell
it to block individual requests or
deliver garbled responses to see what
the effect is winery is an excellent
tool that provides a live web inspection
capability on devices that don't have
web inspector so the blackberry playbook
for example and the new Chrome for
Android have a have this great
capability that you can use a webkit
browser on your desktop machine and just
type the IP address of the of your
device and you can actually pull up the
dev tools as if you're inspecting
content on your local machine it's
pretty amazing and you know you can
mouse-over elements and they highlight
on the device and you can do things like
break point debugging in javascript as
well Winery essentially provides that
capability on devices that don't support
remote web inspector it doesn't provide
the full dev tools so it won't allow you
to do break point JavaScript debugging
but it does give you full access to a
Dom element inspection and you can look
at and you can look at and change all
your style rules so it's great for doing
things like looking at CSS bugs and
webdriver for mobile browsers is a great
way of starting to get a little bit of
test automation going on on the actual
devices themselves in our case we find
that there's no room there's really no
substitute at the moment for a lot of
manual testing with a lot of devices and
a lot of people but using tools like
webdriver we can start to reduce that
manual workload and we can start to
automate the common processes by
actually performing on device testing
automatically so nearly at the end I
give you a quick recap of what I've
discussed so we think a website can be a
nap and that we need to look at a more
broader definition of an app that
doesn't require actual native code on
the device but we need in order to
fulfill this definition a nap we need to
be tailored to the device that is being
used to access our application and that
is a combination of being adaptive to
the particular size of the viewport and
also to the interface technology that
the user is using we can do this with
web technologies in fact we're more
likely to be able to do this with web
technologies going to the future and
then we are any other kind of native
technology that you might pick up today
and that includes those projects that
allow you to create multi-platform
native apps and by building using the
web approach we can retain a lot of the
benefits of the web that you simply
don't have in native at all things like
URLs things like search crawling and
search engine optimization we can
achieve this on the web only and we
can't achieve those things using native
technologies at all so I like to finish
with the quote from the the great mr.
sir tim berners-lee who answered a
question I put in a conference recently
by saying don't build native apps build
web apps thank you very much does anyone
have any questions okay so question is
how much how much dynamic content
degeneration to be due on the server we
do as much as we possibly can on the
server so you will find that the the
content that we send down to the client
is as as pre composed as we can possibly
make it because we want to do the
minimum amount of processing on the the
client side okay so the question is do
we do some of these other native like
things like put a put an icon on the
home screen yes we do so I mean it
really depends on the platform on iOS
like most applications we have this
little thing that points at the button
you have to press two to put the app on
your home screen and we supply a meta
tag that indicates what icon Apple
should use to do that on other platforms
like Android currently we have a native
app short Cora but actually all it does
is is essentially supply the icon on the
on the home screen and the offline
launch
other than that all it's doing is
wrapping the web app ultimately our goal
for our native apps is not to have them
at all so those things that we correct
we currently can't do using purely web
technologies the business imperative
means we have to have a native app that
does that that that particular portion
but where we can we do it using web
technologies on iOS we do all of that
stuff in the browser yes I kind of see
your point thee so there is a tendency
to take a desktop website and say okay
our desktop website is way too big and
complicated we can't simply display this
on mobile we have to create a cut-down
simplified version of it and that is
certainly true on all the devices that
can't deal with the you know the the
complexity of your desktop site
interestingly the FT web app is actually
a significantly larger more complicated
site than ft.com so you know if you're
actually using the app then you're using
a site which is equally large equally
complicated as a desktop site is just
designed to marry up with the device
that you're using to view it in a way
that the desktop site is not so I would
say that yes certainly there are there
is logic to the idea of creating a
simplified cut down mobile site the
loads very quickly and has very
lightweight but that's not what we've
done we do actually have one of those
MDOT ft.com is a cut-down version of
ft.com for simple feature phones so
things like BlackBerry's prior to six
Nokia's you know feature phones that
don't have the capabilities to view apt
I takam we have em directo calm and
that's actually one of the reasons why
we kind of get away with the advanced
features that we do in outdoor ft.com is
because those devices that don't support
it we can consign to my 50.com and say
you can go ahead and use that and it
also means that those devices which are
kind of diminishing in popularity so as
there's kind of the galaxy one falls off
the radar a bit we can say okay we no
longer need the gal
cs1 support in apt ft.com so you can now
go over to m dot ft.com and we can kind
of use that as the long-term support
path for phones that you know we're no
longer a no longer our prime focus yep
so what are we open sourcing effectively
I am desperately trying to get this open
source stuff darn it's just proving
administrative ly a bit of a nightmare
at the moment but just because we have
so much else to do and you know
priorities are quite difficult but as
soon as we can actually get it out of
the door there will be se column flow ft
scroller will both be on github so and
there will be a number of other modern
more minor projects as well so if you
keep an eye on ft labs Twitter account
or github ft labs then you'll see those
when we publish them okay thanks very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>