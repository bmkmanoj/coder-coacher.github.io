<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Google Beacons - AnDevCon | Coder Coacher - Coaching Coders</title><meta content="Google Beacons - AnDevCon - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Google Beacons - AnDevCon</b></h2><h5 class="post__date">2015-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TZf4WquRGJU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everybody morning I understand
it's 8 o'clock so I'll I'll allow that
to to stand I apologize in advance I am
a morning person so if I scare some of
you this early in the morning don't
worry too much about it my name is Daisy
thank you for coming today
I am Android lead for new circle new
circle is a developer training
organization we focus on open source
technology on Android just happens to be
a part of that so I'm responsible for
all of the Android courseware
maintenance and development over over at
new circle and Google developer expert
for Android since just a few months ago
and I'm here today to talk to you about
Google beacons in the physical web so
we're going to talk about three primary
areas today we're going to talk about
Google's beacons and a format that you
may or may not heard I've already called
Eddie stone we're going to talk about
Google's beacon api's which were just
recently released to the public as well
and we're going to talk about this thing
called the physical web and how that
ties into all of those pieces as well ok
and then if there's some time at the end
I've got some demos and some code that I
can show you as well so to get us
started off who can tell me what a
beacon is what do you know about beacons
ok it's typically a Bluetooth device
that's true anything else ok yeah
doesn't usually go very far that's good
anything else ok it's a broadcasting
device that's exactly right
typically has something to say but it's
not usually a device you can connect to
or communicate with in any way as
usually goes along with it any other
things come to mind ok so that's a
pretty good definition the only other
thing that I would toss in there for
purposes of our discussion here is that
the amount of data because we're talking
about Bluetooth that typically bluetooth
le the amount of data that a beacon can
transmit out into the world is typically
very limited right we're talking in the
range of 30 bytes or so okay so what
you'll see when we look at some of the
specific formats of how they're
transmitting some of this data you'll
see that they don't have a lot of space
to
with so they often end up doing as much
as they can to try and cram all the
information they can into those few
bytes okay
so there's some creative tricks they use
to do that and it also has spawned some
of the backend features that Google has
recently released because of this issue
okay so just kind of keep that in the
back of your mind who here has heard of
ibeacon before okay pretty good amount
of you so for those of you who are not
familiar I be canoes apples version of a
beacon technology okay they were sort of
the first ones to introduce this idea to
at least to the the mass public and the
idea behind the ibeacon format was this
was a way of it originally started out
as a way of turning your iOS device into
a advertiser that could transmit out
this information to other iOS devices
that would be listening for that
information and you could use that to
determine a basic ranging and proximity
and location between a user's device and
say an iPad that was acting as maybe a
point of sale in a retail store or
something along those lines it has since
grown to where iOS devices are not the
only device that can act as a beacon
nowadays we have little Hardware pieces
like this one in my hand here and some
of that we have spread around the room
that act is that same type of
advertising device so it broadened out
quite a bit but ibeacon was really the
first specification that most of us were
familiar with in terms of getting us to
that end goal so just to kind of give
you an idea of what we're looking at
here this is the the set of table that
I've got up there is essentially this is
what Apple does with those 31 bytes now
that I've left some things out because
technically speaking I'm not supposed to
show you the whole protocol because
Apple has it under license and all this
other mess but the the basics of what
are interesting are listed here so there
are some primary values that ibeacon
transmits that applications can use the
first is this idea of a unique
identifier it's a 16 byte value just a
traditional UUID that you've seen all
over the place the intention of this
is to identify a specific application so
every application that is using ibeacon
in its overall deployment would have its
own unique ID so I would have one for my
application you would have one for yours
Dunkin Donuts has one for theirs so on
and so forth okay and then every single
beacon in that deployment would use the
same ID so it ties them all back to that
one application the major and minor
value that are listed here are really
just ways of allowing the application to
identify one beacon from another and
what you do with this information is
completely up to your application so you
could you could use them together as a
single value if he wanted to or you
could provide some way of subdividing
your beacon deployment so that when in
when an application on the user's device
detects one beacon versus another your
application can figure out which one
that is now this is it's just a few
bytes it's basically a number and
integer value so your application
somehow has to come up with a way to
match that number to what this beacon is
you know basically the idea that beacon
number 1 2 3 4 5 is the front door of my
store in Boston Massachusetts right so
that's up to your application to do that
work but you know other than that the
pieces are in the format to support that
then the last piece that you'll find in
most of the beacon formats but is also
an ibeacon is the transmit power and in
and of itself this isn't necessarily
interesting to the application but it's
necessary to do any sort of decent
amount of arranging in order to figure
out how far away you are roughly from
any of these devices the device when it
picks up the signal can figure out what
the signal strength is of the Bluetooth
signal when it detects it but that
information by itself is not very useful
you have to know what the transmit power
was of the original device to be able to
figure out how much loss there was over
distance and do a rough calculation of
how far away you are ok this is not
super accurate but it does give you a
way of basically determining am I in the
same room the same building am i near
right next to it or am I really far
whay right so that information will
always be in the packet format as well
the other interesting thing to know from
an ibeacon perspective is we're going to
sort of use this as the basis for our
comparison
ibeacon requires that you transmit this
information from whatever the beacon
device is every 100 milliseconds so
that's basically 10 times every second
this information is going to be
broadcast out into the world okay
that'll be interesting a little bit
later so just kind of keep that at the
back of your mind the type of
applications that this is intended to
enable is sort of a what I would call a
private deployment right you take a
bunch of these beacons whether you buy
these little pieces of hardware or you
code it into an application running on
your device to advertise this
information so that your user
application can use it right so in my
example here Dunkin Donuts puts beacons
in all of their retail stores and the
the Dunkin Donuts mobile application has
to be coded to recognize when those
beacons are in proximity to the users
device right the the unique ID for that
application and all those other values I
just showed you are specific to that app
and so you have to basically have Dunkin
Donuts app to be able to interact with
that technology okay that's not a bad
thing but it has some limitations so
it's something to keep in mind as we
kind of walk through this okay so it's
it's designed to facilitate this
one-to-one communication between a
company's beacon deployment and the app
that they're also provided ok so it can
be an interesting way to re-engage
existing users because if they already
have your application they walk into
your store and they can somehow maybe
get a notification or something like
that that there's something interesting
to see there because they already have
your app but it doesn't necessarily
facilitate any way of getting you new
users because if they don't already have
your application they're not going to
have any way to recognize the beacons
that you have out in the real world okay
so that's the key to take away from
there all right now on the Google side
of things what Google recently
introduced just a few weeks ago was
their foray into the same space and
called in any stone so if you haven't
seen it before that is the logo for any
stone and so if you see that anywhere
that's what it's reference to there are
a couple flavors of the Eddystone packet
format the first one that we'll talk
about is the Eddystone UID and so
basically what you're seeing up on the
screen right now is this is what Google
does with the same set of 31 bytes okay
and in in the UID case so it's a little
bit different they use more standard
packet types they use packet types
called service UID and service data
whereas Apple basically just threw it
all into a blog called
manufacturer-specific which really
doesn't mean anything else other than
from a bluetooth perspective we can't
decipher this data it's up to the
manufacturer okay it's just an
interesting side you don't really but
when you get down to the individual
application level elements you can see
pretty much the same stuff just
organized in a different way so we still
have that transmit power value in here
but now we have these two things called
a namespace ID and an instance ID on the
face of it that's no different than the
unique ID for the application and those
major and minor values right the idea is
that that namespace ID is unique per
application and would be the same for
every beacon deployment in that
application and then the instance ID
would be unique per beacon device so
that your application can determine
whether it's beacon at the front door or
the beacons back door right or something
whatever matches up with your
applications so other than the fact that
the data is organized a little bit
differently and the data sizes are
slightly different there's a smaller
namespace but a larger instance field
it's effectively the same use case right
there giving you the same data in a
slightly different way now one of the
advantages of something like Eddystone
over ibeacon is licensing right
technically speaking
although beacon manufacturers have found
ways around this over time an IB an
ibeacon licensed device isn't really
cross-platform because the ability to
communicate and understand that packet
format is supposed to only work on iOS
devices
so what beacon manufacturers have done
is sort of
well they've claimed to reverse-engineer
the protocol and then they provide their
own SDK around it that sort of hides the
implementation details of the fact that
it may work on Android even though it's
not necessarily supposed to okay with
the Eddystone format it is intentionally
open and cross-platform is pretty much
everything that Google does so you don't
necessarily have to worry about those
limitations or restrictions in what
you're building into your application
okay just an interesting side note now
the other thing about the Eddystone
format is that it doesn't dictate how
often you have to transmit typically
Eddystone devices are transmitting on
the order of one to two a broadcast
every one to two seconds so that's
essentially 10 times less frequent than
the ibeacon okay that becomes really
important if your beacon is
battery-powered because the more often
you turn on the radio the less that of
the Alessa amount of time you're going
to have coming out of the battery inside
of this thing okay so the another sort
of side advantage of working with
Eddystone is that you can typically get
longer battery life out of using the
packet format because you can transmit
less awesome technically speaking you
could transmit even less than this but
the average is usually about one one and
a half seconds on most of the devices at
least the ones that I have here and so
that means that just generally speaking
you know on the same hardware if this
device is running Eddystone firmware it
can last eight to ten times as long as
this same hardware running it ibeacon
firmware okay so that can be very
important now not all beacons are
battery-powered I've got a few of them
around the room that are plugged into
the wall so that isn't necessarily
always the case but if it has to be
powered from some sort of battery it's a
consideration to sort of keep in mind
all right and as I mentioned before
because this is really the same basic
technology or serves the same use case
the application of it is basically the
same right this is what we would call a
private deployment where these beacons
are specifically designed to interact
with the application that I am writing
as the person or the company
these out into the world okay but where
it starts to get a little bit more
interesting is that Eddie stone has
another flavor called Eddie stone URL if
you've been following Google's beacon
efforts for any amount of time this is
an evolution of the format called URI
beacon if you'd use that or played
around with that at all
but essentially what this does is it's a
separate packet format and you can see
that by this identifier right here
so basically Eddie stone reserves a byte
to determine which type of a flavor of
packet we're sending whether it's a UID
packet or URL packet and that value is
in this case either 0 or 10 but that
identifier tells us that the remainder
of the information in here is not these
random set of bytes that are specific to
an application it is a common well
understood representation of a resource
call the URL right we all know the URL
we use it all the time on the web and
the idea behind this format is it allows
you to take this beacon device and
transmit some URL to some resource out
on the open web or other places that
we'll talk about it a little bit then
any device walking by that has the
appropriate scanning functionality on it
can pick up and interact with that
element ok now this is a big change and
a very helpful piece because it allows
us to introduce a new concept that we've
never really looked at before called the
physical web ok now unlike will talk
more about how the physical web is put
together and that sort of thing but
unlike the private deployment the idea
here is there is one application on your
device we'll call it a physical web
scanner for the moment that is able to
detect and pick up any of these URL
broadcasting devices whether you made it
you made it or I made it because the
data is constant it's consistent and
it's something that we can all
understand and interact with because
references are resource on the web ok
and there are actually some interesting
applications that we can glean from that
in terms of native applications as well
but we're gonna get to that in just a
little bit so that second flavor adds a
whole new interesting dynamic to the
discussion all right
so let's dive just briefly into the
details of each of these formats you get
a little bit of a better idea of how
this would look in practice so the
Eddystone UID there are a number of ways
that they recommend you generate that
unique identifier that they call your
namespace technically speaking you can
do whatever you want right you just
generate your own randomized unique
identifier grab some bytes out of it and
go but to as best as possible to reduce
any sort of collision potential or
anything like that the recommendation
that they give you is to basically take
a one-way hash of a domain that you own
and in this case the example I've done
is I've used our domain of new circle
and that's basically that will produce
an output that's roughly 20 bytes so you
just take what you need from that the
first 10 in this case and that becomes
the namespace ID for your application
now the nice thing about this
functionality is if you want to
subdivide your application into
different groups or different namespaces
an easy way to do that is to just tack
on subdomains of your own domain so you
could sort of think of this in terms of
the web where if I had one group of
beacons I define that under this sub
domain I have another group of beacons i
define under another sub domain and i
get two unique namespaces for that that
i can code into my application to look
for both of them if I want or one for
this application and one for another
okay so you take that information and
then that would map itself out on the
individual Vicens to look a little bit
like this right so if we had in this
case four beacons in my deployment then
the namespace ID value for each of those
beacons would be the same it would be
that value that I just calculated from
my hash of above that instance ID then
is used to uniquely identify each
individual beacon and I can do whatever
I want with this field I can do them
sequentially numbered like I have here I
can send them as a bit mask and or you
know some other unique representation of
how I want to see this data so that I
can easily inside of my app
patient determined one beacon from
another okay at the end of the day
that's all this field is responsible for
how do I know the front door versus the
back okay
questions so far yes it's where's the
1610 bytes for the namespace and six
bytes for instance yes right and in
there and that's a thing you don't
provision through Google so there's no
hard and fast requirement on how you do
this but the recommendation is a method
like this they have a secondary
recommendation of how to basically take
certain bytes out of a randomized GUI DS
you can basically generate a random one
and take ten bytes out of that that you
need as well so there's a couple options
that they would prefer you to do but at
the end of the day I could just make ten
bytes grab them out of thin air that's
my namespace there's there's no back-end
restriction that's sort of enforcing
that on me all right so we'll briefly
look at a little bit of code I won't
dive into too deeply here but basically
if in an android application if you
wanted to do some basic scanning of
these Eddystone UID type devices then
what you would see would look something
like this and if there's time I'll show
you the code in a little bit more detail
when we get to the demo but this is sort
of a shortened version of it now what
I'm showing you uses the latest version
of the Bluetooth API is in Android so
these are using the API is introduced in
5.0 and later you can do the same thing
using the previous version of the API is
that go back to 4.3 there's just some
pieces here that are not quite as nice
so I want to show you the the easier way
to do things that you can get away with
so basically a couple piece of
information we need to define we need to
define a reference to the service that
data is being broadcast with so if you
remember back to the slide where I had
the the packet format set out I
mentioned that this data was broadcast
in something called a service data block
okay that service data block has a
service ID associated with it the
service ID that's actually advertised is
a short version right there called FAA
okay that is the unique identifier for
the Eddystone UID service okay actually
just Eddystone service so I need a
reference to that UID and this is just
the expanded form of that that I would
put in my code then the nice piece about
the 5.0 api's is I can provide a filter
to Android that basically says I want to
scan for devices that are advertising
this service but I only want you to
return to me devices that have the
namespace ID that I'm interested in now
the API for this is a little messy
unfortunately because I can't declare
that specific piece out in a simplified
way what I basically have to tell the
framework is inside of that entire
service data block the 30 or so bytes
that are being sent back these are the
bytes that have to match and these are
the bytes that don't ok so basically
what I'm providing here is a filter
value where the elements I'm interested
in are set and the remaining elements
are just zeros that was a bad in color
because of the background and then in
order to define that more explicitly for
the framework not only do I tell it this
is the information I want you to filter
on but I also give it the bitmask
of which explicit elements need to match
and which ones don't
right so the bits that are set high have
to match the bits that are not can be
anything in the resulting scan okay
so the advantage of doing this is simply
that when I start getting results back
for devices that are
around me that have been scanned is the
only devices that I'm going to see in my
application code are Eddystone devices
that have the same namespace ID that
I've actually defined so that I don't
have to write a bunch of extra code to
pull those out of the results later so
it just simplifies the backend of my
application a little bit more okay so
that information is passed off to a scan
filter now I'm not going to spend too
much time on the actual how the
Bluetooth billing API is work I've got
other resources you can look at to work
with that if with the code I'm showing
you is completely foreign you've never
seen it before but the basic idea here
is we just have to define a filter for
our scan that has that information
wrapped up inside of it okay and then I
can take that and my scan settings which
essentially just defines how often do I
need to scan how aggressively that sort
of thing and pass that off to the
Bluetooth scanning api's okay so this is
you know basic sample code you could
find this anywhere if you google Android
Bluetooth le to get your scanning
started for the devices around you now
what this will return back to you is
basically the raw data what they call a
scan record for every device that it
picks up that matches that information
so the nice thing is because of the
filter I set up ahead of time the only
thing that's going to show up in this
method here are the Eddystone beacons
with my namespace so I only have to deal
with that information okay so that's
kind of nice otherwise I if I were using
the older API is that don't support
filters I would be getting all of those
values back in here and I'd have to
manually parse them out at this point
okay so it still works it's just not as
nice okay yes if you turn off the filter
it would yes absolutely because at a
basic level it's just gonna pick up any
le device that's broadcasting and they
use the same technology to do that
it is a requirement it's actually
written into the ibeacon spec yes in
terms of the number of packets you
receive over a period of time yes that's
absolutely true
yes it's well let's go back the one at
the top gears and when you're referring
to this one here so that is that's
basically just a hard to find value of
Yeti stones back so I mean if you were
to look at if you were to look at the
specification page for Eddie stone they
would say here's our service its FAA
this is how you would define it in your
code so that's just straight out of the
documentation was there one more
question in what's highlighted here
absolutely so just to quickly go over
this again so the first piece here was
filtering on what is the value that I
want to see and then the second piece is
declaring from the framework which parts
of the previous value are actually
important short for for certainty
absolutely so this part is what's
defined by Eddie stone the remaining
piece of this is a constant value across
all bluetooth services so basically the
way that this works is every Bluetooth
service is defined by a full UUID
128-bit value but what the Bluetooth SIG
does is they say if we're pre defining
these for you we're only going to give
you a 16-bit value and you take that and
you add it to the remaining piece so
this is just a natural expansion of any
Bluetooth ID that you get from the blue
to say yes great question
good eye so the important the reason for
that is because so obviously we know why
this is set to match the namespace
filter these two bits are set because
this bit acts
is important that is the type identifier
that's at the very beginning of the
packet and for an Eddystone you IIED
that will always be zero for an any
stone URL it's ten right so it's that
frame type that I showed you on the
first slide so even though it's zero in
here it's actually a zero that matters
as opposed to the others being zeros
because I don't care what they are how
how would you set it in the devices that
are advertising or I'm not sure I
understand the question yes yeah this is
the scanning device okay all right so
this is so basically you would get that
information back in the scan callback
now the disadvantage here is that at the
moment we don't have any libraries or
any core API is associated with an abyss
functionality that can allow us to more
cleanly get from this Ross can record in
to say that namespace and that instance
ID what we're gonna get is the raw data
and then we're gonna have to be
responsible for masking out and here's
my namespace and here's my instance IDs
that I can actually figure out okay this
is instance one this is instance to go
on and do that okay at the moment you
have to do that by hand there is a nasty
rumor floating around that the upcoming
nearby messages API that will be part of
Google Play services is going to do this
for you okay now this is not actually
out yet and the documentation is not
fully available so I can't necessarily
tell you exactly what this will look
like in code but what I can tell you is
that the basic idea here is using Google
Play services you will tell the
framework or Play services framework
anyway that I'm interested in scanning
for Eddy stones and here is my namespace
a key and then it will handle all the
background scanning setting up all those
filters and everything that I just
showed you and the callback that you
will get back will be one of their
messaging callbacks that's much more
clean and sanitized that has some of
this information parsed out for you okay
so if you're wanting to play with this
stuff today you're gonna have to use the
code that I have on a slide here
eventually when nearby messages starts
rolling out to devices and we have
documentation for that in the SDK is
available you'll be able to use that
functionality if your application is
able to depend on Play services now for
some reason you can't use Play services
you'll still have to do this manually
and that would be okay it still works so
it's really just an API that simplifies
your life but it doesn't do anything you
couldn't otherwise do on your own yes
basically so that it's available on any
device version as soon as it's released
where bluetooth they'll be is supported
right if we if they added this as a
feature in every town then we'd have to
wait until we could set minutes to
Canberra a.m. to use any of that so the
other part of that is that you could
kind of think of this as more of a it's
more of a google technology so when
that's typically the case when it's
something that it's tying back to a
service or an API that Google is
providing directly they usually put that
stuff in Play services as opposed to the
moment source so that might be another
reason why good question them okay so
keep your eye out for nearby messages
now there is actually a third packet
type that's defined by the spec that I
hadn't talked about before called the
Eddystone TLS TLM stands for telemetry
this is a special packet it doesn't
identify the beacon in any way the
interesting thing about the other two
packets that I showed you is that
Eddystone UID and Eddystone URL identify
the resource that that element is
supposed to represent whether it's using
that unique identifier or whether it's
using a URL the telemetry packet in and
of itself doesn't have any identifying
data in it you have no way to tie it
directly back to any of those other
instance pieces because there's just not
enough room in the packet to fit at all
what this is intended to represent is a
way of broadcasting out to whoever's
listening some telemetry metrics about
the device so what is the battery
voltage if it's battery-powered does it
have a temperature sensor equipped it
can send you the beacons temperature the
number of advertisements that it has
broadcast since being powered up as well
as the elapsed time that has being that
has occurred since the last time this
beacon was reset okay now in and of
itself that information it may seem a
little superfluous and uninteresting but
you'll see in just a moment that it ties
in with another offering that Google is
providing that will make this a little
bit more interesting on the scanning
side just to kind of give you the idea
before I show you a demo a little bit
later because these format are these
packets don't actually I tie back with
an identifier the application that you
write has to scan for all the different
packet types so it has to scan for the
ID packets as well as the telemetry
packets and then be able to match them
up using basically the device address so
if you get an ID packet from one address
and then you get a telemetry packet from
that same address the idea is they came
from the same beacon and it's up to your
application to match those together so
that you know that this beacon that now
has this URL also has this battery
voltage temperature so on and so forth
okay so it's also up to the application
to actually do something with that data
right these are not connected to the
Internet in any way these are just
broadcasting this data out in a very
short field of ramage so it would be up
to the application picking this data up
to transmit that to something where it
could be handled on a more useful way
like a back-end server question at Lee
have two right so the idea is that your
beacon device would alternate
advertisements between its identifier
and its telemetry data probably in
sequence
yeah absolutely so if it advertises both
that's how you can pick them up so again
by itself
this may seem kind of strange but just
hold onto that thought for a minute
because the next thing that I want to
talk to you about is the beacon API is
that Google has released as part of
basically they introduced this stuff on
the backend at the same time that they
introduced the other stone format now
there are there are a handful of
proximity beacon API is that are
available you can access them in the
Google developers console and they're
intended to
Hance a beacon deployment in ways that
we haven't really had access to unless
we were writing this ourselves in one
form or another okay there's a couple
features of this that I want to go
through with you the first is what I
think is the most interesting is this
idea of attachments so using the
proximity beacon API you can build a
system that's a little bit easier to
maintain where you can provide more than
just the 31 bytes of data associated
with the beacon you can now provide up
to an additional 1k of data structured
pretty much however you want whether
it's key value properties or blob of
JSON or anything like that associated
with what that beacon represents right
so go back to the example I had before
where I've got a beacon at the front
door and I've got one at the back door
and rather than relying on my
application code to know that beacon 1
equals front door and beacon 2 equals
back door I can use these back-end api's
to make that basically make that
marriage between the two on Google side
and say that this beacon in my
deployment is the front door and the
speaking of my deployments back door
give them a roll and then when the
scanner picks up that information it can
also from Google's API is get the
attachment data associated with that
beacon which could be this is the front
door this is the location of the front
door you know all this other information
that I might need associated with that
and I can get those two things together
now
you can either do this manually this is
a REST API so you can make calls of it
manually in your code or again the
nearby messages API is intended to do
all of this for you so if you're using
these things properly then eventually if
you're using nearby messages the
attachment data and the beacon discovery
will actually come to your application
together ok so it almost becomes
seamless to where it looks like the
beacons are actually transmitting larger
blobs of data than they actually are ok
so that's really cool
the to sort of make this a little bit
simpler on the deployment side of things
because of this idea that we're now
marrying attachment data to what work
basically calling a beacons role instead
of its
cific instance what happens if the
beacon that is at the front door crapped
out now maybe not necessarily the
battery dies because that's easy enough
to fix but what if the radio blows up
right or the chip dies or it gets too
hot and somebody lets the smoke out
right how do we deal with that problem
in the traditional sense if we weren't
marrying beacon IDs to their roles
somewhere other than our application
codes if we actually coded that into our
app then we would have to ship an app
update just to be able to say that the
new beacon we put out there is now
beacon ID 12 instead of ID 1 okay the
the back end API allows you to do that
by provisioning and decommissioning
beacons for those roles so now when the
beacon of the front door dies and I have
to buy a new one and put it in its place
I just go to the backend API and say you
know what the beacon at the front door
is now 12 it's not one and the
client-side code on the mobile device is
none the wiser right it just knows that
when it goes and observes this beacon
and sends that information up to the API
the API says yep that's the front door
right so it allows you to manage your
fleet of beacons out in the world in a
little bit more of a simplified fashion
okay by tying them to these roles and
the last piece has to do with that
telemetry data that I mentioned before
so that telemetry data becomes useful if
I can marry it to these roles and I can
upload that summer so the the proximity
beacon API is also will accept these
telemetry packets from your application
so that as users are walking around and
detecting these things you can get
information up in the backend service
about how your deployment is doing
do you have beacons where the batteries
are dying do you have beacons where the
you know the temperature looks out of
range or something like that because
you're getting data from the the
application associated with this you can
also add your own information like the
location that this beacon came from is
this beacon 200 miles away from where
it's supposed to be you know and you can
set alerts on all of that data so in
them in the backend API you can say if I
ever get a low-battery warning on any of
my beacons send me an alert or that
location if it's too far away
send me an alert right so you can start
to build some more fleet management
functionality into just when is
otherwise these little pieces of
hardware broadcasting third one lights
right so you can start to kind of tie
them together into what looks like a
cohesive application management solution
now instead of just trying to do all
that in your application code or writing
your API yourself okay now one of the
really neat things about all of this
stuff that I just showed you is it
doesn't just support any stuff right so
the proximity beacon API is will accept
beacon data from I beacons Eddie stones
and all tinkin to so if you were one of
the two people in the world actually
using alt beacon and those are out there
in the world already it's okay you don't
have to necessarily replace them to use
this API now not all of that data is
there not all unquote right because
things like alt beacon and I beacon do
not support the telemetry data format so
if you're bringing those beacons into
this back-end service somehow you'll be
able to get the basic features like
provisioning and attachments and all of
that stuff but you're not going to get
the diagnostic functionality there
that's only going to be useful if your
beacons can transmit that kind of type
of data somehow which that's only
supported as part of the Eddystone
format okay so if you're using other
beacon formats in your existing
deployments you can still use these
api's you know have to change a bunch of
stuff around just yet okay so that's
kind of cool yes I mean you know again
at the moment the API has only been
released for about two weeks right so it
is still fairly early they're not
calling it beta enough so they consider
it to be stable but it doesn't have a
lot of infrastructure built around it
just yet a lot of that infrastructure at
least on the Android side is going to
come from Play services and you can
pretty much guarantee that Play services
on iOS is going to have similar
functionality so if you're using beacon
in a cross-platform application you can
still use the Play services client
libraries to be able to simplify you
know that coding so you don't have to
hit the REST API directly but that
infrastructure isn't released yet so
using it now means you're actually
manually making rest calls to an API
endpoint you have to deal with the
authentication bits and all that mess so
it's a little messy right now but it is
stable you mean financial cost so none
of this stuff has a cost associated with
it so all of these API is you know as
well as you know Google Play services is
is you know part of any Google based
Android device already and all that all
those back-end features are available
for free they're part of the Google
developers console like the rest of
Google's API well so my understanding is
and if you're doing this yourself then
you're kind of on your own but I mean
this this is a web service that you're
hitting so if you don't have that data
at all meaning you've never seen this
beacon before and you're trying to get
that attachment and you have no
connectivity there's really no path to
get it because it comes from a web
endpoint now the my understanding is
that when you start getting to the
nearby messages portion of this API
their intention is to cache that data to
what level and for how long I don't know
but for instance if you had a beacon
attachment and you already seen that
before and you came back to it and you
didn't have connectivity the idea is
that play services could return you the
cached version instead of having to go
hit it from the network so there is some
of that potentially built into the
client side but it is a web endpoint so
if you can't get to the web and you've
never seen it before there's really no
path in the design to get that data okay
all right so let's move on a little bit
and talk about this next format here
called the Eddystone URL so
this is a little bit more interesting at
least from my perspective in that it it
starts to enable some applications that
we haven't necessarily seen before right
the Eddystone UID is fairly similar in
just a slightly different format to the
type of beacon technology and the
applications it serves then that we've
had for a while now but any stone URL
goes a bit beyond that so just to give
you a little example here I mentioned
before that basically the intention here
is to take a URL which is a format we
all know and love and encode that
somehow into the advertisement ok so
just as an example you know if I had a
URL like the URL to our company's
Android page the Eddystone format would
break that URL up to look something a
little bit more like this okay so the
difference is that the well-known
portions of a URL like the schema prefix
and the domain suffix and those things
that pretty much ever you would URL has
those can be encoded into a single byte
okay whereas everything else in the URL
is basically one byte per character it's
all just ascii encoded data so this
allows us where possible to try and
compact these things down by not wasting
a bunch of characters for things that we
know what they are right so there's
there's a table of prefixes and suffixes
that have op codes essentially
associated with them that's defined as
part of the format and that way when you
if you're going to try and define how
should I encode the URL that I want to
advertise into my beacon you can use
that to sort of condense things down a
little bit now this is nice but let's
face it we've seen the URLs that are out
there on the web and even a couple you
know couple characters here and there it
ain't gonna be enough to necessarily get
these long strings from products on
Amazon and stuff like that condense down
into a little 31 but URL right but we
have a technology for that on the web
right that we've used forever URL
shorteners so a very common pattern
associated with doing some sort of a URL
beacon deployment is that you would most
likely be shortening your URLs using
some common URL shortner bitly google
whatever one you prefer and then putting
the shortened URL on the beacon instead
because those are always typically
condensed down to roughly the same
length and fit very nicely on to a
beacon format okay now
I'll mention it a little bit later on
but there are some specific advantages
from a beacon perspective in using
Google's URL shortener so if you don't
have a favorite for some other reason I
would recommend the one you choose is
good GL to shorten anywhere else you put
on a beacon and I will tell you why in a
little bit okay all right who can tell
me what that is a QR code what's it for
but what do we use it for typical a URL
and where do you find these things give
me an example on a screen okay sure so
you'll see it on a vending machine I
thought somebody might try to scan it
you'll see it on a vending machine
you'll see it on the back of a bus and
you know you'll see it on the on a movie
poster or something like that and the
idea is the reason it's there is they
want you to walk up to it
take out your phone scan it and it's a
way of taking you to more information
about whatever you're looking at right
so if I'm looking at a movie poster the
QR code probably tells me what the
latest show times are or something like
that or if it's an advertisement in a
magazine takes me to that company's
website where I can get more information
okay this is we've been using these
things for you know five plus years at
least in there everywhere but as we've
just seen from the folks here in the
audience the difficulty with that is it
forces someone to find their phone in
their pocket take it out find the
application that can scan a barcode
because it's not just native to any
camera app you have to have the barcode
scanner and then try to line it up and
do that and if you're like me you've
tried to do that
driver right so it's not the best
experience the intention at its core of
the physical web is basically to be the
evolution of the QR code right so the
the tag line that they use with the
physical web is you can basically walk
up and use anything the idea being that
with the appropriate configuration on
your mobile device we can now using this
URL based format we now have devices
that can advertise that same URL that
you would have encoded into a QR code we
can broadcast that out to passers-by and
now the device that's in your pocket can
detect that it's walked by that while it
stays in your pocket and it may generate
a notification if you have a wearable on
like me then it might show up on your
wristwatch that hey there's something
more to see about this movie poster you
just walked up to or something like that
and if you want to you can pull out your
phone and engage with it but you can get
a very quick some quick context about
that piece of whatever it is that you're
walking next to and that information is
being pushed to your device you don't
have to it's not a pull based model
where you have to go in and get the
information from the QR code it's now
being sent to you the other direction
but the end game is essentially the same
right it gives you to a URL which is a
resource that most likely goes out
somewhere on the web okay so this is the
basic architecture of what we call the
physical web it will go from the right
and kind of work our way to the left it
starts with these advertising devices
and there are several different types of
them excuse me the the Eddystone is just
one of many different types of
advertising devices that they define in
the physical web spec it also happens to
be the only one that runs over Bluetooth
so Eddystone devices broadcasting URLs
fit into this paradigm but a physical
web also supports mdns UPnP and SSDP as
technologies in which you can advertise
now anybody who's familiar with any of
those tell me what they have in common
in terms of their
ecology does anybody know what those are
they're all running over Wi-Fi that's
right or they're all basically TCP based
so they typically would be running over
the Wi-Fi in your home right mdns is
like Bonjour zero configuration
networking for self configuring wireless
devices like printers in your home that
sort of thing
SS DP is the detection technology that
chromecast uses you can find your
chromecast in your house before it's
paired to your Wi-Fi network that sort
of thing so the basically ways of using
a Wi-Fi radio to broadcast similar data
into the same destination right so it
basically just means that if Bluetooth
beacons doesn't fit your application but
you're still interested in the physical
web there are ways using maybe in the
home or in like a coffee shop where
there's public Wi-Fi or something like
that other mechanisms through which you
could deliver these transmissions to a
physical web scare okay so just keep
that in the back of your mind if if that
interests you you can look at the
physical webpage and they describe in
the spec how to actually implement that
and all that sort of thing it is Haq
yeah but it doesn't require the devices
to be associated right so that's why it
allows you to broadcast over that chain
without necessarily having a device
associated the same way that the
chromecast is able to detect before it's
actually on the network okay so all that
data has to get fed into some sort of
client on your mobile device right we've
been calling it the physical web scanner
so in and of itself it doesn't sound
like we're changing a whole lot in the
paradigm from QR codes right there still
has to be something on your phone they
can pick these things up it's just that
instead of it being a barcode scanner
camera based app it's now this physical
web scanner app that you go download
from the Play Store or from the iOS App
Store okay so this app does exist you
know Google provides the physical web
app you can download it on either the
app stores right now on your device it's
been there for quite a while now
and this is an application that allows
your device to scan for these URL
beacons wherever that might be so you
can be interacting with that application
in the foreground and it will list for
you beacons that are available and give
you access to you know access to
interacting with that URL by just
clicking on it they also run that
scanning in the background so that at
least on an Android device if you walk
by something that is advertising a URL
it will pop up something in the
notification shade that you can interact
with without having to actually be in
the app okay so it's doing the scanning
in the background as well as allowing
you to interact with it physical web so
the advantage over private deployment is
that this is one app to scan them all
all right as opposed to each individual
one because this is generating
notifications it also means that if
you're using something like Android wear
that gets pushed to something you can
see without even having to take your
phone out of your pocket right the
Google would refer to these applications
that are in the store now as prototypes
this is not the final solution okay
eventually I can't say exactly when or
where or what this is going to look like
but it's pretty much a requirement for
this to really gain adoption that we
have to overcome that hurdle of getting
someone to download something I don't
care if it's a physical web scanner or a
barcode scanner or what it has to be in
the platform already okay so eventually
Google will be working towards that goal
okay so at some point you will see this
show up somewhere in the lower layers of
the system now I don't know exactly
where but I can tell you this but last
week they released an update to Chrome
for iOS and Chrome for iOS now supports
physical web scanning inside the browser
okay so basically if you're running
Chrome on your iOS device and you walk
past these URL beacons that we have on
the room here you will see that pop up
in a today widget for Chrome okay so
they're all red
starting to push this into software that
people would otherwise have not
something specific now interesting that
they only did it on iOS which tells me
either it's not going to be in chrome on
Android or they're just behind which
would surprise me so we might see this
in a different place on the Android side
it might actually be in the platform and
might pan play services it might still
be in chrome and it's just not released
yet but we are seeing them already start
to do this so this is going to continue
on in the future which is I think the
really cool thing about this is that
you're going to be able to use this
technology and people aren't going to be
required to download anything to work
with it okay so that's a big jump
forward all right the other piece of the
physical web is it's a back-end service
that we used to refer to it as optional
when physical web was something that we
thought people are gonna have to
implement them themselves this is pretty
much something that Google is handling
for you but it's just sort of
interesting to know that it's going on
there is a back-end client service or a
back-end service that the client
application actually interacts with that
they call the physical web service
running up on App Engine
the current version that hooks to the
prototype app is running on App Engine
but it could run pretty much anywhere on
the open web this is an interface
between the client app and the actual
open web so it does a couple of things
for the user application attended some
of them are security based others are
just to improve the experience but you
think about the idea just at its at face
value if I have all these beacons in the
room and they're advertising URLs and
those URLs are shortened then just by me
walking around and picking up the URL
values themselves that is not incredibly
useful to a user they basically see a
bunch of goo GL with a mess of
characters after it have no idea what it
actually is so we have to have some way
in the client application to be able to
figure out what that URL represents okay
and so the physical web service does
that for us
so that when the user sees the entry in
the
ocation instead of seeing that shortened
URL they see something that looks a
little bit more like a search result it
has the link title description and icon
a bunch of metadata because the service
has gone and queried the actual URL
followed the redirects and gotten what
the actual page is associated with that
value okay so it simplifies the user
experience it also means that when the
user clicks on the link they don't have
to go through all those redirects they
can just go directly to what the
resource was in the first place and
that'll be important when we talk about
deep linking these things into a native
app okay so they do some of that work
for you but there's also a security
aspect to that which is as soon as any
device makes a request of a URL whoever
is hosting that can track that page
request so if the device in my pocket is
constantly checking out URLs just as
it's walking by technically speaking
those are me those can be tracked for
analytics purposes by the individual
servers okay which is probably not
something that we want I wouldn't mind
so much if somebody tracked a page hit
when I actually click on the link but
maybe not so much if I'm just walking
past ten to the beacons okay now the so
basically the way that this architecture
works is it ensures that the client is
only talking to this one service so it
still has to make that fetch request but
it's always talking to Google basically
and then Google does the work of hitting
those individual URLs the same way that
it would crawl a search result so that
it can return that metadata back so it
insulates the user from constantly
potentially getting tracked through
different analytics on different web
sites just by walking by these things
okay so again this is all just
interesting to know it's something that
Google really handles for you under the
you know under the covers of what we
call this thing called the physical web
questions so far okay so this is really
interesting but on the face of it you
think great we basically just created a
way for people on their mobile device to
go to web pages well we're all app
developers we want people going into
apps web pages that's why we're here so
the the advantage of
using this is that we can do that very
thing if it fits our purpose so using
technology that's been in android
forever and even in iOS for a very long
time we can code our native applications
to react to ERL right this is not new
although you may have not seen it before
using at least on the Android side an
intent filter that looks something like
this on an activity you can declare in
your application that if a link is
clicked on this device that matches this
particular format I want you to launch
my activity not go launch it at the
browser right and this supports URLs
with a custom scheme which is what I've
got up here on the slide but you can
also do this with an HTTP URL so I can
declare that my native app handles URLs
that are the same as my website and then
when somebody clicks on a link to my
site they will go to my app if they have
it or to my website if they don't right
so it enhances that experience in
allowing you to view the content in the
native app if you are too got it so it's
that idea of re-engaging users with your
app because they walked by something you
own but if they don't have your app they
can still interact with the content
right it still shows up as a URL that
they can get to and do something with
okay so that's where this starts to get
really interesting is being able to take
these URLs and deep link them into your
apps wherever possible
now there's another Google technology
that you may or may not have heard of
called app indexing and there's actually
a session I think right after mine in
this room on app indexing and search so
if you can learn more about how that
actually works
probably by just staying here but
basically what this was originally
intended to be was a technology that
allowed Google to crawl your site so
what you're looking at here is markup
that you would have put on your website
as a way of indicating that these are
the pages on my website and this is how
they map to content in my app right so
an app indexing markup says if a URL was
intended to go to this page but the
request came from a mobile device we
could instead redirect them to
one of these particular URLs depending
on whether they're on iOS or Android
okay so it pairs up your web content
with your app content and was originally
done so that when Google when somebody
ran a Google search the search result
could have a link to the site or a
direct button to go into the app and
they actually extended that even further
than if you if you did the app indexing
markup correctly then it would allow the
user to install your app directly from
the search result if they didn't have it
okay that was the original intent of app
indexing which in and of itself is
pretty cool but they've recently added a
feature remember back I told you there
was something important about Google's
URL shortener they recently added a
feature where if your site is marked up
using app indexing and you use Google's
URL shortener then the shortened URL to
an indexed page will automatically on
mobile devices take the user to the
indexed essentially the native app
indexed URL instead of to the web more
okay now this is this can be helpful
depending on your application because
both iOS and Android at least in the
latest release or upcoming versions do
support an application to to accept an
HTTP URL as a deep link but that was not
always the case specifically on iOS not
all versions of iOS can take an HTTP URL
and watch an app on iOS they have to
have a custom scheme prefix but that's
no longer true as of iOS 9 and Android
of course supports either one they have
for a long time so this can be useful
because it would allow you to generate
one HTTP URL that could direct
automatically depending on your platform
to a specific other URL in your app now
this may also be useful if you don't
want to if you don't want to mark up
your application activities with the
HTTP URLs if you want to use two
completely different schemes that don't
match page for page you can still use
app indexing to determine for this page
this is the URL should go visit and get
a little bit more custom with it and as
long as you shorten the URLs to the web
pages then Google's back-end will make
sure that on the mobile devices it goes
to the right deep link for iOS and for
Android okay so if you're if you index
your site and you use Google's URL
shortener and put those shortened URLs
on your beacons then you'll get that
best deep linking experience available
whether the user has your app or but
still usable if they don't okay so
that's kind of cool
the last feature that I'll introduce you
to just briefly is that it has a very
specific use case but I think it's a
common one so with what we've been
talking about so far the nice way about
that working is that again if they have
your application installed they can deep
link content directly into your app but
if they don't they can still go to the
web so they don't lose any functionality
they just have a better experience if
they've got it if instead your intention
is essentially to either get people
interact with people that are using your
app or get people into your app and
that's your only end goal you can the
the URL links that you can shorten for
your beacons can be these app invites
okay so an app invite is a beta feature
that Google intranet introduced at i/o
this last year basically it's a way for
any of us to create a URL that we would
share with our friends that's just a way
for them to go download the app that
we're using right and it's designed in a
cross-platform way so that I generate
one URL and if they're on an Android
device that goes to the Play Store or on
an iOS device it goes to the App Store
but the nice thing about it is that same
URL can be set up as a deep link in your
app so if someone clicks on it and
they've already got the app they can
just launch the app directly so it's the
same basic functionality but the
difference is if they don't have the app
that you are or that link they click on
will go straight to the app store it
doesn't have to go to a web page where
you might redirect them to the App Store
or ask them if they want to download it
so if your end game is use my app or
download it you could use an app invite
links shortened on your beacons and they
will interact that way you later go to
the App Store or you'll jump directly
into the native app to interact with
whatever that
okay the difficulty here is an app
invite URL is auto-generated so other
than launching the app you can't really
craft what that URL is to take them to a
specific resource but it does allow you
to basically determine App Store or mine
app which is something that app indexing
is not really intended to do that well
okay all right just a couple more things
before I show you some demos I've got
some links up on the page here and of
course the slides are available so you
can look at them there but just a couple
things if you want more information I've
got the the github links up there for
the physical web project as well as the
Eddystone format this is all open source
it's on github you can even contribute
to it if you want
I've got additional samples code beat on
what's on the Eddystone page on my
github page which is mile-high Android
and some of those examples I'm going to
show you but I won't have time to show
them all to you so you can look at those
and you can play around with some
additional stuff there
if the Bluetooth code that I showed you
on the slide a little while ago if that
made absolutely no sense to you because
you've never used those api's before I
have two video tutorials that I've done
in the past on the Bluetooth le API is
just from when they were introduced and
then an update for the new stuff in
Android 5.0 so that can kind of help get
you started if this is completely new to
you before you start playing around with
some of this stuff in a little more
detail and I've also got the links to
the two google videos when they
announced Eddystone and the proximity
beacon functionality okay now as far as
getting hardware
there's probably oh I don't know
probe to eight to ten different
manufacturers right now that are
claiming to make Eddystone compatible
beacons or will be making them in the
future because they may die beacon or
anything like that in the past I've
narrowed it down to my three favorite
and I have examples of most of these
here in the room somewhere so my
favorite beacon companies cache
technologies part of that is probably
because they're local to where I live
but you know it's a small shop great
team of folks and I've got several of
these beacons around the room I the one
thing I really like about them is they
don't try too hard
to give you too much stuff right the the
KST beacons are designed to work with
the framework api's on both platforms
they don't give you this giant SDK
they're trying to insulate you from
what's going on they let you just use
the simple API is that are already in
the framework okay and a lot of these
other guys like esta mode and even
radius to some degree try to give you
all these SDKs to do all this work for
you and sometimes that just ends up
adding more unnecessary junk okay but
one of the things that may be a
disadvantage if you're working with KST
is that they're beacons are only
battery-powered okay so they have
beacons sort of like the one I've got up
here although it doesn't look quite the
same that are run off a coin cell
battery and that's the design that they
ship which may work great for you but if
you need something that is all powered
for some reason there are other options
out there so that the beacons that
radius makes they make or they ship a
beacon that is USB powered and I've got
a couple of those around the room as
well that I can show you after if you're
interested then allow you to basically
just plug it into a wall outlet stick it
over and it can run forever right
because you don't have to worry about
the battery dying or anything like that
so they have a very useful development
kit that again is very simple but they
offer powered beacons whereas KST does
not and then the last one which seems to
be Google's favorite is become my
favorite thing about beacon is not
necessarily their hardware but they have
a back-end service that they call spy
dotnet which is intended to be a
physical web deployment management
solution right so all that stuff that I
just talked about with the proximity
beacon API is they pretty much are gonna
give you a turnkey solution that already
works with that stuff so you don't have
to just you don't have to try and write
your own web application to enter it
interact with those api's you can have a
turnkey solution available if you work
with them as well okay so those are
those are kind of my three picks if you
wanted to go out and buy and play with
some of this stuff today okay all right
I think I've got just enough time to do
some demos any questions before I do
that yes they should be on the slide
site so was it an DEFCON 5 sides
something like that yeah okay on the
mobile device you mean yeah so what's
the effect of battery life on a mobile
device you know it's it's up to the
application really because unfortunately
you have a lot of freedom and how you
run those scans in Android so you an
application could very well run a scan
in the background at a very high power
level which wouldn't have a significant
impact on battery whereas if you use at
least the newer api's with setting those
scan settings to the appropriate minimum
power levels designed for background
scanning then the idea there is that the
the scans on the overall battery life of
the device should be negligible
right you've given all the other radios
that are always active and that sort of
thing anyway so it partially up to the
application now in the terms of dealing
with Play services and some of the newer
api's that means Google handles that for
you and your you basically have to be
fairly trusting that they're doing that
appropriate before that specific device
which I would imagine they are and same
thing with the physical web right so
those are intended to use the lower
power scanning modes of the device which
should make that impact on your battery
negligible but if you're using a private
deployment where the application is
responsible for that it's really up to
the developer they are still able to
shoot themselves and put it if they're
scanning a too high of a power alright
jump over to Android studio here alright
I think what I will do is I'll show you
the demos first and then we'll see how
much time we have to go through code so
let me connect my device here because
look lovely Bluetooth is not one of
those things you can do later all right
so well I've got a couple of demos here
that I'm going to show you the first is
so I've got a few beacons sitting around
the room and the the first of them is
all of the KST beacons are programmed as
any stone UID okay
so I'm just going to show you a very
basic scanner and then we'll see the
code because the UI of the app is not
that interesting and then I'm also going
to show you a basic example where I turn
my Nexus 6 into an Eddystone URL
advertiser that can be picked up by the
physical web okay so we're gonna see we
have time to go through both of those so
the first one here is my is my Eddystone
scanner application so I can just pop
that up and again the UI is not terribly
interesting it'll come up in a second
the basically what's going on here is
I've got three of them around the room
and this application is just going
through and parsing out the instance ID
of each one which is serial number of
the board in this case that's how they
program them originally but it's also
taking those telemetry packets that are
coming out at the same time and marrying
them together so that you can see them
both in the same list item so when you
actually look at the code which is a lot
more interesting than what you're seeing
on the screen you can see how we pull in
the UID packet TLM packet and match them
up as they come up from the device okay
again this is something that you
probably won't have to do a fuse the
Play services API is eventually but for
now you kind of have to do that work
yourself
okay so there's an example here and you
can just see those things kind of move
in and out as they detect them at not
and you see the battery voltage these
don't have temperature sensors on them
which is why that shows a zero but you
can kind of see all that data in there
and working so I'll show you the code
for that in just a minute
yes yes yes it is that's that's where
it's being well actually you know this
application I believe uses the buff
because that the RSSI is is it's
computed by the device every time it
receives a packet from an advertisement
so I believe this application is
actually using the one from pulse so any
time it gets an RSS I value for that
device is updating what you see on the
screen okay so that's the first one and
then the second one that I'll show you
here
as soon as the thing catches up is just
a very basic example that allows me to
add a basically broadcast a URL from my
device now this is something that not
every Android device can do advertising
functionality is hardware specific and
there are api is in the in the bluetooth
LE api set that allow you to determine
if your device can advertise or not so
this is this is something that would be
specific to your device potentially it
might may not be something you want to
ship to a consumer app that everybody
would be downloading but for instance
the Nexus 6 supports advertisements so I
can punch in and URL and I've got a
default there and then I can hit
broadcast to start broadcasting that URL
out to anyone who's listening now that
is a shortened URL to our website new
circle comm slash Android okay but you
can see just in terms of the application
what's what's added here is I pop up a
little notification in the shade here
that just says when the URL is that were
broadcasting and that's being done in
the background so I could leave the app
or something like that and it wouldn't
wouldn't cause a problem but if I leave
that doing its thing and I move over to
my other device which of course has the
USB cable job so depression now
this physical web application is the app
you can download from the store I didn't
modify it in any way or anything like
that so I can pull up the physical web
app and it's gonna start scanning for
beacons in the area now you can see it's
picked up several of them because I've
got several around the room I've got
beacons from KST I've got the radius
Network URL I've got another one here
for a sample application that I've got
downloaded and then my new circle beacon
and here is in here as well now what you
can see going on and because the network
connection in here is not stellar taking
a little bit of time is that it picks up
the URL initially but then the physical
web application is going out to the web
and figuring out what
those URLs is so what I'm actually
seeing once this is all said and done is
what basically looks like a Google
search page right so what I see it will
looks like a series of search results
but what I'm looking at are the URLs
broadcasted from all of the bits around
them so that new circle element is here
is coming from my Nexus 6 right now
whereas the rest of them are broadcast
from the beacons that have been powered
on since we all walked in the world okay
so and then I can interact with these I
can click on them and for instance the
new circle one will take me into chrome
and eventually will take me to the new
circle web page which probably won't
work given the network conductivity but
you can envision that the other bits
that are interesting though is that one
of these URLs as actually paired or is
is designed to match up to an
application that I have installed on
this device so there is a sample
application that's just this is a Google
sample I didn't write this but it's
called the recipe application that
supports deep linking behavior from
recipe opcom which is the corresponding
website so what I've done what's on
these physical web beacons is one of
them is broadcasting a URL to recipe
opcom to a specific recipe and if I
click on that URL from this application
here then it will take me directly into
the native application okay instead of
taking me to the web now because of the
because the URL resolve is taking too
long that may or may not work but we'll
give it a shot
and if not come up later I can show it
to you now one of the disadvantages with
the current version of the physical web
app this has actually been fixed but it
hasn't been shipped to the App Store yet
the current version of the physical web
application actually does proxy anything
you click on through their App Engine
application which as I mentioned before
it can be a problem for user experience
because if I want to in this case do
something like a deep link it still has
to take me to Chrome to resolve the link
before it
me too the native application like you
just did okay that's been fixed so
whenever you see a physical web
application update in the Play Store the
new version will take you directly to
the URL so it would jump me straight
into the native application instead of
going through pro first but if I didn't
have this app installed then it would
just take me to the web page so it
allows me to interact with that content
and allows me as a content creator to
interact with my users whether or not
they have that URL installed or that
application installed sorry okay yes
from the Nexus device could I have done
it using Wi-Fi I don't want to say no
because there might be a way to do it
but I I can't off the top of my head
work out the code that would use the
api's to do so but you can I know you
can do em DNS broadcasting you know from
a device like this so I would imagine
yes I just I can't rattle off what it
would actually look like okay so okay
given what time it is I don't think I'll
be able to go through the actual code
but the code of the two demos that I
just showed you are on my github so what
I'll do is just briefly remind you that
my github page which you can get from my
android or you can just go to github.com
slash add em up wired and you can find
them there the beacon samples that are
listed here are basically this that'll
take you directly to the source code for
the two things I just showed you you can
download them you can play with them on
your own device do whatever you want
with them so okay but other than that
I'm out of time guys so I'll stay up and
have any questions if you have any other
questions or anything like that but
thanks for coming this morning
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>