<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Android Builders Summit - A Walk through the Android Stack | Coder Coacher - Coaching Coders</title><meta content="Android Builders Summit - A Walk through the Android Stack - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Android Builders Summit - A Walk through the Android Stack</b></h2><h5 class="post__date">2011-04-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ygP3_1Lzrj4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Alexander garganta I'm Marcus
brother who you probably saw and last
talked I'm Yankees younger brother so I
guess I get half as much space as he
does and but and I don't have to also
give you a little disclaimer my slides
are not as sexy as it his are basically
this is going to be an HTML driven you
know slide deck off of asking doc so no
pretty pictures that said hopefully
there's gonna be a lot of useful content
so as far as what brings me here I have
been doing Android so for the last few
years I happen to run the san francisco
android usergroup so if any of you are
in the area we meet them every last
Tuesday of the month with exception of
actually this month but you know you
should come check us out I also work at
Marikana and I do training on a lot of
different things including Android so
this talk is effectively on the Android
stack some call it the physiognomy
autonomy you know geology of Android
however you want to call it basically
where we get to dig a little deeper into
what those layers or what are the
features of different layers why are
there you know why is Android why does
android look the way it does again and
hopefully we'll have some time for
questions towards the end so we're going
to basically look at the layers of
Android which right now you probably
know because you've seen a million times
meaning all these gold or diamonds from
the linux kernel layer and then going up
the stack the native libraries layers or
native layers they call it application
framework layer what's in there and to
the apps yourself and I include apps in
this in this player because apps or
whether you believe it or not part of
the API of Android ok so there's enough
stuff at the a player that basically
without which android would not be a
completely market and when it comes to
android itself i like to classify
android
as a full-blown OS so and this entire
set of pieces all these four layers are
part of it yes so for us understand we
need to basically understand he's left
so this is the this is the kind of the
the picture that i was mentioning i'm
sure most of you have seen it and so
like i said we're going to be looking at
this bottom-up and again these are
scrollable slide so please bear with me
and I've never actually renamon this
resolution so hopefully things are going
to work out so as you guys know being
this is you know linux bumpers up there
all android runs on linux so this is the
first part is us looking at the linux
back and this oh I don't know if it's
useful or not these are kind of the
versions of Linux as implemented by
different versions of Android the common
branch under the Android get fries to
638 it's fairly current okay now that
said I'm sure you've heard of it but it
doesn't hurt to reiterate it android is
not linux as if it's not a linux OS the
way we think of linux OS it uses a
modified linux kernel as we know and
that's what we're going to discuss but
there's no julep support there's no
windowing system a lot of standard files
that were used to you know password file
at the stab clouds don't exist I even
utilities they were used to don't exist
you know su whatever CP of course that
shouldn't surprise you given that Europe
mostly you know coming from the embedded
environment where you know some of these
things go through but fact that there's
no seer you know julep support means
that we can't actually run and you
understand it linux tools without
recompiling and specifically for android
animals specifically against the own Act
which we'll talk about later so the
Linux kernel why does and reduce clinics
and again you know apologies if you've
heard this many times first and foremost
for hardware abstraction model right so
Google realized that it doesn't make
sense to read one of the wheel and they
went my dad I mean not only defining you
know the driver model but also going out
and riding drivers for these you know
thousands of devices that are out there
so we basically get that for free and
for the most part unless the drivers do
for example the you know wakelocks for
the most part linux or Android device
drivers are the same as well against
device drivers that you would use in
other embedded project so there are not
too many surprises here the way plots do
make make something obviously by this is
a new concept introduced by Android so
that makes a difference the other reason
why or the other reasons why we use
Linux is for the process and you know
memory management and all this lead
through that we also get security of
installation or sandbox and as you will
see later when I mention it the the
process layer at the Linux kernel is the
security boundary between the different
applications that may run on an android
system and of course we get support for
shared libraries for being able to load
shared libraries and the complete
network stack now the application and
developers replication users and
developers never really see the Linux
kernel they never really interact with
it and yes there is the adb shell but
you know what's except for developers
are there specifically interested in
that nobody is expected them to actually
go into the Linux layer and you know do
anything in there so while you know
there may be three hundred thousand you
know android devices being activated
daily those people don't think of a
300,000 Linux you know a device is being
active daily because they don't think
about the next player um the as you know
as you've heard for current stock and
tomorrow as well android basically
forked the linux kernel and this
specifically because of the changes they
made and we're not accepted by the main
male and linux kernel so they basically
have a separate get free some of which
is specific to the different devices the
MSM right the qualcomm stuff or map p IM
up tips at samsung and of course there's
the official mirror of the main branch
can so if you were to check out and crim
actually mentioned that as well if
you're to check out android you know on
the mixer the main linux kernel you
could then back toward the changes or
you would actually go and check out one
of these in
move over there of course a lot of the
device manufacturers like you know
thanks sista means they will provide you
with a kernel that is more already well
suited for their particular hardware so
that's usually the starting point that
most people deal with now the real meat
of this particular part are the
extension so that's kind of what I
wanted to go over so i'm sure you've
most most a lot of you a part of the
binder IPC which is basically the big
interprocess communication model that
android offers specifically android
chose not to use the cyst which is the
IPC model and I'll get into later on why
this open open butter or binder based
IPC is wasn't pioneered by Android it
comes from the early work on the palm or
so I should say BOS which was then
require right palm so it was actually
part of the problem called OS before
gained and sell switch to linux enough i
guess whatever so the the concept or the
the motivation behind binder is to
provide a an operating system which
effectively offers or enables and
object-oriented system environments okay
where your services Ryan object-oriented
fashion and pretty much that's how
Android is built most of the services
especially when we talk about the app
application framework layer are
effectively exposed to the binder
without binder Android do not function
ok so it is in a sense of very similar
to poor button in what it offers but
it's you know Hector lot simpler it is
its foes through the / bachelors binder
you know that's very effectively the
binder is a driver in the kernel the
wrong timing for you can query at the
practice binder and as I mentioned like
I said most of the system services are
dependent on it so this rely pc has sole
source of security and performance
challenges some of which involve initial
later on when we discuss Bionic and now
the reason why you know or the reason
why Google
or the Android King's wine for binder is
because they felt that it was the right
lot you know lightweight performance
sensitive implementation of an IPC then
they needed in order to construct a
fairly object-oriented apart so the
bound services for example are
automatically cordwood garbage collected
I claimed up by the kernel as the
caller's disconnect from their qualities
from the from the services that are that
there were basically being utilized the
order the binder framework also provides
a built in a thread pooling support so
basically if you're creating a bound
service you don't have to worry about
the low level communication issues with
all small level threading issues so
it'll automatically handle the other
thread for you of course on the bouncers
can also be used within a single process
right I mean the whole point I ypc is
obviously for your first communication
but you can also bind to services that
are in the same process in which case
you're just using the same threat by
default binder offers asynchronous
Paul's to order the cause feel
synchronously they feel like local
function calls but as a recently they
actually also added something called one
way which is a way of if you were to add
that to an interface which is in the
case of binder supposed to something
called a iel that would basically mean
that at all the caller's calls are
asynchronous so the caller makes a call
literally it returns right away and the
binder mechanism ensures that the the
actual request is delivered to the Kali
the implementation should you want to
look at it is again this was supported
originally from the from bos than palma
now Android but is available in between
the colonel sorcery at drivers miss
binder so you can actually take a look
at it ash ma'am are the non shared
memory is a reference counted virtually
mapped and they say virtual net because
the p man with no visible c is not
virtually map named memory block that is
basically they can be shared between
different processes and kernel is
allowed to free this so it's different
than the post
your memory model where the colonel
doesn't actually is not responsible for
the cleanup so the applications resolves
have to negotiate minutes so the way it
works I mean ultimately is exposed to
sludge the flash ashman and then you can
memory map it but it generally there's
enough obviously functions or function
calls to created to make this easy so
this is an example of an application
creating a memory region that is named
it is its created in the shared memory
pool the implication gets effectively a
file descriptor to this which can then
share with another application through
the finder IPC and then then other
application affecting opens up the same
reason and now they can actually go and
communicate or whatever they write in
your right hand span regions are being
shared what's interesting is that
whenever when all the applications all
the processes to share a memory to close
their file references the the region is
automatically garbage collected if you
will okay so the the end the system or
the current all ensures that that would
be the case so um there's obviously need
for this in certain cases where
applications share resources rather than
each application loading its own coffee
they can basically share it through the
drm system this is then then you can
obviously see where we're in college
this was implemented the P man was
something it's also in a sense used for
sharing but it's sharing between a if I
click a device driver and specifically
or more more commonly GPU and bsp we're
basically what what we do is we have an
application map the wrecked memory that
is managed by the device driver and and
it's usually it was it originally was
created for this particular trip said
but this memory unlike the aspect is not
reference counted which our application
opens this memory of is responsible for
actually closing in a print of course
there's a whole bunch of is a POS with
this exposes as well so this is honestly
the way clocks is the the biggest I
guess work not a big exchange but the
one change that
a lot of people feel strongly about with
respect to you know whether this is you
know the correct way to go about it this
the school business of weight loss so
what Google did or what angry does it
extends the power management system in
Android with this idea of weight loss so
the premise is that you know the vice
should not be the CPU should be shut
down unless something holds a weight
loss and when something actually is
basically requests to run okay and by
the way way clocks are not like they're
not used for synchronization you know
when we hear the word law he may imply
synchronization they really just used to
keep the device away person or
specifically CP although they can also
do is to keep for example the screen
whitelaw or backlight away away there's
two kinds of way clogs the lock suspend
which is going to probate you if you if
you kind of hold that log you prevent
that full system i suspend and there's
something called walk wakelock Idol
which effectively just prevents device
from entering these globe are states
where you may experience largely through
our agencies the way this works of
course this is exposed through higher
level API is both at a Java layer as
well as the name layer but ultimately
what you can do is you're an application
would simply write to assist our way
clock a strain which is a name and the
number of milliseconds or actually nano
seconds afterwards a little a quake lot
would automatically expire and that's
how I would grab a weight loss and of
course you know there's a way of
releasing that same o clock there's all
sorts of different kinds of weight loss
or different sub kinds if you will of
the lots of spend weight loss for
example you can require a wakelock and
have it cause a wake up you can grab a
full wake lock which means keeps both
seq and the device awake so there's the
LCD in the keyboard backlight or you can
have a partial way Claude for example
that only keeps the the CP away but the
device appears to be sleeping of course
this is then integrated with the with
the keyboard keyword or key management
system to duel so Android goes in map
specific key codes to the triggering of
the quake lock so certain key presses on
a device will effectively trigger a
temporary key log giving you
keep it happy the you know the device
stay awake of course drivers can also
request to be notified when the device
is about to enter the thruway clock
states and of course device itself I can
interact with weight loss which is
something that Korean men she wanted
peace talks there's this actually this
problem doesn't exist anymore because
we'll just recently deprecated a lot of
these pages but this actually did a
pretty good job of explaining it called
the power management system name where
it works in Android the baseband
processor our of you know other
obviously known CPU way devices can
honestly raise interrupt and that can
obviously wake up a device so but
normally the way of the way our devices
work is you know oh and a process
whether it's a form of complication or
what your application if it wants to run
it will grab and hold a wake lock if it
doesn't there's usually a timeout that
is automatically managed by the system
which is which will expire and since all
the way clocks for one thing you know
released by that time or a lot of its
fire device goes to sleep alarm is
actually one other one example of how
you know we if we wanted to write some
some kind of a service in android it
will periodically run and do something
what it is it's basically offer support
for or it's exposed through to hip
occasions by something called alar
manager and effectively it's a way for
userspace or your application to request
that the colonel wake up at a particular
time and wake us up by a call back
usually what happens is that in that
Paul back we have a very short period of
time in which we you need to grab a
wakelock so we can then do something
more meaningful like I don't know check
some state of something before we then
release the weight loss and then you
know let it twice go back to sleep one
of the interesting theatrics of the
alarm manager or the alarm service is
that it also has a way of or offers an
API to help a batch multiple requests
for wake up's into a single request to
something called in exact timing so that
you know it helps prevent you know
different applications waking up and you
know just
arbitrary frequencies and then you know
which contributes to do too draining the
battery because every time you wake up
and you spin up the radio resource on
which is usually what you do or some
application to that obviously drink the
better so if they all wake up in the
same intervals that helps the low memory
killer is another interesting aspect of
Android which some people feel it's
somewhat weird it's basically a an
extension of the OM you know a
management or other memory management
you over handling in the legs girl does
by default and so what happens is that
Android basically will eagerly or will
automatically should say kill certain
processes regardless of the stair in
whoa it depending on some plans but
based on how much free memories
available assistant right so Andrew
doesn't use swap storage right so before
various reasons most likely you know
because flash is such a slow right
medium and so basically once we look
like we're about to run out of memory we
simply start killing processes until we
you know we regain some of the memories
that's kind of a way of garbage
collecting and in fact they've any of
you have written applications in Android
you notice that there is no exit
function by your application or never
really explicitly exit yes some
locations could call finish on some of
its components but they're really exit
right so Android some in fact something
in Android called the activity manager
which is responsible for launching the
different components like whether
pivotal services or whatnot in Android
is aware of the states of different
applications and based on their states
it sets something called 00 m adjust ok
which is basically a simple it's you
know in set under / proc / you know your
PID / that that setting and it's a
number it goes from negative 16 to
positive 15 and so what happens is that
in the androids in it RC file we have
the default receta de pagar see file
those assets different properties ie
it's basically classified so different
vacations by different priorities if you
will although these priorities are
actually you know the fire the number
that lower the priority right and so
basically what it end also defines is
that what are the memory thresholds
they're expressed in 4k pages that are
there are the trigger killing of
processes at a certain priority level
right so for example once we get to
about you know it 8k of pages you know
free then in order to prevent running
out of memory we start killing all the
processes with the you know Oh Emma just
a 15 and we killing in the reverse order
so basically from the least recently
used to you know and TV keep on going
until we you know again go above the
threshold and once we have enough memory
we stop killing processes but
potentially depending on the memory
demands we may actually end up killing
quite a few processes in the system
whether their services you know for
grappling asians banking applications
and so on and so on of course Android
defines a fairly well you know has a
fairly well defined you know priority
list so basically empty processes are
there once we get filled first then
applications for example that a better
person Magnar applications like for
example have an application that it has
just an activity that is not actually
currently the foreground then services
so services that are there whether
they're bomb but usually the services
are started bouncer is a serious and
someone differently then a second second
or going up visible processes the
processes that are killed or they're
shown behind the current like for
example if you have an activity on top
of activity and you can still see the
application behind units posted are
visible process and then the foreground
processes are are the highest priority
with respect to you know those go to the
last ones to be killed what's
interesting is the system server which
you've heard from Mark van kuren mention
runs it up oh I'm adjust the minus 16 so
for example if you're building something
that you never want to get you know
killed you could stick it in the system
server if you're modifying the wrong and
that will prevent it basically from ever
being considered for by the low
ventricular for killing one cell is
interesting is that Android also
supports something called in
the applications flag so intimate and
romantic we could add something called
Android persistent equals true and the
effect of this is then that our
application actually ends up being
watched with all mi Joos 4-12 so it
actually gets more effectively
effectively never gets killed right
because if we end up killing the
foreground application which ones at
aurora's priority of one we have other
things to worry about so that is the the
whole memory killer will also mention
the clinic manager which is directly a
set these om adjust properties and which
are then read buddy by the one auricular
to the side want to kill logger is just
you know simple logging utility which
basically uses four different law
buffers the main one was 64 K the system
was if they were created something
called events in radio some of the
buffers are in textual the events for
example is a binary buffer but there's a
way of expecting that and they we have
different ways of log into it ok what's
interesting is these log buffers
automatically recycled right so they're
circular bubbles in the world we can
basically read it right from these
things you know if you read every time
you read from it you get 11 login so
every time you write you expect the
position of one log in between there and
we could of course you know clearer than
and so on and so on through IOC kills
nothing too exciting but what's it what
is interesting is that it this is the
logging framework used for all logging
from the colonel all the way to the
applications another another change is
this paranoid network security which is
kind of interesting not because of that
very network security but this shows how
the security model maps in android or to
them to the colonel so for example what
android does it defines in this
particular case of the parent network
security it basically says that the
order colonel is configured such that
certain a criminal or i should say
networking functionality what for
example bringing up the or or or using
the the Bluetooth device or using the
device right using it either the network
stack required the process being certain
groups right and so for example they
define what this groups are for example
the island group is for you know your
general generic network communication
right and there's a Bluetooth groups as
well then in android what they do is
they basically define logical names for
these groups so for example the inet or
AI di net you know gets a logical and
alignment and so now when we write an
application which war wishes for example
connect to the outside world over tcp/ip
right you know that unique you're
supposed to some of you that written and
replications would know that you're
supposed to include something called
users permission android.permission.read
well the way that is mapped is by a dish
file called you know platform
permissions and so basically what they
do is they say oh if you use if your
application in the manifest includes
permission android.permission.read what
we'll do is upon installation of your
application well because at that time we
figure out what if what ID user ID
should be aside replication will take
that user ID and will basically added to
the silent group so effectively the
enforcement of all this particular
permission is still being done by the
colonel so these permissions these
logical Android permissions are really
just being mapped to use to the Linux
groups and then the colonel to disparity
networks here network security basically
enforces it is just an example other
things that have done the same way like
for example logging in order to be able
to write a lot fall you don't need to be
able to kind of group but order to be
able to read from a lot well you need to
be in the law group so again there's a
permission that you know you are you use
in order to get logging and then they
basically put your your user ID in the
logging or the law group there's a whole
bunch of other colonel changes you know
manipulating time gpio for example for
her vibrator so like you can actually
enable vibrator and
automatic you have it turned off you
know linux scheduler these are for
example and didn't RC and you know I'm
sure a lot of you guys hear no more
about this later schedule than I do but
these are for example is how they
configure go to the scheduler I know
there were some questions on you know
real time usage in android I have not I
haven't seen anyone actually enabled or
add the real time extensions for solve
southfield and support support linux for
pouring in an android stack but it'd be
interesting to see how that would work
they also have support for ram console
us be together driver and so on and so
on that's the colonel layer right so
those are the extensions that you
basically which is why we got have a
separate you know get three for the
androids colonel right at some point we
hope that you know Lennox guys and or
Google guys are going to kind of make
friends with lilies guys and all of this
is going to a mainstream Colonel when it
didn't happen it will see the next the
next part of it is the the user space
native way right so this actually itself
is you know it includes a whole bunch of
things either listen here including the
the runtime which is the dalvik virtual
machine but itself we kind of divided up
this this layer into multiple logical
sub layers or categories okay the first
one is the Bionic library I'm sure
you've heard of it and this is actually
the reason why you know and we say
Android is not linux you know render
doesn't ship with glitz or the julep
support uses Bionic so what's beyond it
it's a fantasy library right there was
the ride from bsd so this is not
something you're invented by google is
the right from work for I think it was
not be easy and then optimized for
android so who thought what some of the
changes with me so the Y Bionic well
first of all its business frankly
license right so GPA our glyphs is you
know lesson rounder algae yell there's
all these licensing issues you know
because obviously Android wants to
enable OEMs to develop a proprietary
solutions so they don't want to
necessarily be on the hook when it comes
to making their source code available
for free and so providing something
licensed under MIT or sorry bsd license
make that awesome right because it's a
non-restricted so very one of the least
restrictive voices it's very lean so
it's only like 200 k about half of the
silos the size of G lips and it's very
very fast so they basically optimize it
for the kinds of execution scenarios the
day for so on android-based device okay
which after markers thought you know
they never need to rethink because
people are stretching youth in all these
different directions so some of the
changes that they've added so for
example support or function calls for
you know getting android system profits
right so sis prob answers properties or
something that you know are managed
actually or attract the kernel level
actually but they're exposed or the Java
layer as well obviously a tomato player
through by our support for the you know
Colonel for logging right support for
groupid user management so Android does
not use a slash ptc / password file
right there doesn't exist it actually
has its own way of managing users and
then this bed Bionic is aware of this so
specific specific specifically this is
used when a new application is installed
is automatically assigned a user ID and
then that becomes fixed with the
lifetime of that application support for
you know getting system advancing as
opposed to providing support for splash
services or social / protocols they
obviously provide a you know a bunch of
colonel Heather or function calls if you
will for ioctl structure declarations
and so on and so on two Bionic as well
that is exposed they have a custom
pthread implementation so it's you know
they claim is optimized for embedded use
so they try to make or provide very
short code paths for things that they
expected we use very
and then they don't provide any support
for certain things that they expect
never to make sense on Android super
example you know recursive air attacks
music scissors are supported but the no
support for process shared mutations
part of it is because we have you know
this binder framework which is which
which is what we use for IPC in the
first place you know for example fewer
specific storage Lots then you know
standard POSIX requires no support for
read/write memory barriers so there's
some issues with this effectively issue
certain or limits SMP or multi core
support almost organ systems other
things obviously no support for a sis
sis v you know I pc so this is basically
because well most people really really
that what it comes down to it this is
kind of why you know later the binder if
you will is what happens is that you can
go and our sis we expect that that you
know connections between processes be
managed by those processes and so if one
of the processes were to be arbitrarily
killed by the whole memory killer how is
that going to be actually handled in
sicily it doesn't have any provisions
for that there's no support for locales
at least not at this layer that's
usually done at the adult big players or
the java later if you will there's you
know they have some custom dns support
provided ever built their own built-in
linker that supports clean mapped files
so then for example if you were to build
shared libraries one of the things you
would do is you with the registry or
shared libraries in this pre map file
and you would say oh just my library's
going to load it at this particular
memory address there's their support for
x86 arm obviously an arm thumb even had
support obviously for new instructions
it is not binary compatible anything
apply all the power obviously against
oh gee lips is not going to work on or
against Bionic so you will not be able
to link against Bionic it is not POSIX
compliant they have no support for
example for C++ exceptions and all your
could if you wanted to use it or Android
binary code would obviously have to be
recompiled so this document in the NDK
interesting not not in the Bionic and
the dots weather or provides a fairly
good overview of some of these changes
or it goes into more detail on these
changes this is available in Android
source together get a big ticket item at
the user space level is this user space
hall right hardware abstraction layer so
this comes as a surprise surprise to
some people as it why the heck do we
need yet another you know how isn't that
what the curl provides and yes you know
the drivers provided hardware
abstraction but the problem is higher
abstraction I provided my drivers is not
necessarily a uniform and be there's
this licensing your show you my colonel
being written you know or being a
license GPL or our drivers supposed to
be GPL or not right so what do they do
is they basically defined common
hardware interfaces or something called
with hardware lip harbor legacy that
implement or or bra or define what
different hardware is supposed to do it
by hardware we mean things like radio
graphics audio Bluetooth GPS Wi-Fi and
so on and so on so of course you know
some of these things already have common
definitions as a Linux player but you
know the way to implement GPS may differ
from manufacturer to manufacturer there
isn't a calmer way you provide VPS right
so they basically provide an abstraction
of VPS and I guess again the reason for
it is one is to provide a common
abstraction to the upper layers and to
to provide a separation of the
proprietary code from GPL you know
thankfully detail requirements of the
colonel so a lot of you know ms they
want to keep their stuff proprietary
they their driver which is basically
memory map you know the whatever member
is exposed by the device to a file which
will then be ours or expose it profile
which would then be
map by the user space driver which will
then you know do its interpretation or
that's where you would implement your
proprietary algorithms to interpret that
data and that's the stub you can keep
hidden because you're compiling is
Bionic so that that addresses the issue
of lysis the way this is exposed is like
as mentioned something called lip our
garlic partner harbor legacy for example
lift hardware has a function called you
know expose a function called you know
get module by some ID and what it does
or by these more like a string and
basically what it does it has a
predetermined a store set of pads it
goes with searches in order to load a
particular user space Drive okay so if
you're for example for something called
if I just like a look at example let's
say you're looking for a module called
GPS well if you are a nun exercise
device you would find there under /
vendor / LED flash harbor / you know GPS
got the name of the board you're on
which you're running god SL and that's
how you would actually look so the
device manufacturers they basically
completely nor implement the API is
defined by the lib hardware and they
basically provide the binaries which
again or don't you know can be licensed
under any terms and it provide those
binaries in a place in a predetermined
place rendering those hard to find it by
some logical name again the lead part of
our legacy provides additional or
provider or defines API is for things
like vibrator Wi-Fi module loader power
sometimes on the farm and when you
advanced audio of camera and songs some
devices like for example live audio are
loaded by a very exact name so system
will search specifically for live audio
which removes most implementations they
would see so far generally just wraps
you know also with respect to radio this
is somewhat special because Rayna needs
to be stateful what happens is that
Android load something called the radio
Damon diode apologies
ril V and basically what it does this
goes in searches for a radio library the
lib you know a rib lil which is defined
by ace you know well some kind of
assistant property called our ild lippa
ok so the Arabia or the radio interface
layer Damon loads looks of this property
from this property determine some kind
of a name and then uses the name to load
the library and then the radio interface
Damon continues to run in order to keep
keep that library if you will stateful
so it can you know handle unsolicited
callbacks like if your phone rings or
your network connection comes in um
which for example on you know again on
exercise would be a little under vendor
lid you know live whatever sec all right
I'll be thought it so the other group
the other layer if you will within the
native layer are the the native Damon's
right so we have something called the
service manager which took me some time
to figure out quite figure out how and
what it did but basically service
manager think of it as the dns server on
android but the answer for your bind
bound object so specifically the binder
that we talked about previously provides
the IPC mechanism but what it doesn't
directly provide is a mechanism of
finding out where all this other service
how do i go how do i connect to a remote
service or that you implemented in a
remote process and so the service
manager excuse me registers if you will
on the only within the binder if you
will as this binder context manager and
then starts listening or requests for
from other from other applications or
other processes and basically what it is
it's a mapping service you just knows
how to go from a particular name a
string to an actual implementation of
Awesome remote object other demons for
example the volume of baldy or the
volume demon that supports mounting and
mounting removable file systems it also
for example managers or
or what's a nexus s which doesn't have a
removable as the card it actually
manages a virtual SD card but another
device is like Nexus while I will
automatically handle the remounting the
mountain request already mentioned the
radio David which basically I provides
that state fulness to the radio library
and the way are you know upper layers
communicated with it is actually through
a socket connection interesting about
their local your silicon connection next
deed the managers for example network
connections PPP routing and if that's
where we the Android enable stuttering
which then you're you know AT&amp;amp;T goes and
disables media server which is you know
the comb for audio flinger media player
survivors races on and so on well I
should talk about these pointers in a
bit the install d which is the daemon
that actually manages the installation
of the actual apks in your device so the
package manager is what is triggered to
start installation but the actual
installation of the APK s is managed or
finalized by the install v.p storms kind
of a secure storage of key value pairs
debugger d basically enables process to
dump their poor specific piece of
crashes to specific location so you can
analyze it can come in handy obviously
the WPA so for Wi-Fi application a DHCP
be honest this is you know this is
standard Linux stuff very little
customization here well extra did yeah
actually very little customization d bus
so there's and of course there's a whole
bunch of diamonds on top of it there
enabled on the fly or based on your
to-buy or the Bluetooth staggie of
turned on the device so they basically
they're different name is that manage
different profiles runtime profiles and
they're like I said loaded on demand
raccoon for for VPN that's what managers
among other things we can connections
you have envied basically sets up
correct ownership of your devices as
they're being
enabled so including some of the
built-in once so basically this is
there's a new event RC Potter defines
effective the mapping between the
different devices the ownership in the
permissions again the NDA dbd which is
the Android debug device bridge payment
which basically we use to cook you know
for a number of things including showing
through a device for example and it's
expected to work over USB about seeing
implementations that enable Corrections
over TCP for example bridge on top of it
there may be a whole slew of device or
vendor specific game is like super
example or nexus s they manage their
their stateful gpsd that basically it
runs when you enable gps on your device
that interacts then drew live gps that
we previously saw and basically enable
the gps services to the upper layer
services and then finally we have this
daemon mean I consider them famous
although they're not really they mostly
in the window in the same census these
are the zyburg in the system server so i
will mention the moment was I good in
system servers are but just leave it at
this for now so a couple of other things
at the native layer so the surface
flinger basically enables or what it
does it's an androids system wide screen
composer if you will right which draws
to the you know your standard Linux
frame buffers that part is fairly
standard that there's no device driver
Linux layer device driver for for the
for the frame buffer the way it works is
their apps effectively get these windows
from the service from the surface later
s surfaces they drawn to the surfaces
the surface swinger basically assemble
these surfaces through effective
buffering in the background and then
draws them and it uses basically two
buffers 14 front buffer where you
actually use the useful
positioning the back buffer use for
drawing there's always a buffer
available so you'll never flickering and
it does automatic page flipping so that
there's always one service available for
drawing on one of a couple of things
that the surface flinger also does that
it org or we or expect is that the beer
driver offering a linear space or
compatible memory of course it's
actually not every it's called the card
requirement if it's not provided then it
can use physical memory so device memory
or video drawing and then draw from
there but that's obviously something and
so what it does is actually memory map
this memory so that he can vary it can
directly like into the video of medford
memory from which the video driver will
then honest the draw audio flinger is a
system-wide audio stream routing engine
/ composer as well as used for recording
or the audio recording it usually or
sits on top of the lip audio which in
turn like I said previously usually sits
on top of the also layer and so what we
do is we when we want to play something
we normally grab something called a
media player which has a native
counterpart we scream to media player
uncompressed PCM streams and the
immediately that this effectively scream
it goes to the article which then
decides how to route it whether it'll
say the speaker to blue through earpiece
or whether it'll actually stopped
writing it in case of some odd something
else more important that comes up with
your example the audio player is the one
that will help manage be like let's say
a phone call comes in and you have
something else playing in the background
like you know music it will actually
send notification to to stop the music
playing or deposit of course the crd the
reverse side which is to capture audio
so the audio flinger doesn't actually do
any kind of encoding decoding with
respect to like it doesn't play mp3's if
you will that's what the the media
services are used for later and they
will talk about in a moment so that's
the media framework actually provides
the actual decoding so function
libraries so we're almost done with a
native stack the functional libraries
basically provide computation fence
to the road would be kind of upper lands
right and this is in addition to the
Bionic and yeah Bionic is a functional
library after all if you will so some of
the pieces in this face or simply
borrowed from other open source project
so the lie the lid webcore which is
effectively you know WebKit v8 sequel I
to openssl free type these are
effectively just copies of what exists
in the upstream project though what's
interesting is that these are copied
into the Linux or three but they're
never really changed the learning
sorcery they're not maintained in one
source with the only also in the Android
sorcery the reason why that is there
there there so they can be recompiled
for butter with Bionic right also
there's the media framework or set of
media framework libraries this was
originally free Froyo based on the
packet videos open core platform we
heard this morning at the keynote this
is now based on the stage fright
effectively this is where this is the
set of libraries that promote the
Mabel's transcoding of you hear an audio
right so including images so when peg
for h.264 as of gingerbread vp8 / web em
mp3 is a CS and so on and so on and this
is pluggable to the Chronos openmax IL
basically API so that the hardware
manufacturers can go and provide the rec
needed a hardware accelerated support
for doing this sort of transporting the
3d libraries we know are also Pettis
where they're provided it also biosens
Chronos as well they're based on opengl
and the we have the 2d libraries which
and this is something that's evolving in
honeycomb because now to do libraries
actually or more of who these being
argue accelerated um finally the last
part of the of the native layer if you
will is the is the piece that enables
the upper layer which is the dalvik
virtual machine this is then forced
English lips get here in San Francisco
and Dalek got its name from
found a nice one where advanced from or
his answers reform so what it is it's
basically a clean room implementation of
a virtual machine that is semantically
compatible to the JVM but is not a JDM
implementation okay so you can't really
call that a job it is licensed under
Apache 2.0 open source license and the
reason why it's here is to provide a
high level so rich API framework for
effective writing applications that are
portable across different devices
because dalek you know like java
compiles into byte code that is machine
dependent so unlike jolla doba dalvik
basically or the bike football dalvik is
stored in these so-called X Files ok and
the way we get the x-files is we use the
end developers we develop in Java
generally and our Java code but gets
compiled into god class files but before
those cause files can be shipped to the
root of the devices or installing
devices they are turned into the decks
code and then by the time the device
actually starts executing this there's
no more job ok so even code they better
write like third-party libraries day two
we'll get the pile into Mexico so why
you know one of the big questions then
you know some people feel strongly about
this why did you know why the dulling
bastard on Java why did it just isn't
that kind of with Microsoft tried to do
you know a decade ago and try to kind of
pay their own Java well Google is very
upfront about it they're not claiming
garlic his jaw lights or like you know
Microsoft did with the acclaimed Java on
Windows was java when in fact it was you
know window job um but why didn't they
just go with standard job so the
standard SE chala is you know consider
too bloated for mobile environment has
api that 0 yeah usefulness in a mobile
environment but to support him with that
bloat right you have to remember that
when Google was first releasing android
you know they assume 64 megs of ram okay
and loading all these or supporting all
these extra libraries man
we had fewer fewer you know megabytes of
memory left for for a run time or for
running applications the other thing is
through too much redundancy Java has a
whole bunch of libraries that are not
your dirty provided by Android with more
more optimized way and it's not very old
well optimized for mobile so why not
jolly well the cost first of all you
know that's where his son was making
money order all of enemy right so did
you have to pay a license for that it
was largely designed by a committee
right and it was now really going to
compete with the you know the way we
about the way iOS or the main way modern
ugly in mobile the bottom environments
for progressive because one of the
problems with the javanese grow two
problems one is that applications had no
access to hard work right so there was
no way for you to access any kind of
pull hard word existed on the device
except for some you know very Lumia some
predetermined profiles which weren't
very or did not give you as much access
this native application so yeah so Java
applications were always kind of
second-class citizens and the reason why
this was the case by the new bridge they
just ujjain used and I well all the
applications you know on a job and the
environment was running a single da
right so obviously that would if we were
to leave the security manager context
provided by GV m and dropped native code
all the security basic formulas so dal
lake on the other hand is optimized for
american-born so it has extremely low
memory footprint yet it provides a
fairly good security sandboxing morning
not directly but order to the use of
Linux so one of the interesting things
is the daleks uncompressed x files are
actually smaller than slightly smaller
then compress Java pots okay and the
reason why they were able to order the
car they were able to accomplish is
because they basically optimize the
throne II you know the pointers if you
will if been the code that there is how
they encoded the advantage of this is
that dex code can be directly memory map
and directly share there's no
decompression that has a big place right
so you can be automatically share
two different processes any offers am
always simplify class loading right
because you don't have to keep on keep
these things I wrote it and then I'm
compressing it on the fly but the other
part of that story is this is something
that kind of surprises people is that
every application every Android
application that uses dalvik basically
runs in a separate instance adult okay
so you would think wow that's a huge
overhead hockaday accomplishments right
on out on a devices and have a lot of
resources so what happens is that on
startup Android basically launches from
in itarsi something called zygote which
you can think of as a hot baked baked in
a pizza as mark likes to put it I and
I'm sure crimp dr. buddy destiny but
basically what it is it's a dalek
virtual machine that goes in preloads
some something like 1,800 classes and
then a whole bunch of other resources
and then sits there does actually do
anything since their weight set up on a
socket lyric socket for connection for
requests to fork itself and when it
pours itself it then goes and runs at a
lower user ID the actual application
that needs services of that particular
belviq instance so because it does it
force itself it is able to take
advantage of the copyright semantics
little alex offers so most of our
applications if we were to do you know
look at their their actual resident
you're a red size in the PS they would
appear to be much larger than they
actually are because a lot of their
memory is actually shared with the
xiphoid process there's actually a tool
called a proc crank on android that you
can use to get a much better idea of how
much actual space how much actual ran
all your applications from consuming ok
and again that is because of the the
fact is I that enables this the other
thing that's interesting is that Dalek
is a registered or based so basically
instructions are fixed and uses 16-bit
while instructions so it's able to
reference the register directly
restructure instructions rather than
loading them off of the stack and memory
access on a mobile device is generally
considered very slow at least much more
memory are much lower away relation
cpu so so the fewer times we have to go
to memory the better so in fact dalvik
runs we're very very efficiently in the
environment for which it was designed so
it's not just Google was trying to rip
Java they actually contributed you know
to creating something that's much better
optimize them with the traditional
traditional J you know j2me or jme JDM
were they able to be able to offer and
so the last thing about all these it's
interesting is that as the froyo as you
guys know it comes with the JIT support
which is also different instead of Java
support in that it enables something
called trace level regularity where it
finds individual branches of your code
that appear to be hot and optimizes the
heck out of them in fact that code when
converted from dolly code to native code
is explored by eight times ok that's how
high level dalvik orders and that's how
well you know optimize the native code
you know that's jit it becomes this
would this the reason why they did it
this way as opposed to the standard Java
which basically does method level jit is
that they basically minimize the amount
of overhead in terms of memory as well
as CPU time that needs to be dedicated
to the JIT support so it's an averaging
like hundred to two hundred kilobytes
extra to enable that yet we get
something like two to five times a
performance improvement there supports
for other things you know tracing blah
blah blah I don't want to bore you with
this and most of the library's the
developing supports are based involve a
seat five including support for generics
and so on and so on but there's no
support for a bunch of these other
packages that are listed here like you
know swing awt for obvious reasons and
here's my license plate so
to read we have only a couple of minutes
so you know these actually these two
layers we're going to go through rather
quickly so the application framework
sits on top of this and for the most
part it really just wraps a lot of the
services or a lot of the native you or
the user space how drivers if you will
that the other applications use so for
example we have support for other
abstraction you know and a Java layer
like the location to less when you Wi-Fi
bindings for native libraries like
OpenGL sequel light and so on and so on
so the rest of these slides are really
kind of on the particular managers and
there's a whole bunch of them right so
if I'm sure you've seen print slides
there's you know I don't know 15
managers or so I call him manager
service because sometimes they get
referred managers the managers name is
Virgil service the two that are the most
important to a lot of post dealing with
Android is this or the lower level are
the activity manager which basically
does all of the you know handles
effectively ceased you know starting
appliqued starting starting a sending a
broadcast starting a service stopping a
service starting an activity and this
interacts directly with that all imma
just the package manager is responsible
for both resolving intense so
capabilities of applications as well as
installing applications power manager
that kind of you know as always that's
how you get access to wake locks
alarmmanager grabs the alarm that we
talked about notification manager for
Androids fairly rich with vacation
system heat guard manager these are just
kind of samples right location managers
it plugs into gps and enable additional
services like you know interpretation of
gps data proximity we know alerts and
things like that sensor manager the
wraps you know android sensors which are
again provided by lib alec hardware
search manager vibrator manager
connectivity manager that basically
enables you to to you know again become
get notifications basically from various
connectivity stacks specifically Wi-Fi
manager you know
if you won't stand for open Wi-Fi
networks and things like that telephony
manager which interacts with the aveda
interface layer input man method manager
which basically enables the custom you
know soft keyboards if you will that
android supports the UI mode manager the
neighbors like you know is your android
car mode or night mode and things like
that download manager which is new as a
gingerbread which enables like
background download which you know with
resume capabilities and automatically
manage awake plots and Wi-Fi lots and
things of that nature storage manager
something it's kind of interesting if
you ever need to store securely data on
the SD card because that's kind of that
where we have additional you know may
not storage capacity how do we do this
internet it's difficult for a manager in
this video opaque binary blobs Oh as a
mechanism to do that audio manager which
you know drags with the audio basically
subsystem window manager managing with
for windows layoutinflater resource
manager for managing in a loading
resources and so and so and you can see
this list goes on and on and on yet some
of these managers implement quite a bit
of logic like activity manager a lot of
these other managers really just provide
nothing more than a rapper to Jay and I
of the native library support so they're
fairly you know thin Java layers and
finally this is just a final note that
want to mention is really the
application layer the application layer
is you know you know it basically comes
with a bunch of built-in applications
and of course you can feel a little
bunch of your own but what's interesting
about the implication layer the reason
why I like to include in this talks
about you know what applications have
which is not as exciting is that these
applications be are really part of the
Android API right so rather than you in
building all the logic in your
application through the Android intense
system which is fairly unique to Anjali
you can actually use components of other
applications and so Android promotes a
yield user tasks and not like everybody
that are made using processes like
multitasking but user tasks users want
to think in terms of what they want to
accomplish not in terms of which with
certification they are using so it's
very you know Colin for user task span
publications as they kind of click
around and have any their system and so
when you're building for Android you
should consider not only providing your
services or exposing your services at an
a in a layer or even as a custom service
there but consider exposing it at a
higher level as effectively complication
components then that other you know
other folks can actually take advantage
of and feeding you can obviously read
through this on your own but there's a
whole bunch of built-in applications as
well as built-in you know content
providers as well as built-in input
method as well as built-in you know
wallpapers and so on and so on ok so
that's that covers my talk hopefully you
learned something I'm sure we're about
to run of time so I'll be outside if you
guys have any questions thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>