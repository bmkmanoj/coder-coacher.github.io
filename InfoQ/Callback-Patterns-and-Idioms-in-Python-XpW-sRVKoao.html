<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Callback Patterns and Idioms in Python | Coder Coacher - Coaching Coders</title><meta content="Callback Patterns and Idioms in Python - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Callback Patterns and Idioms in Python</b></h2><h5 class="post__date">2012-12-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XpW-sRVKoao" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the Stokes is about callbacks callback
patterns and mediums I am not really
going to be able to cover the
alternative to callbacks to do similar
tasks which are very important but I
will briefly mention them and maybe I'll
need at some point to have a follow-up
talk because they're starting to emerge
the URL here don't have to join it down
now it will also mean the last slide is
the PDF with exactly these slides I've
picked this talk because it aims at a
pretty broad range of competence levels
in Python and programming in general you
know every discipline goes through three
stages which in Japanese theater and
later from that in martial arts are
often named Shu Hari first you need to
retain the basics and then you gradually
detach from the basis into actual
practice and finally when you're a real
master of anything you transcend all the
details you've been taught towards the
perfection of the experience
so this talk needs you to be at least
midway through Shu if you're over midway
through re and find yourself bored
please stick around because I really
want to drink at the fount of your
wisdom
but quite a few people have been
privileged to interact with that's
another advantage of working at Google
you're very unlikely to be the best at
anything there's always somebody better
than you that you can learn from I
realize this requires to be actually a
hundred percent true would require us to
have an infinite number of employees
because otherwise there's going to be
one who is best at something but we're
trying that's what we're hiring all the
time we're striving towards that
infinite number of employees that will
allow us to make that actually hundred
percent true okay what's a callback they
concept which by now is like old and
totally digested but used to be somewhat
perturbing is when some library or
framework is going to call your
functions the traditional concept of a
library born in the 50s and the 60s was
hey here's a bunch of functions go ahead
and call them to do cool stuff for you
in the callback things are reversed you
don't call them they call you why would
that be helpful the principle has been
named by Richard sweet it is a sweet pun
the Hollywood principle you know you go
to Hollywood I don't know if you bother
going to Southern California but to like
try out for some big part like out there
on the stage doing it thank you
don't call us we'll call you that's
actually not a particularly promising
introduction in that in that concept but
this shows essentially that the date of
this 1985 for some of you is like wow
I'm older than the concept of callbacks
for some reasons like cool I was already
working then I was recently mentioned
although our very young grandfather
I'm a grandfather now so so what is the
purpose of being called back by
libraries or framework I classify that
into two possible motivations which will
both explore one is get better
flexibility by customizing some aspects
of how the framework is working for you
instead of having to tell the framework
this is how you work at the very start
with some initialization call the
framework calls back to you whenever it
needs to know what do I do here your
callback function will tell it and this
is one important class for which I would
say there are very few alternatives this
is simply the fact that instead of
giving the parameters of exactly how the
operation must go once and for all at
the start you give them like every time
so it can change the penning on
situation and so on that's a nonpareil
flexibility and then there's all the
event-driven architecture event-driven
architecture was actually born in the
world where events outside of the system
actually occur and are important to
react to probably started with graphical
user interfaces so around the early 80s
when gooeys were coming of age or late
70s in the research world and then
somebody noticed that hey networks work
exactly that way stuff is happening
outside it's not a human being it's some
other node in the network but things are
happening and need to be responded to
and they concept for people whose minds
are sufficiently warped which I hope
covers most of us it proved to be such a
useful concept that artificial events
just to be able to structure your
program in an event-driven way were also
introduced I call these pseudo events
and those are of course items for which
there are
any alternatives I'm just trying to show
why would somebody want to program like
that in a couple of situations what the
implementation of a callback no matter
what the purpose of the callback is I
spent some time discussing why would you
want to do that how would you want to do
that well you just need to have a
language with Co level objects which
with the possible exception of Java
I believe applies to every modern
language somebody would say not having
first-class callable means Java is not a
modern language it's a relic of the deep
past every every language that you pass
around even see this you pass around a
function for Christ's sake it's not
doesn't it take and and C was written by
a guy who's older than me now so it's
really not the newest languages only you
hand that call a bowl object over to
some part of the framework whoever
you're handing it off to I'd better
stash it somewhere somewhere might be
very transient maybe just on stays a
local variable if they scope in which
the callback needs to happen is limited
to the execution of a single function or
else it will put it in a container said
it has an attribute you don't really
care from the outside what how does the
framework preserve your callable object
just make sure that it does and then if
and when appropriate at some point in
the future this colorable object of
yours gets cold called back because you
originally did some kind of call to
handover the caller Bo and now you get
the call back either because it needs to
know something to customize the
operation that's the first kind of
motivation or appropriate events occur
like state changes user actions a yo
event network canal system stuff that
the system is about to catch on fire
you better do something about it or
events can be made up for structuring
control flaw property as well see now
customization is not necessarily limited
to tailors anymore we also want to do it
in software system and let's take a
really simple example I have a list of
stuff things in this case probably
strings I want to sort them but not just
sort them any which way sort them in a
customized way for example I'd really
like to sort them in a case insensitive
way how do I do that well let's read the
things backward the original approach to
doing this which I kind of rolled up I
discovered I didn't invent it it was
already being used an important code and
called the DSU for decorate sort and
decorate proceeds like that I make an
auxiliary there stuff which includes the
objects of the list their indices and
some kind of key function apply to them
which comes first and then I can use a
natural sort the lexicographical sort of
python things with different keys are
sorted in order key if the keys are
equal then the indices are going to be
different
note that the object themselves never
end up being compared that's actually an
important detail of the semantics of TSU
and then I have two undecorated is
extract the objects back into my list
this is for an in place sort of my list
so this is and was a great idea but it
really kind of cumbersome to have to
keep coding it so Raymond Hettinger who
you had the pleasure to listening to
last year said hey I'm coding this sort
of thing all the time it's getting
boring
I don't I put it in their interiors of
the sort method if after all the only
thing that changes between one
specialized sorting and another is what
function do I call to get the sorting
key out of the objects so let me just
pass the sorting key in this case I'm
using the two upper method of object
class a type STR because they'd better
all be strings it wouldn't work if I had
some Unicode things there and therein
lies a tale well but as long as they're
all byte strings in in Python 2
something this thing and by doing all of
these internals internally where they
should be done I strongly recommend to
any Python ista with decent C background
to study they Python C internal so
they're extremely interesting but
essentially does all of this internally
and so it can also be much faster as
well as abstracting away all the details
of the implementation it does guarantee
for example that the objects themselves
will never be compared directly so you
could apply to with a appropriate key to
say a list of complex numbers you can
never compare to complex numbers for
greater than less than and that would
raise an exception but with D s you use
apps for example so they the objects are
sorted in in order of of absolute value
you're going to be absolutely fine
you also gain an advantage of
abstraction you're working at a higher
level of abstraction when you're using
the callback customization then you are
when you boringly code it out as usual
more often than not in Python the higher
abstraction you think and work out the
faster you get that's exactly the
reverse of what you get with most
languages which are
Thunder Stepanov called the obstruction
penalty how much does it cost me how
much does it slow me down to use
abstraction in Python typically the
obstruction penalty is an obstruction
premium you actually get to rewarded for
being more concise higher-level and more
abstract and this DSU example is a
perfect one now I did kind of mention in
passing a little problem if I was doing
the comparison directly instead of
passing on the key function I would have
a and B and I would say a to upper open
calls less than B to upper open calls I
would be calling the method to offer on
the objects a and B this way I'm not
really calling the method on the objects
I need to call some callable on each
object so I'd better have a callable
that can be applied to each object so
I'm kind of breaking the abstraction
layer of object-oriented programming we
sometimes okay like if I know that all
the objects are of class str then
passing a method extracted from the
class str will be fine and not too badly
break the abstraction of object-oriented
programming but sometimes you really
need to be getting properties or calling
method in the object-oriented way how do
you do that then well you typically
start by import operator standard
library module 2h Revan Hettinger you
may already be familiar with a name
added a couple of useful tweaks operator
has been around forever but it typically
abstracts into callable such things as
addition multiplication you know
operators raymond handed after getter
and i don't think this was him but
somebody in the same vein added method
collar so utter getter
you give it the name of an attribute and
it gives you back a color so it
dynamically constructs and returns a
color that will directly call that
extract that property or attribute from
the objects so if your objects carry an
attribute K which is the key along which
you want them to be sorted this is how
you do it I already mentioned the
possibility of extracting from the class
to which all day all the objects must
belong some method without arguments
that may be a bit restrictive maybe also
want to pass some arguments well then
you can use the method color method note
that this in some environments is known
as higher-order programming so take it
as a compliment when you're calling a
function that returns another function
in some languages that's called
higher-order programming in Python it's
I believe just as easy as two plus two
so method color takes the method name
and arbitrary set of position and
keyword argument and will extract this
method and call it with this argument
from each object to obtain the sorting
key of course I usually get at this
point of rejection but I could have
written a lambda to do that
well you could have but you don't have
to and when you can avoid lambda you're
usually going to be much happier don't
believe me time this use the Python - M
time it approach and see how many
microsecond or nanosecond does it take
to do this versus doing that and you'll
find out that avoiding lambda
programming at a higher level of
abstraction rewards you
with better performance now to see if
anybody was following on what's common
to all these approaches and this one
that I couldn't just have done wait a
second they they see approach is
different I remember doing sorting see I
also pass in a function but a passing a
function that gets called with two
arguments and master returns minus 1 0
or +1 depending if they're to be
considered equal or one is less one is
more what does this key abstract key
extraction concept by me I'm more used
to passing in the comparator function
unfortunately sort given that Python was
obviously heavily inspired by C at many
levels they're very close languages
philosophically also as a CMP optional
argument that lets you pass a callable
that will perform the comparison just
like in C why would you want to use a
key approach versus the C like approach
of passing in the comparison the answer
can be a single uppercase letter
it could and therefore what's a single
uppercase letter that explains why you
want to do it with key Big O I hope we
have a piece of shrug for this guy who
got it exactly the number of comparison
you're doing is going to be Big O n log
n the number of comparison you're doing
grows more than linearly not that much
more log n is well behaved function but
still in this way all you need to do is
to be go of n is actually exactly n you
need to extract the keys once per object
so n times for an object so of course
you get faster especially if as the
other gentleman said the key is costly
to extract this system can in this case
very explicitly cache the key
computation for you but the key equal
argument does it just the same so thank
you for the cooperation and the
first-order success also key equal is
not only for sorting it's such a handy
thing that it was generalized to max
mean almost everywhere you'd really want
to use key transformation instead of
okay if you're really deep into all the
customization of just for sorting but in
a more general case he's done vehicle
back in the somewhat rigid design
pattern known as template method the
template method design pattern has been
described somewhere perhaps with a bit
of an excessive enthusiasm as the spirit
of object orientation I have a long
presentation at this URL I suggest you
get the PDF the the URL the some of the
first and last page and
as opposed to try to write this one down
and then follow this at slide 49 and
following because it's a presentation on
all sort of classic design patterns as
they occur and get applied to Python
it's somewhat rigid and I also suggest
all sort of more flexible alternatives
but the general point is that in some
abstract class parent class you call
self some hook method and then the child
classes implement the hook method this
isn't obvious but it's always also a
case of callback it's not obvious
because you're not like handing over
explicitly the color ball but you're
creating the color ball by overriding
the some hoc method in the concrete
child class and that is how the objects
find the the organizing method finds
they hook method to call let's get
another example of customization which
unfortunately isn't surviving in the
Python standard library but I still
think was a very nice between design
scheduling I want to be able to schedule
a series of events the events I'm
scheduling are of course going to be in
concrete calls to my method so there's
also this like normal semantic
event-driven
level of callbacks but forget that for a
moment the point is I want this to be
called in five minutes or I want that to
be called at exactly 9:00 p.m. and so on
and so forth how if you think about it
how you're going to implement this well
you're going to keep a queue of things
and you will need two core
functionalities some way to tell what
time is it right now and some time to
say sleep until the time of the first
scheduled event to occur so you
just spin around in a tight loop asking
are we there yet are we there yet are we
there yet I'm looking forward I had my
experience with my children like every
parent I'm looking forward having it
again once my now two month old grandson
gets old enough to speak and be driven
around they one way you could consider
would be well they old fashioned but
still present time module offers timed
up time to tell me what time it is and
time to sleep it's time sleep to wait
and for a certain duration of time so I
could have as a scheduler object except
the module as an argument
modular objects like any other thing and
just call it time and sleep functions or
methods doesn't isn't really any deep
difference in terms of the syntax so
that schedule we'll be using if you're
focused more on functional programming
than object-oriented programming you end
up with the architecture that was in the
Python standard library you pass
separately they time time function and
they times three function so that you
they normally will have to go hand in
hand how you tell what time it is and
how do you wait until or for a certain
time had better be synchronized with
each other which is the argument for
having them as method of a single object
on the other hand advantages of passing
them separately you don't need them to
be named time injury for example you can
name them anything but that's clearer in
your context because the scheduler would
receive them as color blob jects it
doesn't care what they're called it just
calls them it holds them internally and
another factor you could also
supply default for them if you want to
allow your user to customize you buy
call back but not require them to do so
you could have the to function default
to time to time in times of sleep unless
explicitly passed with other values
which in general convenience is not a
bad thing
in practice the original designers of
the of the scheduler module decided to
not have any default so the user must
like is explicitly made aware of the
need to specify those it's they're both
valid choices in different contexts they
not going to pronounce on it they
object-oriented about a evolution of
this is the dependency injection design
pattern I've already given you the the
URL to my general design pattern
coverage there's also unfortunately
should have put the URL here but I think
if you look for Alex and mortality
dependency injection you'll find my talk
specifically on an in-depth in deep dive
in under the dependency injection how
how is it used in Python and why it also
in a sense boils down more often than
not to callbacks although you could give
no callable objects but mostly you will
be given call above such as factories so
this is the part where I cover call
backs for customization
I hope it's obvious why they're more
flexible as they claimed in some cases
you couldn't possibly just specify
things once and for all not with
callable but with values like here you
can say okay and the time it is is 5:00
p.m. okay and how do i that was the time
you called me and now it's past sometime
how do i know what time is it now I
obviously did that is progressing
continuously and also they what I might
need not know some parameter but perform
some action like
sleeping I need to do something in order
to sleep that it's wait for the next
appropriate time but also if even if all
they is doing is just returning a value
it can return a different value at
different time like in the sorting
customization case it's obviously not
just going to return 23 that wouldn't
produce a very useful sorting if every
object has a key of 23 you end up not
sorting anything the object that the
value that gets produced must depend on
the object so the flexibility of the
callback for customization is absolutely
crucial any question on this part thing
or we can wait and have all the
questions at the end perhaps but I'm now
going to move to events which are a
rather distinct thingy for the second
part so okay even's does anybody
recognize this kind of diagram okay so
as I keep saying but the repetition is
not because I'm becoming old and
doddering by having a grandson I was old
and doddering before them but it's it's
an important principle a design pattern
in in writing articles or giving talks
tell them what you will tell them then
tell them then tell them what you've
told them that's the way people actually
retain information better so I'm trying
to apply that by this pattern there are
actual events stuff that is indeed
happening somewhere outside or within
the purview of the system user user do
stuff they move Mouse nice they click
buttons they saw and so forth and each
of these is an external occurrence
and in the sense that you want your user
interface to be able to respond for then
there's stuff more inside the system
like the observer observable design
pattern one object is doing stuff
another object wants to respond to some
of the stuff a former object is doing so
the observe observable is a object doing
stuff and the observer is the one who
needs to respond and then there's a
yellow IO that I always often modeled as
in do the command and just wait until
it's done but depending on who's
responding the wait might be very long
and you don't necessarily want to
program it in this synchronous way you
normally do like you you're reading a
file you're saying X equal my file dot
read open close that may I don't know I
may wait a few milliseconds who cares is
your usual attitude but depending on
what your programming and depending what
that file like object is the way it
might be might be very long so you might
want to actually be reading a line at a
time
and not wait for you trying to arrive
but do something until it's dawn to
something else until it's done
networks are particularly prone to that
because delays can often be orders of
magnitude more than for local stuff
stuff local to your system and then
there are system events like the system
is getting turned off for example the
program is about terminate you know
slightly smaller scale but not
conceptually different from somebody
operating the on/off switch on the whole
system you may want to be able to
respond to that for example oh it's
about to terminate let me save some
information so I can restart properly
next time and then when people have had
become used enough to event so the way
of thinking because they were
programming a lot of gooeys and networks
and things they started making up events
be able to use those structures in where
the events are not necessarily real like
even driven parsing will mention that
the scheduled call back then the
concurrent callbacks is slightly
different and all sort of timing and
debugging which we want to really be
able to get into that much but for
example I did mention tonight in passing
pythons - M time it starts the time it
module the time it module needs
something some way to set up the
situation and something to call
repeatedly so it can call it a thousand
times and tell you how long the average
time took those are conceptually
callbacks although what you usually pass
a string so which off of Python code
which it parses and and the same could
apply to PDB but that's not I'm not
really going in depth in that part let's
start at the beginning where actually
they practice of event-driven
programming did if not really start
definitely took root heavily the early
graphical user interface frameworks they
Python used to have to come with decay
inter which is a peculiar GUI framework
but it was like all others with a lot of
callbacks some events are pretty
macroscopic like user clicks a button ok
user clicks a button what happens when
the user clicks the button they typical
approach is something very simple a
command that is a it's some sort of
argument class function gets called so
it's a callback
responding to the a macro event and then
Takai inter goes in-depth or allowing
you to set bindings between what you
could call classes of event
and and callbacks for example enter
leave that say mousers entered a widget
the mousers left a widget some key has
been pressed or or you could be more
specific like a specific key price only
and so on and upon that event the
handler gets called with an event
argument while they command here is just
gold with our arguments this in this
case the collar bolt takes an argument
which describes the event in details
which attributes like which widget which
X&amp;amp;Y position for the mouse and so on
what type of event so that a single
color Bowl by analyzing the event object
can deal with slightly different
situation you can you don't have to bind
to a specific widget but you can bind to
a whole class to all widgets to a
certain root window and so and so on so
it's a very flexible way of binding
stuff that can happen the event or
classes of events on one or a group of
widgets to a callable that will be
required to deal with that this is a
specific decanter system and there's
plenty of other excellent ones but in
practice at a conceptual level they all
work very similarly some will not have
this kind of flexibility you may have to
write a big block of code to bind a
certain handler instead of matching by
class by root window and so on but
that's in a sense a minor implementation
detailed compared with a conceptual
thing that things happen a handler gets
called the handler is responsible for
doing stuff in response to the thing
that happened which it either knows
implicitly
when it's called without argument or
gets as an
so it can analyze exactly what happened
in detail are there alternatives to this
some to some extent you can for example
it's described as not needing a hammer
but in certain certain frameworks such
as QT you can connect directly a source
of signals which I would call an answer
to a sink of signals and that could
operate without you having explicitly to
code what's going on but that's just
using a handler implicit in the system
for example if somebody clicks here
close that window you may not have
written the code the code calling this
window door close but that's only
because the system supplies it for you
so it's not really a deep conceptual
difference okay
now this if you think of the event
happening on day on the widget is
because actually the user is doing
something they completely system
completely external to your your stuff
but you could think it is okay the
widget has done something this status
has changed in that's a slightly
different conceptualization of the same
thing the mouse gets in well da the user
has moved the mouse and the pointer has
gotten within this particular rectangle
yes but I could see it as the state of
the widget has changed from not having
the mouse in to now having the mouse in
and when you conceive of things that
happen is happening to certain
particular objects you're almost arrived
to the observer design pattern again
there's that big URL where I cover all
sort of design pattern here I'm just
seeing it as a specialized form of
callbacks because it is you can add
observers note the plural that's a
typical often a difference where they
Bui paradigm instead of saying well this
event has happened so here is
the handler the deals with it we says
this widget state has changed so here
are all the objects or they observer as
opposed to handler that a usual term
that who are interested or potentially
interested in it it's not really will
show that him more general having a
single callback or multiple callbacks is
actually not that drastically different
because if you did manage somehow to
force every event to correspond to a
single callback ever possibly you would
have managed to build a taxonomy of
events you know what
suppose the mouse object has an event it
moved and the widget object has an event
the mouse entered you know what one in
the other will often both happen at the
same time because the way the mouse
pointer entered is because the mouse
moved so you can't really constrain all
either the move Mouse has moved handler
or just they Mouse's entered handler to
trigger you really want to trigger both
that's a very specific example of the
philosophy of taxonomy taxonomy is never
correct taxonomy is predicated on the
underlying concept or something is
either A or B well I know things that
are seventy-two percent a and 45 percent
B they overlap is deliberate table isn't
a hundred percent taxonomy is a great
temptation for the human mind but is
hardly ever right anyway in particular
it's hardly ever right when applied to
all except the simplest callback
situations sunway an object must be
aware that it's state is changing which
is presumably house for example it will
have mutating methods
it knows when a we're taking method is
call that changes the state other
methods don't end it somehow keeps track
of all the observers it must inform when
the state changes and it simply does it
after him after or maybe before
implementing the day the stage change
every observer is notified why before
why would you do that before well
because maybe you want to let observer
be to the state change in in a certain
situation in which case you do they
calls before implementing the state
change if some object some observer
vetoes the change then you don't then
you actually just quit the mutating
method otherwise you prevent the change
and then call the non vetoing observers
you can have other design choices to
general observer would be one that gets
informed of any state change and is
totally responsible in a way that's
entirely opaque entirely inside the
object to know whether it's interested
in that state change or not and that's
okay so obviously the most general
possible approach but often you may want
to know only off about objects of a
certain kind for example I may want to
do stuff for when keys get pressed now
exactly what key may be too specific but
I don't really want to be called every
time a mouse moves because I just don't
care is just sheer overhead having to
say if the event is not a key price then
go away it's maybe your framer lets you
say only key presses are state changes
of of interest on the on the keyboard
object and you again may recur instead
of having a simple color ball having a
group of a group of color balls meaning
an object with several methods so that
they could call for example the the
observer object might have a method that
gets called on key presses one that get
called on
moves and so on so they you don't have
to explicitly code yourself if it's
keypress than something else if it's
mousemove something else which one makes
sense depends a lot on specifics of the
framework that is organizing all this
I'm just pointing out all of the design
issues if you're ever designing or if
you're looking at an unfamiliar framer
consider that it may be doing things
different than you're used to for
possibly good reasons possibly not but
this is what you have to handle deal
with similarly you can have several kind
of callbacks in that a callback might
have no argument at all or reasonable
idea for example for the observer design
pattern is past the target object who
stay just changed so you can use a
single observer to deal in similar
fashion with different possible observed
objects however this does require since
no indication is given off okay what
state changed how to somehow explore so
having a description of the state
changes will save all day so is the
mouse in the same place that it was
before yes is the key being pressed the
same as was before yes and so on which
can be rather cumbersome the description
of the event main particular has eight
dogs in TK inter include okay oh and by
the way on which widget has the event
occurred
but first what type of event a mouse
move and then the tails like x and
y-coordinates object in which the mouse
move but then this is all about the
event but the collar ball themselves may
also require other arguments that aren't
really connected to the specific event
but to the reason it's being putting in
he's been put in charge of watching over
that event for that purpose the general
solution
would be sank tools dot partial which
binds some are arguments positional star
a and named they start rkw pre binding
them into a projected callable with
partial application this is a general
thing and if okay somebody will say
lambda is a more general thing again if
you avoid lambda you will hardly ever
have to complain about that having to
for example set to scroll back with an
explicit functional partial why can't I
just set the call back with an X with
directly giving what A's and kws do I
want to pre bind why can't you do the
pre binding for me the answer it
perfectly well can and while I love
single-purpose tools the the difference
in elegance between having the a and kW
passed directly to set B K and having to
wrap the functions partial around is so
huge that I really think this is a
better design in some but not all of the
Python callback systems do that I if you
ever find yourself designing a whole
back system please look for they second
for me just instead of just memorizing
the callable you memorize a callable
tuple a in in dictionary kW in the guppy
and after and nobody needs to yes
is lambda higher level of obstructions
all this not in Python
lambda in Python does not allow you to
are statements in sign and therefore is
not a higher level of abstention it's
our abomination and greed or had wanted
to originally to delete it from Python
three because he just couldn't find a
good way to allow states mint in it and
that thing was never acceptable he
unfortunately then let himself be
lobbied into keeping it around and so
everybody who gets my talk will start
will continue to get bored by my
explaining why lambda is just wrong in
Python you want Lisp you know what to
find it this isn't it even though even
though my good friend Peter Nord we keep
saying that well much the same but it's
not other questions okay so now we come
to the general issue that I described
earlier for for observer what if there's
more than a callback set for a single
event maybe because the event falls into
two overlapping categories or maybe more
directly they simplest in roughest way
is to remember and call they last
handler that was set I remember doing
that about 30 years ago dealing with
that about 30 years ago with pc dos 1.0
which allowed only one way to handle an
interrupt so what you did
you saved the previous handler then you
set yours and all the handlers were
responsible for chaining the Cole until
it got well it was pretty rough indeed
but for thirty years ago I guess it was
acceptable simplified the kernel if it
deserves being called the kernel
alternatively why we've got like more
powerful tools now why not to remember
them all well the problem is you have to
still have to make some decision last in
first out first in first out or is there
like a priority order it's far from
obvious also far from abuses by the way
I set five callbacks to be called in
some order now how do I remove one of
them if the order is specified can a
callback that just happens to come in
early say okay I'm all done every other
callback after me
don't even bother it the nothing to see
move along move along these are very
difficult design choices because you
there is no single good answer
and whatever you pick you will wish in
certain other usage cases to have picked
the other way around what I'm all I'm
saying here is trying to make you aware
that these are promises there is no
obvious solution to them well if you
don't specify the order in which
multiple callbacks occur it then follows
that no callback and preempt the others
because that would make sub salutely no
sense you'd give a random caliber
callback and order if you don't specify
order strongly recommend like you can
get now optionally depending on how you
you build your Python binary do
explicitly randomize them otherwise
people will happen to will end up
relying on having read your
documentation that says the order isn't
guaranteed will happen to rely in
whatever order happens to eat you can
now compile Python so that it randomizes
every time the order of keys in a
dictionaries instead of of just not
caring I will predict that if you do a
lot of unit tests 20% of your tests will
break because they just happened to rely
without knowing yet on on a dictionary
order it's been happening to me
so anyway if you're aware of all of
these issues you stand a chance of
making this difficult decision if you're
not even aware that there's a decision
to be made then your chances are much
lower so depending on this decision that
will be implementation for example if if
you decide the order doesn't matter then
you can use most anything like a set to
hold all the collar bolts if you decide
it's last in first out or simplest out
you need to keep track of the order the
the problem how to remove a collar ball
is actually particularly hard but you if
you can't have exactly the same callable
object and a remove function then
whether it's a cent or a list you can
still look for it it will be much slower
in a list if if it's a very long list
but in practice in my experience you
often want to have multiple callbacks
but by multiple you mean three not three
millions
so even looking in a list is gonna call
you so don't worry about the
implementation to make these decision
it's not what really matters most and
finally I've already mentioned in the
past you have to decide in the case of
of multiple things whether you want
separate collar balls for flexibility or
to make sure the various things are
consistent with each other have them be
method of a single object again both
choices can be right I tend to think
functionally more than I do object
oriented ly but that's just my instinct
and when I design API is I try to think
about these things in depth because I
know that once the API is published the
changing it is going to be such a pain
that I'll have to live with whatever
decision I'm regretting for I'm not
saying the rest of my life but far too
long our errors events like any other
maybe but
I think there's a very good case to
suggest they are best singled out you
may have a cascade of actual events like
still successes and then a cascade of
possible exceptions and for that I
particularly glad to have glyph in the
audience er because he's one of the guys
responsible for this concept of deferred
which remains to this day a great way to
organize it's not the only way but it is
one simple very linear a cascade of a
code of chain or cascade of success
callback such a nor cascade of error
callback every one of them except star n
star star kW so you don't have to use
Funko partial which is excellent little
design convenience and you get argument
to identify what event whatever and this
is how the chain works so it's not
exactly a preemption its each event in
the chain can modify and return and pass
on to the next one the error or or
result of the other print as well
a callback so it is at least something
you can lift without any effort even if
you're not doing anything related to
networking like the system in which
twisted in which in which the farad
we're originally conceived it's still
going to work for you I believe this
also has the distinction of being the
only Python library concept copied
verbatim in a popular JavaScript
framework the dojo they those others are
in general obvious that matters of
Python but this one is like they really
moved is just transliterated from from I
think the JavaScript
yes that's I don't know if this old
paper points to it you probably just
need to use a web search engine and does
anybody know any search engine or or or
maybe you can find yelp reviews for it
I'm sorry can't hear you
so they just for the recording
somebody was explaining that it's not
just dojo there's just very similar
things copied into all remember that a
synchronous programming is very general
is any applicable to JavaScript well
like it's also one of the like passing
function objects around is one of the
very few corners in which JavaScript is
better than Python syntactically because
the keyword that for function is
function instead of death and lambda to
do anything to do with the team known as
the Spartans it just function means
function it's the one bit where
JavaScript got it right in Python got it
wrong so there are several kind of
events that are intrinsic to the system
such as your running program or process
rather so the at exit library lets you
register a callback that will be called
in normal shutdown not if they Python
binary interpreter crashes but for both
the normal and error exits within the
Python control signal to let you handle
unique signals this one is one of those
where you only have one handler per
signal number and what you call signal
signal it returns the old handler so you
can make believe it's still 1982 and
have fun chaining the calls like you did
in dos 1.0 isn't that fun or maybe you
can program at a slightly higher
abstraction level but sometimes you
really have to have those signals and
then there's a series of hooks that you
can use for example
this accept hook is going to be the
callback whenever the interactive
interpreter detects an exception they
default one just gives you a big stock
price but you can actually do something
very different set tray set profile
display hook that's all stuff that can
be really helpful if especially if
you're like writing or or or hacking on
python ide because it all stuff that's
happening to your interactive execution
and some extension modules follow
exactly the same like read line that you
start off set all sort of system in and
callbacks then I did mention sulla meant
to structure execution by making them up
parsing is an example they original
approach to parsing stuff like XML was
well let me process all day they extend
I'll start and end up with a big
document in memory and that organizes a
tree lot physical tree to correspond to
the logical tree that's the XML document
that's a dumb document object model
point is okay so XML took over the world
and now I have I regularly received from
from my partner over there a JavaScript
meant about a hundred gigabyte each oh
where can I buy a terabyte of memory to
hold the Dom for that it's price I mean
you can buy it today but it's pretty
pricey and actually I only need to find
where there's a tag foo within a tag bar
what's the attribute bus that's all I
care about
all of these 64 gigabyte well with the
Dom that doesn't matter you have to have
it all so event-driven parsers like go
over they open tag this close tag that
as event so you can simply ignore all
the junk you don't
care about which in the average xml case
is 97.2%
I think about approximately and and just
capture and keep around those you need
or you can use Paul press codes pulled
on concept now available several
implementation where you essentially
start as a stream of events but when you
find one that oh I know I need this you
get the Dom like structure for
everything that's below this node that's
a dummy subtree as they call it then a
pretty original approach to parsing but
it's partly event-driven and they the
real motivation for the event-driven is
to make it serial so not everything has
to stay in memory considering that in
those documents you don't care about
most of it so you don't really want to
buy a terabyte of memory just to handle
it for schedule they already mentioned
scared in terms of their customization
but of course as I mentioned earlier
what it does is it makes scheduled calls
to your functions your your events with
certain lay priority this is a collab
all the arguments and and so on you can
come sell the events and when all the
queue is ready you run everything and
this is serialized but then there's a
concurrent version which is the part of
it that we like with thread and to some
and of course with processes and other
concepts yet like Green France and stock
LEDs and and so on and other
alternatives such as the NWS way which
has elements and workers cooperating
this is what is where things start to
get really hairy compared to the
cleanliness of the 'single in exact
solution and many alternatives such as
the future also known as promise the
design pattern are getting into the
standard library in Python 3 and very
interesting structure based on that is
part of the NDB module for App Engine
that's fully available a source so just
get the up Engine SDK and or or get
package and so on and then hack to your
heart's content good and we're all done
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>