<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Going Asynchronous with Play! | Coder Coacher - Coaching Coders</title><meta content="Going Asynchronous with Play! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Going Asynchronous with Play!</b></h2><h5 class="post__date">2013-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l7IYY08Bb_4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm Michael side I currently work for
Booz Allen Hamilton and i've been using
scala for about a year now i started was
a big java developer back in the day and
started with play one back when scholars
just a package and as they expanded to
play too I kind of got the Scala bug and
I've caught it and been ever since so
just a few questions to you guys as the
audience so I can kind of give my talk
please feel free to encourage or not
hard questions first off who went to
Josh's talk earlier today all right
that's what I was scared of not really
um so he had a good night's talk on
futures which is when one of my maid
topics of what I was in to cover today
but I'll kind of fast forward through
that part and kind of explore some other
aspects of play that I really like um so
my next question is has anybody ever
used or seen of play framework before
all right awesome now who has put a
website online with said play framework
alright sweet so we got a lot of people
who are comfortable out there and I'm
sure you guys have used um acha which is
a pretty sweet package that is a on the
type safe platform so I'm going to go
ahead and just give you a little
overview of my talk this is not just
building the web service for a common
man a lot of the talks we seem fair seas
very big optimizations and so I kind of
wanted to get step back from it and kind
of say hey this is how you start and
then build your web services and then
hopefully we can get to the point where
a Hadoop cluster would be kind of cool
but you can't really when you build
their startup you can't really do that
at the very beginning so first the
basics async versus blocking I oh right
so one of the cool things that Scala
allows you to do is to create these
really nice callbacks if you have ever
seen a nodejs application you understand
the callback hell that exists right so
what the the map functions and all of
these callback functions really make it
nice and easy for you to create really
consistent and clean code so what we're
trying to prevent here is too
kind of create this non blocking area so
you can see on the left with the red
side you have to wait for your web
service to come back for you even while
you're even before your database call
right has database calls at least for
most other aliases and stuff that I use
that use a JDBC and that is blocking so
on the right you can obviously see
you're going to save yourself a good a
good percentage of time right so play
framework I'll go through this with
because most you guys have done it um
one of the major features I loved about
it was the one click reload it'll
recompile your app for you on the fly
through the browser on it comes out of
the box with all these cool features
like less coffeescript the fun stuff
that make web development what we all
know and love it's done by typesafe
they've done a hell of a good job
especially over the last week they
released 2.1 which is a huge milestone
as well as a slick one as well so
there's been a huge bump dates and it's
a really cool to see them doing their
work and I thank them immensely so a
quick demo here um so I kind of created
like a little here you go demo of how to
create a simple web service so if the
internet works what it's doing is
especially a web service it's actually
really slow and asked actually pretty
cool that I kind of made it so it's safe
it's not going to throw an error back on
our system and I'll show you the code in
a little bit but uh but basically it
says oops our services are currently
service has failed sorry so one of the
main features that I really liked about
Scala and and the play framework
especially was that it was very easy to
make it very safe you kind of call your
errors whether you needed to you can
make your fallback so you can be
repetitive if you wanted to but at the
same time it wasn't it wasn't too
excessive it wasn't to a verbose so so
that's a that's just a cool little demo
and we'll kind of go into that in a
bunch in a bunch more detail ok so let's
review some definitions threads as Josh
said before these are your these are
your single blocks of instructions that
are computed right so you can have
many processes or you can have a process
that contains many threads and you can
have these pools of threads right these
are called execution context and we'll
go over this in a little bit but these
are what actually runs in a computer
code future right so a placeholder which
represents a value which may become
available at another point so Josh might
get in did a really good job at covering
this today and explain to you the basic
functions I just wanted to kind of show
you some of the functions in the trait
from Scala source because there are some
rather interesting things especially
when it comes to failing over so in the
second section the first section was
pretty easy it's pretty self-explanatory
can you guys see it in the back ish no
okay better okay maybe it's a little
better I have good eyes I apologize um
so so the cool thing is failed and
recover um it's a very nice way of
checking to see obviously if your if
your future has failed and if you
recover what you should recover with now
the partial function right that is being
brought into the into the recover
function is really what you can use and
you can adapt that to any way that you
want some common methods I've seen our
three-time retry so if you could retry
it three times and if they all fail then
you can handle it somewhere else or you
can just throw a failure and have a user
retry it's really up to you so that's a
future a simple example of a future Josh
I went over this so I'll skip it a
promise a promise is a placeholder which
contains a future so it's kind of one of
these things that you can use as like an
interceptor um let's just you can you
can complete a future with so I promise
when you declare a promise you can then
gather its future so Josh and really
covered this earlier so I'm going to go
over it a little bit so you have a
future right your computation of a
Fibonacci
number and you have your promise right
and you say you map your promise to your
future right and you say the future on
success right that's normal but let's
just say you want a little more creative
and you wanted to have some other
function that may intercept it you could
say p dot fail or are you can do with
many other things with with the promise
and you can pass the promise around
instead of the future the execution
context these are your containers of
your threads similar to a process but
not really you can create them in a
various various different manners so
when you create your context pool what
you can do is uh is you you create your
you creator context and you can pass
this context around so i'm going to show
you guys a little bit of this in the
source code can you guys see in the back
all right we're going to be scrolling a
lot today so um we have our execution
context right now i want to keep my
database calls separate from my cpu
heavy calls right because I their
database calls are blocking right so I
can handle it a little differently and
manage my threads a little differently
than if I were to have some very
computational heavy let's just say you
know calculation calls right so you
create your execution context and then
you create a new schedule thread pool
and you say how many so this number
right here is 10 so I said I want ten
threads and instead of scrolling up
there I'm gonna zoom it and it should
work alright cool so you can control how
many threads you actually create in a
given thread pool and in your execution
context so one thing to keep in mind
when you are creating these threads and
the thread pool is that you really can't
overload it right threads are not these
magical things that you can just
change every time every time you swap a
thread there's a context switch in the
processor which has overhead in itself
so the more things you have going at one
time the more things at multi peck
multiplex through the pipeline processor
and there's more switches so at a
certain point if you overload your
machine you'll end up seeing that most
of your computer processing time is
actually switching between your threads
as actually opposed to doing your
threads so when you design your system
you need to be a little bit careful
about what you're doing some rule of
thumbs that I have that have been fine
for me I'm not a Twitter so I don't have
these huge like load things and no
tumblr but I said I've used about 10 per
core and then about three execution
context and that's worked very well for
me I haven't had too much overhead in
terms of switching and it's worked
rather well okay so whoops not that
so actors right um we some some people
touch on this a little bit before but
what actors are are a nice abstraction
for creating futures and different
asynchronous comput computations all
right so they're they're very the Atkins
it's a really nice API to work on and
you can create lots of them and network
them in a pretty nice tree so the at
fault tolerance is one of the main
features that I really enjoy about akka
and that is that it's a it's I I think
it falls under the supervisor pattern
that's what that's what I generally
works best basically what that means is
that as you create your different
application you can create a supervisor
that basic supervises all of your let's
say worker nodes and if one of those
fails they'll send a message back up the
supervisor and the supervisor can handle
it so not handling errors within the
specific worker node but you can handle
it from above and it really provides a
nice clean and elegant way of creating
code without actually having to handle
each error case in the specific number
crunch we'll go into that a little more
so as obviously as Josh mentioned before
for comprehensions are one of your best
friends they are really nice when you
chain chain a given future so you can
instead of having to say let's wait for
this to come or zip them together on
this is another alternative so one thing
to note here is so let me go through
this example line by line and sorry for
you guys we've already know play but for
those of you guys who don't um this is
in a controller okay in the MVC pattern
i'm i hope if you guys are not not
familiar with it it's basically the
thing that excuse our code from the very
beginning so the action is called right
and async these tags basically notify
play to that it is an ace
his tag intet and that it will return a
future a future result instead of an
actual result so basically what it's
doing is it just adding it into a
closure and running it as such so you
can do recent posts recent right and
then you can take the tags and then
calculate a word cloud from it and then
you yield your result and you can yield
a you can yield different results like
okay internal servers or server errors
etc so one thing that I really like to
do in this so India in the little post
and you saw the error right so what I
did here is we have our bit so the
account function is what I actually
called that you saw that error if a my
internet was working what you see is I
have these bank accounts and I've
converted it into euros right so i
called this web service i would take a
currency and it would give me a rate but
so this is a little fault-tolerant on
service right so you have your account
which you which you find from a database
and you find your rate which is a
service one thing to note here is this
fall back to that's basically the bread
and butter of the fault tolerance on
this simple simple level so basically if
the future fails right so the Play
Framework web service is actually built
asynchronously so it handles very nice
with the future it actually only returns
the future and you have to either wait
for a result which is a blocking
operation or you can have it mapped to a
future so I actually fall back to a
future of none right so if I have the
account right and say okay no accounts
fans because I don't have an account or
if I had if I have an account and I have
some account instance and I have a rate
and I actually have a rate
can convert it I can basically say hey
the account put it in the current see it
and return it back to the user otherwise
if I don't have a headache account I
return a bad request and I say our
current service has failed sorry chaps
so that's a pretty easy way of doing
some simple fault tolerance so let's do
another demo real quick so building a
synchronous web services are cool but
one of the think the biggest things in
in applications nowadays are web sockets
and real-time single page applications
so have so everybody's heard of a
website that's right okay do you guys
know what users are so it's basically
there's also this thing called continent
which is for for browsers that are old
which none of us like to develop for but
it is a sad reality and especially for
the government you have to use this
stuff so some reason they're stuck in
how you seven don't ask me why anyways
comet provides a really cool way of Lou
literally just inject JavaScript onto
your interior DOM and then it'll execute
so in this simple application I can just
post and it fetches um it fetches it
live from a database right so I'll show
you the code real quick
where is it once
wrong package
okay so here is the dashboard stream
right so that's what we're invoking at
the very beginning to basically call
this comet service right and we are
streaming back results this is not it's
not oh it's not a polling service right
so it's actually a chunked HTTP request
that's always loading all right you'll
notice in the top left corner of the
dashboard that it's always reloading
right it's one of the fall backs of the
comet thing you can have your cool
favicon on there there are workarounds
but at the box it's just not worth it so
so it's literally just keep on it's it's
having a chunked one huge request that
keeps on coming in it's a similar to
what Twitter does when if you do your
feed so in our stream right we have our
we have our enumerators which produce
the given feedback right so let's go
back and say we want in our stream we
want to see the transactions amounts we
want to see want to update the balances
and we want to get a transaction total
right and we feed this all to our
Comment which is extra provided by play
framework to parent dashboard message
know this callback is actually a
JavaScript function that you build on
your client side that basically figures
out how to consume the given inputs
right because the comet does is at least
in the way that I built this system is
that it just give it takes that it
composes this huge string and then
throws it to the client and the client
parses it and then updates the Dom
appropriately so enumerators are have
you guys have heard of enumerators and
and it Ortiz a little bit um if you if
you haven't heard of it a cloud made a
really awesome blog post about three
weeks ago that really kind of broke down
how they work but basically an
enumerator
is like a producer and iterate e is a
consumer and instead of having to
rebuild stuff every time you want to
fetch something they're kind of there
and you can just get what you want at
the rate you want it so um in our
numerators you can actually uh so I kind
of say and I build these strings they
get sent over so that's the comet way of
doing things not not the ideal if
they're you if you have WebSockets you
should use web sockets so web sockets
again it's a it's a native thing built
into play framework thank you very much
not my doing but thank you typesafe and
play is that so you can have it come in
and then you have an iterative consuming
the given the given input and you could
parse it out and do whatever you want
and then you can stream it out as you
can see below so again this is just this
is a simple example but it kind of shows
you the power of what play framework can
do in the just kind of straight out of
the box so some cool things about acha
that are pretty awesome is the is the
ask and tell system okay so when you
pass a message there are two ways to
pass a message you can say
fire-and-forget which is an exclamation
point which is basically like hey handle
this so one cool thing that I use the
fire and forget for our for sending
emails right I see no reason to have it
stuck in my controller and having to
wait and confirm that a email is sent
out I designed my system in such a way
that I fire it off and then in then
ensure that once the supervisor gets it
it supervisor is one hundred percent
responsible for sending that email if it
was a financial service and maybe a bit
differently but for my emails I found
that very doable and a good solution to
my problem
so once you fire and forget it obviously
as it says you fire and then you forget
it if you if you at so it lets say so
this uh I have a little thing that says
a generate a report right there's a few
other stuff but ignore the clutter I'll
just zoom in in so we won't even see it
so in the report actor you ask it a
message right with the account and in
the transactions and you can and then
you've mapped the result which is coming
back so in the report actor okay one
thing to note that I shoulda mentioned
before is how an actor generally works
so you make an actor class you extend
from the aqha actor and you have to only
implement one function or a partial
function which is receive and receive is
basically like a little switchboard in
your actor and you would have it handle
as many different requests as you want
and and then it will route them or do
whatever you want with them right so so
you receive and if it's a report request
you basically what I did was that I
generator the report and then the sender
sends back the report all right easy
enough because at that point in the
report actor you fire and forget you've
nothing more to do now sometimes
actually many times in my application
what I've done is that there I feel the
need to have this cascade right so I go
all the way down to do some computations
and then have to have to relay actions
all the way back up there's actually a
really cool feature that I didn't
actually took way too long to find that
you can actually forward the you can
actually forward this the original
sender to your context to your child
actor
so it's a little more verbose but it's
you can tell your actor your message and
the sender so when in the in the new
actor you send it you do sender !
message and it goes all the way back up
so a lot of times i find myself building
these acha trees in such a in such a
fashion that it kind of looks like a
finite state machine a lot of times they
each handle their very little sweet
piece of knowledge and if they do break
they report back to who they came from
and then you can handle it appropriately
um so a lot of times my finite state
machines actually had this really nice
comeback loop so i actually do end up
sending the sender around a lot does any
have any questions before i continue on
a little bit i don't know if that's a
good thing or a bad thing but we'll
continue on um another cool feature of
akka and that they build out really
nicely is the a car outer so let me find
it real quick so an echo router
basically what it does is it allows you
to simply use a bunch of different
actors at the same time um so if you
thunk if you thought about what I was
doing before right I created an actor
let's say a transaction actor right and
i passed the transaction actor to that
package to the transaction actor that's
literally only one reference of that
actor right now that's not gonna scale
I'm basically just having one worker
thread do everything that's very simple
and won't be able to scale pretty much
at all so what you can do is you can
have a router so you create an outer is
really nothing more than an act that a
premade actor so when you create your
router you do you create a
sure in the system right with a router
so there's a bunch of different
different types of routing systems you
can actually build your own if you want
to but the smallest mailbox router is
one that just makes the most sense to me
basically what it does is that it kind
of cues everything underneath it and if
one actor is going really fast or on one
machine it's going really fast you can
just keep on feeding it to it there's
round-robin routing as well as other
things so a cool part about the router
is it's a can be automatically resized
right so instead of building some
complex logic that will help you scale
and shrink your application is the
corner what it needs you can actually
have a lower bound and upper bound of a
default resizer that'll help you use
Apple use your resources most wisely on
times that have come in handy for me is
during when I deploy a system for work
and during sign up there's a big load on
sign up well you don't have a load
anywhere else it's actually really nice
to be able to use that use your
resources only for your your your signup
actors and your email services and stuff
like that so and then as you Thomas we
finish them you can shrink them up over
the course of time let me see what else
is out there so is there anything you
guys are specifically interested in or
have had roadblocks hitting it with a
plate frame work at all anything that
really confused you okay so um one thing
that confused the hell out of me
personally it was how tedious it was to
deal with JSON in to point out release
it was such a pain I felt that a lot of
it was very repetitive and I'd be end up
just creating these matched objects that
were I felt that and other systems did
very well dynamically so man dubian
Twitter handle I forget is really left
out my head created a really awesome
macro that creates
at literally one line of code so you see
this currency JSON format you do json
dot format and the currency and it will
during compile time create your readers
and writers so that saves you a ton of
time um it does not include the
validation that you can get when you do
your own but it's a cause and effect
that you kind of have to guess and kind
of pic pick and choose your battles
other really cool features in 2.1 is
that filters you can now intercept
requests and handle them and kind of
make sure that you can do them properly
this comes in handy for CSRF for
security and other potential mid or
middleware so you can actually intercept
your emails and handle and somewhere
else if you want to you can add more
module ization you can add routes in
your sub directories and kind of keep
your your application really
materialized keep your admin section
completely separate whereas before you
had to glue them in more than i would
have liked you can also do manage
controller in instantiation before you
had to create an object that extended
your traits that was actually well you
don't have to you could use an object if
you wanted to but for testing it posed
it got really difficult you couldn't it
was really not flexible so what they
decided to do is that you can actually
have in your routes you can choose to
instantiate a new controller for your
request and it will handle it for you
you can do require j/s out of the box so
that you can have a very very JavaScript
heavy application really quickly and
content negotiation which is basically
oh I want XML instead of JSON sweet
let's use that instead so those are all
really cool features that are done in
2.1 and they are still improving it like
every day you could live on the bleeding
edge and have it checked out otherwise
you can just stick with the study
release um some resources that really
helped me out the documentation is
gotten a whole lot better I really
occurred you check it out especially
recently if you are working with the
bleeding edge definitely go to the wiki
on the Play Framework github repo
because there's actually quite a bit of
difference and it be shocked at how much
it kind of kicks you in the butt one way
or the other the samples as well the
Scala school by Twitter that's a really
cool kind of a resource they put
together if internet works and if you
have any more questions feel free to
contact me mb side at gmail I just do
stuff for fun and I really enjoy it and
feel free to contact me and learn more
questions could you talk about your
experiences with a more middle pardon a
norm could you talk about Norman okay um
yeah I really dislike it so I got really
spoiled orm is awesome I have a have a
post on my blog about how I actually use
the Java EE bean as my model and have it
in a subdirectory if you have in the
same directory as the same project as
your scholar plication the Scala
compiled first and none of your
functions you have your Java because it
does a lot of bicoid manipulation under
the hood for java will get brought in to
your scala so if there's a whole lot of
compile errors so what i actually did
and actually has paid off greatly and
minus on decisions is create my model at
a standalone play package great project
and i can actually import that into my
api and do that so it's actually very
modular so i don't have to have a one
big monolithic application i can move it
around so talking about creating a
separate project uh you know i'm i'm
richer than in creating a project and
then creating lots of different themes
of that play application like for you
know reselling the core project two
different clients customized in
different ways so
how would you go about like like with
your models example if you stick those
in a separate package or or a separate
library and get sub-module it in or
something like that it seems like it
would be a real pain to you know commit
between different projects and push and
if you you make a change in your
template over here and you need to add
an infield to the model then you've got
to go like recompile the separate
project and so so there's I when I
wanted to send sub-projects it might
have been playing I apologize for that I
actually don't do separate github
projects and a separate repos what I
have our SVG play projects so you can
actually do dot depends on and have it
depend on another project and even have
it depend on as many as you want so
basically that it'll actually recompile
your other one first before compiling
your parent application so you'll see my
I have one play application at the very
front and actually has nothing in it
besides depending on a whole lot of sub
modules um so in that you can actually
like ensure that accomplished in orders
done right through that does that make
sense yeah so so when I when I do push
to get hub or whatever I mean have you
have you worked with sub modules or is
there uh I use sub modules for packages
that I don't control um in general I
haven't really worked with a big enough
this scale that I have had to have more
than one different project to do
different things okay so I really
haven't done anything like that one last
feature i'd like to share with play in
the last two minutes i have is the debug
feature on so that has saved my mom so
many times to start it you exit back to
your shell and you do play debug right
and it basically creates the socket 999
that you can use to debug your
application in IntelliJ you can do
run your edit configurations create a
new remote change the port to 9999 apply
ok run the debugger and bam you can
throw breakpoints anywhere um saved my
butt so many times so i don't know i
didn't know that earlier but it's that
easy any other questions hope you guys
learn something
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>