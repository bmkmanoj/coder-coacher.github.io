<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Busy Java Developer's Guide to Scala: Thinking | Coder Coacher - Coaching Coders</title><meta content="Busy Java Developer's Guide to Scala: Thinking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Busy Java Developer's Guide to Scala: Thinking</b></h2><h5 class="post__date">2012-10-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_qRYOayG9SM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how many of you saw Neal's functional
thinking session earlier a couple of you
okay oh by the way introductions that's
me
most people don't care moving on how
many of you have used Scala before a
couple hands how many of you are
familiar with design patterns okay let
me let me rephrase that how many of you
are familiar with design patterns and a
man or other than I cut and paste code
from the Gang of Four book okay all
right cool because what this session is
is kind of intended to do is to help
help you start thinking in Scala to help
you start trying to reason instead of
you know like when you learn a foreign
language right and and there's a certain
level of mastery when you have enough
vocabulary words to be able to say where
is the bathroom and please know squid on
my plate right and then there's a level
of mastery where you can actually put
together complete sentences hello how
are you I'm fine and you can actually
understand the responses that are coming
back to you but then the next level of
mastery beyond that is when you actually
think in that language right when you
find yourself when a response comes in
when when a question comes in you don't
have to translate it into your native
tongue generate the response you want
and then translate it back into whatever
tongue you're trying to speak to us all
right they say actually that you know
that you have achieved fluency in a
language when you dream in that language
now are you going to go home tonight and
dream in Scala god I hope not
because if so there's probably less hope
for you than there was even just five
minutes ago but that's really where we
want to go right that's really where you
want to be able to take your knowledge
just knowing the Scala syntax doesn't
really give you a whole lot it's when
you start exploring some of the concepts
when you start exploring some of the
ideas and in particular let's be really
clear about this Scala is not just a
functional language there are a number
of functional languages in the world if
you want to play with a language that is
just functional I'll encourage you to go
look at Yeti why et I write the name of
the abominable snowman it's an
implementation of standard ml running on
top of the JVM and it's just purely a
functional language if you want to just
kind of go grok the functional world for
a while you can go play with that and
still be able to you know produce jar
files in la scala is a hybrid of both
the object world and the functional
world
right and so it's really when we start
drawing from both worlds that that
really is where we see a lot of the
unique power that work that Scala
represents Scala has a cousin by the way
over in the.net world called F sharp and
of a friend of mine who even though
she's a Java programmer kind of got
interested in F sharp and kind of
started playing with it toying with it
etc and she actually Jessa Tron comm if
you go to her blog
she's got an example of how her Java
code improved because she wrote the
pseudocode in F sharp first and then
said okay now I know what I want to do
now I know how I want to approach this
and then sort of translated it back into
Java because of course Java is a very
poor object functional language it was
designed to be an object language Scala
is the most logical equivalent to F
sharp if anything F sharp is a little
bit more on the functional side and
scholars a little bit more on the object
side it's when we take these two and
combine them and start investigating
that that we really start to see some of
the power here now this particular
session I'm assuming that you have at
least some familiarity with the Scala
see and I think one of you raised your
hand so the rest of you you're just
screwed I'm sorry it's not my fault you
didn't meet the prerequisites don't take
it out on my eval all right
it's your fault you deal with it
I think you could still be able to grok
some of the concepts and I think you'll
still be able to see some of what we're
trying to get to but obviously having to
ask you know what exactly is that square
bracket there slows us down all right
so try to you know the syntactic
questions we can try to address later
and certainly you know these the the
examples will still stand for something
for you to pick up later as you pick up
more of the Scala cinta but going into
some of the functional ideas part of the
idea and I'm just going to blow through
these pretty quickly you guys a a bunch
of you went and saw Neil stock so this
will be repeat and be because quite
frankly I want to get to the other stuff
this is foundation prerequisite etc the
functional world says essentially that
the the statement x equals x plus one is
fundamentally busted
I mean think back to your math classes
think back to your algebra now for some
of us that's gonna be a lot longer reach
than ever those of us to think back to
when we were in grade school and learned
algebra but bear with me the
mathematical equation x equals x plus
one think about that for just a second
remember what you do in math right is
you drop a value in for X and the
equation should hold and so if we drop
the value for in for X what do we get we
get four equals four plus one four
equals five
folks this does not work unless you work
for Enron or you're part of the Greek
government
oh come on that was topical and funny
anyway four equals five makes no sense
and the mathematicians of the world will
be very quick to point that out now we
as computer scientists understand that x
equals x plus one is not intended to try
to be an equation it's intended to be a
sequence of steps
fetch ax add one to it store back to
where we had ax right but the
interesting thing is if we look at the
mathematical parts of this there are
some interesting concepts that emerge
out of this for example reaching back
even further and this is probably going
to be more of a challenge do you
remember in algebra algebra two two
equations two unknowns right where you
have X plus y equals 5x minus 1 equals
to solve for X and why do you remember
how we did it we isolated one of the
variables on the other side of the
equality sign right so x equals y blah
blah blah and then we could take once we
had x equals something because equality
is equality right means I can substitute
one for the other then I can take that
other and drop it in wherever X was and
suddenly now we have one equation one
unknown we can solve
ba-ba-ba-ba-ba and get two answers for x
one it's that substitutability that's
really interesting because in the
functional world when we started talking
about doing this for programming this is
where we get some of the lazy evaluation
characteristics you hear about in
haskell if we say x equals this plus
that well we don't have to actually
evaluate anything until we absolutely
have to it if that thing happens to be
made up of other things and then made up
of other things and that
substitutability also means then that we
can do that anywhere that X's where
anywhere it appears et cetera we have
some really interesting concurrency
properties that begin to emerge if X is
equal to this expression here well then
technically we could take the parts of
the expression and fling them off onto
other threads for calculation because X
depends on all of them
and suddenly concurrency isn't nearly as
hard particularly because X never
changes right at no point in math does
the value of X ever change we might
derive a new value from it which point
we call it X Prime but it is immutable
at no point does evaluating X change the
value of anything else these are
properties that are really really useful
for when we start trying to program
concurrent life and in case you hadn't
noticed concurrency is kind of becoming
a big deal because our processors are
not getting faster we're just getting a
lot more of them how long before your
phone has eight cores in it your phone
eight cores think about that for a
second
you can't even program the phone
embedded devices in a singly threaded
manner anymore
so this is part of the reason why this
functional stuff is getting really
really interesting and exciting and some
basic functional concepts we see
functions as first-class values that's
one of the key things that makes a
language functional can I pass a
function around as if it were just any
other datum in the system right do I
have function literals
because remember int x equals 1 well X
is now a value but 1 is the literal
representation of that value of that
integer type why can't I have function
literals in Java we've been able to pass
around functions as first-class values
but in a very very cumbersome manner
we've always referred to them as
anonymous inner class instances every
time you created an anonymous runnable
you were creating a function literal but
you were doing so and quite possibly be
most obtuse syntax ever invented Java 8
will fix that we are getting lambdas yay
thank you God and Brian gets not a lot
of difference between those two actually
and this will help change a lot of how
we program now there's a bunch of other
things that we see too strongly-typed
type inference right functional
languages like to have very rich very
powerful type systems if you are not up
on your type system theory you're
probably going to run into some really
really confusing error messages and
that's probably one of the weak areas of
the functional world is the fact that
they assume that everybody knows what a
cattle morph is amiss they can describe
category theory and we all dream in
monads
I do none of the three okay and that's
one of the areas where the functional
community has to kind of step out of its
academic background and meet the rest of
us halfway immutable values strong
emphasis on recursion everything is an
expression not a statement so in a
functional language again based on its
mathematical background everything
yields a value so for example in Scala
if-else yields a value so you can you
can say return if true five else seven
because that yields a value ideally
yields five or yield seven okay it's
that's a subtle shift in thinking but it
is an important one tuples lists we see
lots of lists vastly preference lists
over arrays for reasons we'll get into
later pattern matching it's basically a
switch on steroids currying partial
application of functions this is doable
because if I have a function and we
treat it as basically a function we
treat it as a first class citizen
suppose I have a function that expects
three parameters and I give it one
what's the result of that
the result of that is obviously a
function expecting two more parameters
in Java it just wouldn't compile but in
a functional language we say okay you've
put one parameter there well now go
ahead now the result of that can't
remember everything yields an expression
yields a value the result of applying
one parameter to that function is a
function that's expecting two more
parameters and you can call that just as
if it were a standalone first class
entity that takes a little while to wrap
your head around
trust me it's taken a while and my head
is probably thicker than yours but still
so again first class values right if I
need to be able to for example iterate
through a collection historically we've
always said get an iterator and use that
to get each element out of the
collection that's just dumb why should I
have to worry about having to get that
iterator what I just passed the function
into the collection and let it figure
out when in how to call my function that
I want to do on each one of these
collection elements this is called
inversion of control you may have heard
of it right seriously it's the don't
count you know don't call me I'll call
you principle it's exactly the same idea
this is part of the reason why Fowler
really wanted to move away from the term
inversion of control and more into
dependency injection for talking about
you know database connections and so
forth being handed in to you inversion
of control is a generic principle it can
be applied in a lot of different ways so
instead of you saying I want to grab
every element out of this list the
collection could do that for you because
the collection has better knowledge of
how the collection is stored internally
and let's think about this for a second
you want to walk across an ArrayList you
want to walk across a list a linked list
you want to walk across some list that
somehow a mishmash of both in each case
you're going to grab an iterator and
you're not going to be able to take
advantage of again some concurrency
opportunities you're just walking across
the list and printing out every item in
the list do all of those have to be done
sequentially
is there any reason why the collection
couldn't say you know what I've actually
stored this collection in four distinct
chunks so I'm gonna spin off four
threads and have your function evaluate
each element across those chunks in
parallel and by the way what is your
code have to do to opportunity to take
advantage of this nada
just hand in the function let it worry
about all the details once we see this
idea functions the first-class value is
starting to permeate through the rest of
the environment we're gonna see a lot of
really interesting things emerge and
that is one of the things that Java
eight is supposed to bring to us is the
idea of promoting this function as
first-class value because now that we
have land us we can start to thread that
into the rest of the library and there's
some other interesting features that are
coming as a part of eight that will help
make that easier to do without creating
chaos strongly-typed type inference they
member I mentioned this immutable values
recursion mention this expressions not
statements mention this tuples a tuple
think about a couple is basically an
object without field names no methods
just data and if you look at what we do
in Java for example if you look at data
transfer objects right and everybody
talks about how you write a DTO and it's
got some fields and there are some
people will even argue that you
shouldn't even have getters and setters
because you're not really trying to
encapsulate anything DTO is a tough old
guys or tuple depending on how you want
to pronounce it it's a temple a result
set is a topple it's basically a
collection of data a bundle of data that
is essentially just ordered right so if
you say I want a couple of string string
int then okay here's a couple of string
string int and what that string that
string in that int mean is entirely up
to you there's no field names there
there are a lot of places in Java where
we could in fact use tuples quite
elegantly quite quite strongly quite
well um lots of people are really you
know lots of object purists don't like
tuples because a it's public data oh my
god a field in the public space didn't
God have a commandment about that or
something at the end of the day
if you're not we need to be more clear
about what we're trying to encapsulate
what we're not trying to encapsulate the
DTO has no encapsulation whatsoever
doesn't if you change the representation
of the eto doesn't matter where the
fields of public private everybody in
the world who touches that DTO has to
recompile
that's not encapsulation that's just
annoying
there are places where tuples are
extremely useful lists are highly used
strongly used inside of a functional
language because lists can peel head and
tail off very very easily you'll see why
this becomes useful in a second pattern
matching pattern matching imagine switch
case but where we can also extract
values out and store them into local
values variables while we're working at
it imagine being able to switch on
things like the type of along with
things like hey by the way switch when
this particular value in the tupple is
equal to this string switch when it's on
this particular stream if you go look
hard at pattern matching in scala when
you come back to java you will feel like
a kid whose Christmas has been taken
away from you ok
pattern matching in many respects is the
gateway drug to getting you to want to
use a functional language because there
are so if you told me that I could have
a programming language with only one
kind of flow control construct in it I
would take pattern matching and I
wouldn't miss the rest ok it's extremely
extremely powerful it's switch case on
steroids except these steroids won't
like you know kill you
partial applications I mentioned that
providing some of the parameters but not
all of them to reveal a new function
expecting the remainder of the functions
and currying well it turns out that once
you understand partial application
currying is a form of partial
application that says you know what I
can take a function expecting a couple
of parameters and provide one and then
use that as the input to another one
which is the input to another one which
is the input to another one to create a
pipeline that's officially known as
currying anin laziness again this is
part of that mathematical representation
that says look I don't need that half of
the equation so therefore I'm not even
going to bother calculating in some
respects we see some some of this style
of laziness when we look at boolean
short-circuit evaluation right if false
and doesn't matter what the rest of it
is because the false will render the
whole thing irrelevant so we don't even
evaluate the rest of the expression but
we can do that in a functional language
by simply saying look I'm not going to
call anything until I absolutely have to
I can pass that thing around as many
times as I want but it's not until it's
actually necessary that I will go
evaluate it and again this provides some
opportunities for concurrency and so
forth one of the other things that we
see show up in a lot of functional
languages although this is not
specifically a functional concept is
this notion of a sequence so we have
these lists in Java alright so I have a
list of a thousand elements and what
that means is I have a list of a
thousand elements in a functional
language for example Haskell has this
notion of an infinite list
and this really blows people away if you
come from a C++ Java c-sharp background
because you're like how can you store an
infinite list how can I have a list of 1
to infinity of all the integers ever how
would I represent that in memory if I
have a finite amount of memory the way
this works is functional languages
actually don't store the entire thing
they just know how to manufacture the
next element in the list this is
sometimes known as a sequence or a
stream and we can look at a lot of
things as a stream or a sequence and
doing so opens up some really
interesting possibilities particularly
when working with iterators and so forth
being able to pass something in so this
for example is where the groovy guys get
all excited because they say look just
hand a function into the file class and
we will go ahead and call that function
on every line in that file up until that
file ends even if that file never ends
we'll just wait for the next line to be
there and then when that line is there
we'll hand it to your function and you
can keep going this tweaks you in weird
ways because now all of a sudden you
don't you don't think of the entire list
having to be in memory anymore I don't
have to read in traditional Java I had
to read the entire file into memory put
that into a collection and then iterate
through the collection if I wanted to
make use of any of the collection style
interfaces but you don't as long as the
collection the sequence knows how to get
the next thing you only have to have one
of those things stored in memory at any
given moment in time and you just
process each and an on demand basis
and you go whoo hmm lots of places where
we can look at things as a sequence okay
patterns there are a number of reasons
why patterns came to be all right now
how many of you've read the Gang of Four
book
come on the Gang of Four book design
patterns right it's been so long ago you
forgot this was required reading for
anybody in the Java space like you know
15 years ago if you walked into a job
and you said what's the gang of four you
walk right back out of that job you were
done right and so one of the things that
I found difficult frustrating about
people in the functional community is
they kind of poopoo the whole idea of
patterns and so forth like that pattern
yeah who needs those let's talk about
katha morphisms okay stop
anytime you're learning something new it
helps to take what you know and see how
it translates into the new world right
even if it's not necessarily a direct
correlation it still helps to be able to
start from something you know because it
gives you some place to sort of anchor
gives you some concrete nuts so for
those of you who've forgotten who the
Gang of Four were alright this is the
gang of four Gama helm Johnson
Felicity's wrote a book back in like
1994 which probably was before some
programmers were born at the rate things
are going and they broke their notion of
patterns these elements of reusable
object-oriented concepts they broke them
up into three distinct categories
creational structural and behavioral and
said look this is kind of how you know
we see these ideas occurring over and
over and over again
in software in object-oriented software
and it was the genesis of the patterns
movement there was actually a book
called the gang of five which predated
them by about six months but for
whatever reason this one really tapped
into the angst that a lot of Java
I will not job it about for C++
developers at the time it tapped into
the angst that they were feeling like I
don't understand this object thing I
don't get it I don't understand how I'm
supposed to use these things
what's an object now the interesting
thing about this is if you look up there
nowhere do we see anything about domain
classes the whole domain driven design
is completely absent from this the early
days about objects were about building
infrastructure and support code and
completely antithetical to the way Alan
Kay imagined objects to be
but be that as extremely influential in
terms of how people looked at object
orientation so one of the most popular
patterns from the Gang of Four is of
course the singleton insurer class has
only one instance and a pride a global
point of access to it I think every Java
C++ c-sharp developer has written a
singleton at one point in their life all
right now interesting and ironically
we've been doing Singleton's for a lot
longer than the Gang of Four it's just
that before then we called them Global's
and they were bad now that they're
Singleton's they're good right kind of
like how you know before it was you know
police brutality and Big Brother and now
it's the Patriot Act right come on guys
no it's after lunch but this is my a
material here come on all right in Scala
we can do a singleton just by using the
object keyword the end I mean literally
you say object foo you have a signal to
the end we're done this is interesting
because a lot of times what happens is
yesterday's concepts that require a
bunch of code to support become today's
first-class citizens we could do objects
in C it was not hard as a matter of fact
if you did 16-bit windows C programming
you were programming in object-oriented
style you were sending messages you were
doing objects the way small talk does
objects you were sending messages you
were receiving these messages discarding
the ones you don't want you had this
thing where data was stored it was
called the H win the window handle you
were doing object-oriented programming
it just took you 20 pages of code to do
it and C++ came along and said you know
we could make a lot of that code go away
and we all went hallelujah praise
objects all right
well some of these other concepts came
along as objects slowly began to mature
and slowly we began to find where the
limitations were and we said you know
it'll be really cool if we can have an
object that was all by itself out there
we call it a singleton and that turns
out to be kind of
so so Scala said great first class
constructing the language object foo
you're done now define whatever methods
you want on it by the way when you have
Singleton's do you still need statics
this is one of the interesting debates
that rage within the Java space right if
I want to have only one of something
should it be a static field of a class
or should it be a singleton instance
Scala makes that very easy it says
there's no such thing as static there
are classes of which we have instances
and then there are objects of which
there is exactly one the end and there
are instance methods on the signal 10
and there are instance methods on the
instances the end no more debate no more
discussion silly it's stupid this is how
language is advanced this is how we move
to the next step a lot of these patterns
are going to disappear because the
languages say we want to make that a
first class concept so here we see a
singleton that was exciting huh
moving on command encapsulate a request
as an object thereby letting you
parameterize clients with different
requests queue or log requests and
support undoable operations
alright the example that they used in
the Gang of Four book for command was
menu actions right you know if you're
writing a text editor and you want to be
able to undo everything you just did but
what they said is each menu action each
keystroke each anything you do inside
the editor should be a command object
and then the command object should be
stored in a queue and that way you can
know exactly what you were supposed to
do the command objects get handed you
know when you click on the button that
command object gets fired and the editor
controller whatever you want to call it
execute the command to see what happens
a new character goes there but we can
also keep these command objects in a
list in order so that as the user says
undo the command object knows how to
undo what it did which is a very useful
construct we actually see this
resurfacing today by the way in larger
systems what's known as event sourcing
so the idea now is okay I have a state
of the universe I have my database and
instead of user does something on a web
page triggers a change to a row here
user doing something on a web page
triggers an event which says by the way
the user changed this table this column
to this value and instead of making the
change to the database we just store
that event somewhere it's very very
similar in some respects to how we see
source control systems work we start
from a known state and then we just have
a bunch of deltas and then at a certain
point you can snapshot and say okay the
Delta is you know will still track all
the deltas but this is what the current
state of the database looks like and
then we'll just start tracking deltas
again this is known as event sourcing
yes all of this is basically based
around the concept of the command
pattern here is a small nugget of thing
that says this is what you do and you
know what we call that in a functional
language our function
any questions I mean again this is a
case where we may put a small amount of
doctoring around it because one of the
consequences one of the context of
command is not just we want to do but we
also want to undo okay but with in Scala
any object which has a method called
apply can be directly invoked so I can
take this Cal command right so you see
CMD here in the in the corner right this
guy here
it's a Cal command the name of it is ad
and the function again here we see the
function literal which says x and y are
two parameters of both of type int and
the expression here is we add the two
right and again because everything is an
expression that implicitly is what's
returned so now when I come here and I
say command parens 2 comma 5 that is
Scala syntax for saying invoke the apply
method on that object any object can
have an apply your person can have an
apply so you can walk up and say Ted
parens something else whatever that
whatever that makes sense to you what do
persons do right it's a do kind of
operation that's an implicit do so
creating a command is just as easy as
object with and apply the end
now to support the undo we would need to
write some other kind of method which
would maybe be unapplied which Scala
won't recognize but again that's us
taking the the the first class construct
in the language and filling it out to be
the pattern right so command wants to be
able to do and undo okay we would still
have this command we would have an apply
we would have an unapplied and we could
string these things together and then
roll them back as we need it but again
the concept of a thing that knows how to
do something we call that a function
strategy define a family of algorithms
and caps are each one and make them
interchangeable strategy let's the
algorithm vary independently from the
clients that use it I mean it sounds
familiar doesn't it right a lot of these
patterns tend to be slight variations of
each other and you know what we call a
strategy in Scala
ah function matter of fact in a lot of
cases where we look at the Gang of Four
once you have functions as first-class
values a lot of the patterns just turn
into usage of first-class construct the
end doesn't mean the pattern is any less
useful it just means that we're not
going to be able to you know ascribe
quite as much mysticism to them as we're
used to Oh
visitor ha ha ha that's like the hardest
pattern in the whole book yeah and it
turns out to be really kind of simple in
any language which supports double
dispatch directly like Lisp composite
compose objects in the tree structures
to represent part-whole hierarchies
composite let's clients treat individual
objects and compositions of objects
uniformly in other words it's the
classic tree all right
it's the classic node leaf tree
directories and files and so forth right
a directory is a file but also contains
files which can be directories business
directory is a file
it's a classic tree in object
orientation and in Scala we can do this
it's actually pretty straightforward we
can see the abstract class that across
the top drawing element you can see it
defines one method called draw we can
see the primitive drawing element notice
it has a draw implementation we can see
the composite which says by the way I'm
just going to take a list of drawing
elements and when I draw now notice what
I do here again list is a collection the
collection knows best how to iterate
across it so what I do is I pass in this
DES dot for each prends d arrow D draw
that is me handing a function literal
into the collection saying do this on
every element
okay and of course what's going to
happen if one of those children is
another composite well then when it's
called when it's draw is called it will
in turn call drawn all the subtypes as
well get really used to that concept
because when Java 8 shifts far as I know
if what Brian has told me his intentions
are all of the collection classes will
have similar kinds of methods so instead
of obtaining an iterator from an
ArrayList you will say ArrayList dot for
each and pass in a lambda
and it will be a hell of a lot shorter
and a hell of a lot easier because
you're saying I don't really care about
the rest of it just here do this on
everyone we're done
okay now Scala brings in a couple of new
ideas too wouldn't be interesting if it
did Scala was just another variation of
Java who gives a crap right let's just
all go home or better yet let's go to
the bar and have a beer all right
Scala brings some new concepts into the
game here now one of the things to
remember is that the patterns community
says it's not a pattern until it shows
up independently three times and then
technically it has to be workshop data
patterns conference now that was what
they said ten years ago when pattern
workshops were available like in every
part of the country I don't know if they
still hold of that today but the point
is it's not a pattern until it has been
independently discovered in three
entirely different places I'm not
suggesting these or patterns per se I'm
suggesting these are ideas that I've
seen and they might qualify as patterns
they might not I don't know
decompositional recursion see one of the
things is when you stand up here on
stage particularly when it's on a real
stage you have to use pretentious
sounding language otherwise people won't
take you seriously
good decomposition or recursion you've
got a list of items you want to do
something to each one as you do it the
list itself however is immutable as are
the items inside of it so what you want
to do is basically peel off the item at
the head of the list do your operation
to that gather the result and recurse on
the tail of the list the head of the
list is the one item the tail of the
list is everything after that this is an
extraordinarily common pattern in
functional languages and part of the
reason is because it is completely
thread-safe the list is immutable lots
of people can be doing things to that
list at the same time because it's
immutable and the items inside the list
are immutable and all of your
intermediate state all of the
intermediate results as you go they're
not stored someplace else they're stored
on the thread stack because we are
recursing down when we get to the end of
the list we'll start peeling at all
back together and turning it into a new
list and handing that back but it's all
scoped to this thread zero concurrency
concerns
and people in the audience are like all
right no thread concerns now most
languages have this construct already
they call it a fold fold left or fold
right whether you want to start from the
head of the list and work to the right
they call that a fold left or whether
you want to start from the tail of the
list and work left
they call that a full right don't ask
just it's going to be backwards either
way you want to look at it some of them
call it fold head and full tail which
makes more sense someone call it L fold
our fold at whatever because the whole
idea here is we're taking two elements
and we're sometimes we're folding them
together to do like we want to add up
all the elements in the list we're
folding them into a single value in
other cases that's known as just a map
because I want to map a function on to
that individual value and produce a new
one but here you can see what I've got a
got a list of string here and what I
want to do is I want to reduce it in
some fashion right and so here I'm using
the reduced list this is this is this
reduced list function here you'll notice
this L matched curly brace that's
pattern matching what I'm saying is
let's look at L which is the list that's
passed in if it's the empty list just
return an empty string okay that's the
exit case that's when we stop recursing
draw this this sort of decompositional
recursion always has to have an exit
case otherwise it's known as an infinite
loop generally not a good thing good but
the second case here you see this case
it's calling : lists in that expression
I am saying it is the head of the list
I'm literally peeling these two apart
and so if the list is an element of one
or more that first head element will get
found to the local variable it and the
rest of the list will get bound to local
variable LST and then what I do is I say
well in this case again because
everything is an expression
pattern-matching is an expression what
I'm going to return here is it that head
of the list plus recursively do this to
the remainder of the list
so what this does is it takes a list of
strings ABCD as five separate strings
and return and smashes them all together
to be ABCDE in one string I'm folding
them all together into one return bell
makes sense you see this pattern a lot
and this is part of the reason why we
like lists because we like peeling off
the head and doing something with the
tail and storing it on the stack storing
the head on the stack until we get to
the end of the list and then pushing all
those head parts together back into a
single list no by the way it maintains
the order as well and good stuff you can
see we can also do this with integers as
well in this case I pass in the exact
operation to do so I've got a list of
numbers that I want to add so I say I
want to take my list of numbers and call
my fold here passing in 0 which is the
starting value the operation to do in
the list to do it on ok and down below
we see using Scala's built-in fold left
these two will produce the exact same
results
so far so good by the way
one more interesting thing about this
this is also how we can turn a list of
objects into a stream of XML
because think about what we do when we
want to take a collection of objects and
turn it into xml we go to each element
in that collection let's call it a list
and we say start with this seed we'll
call that a like a starting value a seed
value and do this to produce this result
this is exactly the same thing we did
with the list of numbers in the previous
slide and the operation used to produce
each person's xml is just he returned
this string right return this person
first name person in XML format the fold
is not just for doing trivial exercises
for adding numbers together it's for
anytime you have a collection of
anything that you want to reduce down to
a single value
now stop for just a second and think
about this if you had walked in here and
I had said I'm going to show you a
technique in Scala that will be generic
across both adding numbers together and
turning complex objects into xml
documents you'll use basically the same
built-in constructs to do both of these
operations how many of you would have
believed me
and do you know why because the
functional way of going at things is
completely antithetical to the
object-oriented way of going and this is
a good thing because it means that when
we have both axes covered we have all
kinds of opportunities for reuse what
you have to do though is you have to
stop thinking in object terms and start
thinking in functional terms not because
I want you to stop thinking an object
but because you have to open yourself up
to the possibility that there is an
entirely different dimension of reuse
here
than what you're used to once you start
thinking in both directions now all
kinds of interesting possibilities begin
to emerge and your code will get shorter
tighter cleaner easier to understand etc
but only if you understand that
additional dimension for years the
object community has said hey there is
no such thing as color there is black
and white I'm trying to tell you that
not only are there shades of gray but
there's this concept of blue red green
etc it's gonna take a while to let your
eyes adjust once you do though you'll
start to see that not everything has to
be these cross-hatched patterns of black
and white now we can start throwing
colors into the graphs it just it's
going to take some time to get that
depth into your way of thinking about
how we do software the iterator
inversion of control we talked about
this a little bit but one of the things
one of the dark secrets that the guys in
Java the guys at Sun who now work at
Oracle one of the deep dark hidden
secrets that they don't want to tell you
is that every time you create an
iterator God kills a kitten
I'm not joking I'm not joking it's a
dark ugly secret bound up in ritual and
you know that the Sun buildings right
they burned them down because they don't
want you to see the pits in which they
conducted these rituals and bound the
source-code together now you guys like
kittens right
does anybody here who does not like
kittens
I should have known the guy from
Oklahoma City doesn't like it okay in
your case God kills a puppy Oh God in
that case it's two kittens or two
puppies that died right the point is I
want you to stop reaching for iterator
every time you want to go through
something because there's a lot of
benefits to be had by letting the
collection worry itself about how to do
the thing you want to do instead of
reaching for an iterator to walk across
the collection create what you want to
do as a function as a block of code and
hand that into the iterator for two
reasons number one because when you
write it will actually be much much
shorter and you won't have to worry
about a lot of weird edge cases but also
number two your code is intrinsically
more reusable because what's the
drawback to a for loop you can't reuse a
for loop
attempts to do so will lead you to this
pattern plus we get the idea of doing
this stream like behavior as well how
many of you have seen the groovy
demonstration where they pile you into a
room and they say groovy is better than
Java and you go down oh no no it's not
they say yes look because if you just
want to read a text file look at all
that crappy code you have to write in
Java and in groovy it's like two lines
and the idea is you're supposed to go
you're right groovy is better than Java
I'm so ashamed
stop the only reason why they can do
that is because they took all that crap
code and they baked it into their
library you can do that and you could do
this exact example in Java by the way it
is very easy to create a file line
iterator now I'm doing this in Scala but
basically this code here write this file
reader bufferedreader etc etc this file
class that has this elements Bulova this
is actually just collections 101 it's
collections 101 and file i/o 101 but
notice what's on what I'm doing here I'm
not reading the entire line or the
entire file in the memory and storing
them as lines in a collection because
then if this is a two gigabyte text file
I blow out the JVMs heap instead what I
say is the iterator knows every time you
call next the iterator knows how to go
fetch the next line
it's all it has to do is know how to
manufacture the next element in the list
so that now down here I can say hey I
want to create one of these and then
because in this case it extends the
iterable interface right by the way that
interface exists both in Java and in
Scala and Scala has some additional
methods to it that are not present in
Java but they'll probably be there as a
part of Java 8 when now because it's an
iterable because it satisfies the idea
of being able to create an iterate or I
can say for each for each line do this
and again you can do this in Java you
just have to put it into a jar file and
use that as part of your standard
library there's nothing Scala asked
about this this is everything about
thinking functional and then the next
time one of those groovy guys comes by
and subscrube e is so much better than
travel you can say you groovy get
out you just have an interest a more
interesting library this is not baked
into your particular language and I'm
not bitter I'm really not really really
not pipelining this is again part of
that notion this concept of currying the
idea that I have a set of behavior I
want but if I've got I've got actually a
lot of these behaviors that I want and
there there seems to be just so many
things that are common across a lot of
them right think about like mathematical
operations everything we do in math is
basically built out of the four five
cardinal operations all right add
subtract multiply divide technically
modulo is in there as well right
everything else is kind of built up out
of those would be great if we could
somehow string them together put them
together in kind of a modular way well
this is where we get into this notion of
partial application of functions
currying so here I have three functions
convert to int double it and square root
it and implicitly they each take one
parameter okay and now using the built
in Scala and then this is a method that
says oh if you give me a function on the
right hand side I will take the function
on which we do this I'll basically
create I'll return another function that
says when you call it it goes to a and
then to B in other words it's the glue
that had that joins these guys together
so now the pipeline is convert to int
and then double it and then int to
double and then square root it
now tell me just tell me that if you
presented that pipeline definition to
somebody who's not a programmer they
won't understand it
this is where we start getting into the
dsls all right the idea of a
domain-specific language that I can give
to non programmers and let them define
the behavior and if you think about it
this is all of what that business
process modeling crap was about this is
what BizTalk was supposed to do is what
oracle beep hell was supposed to do just
basically define these workflows define
these lists of things so that non
programmers could maintain them so what
we do is we build the small primitives
and then they join the primitives
together in interesting ways to create
business behavior that programmers don't
have to maintain winning expend a metal
object occasionally we want objects that
are actually manipulated to find
manoeuvered etc had runs on all right we
don't want to know all of the properties
we don't want to know all the behaviors
for all that the functional community
loves strict typing there are still a
lot of cases where it can be helpful to
have objects that change their shape and
change their behavior and so forth at
runtime the Lisp guys are squarely in
that conjunction of forces the Lisp
language is a dynamic language that is a
functional language okay and believe me
if you ever want to see two functional
guys fight it out have a Haskell guy and
a lisp guy argue as to whether or not
Lisp is a real functional language and
they'll just beat the crap out of each
other that's kind of like asking a group
of C C++ Java or C sharp developers
where the curly braces should go
it's bloody it's ugly and it's really
kind of pointless but so be it we can do
this because hey let's just use the
built in Scala map and notice here Dyne
one it is an object
tell me how dine one is different from a
traditional java class we have fields
first name last name and age and we have
methods we have this thing called two
string which by the way the value is a
function which knows how to do something
with this in order to produce to produce
a string you want to hear something else
that's JavaScript
that's exactly what javascript does
javascript is that the objects in
JavaScript are nothing more than a bag
of name value pairs where the values can
either be data or code the end
that's it that's the secret to
JavaScript
now unfortunately using this is kind of
a pain in the ass because scholars type
sake and so when I say that this is a
map of string to any up there on the
first line it means that in order to
take two string and see it as the
function that takes a map of string to
any and produces a string in this
particular case I have to do this really
ugly downcast there and to be honest
most of the time we don't want
completely dynamic objects what we want
are objects that have a core set of
things that must be there so think about
persons for just a second right think
about people we've always talked about
various ways in which we model the world
right how many people in here speak
French
how many people speak German Chinese
Russian okay how many people in this
room cook how many people in this room
play soccer how do we model your skills
of all these different things we can get
into this well you know we have skills
and there's a name of the skill and it's
kind of a you know a numeric value or
something like that but if we go
drilling deep enough into each one of us
they're going to be things that each of
us know or can do or like to do or have
or don't have right
ergo thinking about for example the
surfer girl who lost an arm to a shark
attack is she's still a person even
though she has only one arm and two legs
is she's still a person if she has no
arms and yet there are a lot of things
that she can't do she's still a person
see object modeling in this really
really strict type safe manner breaks
down at a certain point
every person has a first name in the
last name yeah
how about Bono
how about Sonny and Cher how about the
artist formerly known as Prince dude as
no name he has an icon
is he still a person he's more of a
person to Michael Jackson never was
right our modeling breaks down in weird
edge cases and so in some cases what we
want to do is we want to have a solid
core person has a first name last name
in an age but then maybe they also have
a does business as they have different
attributes which are not common across
all persons historically we've always
said those should be sub classes but sub
classes are a code time a developer time
construct and not all of those are
visible at the time that we model this
thing so occasionally what we want is
something that has a core set of data
but then also has some expansive
capabilities right so we can start we
can still say all right look this
Expando is actually something that
inherits from hashmap and well we still
have the casting problem here or you
know what what I'm gonna do is I'm going
to say that a person has a first name
last name at an age but in fact how the
person wants to represent their string
representation because I think if we go
back far enough Bono does have a first
name in the last name so maybe the way
we represent his name to the rest of the
world is different or the way he self
identifies is different so here what I'm
gonna do is I'm going to say that there
is another value on person called to
string imple and it is in fact a
function and that function is mutable so
we can plug in different representations
of how to generate this to string on an
instance by instance basis and we do so
by changing to string info to something
else and the default to string which the
rest of the framework is expected just
defers to that variable functional
behavior
in other words we can be static where we
need to be and dynamic where we want to
be which if you think about it makes
more sense than all static or all
dynamic the selfless trait so the idea
here is we want to be able to create
some services that people can just
consume but not necessarily having to do
so by being really really explicit and
and and and verbose about it so for
example we have this behavior called
greet to be friendly hi and we want this
to be something that anybody can do so
there's two ways to do this number one
we can extend the object friendly which
means we implicitly get the trait
friendly notice that the object and the
trait can have the same name this is
frequently done just because that way
they we don't consume more than one name
and so here example apple on extends
friendly but the other thing we can do
is because this is an object up here
object friendly it means that when we
import that object all of its methods
can be intrinsically statically imported
as well so that now I can say import
friendly dot underscore meaning that's
kind of like the static import in Java
grab all of the methods because again
there are no static since Scala
so grab all of the instance methods and
make them available as top-level symbols
so that now by importing friendly I can
just say greet
there is no intrinsic inheritance
relationship between example app 2 and
friendly other than the fact that I'm
just using the method defined in that
tree
but people can also import it directly
if they choose to if for example there
would be some sort of ambiguity conflict
because there's another class called
grumpy who also has a greet which isn't
quite as friendly okay
the drawback to the second approach is
it's not nearly as clear where greet
comes from because remember there may be
like 50 lines or 100 lines or 2,000
lines between the import and the actual
usage
so in that case doing the actual extends
can be a little bit easier making sense
so far okay two challenges in the zero
minutes I have left first challenge we
want to we want to create a lottery all
right you guys don't have a lot of works
you can choose numbers one to 49 and
then every week or so the random air
ball thing pops those numbers up you
know 5 6 7 whatever numbers but the key
thing is you never draw the same number
twice so this isn't just generating five
or six or seven random numbers it's
generating random numbers within a range
such that no duplicates will ever appear
that's the critical part of this so
write code to do this lotto thing
now just because we're short on time
I'll show you what the solution looks
like
in essence what I'm doing here is I'm
saying okay I want to be able to
randomly select this number of items
from this range right from 1 to whatever
that number is okay and I call random
select notice that random select
actually has a nested method inside of
it to do the actual work why because we
use that structural decomposition to say
hey I need six numbers out of this list
and what I want to do is I want to
generate a random number within that
range and pull that number out of the
list and then take that remaining list
and do the same thing again and again
and again and again and again until I
have my five six seven numbers whatever
so what we can see there is we do random
select and then we random select are
using that random object that's passed
in if the number that I need to get is
zero remember we have to have an exit
case so that's when we return nil and we
don't continue to recurs otherwise we
remove the number that was randomly
generated from the list and then put
that into a list of its own after
calling recursively into the same method
to generate the next number
you're in simple decompositional
recursion
given an XML document such as this give
me the total cost of these items okay
now one of the things this is a little
bit unfair because one of the things if
you're not familiar with Scala that you
don't know is that Scala has some built
in syntax for being able to consume XML
very easily and the best part of this
built in syntax is it's not really
built-in it's just a scholar library so
here when I've got this data equals
shopping item item shopping right that's
an XML literal what Scala understands
but then the rest of this is all just
straight library stuff you see here
where I do this for loop for item arrow
data back slash item the backslash there
is essentially a small XPath query and
that says give me the items that meet
this particular choir of XPath query so
it says give me all of the item notes
underneath whatever the current node is
so the current node is shopping so
therefore give me all the item nodes
under there then by the way for loops
aren't really loops in Scala they're
what are called comprehensions and
they're more like pipelines and so this
for loop takes the resulting items and
hands them to the next phrase here which
says price is equal to item backslash
the attribute priced dot text dot to
double
good so now I'm converting that price
into a double value and then grab the
quantity and yield the result price
times quantity now how exactly does this
work because essentially the
comprehension does one of two things
it's either a generator producing more
items to evaluate the final body against
or it's a filter saying this item can be
passed on to the next stage or it's not
so what this does is implicitly creates
a list we find first of all the two
items that have item there and each one
of those is going to get passed to price
which is going to produce the price
element and each one of those is going
to be pressed quantity which is going to
produce those quantity elements which
means by the way that now item price and
quantity are locals available inside the
body of the for loop where this body
consists of yield price times quantity
where the yield keyword basically says
hey return this but what we mean by that
is plug that into the list that will be
the result of this particular expression
the end
do that in Java i double-dog dare you
because it will not be pretty this is
these are some of the advantages that
Scala has over other languages okay
Scala is not perfect Scala has some
interesting quirks Scala has some ugly
quirks skull has some things that they
need to fix an error message coming out
of the Scala compiler can read about
like warren piece does in other words
completely aren't incomprehensible and
it goes on for days okay but for all of
that the reason they have those really
really nasty messages has everything to
do with the strong typing type system
category theory blah blah blah and the
scala guys notice martin has heard the
fact that his errors are
incomprehensible starting from about
scala 2.6 and they have been steadily
working to make them more comprehensible
but you also have to meet them halfway
and you can't just use scala like you
used Java or you're missing the point
you need to start thinking in that other
dimension you need to start thinking
about reusing behavior algorithms in
addition to trying to create these
vertical trees of classes that are
related in an inherent spaces couple of
resources for you there's 99 Scala
problems which are similar to the two
that I just showed you how do I solve
this this is what would look like in
Scala and by the way these are not right
you could maybe come up with a more
terse way of doing it and whether terse
is better or not that's an aesthetic
judgment right code that you wrote is
rememberable and discoverable by you
code that somebody else wrote is
sometimes to terse or too verbose let's
just call it an aesthetic and go from
there there's also language org which
has a number of similar problems but
they actually show how to solve them
across a variety of different languages
so if you want to compare Scala to
f-sharp - Haskell - lisp - closure -
java - c-sharp
you can do so
and if you have any questions I'll take
them outside because we are officially
done bye</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>