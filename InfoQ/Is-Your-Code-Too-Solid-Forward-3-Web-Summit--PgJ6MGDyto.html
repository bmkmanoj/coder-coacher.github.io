<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Is Your Code Too Solid? - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="Is Your Code Too Solid? - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Is Your Code Too Solid? - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-09-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-PgJ6MGDyto" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">can you hear me the back okay yep all
right awesome well good afternoon and
thank you for hanging in here till the
end I'm the only thing between you and a
drink right now and I'm very aware of
that and thank you also for adventuring
your way down to the basement this is a
bit of an odd room I wasn't sure if
anyone would show up give him the date
and the weirdness of the space but thank
you for coming I'm Sarah may I am the
chief consultant at dev mind I'm also
the founder of railsbridge and a
director of ruby central I live here
this picture was taken reasonably close
to my apartment in the city which looks
really awesome until you realize that
the other 364 days of the year a picture
taken from that spot looks like this so
that was our one nice day thank you very
much I'm a developer I do a lot of Ruby
and JavaScript I tend to work with teams
that are managing large code bases that
have become unwieldy and hard to change
sorry there we go this is a common
problem right now among all types of
developers I hear it from the Ruby and
JavaScript folks but I've also heard it
from the dotnet people in the Java
people and the PHP people and the CSS
people the Python people it's not a new
problem in our industry necessarily IBM
was having this problem in the 70s
there's lots of vaguely amusing at
academic literature you can read about
that but it's interesting that this is
again at the forefront of our collective
consciousness right now so one theory is
that code is easier to write than it
used to be right there was an explosion
of dynamic languages in the last ten
years but also new frameworks that
compiled languages usable functional
languages all this has made it easier to
generate code at volume you can achieve
a large unwieldy codebase faster than
ever before and perhaps even when you're
a small company right you don't have to
be the size of IBM to have IBM's
problems and a big unwieldy codebase
it's hard to change doesn't necessarily
mean that the team's failed at planning
code that's hard to change his built up
technical debt meaning they took faster
future development today
at the expense of code that's harder to
work with later and some teams make that
gamble deliberately as a strategy to
move faster particularly in the early
days of a company competitors that put
structures in place to support a large
code base in the future couldn't iterate
as quickly so sometimes technical debt
buys your continued existence as a
company and sometimes not planning ahead
is the only way to survive long enough
to wish you had so we should all be so
lucky to have these problems but once
you've survived then you have to do
something because working on these code
bases really isn't a whole lot of fun
the vast majority of developers though
do work in code bases like this we're
not creating new repos all the time
we're working in code bases that have
been around for a while we need to make
working in these fun if possible so some
teams attempt this maneuver with micro
services may have heard that buzz word
and that rant is another talk entirely
but I had to put in two slides I will
say one thing which is that a lot of
people that do microservices end up with
something like this
this is Aaron Patterson he is a core
contributor to Rails and Ruby he says to
be honest the main reasons i like
microservices that i feel like my method
calls are too fast and i would prefer to
throw in some latency turns out carving
services out of a monolith and carving
objects out of a large class with the
same skill if you haven't been doing
good object design in your main code
base then you don't know yet what
large-scale abstractions you need you
have a guess but you'll be wrong that's
part of the deal when you're wrong
inside of a single code base all you
have to do is adjust object boundaries
when you're wrong in a services cluster
you have to adjust service boundaries
which is a much more expensive way to
learn this skill so before making
microservices or doing a rewrite you
have to get better at object or any
design and i don't mean the top-down
figuring out everything in vance type
lying anyone can draw one of those
diagrams and it's usually a waste of
time instead you need to learn how to
refactor your way into good design and
if you don't develop that skill you'll
just end up with the same mess you had
before in different packages
so Aaron the previous tweet is actually
serious well as serious as Aaron ever
gets for this is a joke a joke account
that nevertheless tweets things that are
often more useful than actual thought
leaders so refactoring your way to good
design is not as shiny he's doing
microservices but from a cost
perspective it's much more responsible
plus you can still use find to replace
super awesome so not coincidentally I
suppose we've been seeing a resurgence
of interest in object-oriented
programming design in communities that
weren't that interested a few years ago
including the dynamic language
communities there's now lots of books
blog posts conference talks like this
one about software design this is the
best of the modern takes on object
design sandy meadow at this fantastic
book on understanding objects that I
highly recommend you read even if you're
not a ruby developer and do not intend
to be I love this book and all the blog
posts and all the conference talks but
for a long time I thought about a
problem which is that what I do in my
client work doesn't really look like
anything in here Sandy's book uses
example code being written from scratch
to show you how to put the right
boundaries around your objects and going
into a big large monolithic messy code
base where no one heated Sandy's advice
and moving things around doesn't seem a
lot like that at first it doesn't seem
like object-oriented design for a long
time i called it refactoring turns out
though software design and refactoring
are not separate ideas so I know that
seems a little odd let's define some
terms starting with software design now
i'm not talking about architecture or
systems just within a single code base
software design is really nothing more
than deciding how code is arranged many
people think the software design is
something completely separate from
programming but in reality when you're
programming even if you're not
consciously making any decisions you're
still doing design every time you put a
function in this object and not that one
you're due in design you can try to do
ahead of time some people do but the
vast majority of software design that's
done by developers in our industry is in
line and just like programming
you'll be bad at it at first but just
like programming you get better at
software design the more you practice so
let's be a little more specific and talk
about object oriented design which is
I'm going to give you a somewhat
unsatisfying answer is deciding how the
code will be arranged grouping related
functionality in objects this does not
sound anything like the Wikipedia
definition of object-oriented I'm which
is this planning a system of interacting
objects for the purpose of solving a
software problem there's nothing in my
definition about planning and that's on
purpose I don't think of software design
as a planning activity is something we
do in line in the process of programming
now this is not as you might have
guessed a common definition of option to
design but it's the difference between
how its taught especially in academia
and how it actually works on the ground
so let's talk a little bit about what
object-oriented ein is not object rory
design is not a language feature it's a
way of thinking you can write
object-oriented code in CSS you can
write it and see or in JavaScript or in
Java or in c-sharp languages that have
explicit syntax support for objects or
what you'll hear people call
object-oriented languages but this just
means languages in which it is more
convenient to make objects than other
languages best too long for Wikipedia
page title so I'll join in languages it
is up shorty design is a way of thinking
about code arrangement in some languages
it's easier to express than others but
it's possible anywhere you buy me a beer
and ask me about object design in
Haskell sometime object-oriented
destination it is a means to an end you
don't write object-oriented code for its
own sake or because it's somehow morally
or professionally better i'm shorry
design is not inherently better than any
other way of our ancient code is a means
strategy that we use mindfully to move
us towards some larger goal and for most
of us that goal is ease of change we
build software for people who don't
really know what they want they imagined
one thing then they change their mind
when they actually see it in action
or the business shifts focus or a key
person is replaced or it's Tuesday right
the only constant in software
development is that the end goal shifts
as we build it and I wouldn't do us any
good to wait because the act of building
is what causes it to shift and in theory
object right design makes it easier to
respond to shifting requirements and I
can say that sandy can say that but I've
been on projects now but most of you in
this room have been on projects where
code was parceled out into objects and
it made it harder to understand rather
than easier how does that happen does
that mean the higher concept of
object-oriented design it's a sham to
figure out how that happens we need to
take a step back and look at our goals
that we have when we're designing
software there are two useful axes to
consider when we're looking at different
ways to design software on the bottom we
have the cost of understanding the big
picture of your code lower hi how how
hard is it to figure out what's going on
and on the side we have the cost of
changing the code lower high and every
choice about how you arrange code every
choice about software design goes
somewhere in one of these quadrants so
let's place a few deaths let's start
with writing line procedures someone
does a get on / calendar to see their
calendar for the month and a procedure
is executed a list of instructions
determines the date range fetches events
within that range from the datastore
draws the right shaped grid puts the
events on the grid returns the page the
user it's pretty easy to understand what
happens in a procedure cost of
understanding is low everything that
happens is right there at an ordered
list and the trade-off in a large
project with a lot of long procedures is
that the cost of change is high the
biggest devil on the code base like that
is duplication right which forces you to
change multiple places in the code to
make a single logical change so
procedures blowing up here in the upper
left so some projects have it been
burned by the high cost of procedures go
completely in the other direction
everything's a tiny object that doesn't
do much when you do that get on /
calendar a route receiver picks up the
call which they increase a route
resolver to look at the URL figures out
that it needs a calendar route resolver
which it gets from the calendar resolver
factory and then the calendar route
resolver looks at what you're requesting
and
to get calendar index objects which then
sends your prams to a calendar / am
manager and so forth so the sequence of
events isn't written down anywhere in
the code you just have to trace through
it to figure out what's going on little
pieces of functionality are spread
across many classes assistant like this
is harder to understand than a procedure
make the cost of understanding is high a
list of instructions will always be
easier to understand than a set of
objects however once you understand the
system the cost of change is low
assuming you've got the right
abstractions which is the notion we'll
deal with in a moment it's relatively
easy to take for example one parameter
out and swap it another so a set of
small objects goes down here in the
lower right so let's talk now about code
that has both a high cost of
understanding and a high cost of change
worst of both worlds there are two types
of code bases here both of which are
distressingly common and the first is a
code base made up of really big objects
maybe the framework dictated an initial
set of classes and all the behavior just
sort of a created on to them since then
and a huge object oddly seem to be a
ones that are core to your application
right they changed with almost every
commit changes go wrong easily because
all that functionality in one place
means unintentional interference is
almost a given and the other type of
code basically find up here is small
objects gone wrong which is what happens
when you try to break down a big class
or extract procedures but you don't get
the object boundaries quite right then
it's both hard to understand because as
objects and hard to change because for
one logical change you still have to
make changes in a bunch of different
places so the wrong set of objects
really is the worst case scenario really
big objects are bad but they're not that
bad the wrong set of objects is worse so
there's two questions here the first is
how can we get here can we get here is
this the perfect solution that doesn't
exist and the second question is how do
we move our big lumbering code bases out
of the upper right and into anywhere
else it doesn't really matter where we
go any direction will be in
provement from here but usually when
code bases are this size reducing the
cost of change is worth increasing the
cost of comprehension so people want to
take it down to a set of small objects
and this is where they start reading
about things like solid and design
patterns hoping they can figure out how
to make this move so let's look at solid
for a moment and then we'll take a brief
look at design patterns solid sounds
super awesome right who doesn't want
solid code or to be a solid programmer
right there are very there are many many
object-oriented principles in the world
academia has been studying object
orientation for decades however
academics tend not to deal in volume of
code so most of the principles are
highly academic in the 90s Robert Martin
took the five principles that seemed to
him to be the most relevant to working
software developers and you put them
into this acronym so let's talk about
what each letter means I'll be filling
in this chart as we go we have three
columns name of the principal summary of
what it means not what it says but what
it means and then a measure of how
useful it will be in everyday
development start with S single
responsibility principle which is
usually stated as a class should have
one responsibility or to put it another
way one reason to change it was first
articulated by Rebecca woofs proc in the
80s and it's kind of a fancy way of
saying smaller things are easier to
understand and harder to mess up than
larger ones as far as utility goes it's
sort of in the middle the difficulty
here hinges on the definition of a
responsibility if you've got a class
that finds users persists users
validates users allows access to related
objects for users and contains business
logic for users you could plausibly say
it's got one responsibility it manages
the user however you could equally
plausibly say that all of those things
are separate responsibilities that all
belong in different classes and the
principal doesn't give you any guidance
on this because there is no universal
right answer sometimes it makes sense to
put all that stuff together sometimes it
doesn't and that shifts over time even
in the same codebase the answer to every
question in software development is it
depends o is for the open closed
principal this is usually stated as a
class should be open
to extension but close to modification
Bertram Meyer come up with us in the 80s
fancy way of saying that editing
existing code is more difficult and more
error-prone than just adding new code
right all right sure so you should
arrange your code base so that you can
add new functionality by just writing
new code without editing anything you
already have so that sounds great but
it's pretty hard to conceive of how this
could happen in a code base of
significant size it's pretty easy to
think about how it could happen in sort
of a test project a little bit of an
inheritance and magic fairy dust and so
on but in a cook piece of significant
size hard to imagine hard to imagine not
super practical day-to-day elva liskov
substitution principle this is probably
the most academic of all of the solid
principles it is a a precise
mathematical statement here it is let
theta X be a property provable about
objects X of type T then theta Y should
be true for objects y up type s where s
is a subtype of tea crystal clear this
is a fancy way of saying that anywhere
you can use an instance of class foo you
should be able to use an instance of
class bar that is a subclass of food
nothing should go wrong so the loose
cough substitution principle was
formulated by Barbara Liskov in the 80s
by the way when she was in her late 40s
don't ever let anyone tell you you're
too old to do something awesome the list
cough substitution principle basically
says inheritance this is a thing seems
pretty obvious to us at this point is it
but when I was first articulated it
wasn't really obvious at all it was such
a good idea since that since it was
introduced we have baked it into our
languages it's part of the air we
breathe we don't notice it anymore blue
sky substitution principle has had a
huge impact on the way we write software
which is I soon why Martin chose to
include it in solid certainly not
because he just needed an L however
while its fundamental it's not really a
good source of practical help day-to-day
utility is low let's look at I interface
segregation says the classes should only
have to depend on the part of an
interface they actually need makes a lot
of sense in compiled languages
show you how so let's say you've got a
class musician that has five methods
record song edit song mix song place
that list and sell merch so it has two
classes that consume it an album creator
and a gig and these use different sets
of methods that are not related to each
other so then you add another method
drive the van that is only used by gig
and you'd expect at this point right
that musician and gig have to be
recompiled in a compiled language
however it turns out that all consumers
of musician must be recompiled including
album creator which didn't change at all
so it was just to consumers who cares
right but if musician had hundreds of
consumers that had to be recompiled
every time you made any change you can
see how it's a huge pain makes rerunning
a test for one thing a very long process
to fix this intersect interface
segregation suggest you break musician
into two different parts studio action
venue action perhaps and that way when a
new add new methods added to venue
actions album creator does not need to
be recompiled so that's cool dynamic
languages don't really have this problem
the worst that has to happen is a reload
and it's a lot faster than any
compilation process would be however
interface segregation does have one
really useful core idea and that is that
if different consumers of a class use
non overlapping sets of methods that's a
sign that the class has multiple
responsibilities alright remember in s
we talked about the fact that very
difficult to tell what granularity you
need your responsibilities to be here's
a clue so I put its utility high
relative to the other principles we
looked at so finally d the dependency
inversion principle not dependency
injection although that is one
implementation of the principle so
dependency inversion says depend on
abstractions rather than concretions
which I'm sure is crystal clear which is
a fancy way of saying if you want to
make a new thing a new instance of
something inside of a inside of a
another class you could either just make
it there or you could pass it in and
these might not look like they're very
different but in the first example the
code has to know the name of the
constructor function it wants to call it
has a dependency on that name and in the
second case it doesn't you've mu
moved the dependency to the collar to
the creator of a student object so it
has the effect of moving all of your
choices about behavior to the edges of
your system which can be very useful so
there's lots of dependency injection
frameworks angular has one net java they
make it easier to test classes and given
that most of them have essentially
become gigantic global state sometimes a
bit difficult to tie them back to the
principal but dependency inversion does
seem to be theoretically something a lot
of people see it's all right utility hi
so now that we filled in our chart let's
look at it for a moment the solid
acronym has principles of vastly varying
degrees of utility or concreteness right
utility or immediate applicability code
you're writing day is one end of a
spectrum and the opposite ends
abstraction which describes a general
rule it sounds like a good idea but it's
hard to connect code you're looking at
in your editor so 0 and L with the most
abstract ind of the most concrete and s
sits in the middle so we've got at least
three different levels of abstraction at
work here and none of them not even the
eye or the D seem actually useful in
day-to-day operations in refactoring
code I mean it's nice to say I make the
API and an object small but that ship
has sailed for most of us so we need
some rules that are a little bit more
concrete to guide our everyday work in
these code bases it's not clear how to
find them so a lot of people turn to
design patterns let's talk about design
patterns for a moment a design pattern
is an example set of object boundaries
that seems to work well in many
situations I'll give you an example of
the pattern called the observer let's
say you have a user class and when a new
user is created it automatically sends
it an email to get them to confirm their
account normally this is fine if your
user class is small your object graph is
uncomplicated fine to leave this here
but a lot of times the user gets to be
one of the biggest classes in the system
and it can be annoying to have it send
email every time you want to make one
because you have to find ways to turn it
off when you're creating user in your
tests every test requires you to create
a user so you want to separate user
creation from email
things that it's easier to turn off so
you create a new class called user
observer there we go use your observer
and you move the email functionality in
there and you give it a set of creepy
googly eyes so that it can serve the
user and now when a new user is created
the user observer notices and it sends
the email for you so that's cool right
you've reduced the size of your user
class you've made it easier to turn off
email sending by just deactivating an
observer you've made the code easier to
change but you've also made it hard to
understand you used to only have to look
one place to see everything that
happened when a user was created it all
happened in the user class now you've
got two places to look because it's in a
separate class other people may not know
it exists let alone that they have to
turn it off and then be unpleasantly
surprised when the users they create get
email if you start out with a code base
here and you apply the observer pattern
just like we talked about you move it
down here that is the confounded face
emoji in case you were wondering you've
made it easier to change but you've made
it harder to understand many people read
about design patterns and start looking
for opportunities to apply them they
assume that making less structured code
into patterns is always a good idea but
it's not patterns are not a useful good
everything has a cost that's the hard
part right at what point does the lower
cost of change outweigh the higher cost
of understanding and that again is not a
question with a single answer it'll be
different in different parts of your
code it'd be different at different
times in the same part of your code so
the patterns give us more concrete ideas
about how to arrange code but they don't
tell us when to do it so we're still
missing something you still need one
more thing to help us figure out what to
do like when you sit down had a code
base and we're trying to work on a
feature what do we do to make it better
so here's an idea that might be useful
strategy and tactics are military
concepts I didn't grow up in a military
family so for a long time I pretty much
thought of these words as being the same
thing but they're not a strategy is a
high level objective that will move us
close
some goal a tactic is something you do
on the ground to achieve that strategy
so let me give you an example of how
these are different your goal is to be a
pro mountaineer your strategy is to
climb this mountain and not very many
people find before and you're starting
from the bottom and you can make it up
to the top so there's no trails need to
figure your own way up the strategy is
where you want to be at the end of the
day on top of the mountain and your
tactics or how you get their tactics
include planned route contingency plans
and your tactics or guided by and may be
changed by the strategy as you walk up
the mountain so possible routes include
walking along the treeline and going up
the right-hand ridge climbing this rock
face and then going up the left-hand
Ridge there's you know just straight
going for it that works too they all
involve different tactics I mean walking
versus climbing versus rappelling and
the actual route you take will depend on
the weather your skills your gear and
many other things once you do choose
around it's probably still not what's
going to actually happen you get to the
base the ridge you discover the
Avalanche has made it to perilous to go
up that way so you change tactics
because your strategy of climbing the
mountain is no longer in line with your
original tactics so part of your tactics
include determining when to change
tactics so what would happen if all we
have is a strategy all we know is okay
there's a mountain I need to get to the
top of it if you set out to achieve this
strategy without working on any of the
little steps you could take you to get
there it's not likely to work out for
you very well you make it to the top
accidentally but it's more likely that
you'll try a through fruitless paths
find yourself in a valley you can't get
out of and then have to signal the park
rangers to airlift you out so you need
to have tactics in mind or you probably
won't achieve your strategy our actual
goal is not being a pro mountaineer it's
changeable code that's the promise of
objects we want our code to be easy to
change one way to think about strategies
and tactics for changeable code is to
say that our strategy is obscuring
design our tactics would then be things
like solid and patterns and this is how
object oriented is top particularly in
academia and this is how most developers
look at
whether or not they can articulate that
for most people solid and patterns are
the tactics we use to achieve object
oriented ein there's a problem though
with this picture of the world and that
is that object oriented design isn't
actually a strategy remember our
strategy describes what we want our
world or in this case our code base to
look like at the end of the day an
object oriented doesn't really do that
by hand solid is reasonably good at
describing what our code base should
look like when it's finished single
responsibility principle for example
would make a great strategy it describes
a state of our code base in which there
was one responsibility at the right gun
molarity per class and if we had that
our code base would be more changeable
and open clothes describes this code
base utopia where you never have to edit
code to add features in fact all these
principles are at some level
descriptions of when you know your code
is right or done if your code were like
this it would be more changeable So
Solid is a great set of strategies our
problem is that we've been trying to use
them like tactics for example you can't
just apply the single responsibility
principle directly to a thousand line
class write a class like that has a
muddy set of abstraction spread across
multiple methods each that are hard to
distinguish and when you squint at the
class and sort of envision how you'd
break it up you're most likely going to
be wrong the abstractions are hard to
see by definition because if they
weren't you'd have done something about
it already so trying to eyeball a large
class and sort of see what the right at
attractions are is like trying to head
towards the summit without planning a
route ahead of time but we do this a lot
I've been on many teams where some class
some object is too big too frustrating
to work with so we'd schedule a week to
refactor it and we spend that week sort
of just eyeball in the class trying to
surface the right abstractions I think
about these as stop the world
refactorings and you shouldn't do them
but what's wrong what's wrong with this
what's wrong with a stop the world
refactoring right refactorings part of
being a good software engineer right
taking time to clean up and make the
code better is important right
two interesting things happen when you
stop the world to refactor and the first
one is the product team is really
unhappy you're taking a whole week off
from their perspective meaning you're
not working on anything they can see and
the second thing is because your time
limited you feel pressure at the end of
the week to break that class up somehow
even if you're not entirely sure yet
what the right bounders are now both of
these are bad maintaining trust with a
product team is one of the most
important parts of your job you can only
tell them good software engineering
practice so many times before they start
wondering why with all of this good as
software engineering practice we aren't
getting features done more quickly and
rushing through a refactor is exactly
how you end up here the only way to make
a stop the world refactoring work is to
not do it like global thermonuclear war
right the only winning move is not to
play when we apply these strategies as
though we're tactics we end up with
these ham-handed mostly unplanned
unpopular changes that just leave us in
a worse place than before we're doing
this it's frustrating you ever wonder
why a lot of good developers who started
out in an object-oriented returning to
functional programming certainly novelty
as part of it but if you read some of
the stuff that they write it's a there's
a strong undercurrent of fundamental
criticism of oh right they say it just
doesn't work what they're actually
saying is there's a summit here and they
can see it and it seems like they should
be able to get there but they can't so
what we're missing is tactics that get
us up there and explicit small steps we
need things we can do every day as we're
doing feature work to inline that
refactoring time and allow the right
objects to emerge from the mess over
time patterns are part of our tactics
but they're not everything we need right
all a we talked about the fact that
patterns don't tell you when is the
right time to apply them if we set off
with only patterns is our tactics like
telling the mountaineer all right here's
your tactics you climb an ice wall like
this you scale a cliff like this here's
how you edge along a shelf right here's
how you scrabble over loose rock all
right go have a good time and there's a
lot of skill involved in climbing ice
wall but the real skill lies in knowing
when to do it
and when not to when you come to the ice
wall should you climb it or should you
look for a way around so when you see
code you could change should you change
it this is our missing piece we have
solid we have patterns and now we need
guidelines so I got six of them for you
I made my own acronym I figure if it
worked for solid and work for me stable
this mountain is solid which is cool but
when I'm trying to get up at what I
actually needed stability right I want
it to you for example not be a volcano
not a flanch out from under my feet not
drop boulders on me right I needed to be
solid sure but at a motor immediate
level when I'm making my way on the
ground I need stability and the same is
true of my code base I want it to
conform to all the solid principles that
would be great however what I really
need is to know that if I make a change
in one part of the code it won't cause
an avalanche on the other side of the
mountain so let's go through these
tactics s smell your code but this means
is to study code smells on other don'ts
right we've got lots of don'ts code
smells are a list of common problems in
code Martin Fowler's book refactoring is
fabulous for these I worked with the
team that would pick one code smell each
week and spend one lunchtime sort of
looking at it and trying to find
examples in their code and the reason
you do this is you want to start
noticing and naming the problems in your
code even though you won't be fixing
them all yet t is for tiny problems
first in messy code there will be a lot
of smells fell overlap though
intertwined they'll interfere with each
other they'll be hard to see what you
should make with all of this mess so the
best way to get started is to pick a
really small problem that you know how
to solve in a very concrete way and just
fix that for example rename a variable
whose usage has diverged from its name
pick the smallest problem to fix even
though you see enough of the bigger
problems to start guessing their answers
your goal is to see the larger problems
better by clearing away the small
problems that obscure them the more
information you gather about these
larger problems the more likely the
eventual abstractions will be right
proper abstractions are worth waiting
for let them emerge from the code you
have by clearing away the easy craft
a sense where augment your tests you
will almost certainly have to do this to
be able to reflect your large classes
you need integration tests one level
higher than the class you're working on
and need these in place before you start
doing any of this right so if you were
in a server-side MVC application if you
want to refactor it be control or you'll
need view level integration tests if you
want to refactor a big model you need
controller level integration tests
because you want to test behavior rather
than implementation right that's why you
go one level up you need to test that
describe the behavior you want to keep
and this may mean getting rid of some
lower down unit tests or writing new
tests a level you haven't had been
before be back up when it's useful when
the code has an abstraction in it that
is no longer serving you well when you
have objects that don't seem like the
quite the right thing sometimes the most
useful thing to do is rewind the code
put all that duplication back make it
back into a procedure and start looking
at it again it is much much harder to
move from a much easier rather to move
from a procedure to the right set of
objects than it is to move from the
wrong set to the right set so don't get
caught by the sunk cost fallacy don't
forge ahead with a set of objects that
don't even fit now let alone in the
future L is for leave it better than you
found it during any one expedition into
the code add the feature fix a bug you
won't be able to fix all the problems
you see can't hug every cat right and
there's our meme from 2010 for today
sometimes the only thing you can do
alongside your stated goal is rename a
method so it describes this behavior
better and that action seems really
small and our instinct is to save a
bunch of those up and do them once but
don't give in to that stuff the Royal
temptation fix one thing the smallest
thing while you're working on a story
that concerns that code I was a Girl
Scout back in the day one of our rules
was when we were out camping that we
will always leave a campsite in better
shape than when we arrived and over time
this made a better experience for
everyone including ourselves so
partially selfish if you change that one
method name you're removing a little
piece of cognitive dissonance from your
code the next person to come through
this code will be able to understand it
a little more easily maybe the big
abstraction will suddenly be obvious or
maybe they'll just fix the next smallest
thing the key inside is a little
things add up over time finally II
expect good reasons assume past
developers had good reasons to write the
code they did some code looks cool so
horrible and I think what idiot wrote
this why would anyone ever do it this
way and then I run get blame and find
out it was being six months ago or it
was one of the developers I really
admire right there forces at work on the
code beyond developer experience and
skill deadlines relationships other
groups like product QA operations
company financial situation all of these
and many others leave their fingerprints
on the code base so if you start
thinking about the social pressures that
affect your code base many other things
will make a lot more sense so here we go
these are tiny things you can do to
inline refactor large classes as you're
making progress on features you don't
have to stop the world you can rebuild
trust with your product team and as a
bonus you're much more likely to end up
with the abstractions that you want now
this is a cycle is something not
something you do once you keep fixing
the small problems in the solution so
the large ones become obvious so now
that we've got our our how our patterns
right and we've got our when which is
our stable look there we go is the wrong
order and we've got our wet which is
solid and we've got our y which is our
changeable code and all we're missing is
who the answer is everybody everyone on
your team should be doing this you might
ask don't you still to say it stop the
world sometimes I know I have to go
through them again so right i like that
transition to zoom all right don't
yourself to stop the world sometimes
because after all once you've cleaned up
enough the small problems to see a
solution to a larger problem you still
do actually have to solve the larger
problem Kent Beck has a really
interesting way of talking about this
for each desired change make the change
easy warning this may be hard then make
the easy change when you remove the
small problems the big problems become
obvious and they become much easier
because you've amortize the cost spent
fixing the big problems and as
you end up with a higher quality
solution that when you see it will look
in retrospect really really obvious
Kent's warning is important here though
this may be hard the stable cycle won't
always prevent you from extracting the
wrong objects or trying to fix that
doesn't work you'll still have to ghost
down some paths that lead to dead ends
but on this process that's expected back
up and try another and that's why backup
is one of the essential steps in this
process for this time we aren't just
wandering aimlessly like we were back
here we're moving tactically we're
following steps that we know will get us
there even if the final shape of the
journey doesn't look anything like with
what we thought it would when we started
work on making your code stable and it
will eventually be solid you can get to
the top you can be the success story
just make sure you head up with a plan
thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>