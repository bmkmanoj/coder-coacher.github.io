<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Mastering C2DM: The Android Cloud to Device Messaging Framework | Coder Coacher - Coaching Coders</title><meta content="Mastering C2DM: The Android Cloud to Device Messaging Framework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Mastering C2DM: The Android Cloud to Device Messaging Framework</b></h2><h5 class="post__date">2011-03-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/51F5LWzJqjg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everyone welcome to the mastering
c2dm or the Android closet device
messaging framework my name is Alexander
garganta I work for a company called
marna here in San Francisco well here I
guess close enough as I said if you'd
like to access the slides including the
example code that I'll be showing you
later on it's available at that URL you
can also scan the QR code if you'd like
so let me just see how this works I've
never actually used Google Docs
representations so how do you actually
advance to the next slide is interesting
oh there we go
okay so just a few words about myself
I've been doing Jolla since 96 Android I
guess for the last two years I so
Marikana the company worked for his
defect focuses in training a specific
local store software so do I teach among
other things Android and Java I happen
to run the Java user group in San
Francisco as well as the Android user
group and I'm co-founder Eric organizers
of the html5 user group so here in San
Francisco we do a lot of events if any
of you are interested in learning more
about these things they highly recommend
you check out some of the videos we have
posted from our events from all these
user groups on we're kind of the calm
slash tech TV in the past life have
worked on things like SMS web push MMS
things that involve push technologies if
you will so as far as the outline so
what the goal is for today although to
be honest it's my first time teaching or
demo in this particular we're going over
this particular talk so hopefully we'll
get to everything there's a lot to cover
but the outline for today is to discuss
push versus pull or pull verse to push
discuss see to the end what it is even
talk about some of the other you know
non c2dm
options you may have go over the
requirements limitations get a sense of
what the big picture is
you know figure out how it works talk
about the implementations so both room
you know signing up for an account
you know subscribing to for registering
your app for c2dm you know your your
talk about the app server and things you
need to do on the app server the you
know additional features of c2dm such as
collapse keys the annotation and then
summarize everything and give you
hopefully guys some time to ask
questions okay as far as the assumptions
that make up of you know of you your you
know the audience is I hope you all know
Java I hope you have some experience
building Android apps it certainly helps
if you know what broadcast receivers are
what ANR's
are how to avoid them why you we need to
avoid them what services are if you work
with not use the intent services that
much better if you know what permissions
at least get a sense for what the
security model is on Android wakelocks
now if you haven't used in don't worry
we'll explain it and you know if you
have some basic understanding of HTTP so
you know when I say you know post this
HTTP with some parameters and request
yeah there's hopefully you know what
that means if you don't it's not that
hard to figure out their libraries that
they'll do it for you
the back the back end of of the demo
application which I hope we'll be able
to get working is actually built in PHP
not my first choice but just because of
the you know in framework that we were
using on the server-side just an it to
be what I used so if you know a little
bit of PHP helps if you don't don't
worry it's all conceptual laughter
anyways so as far as the kind of just
some of the acknowledgments a lot of
them a lot of what I'm gonna say has
been said before okay so hopefully you
know will dig a little deeper but
they're really good resources and c2dm
specifically from google they did a talk
on at last at last Google i/o so in the
video of it is available online slides
they are available online and then
there's a see to the end page a coda
Google complex Android /t to the end
that has really good resources can they
give you kind of the steps you need to
go through so that's you know that's
where I effectively learned everything
from but you know
differences if you've seen these things
if you very well gone through these
things that in this talk hopefully we'll
be able to dig a little deeper can
actually go and walk through the code so
that said why do we care about this what
you know what's the big wide behind it
at the end and again some of this
information comes directly from actually
the the video from last Google from from
c2dm talked with Google IO so basically
the requirement is hopefully is to build
apps that allow you know the data on the
apps to be kept fresh right so basically
we want to you know keep apps synced
with the cloud yet we don't want to
drain the users battery now normally how
we tended to do things especially
because the android supports background
services is we would you know build some
kind of a background services and
potentially do you know polling that's
okay when content changes very
frequently and when we're okay to have
somewhat stale data meaning you know if
we if you don't 4-pole frequently enough
and data changes in the server we don't
yet think it we're tolerant of that but
you know or actually before we get to
the but you know one of the things we
should try to do if we do have to do
this is to do the check for freshness of
the server side so the client meaning
our Android application assuming we're
you know syncing with the cloud through
HTTP which tends to be what most people
use these days is we should submit for
example you know request with if
modified since we put you know the last
time stamp of what in the last last time
we fetch the data and the server decides
on you know whether the data is new or
not and gives us only the new data as
opposed to us needlessly downloading
data you know and then throwing away
stuff that we've already seen before so
we want to minimize the amount of work
we have to do in a poll if we decide to
do polling in the first place that said
we want to poison-free is as
infrequently as possible of course that
up you know the frequency of polling
affects the freshness of the data the
reason why is and again this these
numbers come right from from that
presentation is you know when your
device is idle the your baseband modem
is connected to the network but you know
it's
something like five to eight milliamps
in a pole even in a shortfall which by
the way even if you do a very very short
pole the radio stays on for a few more
seconds you've been looking at you know
115 for reading and at about 200
milliamps for transmitting data
depending on what you need to do so
basically it works out to roughly about
you know 0.5 million powers you know if
you do it every five minutes you can
kind of see that's around 144 million
hours for example in a day and you could
imagine that that's you know roughly 10%
of your battery for just one application
if you obviously increase the or
decrease the frequency so you do it like
every 15 minutes that obviously changes
but still you know it the more
applications user run on their phones
and a lot of applications want to keep
things fresh the you know the harder it
is to or the more strain we put on the
battery okay so since full poling sucks
in general what can we do is that so
push is obviously you know the the
logical answer and you know the idea
with Portia's we get the upper the
freshness of our data but you know we
don't put a strain on the battery or at
least you know just the battery and
network utilization corresponds to you
know how how basically frequently our
data changes rather than how frequently
we call for data changes although that
even can you know be affected with c2dm
is we will explain later
so one you know one options for one of
the options for for doing a simple
Porsche is to do it voice you know SMS
you could basically you know get an
account with something like click at L
or one of those SMS providers you send
an SMS you know from your server to the
app the app intercepts the SMS
interprets it as a notification of some
some interesting event and then goes
through server to fetch data okay we
could do whack push although to be
honest I've never actually use web push
on an Android device I've used it before
hated it but we'll explain a you know
how it differs but it's basically just
SMS okay it's still based on SMS another
option we have is to get up you know
build a persistent connection with our
server when I say persistent that sounds
like it's expensive but it
realities is a packet-switched if you're
not using the connection the radio can
actually you know go into the somewhat
idle mode so it's not really drawing the
power and Android allows this fairly
easily by you know effectively allowing
us to build a background service that
creates a connection to our server and
then needs to react to all these network
changes and because of the fact that the
connector extend to be flaky and
especially as you switch from different
modes right
this background service would need to
you know effectively have the logic to
recover from drop connections to do to
detect these half-open connections
because you know in between us and our
server there are all these potential you
know whether they're firewalls NAT NAT
switches or whatever network gear that
just doesn't like effectively persist
persistent connections and thanks to
closed them right so generally what that
would involve is us having some kind of
you know periodic checks to ensure that
the connections are ok so that usually
is done with pings right so things in
acts which kind of looks like polling
but you know there's not much you can do
about it it's you know we but it still
gives you that persistent connection and
then when the server wants to inform you
of some event they just use that
connection with your device they drop a
message you get it and you react to it
so this is doable but it's not trivial
again and what sucks about it is and you
will see in a moment is if every
application were to do this there will
be a lot of overhead right versus using
a single framework that everyone can you
know take advantage of and then the last
option which is hopefully why you guys
are here is the c2dm
which is basically you know it is
persistent connection but since you know
actually Google matters everything for
us it's already being used by Google for
the google apps that we most of us have
on the on the on the devices and it's
super easy and it's free ok so it feels
like a no-brainer now we'll see kind of
the the differences between these
approaches so just just for the sake of
you know I guess completeness if you
were to go and do an SMS based
notification you could build some kind
of application that has a broadcast
receiver which reacts to the SMS
received message for that you need the
receive SMS
and one of the other things that did
here is they make my restless receiver I
change the priority of it okay the
reason why I change the priority of it
is because the SMS received
notifications brought key
simplifications are actually sent as a
ordered broadcast which means that
they're always sent in a predetermined
sequence of the priority all the
different receivers interested in this
okay so if I were to build the Java you
know the Java side of it is that I could
build it in this way so it would
basically be some kind of receiver that
would on receive off my SMS receive
notification go through or grab this you
know pods or you know PDUs effectively
extra interpreters a byte array parse it
into an SMS message decide whether this
SMS message is you know whether it means
it's a notification how we can decide it
we can say for example is it from a
particular number or does the body of
the SMS equal some pre predetermined
string or whatever right and then if it
is we could basically process that the
notification whatever that means for us
and then we can simply call a board
broadcast which means that nobody else
would get SMS message and if we were the
first ones to run you know then we're
the only ones to consume that SMS
message and you know it's not like it's
gonna show up in your you know SMS you
know message queue or whatever yeah but
this will cost money so it's not ideal
again a web Porsche is a more structured
way to do notifications but it involves
a huge amount of well first of all it
requires do you understand whack push
and there's like they have a special you
know format of the messaging to use but
effectively with that push it's a binary
SMS with a URL embedded in it which you
know tells your application or you know
that you should go and fetch the data
from some location okay effectively
that's that's what we are want to have
right ideally the notification is just
to tickle application to get it to do
something again this I get I am I just
copy paste is throw it from Wikipedia
but needless to say the whole point is
that this is complicated now that's not
to say once we see the c2dm diagram
things are gonna be super simple but at
least once you understand the most of it
is taking
here whereas you'll really only focus
the only one part of that dagger they
will see you later but there's too much
too much over too much work here and it
still cost this money so if we were to
roll our own connection or our own
persistent connection as I mentioned we
could build a background service we
could use an alarm manager on Android to
periodically wake us up well we you know
we could then check on the health of the
connection we could grab a wake lock in
order to reconnect because that may be a
longer you know longer operation we
would need to handle you know things
like network changes or the user
deciding not to support background data
or user roaming all these different
things that could happen on the device
and we still have to decide how often do
we check for the scalp of this
connection which is you know again that
involves pulling and pulling as we know
drains battery so we want to do it as it
frequently as possible but if we if we
do it super infrequently to you know to
maximize the battery we basically risk
not detecting when the connection is
dead and missing some push notifications
right and because presumably all of our
users which we hope we have millions of
would have these persistent connections
to our servers and as you as you know
there's a limit as to how many
connections you know machines tend to
like you know that tend to accept that
it means that we need to figure out how
to scale or you know back in
infrastructure to support all these
connections okay so it just means again
more work for us and what if there
multiple applications on these devices
right or in you know what if every
single one of them were to roll their
own are they all gonna go and do a
background service are they all gonna
wake up the radio to test for the health
of the connection how is that gonna
affect or better we can be very well
back to square one you know which is
kind of what we will happen with
multiple applications doing their own
poll right so this while possible it's
not you know it's not recommended just
because it involves more a lot of work
and a lot of overhead and it puts a
strain on your server side so see to the
end hopefully this is why you guys are
here so basically the idea is Google
already has a persistent connection it's
a TCP it's an SSL encrypted
GIP connection between your phone and
the Google servers at all times and it's
all right there okay why is it already
there all of the Google apps already use
it so market gmail calendar contacts
voice all of this you know all of for
example you get an SMS or get a you no
matter a message or let's say a gene a
new Gmail you know email comes in you
get notified through through that push
you wanna for example go to market or
Android comm you select an app you want
to install you say push to my phone how
does the push work through that
persistent connection voice you get an
you know a voice message that's pushed
through the connection thankfully
everything goes over that one single
connection and it's already there again
so effectively you know what c2dm is is
what we just discussed before of having
that persistent connection but we are
not doing any of any of the work Google
is doing it for us or actually letting
us use what they've already built okay
so there is some polling involved I'm
just I'll get to you but that polling
basically you know is being done by
Google anyways we're ready paying the
penalty of it if you will and as you
will see you later it's not actually
that big of a penalty so why not take
advantage it so please go ahead so
that's a good point and we'll come back
to that's that's gonna come in our next
car next couple slides on you know the
limited requirements of limitations but
you're right okay which is not that big
of a deal in most cases but nevertheless
is it is a potential limitation okay so
how did you know so exactly you know
what is then see to the end effectively
the way I see it it's a lightweight
messaging framework plus a service that
provides that push functionality off so
basically we can we what it gives us is
ability to push our messages from our
servers via Google servers to our apps
running on our users devices okay that's
what it is it's way more efficient
because we basically piggyback and
what's already there and you know Google
takes care of all of the hard work the
Message Queuing for example if our
device is not online and being able to
deliver the message later on you know
doing the best effort delivery
so you know they'll keep the message for
you know fairly a long time retry and so
on and so on and they already do the
hard work of verifying to the connection
between us and Google or our devices and
Google is already there but one thing
you need to realize is that the idea the
intent of the c2dm is not to deliver
content to your devices but rather to
wake up your device informative some
event and have your device fetch content
because of the fact that you know your
your messages may be delivered out of
order and that its best effort but not
guarantee delivery you generally don't
want to have any stay to the message you
generally don't want to have too much
data in the message or all they're
really limited actually in how much data
you can have and we'll talk about that
in a moment
you generally want to use these push
messages as you will see just to tickle
your application how your application
wake up and then do something in
response to that okay
so what are the requirements in the
limitations so first and foremost you
need Froyo or you know Android API 8 2.2
or better which you know sucks for some
of you that are still on to you know
Eclair you do need a market app on the
device
okay now the your abs don't have to be
installed through market they can be
side loaded okay they don't have to
actually come from market but there
needs to be market and it has to be
provisioned with at least one Google
account again now you before you say
well that sucks which you know is a fair
point it's okay because majority I don't
know the statistic but majority of our
users to use market and do have accounts
provision with Google okay well they may
not uses the primary account but they
use it as a way of installing apps yes
there's some that don't and yes you may
not be able to target your entire user
population but then again are those
users the ones you want to target in the
first place but that's just a side note
all the emulator in order to test this
you to actually test it to the end you
need to build a an emulator based on the
Google API is eight image so you do not
be and the vanilla Android image will
not do okay
you need to provision at least one who
will account can again do you don't have
your you're actually not gonna have
market on the emulator but you have the
services that are basically provided do
you think that includes you to the end
as well as that account which is
actually going to be able to how Google
manages that connection okay now as far
as the limitations so again best step
for delivery so alright your our
messages can get lost our messages can
be delivered out of order so for example
if you were building a chat application
as google says in their website you
would have delivered the actual chat
message via the push because they need
to let it be delivered out of order or
they may not be delivered at all so you
do is your tickle the application have
duplication go to your server and fetch
the latest chat history as an example
okay just because of how this you know
what what promises they effectively
offer is part of C to the N the payload
of our data that we embed in the message
that we push through C to the end makes
it under the device is 1024 bytes not
that we ever expect you to be putting or
not we who will expect you to be putting
that much data into the message in the
first place there's no support currently
40 TLS you can't say oh I want my
message to auto expire in two minutes if
the device isn't online Google tends to
keep the message or to try the mental
message delivery for weeks to up to a
month
they're they don't Devon necessarily
stated what the number is but it's an
order of weeks before they probably just
discard it okay but chances are you know
at that point you know maybe it's no
longer relevant anyways the biggest I
would say limitation that I see is the
fact that this is still in labs so it's
still a Google Apps project they said
that they were gonna release it to form
you know general use at the end of last
year hasn't yet happened I reached out
to Google ask them when it's gonna
happen still haven't heard back so it's
it's kind of effectively the reason why
this sucks is with two for two reasons
one is you first need to apply for a for
a c2dm account so you need to be
approved they tend to prove most people
I don't exactly what the approval
process looks like they haven't you know
been very upfront about it but it's not
that hard to get approved okay then what
you need to do
the other issue is that the quarter
quarter limits are not quite clear yet
right so what they do is they post
quarter limits on how many of your
messages you can send in aggregate and
also how many messages you can send to
one particular app on a particular
device that are given given time again
what yes you need to be you need to
effectively the way works is you get you
sign up and you will talk about that
process you get a developer account and
then when you're ready to actually go
primetime you you contact them and you
tell them hey this is what I build this
is what I expect can you you know
effectively ask them politely to give
you you know the the quarter limits you
expect you're gonna need okay and so
it's somewhat informal someone you know
undocumented if you will so there's a so
you know some of our risk as to whether
or not you'll be approved you may need
to talk to them ahead of time before
you're gonna invest heavily in this but
that's a good very that's a good point
so well but it has to do with also how
you build step four which we'll get to
because if you cash your auth token long
enough so you don't have to free that
frequently go and grab it then you may
not be prompted for captures change has
to do with whether they expect they're
too many logins whether they see too
many logins so let's take a look at the
big picture cam so yes it's quite quite
you know quite a few steps involved
there's ten of them and in fact there
some of them have you know kind of inner
steps if you will but most of these
steps you only have to go through once
ok and the rest you know most of the
other steps you know tend to happen at
least you know almost half of the head
things will happen by Google so they're
out of our hands anyways so the way
works and we'll go to these things and
actually look at the code in detail the
way it works is you first the step
number zero is basically us getting a
registry for account signing up for a
c2dm account so we get white list okay
so assuming we have that and we when we
do that we also you will see you provide
some kind of an email address okay they
call it the sender in my email address
okay what you then do is you build an
application which uses see to the end
that application when it gets installed
on the device
and the user for example selects you
know a checkbox that says I want to keep
my application up to date or in sync or
whatever you however you build it the
application will go and register for
c2dm it does so by invoking an internal
local service and - it passes this
sender account this special account that
Google approved on it for you okay what
you then do is you send it out to Google
that somehow communicates with the
Google c2dm servers what you get back is
some kind of a registration ID that
registration ID is unique for that
particular app on that particular device
right so you may have millions of
installations of your app and every
installation is going to have a separate
registration ID okay we then do is you
send the registration ID so step number
two you say the registration ID to your
server from where you'll be doing the
push can so I'm assuming you guys
understand that you know push involves
having some kind of a server component
otherwise what exactly we're pushing
right so we push it to our server when
our server goes grabs the registration
ID and records it on the server side now
we can record a registration ID for the
user right now if we have a concept of a
user on the device or we can record
their registration ID for that
particular device okay if we know of
that particular device so that we can
target that particular device or that
particular user in the future what we
then do when it comes time to actually
send a message to our to our app is we
go and talk to something called Google
client login service it's something it's
basically a Google authentication
mechanism that is not tied to c2dm it's
used by other services that basically
you know the Google has and the way it
works is you send aid as you will see an
HTTP POST message to this T to this
client login service and in it you
include the type of the service you're
trying to authenticate for which is the
C to the N the the username which is or
email which is basically the email that
was used when registering for the
account here and your
password and what you get back if the
authentication is valid you get back
some kind of an auth token now you're
supposed to remember that also Qian on
the server side you're not supposed to
constantly go and Rio tentacle because
if you do then Google this client login
service as you pointed out Frank it can
basically go and ask you to can prompt
you one of those whatever capture
challenges right and so then you know
how the heck do you do it because it's
all supposed to be automated you can't
really do CAPTCHA on a server which
there's no human to actually prove that
you know it's you because this role
account that we use it's not really
meant to be tied to a human anyways it's
basically one of these just you know
unroll account it's basically an app
account you can't really because you
know unless you you know you have
connection with the spammers they know
how to get around it public mailbox is
like 30 people on it and then someone
has to jump in and log in quickly or you
hire an army like you hire an army of
offshore you know cops are my solvers
exactly no generally the reason why you
have get it is because the client login
service you know effectively checks on
the on the frequency of your logins so
you're supposed to cache the token and
not and use it as long as you can as
long as the c2dm as long as the next
step doesn't fail if only the next step
fails with a 401 as you will see then
you go back and reopen ticket that way
you will most likely not get prompted
yeah now now do we have that token from
Google we now go to factory push your
message as you will see our message is
gonna be a simple HTTP post that post is
going to include the registration ID
which allows us to target a particular
device or app on a particular device as
well as the data that we want to put in
as well as this this auth token which we
got from the client service now this
auth token is tied to a particular
account that was used to register or an
air creator registration a key D in the
first place so if the two don't match
you
that's gonna fail yeah so the c2dm front
end once it gets our post okay it goes
and verifies you know that we are you
know authentic so verifies our your
token it then goes and effectively does
two things it to use our message into
some kind of a message queue so if you
know the next steps were to fail the
message we would be persistent right so
it tries to you know for recovery
purposes and it then tries to find the
actual c2dm messaging excuse me a
messaging server which is tied to our
particular application okay or our
particular devices would say because the
messaging the connection is not for just
our applications for all applications on
the device and still rouse the message
to that server now that server goes
through a logic of deciding whether the
message should be sent right away or
whether it should be delayed they will
see you know see how that works later
but at some point hopefully right away
it goes and grabs the message and pushes
it over that persistent connection to
our application our application now gets
thick you know gets tickled through
effectively a broadcast message we then
wake up if we do something it's not
trivial we're generally going to grab a
wakelock we start some kind of you know
intense service we'll talk about that
and we'll show some code and then we go
and do the work right so we do for
example generally generally one of the
things that's you know missing here is
we generally go and go back to our
server to fetch the data that we're so
interested in okay assuming that this is
just to inform us that something changed
upon successful receipt of the message
by the device there's an act that goes
back over the same connection to the
Google server the Google messaging
server then you know now I knows the
message was delivered it removes it from
the queue in case this connection is
severed like for whatever reason you
know if this doesn't work then basically
the message stays in the queue and you
know it really tries again later so
we'll see how that works now we're gonna
go through these steps one by one are
there any specific questions with this
so how do you know whether this is
working right so so the quiet I mean I
guess another way to look at it is there
an end-to-end
you know app and the way it works is
really the way you build your it's you
build it into the logic of your
application so the idea is you're your
server pushes the message and then this
if somehow hopefully makes its way to
your app if if your app gets it which
involves potentially refreshing the data
your app can go back to your server to
fetch the data at that point if you
include some kind of a token that's
unique to that particular notification
your server knows that that message was
received and if it wasn't it can retrial
automatically later as an exempt so that
would be like you know your end to end
you know
verification the message was received I
don't have that answers your question
so the we're gonna go into the details
of these particular steps but just as a
big-picture are there any questions now
yes this has to be exactly the same
email addresses the one you use when you
sign up for accounts so the step zero is
sign up for an account and you can you
provide an email address that's correct
and you for example the app that that
yeah I'm gonna demo you know what we do
is we make that email address be
configurable on the server so step zero
really for us is go to our server fetch
that email address so that our app is
not you know the I in email address is
not burnt into the app no it doesn't go
to everybody so the idea here you this
this is a point-to-point notification
system me or quite guess point you know
one to many but it's one to one at a
time right so you can't actually send
notification to everyone from either end
when you you and you send your
notification you target a specific
registration ID which targets a specific
application on a specific device yes
which is kind of like I said you know
that's what we have we built it like so
I'll show you like you can so the the
email the registries so you're asking a
registration ID or registration email
right so like I said you know our our
app the one the one that I'll show you
doesn't actually have the registration
email built into the app what we
do is we their server like our app
doesn't HTTP GET on the server to get a
registration email and then uses it to
register for c2dm surely it's you know
it's configurable well you could have
you could have multiple registrations
with Google and each app could have a
different registration email tied to it
if you wanted right so like so if you
wanted to if you're affected by
effectively the quota limits right so
you can sure you can certainly you can
certainly do that okay so you register I
mean you could potentially register for
multiple email addresses and you know
you you spread them across even the same
installation yeah I don't know how
Google will look at that so that is a
good question and this is somewhat
something that they're somewhat unclear
with as to how they enforce the limits
are they able you know are you able to
have multiple registrations on
effectively the same package ID yes yeah
and right so I mean you could
potentially release it like if this is
you know could release your app multiple
times or something like you could have a
customer specific app so as long as your
package name differs you're good but
that's potentially an option so again
this is the part it sucks and this is
the part unfortunately as much as I
would like to give you answers on it's
really it's a Google run service and
they haven't been very upfront and clear
with housing for these sorts of
limitations right so that's a good point
and thank you for mentioning that so if
your app gets uninstalled the under the
app is automatically unregistered from
this side right so c2dm knows to refuse
future submissions from our server for
that registration ID and our server is
supposed to basically you know get it
gets an error code that says hey this
registration IDs invalid so that point
the server should be provision the
registration ID it has internally saved
for that particular installation right
right right of course of course yes
although generally if you know if we are
on you know if we're online and we on
register or app or maybe we're as we
come online we may get all these
messages before we get a chance to
unregister
so good question the connection between
the messaging server and our app is SSL
encrypted and we'll see actually Google
has a pretty good way of keeping it as a
seller cryptid because that's actually
quite expensive to do not for handshake
reasons because the connection gets
reestablished so many times so this is
as a cell within within the app you know
yes your message your raw data is
passing through Google servers and it's
passing within the app that will go
infrastructure in the app right and you
could argue well you know could they not
you know miss whatever means that all
that compromise the privacy or the
integrity of my data now generally you
could nothing stopping you from
encrypting the data on the server side
passing it as encrypted data you know in
base64 encoded message and then having
your app decrypted so Google has no
knowledge of it anyway but you don't
want to build your data in the method
mesh message should not really contain
sensitive info the sensitive info should
come at the last step when we go and get
notified we go to our server and say
okay give us the last data and we
generally can do that over SSL and that
at that point it's outside of Google
scans anyways or anyone else's right so
it is the way you build your app
effectively is up to you it's up to you
to guarantee that's secure to provide
that security okay so let's move on and
then we'll see if there are more
questions later on so how does it all
work right so all the device Google
actually has a background service that's
running at all times and it's basically
has this SSL encrypted connection okay
it honors the background data setting so
if the user says I don't want any
background data you know basically maybe
or no they're not you know on a plan one
of those tiered plans they don't want to
do it you know then it gets turned off
and the push doesn't work so that's one
other limitation but that's a it's
actually a good one it automatically
discovers will network becomes available
and unavailable so it automatically
starts and stop as needed it uses
heartbeats to to reconnect as necessary
so it'll actually as you could imagine
run periodically
so that is polling after all runs
periodically test the the you know the
health of the connection and some
connections can be half open so it tries
to tries to basically
pushed something to the server and get
an act back and if it fails that
re-establishes the connection now in the
clouds so this is the service part of
the c2dm google provides basically this
farm this massive farm of servers they
there have already for their own stuff
right and basically one of the features
of their farm in addition to being huge
and allowing all these persistent
connections is that it has this smart
SSL resumption system so that basically
as you sell as you know involves you
know public encryption to establish the
session key which is then used through
symmetric key encryption for the actual
data pass right but the the public
encryption part and the you know the
handshake until we get to session keys
quite a kind of expensive especially on
a device where battery matters right yes
they're getting more powerful but you
know batteries are not getting more
powerful at least not at the same rate
as users demanded to be so what we want
is to catch the session key as much as
long as possible so that when these
connections are established we can
effectively reconnect and so Google does
that for us yeah and what's also you
know so basically the server side can
also attack that connection so you can
also push hard beats from the server
side so the server side can actually say
oh this died so the next time around
when there's a message to send to the to
the device I'm not even going to try now
no note that server cannot open a
connection to the device right
it means the device that has to connect
to the server not the other way around
and so what we do right so our job in
addition yes there are a lot of steps
but our job really is to build a
broadcast receiver that can accept these
messages and then react to them however
we you know want to react to them so
let's go to the steps the first step is
you know step zero if you will to go to
this URL and sign up for an account okay
they ask you for things like you know
the name of your app you know the
package name of your app it's okay if it
hasn't been published yet well how many
messages you expect to be sending you
know in corporate you know and in
aggregate or you know to a particular
device at a time your contact
information and the most important this
role email this role email is not meant
to be a human emo it's kind of like you
can call
you know for us he's like Android at
Maracana calm whatever it's very
abstract can and this is the Arenal that
we're gonna use to authenticate to
Google and this is demo we're gonna use
one request the registration ID from
c2dm
okay so that part you're going to do on
your own you just go to the web page
fill out the information wait usually
takes a couple of days you get most of
you will get it
unless you have some naughty things in
your package name and you know it'll
work what you then do is you he just set
up your set your app for c2dm this seems
a little overwhelming but there's not
that complicated it's mostly boilerplate
you only do it once so it's not a big
deal the first thing you notice is that
my app has this custom app here I called
my app I don't know how many of you know
of this application object that exists
in LA in Android which is effectively a
singleton in the way it works not the
way you actually code it but the way it
works at runtime and allows you to share
stuff through it the reason why I have
it is because that's one of the simple
ways to share wakelocks and I'll explain
later on why we use wakelocks
so for the time being that's not really
c2dm specific but it comes into play
here's the big part right here is
basically our receiver this is what we
go and build now this receiver notice
has this permission this you know calm
Google Android c2dm
permission set this basically the reason
why I put this permission here is so
that we require that the sender of c2dm
messages be this Google application this
Google service effectively so that
doesn't someone else's is prove the
messages you asked about security well
this helps us you know effectively weed
out other applications from your
spoofing our notifications what we then
do is we register by intent filters for
two actions one is the receive which is
how we get notified all these messages
and then the other one is the
registration this is how we get called
back when our registration IDs ready
this was step number one right so we go
to Google internal service we try to
register that somehow goes to the cloud
and grabs a census registration ID we
now get it and we basically stick it we
accept it via a broadcast receiver call
and it's for action registration well
it's not just the acknowledgement they
actually contain that's the way we get
the registration ID is asynchronously
right so it's a callback effect it's a
callback we requested and at some point
in the future that particular event is
gonna fire and we're gonna get okay you
notice that there's categories here that
are added that effectively allow there
just to weed out or to better yet to
avoid having are the broadcast that
we're getting go to other applications
okay
so that's why we have the category of
course there's actually a better that's
just there just to simplify or to make
it a little more efficient so the other
applications are not even considered
should they try to receive our messages
and they can have their own obviously
other applications will have their own
brought these receivers that will
subscribe to exactly the same actions
but because they'll have different
categories they will only be interested
in their own messages let's call let's
call the bra even though broadcast post
messages are you know one-to-many
in this particular case they're
one-to-one one particular application is
meant to get the application shouldn't
be running in fact we don't want our
application to be running for all
intended purposes this is you know
that's the whole reason here we want to
we don't want to brain weighs the
battery right so that's that's the whole
point of broadcast receivers so they
will wake up this this broadcast message
that that you know that effectively we
captured through this intent filter whoa
starring tight we're launched you know a
new Dalek instance will launch
replication and it will initialize a
broadcast receiver and we'll call the
own receive Method Island that's exactly
how broadcast receivers are meant to
work so just to come back to one
particular point here with respect to
security how do we ensure that
effectively we only get this message
okay so one of the things we do is we
declare a permission here so notice this
particular section so right here we
declare a permission now that permission
is our package name plus dot permission
dot c2dm message okay it's a
predetermined permission name now the
reason why we build Eclair
and use it okay so we need to use our
own permission here and it's basically
the signature level permission so the
user will never actually see this the
the user who go gets to install your
application they will actually never see
oh this application requires this
particular permission because its
signature level okay so what will happen
is that google c2dm infrastructure on
the device when it pushes the message to
our application the way will prevent
others from effectively declaring their
own receiver with exactly the same
categories i eat that will be
effectively be able to intercept their
messages so the way they prevent them is
because we are the only ones who own
this message right so sorry this
permission so therefore what they do is
i will show in a moment they basic
basically push create an intent and when
they send abroad as they add this
permission so this permission is
predetermined so that's it some kind of
you know you need to just provide it in
such so it's always going to be
packaging and plus permission you know
plus you know c2dm message good well you
want your apps to be to be targeted
separately so your each app is gonna
have a different package name so
therefore each app is gonna have a
different permission and each app is
gonna have a different category if there
are two apps right if they have two
different package dreams which is how
you refresh i2 apps in the first place
you could so you're right
in a sense you could you you know at
that point because you will presumably
sign both apps with the same signature
so then you will be you should could
basically use it and you could have both
apps be or basically an app that's not
meant to be triggered to be triggered by
this but that's I don't know why you
would do that I don't know what the use
cases for that but yes it's possible
that would not be a you just you could
use first case fortification I mean it's
possible Howard why you would do it
would be awesome right but again you
know generally just from one again let's
take a look at the big picture what's
the idea here we want to target a
particular application we don't if that
application gets the message and he
wants to internally broadcast it to
other applications let it do an eternal
eternal broadcast it wouldn't make sense
to have all these applications be
triggered and all these applications
have to die into the sea to the end that
just it's just bad design
right you want to minimize your exposure
to external interfaces not you know make
it bigger again so a couple of other
things you noticed here I have a
permission to receive so I have to
require this permission to receive
basically c2dm in the first place this
is just so I can participate in the c2dm
framework and just in this particular
case because they'll be obviously going
through the internet to register for
registration purposes I also need to
grab an internet permission and I need
to grab a wakelock okay the way clocks
are really building because I'm gonna be
doing a long-running operation so in
almost all cases will you need these
okay and you'll see later on how how you
would use them some good so far hoping
so this is basically that's what step
number one point one one point two is
where we actually you know kick off the
registration process remember we need to
register so what we do is we build an
intent from for example a service or
application or broadcast receiver
application there's only matter one of
our you know Android you know components
if you will and in it we define this
action which is calm you know Google
Android c2dm intent register can we then
put an extra bit into this intent and
this extra seems like kind of cryptic
it's some pending intent of a broadcast
that had just ever has an entity
internally an empty intent seems like
what the heck is this you don't even
have to understand what pending intents
are nor what this would represent and
what does zeros actually mean because
think of it this way this pending intent
is think of it it's just the signature
of our app effectively includes our apps
package name that's it okay this is how
Google knows that we are the ones who
requested this it's just a requirement
that we put it here and then the last
and most important thing we need to put
in here the sender right this basically
over here this sender this email address
that you see over here is the email
address that we basically use when we
registered or in step 0 when we sign up
for c2dm right that is the whitelisted
email address again this you can make
configurable as opposed to hard coding
it as I did in my in my app and then we
start our service so we push this
registration intent we say starter
service this goes outside of our
applications called booster Google
Google's does the registration and send
us back the notification okay so how do
we get a notification so this is the
completing the registration can we build
a broadcast receiver now again I hope
you understand what brought this
receivers are if you don't think of it
as components that can get you know
triggered or tickled by by anything in
the system can't through the use of
intents and this broadcast receiver has
an on receive method in which we grab
for example the action so we won't
understand what was the action that was
in fact that invoked a receiver we test
whether the action equals the
registration part because the reason why
we do this is because they tend to want
to reuse the same receiver for both
registration and to handle the receiver
or there's you know the actual give you
know the messages at that point we can
grab the registration ID at that point
we had the registration ID okay or we
can have an error anyway you need in
case for example we have not made this
is a sender account that we used wasn't
properly registered or we may actually
get this unregistered string which just
means that we unregistered it's kind of
weird like it registration intent he's
also fired when you unregister as we
will talk about later so we test for
errors we can test for whether or not
we're unregistered but let's assume we
are registered that's kind of what we're
interested in so we check for whether
this is not now and now that we know
it's not now we know we are registered
on the server side on the c2dm side what
we now need to do is stay there
education ID and give it to our server
so that our server can basically go and
target our particular installation of
the app okay now generally because
talking to our server is a long-running
operation right involves i/o involves
network which is slow and we only have
up to 10 seconds in the broadcast
receiver before we get an a NR or the
application not responsive and you don't
want to ever even approach the threshold
of 10 seconds you generally don't want
to do anything like talking to a server
inside of an on receive method we also
cannot throw you know create a thread to
do it like or an async task because as
soon as the on receive method is done
our broadcast receiver is considered
dead so our application can basically be
disposed of so you
want to create threads from rockets
receivers so what we do is we create we
effectively have a service do the
registration for us or when I say
registration I mean pass the
registration ID to our server
so the way I do it I create an intent
let's say it has something called reg
service and I go and basically stick
this registration ID into the this
intent as an extra and then I start a
service okay now so you're right so my
application actually the way I built
that is actually has already a checkbox
and then you know when the user presses
in the checkbox you know that means hey
you should be registered and yes you
know you may want to record the
successor than failure of the
registration the way I the way I do it
is if it fails to register and I just
uncheck their checkbox and maybe a give
them like a little toast it says hey
you've just failed sure it can be done
better can so we now start a service
okay now the service looks like this now
I'm gonna assume you guys know what
services are okay these are the
background processes and the reason why
we're like service is because they
prevent our application from being
disposed off after all
all of this can run in the background
there may not be any UI and your cavity
is a social reader application it runs
in the background right we don't want it
to be killed so services have higher
priority and like say background
applications or stopped applications
they just have activities right so the
way I do it though is I build a ending
or extending tensors the intent service
has its own handle intent method which
is called by a separate thread so intent
service for those you that don't know is
effectively think of it as it is a
template for how to not have to deal
with threading in a service get it to
basically to be done for you for free so
rather than you know override the on
start method or on start command we
override the on handle intent which is
internally invoked in a separate thread
that's what intent service guarantees
for us and it has its own internal
thread pools and all that stuff so it's
you know makes it super easy for us so
what we then do grab the registration ID
if we wanted to we can grab the user at
the assuming we have a concept of a user
okay
or you can grab the device ID the way
you drive a device say that you grab you
know get a reference to this telephony
manager through a system service and
then you ask the telephony manager for
the device ID for that to work though
you need to add another permission which
is basically this you know read phone
states you need to stick that into your
you know your your application or your
manifest file and at that point we have
the registration and we have something
that uniquely identify is that
particular you know user or device so we
take those two pieces information and we
post them or however send it to our
server generally using like URL connect
or HTTP URL connection or HTTP URL
connection which I hope you know how to
do or if you can use the even better the
Apache effectively Commons HTTP client
it's built into the Android API so it
comes with androids you know provided by
the end relief yachts so that part is
outside of the scope of this is because
we can talk about that forever it's
generally well understood you can just
google it and you'll see how to post you
know in Java and simple HTTP make an
HTTP POST okay and we're passing to our
server is the device side do you or the
user ID plus the registration ID okay
now saving the registration now we're on
the server
okay how will you build a server whether
it's PHP or Java or whatever you prefer
we go and probate provides some kind of
a storage mechanism for these
registrations and the users it's up to
you how you build this for example you
know in my little sample application I
have a table called users stay to the
end in a my sequel database which
records two things the user ID which you
know is an integer I guess and a
registration ID okay which is the thing
that I got from c2dm in step one okay
and I've made my illustration ID you
know be primary or user ID primary of
course their limitation of this is that
I only allow a user to be registered on
one device at a time so they have
multiple Android devices that kind of
would you know suck so maybe I should
actually use device ID as opposed to use
ready whatever okay and then what Apple
you know the way I do it is I you know
let's say this was a servlet
assuming you guys know servlets or at
least I've seen them or having a
journalist and him how to read HTTP
parameters I would read basically the
user ID and the registration ID or
places with device ID and then I would
simply persist that into my database
okay so now I know that information
should I want to target that user in the
future I can be bigger than to 400 in
fact it's really big it's some it's I
don't know feels like maybe 500
characters and I since I don't know it
doesn't say how big it can be I just
don't want to think about it all right
so the registration IDs or just racially
these are device specific right now if
all I had here if I if this is how I did
in my server-side what what happened is
that one device would register first and
then the second device would overwrite
the previous devices registration
because presumably
in this case in the replace and devil
effectively overwrite it if I wanted to
I would just add a third column and call
it device ID and then I would make the
user and the device ID but then it'd be
the primary key so combination of two
will be a primary key good you know
again you don't have to use it if you
wanted to target a specific device I
don't see where you know other ways
around it yes you can argue that there's
you know privacy issues per se but not
much you can do about it there's no no
no way around if you know better
we all miss feel free to share it's just
an ID I mean it's you know if you want
to encrypt it or whatever if you because
I mean I'm not I don't see I guess if I
you know all the application in the
world use the device ID and yes if one
application leaks say then you can infer
things about the user in other
application somewhere else and yes that
raises privacy issues but again that
just you know we're gonna have we can
enforce it unfortunately we don't have
the time to go into you know how to best
address this sort of thing but you're
right I mean it could be potentially
something you may need to protect right
the app server on the device is danica
with a push word so the device would
inform itself there was already a
built-in you know push mechanism in
Android called broadcast receivers I
don't see how you know the whole idea is
of the city
for the cloud to tell us of something
not for something else on the device to
tell us or something right if you do
need something like that you just use
broadcast receivers and that's that
that's how that works it says it's you
know built into Android can shown we say
this again how we save it is up for you
go ahead we need to we need to
unfortunately move along we only have
another no serve on the user ID here is
your logical user ID let's say it was
let's say which is the app that I have
is a Twitter like client okay
it's a Twitter user that would be the
user ID so we're going to be so
basically what I want to target a
particular Twitter user to tell the
Twitter user hey your friend has posted
something come grab it that in store I
would know that particular users
registration so this is not any way to
perform the the Google account they used
to sign up for see to them in the first
place you're separate so step number
four can we now go to c2dm oh sorry to
client login to grab this auth token let
me just by the way for one quick second
let's see if we can go back to the slide
just so sorry break it back to the big
pictures just so you kind of reconnect
to wherever you are right so in the step
four we go to this client login service
the client login service basically it's
a simple HTTP request it's a post to
basically this URL
you know www.google.com/mapmaker secound
type equals hosted or Google just put it
there
you know take it for granted email
equals this is your role email this is
the email you use when you sign up for
see to the end this is the email that
was used when your account was basically
being up you know whatever right or when
you in step one did the registration you
added the sender thingy the password is
whatever password you provision with
Google the service part this is
important we're now here saying we want
to register specific or get an auth
token
specifically be used for a c2dm android
cloud-to-device messaging and the source
equals it's kind of like a user agent
string you can put whatever the heck you
want in there and so what we then do you
know we format it as an HTTP POST
depending how you do it if you have a
client that will do you know the you
know whatever put like a Content length
and content type headers for you that's
even better and what we then get is some
kind of response we hope for a 200
response and then and then what we do is
we parse that response for a effectively
text which is one line which has auth
equals something and that something is a
token that we care about okay this can
fail or it can challenge us to do the
CAPTCHA thing which is basically to
prove them or not you know there were
human in this and that but we generally
you know hopefully won't long have to do
that because what we do is we hash on
the server side okay so for future
messages we use it we don't have to go
back and reopen ticket we this is like a
wall most a one-time thing
periodically you know they may force us
to come back and then we just really
thank it's very authentic it but it's
not a big ordeal so now do we have it
now it's a juicy part right all this was
just a setup now we want to effectively
send messages this is basically why
we're doing this in the first place the
way we do this is we basically create
another HTTP POST again from our app
server and that post it goes to that URL
you see there okay some predetermined
URL and that post expects the following
parameters okay the parameters are the
registration ID
well our server knows it because he
knows the user so by the way at this
point our server is trying to target a
particular application so it should know
the registration ID okay the collapse
key we'll explain a little later it's a
required driver I'll explain later on
when and how it is you then we can
provide a whole bunch of data tossed you
know name equals vary parameters these
name equals value become the extras in
the intent that you receive on the on
the honor
you know on your app side okay these are
arbitrary you don't have to put anything
in here if you don't want but these are
arbitrary just maybe people's values the
only limitation is that the : you know
the combined size the message must not
exceed 1024 bytes and then there's
another actually optional parameter
called delay while idle and we'll
explain later on you'll see how and get
it that gets you the only other required
bit is to basically pass in this
authorization header and the
authorization header is Google login
space off equals and then your auth
token this is the thing that we've got
in this previous step number five okay
that's it
we now submit the request we if we get
every spot 200 response that has ID
equals some number which is not even
important because that we can't really
call right corner like that ID to
anything but we get some kind of
response back that's not an error
response we're golden
cancer there's a lot as long as there's
no error you know error in in the 200
spawns then either message was sent out
okay at that point there's not much we
can do now if you don't mind save your
questions until the end just because I
know some people have to leave and I
want to go to the slides first so now
our message is in the c2dm front that it
was accepted by c2dm front end now what
it what it then do so we killed handle
errors and there's all sorts of errors
we can get the court exceeded device you
know cortex either this could be like
code exceeded basically you know too
many zeros messages sent can aggregate
or too many different messages sent to a
particular device or invalid
registration ID or expired registration
maybe our app was uninstalled or the
user specific or could be or missing
collapsed in case we forgot included
explainable collapse key is we may also
get a 401 which is good which would mean
that a client login expired or easily
valid right at this point you know that
you should go and we reopen ticket with
client login guess you repeat step
number five and that's it if the server
is busy you may get a 503
which will include like a retry after
header which means hey don't come back
until that time if you do
no Google may you know whatever ban you
or somehow other punish you might
decrease your quarter or mean pose a
stricter limits okay so you should honor
that Heather my particular code doesn't
for sample code doesn't but whatever you
should now step six seven and eight let
me just reconnect to what step six seven
and eight are so you can see it or
basically we do the authentication you
know of the token week you the message
we're out to deliver for delivery okay
those are the step two six seven and
eight these are happening in the club so
let me just quickly show you what those
look like so it goes in verifies they're
off our token okay that seems logical it
then temporarily cues her message to
some kind of a durable store whatever
that is can't think where there's a
message queue and so these messages are
held here until they're either delivered
or they expire the expiration is not
something we get to to control so
there's no support for TTL unfortunately
at the moment and it's you know helps
with the best efforts you'll
automatically retry as necessary if
there was now we can kind of come back
to the collapse key if there is already
a message that's previously been killed
will be replaced so the idea behind the
collapse key is let's say your user goes
on and up on a plane so they put their
phone in the a in the airplane mode and
or they come here they have no signal
right and now they all of a sudden come
into the zone where they have signal if
you've previously sent them a whole
bunch of notifications that they're
friends you know posted some messages to
their profile or something like if it
was a facebook application it doesn't
make sense for their application to be
tickled time you know fifty times if
there were fifty posts you only need one
tickle like one notification because you
just want the application to go back to
your server and fetch all the data right
so by having the same collapse key in
your messages you ensure that you
effectively replace previous you know
not note of cash or cute you know
notifications for that particular user
again and then finally so what we didn't
do is
we're out the message to the messaging
server which hopefully calls the
connection to a device if it's open if
it doesn't obviously if it's not open
them you know the message that stays in
the queue and at some future point you
know recheck it yet so step 9
so let's quickly go through this so in
step 9 we basically go and you know we
want to now deliver the message so now
well the way it works is that we
basically first check for whether we
should delay the delivery of the message
ok this is by the way the messaging
service wanting to deliver the message
through device so he goes and says
should we wait now why would we wait
well there's basically something called
attenuation which will automatically
implements and and not disable this and
what it is it effectively prevents our
device from getting this constant stream
of messages what it will do it will
detect if there's a high frequency of
messages starting at being target to a
particular particular app and collapse
keys the registration and collapse key
and if there is there these messages may
automatically be cute or delayed which
will then hopefully do same collapse key
prevent you know all these messages from
being you know streams of advice you
know and some you know very high 3 the
idea behind this is that we temporarily
delay it
how temporarily you know it so number of
milliseconds potentially minutes yeah
yeah and you know the goal is that we
prevent spinning up the radio for the
delivery of the message for every single
message which ultimate goal is protects
the battery and if in case your messages
are constantly notify the user you know
eventually are less annoying to our
users so the first few messages are let
through and then you know if the con the
stream continues is the same rate Google
may and this is not well documented as
to when and how they decide to do this
so don't ask me questions unfortunately
about that I can't answer because I
don't know they may basically go and say
you know this may have to wait a lot and
this happens in the cloud on the Google
side you may have to wait yes it's / / /
/ app which is basically / registration
on a particular device okay
no sorry it's for for particular yes so
it is poor so I should actually changes
so thanks for pointing that out yeah the
other low feature this is controllable
by us is something called delay while
idle or if you remember that was one of
the parameters we could have specified
here we just say equals true or equals
something and what happens if we do
include it is that basically we wait on
active before we actually send the
message now how the heck do we know if
the device is active the device because
it has this constant connection with
Google at all times it automatically
tells the connection server when it
screen is on if the screen is off maybe
you don't care about these messages
maybe doesn't make sense to inform the
user who cares right so that's basically
if we do include this or there's certain
classes applications where we don't care
to inform the user if their device is
off anyways and it's really just on the
screen being offer on not whether the
CPU is off right and here's finally the
message delivery so this is the message
now gets sent over the TCP connection
that's is so encrypted to our device
something on their device gets the
message okay some kind of a service
which is actually this thing well
actually it's not necessary this thing
this thing goes and pushes the message I
just basically scan for what sends the
broadcast message and this is basically
some Google built-in thing okay and so
what this does and this code is just
kind of you know and it's not real code
I mean I invented this I kind of just
based on what expected them to do I
haven't actually doesn't have access to
their source code but what I do is they
build this receive intent in the intent
they add category that targets our
particular application and then they put
all of our data so if we had like data
that foo equals bar that becomes foo
equals bar as an extra field okay and so
all of our data gets put in here and
then they go and send a broadcast which
is with our intent but in the broadcast
they create a special permission which
is our app plus permission plus c2dm
message
this is how they ensure that only our
app gets the message otherwise other
apps may intercept your messages and
they can do whatever they were
okay so if you remember you know well
again my slides are available online so
you can see go back to the end of the
manifest.xml to see kind of what this
looks like okay so this is how we target
our particular receiver receiver now how
do we receive the message this is we're
almost done yeah we basically the first
thing is we're gonna need to go back to
our server when we receive the message
the problem is while our device will be
woken up okay if when this message comes
in the message will only were device
will be available to us as long as we
are in the own receive method of the
broadcast receiver after the on receive
method is done our device may very well
go to sleep in which case us going and
fetching the data from the server will
not happen so what we need is to grab a
wake lock if you don't know what like
wake locks are you know readable you
know to power manager you'll understand
and Ferries they're not gonna complicate
so what we do is we basically I created
something called a custom application
class that basically creates an instance
of a and of course it seems that I
didn't actually declared awake lock so
this is missing extra declaration but
there's basically some kind of a you
know wake lock which we go and fetch
from this bar manager and we provide
methods here for acquire and release and
this also tracks for you so you'll see
in a moment how we use this so here's
basically us processing the message
here's the broad is to see where that
actually gets triggered by c2dm this is
the final part right we get the on
receive method gets invoked we check for
whether the action is you know receive
action that's the one that we're now
interested in we can now go and fetch
all of our you know extras like our you
know foo one food to whatever we need to
fetch if they mean something to us if
there are no extra school cares now that
we do is we grab a reference to our app
object which we have implicit reference
to just the way Android works okay and
through the web object we try to acquire
the way
clock if the wakelock doesn't if we
can't get it to mean that we're already
running this code so we don't want to do
it again okay so only this works we
actually go on acquire the right we then
building that which basically runs our
service which will then refresh the data
remember we cannot go back to our server
to fetch the most up-to-date data in the
on receive method because it's so
expensive operation and that you cannot
do it from the Rockets receiver so again
we go back to service maybe we pass some
some kind of your information to our
service if that's of relevance to our
service most likely wouldn't be but
let's say there is and now the final
part is we basically in our service if
we need it to we grab our full one if
that means something to us we go to our
server
backdoor server via an HTTP GET or
whatever however you want to go to your
server right so simple HTTP request and
you get your data and maybe you store it
to a local database in sequel a database
or something like that and then finally
you release the wakelock
and at that point to device may go to
sleep of course you put in here do
notifications you can put toasts you
could launch activities not that you
should but you know you could do all
sorts of things inside of that on
handler requests and again this is one
of those intent services okay so I know
we're all one minutes over but let's
wrap it up so the final part is
acknowledging delivering this happens
automatically as soon as the message is
acknowledged by the device it goes back
to Google Google says oh we got it it
removes it from the from there for this
message queue now yeah that's it
so here it says you know it's easy as
zero to ten seems not that easy but in
reality all of this is boilerplate you
do this once right and yes it revolves a
little bit of setup but it's not that
complicated right I mean actually
there's more complexity on the server
side and on the client side so it's
fairly easy to follow okay um if you
want to go back set back to selling more
messages you already have the
registration ID you already have the
auth token you just
repeat steps you know 5 5 and
effectively Google does everything else
so it's super easy you may have to worry
about you know if this fails with a 401
you may need to real tentacle if this
fails with court exceeded or 503 you may
need to back off
so then potentially this is the part
part potentially go on the server side
may need to build a message queue right
in case your you know your your guys's
the aren't being accepted by the goofy
by the Google servers and so that you
can you can do your own you know three
tries and if you want to register should
you need to
you basically unregistered to an intent
that also goes back there's two receiver
same thing fires you're not just getting
on the register and you are invited you
go back to your server and unregister
should you need to so in summary you
know we want to keep the data fresh
polling sucks don't use it we want to
use Porsche SMS is okay but expensive we
don't we could roll our own persistent
complexion but that's hard and you know
an expensive seafood diem is free we you
already well leverage what's already
there right we can Amitha amortize this
one existing connection Google already
has across a range of these apps so you
know it's much better better experience
or better life and therefore user
experience on the devices and you know
we get these advanced features like a
automation you know delay while idle
collapse keys and so on and so on the
only problem is still labs not quite
clear and where the terms are so thank
you for for listening hopefully you
learned something I'll stay around in
case you guys have any questions I know
some of you want to leave if you want to
get these slides as less well as well as
the sample code that includes a complete
app which I'll explain more I need to
actually update this with this
documentation so complete app it
includes the server-side components
everything and it works you can test it
out go through their URL for other
videos and stuff on Android or check out
our tech TV so thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>