<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ECMAScript 6 with Kit Cambridge | Coder Coacher - Coaching Coders</title><meta content="ECMAScript 6 with Kit Cambridge - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ECMAScript 6 with Kit Cambridge</b></h2><h5 class="post__date">2013-09-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3KqCuYvOO48" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm incredibly excited to be speaking to
all of you today about acma script 6 the
next major revision of the standard that
governs JavaScript along with some other
programming languages so let's go ahead
and get started at w3 conf one of the
things I said was that every technology
had a story behind it and this
particular worldview was in part upon me
by farruko toss about a year ago I was
watching speak at html5 calm as it turns
out and so froak is the moderniser is
the developer of moderniser he is also a
amazing open web advocate and one of the
thing and his presentation was about the
beauty of constraints and specifically
embracing them in software design and
the way that he presented it in this
type of frame story was particularly
engaging because a lot of times when you
see at a particular technology the only
context you have is the final product
you don't necessarily have the story
that's surrounding it you haven't seen
all the decisions that made the that
resulted in the way that that technology
was designed and a lot of times it's
very difficult to be able to grasp why
we have a particular version of a
feature or why something ended up being
the way it did and without having this
frame story very few decisions make
sense now equi script 6 has had a very
long and torturous road that I'll cover
before we delve into some of the
features and it's not been without its
fair share of controversy there
developers who have wanted to get start
with aetna skirt six but have a few
qualms either about the syntax or about
some of the features and without
understanding the story who can blame
them it's very difficult I think to be
able to make and to step back and make
an objective assessment about the value
of a feature when you don't have the the
full context for its emergence and so
what I want you to
was to briefly cover how atmosphere six
became the language that it is today and
some of the interesting challenges that
it's faced on along the throat will then
proceed with a deep dive into some of my
favorite parts of the language now the
talks titled atmos crib sets the refined
parts and I think this idea of
refinements is very key to the next
iteration language there are a lot of
major features in it everything from
classes and modules to entirely new sin
taxes for doing the common operations
that we as programmers work on every day
and I wanted to step back and give some
of these smaller features some of the
highlights because features like classes
and modules I think either many would
have heard of or they're going to
receive the most coverage as soon as
they're released and so what I wanted to
do today was to showcase some of those
features that might not be that
world-changing at first glance but that
will nonetheless make it a lot easier
for you to write bits of code that you
do so JavaScript by itself is by most
accounts the world's most popular
programming language because every
browser made today and certainly all the
major browsers ship with a JavaScript
interpreter and the barrier to entry for
it is incredibly low all you need to do
get started javascript is just open up
the dev console and begin typing away
and thanks to the recent incredible
growth in the front and tooling
community there are all it's easier than
ever to get started building apps of
increasingly complex scale but
javascript isn't just for the front
anymore of course no Jas has made has
completely changed the applications of
JavaScript on the server as well and
know it has a wide variety of uses you
can use it everything from tooling to
root rudimentary chat servers or your
typical HTTP servers and now build
databases ala carte thanks to leveldb
movement so javascript is incredibly
versatile it's everywhere how are you
going to move it forward because we
can't break backward compatibility with
some of the existing standards with some
of the existing code that's out there
day
we've tried doing that in past efforts
and the results haven't been good so
equi script 6 is an attempt to learn
from some of those mistakes as well and
to focus on getting some of the
refinements right so that developers can
continue using the code that they write
today and not have to worry about it
breaking when a new reduce so let's
begin with a story our story starts in
1995 with an engineer at Netscape
Communications Corporation named Brendan
Eich Brendan Eich was tasked with
developing a new client-side scripting
language to complement the latest and
greatest technology that Sun built at
the time which was Java now Java was
perhaps the best way to create
interactive immersive experiences again
1995 but Java code Java applets didn't
mesh very well with the remainder of the
page they could perform some basic
introspection into their environment but
they didn't have access to every element
on the page or our have any type of
meaningful interactivity with them
similarly for small bits of
interactivity so in say menus or base a
client-side validation it was simply
unreasonable to expect that users would
wait while the while your browser
downloaded a Java applet over a 28.8 but
dial-up connection again mid-90s and
then wait for the Java plugin to kick in
and for the Java Runtime environment a
startup that wasn't the way that
developers work went to do things but at
the same time this a lure of having Java
as a write once run everywhere language
was very appealing and so it was
important to have a client-side
scripting language to complement that
now Brendan named his original creation
live script it was subsequently renamed
to mocha and then in a last-ditch
attempt to capitalize upon the marketing
surrounding Java it became known as
JavaScript and we've been we've all been
confused by the name ever since now
javaScript quickly eclipsed its distant
and rather confusingly named cousin and
was then pick up by Microsoft and
implemented in the latest iteration of
its
sir which at the time was there an
explorer 3 but because there was no
definitive specification for JavaScript
at the time Microsoft did the only thing
that any good engineering company would
invariably do they reverse engineered
Netscape supplementation's and without
that formal spec of course different key
differences arose and about a year later
in 1996 Netscape Microsoft and a
consortium of other companies step
forward and decided to submit the
version of java script to the ECMA the
European computer manufacturers
association and the result of this was
the emergence of a standard called ECMO
script now nobody had particularly cared
for the name echo script Brendan Eich
was once known to refer to it as that it
sounded like a skin disease it was and
it was really this verbose tedious trade
name that was only used to protect
against trademarks and to have some kind
of distinguished name for the standard
but nonetheless JavaScript NJ scope
continued to evolve and emerge and soon
there was a second edition of the
language that was published primarily
for bringing it into compliance with
existing existing international
standards but things became interesting
in 1999 with the emergence of the third
edition of echo script now it included
features that today we'd find today we
couldn't think of Joss without them
things like regular expressions or try
couch before this point exceptional
javascript was easy meaning that there
wasn't any if your script through a
runtime exception your browser would
stop executing it that's it there was no
granular exception handling things like
the instance of operator additional
loops array object literals these are
all fundamentals that we would consider
that will be we couldn't write our
JavaScript applications without them and
an epic tree was also built to
anticipate future growth with an
upcoming fourth edition of the of
standard but things didn't quite work
out the way that the EC may had intended
in late two thousand four early 2005 the
EC made the working group responsible
for innovating the language within tc39
within the
ma named tc39 just short for technical
committee 39 had decided to attempt to
assimilate some of the features that
macromedia had developed in its dialect
of a conscript called ActionScript so
whereas javascript was a relatively
conservative departure from aetna script
again primarily due to the naming and
some netscape and later mozilla specific
extensions acma script really extended
the JavaScript language in several key
ways it introduced classes and modules
packages namespaces optional static
typing type annotations and this doesn't
really look like the JavaScript that we
write today so what happened in between
there around in late two thousand five
there was there was a movement that
would change everything on the web and
this was Ajax suddenly with the
emergence of libraries like prototype
dojo mochi kit Rico name many names
which have since gone by it was very
easy suddenly to build complex
interactive apps that's not to say that
developers haven't been building these
kinds of applications before but rather
than at this point it became mainstream
and with the incredible growth in the
jaws community at the time it was in an
incredibly difficult proposition to go
to developers and say that in a year's
time or in two years the code they were
riding would break atmosphere for was
not intended to be backward compatible
initially in fact some of the key one of
the key goals of the language was to fix
some of the issues that have cropped up
in the past but now with with developers
continuing to build existing code on top
of it it really wasn't practical to
create a backward in compiler version of
the language so atmosphere for the
proposal was eventually cancelled the
only hint of it is looking at the
various specification versions and
seeing that there was no atmosphere for
released on the e cmas website in fact
there is no official specification
floating on for it because it was never
finalized until that point and the
technical committee went back to the
drawing board and decided how do we
innovate the language but in a way
that's backward
and in with the code that developers are
riding today and so in 2009 when they
release the 5th edition of the ACMA
script standard the fifth edition was a
relatively conservative departure from
the third edition it provided some nicer
syntax for getters and setters the only
major syntactic addition that wasn't a
codification of an existing de facto
standard it provided some object
reflection methods array extras that had
existed in Firefox since Firefox version
2 so not a lot of particularly
interesting surface changes but under
the hood it tightened down a lot of
internal semantics it became a much more
precise strict and unambiguous standard
on top of which the tc39 could continue
to innovate and build other language
features and that brings us to where we
are today in 2013 went into the
atmosphere 6 specification is scheduled
for is scheduled to be released by the
end of this year in December and it has
a lot of features limit but if you look
at this list a few of the features jump
out things like classes modules block
scope iterators a lot of these features
did make their debut in atmos crypt for
in the canceled fourth edition but
whereas previously there were nice to
have features that could be assimilate
from other other languages now there's
been an eye toward making them mesh very
well with existing code that developers
writing the technical committee looked
at a lot of look at the common patterns
that developers are using and try to
figure out what are some what are some
solutions that would best be adopted at
the language level and so what I'm a lot
least we don't have time today to cover
nearly all of all these features in
detail but I want to give you just a
quick introduction to them so that
hopefully you can see a feature that
strikes you and you might find a way to
use it in your application the goal here
is to provide some practical syntax that
you can get started with today and we'll
go ahead and the other point of course
of ECMO script sex is to build a
foundation for future revisions of the
language
atmosphere 7 has a lot of features plan
for it things like a rethinking of the
concurrency model of language as well as
features like object observe now these
features are ones that would still be
fantastic to have in the current
iteration of language but there just
wasn't enough time to build them right
it was tc39 needs to get this version of
specification out the door so that
developers can start using these new
features and then at a later time once
the proposals are finalized subsequent
versions of the language will be
released so acma script 6 is both a
codification of existing patterns and a
platform that continues the trend by es5
to allow to allow future innovations in
the language and we'll go ahead and
begin by it starting to talk a person
talk about generators which are an
interesting pattern and that tie nicely
with the theme that will be furthered
es7 with the new concurrency model a
generator is a form of a co routine so
what Sakura team a protein is nothing
more than a construct that allows you to
suspend and resume execution of a
particular function at multiple
locations now it's important to note
that suspending does not mean blocking I
think there's been some misconceptions
about looking at this and seeing that a
generator will automatically block your
code so that nothing else can run and
that's actually not the case at all it's
a generator is the generators have three
multiple three patterns that you should
know about there's the new yield
statement which suspends execution of
the function there's a next method that
the resulting generator object halves
that allows you to resume execution and
then there's a throw method that allows
you to propagate an exception to the
parent function and have it be thrown at
the position of that yield expression so
we'll go ahead and begin by looking at
generators through a simple fibonacci
sequence example how many of you know
Angus crow or followed some of his log
articles ok there's a fantastic series
that he's certain about if Hemingway
wrote JavaScript and he covers how
various famed literary figures would
tackle riding the Fibonacci function in
JavaScript and this
is the generator this is the plain Jane
generator version of that there are ways
we can make this a bit more fancy but
we'll just look at the basics so the
first thing you'll notice about this
function is that we have the regular
function keyword but with an asterisk
after it that's an indication that this
function is actually a generator
function the reason we need it is
because the yield keyword that allows
you to yield a particular value is
actually not a reserved word in the
current in akma script 5 and earlier so
there needs to be a way to distinguish a
regular function body which can freely
use yields an identifier from any other
type of from from a generator function
in which this has a special meaning so
you can see that here were initializing
two values up two variables previous and
current this is using an example of the
destructuring assignments attacks we'll
cover that in this presentation as well
because it's also one of my absolute
favorite features in the language and
then we enter this infinite loop now if
we were exes were not a generator
function if we were if we were to
execute this function outright what
would happen is that our interpreter
would meet would see this function and
set up a stack set up a stack frame for
it set up any execution context which
could bind variables and begin executing
it and because they have an infinite
loop in it that function would never
stop it would consume all of your CPU
and there would be no way to get out of
it short of either force quitting a
browser or killing your process in the
case of note but a generator is
different a generator indicates the
engine that we don't want to immediately
execute and evaluate this function in
its entirety what we do is the is the
engine will continue executing each line
as normal but then it encounters this
yield statement and the yield statement
is meant to up is meant to take the
current state of the function so
whatever in this case what every bit of
state we want to pass it and gives it to
a resulting generator object so when we
invoke the Fibonacci function we're not
going to get any the return value that
we get is not going to be the final
return value since it's an infinite loop
or an example of an infinite sequence
there isn't a
value that we have instead we'll get
back is this generator object that
allows us to interact with the internal
state of the generator and as I
mentioned previous slide those two that
general object has two interesting
methods on it next and throw so where
you you can also see that there is a way
for that function to pass back any state
that we want to modify so if I didn't
have this I have this line saying it
declaring this is reset variable taking
it and then using it to reset the state
of the generator if if the parameter
this past is a truth eval you now there
is no reason there's no reason for me to
I need to capture this to capture this
information I could just have a yield
statement used directly without any
assignment to it and in our case the
function just continued yielding
Fibonacci numbers but being able to pass
back values to the generator is quite
interesting as we'll see soon so you can
see though that yield also returned and
by allowing us to modify the state of
the generator we can we can use it to
follow up some additional patterns so
here's an example of using a Fibonacci
function you see that we get back a
generator and when we call next on the
generator they basically just step to
the next instruction code we get back
this tupple of containing a value
property and a Don property the done
property is always a boolean value that
indicates whether the generator has
finished executing because we're in an
infinite loop to generate an infinite
sequence the dumb property in this case
will never be true it'll it'll always be
false because there will always be more
items to consume so you can see that we
call next ones and we get the value one
you would call next again and we get the
value to the third element of the
Fibonacci sequence but then we pass back
this parameter called true in it glitch
is then assimilated by that general
function and bound to the is reset
variable we because is reset is not
truth value this indicates the generator
that we want to reset its state back to
the beginning and finally there is a way
that we can have it throw an exception
let's say that we give an error object
with an exceptional condition that yield
statement will be transformed you can
think of it as that yields name being
transformed into a throw and then once
that exception is thrown its propagated
until the first until the first catch
block that catches it inhales the
exception appropriately but Fibonacci
numbers aren't particularly interesting
right unless your Angus writing another
blog post or unless you want to write a
Fibonacci server benchmark for nodejs
you'll rarely want to use a few barrace
sequence in your production application
but this ability to suspend execution of
a function has some interesting
applications namely what if the color of
next and throw could resume execution
when an asynchronous function completed
how many of you know what's coming next
no one yet awesome promises hahaha yes
but the point is is that promises are
just one pattern for facilitating
programming and the reason I pick them
is in facilitating a synchronous program
and the reason I picked them as an
example is because a promise is meant to
parallel asynchronous code is matoub
make sync asynchronous code parallel the
synchronous variant and asynchronous
function can do one of two things it can
either return a value or it can throw an
exception so and as you saw with
generators we can either pass back
values to the parent January function or
we can have it throw an exception at
that current position and have it be
caught by a catch block so the library
that I'm going to be using for this
example is Chris Cole's key library but
that's not the only library that works
with generators if you're using node T
Shahala Chuck Vision Media has published
a library called co which you can look
at on github that's built entirely
around generators and it supports both
promises and thunks so if the constant
promises looks confusing or you just
don't want to use it and there are valid
use cases for not wanting to use that
pattern you can still have the benefit
of generators and have a return special
thunks instead the reed knees are
incredibly comprehensive and will out
and we'll take you through setting
pure generator objects but let's look at
an example of using q2 to map
asynchronous operations you can see that
in imagine that this is some kind of
handler in some kind of wrap hands lurk
in our business logic i'm using the
happy j/s framework in node how many of
you have used happy or are familiar with
it okay so it's a regular htp framework
itam allows you to you can access the
request payload you can access the you
across body even request payload and you
can have your handler execute some code
and then return a response that then
gets sent down to the client so we're
doing here is we're defining a create
account function and at first what we
want to do is let's say that our our
post body has two fields a name and
address and we want to enforce the
uniqueness constraint so that an account
cannot have both so that an account will
be associated with one address so the
first thing we do is we have we call a
get by address method imagine that
account is a an abstract model class we
invented and then we have it we give it
the address and then we wait for this a
sync operation another way to think of
the yield keyword in this particular
instance is overloading it to mean wait
so we have this account object and let's
say that our account object is promised
where their returns a promise that you
can consume and then at some point at a
later point it retrieves the account
model or throws an exception if that
address if that account was missing so
if the response code is 40 is not 404
then we want to rethread right it could
mean that a connection it mean that we
had a connection error it could mean
that we passed it an invalid address
there are multiple use cases for that
and then we can have another handler
catch it and return a nicely formatted
error message to the client if the
response code is a 404 though that's
what we want in this case because that
means that our address is actually
unique so and at this point just to
confirm if we did get an account back it
means that we don't it means that we
don't have a unique address and that we
need to throw an error and someone
inform the user that the address is
already in use now if we don't have an a
yet then we create it we create we
construct a model class we update it
with the payload properties and then we
make another yield call that allows us
to save the account in the background
now remember I mentioned earlier that
promises do not that suspending
execution does not mean blocking the
thread so we have our handler in this so
you have our route handler in this case
and our server can continue handling
other requests and looking up say in
this case fulfilling other account
registrations and when a particular and
once the request resolves who are able
to continue executing through this
generator function until the end so that
was so that's an example of a program
pattern that you can use in your code
and that doesn't require you to make
significant changes as I mentioned with
co it's very easy to adapt existing
program patterns node to make them work
but now let's move on to talking about
the collections API in excess script 6
atmos crypsis gives you four new
collection types a map a set a week map
and a new one that's been added recently
called a week set and collections
address some of the pain points about
manipulating data in JavaScript
currently the only two data structures
that you really have our arrays and
objects or the two fundamental data
structures on top of which you can build
your own abstractions but the big
benefit of using collection is that all
of them finally supports sub-linear look
up times this means that you can have
real stats and real maps that are that
have any key assigned to any value right
one of the weaknesses of JavaScript
objects model is that all keys are
strings currently which means that if
you wanted to store if you want to
associate a key with a value you will be
restricted to using a string identifier
or it would be just cast to a string and
then produce unexpected results so with
collections you get subtle in your look
up times of a for regular objects it's
incredibly it's incredibly convenient
pattern the other point is that maps and
sets have a predictable enumeration
order if you use a for loop over a
regular Java scrub jecht that order is
actually implementation dependent there
is nothing guaranteeing that iteration
order so with we can't
change that because we can't break
existing behavior of libraries but we
can at least develop new collection
types that enforce a particular
enumeration odour an example sets is
that you can remove duplicates in linear
time currently one of the only way to
really have a a set in JavaScript or two
unique if I an array is to construct a
new array iterate over one Ford at push
elements in here results ray and then
every time you encounter an element in
that original you iterate over the
results array so n square complexity in
order to retrieve in order to create a
unique set but because we have real sets
now rather than using a rather than
arrays that just happen to contain
unique values it's incredibly easy to
write to write a function that unique if
I is a set in a single line and that
accomplishes it much more efficiently
and finally week maps and week sets can
use weak references to allow for garbage
collection maps and sets have strongly
held references so this means that while
that object is holding on to a reference
for a particular item it can be garbage
collected now this so this can be
painful we'll say for example when
you're developing an element storage
engine J queries element storage engine
associates a identifies every element
with a unique appends a unique
identifier to every key just to use
jQuery as an example and then uses that
as a lookup table in an object literal
to associate some data with it the
problem is when that element goes away
that data is kept around in memory and
or if you're just holding onto those
references by default even when you've
removed an element from the Dom there's
still that one copy left of it you're
holding a reference to it and until you
either explicitly clear that reference
until you its litera reference there is
no way to for the garbage collector to
be able to collect it so let's write a
leak-free element storage engine using
week maps jquery actually has a clear
migration path for this which is what
which is one's reasons why i picked week
maps use this example because they work
incredibly well for being a
take an object in this case an element
see if it exists in our week map and
then assign some storage to it now for
our storage engine we're using a regular
map we're not using a weak Mac because
we want to keep that element data round
so this is an implementation of the
store function that allows us that will
allow us to give it an element some key
which can be any object remember now
that we have real maps and a value to
associate with it we then make sure that
the element is in our storage map and
then simply set its name and value
appropriately so we can use the same
pattern for retrieving and deleting keys
and again because we're using a weak map
the element once the element is garbage
collected all of the associated element
data for it will be deleted so you're
not leaking memory and preventing your
garbage collector from running to
collect all these phantom references
that you still have references to so
weak maps are ideal for use as a global
private data store you can have a single
application or a nod or an i know'd
module use a weak map to store a lot of
private data without incurring any
excessive memory usage but there's
another even better solution for storing
private data directly on an object and
those are symbols symbols give you
unique private object property names and
they're a memory efficient alternative
to the revealing module pattern right if
you today information hiding in
JavaScript isn't very practical either
need to prefix your properties with a
leading underscore which says this
property may change later but does
nothing to prevent users from actually
using it or or you have to use the
revealing module pattern and create a
closure for every single instance do you
create and that is incredibly wasteful
for memory so now information hiding I
is not necessarily something that's in
finish writing can be important because
it allows you to move your public API
forward right you can change your
underlying API as much as you want and
as long as the public API remains the
same users code users can migrate the
latest version of your library and keep
using it without being none the wiser
that you had any
changes to it and symbols allow you to
have that private data so that you can
store as much as we need to on your
objects and not have to worry about
users modifying it in unexpected ways
and then encountering issues when they
upgrade and their code breaks to
accomplish the use of symbols versus
regular strings for keys the square
bracket operator that you would use for
accessing Jessica Parker name has
actually been upgraded to distinguish
between symbols and strings now it can't
be upgrade to distinguish between
strings than any other type of object
because there are developers that are
relying on that behavior but symbols are
a new type so we can change it and make
this one modification a good example of
this is an OAuth client let's say that
you're writing off client implementation
there are three particular bits of
information that an offline instance has
to keep track of the base URI the client
ID also called the consumer key and
that's the end a shared secret was
called the consumer secret now all three
quests are particularly interesting
because every request has to be signed
there's a signature bass string you
construct with the base URI and the
token the token identifier and then you
sign it with a with a pair of shared
secrets so you don't want users coming
in or you don't want to give this to
untrusted code so that it can modify
values and then have your request
completely fail because you're
overriding instance parameters so what
this allows you to do is to have
guaranteed private storage you just
store the base you I the client
identifiers and the secret as private
names and here you construct a new
request you can start a new instance of
a request object imagine that request
lives in it's in a separate file that
returns a signed request with the given
credentials so again it's a it's a clean
way to allow you to attach bits of data
objects without worrying that users
might take it and modify it come to
depend on it and then you can't ever
deprecated it or move your API forward
the next pattern that I'd like to cover
is destructuring assignment d
structuring time is one of my absolute
favorite patterns and it's been around
since firefox to early two thousand four
so it's been a long time coming
in arriving with this language and it
makes it possible to extract data from a
raisin objects using a syntax that
mirrors the construction of those
objects right so I'll show you an
example on the next slide that
illustrates kind of what I mean the
other use case for Destruction
assignment is that you can now swap
variables without ever needing to incur
views of a temporary variable so no more
VAR TMP equals a and then swapping bna
there's no there's no need to use that
pattern you can also now parse complex
structures in a single statement and
this makes it possible for objects to
return or this makes passport for
functions to return complex structures
that can then be dereferenced in in one
go and now it also makes multiple return
values or things that you consider
multiple return values either as part of
an object and rate a lot more meaningful
right previously if you if your function
return an object you wouldn't have to
manually dereference its fields no
longer and finally G structure
assignment has a syntax for allowing you
to specify default values for arguments
one of the previous syntaxes had a
feature called refutations that has been
removed from the specification but
default values are a nice compromise or
a nice feature that that has made their
debut in the end and you can use this
for simulating named arguments echo
scripts X does not have formal named
arguments they can use this syntax to
approximate them and I'll show you how
to can do that first some rudimentary
examples of destruction assignment the
first one is importing two functions
parse and stirring fight from adjacent
object and now by writing so you can see
that the syntax here mirrors it quite
nightmares the construction of the
object quite nicely if you were
constructing any other object you use
the braces and then keys in order to
indicate the property names and now you
can dereference them in much the same
way it's very symmetrical the second
pattern shows you an example of
executing a regular expression on a
string and then pulling those values out
so in this case we're taking a us-style
formatted phone number and then matching
it on some phone perhaps one of the user
gives us but we also have a non
participate in capturing group at the
beginning that surrounds the area code
so the area code is optional and in this
case if the user doesn't specify the
area code if they just specify a number
directly then we want the area code to
default to 415 san francisco and this is
the syntax that you use for default
assignments just us provide the
identifier with an equal sign and then
the default value that you want to use I
should also emphasized that the
structure Simon only currently works on
objects so if you try to destruct your
null or undefined then or even a
primitive you would have you throw an
exception think of how JavaScript works
day if you try to access a property of a
null or undefined value it'll throw an
exception so this the same design
district assists the third example is
reversing your of two parameters and
let's look at the last one lesson is
interesting this is actually a full
function definition in Equus crypt six
using the new arrow syntax what we're
doing is we're defining a get headers
function that takes a node style request
object and there in node each request
object it represents HP request and it
has a property on it called headers that
contains those HTTP request headers so
we're doing this case is just simply
pulling those headers from the function
again you didn't necessarily need to
write a function for this but I just
wanted to show you how you can use
destruction assignment in as part of an
argument and where I am now that you
have arrow functions you can create
these incredibly compact expressions so
let's look at a more complex example to
addy structuring an entire an entire
object of information let's say that you
get this the data back from from your
server it comes down the wires JSON you
deserialize it and then you want to
print out information about TS Eliot's
poem Rhapsody on a windy night so in
this case TSL is the first element in
our poets ray the Cyclones Ezra Pound we
don't care about him for now but um and
wraps the movie night is the second
element of Eliot's work so you can see
that we have an array of two elements
this array contains two objects with an
name and works properties and works is
itself an array with containing objects
of title and day properties that's quite
a complex nested structure and you might
be and in current let's even though it's
very semantic and explicit you might be
tempted not to use something that's this
intricate just to avoid having to
dereference that when you parse it but
now it's incredibly easy to do that we
have this variable declaration here and
we're dereferencing the first element of
our poets ray in this case Elliott were
taking the value of the name property
and assigning it to the author variable
so the example I was trimming previously
was dependent on if both the object and
the variable that you want to bind a
property to have the same name you can
also pull them from different names so
you can take the name property and
assign it to an author variable we're
also notice that we're also going into
the works array we're using an illusion
which signifies that we want to omit the
first element into structuring and take
the second one which is Rhapsody then we
we then bind it up into a template
string I'll talk about template strings
in a bit because they're also incredibly
useful features language so we're using
this writing out the title of the poem
and its publication date and the author
and just like that in two lines we've
parse this complex structure that our
server has sent us so it's a pattern
that I think will make writing this kind
of code incredibly convenient also the
default parameter syntax is useful in a
in an API like nodes request module
nodes request module can accept an
options argument that has all these
different options you can send the
request you can set the method the query
string the headers the payload either
stuff side as a form or as JSON number
of max redirects whether use cookies and
these are just ones that would fit on
the slide there is a plethora of options
you can pass to it but before net but it
can get very tedious to have to
reference them from within the function
and writing default parameter and
writing default values for every one of
these parameters the method is gat if
it's unspecified if it is specified then
use whatever these are passed in it
madness writing that there are if you
use a library like load Asha underscore
it has a default method that can
accomplish this but now you have a
language level constant does it specify
default parameters you can also see that
in addition to providing default object
properties or a makeshift named
parameters we have default grammars so
if you don't specify a you are a request
URI it becomes just the empty string now
in this case note on the request module
will throw an exception when it finds
that because the empty string is not a
valid URI but it's a convenience example
of being able to provide multiple of
being tried multiple default values for
functions again these are features that
other languages have had for some time
and that we're now getting in JavaScript
that'll allow us to make our API is more
expressive rather than simply have to
re-implement this code repeatedly in
user with magic or have some third-party
library handle this on the line of
destructuring assignment are on
knowledge destruction time is also the
shorthand syntax and there are two forms
of short have syntax for initializers
and method definitions the first one I
want to show you is for object
initializers in this example we have two
variables name and occupation and then
we're constructing object from them with
name and occupation properties that are
bound to those to the variables it to
the values of these two variables but
that's bit redundant right we have we
already have the name and occupation
variables that are sufficiently
descriptive and only to have to read
eclair them again as property names and
as values that's too much typing so what
we do is we can cut down on this end and
just define a person as containing the
name and occupation variables so the
values of these variables will be
assigned to the property names will be
assigned to the property values and the
names of these variables will become
those property names so these two
examples produce an identical result but
you can see how much it cuts down on on
repetition the second syntax I wanted to
cover our method
missions and in this example i'm showing
you both a shorthand math definition and
some other parts the atmosphere ppi we
already cover template literals getters
were actually present in equus crypt 5
i'll illustrate how not illustrate how
the shorthand syntax meshes nicely with
them and we also have a setter syntax
that uses a new API method but let's
look at our definition of the speak
method this doesn't look like a valid
JavaScript right where's the property
name there isn't one we also don't have
the function keyword instead the
function name in this case speak serves
as a services an indicator that you want
to declare a method so this syntax works
within object literals and it allows you
cut down on typing one of the criticisms
that JavaScript has received is that
despite being a functional language and
while allowing to declare object
oriented forums it's incredibly verbose
for both right you have to you have this
function keyword that you need to type
out and if you want to bind a property
to an object you have to use that
property explicitly and then name the
function again it's it's needlessly
repetitious and equus crim 6 fixes us by
giving us this lovely shorthand form the
next two features I wanted to cover work
best in unison first up is spread spread
allows you to expand the value of an
array of arguments without altering to
this context you can think of it as a
better function prototype apply but
function apply has some weaknesses
namely it can't be used out of the box
with constructors what you have to do in
that case is to create is to define your
own intermedia constructor call function
apply on that and then it doesn't work a
native objects and it's a mess so it now
so we now have a syntax for unpacking an
array of arguments and applying it for
in stanching both for instantiating a
constructor or for calling a regular
method it's also a great syntax for
merging arrays and ray like objects as
well as casting any object with a length
property an array-like object into a
real array i'll show you some examples
of this syntax rest is the spreads
counterpart it provides this natural
syntax for very attic functions
and it's a nice replacement for the
arguments object currently the
JavaScript arguments object is array
like in that has length property and
numeric indices but it's not an array
you can't call array methods on it
either have to you need to convert it
into array or just use a regular for
loop over it and arguments can be quite
magical let's say that you have nested
functions because it's a because
arguments is local to a particular
function you can't reference say a
parent functions arguments variable so
rest allows you to work around that it
also always returns an array even when
parameters are emitted so let's say that
you have a function that can accept any
number of arguments and you just don't
give it any at all that was the value of
the rest parameter is going to be an
empty array not undefined not null
nothing that you can't accidentally try
to error it over and then have a throw
an exception our rest is also only valid
as the last round or function if some of
you have used CoffeeScript this might be
it might be rather odd because coffee
skirt allows you to specify a rest
parameter anywhere within the arguments
list this is primarily done so that you
don't have to worry about collisions
between rest parameters that need to be
soaked up in an array and then optional
trailing arguments so let's look at a
comprehensive example that kind of puts
all this together this is a function
that takes a node style request object
and parses the authorization header as a
base as basic authentication so
basically is the string basic followed
by a space at the base64 encoded using
name password concatenated with a colon
so what we're doing in this case is
we're taking we're using the g structure
assignments attacks to extract the
authorization header immediately right
in the tub our function we then parse
the scheme and the components there can
only be one component or so if the
scheme isn't basic or you have multiple
space separated tokens in that header
then it's invalid we return null
immediately we then take those
components and then in node decode them
as base64 and convert it to a utf-8
eight string that we can parse we then
check if it contains a colon character
contains is a new convened string method
in
script 6 so no more string index of a
value is greater than equal to negative
1 or using the leading tilde the bitwise
not to a coercive 20 so no you no longer
need to do that you have the contains
method you then execute a pattern over
those credentials and we use name and
password default to the empty string if
they're not provided so we parse this
header and we return this object for us
and then you can take that and your
application can authenticate the user so
this looks very JavaScript key right
there are a lot of syntactic additions
to it but if you were looking at this
you would be able to recognize it as
JavaScript I think this is where a case
where equi script six really shines in
giving you this syntax that extends upon
existing patterns but that still retains
the familiarity of the language so the
next concept are tagged template
literals which you've seen throughout
this talk template literals are back tip
delimited multi-line strings with
embedded expressions within them and
those and they're kind of useful because
we can pass handlers that can perform
additional string processing on it now
by default being able to do string
interpolation is kind of useful right
it's it's nice to be able to not have to
do manual steering the catenation but
what we can also do is because we have
app because this handler has access to
both the raw string components they were
used to build up the template literal as
well as any expressions that were
interpolated in them we can build our
own extensible templating languages on
top of this it also makes it easy to do
contextual escaping now on this next
slide where I show a simple HTML escaper
I don't have it be content I it's not
context-aware sadly but what we're doing
is we have in our template our tag
template helper sorry has a object that
has an object that we give it values
it's an array that has a raw property
and then we're soaking up the remaining
substitutions which get which get passes
very attic arguments we're then
iterating over each raw value checking
to make sure that we're still within the
balance of our substitution and then
interpolating those substitute
since this is an HTML escaper what we're
doing is we're taking those is wrecking
windows substitutions and replacing the
ampersand angle brackets and quote
characters now in a this is the
rudimentary version of the escape
function it's implemented by most
popular libraries and as you can see
here at the bottom we can we have an
input called name say some untrusted
user input like containing a script
element and that what we can do is we
prefix the handler function to the tag
template literal so that gives us back a
string with its contents escaped and you
can use this to build a
context-sensitive HTML escaper right
there are different escaping out or
escaping rules for attributes versus
element contacts or let's say that you
wanted to allow users to specify some
HTML tags but not others this can also
be incredibly useful if you're writing
if you're working with a database that
allows the past query strings for
instance at Black Pearl where I work we
use the dot we use the Cassandra
database which uses a query language
called cql so anytime you interpolate
query you interpolate untrusted user
data into a query string you have the
potential for injections in this case no
SQL injections oddly enough but
cassandra has a lot of escaping rules as
to how as to how it interpolates those
values and now you can pass in those
about and now you can pass in the input
and then have it be escaped based on the
surrounding context so something that at
first last doesn't seem attacked on the
road seems like a useful syntactic
convenience but it has quite a few broad
applications another feature is block
scope this is one that I think a lot of
us have heard about that we've been
excited about and that it's one of the
more confusing points for people who are
first coming into the language so the
fact that VAR is actually a scope to a
particular function or the global scope
rather than scope to within a block so
blocks cope with a let and const which
is the constant version of the console
version of let gives us our real la
block scoping semantics and gives us
real constants they cannot be reassigned
once they've been declared
let also introduces meaningful semantics
locks currently you can have a bear
block in JavaScript but it's not very
useful you can't interpret there's
nothing that you can accomplish within
it that can't be done by simply removing
those braces now that now that we have
lat though it actually allows us to use
those blocks in a meaningful ways
function declarations are also now
supported within blocks so previously
this is an error in Equus script 5 and
earlier now this is a standard I syntax
that you can use to affect so one of the
most popular examples to use when
introducing people to the problem with
the with Lex with the non lexical VAR
keyword is this idea of declaring
functions within a loop right because
that variable gets hoisted to the
containing scope it'll point it'll
reflect the very last value at the end
of the loop in this case let's say that
we're writing a Dom library and we're
defining two methods get with and get
height and we're discriminating on
whether use width or height based on an
index or based on the current value of
the counter variable a rather contrived
example but the fact remains that if you
were to call get width on it because
with was the first element which then
was overridden by height remember that
variable got variable got hastened it
means that both get wit and get height
will return the height of the element
that's not what you want and there are
various workarounds you can use you can
declare your own closure with an loop
just use an immediately invoked function
expression you can also use a weird work
rounds with width or using the catch
block of a try-catch statement just
exploiting some semantics in the
specification those aren't very workable
and they will increase lines of code
that you have to write what's the ESX
solution to this one change change the
VAR to a lat and now you have real box
hoping and yet with and get height will
return the correct values that's really
all there is to it so some gotchas with
the syntax though first of all you
because blocks now have meaning
attempting to declare a let attending to
declare a let or const binding within a
block that within an implicit block is a
syntax error they actually have to be
nested within real blocks the second
example here is a syntax error because
we're Rida clared constant right and
this is what you want in if you try to
reassign the value of a constant things
are aren't quite as explicit if they're
they little silently fail in non strict
mode in strict mode it will throw an
exception so in both cases you have real
constants that immediately alert you if
you're trying to do something that you
didn't anticipate earlier also the last
example is variable variable bindings
with the VAR keyword have to be
different from let and cons bindings you
can't declare a variable and have a
shadow a constant or a constant or a let
declaration that will immediately throw
a syntax error and the final bit that
I'd like to cover our arrow function
arrow functions are a convenient syntax
for declaring of for declaring lambdas
it's something I mesh earlier that one
of the criticisms been leveled against
javascript is the fact that for being a
functionally influenced language it has
an awfully verbose function operation
syntax let's fix that so in this case
I'm calling the filter method filtering
out the value and then retrieving just
the odd numbers from an array of five
five numbers of them as you can see I
don't have to put any parentheses around
a around the first argument I can just
simply declare the value the the arrow
symbol and then the expression and this
expression is implicitly returned also
if you have that kind of structure just
a single value expression you don't have
to surround it in blocks to show you
what you can though and this example
rather contrived one for which I
apologize illustrates that nicely what
we're doing is we're declaring a
function without any parameters right
arrow functions can you can only emit
the parentheses if you have one argument
if you have no arguments or more than
one you have to provide the parentheses
there's been some discussion in the past
as to whether to allow you to use bare
arrows directly so if you don't have any
arguments you don't have to put any pair
of parenthesis this function then
returns an object we're wrapping it in
parentheses to disambiguate it from the
blocks that has a two-string method our
to stir method accepts no arguments at
all but then has a block that has an
explicit return right in this case the
return is implicit since we now have a
single expression here we don't have to
add the return statement but it is
definitely possible to do that and in
the cases of having a.m. and error
function with multiple blocks it's
actually required and then if we take
this object that has a or two string
method and we in if we take this
function that returns nacho tutoring
method and invoke it we can obtain the
value by castle a tostring correct I
know so in this case we're iterating
we're iterating or the values so
the even number yeah oh I see what
you're asking okay yes so we don't need
20 in javascript is consider to be a
faulty value so in this case any money
so in this case any number modulo 2 is
going to be 0 and 0 gets course to false
the filter method invokes this function
and then it it uses it does a simple
boolean cast on the return value so we
don't have to explicitly return true or
false we can return something that's
false e so empty string 0 null undefined
or we can just have it or we can use the
implicit cast does that answer your
question okay sorry arrow functions are
also interesting and they mirror the
semantics of bound functions in practice
this means that they're equivalent to
calling function prototype bind on a
particular method they distance that
they don't have a prototype and they
can't be instantiated as constructors
trying to do that will be a type error
so just something to be aware of syntax
so we went incredibly fast today I'm
really sorry for not nothing to spend
more time on some of these or being able
to talk about some of the other
fantastic features that we have but i
think the thrust of this talk has been
that there is something in the language
for absolutely everyone there is a new
convenient shorthand syntax to cut down
repetition there's improvements for
tooling their data structures there are
improvements to modularity of classes
and modules and there are core
refinements so when can you get your
hands on some of these features Firefox
and firefox aurora have supported many
of these features in fact firefox's
implementations since the beginning have
been one of the inspirations for Agnes
crypt sex they're also available in
chromium and chrome by enabling the
enable experimental JavaScript option in
about flags and now in node you can
start up node with the harmony flag that
allows you access to early harmony
features a lot of these are if you're
interested in whether particular
environments support those features king
acts URI sites of has an excellent table
of
various implementations and the and the
features that they support but there's
one more thing you can't expect your
users to be able to enable those
external features if you're targeting
toward developers then yes definitely in
fact it's quite likely that those
developers will have already enabled
those parameters and if you're running
node it's easy to pass flags to your
server process but your user can't
navigate to a page and then see that we
wanted to we wanted to make our
experience very good for developers so
to do so because of that we decided to
only opt-in to echo script 6 which is
reasonable in and of itself but in order
to do this you have to go through these
steps to enable experimental flags and
if you go to baptizing chromium there's
this big warning at the top that says
enable these at your own risk and so
when users are going to this and there
and they see every single indication
they should not be doing this it's very
very difficult kind of to retain their
attention and they'll probably leave if
even if they take the time to read
through that through the instructions
they'll probably leave once they realize
just what is you ask them to do so there
are a couple of ways you can experiment
and use a transpiler building on
languages like coffee script or
typescript to compile atmospherics code
or anticipated atma script six editions
to echo score five code the first one
that I have up here is 1i particular
enjoy it is not actually a transpiler it
is a virtual machine that's implemented
in existing excellent atmos code five so
provides a full run time that allows you
to experiment with aetna script six once
you've if you're if you're interested in
actually taking or writing atmosphere
sucks code and converting it to
atmosphere five you can use the
excellent tracer compiler that's
provided by Google and finally if you
use browserify in ode to package your
assets there is a great extension to it
called es6 if I that uses tracer under
the hood to compile equi script six
files and serve them down to the client
and in its in a syntax is compatible
with existing atmosphere five efforts
I'll be posting the slides afterward as
well so if you haven't caught some I see
some of you trying to write down the
URLs if you haven't caught near else
here then
I'll I'll be able to post them then you
can access them there so I think at this
point it's in akwa script six is growing
incredibly quickly and it's a wonderful
opportunity to be able to be to be able
to follow the language as it as it
develops now what are some if you like
to be involved in watching language
proceed you can either follow the es
disqus account on Twitter it's
maintained by dominic de Nicola who's
been very active in the ACMA script 6
efforts he's also the author of the
promise of specification that I
mentioned earlier you can also catch up
es discuss org forbes lindsay has built
a wonderful front end to the es discuss
mailing list that allows you to parse
some of the messages in detail if you're
interested and on that note I'd like to
thank you all for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>