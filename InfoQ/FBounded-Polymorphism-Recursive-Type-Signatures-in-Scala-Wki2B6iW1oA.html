<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>F-Bounded Polymorphism: Recursive Type Signatures in Scala | Coder Coacher - Coaching Coders</title><meta content="F-Bounded Polymorphism: Recursive Type Signatures in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>F-Bounded Polymorphism: Recursive Type Signatures in Scala</b></h2><h5 class="post__date">2015-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Wki2B6iW1oA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay hello everyone
that just got started here okay so my
name is Marconi and I work for
originated I am before I start last
August I had the opportunity to meet
dick wall in San Francisco at scallop at
the Bay and I was telling him that many
years ago when I was learning English I
downloaded every single episode of the
Java policy and I was listening to the
Java policy four or five hours a day it
was a very important tool for me to
learn English so if you have any problem
durst and my accent blame it on deck
it's totally his fault so yeah I'm gonna
talk about F bounded polymorphism and
thank for the guy who didn't spoil my
talk recursive type signatures in Scala
and I would like to use the opportunity
to thank my good friend Andrew at
originated who wrote most of the content
that I'm going to present here today
okay so raise your hand who has ever
seen a type signature like this one
trait tu it stands to you okay yeah the
ones who did not raise the hand you
should have because even Java has them
so you have something like enumerations
in Java that they are parameterize and
they extend the numeration and on the
same parameter so this is called F
bounded polymorphism and you may also
see the names like self-referential
types recursive type signatures
recursively bounded quantification and
so I got this from the Wikipedia page
I'm not going to read that the important
thing here to know is that it's an
interaction of parametric polymorphism
parameter polymorphic is a fancy name
for generics with subtype and so if you
have generics in an object-oriented
language
all object-oriented language have
subtyping or most of them have so this
is something that you can use with
object-oriented language and generics
and F bod that went fishin is when the
constraint the subtype constraint itself
is parameterize by one of the things you
know that are on the left hand side what
that means is if I have a type A in a
parameter B that B is going to be a
subtype of a itself okay what wikipedia
is not going to tell you
it's why it's called F bounded
polymorphism but don't worry because I
will also not tell you because I I just
have no idea why they call this F
bounded polymorphism I don't know it
could be called he bounded gbaud and ax
bounded I have no idea if anyone knows
the answer please taste and brace the
hand I would love to know why it's
called F bounded okay so how I see it
for me this is a very powerful
object-oriented technique that leverage
the type system so we can encode
constraints on generics so why our
generics do not grow true while so we
have some advanced its type semantics
they're enforced by the compiler over
classes and traits and just a hence type
safety and at the same time and this is
what I love the most about them is that
the number of unit tests that you have
to write to test your code they can be
greatly reduced because there would be a
lot of things you're not going to need
to test because the compiler you ensure
to you that they would just work and
your tests get simpler so this is the
main reason my main motivation for using
I've bounded polymorphism okay but what
the heck does it do after all but why
can I just use trait to you know even
better just 3t
well let's learn by example here I think
it'd be a good idea let's suppose that I
have a database and you know I have
entities and some crude methods we could
define them something like this so I
have a class a PO and I have a class
Orange and they have methods for create
read update delete that or take some
reasonable parameters and return some
reasonable things do not pay too much
attention to the methods themselves if
these were real things like read would
not be in the instance would be on a
companion object but this is not
important here just an example and the
problem is that the class they look
nearly identical you know they have the
same methods with very symmetric
signatures and if we are where to create
a new entity we would have to expose the
same methods again so let's abstract all
of that into a trade but let's start
simple with our little friend trade 3 ok
so I have a trade entity and then I have
create that returns an entity read which
may or may not return an entity and so
on some part and then I have a class a
po and a class orange and they both
friend entity there's nothing really
great about this code I'm not that
worried about the methods here you know
just going to define empty trades
because what I want to show you is if
they type check I'm really not worried
about the methods for now I don't spec
to surprise anyone with that piece of
code over there ok well this the method
signatures that we have on trade tea
they do not express what we want
they I cannot ensure for instance that
if I call update on an apple I'm gonna
get Apple
there's no guarantee in the type system
for that and other reasons I can return
any entity I want when I call Apple dot
update so let's try again and now we're
going to add a type parameter okay to
you getting that so I have again a trait
entity II and I have a Apple extents
entity apple and orange extents entity
orange so let's run this code here and
again I really do not spec anyone to be
surprised it's better than what we had
before but it's still not good and the
type do not yet Express exactly what we
want do you see the problem well and the
problems that entity can be extended in
unintended ways okay there is nothing
forbidding of having class orange
extends the entity flying saucer and
just to show to you I have a class
flying saucer yeah it's durable and now
orange extends flying saucer doesn't
make any sense so how the problem now is
that entity does not restrict the type
of e I can have any and anything could
be used
there's no compiler errors you know I
just compiled the code and you saw the
output the compiler was very happy Jesus
no boy I know by the way I speak
Portuguese not Spanish you know we want
a big fat compiler error if we try
something other than orange extends
entity orange so how to ensure that
Emacs its class
five pounds of course of course whoo how
could I forget
and finally we arrived at trait tu
extends tu which is the whole point of
this talk so let's try again be careful
now oh I'm sorry
so I have a trait entity II extends the
entity II and everything as usual let's
see how this guy works
portes compiles nothing nothing wrong
okay it's better we have constraint that
he has to be a subtype of entity no more
orange extending flying sauce and I can
show you that if I try to extend flying
sauce I finally get a type error here
but there is still one last problem
there's always problems I don't think
you so can you guess what it is in our
good friend there just gave us the
answer I may have a class Apple that
extends apple and orange can extend
Apple so just to show you that the
compiler will happily accept it I just
did it I created that class orange
extending Apple okay thank you sir so
it's not ensured that II met it on type
it can be any entity okay and the trait
is to open for abuse we are getting
there getting there okay we need a way
to ensure that orange extends entity
orange and nothing else
soft apps of course self-types who could
not think about it so this is what we
need okay we need the trade entity e
extends entity a with the self type E
okay so the soft type II ensured that in
class that extends entity is of type in
I believe I should show you here okay so
I have my class here as I said in a help
extent Apple just as I wanted it works
but now if I try something like class
orange extents entity Apple what I'm
gonna get let's go back here so this is
my little guy and I get a compiled
finally I cannot have an orange that
extends an entity Apple okay so we can
wear a scarf that that our definition of
entity ensures that n sub type of entity
a is in fact an e so if you have a code
base you do not need to write unit tests
for every single entity in your code
base to make sure that create is going
to return the same kind of entity that
update is going to work you could find
those methods in a trade and just by the
type signature of the trade the compiler
will ensure that everything is fits
right in place okay so we have the same
etiquettes with desire and the compiler
will reject invalid code okay and that
was it for me
here are some reference and there's this
github I'm going to put this
presentation there it's not there yet
because usually I make some changes even
to the last minute all the content is
posted as a blog post a blog that
originated com you can go there and you
can read the article it's a lot better
than what I could do here okay thank you
all very much and do you have questions
order then how did I do it everything in
the wrapper okay that's a good question
so let me recover this light here no I
don't have
well okay so yeah so I I would say that
the self type of notation would forbid
that I would have to test I'm really not
not sure but it's a good question I'll
test it that that's variance I don't
think yeah it's a little but it does
work and after you learn it it makes
sense
yeah I first saw this kind of syntax on
Java file for the enumeration and if you
have the you know that Java book did you
have a programming language they're
going to say something like the type
theorist tell us that this is the type
it should be yeah I think this is you
know in that book this is the
explanation they give and I said okay
awesome
oh I have 35 seconds 30 seconds yes it
will be online on my github it's just a
little trick here something to fill this
crayon the wrap oh yeah you just press N
and P to to go back and forth between
these lights yeah
I'm abusing the wrapper
okay guys then thank you so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>