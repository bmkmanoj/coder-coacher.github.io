<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Hello, Brillo | Coder Coacher - Coaching Coders</title><meta content="Hello, Brillo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Hello, Brillo</b></h2><h5 class="post__date">2016-02-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ig9GKAFzDxQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">morning everybody okay all right good
good I like that
thank you all for coming this morning as
she said my name is Dave I work for a
new circle which is a developer training
organization I'm the Android lead over
there I deal mostly with training
Android application developers and we do
a fair amount of work with Android
internals and platform pieces as well so
what I'm here to talk to you about today
is brillo
just quick show of hands how many have
heard of brillo perfect otherwise you
probably wouldn't be here so what we're
gonna do today is we're gonna talk a
little bit about what is this thing you
know we've heard about it it's been
announced at Google i/o we may be heard
little bits and pieces over the past few
months another question for you how many
of you either were at or we're following
the live streams of the ubiquity dev
summit last month okay not quite as many
folks so a lot of the information for
those of you who were a lot of the
information I have here it might be a
little bit repeat but for the rest of
you it should be fairly new so let's
just talk a little bit about kind of
what we've got going on here so what I'm
going to describe to you today is what
is this thing that Google calls bro and
I've broken that into sort of three
primary areas here the first is that
brillo is an Android based operating
system okay now what that means is it's
really it's an operating system that
Google has provided it's a software
stack that is designed for embedded
devices or IOT Internet of Things
devices that is based off of the Android
stack it is not the same as Android but
they have the same common base and I'm
gonna go in to describe a little bit
more about what that means what's the
difference so on and so forth in
addition to that Google has provided a
suite of core services built into this
platform to help make it attractive more
specifically again to embedded in IOT
developers okay
in the Android world you could think of
this as sort of the separation between
AOSP and the Google mobile services that
are provided on most Android devices
it's not quite that separate but there's
some there's some similarities there and
then the last piece that I'm going to
talk about a little bit is security
security is actually really important
because specifically in the IOT space it
is extremely hard to do okay and it and
with IOT devices the concern of security
and privacy and and who can access
certain devices kind of goes through the
roof as opposed to any other computer
systems that we've had sort of to this
point so we're going to talk about the
the pieces that Google has put into the
brillo architecture both at the platform
level as well as within the services
that help to make that easier on those
who want to build products on it so that
you sort of get security for free you
get security by default without having
just to stay up at night and whether or
not or determine whether or not you're
come up with some sort of door lock that
just about anybody can get into allowing
others to break into people's homes okay
so those are kinds of the the three
things that we're going to talk about
here today okay so I mentioned that
brillo is based on Android
so how many of you have seen a stack
like this before a diagram like this
okay so this is a typical diagram of
what the Android software stack looks
like okay you've got some Hardware
specific pieces there at the bottom
things like the bootloader and the
kernel Android has some middleware
pieces there that are really more
specific to the Android platform things
like the hardware abstraction layer
which if you've never heard of that
before is sort of like androids and
device drivers this is what
manufacturers provide as part of an
Android device to make your camera work
your sensors work that kind of thing so
they have these device drivers in the
lair series of native services as well
as the application runtime so this is as
Chet mentioned in the last session this
would be your dalvik or your art this is
the runtime that the applications that
developers are writing in Java executes
inside ok and then inside of Android we
have the framework layer on top of that
which is all those Java frameworks that
developers are actually touching right
these are your activities your services
all the managers you talk to all that
stuff is built into that layer and then
a few core applications on top of that
so this stack is essentially what a
device would look like an Android
if you got it just straight out of the
box right this is the Android Open
Source Project on a Nexus device with no
additional user applications or anything
else installed there are still some core
applications built into the platform for
basic functionality messaging phone
browser all that stuff is in the open
source project as well and would find
its way on to a device so I mentioned
that brillo is Android based so what
would the brillo stack look like
compared to this brillo stack looks
something like that
basically all of that Java stuff is gone
there's no runtime there's no framework
and all those core applications that run
on top of that stuff has been removed
from the system hey this makes it
extremely lean but it also means that
all of those familiar SDKs that
application developers might be used to
don't exist okay and we'll talk about
how you would develop applications for a
system like this a little bit later on
ok and similarly in that sort of native
Services layer there are some things
that are still around but there are
others that were removed you know
there's a fair amount of native services
that only existed to support those Java
frameworks and so once we remove those
there's no need for any of that stuff
hooked to hang around now interestingly
enough when you cut out all that stuff
from Android it turns out there's a
couple holes to fill ok even just in the
system itself
and so while you may or me and so it
might be interesting to you that you
have probably heard in the press or
whatever that brillo is Android based
but it turns out that Android is not the
only platform that has code in brillo
there are several of these layers where
they've actually pulled in code from
Chrome OS and they did that for the
purpose of filling in those holes ok so
if you actually look at the software
stack and you pull down the code for
further brillo operating system you'll
see a number of packages that actually
came from the Chrome OS side most of
them living in the services layer to
fill in some of those holes left by
taking out the Java
framework so there are some connectivity
services and other things that
applications can use that they actually
pulled in from Chrome OS team because
they're written in native code and can
live without the Java Runtime okay so
there's a lot of that going on in there
as well as the entire bootloader
architecture is pretty much taken from
Chrome OS and we'll talk about some of
the reasons and benefits of them
choosing that a little bit later on as
well okay so that's sort of the
high-level difference between what makes
Android Android and what makes brillo
Android like okay so what about these
core services that they've added into
the platform that are specific to brillo
does anybody recognize what that logo is
anybody tell me what that is
we've right so the big one the one that
you've probably all heard about that
makes brillo unique I guess you will in
terms of it an operating system choice
is its integration with Google's other
IOT offering which is the weave protocol
okay so I'm going to talk just a little
bit about what weave is and what it
brings to the table in case you're not
too terribly familiar with it so we'll
start there so weave is a device to
device communications protocol okay it's
not specific to brillo it's intended to
be implemented across a wide range of
IOT and embedded devices but brillo has
it built in by default so if you choose
brillo you're sort of getting weave for
free okay but let's talk a little bit
about what it really is so the the weave
architecture provides three primary
things to developers of products that we
have a set of mobile SDKs that allow iOS
and Android and even on the web devices
to interact with these embedded devices
that are we've enabled they provide
device libraries to embed into those
devices and for example brillo devices
would be one of those choices but there
are others and they provide a layer of
cloud services that allow users from
their mobile device or from the web to
interact with these remote devices
whether it's locally device to device or
whether it's remotely using the cloud
and the API is in the library
abstract all of this away so that it
happens automatically and securely okay
so as I mentioned we have cloud API s
and the local API is available so that
users from their mobile devices or from
the devices in their home can interact
with whatever this embedded thing is
whether it's their temperature sensor or
their light bulbs or whatever it is
embedded with this functionality okay
let's talk a little bit about those
device libraries
I mentioned that brillo has we've
enabled by default but we've really does
live as a separate thing and it's a
library that can be included in any
embedded device providing it has the
appropriate support so we've comes in
two flavors
the first is Lib weave which is what we
would find is on anything that's an MMU
enabled device does anybody know what I
mean when I say that that term makes
sense okay so an MMU enabled device is
really any processor or system on a chip
that is capable of running a
higher-level operating system like Linux
okay if if the hardware can support that
it has an MMU which is a memory
management unit and this would include
devices running brillo so brillo has lib
we've integrated in automatically but
any other embedded Linux system that you
may have already built for an IOT device
could include lib weave in there as a
package as well and you could we've
enabled that device potentially without
using brillo if you wanted to go ahead
and do that so they definitely want this
to live on its own but those types of
devices are not what are essentially in
terms of numbers going to dominate the
IOT market right a lot of the Internet
of Things devices or connected devices
it will be in the home are going to be
much smaller much simpler devices they
don't need to have a full Linux stack
running on them right your light bulb is
not going to be running brillo it's
probably going to have a very simple
microcontroller in it or something like
that just to interact with the state it
needs to control so they've also
provided an implementation called Lib
micro weave which is intended for
microcontroller level devices so lower
level ARM Cortex processors things like
that okay so these are systems that
would have more direct access to the
hardware and you can integrate this
library into those devices to get them
we've enabled as well okay so they want
this to cross really the entire scheme
this isn't just something that's built
into Braille now both of these things
are also available and developed in the
open so you know even today even if you
don't have an invite into the official
program you can go look at the code for
weave for both lit weave and live
microwave at weave Beck local source
comm now a lot of these packages or
repositories that are in this project
are mirrored in the brillo project and
so that's how they get it sort of pulled
in automatically on that side but this
is where the actual development is being
done now I will say that if you're
interested in this live weave is much
more mature than microwave microwave is
still something that's kind of being
baked a little bit and it's very heavily
in active development so it kind of
works but they're still kind of moving
forward on that lib weave is a little
bit more mature ok so what is we've
actually give you as a developer of an
embedded product right so there's two
primary flows that I kind of want to
walk you through the first one is more
of a device level flow we provides to
you the ability to get your users online
with your device quickly okay so you
think of the typical flow if someone
were to buy a connected device off the
shelf today right they would have to go
take the device out of the box turn it
on or whatever find the instruction
manual figure out where to download the
app or otherwise connect to this thing
on their Wi-Fi network and do all of
this provisioning and setup using the
instruction manual and the device and
then that may or may not involve in a
mobile application and one form or
another it's a bit of a disconnected
process and it involves a lot of manual
discovery on the user's part one of the
things that we've attempts to solve is
to provide a discovery and provisioning
flow built into the device that works
automatically with people's mobile
devices right so whether you're on an
Android device or an iOS device if you
have the appropriate software to
provision weave devices then this flow
becomes very automatic you can discover
the devices set them up on the
appropriate
local network and that flow ends with
downloading whatever companion
application you might want to provide
them to interact with your device
instead of it having to start with that
process and having that application have
to have all that logic inside you don't
have to write your mobile app with a
bunch of code to actually get the thing
online
we've handles all that for you and you
can just write your mobile app to do the
interesting stuff at the end okay so all
that's built into the weave protocol the
device libraries in the client SDKs
similarly once the device is online
we've provides this sort of command
state architecture that allows you to
interact with these devices so from your
mobile device or any device that has a
client SDK on it you can view the state
of the connected devices you can send
commands to these devices to change that
state and then the device libraries on
those local devices will can are set up
to receive those commands modify their
internal local state and track all that
for you okay that all you really have to
define when you're building a we've
enabled device is the schema of what
this device is State should represent
what are the things that it exposes as
state so like for a light switch it
might be on and off for a light bulb it
might be on off and some brightness but
there are a number of predefined schemas
for common devices but this is
extensible you can define whatever this
is and you just publish that and that
effectively defines what the commands
are and what the state is that that
device can can manage so inside of that
the device can then manage its local
state but even more than that we've
ensures that that device is state is
synchronized and propagated to all other
connected devices simultaneously so
there the this concept exists in weave
where devices can subscribe to one
another so for instance I'll go back to
that light example my light bulb might
be subscribed to my light switch and
when I as a user send the command to
turn on my light switch we've will
automatically propagate that state to
the subscribed devices saying switches
turned on so that the light can react to
that for me okay all that thing Dov
updating maintaining and sync
State across all those connected devices
is done automatically and we've okay
alright so that's a very quick overview
of what we've brings to the table I
could spend a whole nother hour talking
about weave in detail because it's a
pretty big thing but that's sort of the
the first primary service that brillo is
giving you for free if you choose to use
brillo as a software stack in whatever
device you're building okay but there
are a few other things that they brought
to the table as well
the first is integrated metrics and
crash reporting services as I mentioned
before we have components from different
places metrics and crash reporting our
services that came from Chrome OS so if
you've seen this behavior in Chrome OS
before it's a safe code but this is
simply giving you as the product
developer the ability to get data back
from the devices you're shipping out
into the field how many active devices
do you have what versions of your
software are they running
what weave commands are users actually
sending right I could use this analytics
to say you know all the light bulbs we
have out in the field people are turning
them on and off a lot but nobody seems
to be finding the dimmer setting you
know maybe it's something wrong with our
app or maybe people just don't care
about that feature so you can get those
types of analytics back in an integrated
console that is part of just a
traditional Google developer consoles if
you've used any of those in the past
same thing with crash reports if you
have a bunch of devices who have a
service that's crashing repeatedly you
can see that information you can
prioritize those and you can fix them
okay
so it's bringing some of these flows
that as mobile application developers
we're used to working with to IOT or
embedded devices something that we've
drastically needed and many of us have
written ourselves okay the other big one
is over-the-air updates along with I
sort of mentioned that security is one
of the most important and one of the
hardest things to do right in IOT
updates goes along with that as well one
of the hardest things to do is deploy
you know hundreds of thousands of
millions of devices and then try to ship
a patch in your software to all of those
devices and one actually have it shipped
there actually have the user apply it
and all of these things so
the OTA update functionality aims to
simplify that right so because all these
devices are connected in this particular
case using weave they provide through
the developer console the ability for
you to create a new image for your
devices upload that image to a Google
developer console and then have that
automatically be disseminated across
your connected devices
okay so brillo has built into it
services to automatically on some
schedule check for new updates pull
those updates down to the device and
install them automatically and one of
the really neat features about this and
again this actually comes from the
Chrome OS side not the Android side is
the the way that these download these
updates are applied is they do so in
such a way that they're done entirely in
the background without interrupting the
device's functionality okay those of you
who have Android devices or Android
developers think of the process that
happens when you get an over-the-air
update for your phone right the update
can download automatically but at some
point you have to say okay yes I'd like
to apply that and that means that your
phone has to reboot into recovery mode
and spend the next ten to fifteen or
twenty whatever minutes applying
installing that update while it's in
recovery mode and you can't actually use
the device and then at some point you
can reboot it back into active mode and
it might still have to do some more
updating or something along those lines
okay brillo aims to fix this using
Chrome OS whose bootloader structure so
Chrome OS actually has two parallel
portions of the system running at all
times okay well they're not actually
running but Chrome OS has what they call
the a/b partition scheme where every
every part of the filesystem that is
required to run your device actually has
two copies that a copy and the B copy
and at any one time you're running from
one and the other one is available to
apply an update so the way this
typically works with the OTA updates is
let's say for example I'm running on the
eight partitions of my device when an
over-the-air update comes in the brillo
services will automatically download and
apply that update in the B partition
while I'm still running
so this all happens in the background
the user doesn't have to know it
function of the device isn't interrupted
or anything like that
once that update is ready to be run all
the installation and everything has been
patched and applied at that point all
you have to do is reboot the device when
you reboot the device it just starts
running from the other set of partitions
instead of the original ones and so the
the downtime of that device is minimized
all the way down to simply the time it
takes to reboot the device and then it's
up to you as a product developer to
determine what is the best way to
facilitate that do you want to do it
automatically in the middle of the night
do you want to alert the user through
your mobile app that the update has
already been downloaded they just have
to reboot to apply it that choice is up
to you but the portion of actually
getting it on to the device and
installing it with almost no downtime is
completely automatic because of the
services provided by Braille oh that's a
big deal if you've ever had to do this
yourself in an embedded world ok so let
me talk a little bit about security so
on the security side of things primarily
from bringing in what's already on the
Android and the Chrome OS side Google
has tried to create a system that is
secure in layers and has all the
security that is provided by all the
Google services we know and love already
into this market ok so we have from from
the brillo side of things all of the
secure process isolation and sandboxing
that application developers are used to
when working with Android all of that
still applies on the brillo side so
because brillo is based on Android all
of the SELinux policies and everything
that has been used for you know the
number of Android versions pass to
ensure that processes are properly
isolated and one process can take down
the entire system and all that stuff
it's all the same ok so they brought
that over wholesale in addition the
functionality along the verified boot
path which is also available in Android
from lollipop plus essentially ensures
that when images are downloaded and
installed on this device that they
are signed appropriately so we know who
they came from and that those images
have not been tampered with
so we know they can be trusted both of
those things are implemented in the
verified boot structure from the
bootloader all the way up so if for some
reason an image or an update or some
change is made to that device that Val
invalidates those hashes are those
signatures that if I simply won't boot
so it ensures that when that device
boots it's always into a known state
with a good image okay that kind of
piggybacks along with again this a B
over-the-air update structure because it
also ensures that if an image is
downloaded into a partition that is
corrupt or improperly signed or
something like that
all Chrome OS has to do to rollback
we're brillo rather all they have to do
to rollback just start booting from the
other partition again so you walk
through that over-the-air update
structure where we download an OTA into
a secondary set of partitions but that
update is bad so when we read with the
device it tries to boot from that stuff
but it can't no problem it tries once or
twice and then it just goes back to the
old code and so we can see using the
developer console that these updates
that are being shipped to these devices
are corrupt or bad or something happened
in that process or we're having devices
where someone has tried to manipulate
the image and the device doesn't stop
working right if you did that on your
Android phone what would happen it'd be
a brick you wouldn't you'd have to
figure out how to get back into recovery
manually find a new image and flacid
with a brillo device it just rolls back
to the existing previously working
version and then you can figure out how
to fix the update okay so the device is
the functionality of the devices does
not get interrupted okay so it's also
very important from the weave side of
things
the added layers of security are around
communication layers right so when
you're when a device is we've enabled it
means that access to that device is
governed by Google accounts so the
security and layers that we're all
familiar with with the Google account
structure when a device is provisioned
as a weave device that device is
provision
as owned by a specific Google account
and that account determines who can see
that device who is it shared with
there's no more this concept which we've
seen with a lot of IOT devices up you
know it as long as you're on the local
network I can trust you right that
happens with a lot of devices which is a
really bad thing from a security
perspective so instead when a device is
provisioned from we've you whoever owns
that account get to control is this
device shared can other users just see
it or can they modify its state or
things like that that's all built into
the weave provisioning process okay so
you have much more control about sharing
an access to these devices and it's
governed by Google accounts which at
least by my standards are plenty secure
okay and then in addition to that all
data whether it's in flight or at rest
is always encrypted so anything that's
communicated over the weave protocol
whether it's device to device or through
the cloud is encrypted over TLS and any
device that's or any data that sits on
either the device or the servers in the
cloud is always encrypted as well okay
so they they do the best they can with
all these different layers that Google
already has in all these different areas
to bring that together and to provide a
single product offering that is as
secure as possible in today's world okay
while also providing all these
convenient services like metrics craft
reporting and OTA updates okay they're
bringing it all together and one package
for you to use for free okay so the last
thing that I want to touch on here today
is just a little bit of a walk through
of if I wanted to build a product using
brillo today what would that look like
and what are the steps involved what am
i is a developer going to have to deal
with that sort of thing
so it's basically in the in these sort
of four steps here we've got you need to
find some hardware you need to install a
BSP and I'll talk about what that means
create a product which product is a
special term in brillo and add some
services okay that's kind of where we're
going with this so the first thing you
need to do is get some hardware what I
have up here are these are the currently
supported boards that you can buy off
the show
today that will run brillo okay going
from left to right there that blue board
is a dragon board which is a Qualcomm
single board computer the dragon board
410 the Intel Edison is there in the
middle and then the other board off
there on the right hand side is a the
Andromeda box by Marvell okay
all of these boards less than 100 bucks
you can buy them from any major
distributor today so the first thing you
need to do is actually get one of these
boards in your hands because today
anyway these are the boards that are
they're going to provide direct support
out of the brillo SourceTree okay now
this doesn't mean that beyond this you
can't build your own board or your own
product based off of one of these for
what you actually want to ship to your
consumers but when you're getting
started and you want to actually just
see how all this thing works you need to
start with one of these that has direct
support so you can pull everything down
and then kind of extend from there the
hardware requirements that brillo is
targeting are listed over here as well
in case you're curious I will say right
now that these are not the specs they're
actually hitting but this is where they
expect to be when they actually release
you know technically brillo is still
sort of in a private beta but 32 mega
RAM 64 mega storage given where Android
requirements are this is pretty good
okay for the fact that this is actually
based on an android system supports all
architecture is 32 and 64-bit across the
board because android supports all those
things so we're sort of drawing off the
idea is if your SOC supports Android it
should support brillo with essentially
no work because all those lower layers
are unchanged ok and then Wi-Fi and
bluetooth requirements as well alright
so I mentioned all these lower Hardware
specific layers before right everything
that's in these layers of the stack are
specific from one board to another they
they they change and they have to be
recompiled whether you're on x86 or arm
whether you have these peripherals
installed or these different types of
device drivers all that stuff is
specific to the actual device everything
above that layer is pretty much
consistent so what
the brillo team did that is unique from
the way we used to have to do this in
embedded Android is they wrapped all of
that in a new extra new abstraction
called a BSP or a board Support Package
if you've done embedded development at
all in one form or another you're
probably familiar with this term already
it's just never really been applied to
LSP before so all of this stuff that is
typically board dependent is now wrapped
up in a single clearly defined package
called a BSP and for those boards that I
just described you can get the BSP's
directly from google okay so you don't
have to write this code you don't have
to go to Intel or ask them to make sure
that they support the Edison or anything
like that the tools provided in the
brillo developers kit are the BBK allow
you to download the bundle for the
Edison for the Dragon board etc that is
the BSP that has all this stuff in here
ready to go okay as a product developer
well first let's take a look and see
what's inside of here so inside a BSP
you effectively have firmware and vendor
specific blobs that are not open-source
you have definitions of how the SOC
should be configured so that's the
actual you know the actual main
processor the x86 chip and its on-board
peripherals that sort of thing stuff
that you probably wouldn't change even
if you built your own product off of
those then what they've done which is
actually kind of nice because it makes
it extensible is they've expanded out
everything else that would be on your
board into this definition of a
peripheral so what LEDs are on this
board or what are the sensors on this
board those are added as peripherals and
the Edison and the dragon board and the
existing BSP have a handful of those
peripherals already defined but the BSP
itself is built in such a way that you
could extend that and just add your own
peripherals for the pieces that are on
your board and reuse everything else so
you don't have to worry about moving
from the Edison to some other product
that you're building and think that that
all of a sudden turns you into having to
develop the whole BSP yourself these are
extensible they're built in such a way
that you can just include the
peripherals but keep it
anything else in the base the same okay
that's the idea that's the way it's
architected anyway all right so you have
the BSP installed now we have to create
a product I said that product is a
special term in terms of brillo and that
actually comes from its AOSP roots so
when you're building an Android based
embedded product whether it's a Nexus
device or something else along the lines
if you look at the end right build
system they actually define three layers
that are intended to separate different
parts of a build they have a board a
device and a product right and they were
intended to define sort of the the
hardware specific elements versus maybe
taking that board and using it in
several different products and the
things that might be customized amongst
those so they just build on top of each
other that was the design they didn't
implement it very well in AOSP with
Nexus devices and other devices like
that these layers are all over the place
they inter depend on each other things
that are in the device layer talk to
things in the product layer and it's
very hard to really tease out where
these differences on the brillo team has
done a great job of actually separating
those layers to make it easier for
someone like me or someone else in the
room trying to develop a product to
figure out what they actually have to
touch versus the things that they can
sort of leave behind so they've
separated these layers out much better
and they've moved it out so that the
layers that are device-specific as I
mentioned before are covered by the BSP
so that's done and the product developer
only has to deal with this one piece and
they've actually moved it out of the
source tree so the other difficulty with
doing these things in AOSP was that all
this stuff was inside the source tree
with the rest of Android which meant
when you wanted to update to the next
version of Android on your product you
had to deal with the fact that you had
to merge your source tree with the
upstream source tree okay in this case
the product is now outside the tree
completely and this product is just a
it's it looks like an application
project it's a directory with some build
files in a source directory where you
can put in your own stuff right and then
you build your product and it links back
to
these other lower layers so the nice
thing about this is when they come out
with a patch release or when the next
version of the brillo LTS is released
based on the next version of Android or
whatever they decide to do you can just
swap that out wholesale rebuild your
product and move on ok there's no more
emerging issues or anything like that
because this has now done completely out
of tree ok so once you've got your BSP
installed you just create this product
directory and there's a tool in the BDK
to do that it just generates this
project structure for you with all the
build files and scripts and everything
you need and then from that point it's
just up to you to start adding services
so you add a service to toggle your LEDs
or change your door lock or whatever
specific to your application at that
point they just get built-in now I will
point out brillo does not have a concept
like the Android does of package
management so there's not really any
idea of installing an application on a
brillo device after it's been shipped
right think about an IOT device that's
probably a good thing but it means that
you're not going to be writing
applications and installing them on to
your brillo device the application
services you write are going to be built
into the system image with the rest of
the device structure and flashed at once
ok so this is a much more tightly
coupled embedded model than what you
would have on just an Android phone or
something like that ok so you know I
mentioned we have these lower layers
here and this part is very much in flux
this this could change a lot between now
and when this is actually released but
just to give you an idea of what brillo
looks like today effectively what
they're trying to build is this API
surface area between application
services and the rest of the system but
right now this is quite fragmented this
actually has a number of different entry
points some of these are in native
services that are they're basically
pulled directly out of Chrome OS so
you're interacting with demons that are
Chrome OS daemons some of these use some
of the NDK api's like right now
interacting with sensors uses the NDK
sensor api's and in some cases you're
just talking directly to device drivers
either because they haven't written an
API yet
they haven't come up with a good way to
abstract that into an API layer so it's
a bit fragmented in terms of how you
deal with this today but hopefully
eventually there will be a clear
definition of the things that you can
talk to in a more consistent way now
what will that look like
it'll be things like connectivity power
management sensors they have some GPIO
functionality and therefore just
toggling pins that kind of thing and
there is some media capability there's
not really any graphics support but they
do support audio playback and that kind
of thing using the native Android
services okay so some of that
functionality isn't very well and then
you your job is then to build your
application on top of that layer okay so
as I mentioned this today is a bit
haphazard but this is very much in flux
and we might see this change a lot
between now and when brillo is actually
expected to be sent into its first LTS
release which they won't give us a hard
date but maybe later this year maybe q3
or something like that we might see this
at least come out of private beta and be
more widely available to other
developers along the way so if you're
interested in playing with brillo right
now you know as I mentioned a couple
times the the access to the program
itself is a private beta so you can go
to the website you can request an invite
and they may or may not you know get to
that and get you into the system however
the only thing that you are missing by
not being in that program is access to
their documentation so they they have
some amount of documentation on how all
this stuff works and that's really the
only thing that's behind the paywall
there's no code or no developer tools
that you don't have access to today all
of that stuff is in AOSP
ok so I mentioned that the weave is
developed out in the open at we've got
Google source com if you just go to
Android Google source com all of the
source code that builds that makes up a
brillo system is right there and there's
nothing private that is available only
to those of us who are invited versus
what's in a OSP so you could buy one of
these boards down
the Android Open Source Project and
start working directly with all of these
tools okay the only thing you're missing
are some of the getting started guides
and things that might be a little bit
more helpful in there but if you're
familiar enough with how a OSP code
looks and how the Android source trees
are put together it should be relatively
straightforward for you to figure out
how to build a brillo product and get it
running up on one of these getting
started boards okay alright so that's
all the information that I have for you
today if you want to get in contact with
me at any point after this you know I'm
on Twitter dev on wired G+ at Dave Smith
dev mile-high Android is where you can
find all my github stuff where I write
sample code on any number of things and
then my personal blog wires are obsolete
as well alright I think that's all the
time I have if you have any other
questions feel free to come up but thank
you guys for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>