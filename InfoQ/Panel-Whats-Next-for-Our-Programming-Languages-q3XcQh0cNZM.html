<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Panel: What's Next for Our Programming Languages? | Coder Coacher - Coaching Coders</title><meta content="Panel: What's Next for Our Programming Languages? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Panel: What's Next for Our Programming Languages?</b></h2><h5 class="post__date">2017-07-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q3XcQh0cNZM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay welcome everyone I've been very
much looking forward to this around the
speaking I get to share so let's welcome
our four speakers onstage here and we're
about to have a panel discussion looking
at the current state off our languages
and where they're going to go in the
future we've got a nice range here so
I'll start off by letting each of them
introduce themselves so we know who of
God go for Richard I'm Richard Feldman I
work at no red ink we make grammar
writing software for English teachers
where I start up in California we use
almond production where the biggest elm
codebase known to anyone so the creator
of elm is my coworker and I work closely
with him and know a lot about the
language design but I should clarify
that I'm not actually the language
designer of elm so a lot of knowledge
about elven sort of a front-end
technology's functional programming
things like that and excited to talk
about the future okay hi I'm Joe Duffy I
was previously engineering director at
Microsoft for languages simply C sharp F
sharp Visual Basic C++ nowadays I'm kind
of off doing a new cloud startup but
it's actually very much in the language
space as well hi I'm Brian guess I'm the
architect for the Java language and core
libraries of Oracle so I was the I was
the lead for the Java eight language
library features lambdas and screens and
I'm currently working on the next 20
years of Java's life hi I'm Sylvan
clutch I work at Microsoft Research in
Cambridge and I designed the pony
programming language which is an
actor/model language and I work on other
language things at MSR thank you so I'm
going to start off with a few questions
to begin with and we'll see where the
conversation goes but we'll also open it
up so people can provide questions and
they expand on some of this later so I
want to started off with something I
cannot often think about is where do we
spend your time when writing code what
sucks up all our time so it takes us
longer to do something I want to kind of
put it to
to the panel what they see that problem
being right now what to think the
current state of the world isn't how
they see that going forward I will
reverse and for sure I think sort of
five to ten years ago people used to
reinvent concurrency every time they
were writing an application and that was
a huge problem we still do that but now
we reinvent distributed systems every
time we write an application and it's a
lot worse Brian so when I'm working on a
programming problem and I'm not making
progress what I find the the root cause
is usually that I'm not thinking clearly
about what the data flows are and once
you get the the data flows right then
usually the code pretty much writes
itself mm-hmm
I would say probably debugging a lot of
people don't think of debugging as sort
of being part of language design but I
think you know especially having
language abstractions that map closely
to kind of your mental model of a
problem which is why if anybody heard my
talk this morning I'm really a big fan
of kind of the actor model for
distributed programming and all the
concurrence and constructs have been
added you know it used to be the case
that there's such a gap between kind of
the code you would write and what was
actually executing you weren't
expressing things in a logical level
isms like you're doing assembly
programming and nowadays at least you
have tasks and that sort of thing I feel
like we're still in that stage with
distributed programming and then when
something goes wrong you're left kind of
manually reconstructing everything that
happened between when you wrote your
code the compiler got its hands on it
and then you know mapping it to runtime
abstractions and so I think of debugging
is very much in the realm of language
design
I think debugging is great answer I'll
also say sort of bridging the gap
between when you're initially shipping
an application and when you're scaling
it so one of the things that we've been
talking about is sort of if you hire
another ten developers you're not going
to get 10x the productivity of one
developer the more and more people you
add the less and less you get out of
each person in terms of velocity and the
reason for that is just that complexity
doesn't increase linearly it sort of
compounds upon itself and so I think one
of the areas that we
spend a lot of our time and even though
we don't necessarily think about it that
way at the time is just that added
complexity doesn't scale linearly so I
think one of the things we can get out
of our languages is the ability for
maybe not to get all the way down to
linear but at least to get the
coefficient lower so that it gets have
less and less of a compounding explosion
the more complexity that's sort of
innate to our application okay that's
really interested my second question was
going to be a buddy bugging because I
find it I don't care if obsessed by did
I measure lots of things and I realize
that I spend a lot of my time working
across many languages debugging code we
often don't talk enough about that so
I'd like to go back to Joe this because
I've been of a fan of his blog around
similar stuff you talked about you
talked about the three safeties for me
the three safeties are a great way to
avoid many of the debugging issues we've
be fierce and what can we do to go
forward from here
right so the three six is sort of the
Midori operating system we built was
kind of based on the fundamental premise
that operating systems of the future
should be type memory and concurrency
safe and concurrency safe means free of
data races as I talked about this
morning you can never be free of race
conditions entirely but at least you can
be free of data races and to me it's I
think one of the things we can do is use
languages that actually solve the
problems by construction that was also a
big mantra
we call the correctness by construction
which is kind of alive because you can
never prove that your code was correct
unless you're programming in like TLA
plus or you know some some logic
language but but I think it's you know I
look at one thing that pains me is that
for going through that experience
looking at all the security flaws time
and time again I mean I think something
on the order of 45% of the zero day
vulnerabilities that come out in any
given year are actually due to buffer
overruns which we've known how to solve
for years I mean if people would just
use type in memory safe languages sure
there is opportunity to get that wrong
because you know you even Java and.net I
mean there's some native code obviously
in there somewhere but the less of it
that you can expose yourself to the more
your programs will be correct by
construction and I love seeing more
people using type in memories
languages especially you know rough kind
of takes it to a total extreme
especially trying to solve the
concurrency safety problem which i think
is out of the three safety is the one
that is probably the least kind of
mainstream it's the most difficult and
even in rust you can see the great
lengths to memory ownership that you
need to go through to really solve that
problem but it's a super promising
approach I think mm-hm
anyone want to add yeah so this might be
sound like a little bit of a snarky
answer but my favorite favorite way to
reduce the pain of debugging is to not
have to do it right and it connects a
little bit to you know to what Joe said
which is use languages that are safe use
libraries that are well tested in
building blocks you can rely on so that
you know you don't have to reinvent the
wheel from scratch every time but
another aspect of writing code that
doesn't have to be debugged is to focus
on writing simple code right code that's
so simple that you can't possibly
misunderstand what it's doing and I
think a lot of developers they sort of
get caught up in writing fancy code or
trying to make the code fast at the same
time they're trying to figure out what
it's supposed to do and you know all of
these sources of complexity are places
where bugs can hide so if you focus on
writing the simplest possible code it's
a lot easier to get something working to
build up good basic tests before you
start to add valves and whistles or try
to optimize it or if you have to
optimize it so by striving for
simplicity you find you have to debug
less often and that that's a good thing
I yeah I think it's really very fun that
a bunch of language designers when asked
about debugging
we all immediately start talking about
correctness I'm going to do the exact
same thing I think formal verification
of code is it it has been the future for
a long time and much like fusion power
it will be the future for a long time
but those techniques are getting better
and better and their languages like
Daphne and F star built on top of the z3
SMT solver they make it possible to
write significant code that is proven to
be correct there are no debug
issues unfortunately currently with
those tools it means that you spend a
lot of time fighting your SMT solver and
debugging the fact that it can't prove
what you could prove in your head easily
but building up those tools along with
dynamic tools I think for example Elm
has a brilliant rewind double debugger
and tools like that building up those
dynamic tools is important but I think
building up static tools that can prove
correctness even more than just the type
system and amore safety concurrency
safety as much as I think those are
absolutely critical I think formal
verification is the only way we're going
to end up with widespread code that is
impact cross-table so I would like to
build on all this because I'm general
agreement but one thing that I think we
don't think about is when we're
accidentally making decisions that lead
to more debugging later so I'll give you
an example this so I can CSS if
something about your stylesheet is
invalid it will just sort of silently
fail just on that one property which
makes it pretty easy up front to make
invalid properties and not realize it so
on the one hand to feel like it's nice
though it's not it's not blocking me
from making progress it's letting me
continue from the other hand what that
means is that potentially later on
you're going to have some unexpected
behavior as a result of that invalid
property where the error was just
silently ignored early on so on the one
hand it can feel frustrating to get all
these errors up front and have them
block you and have it say wait a minute
you can't progress because I found a
single style that was invalid none of
your page is going to render for you but
on the other hand having that stuff up
front can save you from debugging later
so very often there's this implicit
choice that you're making by choosing
tools that that sort of swallow errors
and don't force you to deal with them
upfront and the ways that we're talking
about it can be convenient at first but
very often it leads you to spend more
time debugging later and you don't see
that cost at first and if I can add
something to you know what Sylvan said
about that formal verification so not
all of us can afford to you know make
the effort to formally verify our code
but there's something all of us can do
to get some of that benefit and and when
we talk about correctness
what is corrects correctness means
program is correct if it conforms to its
specification so how many of us write
good specifications for all of our code
and the reason I'm raising my hand or
the consequence of me raising my hand is
why Java takes a long time to evolve
we're obsessive about specifications the
most valuable thing about the java
ecosystem is the quality of the
specification for the language in the
JVM and so we take specifications very
seriously and it's the act of writing
the specification that forces you to
think really hard about what problem I'm
trying to solve here and even if you're
not going to then try to code up these
specifications in a formal verification
language just having gone through the
exercise of trying to write a
specification such that someone who
isn't immersed in the problem could
understand what's going to go right
what's going to go wrong what's the
boundary what's the goal is an immensely
helpful thing there I love that answer
so one of the things that we did
building Pony is that we started with a
formally specified operational semantics
and type system that was proven sound
and developed the language and the
runtime from there and there was a
feedback process where the development
of the runtime actually fed into the
formal specification and vice versa and
I think that maybe that sounds overly
nerdy for real-world application code
but it kind of isn't you can write those
specifications and do that feedback
process even if you're not doing it in a
sort of a strict mathematical way and it
can be hugely valuable I also think if
you look into the future I believe that
some more advanced type systems will
start to influence kind of more
programming languages and if you can
bring something into a programming
languages type system it does have the
advantage that some of the performance
problems of using a constraint solver
for example start to go away because you
can rely entirely on local analysis so
specific example dependent typing the
ability to actually have constraints
actually expressed in your source code
that say that limit the domain of
particular values like hey this is the
number and I know for sure it's between
the range of 0 to 3 and the type system
can kind of can prove this and
and do it in an efficient way I think
we'll see more of that I also think
another example Daphne is a great
language for people that and looked at
it's fantastic kind of shows kind of
what the future might hold but just some
of the ideas around designed by contract
for example actually being able to
specify requires clause and insurers
clauses and these sorts of things and
then if you couple that with compile
time safety plus the potential for kind
of fail fast so treating bugs as bugs
rather than letting them go silently do
you think that leads to somewhere
magical and I do expect that to sort of
start impacting languages in the future
so thinking about the intersection some
of these things one of the things that's
interesting to me is how different
organizations different teams have
different needs so for example let's say
you're working on Java like formal
specification is very important but of
course you also have you know so the
time scale that you're working with is
you're talking about like you know in
Java for the next 20 years I work for
startups so we also have the you know
the very familiar experience is saying
oh we're going to be running out of
money in 18 months you know so maybe you
know some this is these are sort of not
all one-size-fits-all approaches right
it's not probably not a good use of our
time to write a formal specification for
our software because by the time we
finish it we might be dead
so you know with the understanding that
different organizations have different
needs I think that the languages of the
future are going to make it easier to
make these trade-offs in an intelligent
way so maybe if you're just jamming out
a prototype and you just absolutely the
most important thing is that you get it
out to your users you know tomorrow
maybe you do want something like the CSS
approach but ideally you can then start
with that and then say ok now we can
transition pretty easily from that with
all the safety is gone where we've piled
up a bunch of you know potential bugs
for later and transition that to
something where that is more fail-fast
that's more reliable for the future and
I think the one of the recurring themes
we're going to start seeing in languages
of the future is that it becomes easier
to make that swap so you don't have to
sort of sacrifice the upfront velocity
of just getting something out there and
building a prototype for the sake of you
know or you don't have to load yourself
up with future bugs in order to do it
okay so for me that's all interesting
let's make it a bit more concrete things
that people do every day we communicate
between systems we send messages we
encode those messages we used to do it
knacks ml a lot which was pretty
terrible but at least it had some types
because you have been talking about
types we then went to Jesus
we'd even throw in a where the types so
almost formal theory come on guys like
we seem to be going backwards rather
than forwards and we're going distribute
it so how are we going to get this
safety if we're just going to pass
around strings with no typing
information at all versus better ah
that seems to be what the community has
decided right I mean they had they had a
number of things to choose from of how
they might encode messages across the
wire and they picked from a computer
science perspective what might be the
worst possible choice in fact like going
back to top of the specifications there
was a great great post recently where
someone did an experiment with you know
30 different JSON parsers and found that
like no too accepted the exact same
language because there isn't a
specification right but it's what the
world is chosen to use is it linked to
debugging many people use these
protocols are these encoding because
they're easy to debug well my theory is
is it has to do with a couple things one
is just sort of like programmer
happiness like I noticed that you know
your comment was like XML like something
that everybody here would agree is not
fun to work with and maybe not one
percent but probably a lot of people who
have spent a lot of time with XML
probably don't have the fondest memories
of it and JSON is if nothing else it is
at least something that's relatively
familiar if you're already familiar with
JavaScript objects and text you can just
sort of write it and there's not as much
to learn which can make it more fun to
work with I think that that's something
that's sort of underrated in programming
programming language design is just like
fun use you know user friendliness for
the programmer we are all humans we
respond to incentives right when when
our tools are more delightful to use we
tend to gravitate towards those even if
those are not necessarily as you know
formally rigorous as other tools that
are out there well believe it or not one
of the most popular releases of
one where it didn't have any like
brand-new features in terms of
productivity all it had were nicer
compiler error messages it was just you
know look here's it's the same does the
same things before but now it presents
them in a nicer way and that was one of
those popular releases ever and it
really just like jumps Elmo's popularity
massively not because it was something
that was more reliable than before but
just because it did the same thing in a
nicer way and I think figuring out ways
for languages to be delightful while
still also rigorous and reliable and
maintainable is one of the challenges
that is sort of starting to come up on
our radar it says like oh maybe we
actually need both of these things if we
want to be successful and so I I think
in this specific case I mean the
Internet has no type system right so
we've with Jason and everything we sort
of found the lowest common denominator
that can kind of sort of project into
every language and I think you know if
you look I think is the gap that
programming languages need to fill I
think if you look at gr PC and protobufs
you know from from Google which are
definitely not new they've been out for
years and Google's use them internally
for years it at least gives you sort of
a type system to talk about things a way
to provide an interface that is typed
and provides a little bit more static
typing now it's not as extreme as it
could and it's a definitely a subset and
you're closer to Jason then say goes
full type system I think it's a huge
step forward and I think the more we
start thinking about these systems as
programs and less about kind of services
that are treated differently an
infrastructure that's about metadata and
markup and these messy grungy things
kind of low-level details like you
wouldn't start you know calling methods
within your programming passing around
blobs of XML right so why why would you
do that kind of over the wire and I
realize it's getting dangerously close
to like distributed CORBA sort of
territories I definitely don't want to
go there I think we've learned a lot
since then but I do think the Internet
can have a type system that straddles
this line between being fun be flexible
taking into account all the things we've
learned around versioning
namely that you can't version things on
the internet like it's v2 with v3 as
before or you deal with breaking changes
I think you wrap all those lessons
learned I think it can actually be quite
a beautiful thing and to pick up on the
comment you made earlier about wouldn't
it be nice if you know our safety
mechanisms had knobs that we can turn
that say like I'm in rapid prototyping
mode to turn the type system off I'm
just going to write some code I want to
see if I can get something out of it and
then once I'm convinced I've written the
right thing turn up the knob so that I
can get more protection that's a nice
idea there's been a lot of attempts at
doing that with gradual and optional
type systems they have in stock there
they're a little bit like what you were
saying by formal verification which is
they've been coming for a long time now
it's like tricks for the last 10 years
everyone's saying well gradual typing is
the next thing inside theories like well
I'm still waiting for it but I'm still
hopeful that we might get something out
of it uh but in in I think you know the
mistake of adopting JSON at the language
of the Internet is not that we picked
something untyped is that we picked
something that we can't impose any type
discipline on if we want right there's
no way to turn that knob from fully
untie it's to I have you know some some
way of validating what I accept and what
I meant and the coolest thing I've seen
in this space that it doesn't
necessarily work on JSON but but the
approach might my carryover is cloture
spec has anybody look at the closure
spec this is so cool right so it's
essentially an optional static type
system for sets and maps so you can talk
about here you know I accept this you
know this is hash and these keys are
required and these keys are optional and
if the ski skis are present then their
values conform to this other
specification and it's something that
you can add on after the fact you can
turn it on or turn it off in production
and it's it's a very nice way to bring
in a little bit more reliability once
you've figured out what you want your
system to do it's a really pretty
example on it it fits nicely also a
generative testing which is probably
like you know testing is one of your
other questions on the back your
envelope there Martin you know that you
know writing specs for what you're you
know what your functions accept and emit
means that you can write test generators
that will generate conformance and
it's really pretty so I would take a
look at closures back there's a lot of
really original thinking there so we're
focusing on Jason because we sort of
think that that's the way that we
exchange messages and in some sense we
do in the sense that we're exchanging
application data but far more than that
what we actually do is use IP TCP
layered over IP and TLS layered over TCP
these things are formally specified
extensively so TLS 1.3 is progressing
extremely well people are building
formally verified implementations with
TLS multiple companies are building such
things when we look at the incredible
progress that's being made on that front
I think it should be it should encourage
us as to the progress that we can make
with application data in metadata going
back to gradual typing so I'm going to
make a claim right now since we're on
the future of programming languages
panel I'm going to make the claim
gradual typing is not the future I think
it's a failed experiment I think like
we've seen like so closure has a gradual
typing thing and a few so circle see I
did an interesting series of blog posts
the year apart the first is why we're
embracing gradual typing with quartet
types and then a year later why it
didn't work and we're tearing it all out
and going back to untyped and I think
what it has to do with is whether this
is opt-in versus opt-out and I think if
you make typing opt-in the result is
that you end up with a lot of libraries
that really are not getting the benefit
of the types and you're not unique Oh
system is not designed with that in mind
I have heard of an alternative to this I
haven't personally used it but Haskell
has this and I am NOT a Haskell around
so I don't really know but I'm aware
that it has so Haskell is type checked
everything is verified at compile time
to the extent possible but there's a
compiler flag you can set it says okay
sort of just turn off all the safeties
and anywhere you find a type mismatch
just keep compiling but turn that into a
runtime exception if that branch of code
ever gets run and so the idea here would
be that by default everything is type
checked but if you're in prototyping
mode or whatever and you're like midway
through a react refactor and you want to
just see if something works you can do
that and sort of opt into that the lack
of safety
that's really interesting to me I
haven't tried it but it does sound like
a better way to approach it than the
other way around with gradual typing one
thing that's sort of an interesting
experience that we've had with elm so I
don't know many people saw my talk on
Monday but we've been using Elmen
production since 2015 about hundred
thousand lines of elm code and like two
billion questions answered by students
we still have not gotten a single
runtime exception from our elm code like
not even one and that's because of Elms
compiler absolutely and because of the
type system and the language is designed
but the you know the idea that if we
were in local development mode and we
were to say okay just turn that off just
for now while I'm doing the tree factor
especially if that's going to you know
compile but exit with you know nonzero
exit code so it would fail all our CI
bills and people would not check that in
it doesn't seem crazy to me that we
would still have that same level of
reliability while still getting to you
know sort of have our cake and eat a -
with fast prototyping when we needed it
that doesn't sound crazy to me but when
I look at what gradual typing you know
seems to be doing in practice it doesn't
seem to be getting there you don't hear
about graduate type languages where
people are saying yeah we could go on
for like two years in production with no
runtime exceptions I never hear stories
like that so you know it seems to me
that it was a nice idea but I don't
think it's going to work out Tim Jones
at Victoria University in London New
Zealand wrote a paper called gradual
typing is morally wrong and we're all
monsters now
his entire PhD thesis was on gradual
typing and he wrote it just after
finishing as a refutation to his own
thesis and it's well worth reading if
anyone ever considers going down that
route Richards right so this morning Joe
you made the comment about the lines is
more important than the boxes so because
this is where kind of drifting off and
we're very much going into distributed
computing we're seeing advances in
platforms also we're not seeing so much
advances and languages usually when
we're doing i/o and languages it's up
and what's what's going to change people
caring about this yeah so what I meant
by that is really it is funny when
you're focusing on you know a single
process system that process
is kind of pristine you know the failure
of that process is the end of the world
like you never want that to happen and
so you go to great lengths to secure
yourself against that by using formal
verification or at the very least you
know aggressive assertions it's a
distributed system you kind of don't
care sure there's some important
processes like you don't want your
masternode and your pesos system to go
down ideally even though recover form it
but really it's the communication
topology between nodes that matters more
and the ability to recover those
connections between the nodes and the
failure of one ideally is not
catastrophic if you've architected your
system correctly and I think that sort
of gets back to a lot of the theme that
kind of is recurring which is you know
the programming languages need to
increasingly be about helping you to
build correct distributed systems just
that as programming languages today
compared to 10-15 years ago
help you to build correct concurrent
systems and we really haven't seen that
and the question is it's harder it's
much harder because we get into the
Jason question
it's a polyglot world like everything is
heterogeneous everything speaks a
different language and so how could you
possibly have a language that helps you
to bridge that gap when the thing on the
other side of the connection may be
written in a completely different
language the type system really can't
span many processes or many nodes in a
cluster or if it does we need to have
some sort of type system of the internet
if you will that already agrees on
ideally something that's much better
than Jason so I won't say that it's a
solved problem but I do think this is a
problem that programming languages do
need to solve ideally quickly something
that's interesting to me along those
lines is so we've been talking about
sort of broadly speaking guarantees and
we talked a lot about like tight
guarantees but there are other
guarantees that can or cannot be baked
into a language and they have different
trade-offs especially when it comes to
things like concurrency so speaking
again in terms of elam so like an elm
everything is immutable and everything
is a pure function you can't write
functions that have side-effects and you
call them and you can't write functions
mutate anything and so this rules out a
lot of possible concurrency related
problems so Evan if you were here I
guess you would say because I've heard
him talk about this in the past there
are lots of different ways with handling
problems of you know what happens when
data changes in various ways so like you
heard may be heard like reactive
extensions and streams and like you know
event listeners and things like that to
sort of react to the idea of data
changing in a somewhat imperative
somewhat functional way but Evan makes
the point that if you just say
everything is immutable then you sort of
don't have that problem because you
substituted it with a different problem
the different problem is that you sort
of have to rethink how you're going to
write your code but once you do learn
how to write code in that different
style and you get comfortable with it
then all of these problems get sort of
ruled out right you have this guarantee
that you can't have like a concurrent
modification of the same piece of data
because all the data is immutable you
just can't do that even by accident and
so it's interesting to me to think about
you know as languages evolve how much of
it is going to be trying to find
solutions to these problems within the
current set of features that people are
accustomed to and how much of it is
going to say look if we draw these
guarantee lines in a different place can
programmers adapt and just like learn
how to get comfortable programming with
this different set of rules where these
problems can't happen anymore so you
know just to talked about how languages
need to get better at helping us solve
distributed problems and and in the
short term I'm not seeing an awful lot
of evidence that happening in the
mainstream programming community and in
fact in some sense I think we're going
in in the wrong direction because as we
as our program size on average gets
smaller because we're breaking up our
programs into micro services or
serverless or any number of programming
paradigms that exploit the fact that
network bandwidth is really cheap and so
you can you know break up your program
into separate loosely coupled entities
without a lot of cost people tend to
make their programming language choices
on the basis of what's convenient for
you know and for productivity what's
easy for me to get this you know up and
running and so you see you know pea
choosing languages I will name any names
but you know some of the more popular
languages in this space offer you know
nothing in the way of Joe's three safety
is right but that's what the market is
choosing right so I I think the
availability of chief bandwidth is in
some sense making programming languages
less relevant which is kind of a shame
because I think programming languages
have a lot to offer in terms of solving
these problems but short term expediency
sometimes that ways you know that way is
a big picture now I will point out there
there are some successful examples and
it tends to be in sort of the more
domain-specific realm so you know spark
for example or Map Reduce generally when
you when you have the main specific
programming language or programming
model that is sort of a language plus
some framework or libraries you use plus
a runtime that takes care of scheduling
for you
then you can have this nice beautiful
model that is consistent and and has a
richer type system and richer
capabilities with it the problem really
is when you run into kind of the
boundary of that system and you want to
interact with other systems and it's
more of an open-ended problem I think
that's kind of where things fall down
today and there's clearly a limit to how
long you can stay within the confines of
a very specific domain specific solution
it says kind of interests and you're
going off into that way but I heard a
lot of different mentions also in
various qualities of service like some
people called non-functional
requirements you don't see a lot of are
in a draft like as we go forward
performance is clearly becoming more of
an issue not just in raw truth but
saving battery life so we parse decent
on our phones we just can eat our
batteries we do all of this in the
browser seem sort of thing but you also
see with reliability with all sorts of
other things but for me I spend a lot on
performance we look at five hardware's
going bandwidth is going up generation
by generation sometimes doublings
sometimes going up orders of magnitude
accumulated latency we're not getting
any better
we're not seeing any evolution in FP is
at a significant level within languages
or the runtimes that we need to do a
sync
it's not happening but why are people
not doing that use asynchronous
languages they exist but I to be more
serious in terms of that I think that
performance is incredibly critical and
people often dismiss it and say wow my
particular application doesn't need to
run fast it may not need to run fast but
it absolutely needs to run cheap and
that means that performance should be a
consideration for every possible
application and cheap on a phone is
about battery life it's about what you
can conserve so that you can run longer
and that means that the only thing
better than fast code is no code at all
and some of the techniques that we've
been talking about up here like type
systems and memory safety and even going
all the way to formal verification
involve taking things out of the dynamic
world and putting them into the static
world things that you can solve
statically so that they simply don't
have to be checked at runtime that's a
big deal as much as async is a big deal
and I think it is those lifting things
into the static world is how you get to
more asynchronous and faster programs
also interestingly what we found in the
Midori project it was interesting
because it was you can think of it as
every process was decomposed into a very
fine-grained process and but you can
think of it as more like a container
sort of connected through our PC and the
whole system was built this way so like
the the file system itself you know it
was a separate process and the NIC
driver was a separate process and it was
all kind of message passing and
interestingly with a with a aggressively
optimizing compiler kind of behind the
scenes but interestingly this is trend
towards finer and finer grained
processes actually has one advantage to
it from a performance standpoint which
is smaller GC heaps and GC heaps that
can be collected independently of one
another we have fantastic parallel and
concurrent GCS but nevertheless they're
shared data structures whenever you need
to do a collection even in the most
advanced parallel garbage collector and
actually having in depend
he 60 collected independently helps the
overall throughput of the system and
forward progress and so I think you know
that there are many disadvantages to the
trend towards you know smaller and
smaller processes but that that's one of
the advantages so to the question of why
like how did we get here I have a theory
that involves two languages and how they
got popular so one language is
JavaScript and the other language is
Ruby so JavaScript I claimed got popular
not because of any intrinsic merit to
the language itself but just because the
web compact like browsers blew up it's
an amazing deployment mechanism you type
in the application you want you press
ENTER and then you've got it and no
installation nothing it's hard to
compete with that like you can't really
do better than one step that's the next
step is zero then you computer has to
read your mind to get you the
application faster so I think doing that
cause JavaScript to get popular because
that was sort of the only way you could
get that application deployment
experience javascript single threaded
right and it's not really optimizing for
any of the things you're talking about
it works with strings a lot and so
people sort of made progress in
JavaScript like if you remember how JSON
originally you know came to be it wasn't
that browsers started off writing native
C extensions to parse JSON as fast as
possible Douglas Crockford said I want a
thing that does this thing I've got
strings to work with I'm going to invent
this format that was it and then it got
popular
similarly Ruby also single-threaded was
not a very popular language until rails
came out and the thing as I understand
it that the popularize rails was about a
20 minute YouTube video saying check it
out I can make a blog engine from
scratch in 20 minutes using this thing
called rails and at the time a lot of
people were feeling like I can't build
stuff that fast it's a lot of ceremony
it's a lot of set-up time it's just not
as fun and we're programmers we like to
have fun
so people gravitate towards that they
say rails is something that will let me
enjoy programming but I think both of
these put together make it so that it
becomes more normal and more acceptable
to have single threaded stuff that's not
focused on performance like Ruby's not
performance focus javascript wasn't for
a very long time until the browser Wars
in 2008 when they sort of started
fighting over optimizing this stuff with
just as fast as possible but in both of
those cases you know talking about what
what the market was I think the fact
that Ruby and JavaScript became normal
programming language they saw no js' you
know
I'm out of JavaScript you know ubiquity
on the front end all these things are
sort of coming together to make it the
idea that this is fine this is normal
everybody can get stuff done in this way
performance isn't that important you
know latency is not something we need to
worry about and yes maybe over time we
will we will come to regret that but I
think that does answer the question of
why at least to my mind and to follow up
on that story about that ruby is so
it'll astray --ts you know the fact that
I think we're only looking at half the
story we're looking at the developer
facing half the story when we make some
of our technology selection choices
right so Ruby got you know uh you know
it was around for a very long time it
was this you know minority thing and
then all of a sudden when rails came out
and got popularized it Ruby really
caught on people loved it it would have
made it really easy to incrementally
build a data-driven web application you
know a little bit at a time and it was
great but it performed terribly when you
went to deploy it and you know so
Twitter had an interesting story where
you know they had originally developed
most of their infrastructure in Ruby
they felt like it gave them big
productivity events doing so but then
when they started to get popular they
were adding up what their computing bill
was and it was astronomical and they
went through a process where they
rewrote everything in some combination
of Scala and Java running on the JVM and
their hardware cost went down by over a
factor of 100
and I not not I I say that not to
trumpet Java success even though I'm
sort of obligated to by my employer but
point out that that when people talk
about Java or C sharp or any any
language ecosystem there's the source
language you program in which is what we
as developers are obsessed with because
we spend all our time looking at code
and then there's the runtime which is
really kind of the important part right
and that's where all your deployment
economies come from it's where all your
above ability comes from its where
monitor ability comes from its where
serviceability comes from but as
developers because we're focused on code
we think the surface language is really
the important part but in a lot of ways
runtimes man
our way way more than programming
languages do yeah this reminded me a
funny story at Microsoft so we were
porting an existing system which is
actually used for mission-critical
things so that in this case it was the
real-time bidding engine for Bing ads
and it's a large-scale thing so on a
regular basis every hour it crawls
terabytes and terabytes of data and what
we found was for every one K of data
that I actually was persisted on disk
the program would allocate 8k of just
garbage objects so strings in this thing
and what it was doing was actually
loading up something off disk parsing a
blob of JSON into memory splitting the
jason by looking for commas at which of
course allocates a bunch of substrings
into an array which itself is another
object and then continuing to go on and
on and do this and so this is running
across terabytes of data it turns out
this was you know you could have written
this terrible code in any language
really the the framework itself so
building on Brian's point that the
runtime is important the framework and
the library itself is also very
important because it kind of encourages
a coding style so if you walk up to the
string API and c-sharp well it's got
these handy dot split methods and so on
and so forth that will happily allocate
allocate tons and tons of memory on your
behalf this is an example where the
language and the framework can help I I
love you know go slices for this this
reason where you can actually just say
no I just want ECU bytes in the middle
of a string you not have to allocate an
entirely new substring yeah like that I
can pick up narcosis a lot of what I've
seen and measured many performance
issues I see in the wild or API design
and not fundamental language design yet
it doesn't seem to get anywhere near the
same love like what can we do to get
better at that well I think static
analysis can help I think having the
right fundamental primitives helps I
mean that that's why I mentioned the go
thing you know before I left Microsoft I
spend two years leading up to the time
when I left and I think we'll finally
ship in c-sharp seven potentially adding
slices in
language was so hard to retrofit after
the fact because you know at least go
had them from day one where an array is
a slice a string is essentially just you
know a slice of utf-8 bytes and so on
and so forth so you know all the api's
were built around the right fundamental
concepts it's hard to recover that after
the fact you know all of the dotnet API
is except strings you know streaming API
is for example take a byte array and see
if you walked off with you know bytes
star okay now you need to copy into into
manage memory so some of those
fundamental things you have to get right
from day one but a lot of it you can
catch through static analysis and just
sharing knowledge it also it needs to be
part of the culture of the language like
that that is one thing I like about the
go culture it's very minimalistic and
very attuned to these sorts of
challenges like it is overly
minimalistic I think it's closer to see
than you know say modern languages but
that is one thing is embedded in the
community so I think people just kind of
are on the lookout for that sort of
thing cool so following up on on
language community culture so screw
strip said that language design is
library design and library design of
language diner design and what he meant
was we tend to think of that we're
thinking about language features we tend
to think about what kind of libraries do
I want to be able to express easily
right so the that the natural API is
that you can write in a given language
and the features of that language are
pretty much inextricably bound and if
you're if you're good you will actually
think about that explicitly rather than
implicitly when you're designing when
you're designing things but languages do
tend to encourage certain kinds of API
patterns and and so if you have as you
say the wrong primitives you're going to
build the wrong api's and they hope with
niño getting better in the future Brun
sure it's been a while okay this page
I'd like to open it up a bit and do we
have any questions from the audience
yeah one over here I'll run around if
we've got a microphone over there thank
you I would love to know if you exclude
your own languages the ones that you've
worked on if you could pick another
language as your everyday workhorse
language well which one would you like
to work with and learn and play with and
why although no closure
basically because everybody I know who's
working in cloture is just so happy
about that you know that that looks
great I think strangely not that I want
to use it but that I want to learn from
it's excel excel has 500 million
programmers just let that sink in for a
second it's also a functional language
and a functional reactive programming
framework it's been highly effective for
about 30 years we have a lot to learn
from excel strangely people can approach
it and use it they have fun using it
which i think is a theme from what which
has been talking about that's hugely
important I don't know quite how to
learn from it but I think I should
hahaha so I do program every day now I
let my management job and I'm actually
down in the trenches now and I picked go
for for that mostly as a detox after
having spent many years working on
advanced type systems
I'm going to say rut so one of the
things that's interesting to me is sort
of like language identity and like
what's the language abouts I think Elm
is about sort of like delight and
maintainability and reliability Rus is
like very focused on be as fast as
possible and be as not broken as
possible they would probably express
that more eloquently but I really
interested in those things because it's
in some ways sort of like the opposite
end of the spectrum of like what I'm
doing with Elm but I'm very interested
in the idea of what if you're just
saying let's go as fast as we possibly
can but still not break things what's it
like to work in that environment and
like optimize those things and that
sounds like a lot of fun to me for
entirely different reasons than else is
fun for me okay anymore
thank you for this panel it's very
interesting I find it interesting that
we've talked a lot about languages being
interrupt important for district
distributed programming typing etc yet
nobody's mentioned anything about
paradigms like object-oriented or
functional or any of these things do
these things not matter anymore for
future languages I think the thing that
at least Joe and I have brought up is
something else at slightly different
paradigm which is actor/model
programming and it's somewhat related to
those things I personally think that
it's quite easy to craft an explanation
of object-oriented programming that
sounds like functional programming and
vice-versa
so that particular distinction doesn't
fascinate me
but the distinction that does fascinate
me
there is ideas around memory safety and
I think if you think about it as a
memory type and concurrency safety issue
and think about actor/model programming
as a paradigm then it does still matter
and a lot of times now you're looking at
the difference between CSP communicating
sequential processes and the actor model
much like object orientation and
functional languages they are dual but
they do lead to different designs for
systems and I I think the o L versus FP
thing is largely a
false dichotomy right and so you know
what one of one of my mentors once said
you should learn oh oh
you should learn FP and then strive to
rise above them both right and I think
we all have something to learn from both
of those paradigms and if we align
ourselves with I'm a functional
programmer I'm an object-oriented
programmer you're missing a lot next
question thank you very much for your
time as well as your talk I just had a
question in couple of last weeks or some
kind of conversation over the net about
AI and the University of the Camrys and
Microsoft they both together they done
some nasty SF now a I can I wrote a some
line of code I think up to five or six
lines to solve a problem do you think
the future of the language programming
is going the way that instead of we we
come with a better language for also to
solve the problems maybe we should come
with a better language that AI can use
it in a better way and if it if it does
go that way then how does it impact our
career as a coder so that work is mark
Brock Schmidt's work at MSR Cambridge
deep coder and it is indeed given a set
of inputs and outputs synthesizing code
and it is pretty magnificent work in my
opinion I don't think anyone should be
worried about their job too soon also in
terms of the programming language is is
a UI to the runtime sort of touching on
what Brian was saying and yes an AI
needs a UI to a runtime and perhaps that
looks like a programming language and
perhaps there are different ways to
build you guys to run times that look a
bit different that are appropriate for a
is for example AI might be more
comfortable and forth than in a lot of
other languages however as a programming
language designer looking to expose a
runtime in an efficient and useful way
focusing on how an AI would use in
runtime it doesn't motivate me if that
makes any sense I also think before I
left Microsoft I was working some folk
cinemas are as well on
basically using deep learning to teach
machines how to write code but one of
the challenges is when you're teaching a
machine how to learn to solve a problem
so that it can write the code the
representation of that learned artifact
is not necessarily easily transplant
transcribe level into code and so I
think the more interesting thing is is
code as we know it actually the correct
intermediate representation for the
interface between neural network and the
Machine given that the neural network is
a network of weights and mostly opaque
in terms of you know our understanding
of it so I think a lot of research over
the next however many years it takes is
going to be around teaching neural
networks to interface with computers and
it's just not clear to me that that will
look more like code than say an opaque
assembly language for example that's it
one final question quick answers please
so we've heard a lot about strong typing
being important both for data types and
functions and matern values and so on
but and of course asynchronous code for
concurrency but how the errors handle in
this as well is strong type for error
handling important or for asynchronous
error handling yes very good
perfect thank them all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>