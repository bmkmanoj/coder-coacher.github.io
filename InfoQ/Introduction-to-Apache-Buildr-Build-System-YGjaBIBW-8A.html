<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Apache Buildr Build System | Coder Coacher - Coaching Coders</title><meta content="Introduction to Apache Buildr Build System - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Apache Buildr Build System</b></h2><h5 class="post__date">2011-01-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YGjaBIBW-8A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">jump
so before I begin my talk I want to
preface the talk with different things
first this is a talk that I've done
before at Java zone 2010 in Norway so if
you have been the Java zone it's the
same exact talk except maybe with a
little bit more longer demo in the
middle second I like to have my talks a
little bit entertaining and so I'm going
to be making you know bold statements
and you know somewhat provocative
statements especially about you know
other build systems including aunt and
maven I do use aunt and maven all the
time and I I have a lot to say about
them of course and if you're not
familiar with builder it's a build
system and if you're not familiar with
build systems and don't understand why
you need to build system you need to get
out of your IDE a little bit more right
and i'm also pleased to introduce you
sort of our new tagline which is built
like your code and if you've used any
sort of build systems in the past like
ant and maven and Gradle and make and
there's a whole bunch of them out there
it sort of feels like you're you're
doing something different from your
regular programming right you're now
programming in this other language or
you're now programming in this other
world that you need to learn you know
whether it's you know sort of XML
programming and it doesn't quite execute
the same way as your regular programming
language so you sort of you know switch
hats and work on the build system and
the build system is sort of very
detached you know from from your product
and and I think that's sort of a symptom
design you know fail of some build
systems it's nice to have something
that's sort of separate and you know
decoupled but it's at the same time you
don't want you know the the activity of
working on the build system to be
completely different from what you're
doing you know with the rest of your
system because very often the build is
and what you make out of the build is
part of your product right it's sort of
alka ways of how you package it how it's
built how your
you're sort of assembling the components
together shouldn't really be sort of
this different from you know the other
parts of you know programming so so we
sort of chose this tagline to sort of
you capture that feeling the experience
of you know I'm working on the build
system but I'm still you know developing
I'm still applying all the same you know
concepts and and approaches and
techniques that I've you know learned
you know programming but now I'm just
working on the build system so that's
sort of the idea and and just so you
know the talk has sort of you know I'm
going to be talking a little bit about
the history of the project and why we
built yet another build system and then
I'll sort of jump in the middle into
sort of a live coding demonstration of
you know how what it feels like to to
use builder and then I'll come back and
sort of you know talk about other things
at the end so that's sort of the outline
to talk a little bit about me my name is
Alex bava I'm french-canadian I have
this you know funny accent that people
can't quite you know pinpoint yeah it
sounds French but it's not quite French
it is French but it's a you know a
dialect of French that's especially
unspoken side very different sounding I
happen to live in San Francisco I live
right in the neighborhood of sea cliff
so right by you know on the other side
the Golden Gate Bridge very close to
sort of china beach if you know where
that is so I'm local I was I work
downtown here and I like to call myself
a sort of you know language polyglot
which means you know I use different
languages for different purposes and use
sort of the best tool for the job these
are sort of the recent languages that
i've been using professionally i have a
lot more languages you know under my
belt some of them i never want to use
again i started my career doing mostly c
and c++ development doing embedded
systems especially in the telecom world
so tcp/ip stacks on pbx and things like
that so
the language I used mostly most right
now at the office are Scala and Ruby if
you care to know I'm a builder committer
I am NOT the founder of the project
proper or the you know original author
of the project although the project was
created that in tally a company that I
worked for earlier in the past and so
i'll be talking a little bit about you
know the reasons why we started this at
intaglio but I'm I also happen to be the
PMC chair which is the project
management committee chair of the
project that Apache were a couple
project each top-level project needs to
have some sort of administrative person
who sort of oversees the you know
administrative pieces of the project so
it's not a glorious roll it you know I
it doesn't give me much more powers just
that I andale you know things like you
know the i push the paperwork when
paperwork needs to be pushed those kinds
of things or you know make sure that
process is respected I work for a
company called bizzo there in the online
advertising space we're very much sort
of in the same you know field as as
Google if you want like you know when
you think about where the money is on
the internet willison you know
advertising and abs and all these things
bizzo has nothing to do with you know
builder in itself so i use builder a
little bit at work but there and you
know they they helped me get my job done
and if i need to work on builder than
you know so be it but they're not in the
business of you know supporting
developing and build system it just a
means to an end sort of i use builder on
a daily basis and i've made them several
contributions to the project citizen
started mostly related to the scala
support and plugins and extensibility
which i'll talk a little bit about
during the talk so enough about me and
if you want to stop me at any time
during the talk feel free to do so if
you have questions or I'm a little bit
unclear
or I make a broad statement did you
disagree on you know feel free to cough
I want this to be sort of an interactive
presentation or I don't want to leave
anybody behind and actually our first
like line was the build system that
didn't suck because when we you know I I
was never meant to be somebody working
on the build system I think it's just an
accident of reality I never saw myself
you know working on at that level but
really we we started the project because
I was working on another Apache project
called Apache oh de and apache OD is
sort of this big java enterprise
middleware it if you know j2ee you know
the enterprise Java stack you it's
fairly big lots of dependencies it's in
the enterprise integration space and so
there's lots and lots of protocols and
standards and formats and is the kind of
project where you know we we sort of
feed on many many other libraries and
combine them together and you know make
you know this component talk to this
other component and there's a lot of
plumbing in between the product itself
happens to be a sort of a prod process
management software but the you know
large majority of it is sort of you know
integrating with different systems which
means that most of the code deals with
you know those sort of integration so in
that specific project we have more than
15 modules we support 9 databases which
is a lot of databases we have more than
120 dependencies all of them you know
open source since you know Apache only
allows you to release open source
software as part of your product we had
three distribution so we have sort of a
standalone distribution that ran you
know straight on tomcat if you want like
a war file that you can just deploy like
a web application we had a distribution
that those meant to go into another
product called service mixed Apache
service mix which is a JB I
implementation Java well
losing my acronyms or Java business
integration yes java business
integration so so a sort of a GBI as
sort of an internal data bus inside the
JVM where different components can
connect so that's a complete different
packaging it's a different sort of set
of dependencies and we also have a
distribution which is which complies
with the SCA standard the scalable
component architecture which is yet
another integration standard Java
integration standard and so the
supporting these you know distributions
required a lot of code or you know work
to to package and distribute the
software into different sort of
environment so very tooling heavy
tooling heavy like we have things like
you know sequel generations for the
databases we have you know schema
generate schema generation for you know
generating xml schemas we had an
annotation processor to you know sort of
go and read adaptations and the java
code and generate other classes sort of
name it we had it's right at all of
these things that need to be integrated
together and our first shot at it was
using maven to it was in their early
days of maven to sort of you know maven
2020 120 120 2 and so on and the reason
why we chose maven2 is because we had
used maven one before and it worked
pretty well maven wanted this sort of
language called jelly that allowed you
to do sort of scripting and we have we
have been able to customize maven to do
a lot of you know things that it wasn't
necessarily designed for but we you know
were able to add on top of it and that
was pretty difficult with maven too
especially at the beginning because it
didn't have these sort of scripting
languages around it was it was supposed
to have them you know some time but it
never had or early enough and the main
sort of integration point was you could
call aunt targets and and so we ended up
with a lot of XML
you know five thousand lines of XML
spread over 52 files that's a lot of XML
and and we're all like oh this really
has to be a better way of doing this
right it just doesn't feel right and and
and to be fair you know that the
challenge that we have were not not just
related to maven but how people use
maven right and so if you're for the if
you're not familiar with maven maven is
a very declarative sort of build system
where you use sort of state you know
what you want and you know you don't
don't really care much about the how
maven sort of figures it out and it has
all these plugins that are you know
supposed to do you know handled the how
but in in the way that you declare
things when other people integrate your
components they may even goes and reads
the description and integrates that and
so it uses the description of other
projects to do a lot of things in your
project and and so if other people
declare things in their project that are
not quite right way if they don't
declare all the dependencies or some of
the dependencies are not declare
correctly or the the version the
versions are too strict or they publish
you know a description in the repository
and it's not quite right it's too late
to change it and so there's like all of
these sort of social problems around
maiden that are not due to maven itself
but just the way people use maven right
and so we were sort of victims of this
especially because it was also a
transition way it was early days of
maven so not a lot of project had used
maven and they were all learning
together at the same time and it was
chaotic to say the least so what we
really wanted is you know something that
didn't involve XML at all we sort of you
know grew allergic to XML you know not
the only ones but we sort of have you
know this allergic reaction to XML
something that was a lot more flexible
than maven that works sort of on you
know on smaller projects and one-off
projects and we happen to have a lot of
customizations and ever
time sort of you know if if you're doing
what maven was built to do is great
you're on the path and you're like on
the highway and you're flying at 100
miles an hour if you serve deviate from
that it becomes like the trenches and
you're you know progress is very
difficult and building plugins was
difficult and there was little
documentation and and you also used
other plugins that were not very mature
and you know once again I'm not going to
get into the details but it was painful
and so we wanted something that was sort
of more flexible and easier to extend
and customize we wanted to have a build
system where we could say you know
here's what I wanted you and if I want
to apply it to different things you know
I can build an abstraction for it and
apply this abstraction two different
things and so one of the things we had
was you know we wanted to build you know
let's say generates equal right SQL for
different databases and there was a
there was a plug-in to generate you know
sequel you know out of you know like a
hibernate you know configuration or a
jpa configuration but it only supported
one database and so if you wanted to
support multiple databases you can just
do like you know run this ten times
right like a simple for loop around this
thing and say you know this is what I
want to do ten times like you know
here's the plugin here's the 10
databases I support and we can do that
and and so we have to shell out two and
then run different things and build
different files and so we were really
missing sort of the sort of the basic
you know you know software engineering
tools of you know abstraction and you
know composing components together to in
the build system the dry acronym here is
don't repeat yourself so we ended up you
know repeating ourselves all the time
with you know in palms or an aunt or so
on just because we didn't have these you
know call this function with these
parameters right so in other words we
wanted like a real real language and so
don't you know builder and it just
happened to that
you know as we implemented this or build
got a lot faster and it wasn't a design
goal but it just turned out that you
know at the time and I don't know if
it's still true because we haven't we
don't maintain the bill maven build
system anymore but maven did a lot of
sort of external you know calling of
java the java compiler and the unit test
and so on and you know the bootstrapping
of the JVM every time made it so that it
had you know significant you know sort
of fixed costs every time you did a task
and builder just kept you know one JDM
it we did run the test you know outside
of the vm or in different different vm
if you want but most of the compile and
sort of the decision logic was run
inside the same vm before we have you
know 52 files you know five thousand
lines of code or xml and after we have
you know everything they find in one
file and about you know 500 lines of
code so we're talking like an order of
magnitude change or difference between
the two files how did we do this so
builder builder is built on another tool
called rake and rake is sort of the Ruby
make and so it's it's a tool that
existed before if you're familiar with
make it's it's sort of the same you know
philosophy and rake itself is built on
on top of Ruby so there's sort of three
layers in the stack here so we have Ruby
which is a great you know scripting
language that allows you to do you know
file manipulation and 11 line of code
you know you don't have to you know open
the file input stream and open the
reader and open this and that to go and
read a file or write a file you can just
you know do that in one line you have
rake which allows you to declare sort of
tasks and file dependencies and wire
them these things together and builder
which is just a layer on top which
allows you to also define task but in
the very sort of project oriented way so
it sort of keeps them the Maven style
you know declarative approach of having
like projects and nested projects on top
of wake so why do we choose Ruby again
just because it's a great scripting
language language there's all kinds of
nice features in Ruby that are
convenient to have you know when you're
doing sort of Christa custom work you
want to you know iterate over something
you can just do you know here's my array
and you know 4-h over this or each over
that and in run loops you can easily
execute external programs it doesn't
require you know lines and lines of code
to go and execute like another UNIX or
you know windows binary and run an
external command so very very good
scripting tool very good meta
programming capabilities that are sort
of very accessible for you know casual
use or casual programmer so you don't
have to be sort of a rocket scientist to
use the meta programming facilities and
and more specifically the meta
programming facilities in Ruby allow
allow you to build sort of
domain-specific languages that look like
they're sort of native to the language
and Ruby happens to be a very sort of
JVM friendly language there's there's
sort of two ways that we can run builder
one is as running as JRuby so running
completely on the JVM or we can use
what's called RGB the Ruby java bridge
which is sort of running Ruby on one
side and running the JVM as a sidecar
and so builder starts in Ruby and
whenever we need to call java code it
sort of execute the java code in the JVM
and then comes back into the Ruby world
and it happens to be a very good
compromise because you know the build
tool starts pretty quickly it's faster
than starting jruby because the JVM has
sort of a heavy startup costs so both
both of them are good choices you can
have a full Java implementation or sort
of mixed implementation so I want to
talk a little bit about rake and and you
can sort of think about rake as and it's
sort of that the same conceptual level
in the
back so what Rick allows you to do is if
you have an application that has like
sort of three components right you have
a module that's sort of you know see
here that depends on a and B the way
that you structure these as sort of
build task is you you define a set of
dependencies and you have you know your
your application here that depends on
packaging you know the three components
package a and B and C and C happens to
require a compilation but it requires a
and B to be compiled first and so the
same way that you define you know these
dependencies and aunt like targets and
dependencies that's what rake allows you
to do and it's it works the same way is
you know make and and in the sense that
if these dependencies happens to be
happen to be file like if you have a
file a that depends on and B and C if
they happen to be filed and it will
check the timestamps of the files and if
they haven't changed and the task can be
sort of skipped and so rick has these
sort of built-in constructs to to do the
Pennsy checking but also clever
dependency checking so things don't have
to be rerun all the time and you get
sort of fast build or you only to you
only need to rerun the the tasks that
need to be updated depending on you know
the changes and so if a changes then a
would be recompiled but B wouldn't be
recompiled you would recompile see and
then repackage so you have sort of this
you know transitive dependency or dummy
no effect in the transitive dependencies
so this is sort of rake rake code and
this happens to be Ruby but it's it's
the rake dsl and so in your AQ sort of
depart define a task like task then you
give it a name and then you give it a
block and say you know here's what you
do to achieve this task and same thing
for a compile B and C and here we have a
dependency so see depends on a and B so
this is like an array of dependencies
here here's what we do to compile C
package depends on three other things
and the default task is to package
everything up so
so that's rake rake code and I'll just
stayed in passing that learning rake as
a standalone tool is is very convenient
especially if you have to anything to do
with sort of the the cloud there's lots
and lots of tools that are that benefit
from using rake and for like automation
and starting machines on the cloud and
monitoring machines and updating them
and restarting them and so on so
generally something good to add to your
resume if you think of you know using
sort of cloud technologies very
convenient tool in your tool belt and so
if you were to run this this rakefile
with these tasks and they would just say
you know I'm compiling aid and compiling
B and C and then packaging everything
right so this this same application with
three modules we can redefine it or you
know explain it in builder as such here
so instead of having sort of them you
know individual tasks that need to be
wired together and you have sort of a
graph approach to your task rake is nice
but when you as you add more cast it it
becomes sort of a spaghetti right you
too many tasks that don't have like sort
of implicit wiring so it's nice to be
able to wire things hierarchically
because the hierarchy represents a
natural dependency and so my application
naturally depends on a B and C so I can
just put a B and C inside and I don't I
have this sort of implicit you know
dependency and all these things and then
builder you would you know define the
sub projects and say I want to you know
do a and you know package it as a jar
builder has adopts a lot of the
convention over configuration mentality
and so if you're following if you're
following conventions then you don't
even have to say that you have to
compile something because it will detect
that you have you know Java files there
and it will just grow and compile them
right and if you if you have you know
dependencies between projects you can
say I want to compile C and compile it
with a and B and then package the
resulting application as a web
application for instance package of war
and then the libs that I'm going to be
packaging or
projects a B and C so all of the
libraries that are defined in projects a
B and C so far so good yeah all right so
if you were to you know run this with
builder builder package then it would
just you know go through all of the
tasks that it internally created compile
everything and then package everything
and then package the application which
is the war file and run any integration
tests if you have any so that's sort of
the basic builder usage and we have a
set of default tasks that you that are
defined that are sort of the backbone of
builder which are very it should be very
familiar with to you if you've used
maven and and and even if you haven't
used maven because these are sort of you
know archetypes of you know build
systems so by default we we build the
software so that's the default task here
we build and to build to build then we
sort of copy over the resources and
process the resources sometimes you have
you know properties files and you want
to process them like change version
numbers or add a timestamp in there and
then the compilation would follow then
run the test and that's the equivalent
of doing the build if you want to
install then that would depend on
packaging the software and if you want
to release and it would upload before
releasing and then you know tag your you
know tag your project and your source
control system and so on and there's
other tasks that are sort of stand-alone
where you can clean run some integration
tests which you can sort of hook on to
different places in your bill so it's a
standard task but you're you're
responsible for hooking it into your
project where where you need it and you
cannot also uninstall components if you
if you installed them into your local
maven repository you can install them as
well we support maven artifacts and
repositories so it's it's pretty
difficult these days to use dependencies
that are not right in maven repositories
that's sort of the
the reference in the Java world of
putting all the dependencies and
repositories so if you have if you want
to use repositories you can just say
repositories remote repository posit or
remote is happens to be a ruby array and
so the you know these signs here these
two less equal sign or just append you
know this repository to the list of
repository so this is all you know Ruby
code love for j is an artifact there's a
shorthand to write you know the artifact
which is you know the group the name of
the artifact the type of the artifact
that happens to be a jar file in the
version and you know builder is a DSL so
we have you know different instructions
to you know put things in the manifest
controlling the compile options if you
want to target you know Java 15 the
version compilat log4j and so on so this
is how you use sort of maven
repositories and maven the artifacts and
and so the nice thing about all of this
is that artifacts are tasked to and so
whenever you depend on the artifact then
the task of the artifact is a task that
will go and download or find the
artifact in which repository it is and
go and download it and so all of this
sort of graph graph of task is
completely ingrain into builder and
everything you're doing is sort of
wiring tasks together even though it
doesn't look like we're worrying task
here past here builder supports a lot of
languages this is just an example if you
wanted to bring in the Scala support you
would just type at the top of your build
file require builder slash Scala that's
the location of the scallop plugin in
the distribution and this brings
automatically all of the scowl supports
it will automatically detect you know
skala source compile them you know do
incremental compilation we support mixed
Java and Scala compilation it supports
generating documentation and so on so
fairly standard sort of use a plug-in
and the way you do that
just by using the require keyword which
is a standard Ruby keyword to require
another piece of code which happens to
be a gem yeah I have a small project
that will sort of you know be building
together so I'm going to create a
project SF jog in I'm going to cheat a
little bit I've you know prepared a
little project where I have already a
small piece of code here sort of globe
here and we're going to copy it here
sorry we're getting there all right so i
have a small small project here i'm
following convention so putting all the
source file and their source main java
the tests are under source test java i
have a couple of tests here you can see
that i have a failing test i have three
different java files here and i can
invoke builder and builder will detect
that I don't have a project defined yet
so we'll offer me if I want to create a
project from directory structure so I'll
say yes and then it creates a project
and starts compiling you know the
project right away compilation fails
because the project requires some
dependencies which I haven't defined so
let me just open the build file that was
created here this is big enough for and
everybody can see you okay good okay so
this is a big basic builder file here
there's some comments I have a basic
version the group copyright I'll just
you know strip these out and just keep
you know the necessary parts so the
version is required if I want to package
anything so i'll leave it there the
group i'll just say you know this is you
know our group is you know org SF jug we
don't need the copyright define globe
defines my project so i'll be adding
some some dependencies here and i'm
going to cheat and just go and refer to
my other the build file here that I made
and I'm going to declare two things
first I'm going to use an environment
variable which is called world wind home
which is assumed to be defined in my
environment and I'm going to pick up
artifacts directly from my file system
so directly from this directory I'm
going to pick up all the jars that are
there so just to show that you don't
certainly have to use maven artifacts
you can use files that are directly on
your file system if you prefer that you
can have a Lib directory and source all
the files directly from there the reason
why I'm doing this here is because world
wind is a project that has native
bindings it has it uses OpenGL and it
has native bindings and people don't
typically put you know native code
inside maven repositories it's sort of
frowned upon just because it's binary
stuff that's not running on the JVM
which is a safe environment and so world
with is not typically found in maven
repositories the some jars are but not
the native bindings and having one
without the other is sort of pointless
so that's why I'm doing this here and
also is just illustrative purpose so
I've defined you know world win which
happens to be now or an array of all
these jars that are there and I'm going
to say compile my project with world
wind and just for the sake of it I'm
just going to put a print statement and
print the content of this array just to
show you so I'm going to type you know
builder by default builder tries to you
know build which means I'm we're
compiling the project and building also
implies testing and so we have a visual
test here so this is the world wind
project at work so world win is a nasa
project it uses opengl and it has like
different sort of maps of the globe and
you can do interesting things with it
and put texture on them and sort of do
different kinds of plotting on the map
so interesting projects and I have you
know test cases that need to be visual
because you know testing the software
requires visual inspection to get you
know is the cube rotating as we want and
so on so just an easy way to test
visually so we have its failing test
here and I don't quite like this and I'm
not ready to fixed it so I'm just going
to exclude this test for the time being
so I'm just going to write tests exclude
and we're going to exclude all of the
tests that have you know failing in them
right and I'm just going to run again
and it's going to run the test again
show the globe it's rotating nicely I'm
happy great and so test rotation work
the frame tests work and now we excluded
the failing tests so everything works
and we're happy with you know or built
so one of the problems with these kinds
of tests is you know you don't want to
be running these visual tests on your
you know integration server right that's
not a good idea and so these are meant
to be sort of real run interactively
somebody watching them so how would you
how would you exclude tests that are you
know if you're running on the build
machine and not on your machine right
like just to come and you know how do
you do that right well maybe you know
you could add a variable that says you
know oh we're on the build machine so
don't do this before in the build
machine right well you could do that and
you know that it works it's a good
solution but but really there's a better
way to detect whether on the build
machine is to say you know are we
running endless right and it just
happens that unix knows if you're
running a headless or not so there is a
there's a primitive in Ruby oops which
is called you know is the standard out
so the output is it a TTYL TTYL is an
interactive terminal so are we running
inside of it you know interactive
terminal if so then we can run the test
if not then we shouldn't run the test
because nobody is looking at this right
so just an example of how Ruby can help
you easily exclude test and you know you
don't have to resort to environment
variables and so on so in this case in
this case you know I'm excluding the
globe test anything that shows the globe
I don't want to show if we're not
running on the interactive terminal so
i'll just show you that you know if I
pipe the output of builder into
something else we're not running in an
interactive terminal so the tests won't
be running that's it right simple enough
so far so good yep okay so
let's let me just show a few other right
so if I if I run builder again even if
I'm not in their interactive mode
nothing happens right because I build
the project nothing has changed so you
know it runs pretty quickly you know
nothing happens if i go and touch one of
the one of the source files so i make a
change globe frame right I run builder
again then it will recompile right so
standard build stuff but she wanted to
illustrate this and since we have to
we've rebuilt and we've changed a source
file then we'll run the test again right
so this is just the transitive you know
dependencies at work I excluded the
failing tests and I excluded the globe
test if we're running in non interactive
mode yeah and so so that's why they're
still running right all right and if I
want to we already have the package as a
jar task so if i wanted to package this
as a jar i just type build package
builder package and if i look in my tree
I now have somewhere a jar that's called
you know SF jug you know globe and it
created the jar and if I look into this
jar I'll see all my you know java files
the class files and so on all right just
again basic stuff so let's add a another
project here so Cintron demo I'm going
to add a scallop project in here so I
have different skala files here I we
want to add some annotations to the
globe we have a globe actor so in in
Scala actors are sort of a concurrency
primitive that allow you to sort of send
messages asynchronously and and the
actor will andale the messages in this
case we're using the actor to sort of
rotate the cube to where we're put
the annotations and we have a test suite
22 test that everything is working
correctly so I'm just going to launch
builder here nothing happens because I
haven't defined this project so I'm
going to go back to the build file and
we're going to say define and this new
project is called annotation and if i
define this project nothing happens
because I haven't loaded the Scala
plugin so nothing you know no known sort
of source files are discovered so I'm
going to run and require the scallop
plugin and now if I run again it's now
compiling the Scala files and I'm
missing some dependencies so I have like
these all of these compile errors
something I forgot to show you is we
were we were printing the array of the
dependencies you know the world wind
dependency so have whirlwind ajar
there's a blue Jen here and geo GL here
which is a java binding for opengl so
all of these jars were picked up you
know from from this directive here you
know take from this directory take all
of the jars and you know sort of
concatenate them together so I'm just
going to remove this print out here
because I don't need it anymore and go
to the annotation project and say well
so we're compiling this and I'm going to
compile with the globe project so the
globe is a dependency and I'm also going
to compile with all of the dependencies
of the gold the globe project so all of
the compile dependencies and this so so
our scallop project depends on
everything that was defining globe
no it's not automatically transitive so
right now you have to say I want to
compile not only would the artifact
that's generated from this project but
all of the dependencies of this project
as well so so that it picks up like the
world wind right I'll talk a little bit
more about transitive we have also
translated primitive but I want to sort
of go sort of with the basic approach
here yeah and if we go back to builder
and build this project oh so since I
changed a build file I might have
changed something in the build file that
affects the first project so it's it
rebuild the first project it ran the
same tests and now it's building the
second project and running the test in
this project and so this test here is
just showing annotations on the globe
right so we put in one annotation and if
we put another annotation the globe has
to rotate and place the new annotation
so just again a simple demo here and all
our tests ran and so since I'm changing
the build file all the time I don't want
to rerun everything all the time because
the bill files change so I'm going to
use an environment variable which is
called ignore build file okay and so it
won't be considering the the bill file
is one of the dependencies as I'm
changing you know different things and
so we also want to package oops what
indentation is packaged this project as
a jar file and now I'm going to move to
a third project which I we're going to
call feed which is a groovy project and
I'm gonna
copy the project here if I look at the
project is just too simple groovy
scripts that I can compile and run and
once again this project will depend on
everything that we've done before so it
will depend on the annotation project
and all of the dependencies of the
annotation project so if i run builder
on this project i haven't added the
groovy plugin so there's nothing to do
unless builder knows how to compile this
so now we're compiling the groovy
project which has another dependency
which is called HTTP builder and so i'm
just going to go and cheat again and
copy something from the bill file i have
prepared so HTTP builder is a just a one
of the sort of core modules of groovy
which allows you to do HTTP invocations
get the result it's the dependency sets
in maven2 repository and that's the sort
of the artifact ID it's it's inside the
groovy modules the name is HTTP builder
and i was using version 050 rc2 I don't
know if there's a newer version and in
this case I not only want this
dependency but I also want the
transitive dependency so the transitive
closure of all the dependencies that are
referenced here so I have the transitive
method here that goes and reads the
palms or the project description and
grabs all the dependencies out of this
and just for fun i'm going to put put
out the the
for your print out of this dependency if
I do builder clean so you see there's a
whole lot of transitive dependencies so
we're depending on you know Commons
logging and some JSON library and a lot
of HTTP related libraries HTTP core and
HTTP client and when we now have a
groovy dependency as well from this ASM
I don't know why they're using this and
all of these libraries but it doesn't
matter this is a demo I just grabbed all
the dependencies i'm happy i have lots
and lots of dependencies and if i try to
build again it compiles using the groovy
compiler and i get a few errors because
i haven't told the project that i want
to compile with HTTP builder and all of
its dependencies
run again and hopefully everything will
build right so we've built our project
it's ready to run so how do we run the
project well we could define a new task
using just a standard you know rake
indentation on this is terrible I'll
define a run task and to run the task I
can just say I want to use you know the
java runtime and I'm going to cheat and
so Java commands java is calling the
java command on the command line passing
it them in here and the class pot I i
want to have when i'm running this
command is the compile dependencies of
the project not only the compile
dependency the project but also the
output of the project so the output of
the compilation which happens to be in
compile target okay and since the run
command yep since I've defined the run
command and I'm in the feed directory if
I I builder run it will run my script my
groovy script and the since I have more
dependencies it takes a longer time to
start up and hopefully we'll see
something
yes okay so so this this script
essentially is a mashup so what it does
is it connects to Twitter it reads a
bunch of of tweets I selected the
WikiLeaks keywords so it's giving me
tweets of WikiLeaks it also goes and
gets the location of all the tweets and
from the location so if somebody lives
in San Francisco it connects to the
yahoo geo geolocation API and from San
Francisco he gets a longitude and
latitude coordinates and it takes a
little bit of time because these api is
I'm not a paying member so it's a little
slow they throttle my request but what
we should see hopefully is our globe
with some you know tweets about
WikiLeaks that have been sort of grabbed
from Twitter extract the location call
Yahoo to get the geolocation and so we
have people in the US and if we're lucky
we'll get you know somebody in Japan or
elsewhere that's a little bit more
exotic Australia
and so on so just a basic application
just to illustrate you know building
this sort of you know composite
application built with different
languages all you know wired together
with this simple dsl that's builder
somebody in the UK and so on we could
you know watch this all night and I
actually wanted to run it with a so this
is the code that does you know all of
this you know calls the Twitter Search
API gives this is the query so I'm
querying for WikiLeaks so I'm just going
to try to query for San Francisco Java
user groups see what we get it extracts
you know the response as a JSON document
uses the HTTP builder to call the the
twitter api for forgetting the user
locations and from the user location i
call you know the yahoo geolocation api
with my security key here and so on and
so forth so now that I've changed it to
SF jug if i run it should recompile so
it recompile my groovy code
and hopefully some of you have tweeted
about the SF jug and we'll see something
interesting well this is really slow
oh yeah looks like we're getting some
tweets very nice so we even have tweets
about me bitching about maven is awesome
that is awesome no no this is exactly
what I wanted all right I'm hoping that
all of you have some location in your
twitter twitter account because if you
don't have a location i don't display
them so hopefully Thank You mr. Sanchez
the your location is not current but
that's that's fine they actually twitter
has a cache location to individual
tweets as well so I should really get
the location of the tweets I was lazy
and just get the location from your
profile yeah yeah and I'll to 10 y al 21
is right here so again just a simple
application that i put together for java
zone so now we sort of covered the
basics of you know building the
application taking the components
together so maybe we want to get fancy
and write like a little plugin right and
and so I want to do something that you
know builder doesn't do out of the box
and so something we often want to do is
put some version information into the
jar so that you know you know you know
when the jar was created and I want to
have let's say like the svn version
where it came from and since I don't
want to set up as VN I have get running
and well I can run get here so I'm going
to initialize my git repository and add
some files here I'm just going to add my
build file and commit my build file
right so we now have you know get going
so
just gonna
just going to cheat again and so there's
a so there's a cute command git log
minus 1 dash dash Brady format which
gives you sort of the current version
your app and get so that's an easy way
to get the version current version and
so to build a plugin and builder you
just create a what's called the ruby
module you just give it a name and you
include a builder module which is called
extension and so extension is sort of a
mix in so it brings in some
functionality from from builder into
your extension so that's sort of like
importing importing some code from
builder into your into your plug-in when
we execute so when we initialize this
module it will run the command git log
that I just ran and put it in an
instance variable call version and using
the extension methods that are brought
in by builder one of them is called
after a define hook so it's a hope that
that's run anytime a project has been
defined it runs when the project is
finished being defined so it runs as the
build file is loading we define a
project and when when builder well when
Ruby parses you know this block here it
finds define and when it reaches and you
know your hook is called and so after
defining what we want to do is look
inside the project and look for all of
the packages that are defined that are
defined in the project and we're just
going to assume that they're all you
know jar files right now we're going to
create a file called good version and
write the version number that we
extracted from get here so just create
this file into target enhance the jar so
wire this new file that I created wire
it as a dependent seat of the jar so
that before I create the jar this file
needs to exist right and so enhance is
is a rake method and this rake method is
just creates a dependency that says you
know this needs to happen before this
other task so so my jar file as you can
see is a task so the jar file is you
know is a task that create well that
waits for all of the classes to be
compiled and then you know them up
inside of a jar file and and what we're
going to do is include this new file
inside the jar and put it under manifest
so very simple extension builder plugin
here so I'm going to put this file oops
in the Korean directory here right just
do LS right I have my build file here
and I have good version which is a
separate ruby file and in our build file
I'm just going to say require get
version which is my extension right so
now the plug-in loads as you know the
the bill file is loaded and the way to
sort of hook it into projects is to say
switch
I'm getting a lost into too many files
open so i'm going to add this extension
to my globe project i could do it
globally or i can do it for specific
project in this case i'll just do it for
a simple project so i'm going to extend
this project with the good version
plugin so when the project is defined
the plugin will be called the after
define method that was defined here is
going to be called and so just going to
wire things together so that the good
version well first get is called the
version file is created and then
including the jar and so if i go into
the globe project and i run builder
package it didn't do anything because I
I told builder to ignore changes to my
build file so I'm just going to tell it
no longer ignore the changes to my build
file so now that it detected that my
bill file changes it recompile the
project runs tests usual drill and then
it packaged my project and if I look
inside the jar there is now should be
there is no kid version what did I do
wrong
stand get version yeah let's see if the
file has been created you know the file
hasn't been created
this is fine what did I hit you wrong
did I oh yes okay I didn't save my file
I edited the wrong file and save the
wrong file our test is running again and
let's see so the good version file has
been created and if I look inside the
jar file we should have the good version
failure so again just a simple extension
if I didn't want to run the test I could
just say test equal no and that doesn't
run the test the test want to run anyway
because they've been run anyway or I can
put this as an environment variable and
say you know test because no so I no
longer have to pass this on the command
line so so rake takes any sort of
arguments like this like name equals
value and automatically binds this into
as environment variables inside for use
inside the build file so it's easy to
pass in parameters to task and you know
have conditional expressions into your
build file based on arguments that are
either passed on the command line or
found in environment variables and so on
yeah something we really wanted one we
created builder was to reuse the
infrastructure that was there we didn't
want to go and you know rewrite
compilers and rewrite lots of plugins
that already work and so builder can
reuse any ant tasks that you have or and
plugins that you have and so normally
when when you use amp you define your
your custom tasks using this so this is
an example using XML beans which is sort
of an binding framework for binding
between XML and java java beans and so
in builder you you can do something
that's very similar and the notation is
ant task def and then you can pass in
the same information as you would using
the past f so it's just the quality of a
builder if you want that maps to and
plugins
and in this case it's a little longer
because we're wrapping this inside of
the method and I believe we do some
wiring here so in XML we pass in the
compile dependencies and some of the
some of the project paths here so this
is sort of just an equivalent of how you
would use an XML actually an ant task
inside of your bill file or as a plug-in
so we can just wrap existing ant task as
plugins and so builder for many of our
standard features you know like running
you know j unit or or running you know
code coverage with using curvature and
so on we didn't go and rewrite write a
new plug-in we just reuse and plug in
and just wrap it so that it's wired
correctly inside of builder this is an
example like I was saying we know one of
our challenge with you know generating
database sequel database file mappings
and you know just creating a for loop
around and an ant task so we have an end
task which is the open jpa mapping tool
so there's already an amped tool for
open JPA open JP is just like object
relational mapping tool and so we just
want to generate xml sequel database
schema for all of these databases there
be my sequel or whole and so on and for
each of those we want to run this
mapping tool not only that but every
sort of artifact that are created by an
Apache project need to have the Apache
you know Heather on top of them and so
this task also adds this header which is
the licensed Heather here and
concatenates this header with you know
the generated file and that's like an
example of a typical thing with like
maven you're sort of pulling your hair
out like how am I going to tell maven
depth I want to generate this mapping
file and then for each of these mapping
files and what sadly this little thing
on top of the mapping file it's sort of
excruciating to do that and and you also
want to
sort of a clever mapping so that if you
change the mapping file or if you change
the header file you don't want to
recompile everything you don't want to
recompiling the entire project so you
want to be able to have a clever wiring
so that you know the dependencies are
wired so in such a way that if you only
change this and it will recompile or you
know regenerate you know the minimum
amount of things yeah so just just an
example here another example here is
just some sometimes the artifacts that
you depend on our sort of distributions
or not the artifact itself the artifact
is inside of you know the war file or
inside of another jar and so this is
just an example where the artifact that
we depend on is a war file but our
dependencies are inside this archive and
so wiring tasks such that you know we
download the war file which is an
artifact and an unzip it and then
compile with whatever you know libraries
are in there right of course you could
you know go and every time the war
changes you could go and you know
publish you know the jars into your own
private repository but it's just easier
to say you know here's what you do when
you have you know this this sort of
composite distribution where you need to
point to or extract things from it
because because we run either in JRuby
or we run with the Ruby Java bridge it's
also easy to call just any plane you
know Java class and so the way to call
any plane Java classes to prefix them
with the Java constant and then you know
the fully qualified path to the class
we're doing dot new which is creating
the instance of the class and just
passing parameters and calling the
process method so JRuby in the you know
the Ruby jawbridge do that you know
fairly easily so that the integration
it's it's pretty easy to you know call
any existing Java code so if you're
reporting and build system and it used
to you know call java code or if you
have a Java code you want don't want to
rewrite in Ruby it's just very easy to
call
from from builder I also wanted to show
our support for test inside the build
and so we integrate with a ruby gem
called r-spec and so our spec is like a
specification oriented testing framework
where you can where you can sort of
declaratively you know write your tests
and you can say well you know whenever
I'm releasing you know check that you
know the package that I'm releasing has
a manifest in it and making sure that
the lysis is inside the manifest making
sure that a specific class is inside of
a jar this happened a couple of times in
the apache or the e project where you
know we we rode the build file and you
know it sort of work you know one time
and you know we released and realized
that oh we're like missing files out in
the distribution because you know some
reason so so it's pretty nice to have
also test written as part of the build
file just like your test you know your
software you should test your build and
that's just one way to do that we've
already covered the git version
extension and so I showed you how you
can apply to a specific project so you
can just add extended version to the
project that's just regular this is just
regular Ruby and in Ruby you can extend
any class any class instance and so
these are regular Ruby keywords and
features you can also apply to all the
project by mixing in your your extension
to the Builder project and so all of the
classes that are projects in
automatically inherit from the behavior
so again just standard Ruby stuff and
yeah there's there's a lot of stuff that
you know I won't be covering now we can
ask questions but the layouts that
you've seen source main Java that's not
hard coded so you can define your own
layout if instead of using source main
Java you source java or just Java or
nothing you can define your own layouts
we also have a profiles feature so your
build can act differently whether you're
doing you know sort of local or you know
development testing or integration
testing or production so we have these
sort of profiles that are you know
provide groups of information form that
are triggered depending on which
environment you're running we have code
coverage bill notifications I think you
saw these you know low bubbles you know
what my build finish so that's the
notification feature there's lots and
lots of plugins we have more languages
coming so so i showed you java groovy
and scala today there's a closure plugin
that already exists that we're
integrating into the core now and if I
dare go to the website there's more more
plugins and you know all the plugins
that exist out there that are sort of
amp plug ins already working in builder
so the ecosystem is as big as you know
these other the existing Java ecosystem
I can go to build it apache org this is
our build site if you go to the
community wiki well there's a lot of
plugins that are discussed in our own
documentation if you go to more more
stuff there's there's a bunch of things
here and if you go on the community wiki
we have a page where you know people who
build extensions can sort of register
and add you know their extension there
so if we look at builder plugins there's
different yeah the different plugins and
a lot of these plugins are just wrapper
wrappers around and tasks that happened
to just have provide like a convenient
interface so they're just easier to
reuse yeah yeah there's different
different things so yeah we have
integration with IV so if you're if
you're using IV and you want to use like
the transitive dependency features of IV
or repo you can you can reuse that what
we're doing for the next version in
version 15 is sort of putting
IV into the core builder for for some of
our dependency feature and so builder
will provide sort of an opinionated
integration with IV and the IV for our
plug-in will continue to provide IV as
sort of a generic extension where you
can just program it any way you want or
however you're using it already what's
going to be inside builder is going to
be a more tight integration that's going
to be less configurable but nicer to use
for most cases yeah and and if there's
like sort of one takeaway from my
presentation is you know if you're if
you're scratching your head every time
you sort of go to your build system and
you're like you know this is different
mentality em now you know building my
stuff and I'm not you know coding
anymore i'm building sort of reflect on
that and ask yourself it's that's really
what you want or would you rather you
know use all of the techniques did you
know and apply them to to your build
system and that's more and more common
now than there's more and more build
systems that exist today then when we
start the builder project you know
Gradle is a groovy build system that
actually looks more the more more
similar to to builder everyday except
that it's you know groovy versus Ruby
their their their head they're ahead of
us and in some areas and I think we're
ahead of them in some other areas in
terms of features so you can look at you
know the specific features if you're
adopting one I think groovy will give
you sort of that same experience of you
know coding and nothing like a separate
experience same thing for there's
another cool call SBT the simple build
tool which is written in Scala so so
every language sort of gets its own you
know build system I'm firm believer that
the language used for the build system
is like a main driver for you know the
the adoption of the build system and so
as people I think will migrate slowly
migrated away from maven maven won't
disappear but i but i think the adoption
curve is slowed and you know people
use maven will continue to use maven and
there's no point in you know changing a
build system just for the sake of
changing and build system if you have
something that works for you there's no
point changing but if you're if the
build system doesn't work for you you
know consider something something else
and there are good attitudes out there
and builder is an open source project
and we get contributions you know almost
every week certainly every month from
different you know people use builder
I'm one of the contributors but there's
there's eight other contributors
committers and a lot more people
contribute to the project so if you if
you want to adopt builder if it doesn't
you know fit your purposes you can of
course extend it but you can also
contribute to the core builder and help
us you know make it better so that's the
end of my talk yeah so the question is
ahead how much of a pain is it for I
guess existing you know build engineers
and release engineers and you know test
engineers and like other people not only
developers with other people i guess
that are either using the build system
or integrating it into sort of the IT
landscape i think that depends a lot in
the IT environment builder integrates
very well with hudson and and all of the
continuous integration build tools it's
it's just a command line right so if you
if you install it on the machine it's
it's a question of installing ruby and
installing the the ruby gem so doing
like ruby gem install builder and if
you're on you know one of the supported
configurations you know Mac OS you know
linux windows then it should just
install easily and then you can use it
like that I know on here with another
builder committer was thinking and about
doing a Hudson plugin for builder so
that it's sort of easier to you could
just you know use them
house and say you know install and it
becomes part of the Hudson configuration
I think that's a great idea and that it
would you know ease you know part of the
no pain of integrating builder to the
culture and environment of large you
know company and then the rest i think
is just how you do it right introducing
any kind of technology into an IT
department it's how it's you know how
you coax people into managing you know
the change you start with a small
project or you could do like a covert
you know operation where you know it's
just Java so you know it's just jruby so
it's just a gdm it you know it works
differently in two different
organizations I haven't been in an
enterprise e company for a while so I
don't know and I haven't had to do that
I know that a visitor where I'm working
now they have the significant investment
in ant and they don't see you know I
need to change or move away from that at
least for the existing projects and so I
think the question is more relevant for
for new projects and just like any
technology adoption you want to start
small reduce the risk and that's you
know proportional to usually the company
size and you know how many people are
involved and and whether you're sort of
an isolated project or you know the
cornerstone of you know the company's
future yeah yes so the question is I
talked about consuming artifacts maven
artifacts from maven repositories do we
support you know publishing artifacts
and repositories we do and and part of
the question was whether we generate
palms and so on so so so right now we're
support for remote repositories is we
can go and put things in there both a
jar and a palm with the caveat that the
palm doesn't embed a lot of information
right now just because the the way we do
dependencies is different from the way
maven those dependencies and so
right now we we don't put dependencies
in there by default and then you can
override the palm by yourself and
declare whelmed you know you know these
are my test dependencies and you can
grab them from your test task and so you
can do that there's been a recent
contribution where this some of it is
done automatically for you and so I've
been reviewing that and it's been on my
desk for a little while it just had the
second child recently so that's been
taking my priority but that should be in
the next version so minimal support for
for that so you'll get sort of a default
you know should do the right thing for
simple projects and if you have more
complex projects you might have to do
some manual mapping and in our hope is
certainly to have you know if you're
using the maven dependency system inside
of your build file and if you're already
managing your dependencies in the same
way that maven does with you know
compile runtime provided and so on then
you would get exactly sort of the same
experience yeah and and because you know
we'll get this from from IV which does
the right thing for maven yeah so the
question is since we don't publish you
know complete dependency information
inside the palm how do I say what's the
best practice for sharing artifacts
between two teams or you know to
external people well I think one option
is to just you know provide the
information which is a little bit more
work but you can provide information in
the palm and you get exactly what you
want as a personal preference and
opinion I'm i think i'm considering a
heretic in the transitive dependency
world but i have faced personally so
many issues with transitive dependencies
that I don't do transitive dependencies
at all anymore ever maybe i'll do it for
when i'm starting a project and just
like to get off the ground but there's
there's two sort of schools of thought
here there's which i usually label as
whitelisting depend
season blacklisting dependencies right
so so maven is essentially a
blacklisting model where you say here's
the dependency I want and it will get
the transitive dependency for you and
then you sort of manage things by
exception so you black list things and
so you say well I don't want this jar I
don't want this version i want this
version instead of this other version
and so that's one school of thought the
other school is white listing which is
I'm going to tell you all the
dependencies I want and explicitly and
there's no guess work because I give you
a list and you take this list and run
with it and and I personally found that
this model works better on bigger
projects and and it's it's a little bit
more of a pain to do it for smaller
projects but I take the hip and and
adopt this and so I haven't found
transitive to be transitive dependency
and information and palm to be useful on
large projects because I there's so many
exceptions that you end up doing a lot
of work a lot of sort of guesswork and
yeah over time and so let me just finish
the thought here so I I equate this a
little bit to sort of the optical
character recognition OCR right OCR has
been that level where they have like
ninety-nine percent accuracy right they
recognize you know you put the sheet of
paper in and they recognize 99
characters out of the hundred well
nothing with this new witness google has
been that we this sorry optical Kenny
yeah mission right hidden is right cuz
I'm far has been the South tuner they
have artifact nine percent maximum see
right trees recognize do we sublet paper
in yeah from Thais nitrogen is in / out
of the hundreds when welcome we
this palm we miss tickle tickle and
parts been that is whether they have
very happy Paul ninety percent of the
park night recognized said the putter
paper is paper I said the puff those
nights out of the honda said the pot of
honey I said the pony this to
traditional way to optical captions and
we nation right now other way right the
bar has been that there they have had
away with ninety percent see the sea
right the way recognize does to your
paper in hitting guys nights out of the
hundred well we'd this we miss tickle
tickle far spin this thursday very hello
nine percent recognize recognize your
paper we'd this number two sorry but
optical camera petition right it's
alright but far has been the saboteur
they have about nine percent but for me
nine percent for me recognize and for me
recognize and for made a paper in for me
to make right inform a few guys night
and for made out of the hundred for made
out of the hunt and for me I weighed
this to sort of optical cats and fishin
right and so far right and so far has
been then so I want so the question is
when I say whitelisting I do I mean
flattening out all the dependencies and
putting them on the same level and
managing them this way not really that's
that's the simple case and that's sort
of what I've been showing in this talk
how it works out it works practically is
a little bit like what we used to do
with maven one and and so when you start
doing whitelisting you start saying well
here's a group of dependencies that we
know work together well and so for
project something here's the list of
dependency and so project something
becomes like an array right or a map or
something incidence yes it is including
instead of exclude but
when you're when you're doing these
lists you can package them into arrays
maps you know different categories
however you want and you can because
because Ruby is very flexible you can
now share these lists and so you can
have multiple projects depending on the
same lists okay and so that's sort of an
alternate system two palms where you're
publishing these lists and lists of
dependencies although you're managing
all of them explicitly and so if you
have multiple projects and you know
inside one company multiple you know
you're publishing artifacts and
consuming them you can share these lists
20 you do with palms except you're
managing them versus somebody in the
intranet that decided that you know
dependency X was dependent on log4j 12
14 and not 15 okay so so I think three
questions so whether we support
snapshots yes whether we can enforce
that we're always using the latest
snapshots and whether we can publish
into snapshot repositories so yes to all
of the above we so we support consuming
snapshots and so we look again in this
many fast file it contains all the
snapshot pick the last one you can
enable or disable the feature and so
that's an environment option I don't
remember exactly the name of it but it's
like you know snapshots yes or false
true or false and if it's true then it
will check for snapshots and by default
it's false and so by default it's false
and you have to specify it on the
command line to say I want to refresh
the snapshots and then it will take the
last one and whether we can publish
snapshots in snapshot repositories right
now it's a manual operation so you have
to do a conditional right so the same
way that you define remote repositories
right now you say you know repositories
remote equals blah you would say if my
version is this is a snapshot so you'd
probably use a regular expression just
to check at the snapshot then use this
repository otherwise use this repository
that's how we
do it today there is somebody working on
sort of native support for snapshot
repository so that they're published
automatically to snapshot repository so
so right now we have sort of one
repository source of repositories where
it can be snapshot or both and we're
separating them to be sort of in line
with the Canadian conventions word for
today I would probably adopt something
like Gradle or SBT in combination of IV
starting from a clean slate I would not
personally use maven 3 myself despite
all the features that they've added just
just because I sort of fall out of favor
in my own set of preferences and
opinions yeah and and I have a and for
that reason I haven't kept up with all
the new features that are in maven three
I know they've improved a lot of things
they fix a lot of things but I haven't
kept up so I couldn't give you sort of a
good and fair comparison mostly because
i don't have the accurate information
now and build systems are quite complex
and even if you ask me questions about
builder sometimes I don't know I have to
go and look at the source or yeah but in
terms of just philosophy builder is such
a small code base and it's very flap I
it doesn't take you a long time to
understand exactly what's going on
whereas for me maven has evolved into a
bigger and bigger and more complex
software a sort of a bigger framework
and and and the way I explain this
better is you know it's the difference
between the library and a framework
right a library you call it right you
call the library and you say do this and
do that a framework calls you and and so
you're always sort of at the mercy of
you know whether their hooks that I can
play with so that I'm called at the
right time to do exactly what I want and
so for this reason for me it's sort of
you know not my first choice anymore
yeah
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>