<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Art of Metaprogramming in Java | Coder Coacher - Coaching Coders</title><meta content="The Art of Metaprogramming in Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Art of Metaprogramming in Java</b></h2><h5 class="post__date">2012-09-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0b0hrd6k1Zs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so meta programming um what is made of
programming meta programming is kind of
little hard to define but what is it
what it is it's pretty much writing
programs that are capable of writing or
manipulating other programs based on
some kind of metadata so we have
metadata out there and we have a program
that goes pretty much reads it processes
it and does something with it changes
itself or produces something else based
on that on the predefined metadata it is
not generative or automatic programming
it is not it can be but it is not all
the time it is supported by a lot of
languages and platforms it's something
that is a in editor and of youth
something that is not willing to stood
and kind of somehow like am a black art
so unless you are somebody who's writing
frameworks or doing that kind of work
you're not really going to feel the need
to do any serious metaprogramming you
know as much let me put it this way next
slide so certain concept that we are
pretty much going to go over right now
before is the concept of the meta
language which is simply the language in
which the meta program is written in so
the language that goes and process the
metadata and then does something with a
dusty middle language the object
language is whatever pretty much comes
out on the other side so we say that we
have reflectivity your reflection when
the meta language and the object
language are the same when Java reads
XML produces java based on that
particular particular XML or when Java
pretty much goes and reads any other
format or like any other form of
metadata and does something with it we
say that that's pretty much like
reflection when the language actually
looks at itself next slide please so
meta programming takes multiple forms in
the wild it could be as simple as
exposing the internal of all of the
runtime
or in the compiler as an API if you have
a language that pretty much gives you
the capability to ask the runtime
questions like what type is this class
you know ask and get information about
the signatures of a method of a class
for example that is a form of meta
programming or a language that allows
you to actually control the compiler
from within the language itself or it
could be something like a language that
would allow you to dynamically execute
expressions containing code so and it
could be just strings and java or like
Python you give it a Python expression
and it pretty much execute sit trying to
extend or it does not have to be
strengths you could be as well as series
of method calls and it could be
something as sophisticated as a program
transformation system meaning that there
is a description right there that gets
transformed to a target language the
compiler itself pretty much does that
you give it the java source code and
they translate and then compiles it into
this bytecode or even binary you know in
certain for other like languages that
don't have an intermediate language yak
takes grammar produces C++ or C or C
code containing the YY parse function
and enter great project by the way usage
in code why would we use meta
programming these are a couple of
examples there is certainly a lot more
but when you have a lot of static data
that can be pretty much precomputed or
pre-generated at compile time let's
assume that depending on your
environment you have to create these
huge pretty much look up tables you
could either wait until the program
pretty much starts and take a
performance hit and do those
computations over there or you can't
redo that before you know write code
that will interact pretty much with the
compiler or like asking at one time
itself about certain information and
have that data pretty much prepared for
your application before it starts or it
could be this is partly the most useful
features to eliminate boilerplate code
that cannot be abstracted in functions
for dryness sake
sometimes we have a lot of code that is
scattered all over the place that we
couldn't simply just go and motorized it
and put it in like a function or like a
study or like a utility and be able to
pretty much like call it you just can't
do that it's all over the place as an
example aspects in an AOP that deal
where they're cross-cutting concerns and
stuff and we we're pretty more we're
going to go over that in a little bit
the concept of stereotypes in spring for
those of you are familiar with spring
with the spring framework you could
simply just pretty much go and annotate
a particular class as controller and it
would magically acquire control of
behavior and know how to pretty much
deal with you know HTTP and bring you
much become a servlet a simple POJO
becoming a servlet and this is because
of the techniques of meta programming
instead of actually forcing the user to
do all that kind of work next one so the
benefits in code of course you get like
pretty much a performance gain if you do
a lot of things that compile time versus
like waiting until the runtime of the
application gives you great flexibility
and in terms of development time it
minimizes the lines of code to express
that solution a lot and I'm going to go
back to the spring example I mentioned
before productivity gain and it reduces
the development time and efficiency all
these things are kind of the same thing
in a way they're all interrelated so to
go back to the model-driven engineering
that we mentioned before model
engineering as is or like the philosophy
is that is pretty much that there are a
lot of artifacts that are good candidate
for other generations we all build
applications will end up dealing with
the exact same abstractions in when we
deal with the non-functional requirement
anyways you know you have security and
you have login and the way the
architecture of most enterprise
applications does not really change most
of them are pretty much entered and we
end up with all of these abstractions
and we end up rediscovering pretty much
the best approach over and over again
what mde says is we should rely on
cogeneration rely on pretty much
scaffolding as much as possible and
pretty much have the
developers focus on the domain itself
you create your domain model and you hit
you type a few commands and a lot of
stuff gets pretty much generated for
your like all that boilerplate or the
entire even structure of the application
would get generated for you based on
that thing can get a ruby on rails as
well spring grew on the java space as
well so now that we've talked about what
metadata is we've talked about to an
extent what made a programming is let's
talk about made of programming in Java
the first thing I would like to talk
about is Java annotations and I'm
assuming a lot of you guys are familiar
with it it's been around since Java 1.5
and it's defined by the jsr 175 so
before what we used to do is pretty much
would go and add the metadata as a part
of Java doc in the comments so like as
an external XML using pretty much x
doclets and we built all these tools
around it they would go to the comments
look for specific tokens and pretty much
extract that information what jsr 175
introduces these annotations that are
more readable closer to the code they've
statically typed which is a which is
which is very nice mean if if you're if
you're a Java person and can be pretty
much retain and tell runtime because if
you have stuff in comments and then you
compile your class the comments are
pretty much thrown away after the code
it's compiled and you're not available
for you in one time so I notations are
so I'm a lot of them the JSON 175 define
some annotations that are part of the
JDK itself like override and deprecated
suppress warning if you use of eclipse
or any other ideas they're pretty much
like do that for you and all I can put
like a little warning for your photos to
be added DJ saw 250 common annotations
for the Java platforms defines that and
a good set of them post construct as an
example at resource to deny all some of
them like for are used for security post
constructor more very life
life management of the actual of their
of the PO Josephine's next so um the
good but if you don't want to take
advantage of metaprogramming one start
your right when you start writing your
own energies not a very minute very many
people pretty much like do that but and
before we do that I'm going to show you
some code I would like to go over
certain annotations with you that will
pretty much give you an idea of what of
what we're talking about so when we use
the the at Target that pretty much tells
the JDK hotels pretty much java that
this particular annotation is pretty
much used to annotate either a field or
a method or a package or parameter
wherever it is so just an indication
tells them this annotation can only be
used for this particular type next one
and add v10 shun this is pretty much the
retention that we talked about there are
three different level of levels of
attentions of the actual annotation
itself this is something it could be
retained at the source level that means
when the code is compiled it's gone so
be an equivalent to pretty much comments
or class something that is included in
the class file but the JVM doesn't
really care about it or like at runtime
something that stays and that
information is pretty much kept why the
code is live and running I documented
whether you want your annotation to
pretty much show up in Java code in Java
doc or not and lastly inherited whether
you want that particular annotation
should be passed down the inheritance
hierarchy the last thing I'm going to
talk about and everything is going to
make sense when I show you the code in a
little bit is the concept of attributes
these annotations have attributes mean
and if you just annotate something get
ID that's probably sufficient but if you
educate something at table you might
want to be able to add extra information
add extra attribute like the name of the
table and and and and such so there are
certain restrictions around the values
of attributes like that they can only be
primitives in Java only it can only be
strings they can only be announced and
they can only be one dimensional array
is
of the above I think their law class as
well and they may have default values
and the modifiers are not allowed next
slide so this is a piece of code can you
guys see it okay so this is pretty much
an annotation um that's called called
freedom adds a code review what we want
to do is pretty much one Allah want to
build this tool that pretty much goes
and scans our entire source code and
detects and be able to tell us whatever
all the methods for all the classes
within our source code was reviewed when
I went and a review on they go under a
review or not so we allow people to
pretty much annotate their classes at
code reviews and specify a list of
authors and specify pretty much a
creation date and we just leave that so
the way this annotation is pretty much
created is the second piece of the code
right there we use public at interface
instead of public act class we call it
code review and in we go and we define a
set of attributes notice that the
attribute authors is pretty much a an
array of strings the creation date is a
string and it has a default as a string
I want to ask me you know why is it as
strange because they and objects regular
objects are not allowed to be attributes
for annotations in Java so we just put
it as a string and right there the int
version the default version is one and a
status which is pretty much the status
of the review itself whether it was it
has been reviewed on that and that's
just pretty much a value of an enum so
um yeah notice that if you don't provide
a default on the Java annotation the
compiler would actually force you to
provide a value so I only provided a
list of authors and appeal in the
creation date I would be just fine
without going pretty much just creating
the list of the authors and everything
would get a default Java is not going to
complain but you have also the optional
pretty much overriding the default value
next so misc you can also enjoy I can
also annotate packages but to annotate
packages in Java what you have to do is
pretty much create a file called package
dash info that job
inside the package itself and in there
you provide pretty much like a list of
annotations annotations of that
particular package one thing is we have
the habit every time we want to create a
Java file of pretty much just going and
creating that class and passing package
dash info that's not going to work
because this is not an actual valid name
of a valid name for class in Java so
make sure you create it as a file that
Java next so meta programming in Java
metal annotation processing I'm going to
go over the different API that would
allow you pretty much to do that and
this might be like a little boring for
some of you may be a little bit more
interesting but the next section would
be a would be better after we have this
after we constructed this metamodel week
we pretty much created all these like
annotations what you do with them so at
one time when your code is pretty much
running assuming that the annotations
that you created to be processed have a
retention of a month on retention we use
pretty much simply JSI 175 which is a
reflection our reflection is it's pretty
much reading the annotations needing the
arbitration this is pretty much like
done in reference to the structure of
the program so what you do is you ask
the question this particular class of
the class named a certain way or this
particular field of a class give me all
the annotations that are pretty much
associated with it so this is done in
reference to the structure of the code
itself JSI 175 pretty much defined the
reflection api for this there was a lot
of work that is redundant and tedious if
you want to make your life easier you
can pretty much pick up the reflections
library which is a great library and
then a lot of that work is pretty much
going to be abstracted from you first
reflex is a very interesting library
which is a little more dynamic little
more not dynamics little more fluent
like a fluent library for annotation
processing reflect and i assume is one
of my favorite as well so this is an
example we quick a quick example we have
the annotation class and we go my class
that class give me all the annotation
and that returns an array of every
annotation used in that particular class
and you pretty much go and iterate
through it and verify whether it's an
instance of that particular annotation
of my annotation that we were looking
for and we do further processing you can
print up pretty much the value of the
attribute by my annotation that value or
do pretty much further processing with
it that's a little bit that would be a
little bit more interesting next one so
at built time it's a different story you
don't you cannot you mean you you don't
have the JVM yet I mean your code is not
on the JVM to just pretty much like a
skit give me the relations of this
particular class so what this one is
called is mirror based reflection
meaning that the annotations are pretty
much accessible through a process where
actually I notations are accessible
through a process of API and we're
reflective capabilities are encapsulated
into intermediary objects called mirrors
so what this API does it looks like it
looks up your entire code and it pretty
much creates kind of mirrors that hold
the metadata of your actual of your
actual source source code in Java 5 this
was not standardized and we used to use
this tool called apt which is pretty
much a standalone tool with the mirror
API comp that sunday mirror so you use
app then he goes over your code and you
can ask it questions about particular
annotated elements but in Java 6
fortunately jsr 269 was introduced which
is the pluggable annotation process of
API and it's a kind of very interesting
jsr 269 leverages jsr 199 which is the
java compiler api java java see that
would allow you to pretty much
programmatically invoke and invoke java
sea it has the most important thing in
implementation of the service loader in
interface and it which pretty much would
allows the capability to actually
provide certain services for the java c
compiler and and and and have been
pretty much execute them for us while at
pretty much like build time and that's
what Jace off 24 is
we got to go in a little details of how
this is done very soon here so the java
269 extends the Java Sea as a plug-in
and allow us to write custom annotation
processors this is great because it
provided seamless integration with the
Java Sea or what Java C does is just
pretty much starts fine if there is an
annotation processor register to process
a particular annotation and in a plugs
it into the compiler of itself it goes i
have i'm looking for at code review and
every time that it complies the class as
well as it goes through your source code
a fine add code reviewing it processes
it and a certain way so jess after 69 to
drill a little bit the details of this
it's two parts one of them is pretty
much the fact the act of writing the
actual the part that lets you write the
actual annotation processors and lets
you interact with the processing
environment which is defined in the
package java x annotations processing
because you don't have system that out
yet I mean system dot out dot println is
something that exists in the runtime
means literally a class of a part of the
JDK that that is available on one child
so um there are certain interactions
that you would need with the environment
like getting feedback and taking care of
errors and all of those things and let's
show you a code example in a little bit
and it has the part that models the java
programming language which is pretty
much java x leg model the mirror API
that we've talked about as type
declarations and types and by the way it
kind of knows about generics we all know
that the problem with generics one of
the problems of Gerak's in java in one
time is type of asia I mean the list of
integers or a list of strings it's just
list for the JVM itself for backwards
compatibility reasons the mirror API
knows that this list is a list of
strings that is different from like a
list of integers so if you were to do
this in code and i'll show you an
example a very short example what you do
is you provide an implementation of the
processor interface
and meaning that you will provide some
kind of implementation of a process
method right there and you can figure
your processor using certain annotations
supported annotation type supported
source and its reporting options I think
it would be best right now if I just go
and show you a little bit of of the code
via quick not going to spend a lot of
time in this so can you guys see okay or
should they make it little so they zoom
in a little bit is this okay so yeah so
anyways I think I just got some of them
can you guys see okay that's fine okay
so what we have right here is we have an
implementation a class right there
called for type processor and by the way
for type is one of the annotation that
I've written myself and that extends an
abstract processor right there there are
annotations out there that i'm only
going to do this if the supported source
version is pretty much like java 6 and
the supported annotation and looked at
look right there they provided the full
fully qualified name of my actual the
actual annotation that i'm trying to
pretty much process so the Java Sea
pretty much goes and then has all these
registered processors and then pretty
much compares the fully qualified name
if he encounters the for type
annotations they pretty much execute the
following code the process method is
right there and I take some you know a
set of type element and there the actual
environment itself and that's pretty
much like further further further
further processing I am NOT going to
drill down into the details of of this
particular code but it's something that
is pretty much straightforward one thing
that I would mention is pretty much this
boolean that is returned right here by
the function itself it only tells the
the java see whether i am done
processing the for type and they should
not mention it to other processor or
whether i should make it available for I
don't like you know if you have two or
three
you can want to vacate you can either
like claim it back or like process it
again or pretty much or or not so going
back to the slides I can adjust the zoom
level we good okay so registration right
now you went in you start your provided
this implementation you're ready to reg
it so how can you tell the java see each
other see your body there are two
different ways the first one is simply
pretty much using the command line and
you pass through java see an option
called processor and pretty much we tell
them they said this this is the list of
the processor classes they are pretty
much provided the four type processor in
my case there are other options for
example that would enable and disable
the discovery of this processor if you
want to if you want to say that on the
use of these or these processors by the
java compiler itself but they're the
best way of doing it the way I do it is
pretty much to leverage the Java service
provider API jsr 22-24 that I am that I
pretty much that we mentioned briefly
which pretty much would allow the
compiler to already discover and
automatically pick up all the processors
right there for your coat so these are
some detail right there of how you could
do it but I might just show you be like
much easier to just show you the code
this is very simple you can simply
pretty much just go and create and their
their mirror and folder a folder not of
an inner folder pretty much called
services and you provide a file named
with the actual interface that you want
the Java Sea to pretty much discover and
in this case since it's the arm since
it's the jsr to 72-69 processor we
actually named the Java X annotation
processing processor so the compiler is
going to go and look for everybody that
pretty much provides an implementation
for this interface
throughout the class thing and pretty
much use it somehow and inside this file
you provide all the implementations that
you want your compiler implementation of
that class you want your compiler to
pretty much consider or pretty much
execute and there's an array over there
of them of implementations processing
different annotations right there you
can pretty much like a play with the
order you know and define like pretty
much a position and all that stuff its
premium is defined by the spec what
pretty well defined by the spec itself
so since like wicked and boring even
with the entire slides and pretty much
this is what it is oh now that we
learned all these api's and we learned
reflection how we can ask the runtime
about meta information associated with
the annotated elements we learn how to
interact with the compiler itself and do
that at compile time what to do with all
this information that we have access to
and we can read what you do is it is
pretty much to construct a metamodel you
go back and what a metamodel is it's
pretty much when we take the metadata
and we process it into something that
can be accessed pretty much
programmatically as simple as pretty
much a data object that is associated
with like a field and want my field
classes this is pretty much the
information that is associated with the
one field encapsulated in one dto of I
mean DT arrows probably the wrong in one
poggio to use like a right word so this
metamodel could be something that is
static or could be something that is
dynamic a metamodel can be nothing as
simply tagging the annotated element as
an ID this is the ID of my class it
could be something as complex that would
provide metadata context of the
annotated element itself this being said
that the field can have three different
annotations or that we bring in
attribute values with them or it could
be simply just pretty much a tag this is
an idea this is
you know a a unique this triple this
this this is repulsive and not no value
for jsr 303 so what is a static
metamodel to be very clear they have a
little code example short code example
for you for that it's pretty much what
we do is we create this one all know
knowing God object that would
encapsulate every possible metadata
value that could be associated with the
one annotated element if you have if you
allow you have an annotation right there
that is for fields you allow that the
target whose target is like a field you
allow what you do is like you create
this this pojo that has all possible
open fields of all possible attributes
or all possible bits of metadata that
could be brought in about every
annotation whose target is pretty much
filled it'll become clear in a little
bit the advantage of this and it's very
simple you know that this is a field and
you know that this is all the metadata
it could ever be associated with it it
statically typed and with Java people I
mean mostly we kind of favor that in a
way the disadvantages is pretty much
you're going to have nulls all over you
go back to the next slide so right here
we have certain fields for example we
have a private long ID that is annotated
with ID it has like a generated which is
like another annotation that tells you
how the value of that particular idea
generated we have a column name
associated with ID the second one is a
full name only have at column the third
one is email and it's actually annotated
with that unique and at column has like
an email right there so we have three
fields they have different combinations
of of metadata of different combinations
of annotations so what may our metamodel
is going to be it's going to be a POJO
that called possible metadata that's
going to have a boolean to indicate
whether that particular annotated
an element is an idea or not the name of
it whether it's unique a boolean again
or like the actual strategy which is
which has to do with the actual how the
value of that particular element has
been created now you look at this use it
for like the ID and you see that all of
these ones pretty much is ID has a value
and it has a has a name and it and it
has pretty much a type but there is
nothing but it's pretty much like a
default false for like uniqueness which
in the case of primitive types itself is
kind of problematic because um it does
not really make sense i mean there is no
no for primitive types and it's kind of
false which I don't know if you if I
said this one right or not but anyways
in the case of the second one which is
full name all of those values over there
are kind of irrelevant the only one that
we care about is the actual name itself
we look at the bullion they're both
pretty much false because that's pretty
much the default which does not really
make any sense much much is much easier
to do it to deal with because we could
just have getters and setters of this
possible feeling much metadata possible
metadata object and you pretty much ask
the questions give me the name get name
is unique get me the type so we take all
this ones and then we put it in a map of
object that would map the actual field
in the class to all possible pretty much
metadata right there and that's actually
our static metamodel the next one is a
lot more interesting which is pretty
much a dynamic metamodel and we kind of
means certain people would call this
destructive the code the ravioli code
mean that it's very small and loosely
coupled the Koreas constructor very
loosens very very loosely coupled and
small components which is as simple as
actually pretty much applying this
simple decorator design pattern can I
kind of making the observation that all
of these fields are kind of decorated
with these annotations right and
you pretty much go that so what you end
up with is a dynamic model which is
pretty much just like a map a map of
maps that is very flexible but it's kind
of complex complex in terms of
processing the annotations itself in
constructing the model but it's a it's
it's correct and it's very very flexible
I am NOT going to go down and explain
and drill into you know what a decorator
design pattern is all like how it's
supposed to look like but if you want to
discuss that with me after the
presentation I'll be glad to and they
have actually code to show for for this
okay go next so now that we have we
process the annotations using this these
api's know we created them who created
this metamodel dynamic or static it
doesn't really matter we would need some
kind of validation I mean you can't just
let people especially if you have
somebody that writes pretty much the
framework somebody who creates hibernate
you can't expect people to just pretty
much do things the right way and then
highlight this was like with it with an
example so um what validation is in a
nutshell is pretty much ensuring the
validity and the correctness of the
semantics of metadata because metadata
brings in semantics it tells you that
this is a column tells you that this is
an ID it tells you that this is a table
and there are certain things like in a
table you could only have like one ID
for your particular framework if you
don't that's that's what you want that's
your pretty much choice and
unfortunately compliance with these
additional consistency constraints of
outside the Java language spec the only
thing that is enforced by the compiler
of itself is at target is when you
create your annotation you say then I
want this annotation for methods to be
only allowed four fields to be only
allowed for classes so assuming that
you're writing for example jsr to be 18
which is enterprise javabeans you are
you woke up this morning you felt very
very well you want all right I'm tired
of these guys on creating my own
implementation so in the spec
it says that a bean or like a POJO can
be both annotated stateful and stateless
this is completely allowed by the way
and compiler is not going to complain
but it does not really make any sense
you can't be both stateful and stateless
at the same time and if you have the one
creating this framework or providing its
implementation you should have a problem
with this and say this is not pretty
much allowed in mostly in the runtime so
this is anything but simple you know
constraint a constraint satisfaction
problem it's very hard I mean you can go
and read up on it online there are a
bunch of them oven algorithms and
solutions for it if you are interesting
you're interested but these are pretty
much out of the scope of this
presentation so um but it's not really
that bad I mean because you're the one
who creates those annotation you suppose
that you created ten of them and you can
pretty much just sit down and have some
kind of very simplistic algorithm that
is like conditional that would pretty
much define certain rules a certain
logic of that would answer the question
whether this is valid or not you know
just say if you process a particular
field and it has stateful and it has
stateless at the same time throw an
exception and say that this is not
allowed as simple as that um go back so
this is pretty much the imperative way
java but what you end up with is a
jungle of if statement crazy and n
maintain balls and you're just going to
end up shooting yourself in it I am NOT
I'm not promoting that by enemies so um
or you could solve these things in a in
the logical way that means using a logic
programming language we're actually
semantics are actually represented in a
way there is declarative as predicates
and we procedurally interpret query
pretty much resolutions what you do in
Prolog for example it's pretty much gone
you stay these are the rules these are
pretty much the fact and you ask for log
itself a query and you pretty much can
it have valid or like invalid this is a
good way so um if you
on Java there are different
implementation of the Pollock
interpreter interpreter in Java there is
a true prologue there is j log and there
is also an interface to sweet prologue
if the prologue happen to be installed
in the actual machine which is pretty
much sushi gen AI interface it's great
but you're going to have to nepal out if
you're not familiar with it you don't
have the time for that then it kind of
sucks it's a lot of fun though or if you
happen to be familiar with closure which
is a very nice language it is this bike
you could that runs on the JVM as well
you could use cord out logic which
pretty much support logic and constraint
programming and there's like a very nice
API actually will allow you to do that
easily there are other options for you
that you could explore one of them is
the probe I will roll language open
source and it's out there mercury as
well it's like a logical programming
kind of type of language and all of
these ones run on the JVM so they are
very nice they've actually pretty well
documented in the case of prova but
there is not another option another
option is pretty much you use those
inches that's what was engines are for
so probably one of the most popular ones
the jewels expert by jboss which is
pretty much highly performant an
optimized rules engine and they would
allow your rules to write the redefining
mean level which is just an expression
language or XML not that hard at all a
lot of you up pretty much like familiar
with the dealing with all these
expression languages and jsps and all
that and it integrates very nicely with
java collaborative photos it's pretty
much a library a jar file you pretty
much include in your project ewing
include that dependency you define these
rules in a particular file and you
pretty much take your meta model and
then you validated against those
particular rules and you get pretty much
feedback from the engine as actual java
objects which is very nice so check out
drools experts now that we process
this minute we have this metadata in
some format we processed it we
constructed a metamodel we validated
that metamodel made sure that it's the
semantics are actually correct what you
do with it I mean you can just stab the
data just sit there so one of the
options is pretty much do some kind of
transformations to the actual code
itself or like create new classes or
like new byte code like a you know
modify the abstract rewrite the abstract
syntax tree by actually changing the
structure of your actual code so you
could say for example for all the
methods that are annotated with at
change if statements to change if to
switch you want to go down the ast tree
and every time you find an if statement
you would change it to a switch
statement because you just hate if
statements for some reason you prefer to
switched for some reason in some other
universe they happen to perform better
it can be your code it could be somebody
else's pretty much code so you say every
time you see this particular annotation
please change all their statements and
turn them into switch statements or you
could be adding or removing pretty much
behavior right so automatic generation
of cookie cutter code right so when you
when spring stereotypes a particular
POJO at controller right runtime they
would go on pretty much take that
particular pojo and then have it inherit
another class which is which pretty much
brings in the behavior of the controller
itself and knows about servlets and
knows about all that kind of stuff add
methods remove methods you can do
whatever you want with it so you'll end
up creating a complex and class
hierarchy or based on that one annotated
class you want to create different
things in the case of the active record
of for the Ruby on Rails people you
define this one model and based on that
model they look at it and they create a
repository or pretty much a doll that
knows exactly
to persist that and and and pretty much
read it from like a relational database
based on some kind of configuration
based on convention of the actual object
itself and the configuration and the
ammo file of what database that you
actually have that had defined for your
actual application there are a lot of
bytecode manipulation libraries I'm
going to mention mention a few ASM very
small fast very low level you need to
know by code up codes for for for the
Java pretty much my code to actually
understand this which is a really good
practice but it requires a good
understanding of the language spec
itself as well but it's very well
documented I mean ASM is king GC live
this is something that came as a
response of the fact that not everybody
wants to go and learn Java assembly
nobody likes that and they built like
this abstraction on top of it it's hype
really it performs really well but it
has some issues with when you start
dealing with like signs and everything
this library was used by hibernate but
they dropped it in favor of java assist
for lack and support and act for lack of
support in active development java
assist which is the last one i would
like to mention i love this library a
lot it's very easy to use it works well
with sign jar has very good
documentation as an excellent javadoc
and it was the one that pretty much an
adopted those adopted by hibernate well
it's a little slower than then then GC
GC lip it's not that I mean it for me or
like for the problems I was trying to
solve it didn't make that much of a
difference it's not really slow but it
allows you to pretty much just literally
go and then construct your code in
strings and in pass it to the ASM
library would actually create the
equivalent code and they pretty much
load it on the JVM use the class loader
loaded to JVM of life code as you do
that so on all you could other than
transforming doing all these
transformation and cogeneration you can
pretty much just do
interpretations and one of the example
of interpretations it's pretty much just
mapping one object to another one based
on the metamodel itself an example of
this being done is dozer which is pretty
much this library that takes one java
class and then copies it into another
one or map sent into another one two
different classes what takes this one
and copies the values or another one
based on metadata right there because a
lot of the times the fields on that name
the same way so you have this metamodel
of I there that tells you that field
name first name camel case maps to a
field called first name and garion
notation kind of whatever it is you can
do whatever you want or in frameworks as
well on so and it's pretty much this way
now am a pretty much you have like yet
you poggio your class and you have the
minimal data associated with that class
whether you chose to express it as Java
annotations in the class itself whether
you choose to express it externally as
XML or JSON wherever you you want you
processing into a minimum and you have
that data sitting there right the minute
you have an instance of the Poggio
itself that means that you don't only
have the fields you have the fields and
their values right a mapper would take
that information all right and create a
new instance of whatever you're trying
to pretty much interpret the object as
in the case of the object relational
frameworks every instance of the objects
maps for example to arrow mean and
amusing this it could could be more than
that or multiple roles across different
tables but a row for example so we take
the Poggio read the metamodel
interpreted a certain way take the
values and create a new instance and a
new instance of the row class which is a
part of the persistent model a very nice
abstraction so you code that interacts
with the database has nothing does not
know anything about your PO jewels has
nothing to do about your employee class
all it knows that every time I
an instance vil of this particular table
I pretty much go and save it to TBL
employees so um and that's what
hibernate does for you next so the next
thing then other than transformation and
in interpretation is dealing with these
cross-cutting concerns and what opie
pretty much creates is this hierarchy of
this hierarchical object model by nature
this thing inherits from this thing this
thing implements implements this thing
but we have certain things that are not
necessarily a part of them of the
application logic certain things that
you couldn't moduli more generalized
anywhere because they show all over the
place login for example transactions
security you end up if you don't use aop
with login statements all over the place
you log in this class and you log in
this class you log here and your log
here when you have an exception you have
all these coding all over and you can't
really do anything with it so what
aspect-oriented programming is pretty
much does that what it does it's pretty
much it allows you to say things like if
the a method of a particular class
through an exception do this log
statement or if am an object of this
particular class or an object within
this package of a class within this
package is created log this statement so
what you do is like you remove all those
costs a cost-cutting concerns and you
modularize them in these advices of
these like aspects and your code is
highly cohesive and highly maintainable
you look at the employee dau and he only
does call operations for employees you
look at some kind of service or try your
translation service and you only hands
translation code code that actually
carries the actual translation no log n
no security not nothing like that but a
lot of frameworks like aspectj would
provide that for your out of the box you
can choose to pretty much do that
and just tag these pointcuts and these
annotated elements in the code yourself
and say that every time you encounter at
laudable you're pretty much log when
after like a successful execution and
you would do what it's called in the aop
word code weaving at compile time or
like at runtime using dynamic proxies so
as you compile every time you see this
annotation you insert this statement
here and you insert this statement here
which is pretty much the login statement
next other you could pretty much no
instrumentation there are very few
libraries that'll actually do a very
good instrumentation out there the one
that I saw was former Yammer I think
it's whether you've chickened out that
defines a bunch of annotations that lets
you say time this method in time that
method and such but which would allow
you to pretty much monitor and measure
performance do diagnostics and trace
info things that are allowed by meta
programming as well as pretty much
inversion of control or dependency
injection that the spring framework is
pretty much known for unknown for when
you say and inject the runtime actually
goes weed off your meta data and pretty
much injects the correct implementation
of the interfaces in your and your PO
Jose so um we go through all of this
stuff right now all of this mess will
you get to do validation you're going to
do use rule rule engines for validations
you could use prologue annotation
processing this API in that API and it's
just tedious work and me as a developer
do not want to have to pretty much do
that reinvent the wheel each time so I'm
now the this project pretty much started
that was pretty much assigned to write a
framework that looks very much like
hibernate that runs on top of hph basis
in no sequel database so on I wrote the
first one and did the whole thing and
then at the end on when I thought is
that everything was pretty much done I
discovered that it had no validation
that people were using are going to be
using my
pretty much devoted the wrong way so I
said it's fine let me start doing a
bunch of if statements and it was hell
so what the presentation is it's pretty
much what I went through trying to
pretty much build this framework and it
was probably the third one or maybe the
most complex ones I built using meta
programming techniques so i created this
project pretty much called project of
Eros our project avaricious gives you
everything out of the box just true this
is still a work in progress I still need
a lot of help with it and it's just a
github project right now it's not done
by any means it's not even 0.1 but it
works to an extent about what this thing
does it's pretty much would give you the
ability in a nutshell a meta programming
framework it gives me the ability to
pretty much already discover all these
annotations and within a particular
package it does annotation processing
for you in a dynamic model and pretty
much construct that for you and it does
validation and what i SAT there and I
was what would be the best way for me to
allow people to pretty much express the
semantics of their metamodel easily and
in night in a very nice and simplistic
way and it was annotations annotations
or annotations that was the simplest way
that I could I could have came up with
so I created a set of annotations and
you might think about it as meta meta
data so and there is a set of em right
here a company accompanied with
accompanying with at least one for type
prototype annotated why with for type
including I'm going to use one of them
and give you an example and show you
some code if you are right in hibernate
for example and you create an annotation
called at table that was supposed to map
to an actual table in your data store
you want to ensure that there is always
an ID that there is always a field
within the type class called ID so when
you define your annotation you define
the retention type and everything you
would say for type including
ID and the framework would actually go
create the rules rules for you and kind
of go over your meta model and make sure
that that's actually accurate and not
accompanied with is another one this is
the github project it's nowhere near
done probably going to be doing more
work with it and around this thing very
in the next the next few months but let
me show you an example of how this thing
works so what I want I am a big fan of
one-liners so I want you to pretty much
do this when say at various Noah various
data dot notations which is pretty much
annotations which is pretty much the
package that can change all your
annotations you go and define 20 of them
you just point Maya various to that
particular package and I want you to say
construct metamodel for and you give me
a class for employee that's it I
construct the metamodel dynamically I do
the validation for you and a pretty much
just give you here is your metadata and
here is a very nice interface for you
that you can pretty much access at at
one time i will show you an example of
this class can you guys see it really
well is everybody fine so we have the
class that we're trying to construct
that you created is this one is an
employee class and it has a bunch of
annotations as an ID has a simple value
at column and all of these things and
it's like a table at table TBL employees
so those annotations are yours there's
something that you created so we're
going to take one as an example we're
going to take for example the table
annotations you're the one who writes
hibernate you created at table for
example all right the way you're going
to do it in javas went over j saw 175 is
we did public at interface table and has
one attribute which is pretty much the
name of the table we do at target you
can only have classes under k classes
with that
and you retain this thing until pretty
much one time but I have two annotations
that are part of a ver ways which is the
framework that I provide the first one
says that for type included value ID
that class so this type must include
something that's pretty much annotated
with that ID and the second one is like
not accompanied with embeddable for
familiar with hibernate there is the
concept of an embeddable poggio and a
table so a every every class of a POJO
every entity maps to a table but it can
have nested entities and they've just
pretty much called embeddable so it
makes sense for an actual entity and an
embeddable not to be the same because it
just does not make sense that way you
embed something in a in an entity and
that one's the embeddable this one is
the table as well so and they have those
rules around this particular annotation
and I have other ones i can i can show
you maybe I should show you all the
annotations that I defined this is the
test project that pretty much include
that when I have for example column
right and I have a rule that a column
should not be accompanied with ID you
annotate something a field called caller
ID you don't annotate it as column so as
simple as that and so forth a bunch of
them right here all right simple value
for examples a little more complex it's
like not accompanied with composite
values you can either be simple it could
be be pretty much composite all right so
enough of this and let's go back to get
rid of this let's go back to the actual
Manko let's go actually let's go to
remain and into this so this framework
pretty much does not only take classes
right here does not construct metamodels
for like a class only it constructs
metamodels in fact for anything in java
that could be annotated any annotated
element so right there what it has
is they pretty much got a field of the
employee class called ID a declared
field called ID which is this guy right
here alright so what I'm going to do is
I'm going to tell the framework to
construct the metamodel for ID and one
day Scott I hope everyone's you know it
goes in there and I get pretty much this
information it just sets out the printer
that I printed it out for you just to
see but it says that this guy is a field
the property navigational path forward
is pretty much ID and it gives us name
for the actual field itself this guy is
annotated with an ID a simple value all
right and with an ID and it gives whose
data is see that extracted the type
which is pretty much provided and
extracted yeah it's been a pretty much
said that it was annotated with this
with this interface called pretty much
ID and other information I mean this is
probably like a.m. let's pick a lot of
example this one is not as friendly as I
thought it would be and it's just big
and say um last name for example and the
information that we were supposed to
pretty much get from like last name is
like family HR and then qualify with
first name for an ID called first name
for this particular this particular
field and we just say give me the
and if it is it says that this guy was
annotated with column and this is the
emitter information that is associated
with the actual economy itself I can
assure you that this is not just reading
off the actual simply reading of that
particular annotation displaying it that
way it's actually in a dynamic data
structure that was pretty much printed
that we're right there so there is and
this is actually the next piece that I'm
going to that I'm hoping to work on is
pretty much to provide a programmatic
interface that would allow you easily to
pretty much extract and say for this
particular element what is the value for
family or what are the values that are
like available and things things of that
of that sort but what we all do is want
to test out like the hard piece which is
pretty much annotations and break this
guy so I'm going to go to do this first
name guy and annotate it as ID notice
that I have two problems right there the
first problem is that I have two ideas
that I would in the employee one and
something that I didn't allow is pretty
much to annotate the same thing with
idea and column at the same time and
then go on pretty much run my my code
and they get an error right the first
one is it says that the intimate private
java string and first name cannot be
annotated with with they're both at
column and any other annotation and
gives me for example the one that with
the problem which is pretty much ID the
second one is the element straying
whoever it is employee annotated with ID
must be of type bite that's one of my
rules as well then I didn't tell you
about I change the ID too long right
I change all the ideas too long and I
change all my ideas too long and they
run this and they get pretty much like
feedback oh I'm good didn't break I
broke for a second and they get the
minute for metadata for like ID and they
write it I'm expecting it to say you're
not allowed to have use anything other
than bite for that particular you're not
allowed to annotate anything out of that
than bite for the annotation ID a tidy
this and then you can pass it the entire
class which is going to do that for fun
let me fix my my bite thing deal here so
everything would pass and then we're
just going to run the entire thing and
there you go it goes in my class extract
all the information all the metadata
associated with the class itself and the
children of that particular the nested
educated element of that particular
element right there how this is pretty
much done if you're curious and you
would like to talk to me about it the
project didn't get help as well is this
right here they send this day in a
structure everything that is blue is
pretty much the decorator patterns that
would pretty much go to all your classes
and goes and build that metamodel
dynamically for you right the second
part right here is the red part is what
does actually the actual entertaining
annotation and annotation processing and
creates this blue model the green parts
that's pretty much what is pretty much
what gets jodoh generated for you
because when I go through the package
and look up all your annotations I read
them off I read off all the metadata is
associated with them I go on pretty much
prepare a set of classes for you as
classes of for you and complete the
decorator design pattern for you
otherwise you're going to have to go and
provide an implementation here
implementation here in implementation
here for every one of your for every one
of your of your annotations if you want
to process them if you want to create
this very nice dynamic data model you
don't have to do that because I do that
for you I use this bytecode manipulation
libraries to actually go and complete
those data structures and they pretty
much call them at runtime all right one
thing that is pretty much important is
the concept of pretty much validation
right there I spoke to you briefly guys
about about drools I dynamically create
those rules so I go for example in your
column annotation right here and you
told me that you should never allow and
add column to be pretty much a tidy
what's happening in the background right
there is I have pretty much and rules
rule template for not accompanied with
that define all these rules this is
pretty much just like a template and I
go at compile time discover although all
of those classes right there and create
these rules this rule of not accompanied
with for every single one of your
annotations that you're providing this
is something that if you want to do
things the right way and nicely you're
going to have pretty much to do you to
do yourself and then at the end we end
up with let me see if actually if that
file actually came out before I I tell
you anything and see if it's in the
target no Sonya so you end up with
pretty much is huge rule files that I
actually validate against every time you
pass me like a particular entity or
every time you pass me a class so you
get all the stuff for free I'm hoping
that this pretty much this is going to
materialize to something that a lot of
people use I went down the source code
of big library is like hibernate
different implementations of jpa to kind
of see how they actually go and
construct this metamodel now and then
and I was very much interested in the
actual fact validating that's that
semantic model the metamodel adiga
they ended up with semantically and most
of them was pretty much a bunch of if
statements that they pretty much have to
maintain but this is a framework and
that's the hard part about being a
framework you're too generic and you
should pretty much be ready for people
to throw anything at you thank you very
much for your time
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>