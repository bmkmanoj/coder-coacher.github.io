<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scala Versus Java | Coder Coacher - Coaching Coders</title><meta content="Scala Versus Java - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scala Versus Java</b></h2><h5 class="post__date">2012-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/PKc5IwHG68k" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">now just a quick note about the about
the title of my presentation you're
obviously any any programming language
that is that is Turing complete is going
to be equivalent to one another so you
know and especially on the JVM it's very
hard for me to say that that one that
one language which compiles down to Java
bytecode is is greater than another in
some sense and in fact I think the
punchline of this talk at the very end
is going to be something like Scala is
actually less than Java you write less
code it's more regular you have to think
less about what you're doing but but the
the thing that I want to try to sort of
set the tone with is is the idea that is
the idea that this is going to somewhat
change your mindset about programming in
general and I think even even some of
the lessons that that you pick up from
here even if you're not programming in
the Scala language are still going to be
applicable to some of the Java code that
you end up writing so actually another
another quick show hands how many how
many people have used the guava
libraries sets about is it like maybe 20
people something like that am a bit bit
more than a quarter of us so that's good
or a guava Google collections and
there's a lot of sort of functionally
oriented stuff in there that that does
somewhat reminiscent of Scala or a
closure if you're familiar with that or
other other functional languages so so
it should be fun so let's let's jump
into it here first start off with a
little history lesson so first things
first 1996 everybody remember Duke yeah
good old Duke so son releases Java 1.0
designed by our buddy James Gosling 97
Java 1 dot Oh obviously had some
shortcomings and so there was a there
was a small group primarily martin oder
ski and philip Wadler who
you set out to work on a new language
that called pizza and their work was was
published at the Papa conference and
that was a superset of Java strictly
superset so you could write Java code in
pizza in the pizza language and it would
actually you know if you run it through
the Pizza compiler we'd actually
translate to Java source code which then
you would run through Java C and you
know that lo and behold you get byte
code out the other end so it had a few
interesting language features one one
really interesting one very very
important one for Java is this notion of
parametric polymorphism
which I think everybody everybody
probably knows better as generics it
also had a couple others algebraic types
higher order functions and we're going
to see some of that a little bit later
1998 rolls around and son or the was it
called Java soft which was the
subsidiary of son that was working on
Java it took a real interest in what was
going on with pizza and they said okay
you know all this stuff is great but you
know of course we can't introduce all
these new features in the language all
at once what we'd like to what we'd like
to work on is a new approach to generics
again this parametric polymorphism and
and so they worked on something called
GJ and actually I've got a little
picture here of we've got Phil wobbler
Martin odorous key
stat I think it's Eric Stoudemire and an
Gilad bracha so so that that pulled in
generics and there was a there was sort
of a shift in the in the computational
model or the compilation model I should
say where rather than having a sort of a
source to source translation translating
pizza to Java source the this the the
new the new GJ compiler actually
literally compiled this GJ source code
down directly to Java byte code so that
was kind of cool and that was where the
notion of type erasure came from which
yeah you know for anybody who's sort of
wrestled with the wrestled with Java
generics in any any appreciable way
you're going to be pretty familiar with
erasure so that's where that came from
that was 1998 2000 so this was an
interesting development
so this guy Martin odor ski who had
worked on the GJ compiler and who had
initially worked on pizza Sun it took a
look at the work that he did on the GJ
compiler and said wow our job to see
kind of sucks why don't we take that why
don't we just take take G J's compiler
just use that as Java C so so that's
actually what they did the the Java C
that we're all using today that was
introduced in jdk 1.3 was actually it
basically sort of a stripped-down
version of the GJ compiler at that point
obviously in Java 1.3 they didn't even
have generics yet they weren't using any
of the new the new language features
that were introduced in GJ however the
compiler was I guess more correct and
performed better and crashed less and
stuff like that so just you know kind of
off on a little bit more of a tangent
finally in 2004 Java 1.5 incorporates
generics so this was what was seven
seven years after after the pizza
language that came out so that's the
sort of the testament to to the the Java
process but it made it in there okay so
meanwhile kind of on a whole other story
arc in the in the programming language
community we've got you know starting
starting around the mid 80s there was a
ton of functional programming languages
and they were used mainly in research or
academia so these would be derivatives
of Lisp you know scheme
ml so for example oh camel or things
like that and another language called
Miranda they explored a whole lot of
interesting different language features
including type inference which we're
going to see lazy evaluation and higher
rank types and oh actually one thing
just to back up here I am saying sorry
these pictures are so small but we've
got another picture fill Wadler here who
who incidentally had worked on GJ
wearing a bowtie and I feel like bowties
are really a big thing in functional
programming this is really something I
noticed I want to I want to get myself a
bowtie
really feel legitimate with that one
anyway so so next next sub slide here
we've got we've got Simon Payton Jones
wearing his bowtie and he was he was one
of the principal contributors to a
language called Haskell how many people
have heard of Haskell everybody
how many people have programmed in
Haskell
how many people have programmed in
Haskell for their jobs how skill
introduced some some interesting new
concepts on top of on top of those that
I mentioned previously notion of type
classes which is somewhat roughly
analogous to what you see an
object-oriented programming but a bit
more open a bit more extensible still
and it featured this notion of monads
which we'll talk about in the talk here
and again Marta notre ski pops up he he
contributed some interesting work here
on on higher-ranked types into the GHC
the Glasgow Haskell compiler so the
student Martin is showing up all over
the place finally between 99 2001 Martin
was at the e P FL or EF PL I never
remember which direction is but he was
working on a a new research language
called funnel which was sort of I'm not
going to dwell to dwell too much on this
but it you know basically a return to
totally basic principles wanted to
really divorce himself I think from from
all of the all of the sweat and tears
that had gone into gone into the work on
GJ and so forth and wanted to wanted to
really get back to the functional roots
while also looking at something called
Petri net switches which was relevant to
concurrent programming it was able to
model a lot of different programming
styles of imperative object-oriented I
mentioned concurrent also and it also
compiled to JVM bytecode so so that was
kind of an interesting start and then
finally coming up to where we are now oh
there's Martin he's not wearing a bowtie
he he published along with the along
with a few colleagues the first version
of the Scala language
which is I think his reflection on
funnel it turns out actually that that
although it was it was very beautiful
and very sort of elegant and pure in
principle it was very difficult to
actually work with if you were trying to
write real you know real production
scale software just because of some of
the some of the synced syntactic issues
so so he kind of started fresh and Scala
came came out as a result of that so so
the idea with Scala of course is it's
both an object-oriented language in the
tradition of small talk and self even
and you know C++ and Java and so on and
it's also a functional language at the
same time and it seems seemingly
seamlessly integrates the two approaches
and to sort of tie things back up it
includes several language features from
the pizza of this and you know initial
project that he had worked on back in
1996 such as higher order functions and
of course generics and in case classes
and so on and then over the last I want
to say about six years the Scala 2x
series has been going under going rapid
like I mean really rapid rapid change on
write rapid development so incorporating
some stuff from Haskell this this lazy
evaluation a notion of implicit and
refining those two basically the work
out is as Haskell style multi parameter
type classes which we won't be talking
about sort of an advanced topic but it's
very cool that you can do that
generalized pattern matching finer
grained qualification of access
modifiers or private protected and so on
and and better interrupt with with Java
code so
now I spend at least 10 minutes working
on this graphic my ivory tower with the
with the lambda I hope you enjoy that
yeah thank you my talk is over hey any
questions so you know this functional
programming introduces a lot of very
unfamiliar vocabulary parametric
polymorphism we've talked about we call
it generics it's not quite so scary
things like algebraic types higher-order
functions and higher rank types and so
on and people really talk this way
especially if you if you go on Twitter
and you follow a certain a certain set
of the certain set of the community
you'll see some some people who really
look smart but you don't have to you
don't have to drink the kool-aid quite
that well quite so much from the
firehose you can you can take things
much more much more pragmatic pace I
think so you know there are indeed users
of Scala in the industry and I'm sure
you know most of you are here because
you've heard some buzz from say Yammer
or Twitter Foursquare you know is that
some of these guys who have been using
it to great success and especially
who've been using it for for its
concurrency primitives its ability to to
handle multi-threading in a sort of a
higher level of abstraction in therefore
a higher level of safety so you know
just kinda to skip through these real
quick there's no some some testimonials
it's been a lot of people talking about
Scala so for example one thing that I
really lay you know you can sort of read
this read this as you like but one one
thing that are really appreciated is is
the mention that that the fact that it
is a JVM language and the fact that
there are you knows it essentially
language bindings for free with Java
gives you you know integration with any
existing code that you've written or any
existing code that's out there in the
community so you know you've got maven
central let's say that that's full of
you know tens of thousands of of
different different artifacts that have
that have been committed and contributed
and you can just straight-up use those
and you know it's it's really fun it
gives it gives Scala sort of the
kickstart in a sense and you know of
course if you if you have some legacy
code of your own and you you know you
need to you need to work with that you
can't you can't afford the time to
rewrite everything all at once being
able to introduce just in bits and
pieces some you know some some new Scala
code while at the same time retaining
most of your other work is a really nice
thing to to have what else the product
productivity improvements are massive I
just say they Twitter had some good
quotes at languages that are more
research-oriented missus gets back to my
sort of ivory tower slide here the
language is more research-oriented tend
to have a lot of problems in production
and they didn't find that they run into
those sorts of issues in Scala and
certainly I mean I've done some work for
example with Haskell again not for work
but for fun and you know even just my
toy for fun code I did I did run into
some set of some set of issues where you
know for example there were space leaks
due to excessive laziness then things
like that that you know things that
things that sound very good in principle
but don't don't actually work out that
great and practice all the time and
Scala is surprisingly surprisingly low
on on that scale let's see coda Hale so
anybody familiar with the with the the
big the big leaked email Yammer
controversy yeah if 510 something like
that there was a there was an email it
was a private email between coda and and
Martin and a couple other a couple other
folks in the scala community where he
was really kind of kind of digging into
to a lot of a lot of serious performance
issues that that come up in you know
very common practice but you know so
this was sort of code it's code as
public response to that which said look
you know Scala is currently the main
language for
our back-end services and in the past
few years we've solved a number of hard
problems using it so you know that says
something this is this is still a very
pragmatic you know circuit approach and
that Mike my favorite quote of all here
is is this is better than tab-completion
which I think speaks for itself alright
so let's take a look at some Scala code
to start with so first of all I'm gonna
ask and I'm not sure I want to know the
answer but can everybody read this
anybody can't read this in the back is
it all right so the guy in the front
can't read it you guys in the back here
okay all right sweet so what do you
notice here so we've gotten a nose this
is basically our little hello world app
right so some things that we notice
about this well it's just you know it's
kind of run through this I actually I
let's let's get some audience
participation what do you and actually
particularly the folks who have never
seen Scala before I want some I want
some first impressions yes looks very
much like Java mm-hmm hey what the
what sort of differences do you pick out
yeah this was this one's an object so
that's interesting def yeah
that's that's different yeah it's like
method what about what about yeah this
is this : so this is this is this is the
type of args and it shows up after after
the name of the thing right and
similarly here this this type unit which
is the return type of main that shows up
after after the the parameters we've got
no noah curly braces so here yeah sir
oh the semicolons are missing where's
the semicolons go what else
the O is we don't say you know public
object hello we don't have to say that
public is missing we don't say public
def name we don't need to say that and
this you know def that's that's a new
keyword right def is what we used to
define a method that's different we
noticed that that yeah this this :
syntax the return types and you know the
type types of anything or are written
after the names instead of before we've
got some mixing mysterious unit type
we've got yeah yeah this this one this
actually looks a little bit like a
regular function declaration right or a
regular variable declaration rather you
know is they say you know I equals 10
you know say this function equals
something and it looks like an
assignment right and first thing we
picked out was that hello is declared as
an object rather than a class and that
actually means something special you
don't declare everything this way and
main this you know this is very related
here main isn't declared as static so
Hello is declared as an object and main
is not static so so what could that mean
what does that mean about what object
means this this this keyword object
hello hands yes
it's a singleton it's a singleton cool
all right what's the singleton yes / /
classloader
right yeah so so right so the answer is
is that this object this object hello is
a singleton instance there there can
only be one instance of this hello thing
and we happen to just refer to that
instances hello we don't have to do some
you know some static like get instance
singleton pattern or you know the enum
singleton pattern something like that we
actually just say object hello that's
our singleton there's only one instance
of this four / / class loader thread I
think now per class ler
so therefore our our main method doesn't
have to be declared static because
there's only going to be one of those as
well right okay all right so some bits
of sort of sort of formality and
mechanics that I want to kind of get
through real quick because that's gonna
that's going to bring us to some some
real interesting stuff so so voer so the
way that we declare a variable is we use
ver
so say you know there are equals 1 so
actually you know quick question what do
we notice about this immediately you
know what's what's the type of I yes
there's no type that's right so what is
the type is this a dynamic language or
is this a static language is this a
dynamic language like Peno JavaScript or
Python or something like that where we
just say okay I I is whatever type it
happens to be at runtime or is this
still language more like Java or C++ or
whatever where where I does have a
static type is anybody know more dynamic
more static yeah all right let's take
two let's take a vote dynamic one two
three four five static everybody else
okay there everybody else wins this is
actually a static language it's
statically typed however it incorporates
a notion of type inference which in this
case the way it the way it works out is
is we see this you know this thing is is
a11 is an integer literal therefore we
can infer that I is of integer type so
something that we couldn't do for
example is we couldn't say you know I
plus equals hello
that would that would fail to type check
even though we hadn't specified the type
of I it's it's statically inferable by
the compiler right okay so that was just
sort of a little day yes go ahead a good
question if you do I plus equal 1.0 I
will come back to that in a few slides
that's a very good question the reason
is so the question was why did I declare
a type for the the args parameter in
main and the answer to that is that type
inference only works locally within a
function and type inference has to start
somewhere so you know we can't we can't
go and look at it who are who are the
callers of main to try to figure out
from that context what what the type of
args is so any method parameters that's
that's one of the only times when you
have to specify types there are a few
other a few other instances and and one
one place where I really like to do it
even though I don't necessarily have to
is return types where return types if
you specify a type that's almost like
documentation it's almost like saying
yes you know this thing returns an int
whereas you know you could technically
leave it out but then it's up to sort of
it's up to the per consumers of your of
your code to kind of squint and look at
it and figure out yes go ahead
there is a bite type but you can't you
can't implicitly downcast you can you
can do like a there's like a to bite or
an ass bite anyway so so the the big
point here that I've been dancing around
for the past five minutes is that this
is how we declare mutable variables
immutable meaning I can change the value
right I can say there is one I is an int
and then I can say I equals I plus 1 and
that's just fine now Java of course has
the keyword final for the cases where
where do you want immutability and Scala
gives you a little bit of a shorthand
here it gives you the the keyword vowel
which is supposed to be sort of
indicative of this is a value that this
is this is a symbol that's down to a
value and that value isn't going to
change so if I were to say Val I equals
1 and then I was I was going to say I
equals I plus 1 then similarly to you
know if you're working in Java and you
said final into I equals 1 I equals I
plus 1 that won't compile right makes
sense but this goes even a little bit
further I'm just going to scroll down
here there's this notion of lazy Val
mm-hmm excuse me this notion of lazy Val
which is similar to Val it declares an
immutable variable but the the actual
binding of that variable the computation
that's on that's on the right-hand side
of the equal sign is computed on demand
it's it's it's you know a lazy
initialization right everybody familiar
with the lazy initialization yeah
unenthusiastically the familiar awesome
and it's also memorized such that that
lazy initialization doesn't happen over
and over again right so you know I've
got my my Hitchhiker's Guide to the
galaxy example here I've got my lazy
valve 42 is equal to deep thought
compute and the deep clock compute
computation is according to the book
going to take 7 and 1/2 million years so
you don't necessarily want to actually
do that initialization until you're sure
you want that
value so then you know of course we can
do print line of 42 which is our latest
value here and that will trigger the
computation of of that value of course
then we can print line again and this
and the subsequent computation won't
take seven and a half million years
you've computed the value and since the
value is immutable you can hang on to it
right so that's kind of nice and then
similarly to our previous example of
value here we can't reassign this
immutable value so you know we can't say
42 is equal to the number 43 though that
won't compile okay and lastly this thing
that we've seen already is is the
keyword def which declares a method and
typically you know you have methods that
that take some number of parameters you
can also have methods that take no
parameters at all and you don't even
need to put the parentheses you can
optionally and of course you know as you
would expect the value of let's say you
know increment I've got a function that
I'm calling increment that take takes of
it takes an eye again this is a case
where I have to declare my type for for
I because it's a it's a it's a parameter
right but I don't have to say that
increment returns in int I don't
necessarily necessarily have to say that
because it can figure out based on the
fact that it's just doing I plus one
that oh that that's an int all right and
of course you know for any given I
you're going to compute the value of I
plus one
each time you call the method okay cool
yes question
so so the question the question is is is
isn't lazy a little bit overkill I can't
can't Java just sort of figure that out
because it's final and the an answer is
is well kind of know they're different
evaluation strategies like in Java if
you were to say you know final int I
equals whatever then the Java compiler
is free to reorder you know it when it's
one is emitting bytecode the compilers
is is free to reorder things to optimize
register usage or not registers it's a
stack machine right but it but it's free
it's free shuffle things around a bit
just within the constraints that happens
before however there's still the
requirement that that certain things are
computed and when you've got things that
are escaping off into the heat play like
you know I've got say an object that has
a lazy Val member I can't really I can't
really do a whole program analysis and
see oh you know I actually am never
going to use that value or anything like
that
so lazy dollars is a bit is it special
it's it's a I would say it's not over
killed it to take care of that and
actually we'll see it we'll see an
example here lazy initialization this
thing that this thing that folks were
were unenthusiastic about the idea
that's you know say say you've got some
class foo and you've got some some
member bar and you want to initialize it
to null you don't you don't want to
actually instantiate a bar because maybe
that'll take a long time and maybe that
takes up memory that you don't
necessarily want to consume so you know
in a single-threaded context what you
would do is is for your getter method
you would you would have a check like
this you'd say if bar equals null then
we'll instantiate a new bar this is Java
again right this is Java and then either
way you know we should we should have a
legitimate bar at this point and be able
to return it but you know of course this
if you're if you're in a multi-threaded
context this gets much more hairy so
this is a lesson in painful Java
the way you know sort of the easy way to
do this to make this thread safe in a
multi-threaded context is to say
synchronized get bar you synchronize the
method okay everything's safe there's
there's no there's no you know
non-atomic accesses to bar assuming if
there's no other no other methods that
reference bar but let's let's make that
assumption let's let's make the
assumption that everybody's calling get
bar to get the bar okay so this works
this is safe this is totally thread safe
but it's slow there's a there's a
performance penalty to declaring a
method synchronized yes you have a
question in the JVM there may be I'm not
aware of it so the question was are
there some some recent new optimizations
in the JVM to take care of cases like
this and my answer is maybe
I don't really know yes another question
yes yeah atomic objects do do eliminate
the pain here the the classic way of
dealing with this problem is you would
do this double check locking this is
this is assuming that you don't have
atomic reference from it's in java.util
concurrent right yeah so this is
assuming you don't you don't have fancy
toys like that you would have to do this
double check locking idiom so you have
to declare but bar is volatile meaning
the compiler isn't isn't allowed to
basically have one thread see see the
thing is no while another thread sees it
as as at least halfway initialized so
you would check you know if bar equals
null then you synchronize and then you
check again if bar equals no and then
you initialize it and this is this is
just a mess lazy bar it late lazy Val in
Scala actually compiles to you know it
to something almost identical to to this
code here this this double check locking
pattern so you know this is this is
already a case where you can program
more safely and more correctly in Scala
without having to I mean in essentially
without having to worry about screwing
up yes question
in the cookie in the in the Scala case
oh yeah yes so so the question again was
it was you know does the underlying
bytecode that is output by the Scala
compiler does that actually do all the
all the locking for you and the answer
yes but yes blocking does occur it
compile a like if you were to take take
this little code snippet run it through
the Scala compiler and then D compile
what you've got using D compiler like
dad or something like that the the
output that you would get modulo you
know some nice-looking names is you
would get output that looks almost
identical to that code make sense so a
quick word about mutability versus in
Ute ability and what immutability might
buy you so we've got a few you know we
can talk about this
impure versus pure or imperative versus
functional so let's say let's say our
let's say our boss comes to us and says
hey Dan I need you to write a list from
1 to 10
I've never actually been asked for that
but but but if that were to happen then
you know as a as a Java developer I
would say ok what are the tools at my
disposal I'm going to create a you know
you create a a counter a counter I
starts at 1 and what else a list then
I'm going to populate along the way and
I'm gonna have a little while loop you
do this with a for loop - I could say
you know for I equals 1 to 10 then I'm
going to say list and this is you know
so this is Scala here again actually
this is this is a funny-looking list
concatenation operator so I'm going to
append I on to the end of my list and
increment I and then I'm going to return
list at the end so that's that's my
that's my sort of imperative style code
use the looping construct now I've got
my pure holy grail functional style in
which I use a small helper function
that's recursive I define a you know I
say def list 210 and it takes some some
parameters I'm integer parameter so it's
going to be a list from that I to ten
right so we've got two cases since this
is a recursion we're going to say if is
less than or equal to ten then I'm going
to take my car and I and concatenate it
or cons it if anybody's familiar with
that term from like from scheme or
whatever I'm going to cons it with
another recursive invocation here though
my list of ten of I plus one so you can
see of course you know if you were to
call this with one then it would be one
Const with the list of ten starting with
two which again is two cons with the
list of ten starting with three and so
on until we get to ten you know we get
to our else case and we're saying L
which is the empty list very terse I
would say pretty readable if you're
comfortable with recursion
in fact this is this is even free of the
you know sort of the burden of recursion
of the you know possibility of stack
overflow error because the Scala
compiler is smart enough to do a tail
recursion optimization on this this is a
tail call this is this list of ten call
no it's not correct it tail recursion
module accounts is fine if you were to
decompile this you would see it as a
go-to yes Oh prior to eight when nothing
existed prior to to eight there actually
there was no there was no world prior to
Scala to date actually I should have
mentioned this a little bit earlier
between Scala
- oh it's called Scala Wando definitely
didn't exist between Scala 2.0 and 2.7
whatever was the 2.77 there was quite a
bit of change and between the 2.7 series
and 2.80 they made some again
significant changes they changed the
collections API they changed some
aspects of the ABI the the binary the
binary format that broke compatibility
with existing code and man the community
was really in an uproar about that
because there were enough people
actually using Scala for real at the
time including Twitter they headed up to
adopted Scala
during the 270 years months whatever it
was and you know so this this was a
little bit a little bit of a pain in the
sense that they had to rework things
with the new collections API they had to
recompile a lot of existing code yeah
it's not necessarily too bad
but if you have a large enough code base
things like that really become sort of a
let's call it a public relations issue
so so so yeah the question was prior to
- 8 was the Scala compiler smart enough
to to determine that in fact you could
optimize this case into into a tail
recursive call the answer is I don't
know I know that I know that - a tend
and after I pretty sure works - tail
recursion modulo cons so of course you
know if our boss asks us to build a list
from 1 to 10 we could we could just say
1 to 10 - list or even better we could
you want to tend to stream
which which build us a lazy list the
ELISA list whose elements are not
actually computed you know per element
not actually computed until we need them
so that's kind of neat that's a little
bit Haskell style okay
object-oriented basics so Scala is an
object-oriented language I don't want to
say first and foremost necessarily but
but since it runs on the JVM of course
it has to conform to certain conventions
the JVM requires such as stuff has to be
an object right okay all your methods
have to be associated with an object you
can't have free-floating functions for
examples so we'll talk about let's talk
about object so walk into an interview
this is you know an interview circa 1998
and the interviewer says you know can
you go up to a whiteboard and tell me
what is object-oriented programming and
then I walk out but the usual usual
answer that your interviewer expects
here is is they want to hear
encapsulation inheritance and
polymorphism right everybody want to
everybody want to I want to get into the
details about what encapsulation is
inheritance is I think this is probably
familiar to everybody everybody's
working in Java right yeah great okay so
this is not news to anybody but Scala
Scala puts I don't want to say a new
twist more like a more rigid worldview
it adheres to the principles of you know
everything is an object and we really
mean everything is an object even
functions are objects even primitive
types like int and bool x' and so on
those are those those are those are
objects that are treated uniformly in
the class hierarchy but the functions is
an interesting one because because
that's sort of the crux of how you how
you merge the two approaches right if
you can accept objects as parameters to
methods and a function is an object then
you can accept functions as parameters
methods so tada you've got higher-order
functions okay cool
uniform axis
let's see I'm gonna skip over some of
this traits is an interesting one this
is this is sort of almost almost a
return to to some of what c++ offered
that that people lament it a little bit
when when Java came to the fore the idea
of multiple inheritance Scala does not
it and I wouldn't really want to
emphasize that Scala does not have
multiple inheritance first of all again
because Scala is a JVM language and
multiple inheritance is not possible on
the JVM however it has an interesting
idea of how to how to compose snippets
of different classes and we call those
snippets traits now you can think of a
trait sort of like an interface and in
fact when you compile Scala traits down
and look at them in in Java P or Scala P
or whatever or Java P is probably more
interesting you'll see indeed an
interface like if I have you know trait
foo and I use Java P I can see oh that's
interface food but a trait can also
contain code it can contain you know
contain member variables with with
actual assignments it can contain
methods with with with method bodies and
you can mix in as many of these traits
as you like up to some you know compiler
determine limit I think or possibly even
VM determine limit you can mix in as
many of these as you like in you know
practical terms to a given object so so
the the difference between this and how
it works in C++ let's say we're C++ you
have the the dreaded diamond problem and
you have to you have to understand all
this all this crazy stuff about virtual
inheritance it's not like that the the
order in which traits are mixed in you
know if I say you know object foo with
bar with Baz with pizza the order
actually matters they're a class
hierarchy is constructed by the compiler
sort of in inada ad hoc fashion where
when I say you know foo with bar with
Baz let's forget the pizza actually says
that foo
who inherits from Baz that's our that's
our most significant trait which then
inherits from bar if even if these don't
actually inherit from a common common
based class or whatever the the
inheritance relation is is sort of
synthesized by the compiler so this this
sends it being kind of nice you can do
you know sort of this some anybody
familiar with the the Josh it was Josh
blog write the effective Java Josh
blocks rule about favorite composition
over inheritance inheritance is not for
code reuse yeah no how many people agree
or disagree with that agree yeah how
many people disagree with that and just
using herons for code Rios anyway one oh
you're brave so this makes the argument
knew it moot in a sense that you know
you can you can sort of do this safely
and this and the semantics of what it
means to compose these these standalone
bits of code is actually well understood
so it's kind of nice skip over a bit
more here so we talked about everything
is an object yes question
ah it's a good question so the question
was is that kind of like duck typing as
in Python no I would say there's no
relation to that there's something I
don't mention this talk here about
structural types which is sort of like
duck typing in Python where I can say oh
well I want this to have I want to
operate on on types that have you know
methods a B and C but I don't know what
that interface is called I don't have an
interface that actually defines those
necessarily so you can do that and Scala
compiles that down to to something that
uses reflection so it's slower but it
does work effectively as duck typing is
it's they call it structural typing so
it's nice to be able to do that
sometimes okay everything is an object
we talked about this a little bit you
know the idea that the idea that all of
our all of our value types all of our
you know what we would think of as
primitives in Java you know by short int
so on those are those are all objects as
well so so we know
really have to worry at the at the code
level you know at the source code level
about about oh you know is this is this
boxed or unboxed can I put this into a
collection or not yeah you just it is
there's only there's only one way to
spell int there is there's in two ways
to spell int there is no difference
between an int and integer and again
this kind of compiler is smart enough to
take that uniform representation and
split things out at compile time when it
notices oh I can actually use the unbox
representation here I don't need I don't
need a capital i integer I don't need
that that's you know and it's able to
figure that out on it you know a compile
time there was a question here earlier I
think it was you I'm not sure about you
know what happens what happens to type
inference if I say you know Val I equals
one and then I say or is sorry Vera I
equals one and then I say you know I
plus equals 1.0 what happens there
there's a notion of implicit conversions
and implicit conversions are not
something that's that's special to to
the primitive types or you can define
implicit conversions between any
different types of objects but these are
some interesting built-in ones the idea
that a byte is implicitly convertible to
a short and a short is implicitly
convertible to an int and so on and and
you kind of expect that because they're
you know a int is of what for rough four
bytes on JVM and along is is is eight
bytes so you can do that without without
losing any precision whereas the other
direction wouldn't wouldn't make as much
sense you could you could be losing
losing data mixin trade so I talked
about mixin traits I didn't think I
included this slide all right so let's
see this we talked about traits a little
bit yes go ahead
ah
right so so the previous question had
been about type inference which is what
happens when you leave off the types but
of course if you if you want to say this
is an int you can say you know : int so
type annotations are totally fine
anywhere that you want them is just a
nicety for for the cases where the type
is obvious to be able to leave them off
okay so mix ends we're we're going to
define an abstract base class of a table
in a table you know look let's say
tables sort of like a map it has keys
and values but our table is a little bit
special it's a little bit different from
you know the regular map semantics in
that we're going to provide a default
value for the case where you try to look
up a key that's not present in the map
or in the table I should say so so we
have a default value in the in the event
that you try to look up the key that's
not prison so okay so those are our
abstract class we do a def get we don't
know what get is going to look like we
don't have an actual implementation for
that and that returns an option of V
which is an optional you know maybe it
has a return value maybe maybe it
doesn't we have a put which takes a key
and a value and returns something called
unit which is basically like void and
then our only concrete method here is
this apply method which which carries
out this the semantics that I talked
about this idea that if we get a key
excuse me I'm not left handed if we get
a key and we match that against some
value then okay we'll return that
otherwise if we match that against none
if the option that we get out of get
actually wasn't present then that's
where we return our default value okay
so this is our this is our table
abstract class now we can also say okay
map table where we're going to implement
table concretely using a map and you
know let's say okay we've got a private
VAR map and yeah I can say private this
is exactly the same as in Java but by
default everything is public okay so
this one's private that's that's kind of
interesting private Burnap starts out as
an empty map
will define get as map get of course and
will defined put as map dot updated and
this is this is all just sort of
standard library stuff I'm not going to
not going to go into too deeply so
that's art that's our map table and we
could totally just use map table that
have just that'd be totally fine but
let's say that I also want a trait that
implements concurrency because you know
get I didn't I didn't say get input
we're synchronized right but let's say
let's say I want them to be let's let's
say I want concurrent get and concurrent
put so the way that I would normally
have to do that if I were if I were in
Java is I was I would have to say the
subclass map table or I would have to
write a wrapper which which references
you know which which encapsulates a map
table what I can do in Scala is define a
concurrent table trait and okay so we
say concurrent table extends table it
obeys the same the same contract the
same interface and let's say we're going
to override get with a synchronized
block and we say synchronized super get
key well super right now super looks
like our super classes table okay so
we're calling table dog at the table
Doggett doesn't actually do anything
that's that's that's still abstract
likewise are put called super dot put in
a synchronized block so that's cool but
but it's a little bit weird we're
calling we're calling super where super
is abstract and like I like I mentioned
before what what happens basically a
compile time is Scala is able to weave
these things together so if I if I were
to say either of using these are
equivalent if I were to say new map
table with concurrent table then what
would actually be happening here is I
would I would be getting a map table
whose parent class is a concurrent table
rather than a regular table and that
concurrent tables parent class or no I'm
sorry other way around concurrent table
whose parent table is is bound to map
table so that gives us that gives us
this inheritance relationship for free
without having to explicitly state
concurrent table extends from map table
because let's say we want you know
concurrent to
to also be used in a context of a list
table let's say something like that so
you can you can literally mix that in
say new map table with concurrent table
or I could you know if I if I wanted to
reuse this this behavior I could say my
awesome table is going to extend map
table with concurrent table so again
anytime I ask for an awesome table what
I'm getting is something that is a
concurrent table than a map table than a
table at the root so this is this linear
as a linearization algorithm when I was
talking about that happens in the Scala
compiler and it's really nice again to
be able to to compose these sort of
snippets of different behavior that you
want to be able to mix and match without
without stressing too much about are
these going to conflict with each other
because the conflicts are resolved by
the order in which you specify the V
would be with the you know extends map
table with concurrent table and so on so
there's there's your your precedence
right there so it's kind of cool
let's see control structure is I'm going
to breeze through this pretty quickly so
we've got you know control structures
are going to look the same more or less
in most programming languages except for
the ones that are explicitly designed to
cause pain so you've got you know things
like if-else you've got things like
while and do-while mm-hmm
but but Scala also takes some existing
ones like for loops and sort of beefs
them up a bit say putting them on
steroids I use the term fondly and match
case is sort of like a switch statement
but it's a little bit beefed up as well
so so let's let's take a couple looks at
their looks at these and the thing that
I want to sort of observe over all about
all of these these different control
control structures this is you know this
is starting to get into what we think of
as functional like we've talked about
objects we talked about traits this is
starting to get into something that
feels a little bit more like functional
programming so all of these controls
control structures like an if-else is
actually an expression a for yield is an
expression even even a block you know if
you put you know curly and then a whole
bunch of statements and then close quote
close curly that's an expression that
actually
has a value and a type it's not just
it's not just a block statement it's a
block expression so let's look at
if-else as a starting example here if
else of course has the farm if some you
know some key some predicate that has
type boolean then some then you know
then then the if-else it evaluates to
some expression one with type one else
it evaluates to some expression two with
some other type now of course you have
to unify those two types somehow if the
if else is going to have a you know a
type of its own so what we say is is
that the type of the if-else is the weak
least upper bound of those two types so
for example well let's let's actually
look at so look at some examples here
let's say you know if if P you know we
don't we don't care about if P is true
or false if P then new foo else no okay
you can see actually this this looks a
little bit like the like the the you
know question mark colon syntax that the
ternary operator in java or the
conditional operator this is this is
essentially that is essentially the same
thing but looks a little bit more sane
so what's the type of this thing what's
the type of this expression well say new
foo okay so that's probably going to
have type foo and know well that has
type null and a few slides back I
glanced over this really quickly but we
saw the the uniform type hierarchy and
it turns out that null is actually a
type which is a subtype of all other
object types so the least upper bound of
foo and null is going to be food because
null is the subtype of foo okay it's
cool and this is more or less the way
that the Java compiler did is does it as
well of course for the for the ternary
expression I how about if if key the new
foo else new bar well let's let's assume
that foo and bar aren't related to each
other they don't have some some common
common superclass that we defined so in
that case it's going to have type Scala
object
or any Ref something like that scala
object to be more precise because that's
going to be the least upper bound of
those two types again getting back to
the question before
what happens if we've got an if we're
where the the true clause has an integer
one and the false clause has a double to
zero what's the the type of that going
to be did I not give it away on my slide
show of hands is this a double yes
not everybody's falling asleep yet cool
and then the interesting sort of last
case again talking about the uniform
class hierarchy is that is that we can
say you know if if P is true then one
which is a value type the integer one
else new foo which is an object type and
that's going to have type any which is
the common super type of everything in
in Scala both the value types in the
reference types yes go ahead yes if if
two different objects have a common mix
in and that happens to be the sort of
you know the least common denominator to
then yes that mixin trait essentially
that interface right will be will be
used as the static type of that
expression it's a good question
so if else is just one example of this
of course like I mentioned basically all
of these control structures all of these
you know even a block of multiple
statements is going to have a type
statically at compile time that can be
you know that can be used for example
for type inference for for subsequent
things in the function and as value so
that ends up making your code look a
little bit shorter match case is another
great example in this this is this is
something that that I think more
experienced Scala program is find
themselves using all the time it's sort
of like a switch statement in Java but
you don't have to worry about fall
through between cases you don't have to
worry about breaking and the the pattern
matching ability is is not limited to
just value types or even I know that in
Java 7 for example you can you can
actually finally do switch on string
which is cool but you can do that in
Scala too and more so we look at a few
examples here so the way that this looks
is I actually think fairly
straightforward we say you know some
ease some expression match and then we
have a bunch of cases so case some you
know pattern one yields expression one
with type one some pattern two and
actually we can we can specify multiple
patterns and this would be the
equivalent of falling through ink in
case statements we can have multiple
alternatives for pattern that result in
some you know expression to with some
type two and you know we have as many of
these as we want of course the least
upper bound of all of you know t1 t2
through t TN that's going to be the
static type of our of our pattern match
so you know actually just in Java again
let's say you wanted to assign something
to a value in the scope of a switch
statement you would have to you know
you'd have to declare the variable
before the switch statement and do the
assignment in the switch statement a
whole bunch of times and try not to miss
any cases and the compiler ideally warns
you if you've missed a case well here
you don't have to do that you can
literally just say you know Val Val foo
equals e match whatever and you know
again foo foo acquires the value and the
type of that thing a question in the
back
say again
is there an equivalent of default yes
there is there is a there's a an
intriguing little bit of syntax in Scala
which is the underscore a use Scala guys
out there how many how many how many
uses of underscore can you can you think
of off the top of your head like on the
order of one four seven nineteen
I actually don't know it there was on
Scala line org they had like you know a
little survey off in the sidebar lay
like hey how many how many different how
many distinct uses of underscore are
there and I never actually I never
actually paid attention to the survey
results on that but under say so
so the underscore character is
essentially used as a wild-card
it can mean I don't care about this
value it can mean everything can mean
anything it can mean I'm binding a
binding a variable to this thing it
means a lot of different things but
essentially if I were to say case
underscore then that's that's like
saying case true case you know case
default case I'm going to match
everything that you send my way so you
would see that a lot as the last medal a
statement the case statement and a mesh
so some some examples here this is a
great example I think actually because
you get to see you get to see most of
the different different constructs here
you can see you know let's let's try to
let's try to compute the number of days
in a given month from from one to twelve
and we also want to know if it's a if
it's a leap year then we want to make a
special case for February right so I can
say to start out with that special case
case two for February if leap so this is
a guarded a guarded case then I'm going
to get 29 days in February right then my
my sort of fall through which you can
kind of think of it as a fall through is
case two if not leap right then
twenty-eight case four or six or nine or
eleven we get thirty days in those
months so April June
September and November I guess no yeah I
don't know and case underscore right
case underscore all the rest have 31
days make sense so far and so this is a
this is a method right I've defined a
method called days that returns an int
and I didn't have to say return month
match blah blah blah blah blah I just
said okay well that's the value of the
thing and it has value int or type int a
couple more examples here let's say I
made this example up for for a class
that I taught a little while ago let's
say we want to prepare some foods we
have we have a a based rate or an
abstract based class called inedible
food and we want to get an edible food
out the other end so we can match on the
type of these foods so let's say you
know the food match B and B is a banana
then we can say you know just beat up
peel and this would be equivalent to
saying if if food instance of banana
then B equals you know cast to banana
and then beat up peel right that's how
we would do that in Java in Scala this
gives us the option of directly pattern
matching on types so you know if we have
if food happens to be a banana called B
then we'll just call beat appeal if it
happens to be a nut we'll call it n will
bind it to this new variable and and
call n crack and otherwise you know
let's let's say I'll call null or
eternal another example we have this
notion of case classes things that can
be matched by their structure and we'll
see an example of this a little bit
later on but let's say I've defined add
as a case class then I can I can
actually say oh if I'm calculating a
bunch of operations or a choice of
operations so let's say we've defined
add subtraction and exponentiation as
our is our different operation types
then we can pattern match
add and say oh well if we're adding a
and B then the result of doing that is
going to be a plus B this is sort of a
contrived example because what you would
probably have in your case classes you
would probably have like a you know dot
evaluate or something like that so you
would just say you know add dot evaluate
but you know just to show you that you
can actually pull this this this
structure out you can say oh but ad has
a left hand side on the right hand side
my a and B and I'll just pattern match
those to say oh I'll bind those a and B
here and do the additions that was
subtraction same with exponentiation so
it takes a bit more work in job but I
think right yes question so the question
was how do you call this function and
you know of course you just you do it by
calling calculate on some operation ah
so again the question was where do I and
B come from a and B are new this this is
this is as if I had said Val a and Val B
here I'm creating I'm creating new
variable names fresh and binding what's
inside this add to those variable names
does that make sense so so if the
operation is an ad that has some fields
a and B that I'm going or you know some
fields and I don't even care what
they're called in fact if I didn't care
about their values I could say ad
underscore comma underscore and those
and that wouldn't bind those variables
but you know of course I want to do
something with with the structure that's
inside that ad so so I can bind them
there yes another question um good
question so in the in the event so so he
observed that I didn't have a default
case like I had here and in the event
that the operation wasn't any of these
things then the the the behavior there
could be one of two different things one
thing that could happen is if ad sub and
X are the only three case classes that
implement operation then the compiler
will be totally satisfied it won't
inject any extra you know try catch kind
of code or anything to handle the
possibility of none of these things
matched
because it can see oh this is a this is
a exhaustive pattern match we've covered
all of our bases but in the case where
we've got some other you know let's say
a division operator or a multiplication
or something like that that we didn't
match in here then the compiler will
actually complain at us and say hey you
didn't you didn't cover all your cases
yes so the question is is how could the
compiler know the exhaustive list and
the answer is if if we're using I'm
trying to think like what's the quickest
way I can explain this so the short
answer is there's a notion of sealed
classes or sealed traits if I declare a
an abstract based class or if I declare
a trait to be sealed then what that says
is all of my subclasses have to be
declared in this one file oh that's
another thing that you can do in Scala
that you can't do in Java you can define
multiple classes per file without having
to you know and without them having to
be like inner classes so I could I could
have you know let's say an operation
file
you know operation dot Scala right that
has you know sealed trait operation and
then a few case classes add sub and X
and the compiler will know based on the
fact that they're in the same
compilation unit the same file that
those are the only possible values the
only possible subclasses for that
operation trait that trade is closed for
business
aft at that point but let's say I
haven't declared it a sealed then we're
out of luck then the compiler injects
some additional code in which you know
basically if you if you get to the
bottom of your match and you haven't
matched any cases then you'll actually
throw an exception you'll throw a I
think it's a match error a scala dot
runtime match error yes yeah that
becomes a runtime error there so so
that's so that's the value of using
sealed traits with case classes or the
value of you know say using Eames
Scala has has something that I actually
find a little bit janky
that is the enumeration trait I like
case classes better I think they're a
bit more elegant usually but you know
anything where you can exhaustively list
all of the possibilities the compiler is
going to do more work for you and give
you faster code and safer code so it's
kind of nice you don't you know you
don't get that from Java so we talk to
you now we just talked about this if
you're matching on a sealed class since
this is the compiled level will warn you
if you missed a case for loops for loops
are a bit more powerful in Scala so
similar on first glance to to what was
introduced in Java 5 before each loop so
I can say you know let's say I've got a
list of a list of strings you know a
list of hello and Scala I can say for s
comes from that list print line s okay
so that looks that looks pretty normal
right but I can also have multiple
generators multiple things that are
bound to temporary belt variables so I
can say you know for for a comes from a
list of hello mija and namaste and then
B also within within the same for I can
say B comes from the list of world in
Scala print line of a plus B and that
actually gives me sort of the different
combinations so I would say hello world
hello Scala me AHA world knew how Scala
and so on right and I don't have to
express these as nested for-loops
just the fact that I have multiple
generators in this one for loop is good
enough I can even have guards on this
where we're you know I I don't even want
to execute the body of the for loop
let's you know let's say I don't want to
execute my my print line here if the
word length is equal to 4 I've you know
I don't want any four-letter words so
you know lately I'm doing a read line
I'm splitting it on splitting it on
space characters and if we're not a
four-letter word then let's convert it
to uppercase and print it out all right
so we've got it we've got a value
assignment in there as well gutter guard
or value assignment and so of course the
general form here is you have four and a
whole bunch of enumerator
an enumerator enumerator is sort of like
a a general way of saying you know any
of these generators or guards or value
assignments or what have you
but then you know this this sort of gets
beefed up even further when you
introduce yield in which you know so so
say in a normal for loop you have the
body of the for loop and that's
something that's executed and you don't
really care what the what the value of
that thing was you don't you know you
basically discard that so our print line
right you know our print line we just we
just execute that for its side-effects
and move on with life but in a for yield
we actually collect the values that are
computed so I've got sort of a hairy
example here so you know for I comes
from one to ten J comes from one to ten
we'll compute a sum of I plus J will
have a guard you know if if the sum is
even you know some modular two equals
zero and then we'll also compute a
product I times J and then we're going
to yield a four tuple and actually I
could write this I could write this even
more cleanly without saying the word
tuple for like I can just say you know
per an IJ some product closed paren that
means the same thing but I'm making it a
little bit more explicit here for the
Tuck and what happens is is we actually
get a vector at the other end containing
all the different permutations this this
does this does all of that sort of
collecting and flattening for us so you
know the first you know we get I equals
one J equals one their sum is even so we
keep going and their product is one next
you know is 1 J is 2 oh that doesn't
work so we skip it then you know I is 1
J is 3 the sum is 4 okay product is 3
and so on so we actually get these
collected into a vector or say a list or
whatever and end and these are these are
basically spit into some appropriate now
I'm not going to define this but some
appropriate container type based on the
types of things that were in the
generators so this is kind of nice
because like you know as they say in in
Java if you wanted to collect things as
you went through a for loop or let's say
you know as you went through a series of
nested for loops
you would have to again declare the list
up top that you're going to put things
in and then as you iterate through the
for loop you would have to say you know
list add it's a very procedural right
you're saying how you want the things to
be added is it very uh sort of
procedural approach right or imperative
approach here you just say I'm going to
collect everything I'm going to collect
everything into one big flat collection
all right then finally let's let's look
at some higher order functions this is
this is where this is where Scala starts
to get really powerful I mean everything
else that we've seen so far was for the
most part except for maybe traits I
think I think traits is is sort of big
deal like I think everything else so far
for the most part is sort of syntactic
sugar but here is is where things start
to get really interesting because in
Java in Java if you want higher-order
functions you have to have a class
called function with a method called
like apply or F or whatever like if you
if used guava for example you have a na
interface called function and you have
to implement apply right well here you
can literally pass code so let's say you
know I've got some some trait I'm not
gonna I'm not going to say its name you
know maybe it's a sequence maybe it's a
list whatever so you know it's just
called trait X of a where a is a is the
type of the thing that's in my in my
list here and we'll define a function
called map that takes a function you
know it's not just taking an object it's
taking a function f that map's things
from s to B's and then out the other end
will get some collections and some X of
B's right so you know let's say I've got
a list of a list of numbers and I want
to map those to a list of a list of
months or a list of you know colors or
something like that right so I would
pass it a function that that defines the
mapping and then I would apply that
function of apply that mapping to each
element in my list right as I go along
so for example let's say I've got you
know the function let's say I've got the
the range 1 to 10 and I want to map this
closure this this this you know this
this anonymous little function here that
takes an X and gives us x times 2
anybody who's used say groovy or or
Python you know I think is going to be
fairly familiar to you guys
yes questionnaire this is a lambda yes
exactly
or yeah that's right yeah you can also
think of this as a function pointer
which you know if you were doing this
this style of thing and see you can
think of a lambda is essentially like a
callback right a function that's going
to be called inside you know inside your
your higher-order function the function
that's that's accepting the function
pointer so if I if I map x times 2 over
m over the collection 1 to 10 then I'll
get you know 2 4 6 8 and so on I can
also in it this is another another case
of my my mysterious underscore here I
don't have to say it's a function that
takes an X and gives us x times 2 I can
just say it's a function that takes
something and doubles it there's my
little underscore shorthand all right
so let's say let's do another example
here let's say I want to filter things
out of a collection so I've got my
collection type X again so you know some
trait X and I'm going to pass it this
time I'm going to pass filter a function
that takes takes my a I might you know
the type of thing that I'm containing
and returns a boolean indicating whether
or not I want to keep the thing or or
toss it out right and that gives us a
new a new list or a new container X of
A's so you know we can do the same sort
of thing let's let's take our take our
list 1 to 10 and filter filter out the
mmm filter out the odd ones we'll keep
only the ones that are even so so given
some X our little lambda here is going
to be X mod 2 equals 0 right so that'll
give us again just the even-numbered
ones 2 4 6 8 and 10 and we can we can
shorten that again using our using our
underscore trick we can say underscore
mod 2 equals 0 so saying you know we're
going to filter the things who when when
taken modulo 2 is equal to 0
you include you include the ones with a
better their true yeah
partition is another interesting one is
sort of like sort of like filter but but
it gives you gives you the best of both
worlds partition is going to take that
same type of function the do I include
this or do I throw it out and it's going
to give us a tuple a pair of lists one
for the stuff that was included and one
for the stuff that was thrown out we can
define these ourselves this happens to
be something that is present that is
present in the in the Scala standard
collections library on things like lists
and sequences and vectors and arrays but
we could very easily define this sort of
function ourselves it's not it's not
special to be able to take a to be able
to define a higher-order function that
takes another function so you know again
we can say one to ten partition
underscore mod two equals zero and then
that gives us a tuple of two vectors one
which includes the evens and the other
which includes the odds all right so we
can do all kinds of stuff like that
another another one this is a little bit
of a trickier case reduce left again
this is this is present in the Scala
standard collections library let's say
we want to take the sum of one to ten so
we give it a function and this time our
function doesn't just go from s to B's
this goes from a tuple to a B in this
case our DNA are actually the same
they're both hands but basically our x
and y represent the value that we're
looking at right now and the value that
we've accumulated so far and we're going
to do X plus y so this this is sort of
the same thing doing this reduce left is
the same thing as is doing basically a
for loop right basically the same thing
as doing a for loop where we say you
know I is equal to the element that
we're looking at plus or you know I plus
the I the element we're looking at right
even shorter hand here since we've got
two parameters each of which we're using
once we can just call them both
underscores reduce left of something
plus something else that's cool but of
course you know a shorter hand is just
called the sum function which already
does exactly this and since we're out of
time I'm not going to get into monads so
what I want to do first of all anybody
get the movie reference okay good I know
right it's going to be global
thermonuclear war yeah yeah now we're
going to be talking about tic-tac-toe
and I promise these are my last two
slides here so we want to model and this
is something that I do in my my class on
Scala we want to model the game of
tic-tac-toe and then we want to define
an artificial intelligence player for
tic-tac-toe very sophisticated so let's
let's model this real quick this is this
is sort of our only like real world code
code example in this whole talk so so
everybody wake up we've got let's say
you know we need to we need to have some
notion of a player right this is two
fifties two players playing the game and
I would say you know well we could
represent these however we wanted we
could represent them as a boolean we
could represent them as an int we could
represent them as a string or whatever
but but the nice way of doing again is
this this sort of finite and expressive
set of choices is using our case classes
again so we have what we called a sealed
trait or I could have also done this
with a sealed abstract class sealed
again to indicate that there's only two
possibilities which are the ones that
appear right here one of them is called
X and the other one is called o and
there's a both objects that both
Singleton's so this is sort of like
doing an enum right and also similar I
think in Java 5 they introduced to
introduce the notion that an enum can
have can have data inside and game can
have methods inside so same thing here
are our sealed trait defines or declares
a method called opponent and in our in
our concrete implementations we say oh
well you know the opponent of X is going
to be o and the opponent of o is going
to be X ok fairly straightforward I
actually think this is a little bit more
verbose than Java z gnomes I actually
really am a fan of Java z gnomes so this
is a bit more verbose it's also more
flexible in some cases but anyway this
is the way it is
then we want to be able to make a move
on a board so what does a move look like
well takes a player you know it's a
particular player making the move and a
row and a column on the board right you
know somewhere between 1 &amp;amp; 3 or 0 &amp;amp; 2
and an interesting thing to note here
that I haven't talked about yet is this
parameter list I've declared my you know
case class move and I give it a
parameter list right up front I don't
declare a constructor so that's kind of
odd that that's that's also you know
again this is just sort of a syntactic
difference but this is something that
that ends up saving you like kind of a
lot of boilerplate typing because in
Java the way that I would normally do
this if I wanted to have a player field
in a row field than an inch field or a
column field is I would say you know
private player player private row or you
know private final player player private
final intro private final int column and
in my constructor I would say you know I
would take those parameters and say this
dot Rho equals Rho this colleague was
call this is doing all that for you this
is doing all of that for you player is a
private final you know objective player
type there's an accessor for it there's
an access or method and that method is
called player so if you were to call
into this from Java code you could
actually say you know move dot player
paren paren and get the player and the
constructor is you know doing that you
know this dot player equals whatever
this dot Rho equals equals Rho and so on
so this saves you quite a lot of typing
and quite a lot of consternation when
when you're you know basically you're
going through the whole process you're
trying to trying to create a big class
hierarchy for some some problem domain
that you're modeling you don't want to
have to do all this sort of boilerplate
stuff is yes so so you get the getter
and setter the getter it doesn't follow
being naming conventions is so it's not
called get player it's just called
player and a setter so so these are
actually vowels they're immutable so
settar won't be generated for them if I
were to additionally you know create you
know put some curly braces here and
define some Verena body then setters
would be created for those okay we also
want to know the status of the game
we're modeling tic-tac-toe I want to
know we want to know who won and there's
three different statuses that a game
could be in three different kind of game
states we could either have a winner so
the game can be over with a winner which
is unlikely all right
and this case class is actually going to
you know again where we're going to
specify a parameter to that case class
and is something we can pattern match
against we'll see that in a second and
that went you know the win is one of our
potential statuses draw is another one
and that's obviously the most most
likely outcome and again and then
undecided of course meaning that the
game is still on so okay now I've
defined it this way you might might
think of defining it some other way but
this is just you know this is me really
getting into the idea that case classes
and case objects are very cool because
you can pattern match against them and
exhaustively so you don't have to worry
about some additional you know player Z
popping up in the in the mix and then
finally I'm not going to I'm not going
to show the implementation of board but
let's just say I've got an abstract
class called board that that knows what
moves are legal on it and implicit in
that is it knows whose turn it is right
we want to also be able to play a move
out of that set of legal moves and I'm
going to say that that returns an option
of board meaning well you know if we
actually try to play an illegal move
it'll give us none sort of like
returning null right it'll give us none
no board because you try to play
something illegal on it or you know
normally you'd get some board and then
finally it's able to determine its
status so okay so this is all fairly
straightforward I think I think this is
this is enough to kind of model the
whole game of tic-tac-toe right and you
know so you could consider playing a
sequence of moves getting a new board
each time with with some different
players and what I want to do sort of is
my my fine
my final exercise here is show you a
giant chunk of code that takes up a
little bit more than a slide and show
you how I implemented an AI for
tic-tac-toe basically the the whole the
whole need of our AI is going to be in a
in a method that I'm defining called
best move we want to know the best move
on a board right for any given player
inside best move we're going to define a
couple little helper methods one called
value and one called find so what value
is going to do for us is we're going to
compute you know basically if I were to
if I were to make some move some you
know some move M if I were to make that
move then then what I win lose or draw
the game and then find is going to find
the first legal move providing some
desired outcome so what I really want to
do is say I want to find a win and we'll
find the first one otherwise well I'll
settle for a draw and this this really
this right here this this lazy eval move
that's that's really the crux of the
algorithm I want to find a win and if
that doesn't work then I'll find it
wrong and if that doesn't work then well
alright fine I'll find the first move in
which my opponent wins which of course
is going to be the first move that I
look at so the way value is defined
we're going to say but oh and here's
another another little bit of scholar
syntax for you know to make things still
be be essentially Java ish while
appearing a bit more functional this
board play move is actually calling
board dot play parens move this play
looks like an operator looks like an
infix operator right and in fact any of
our any of our normal operators like + +
x + equals equals whatever those are
actually defined as methods on their
respective classes if I say you know one
plus one that's actually one dot plus
paren one is the way that that's
actually defined in Scala so kind of
interesting tidbit so I say board play
board play move and this then this weird
flat map thing which was in the slides
that I skipped over
and we're we're doing pattern matching
now on the status of the board that we
get out the other end if the status is
undecided then we're going to
recursively call best move until you
know we want to keep calling best move
until we actually get to the end of the
game we want to follow some some path in
the game tree otherwise and this is you
know pattern matching again sort of sort
of being as powerful as it is this is
our first case or undecided case
otherwise any other status which of
course there could be there could be -
it could be win or it could be draw
either of these two statuses will say
okay that is the value of that move
ended up as some status set you know
some win of X or o or some draw so this
is fairly compact I haven't explained
all this stuff and that's fine then you
know we define find and find is actually
a method that's defined on collections
so we've got our we've got our list of
legal moves our set of legal moves or
whatever and we can we can literally
call find on that but find again is a
higher order function find takes a
method or a lambda right and I'm using
my magic underscore here so find
basically you know find something that
satisfies this condition where the value
of the move I'm looking at that's my
underscore my little anonymous variable
binding on this given board is equal to
the status that I want and then I'm
actually going to bundle this stuff
again using map I'm going to bundle it
up again with the status so that I can
propagate it back out and then really
the guts of this algorithm again like I
said is this lazy Val well why have I
made this lazy this is this is just to
sort of tie everything back up and what
we talked about really early on in the
talk this idea that lazy value it lazy
vowels aren't computed until we actually
need them right so my lazy Val expresses
or sort of the the right-hand side of my
lazy Val I'm doing all this finding I'm
doing all this recursive stuff you know
it's going to take forever tic-tac-toe
is really hard game but I've also
introduced a cache
that's you know something I'd define up
here a little a little private private
Val cash that's a needle and it starts
out as an empty mutable map and as we go
along we try to get stuff out of our
cache this is a really cool little
method this is something that that I
believe I believe the guava library if
you're if you're using guava in in Java
I believe guava has something some some
little helper on maps and and I think
it's like the maps to interface or maps
to static class something like that has
something that's that's kind of like get
or else update where you try to get
something from a map and if you can then
you know it just returns a value
otherwise you you pass it basically I
think guava calls them suppliers
basically you pass it something that
will end up computing the value if you
didn't already have it insert it into
the map and then return it right that's
what get or else update does get or else
update tries to tries to find the best
move on this board and if it's able to
find it then it simply returns it
directly and this lazy val is never
evaluated so that's kind of cool you
know III don't I don't have to worry
about oh does the cache have it and if
not then I'll you know I'll have an if
block that actually does the logic or
whatever I can literally just say okay
this is this is what I would do but let
me check the cache first so so you know
then of course if the cache has it we
get the best move back that we've
computed already otherwise we will we
will go ahead and compute the move from
this lazy Val so you know this is
obviously after after maybe an hour and
errand of hour and two hours and three
or whatever of hearing me talk about
skull is probably not enough to to
really understand all this code but the
idea that that essentially I've defined
an AI for admittedly a simple game in
what amounts to more or less you know
three lines of code and is you know some
some helper methods but you know
basically a slide right the idea that
you can do this in in the scope of
in the scope of a slide is really kind
of an interest interesting thing and I
haven't even started talking about stuff
like concurrency stuff like actors in
Scala right I haven't talked about any
of that kind of stuff the stuff that
that makes code on a very very large
scale but you know that that's going to
be deployed across multiple servers or
whatever it has to deal with thing I'll
call all kinds of fault tolerance and
things like that makes that appear as if
it were you know simple simple one two
three kind of procedures so the
punchline of all this I think is is that
Scala is like I say sort of less than
Java in the sense that in the sense that
by following a very rigorous set of a
very rigorous set of principles this
idea that everything is uniformly
accessible including functions as
objects the idea of monads which we
didn't talk about that let you that let
you encapsulate a lot of stuff and sort
of sort of hide it off into into the
type system really lets you write a lot
less code and the code that you do end
up writing ends up expressing expressing
your real you know sort of your business
logic right the stuff that you actually
care about not not stuff like oh I need
to do some null checking here or oh I
really want to optimize this so I'm
going to do some double check locking or
or whatever yeah you you get to sort of
throw that under the covers and entrust
that trust that the the power of the
type system is able to is able to take
care of a lot of that stuff for you
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>