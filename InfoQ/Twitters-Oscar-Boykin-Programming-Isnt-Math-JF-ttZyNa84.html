<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Twitter's Oscar Boykin: Programming Isn't Math | Coder Coacher - Coaching Coders</title><meta content="Twitter's Oscar Boykin: Programming Isn't Math - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Twitter's Oscar Boykin: Programming Isn't Math</b></h2><h5 class="post__date">2013-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/JF-ttZyNa84" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oscar Boykin I work at Twitter on
analytics type stuff data science type
stuff and I'm going to talk about a
little bit of my view on programming and
its relationship to mathematics
obviously the topic there the title says
something about it and then more
specifically talk about some of the code
we've developed at Twitter for Hadoop
and for some streaming applications
usually aggregations and how we've used
mathematics and how sometimes we weren't
that uptight about so here's here's kind
of an outline I'm going to talk a little
bit about my background in my view some
of the things that we've we've done with
abstractions that are like completely
out of math textbook which we thought
were really good some things that like
we're pain points that we just like we
we dealt with in you know less than
ideal ways and like what we look for
like you know what's the future of this
I'd like to hear some of like maybe we
have some other ideas so maybe someone
has some improvements we can make so I
I'm really uh my background actually so
I like I'm just telling how did I wind
up giving this talk so I'm not like I
really not a much more of a
mathematician than a computer scientist
I was programming from a relatively
young age I've only only took one
computer science class in school and it
was a language called small talk with
some crazy people like but I didn't
really use much after I did my PhD in
quantum information theory is mostly
what you might call mathematical physics
proving theorems about about mostly the
Schrodinger equation that's all people
are doing with that which is just linear
algebra um I was an assistant professor
for a little while the University of
Florida I did some stuff in quantum
information theory there but I started
to move more interested I was more
interested in distributed computing
systems for that in the academics are
usually more interested in compute bound
problems since moving to Twitter not
quite two years ago I've been more
interested in the i/o bound problems
that you see in a lot of analytics I
really it wasn't really that into the
functional programming community for
very long my introduction was I used
Haskell for a computer-aided proof on an
old quantum information theory result
and it was
a nice fit you really could have done it
in any programming language but the idea
was to use get the program to enumerate
all these possible little easy to prove
results which you could prove in your
code right there see that as long as the
program terminated they were each true
and then have it go through and
enumerate billions of these so don't
listen what the hell i'm going to say
because i've only been programming
professionally for two years you know so
like what the hell do I know about
programming maybe it is Matt you know
but I'm going to make the case it's not
okay so the first thing I want to say is
the fact that a math model mathematical
model exists for something is not
equivalent to saying that it is that
thing and in my view if that were true
everything's math I'm not aware of
anything that I'm skeptical that we can
build mathematical models for so I'm may
be saying tacitly then I'm like strong
atheists like everything is physics at
the bottom level and maybe we just don't
know all of it but like there are
mathematical models for everything right
so let's like I'm not saying that but
that doesn't mean it's math so what is
mad you know well actually what do I
think of your scientist what is
programming so I think programming has a
lot more to do I happen to choose to
computer science building at MIT but it
has a lot more to do with building
buildings there's some craftsmanship
there there's some artistry you're
building a complex structure like
definitely I'm i assumed that people who
built that building there's something
about math I don't think most most
mathematicians would say they were doing
mathematics while they did that you
might have been doing some arithmetic
they're not doing mathematics a lot of
us might think this is dirty when I'm
enjoying programming the most I feel
like a craftsman I'm there at the table
I'm making something beautiful if it
doesn't look beautiful I'm not really as
interested in it mathematicians will
also say that by the way like beauty is
very important to mathematics but when
I'm done making some code it's it's
going to its it's like a chair i'm gonna
guess I'm gonna enjoy sitting in I'm
going to use this it doesn't just go and
sit in the library it doesn't get
written down and github and hopefully
never executed hopefully
when I programming you're telling
someone how to make something that
someone is often a computer you're
giving instructions you're giving
incredibly precise instructions I don't
believe when you're making recipes
you're doing mathematics I think making
recipes is fairly similar to what ninety
percent maybe more of my colleagues at
Twitter are doing so it's like they
don't recognize themselves as
mathematicians when they're there some
of them with their Ruby and their other
like I don't know your hipster coffee
script or something that's maybe a
hipster anymore right I gotta go to be
like royer I don't know I don't know
what the hipster thing is no um but
you're giving instructions you're not
proving theorems that doing mathematics
you're so mad here's some programmers
there they are there are following
instructions and hopefully that food
tastes good I don't know so there's a
great old joke about what a
mathematician is and it's a device for
turning coffee into theorems that sounds
like a compiler to me but it doesn't run
on coffee but so that's not what I do
though really I I write code and
hopefully the compiler can help so what
are the generalizations that I'm kind of
making here I mean like one thing is
there's this whole joke about like a you
know the Supreme Court like how do you
know pornography we really read the the
old quote it's actually heading to
hardcore pornography which somehow makes
it sound dirtier well for obvious
reasons I guess but um but the Justice I
can't remember who it was it's very
famous quote but I know it when I see it
right if i offered you ten million
dollars to distinguish a mathematician
doing mathematics from a program we're
doing programming I bet most of you
wouldn't say that's controversial like I
will take that yes i will i will try to
distinguish the mathematicians and get
my 10 million dollars so generally
programmers are busy giving precise
descriptions of how to transform input
bits to output bits they're writing down
functions generally in some sense okay
mathematicians get paid to prove
theorems if you're employed as a
mathematician what the highest level not
to put too many judgments on it you
would hope to be like writing papers
sending them to journals they would be
like no just contain proofs they're
ulemas there you start with axioms
this would be your business okay that
would be great that's that's that's not
what programmers are doing in some cases
compilers are doing that but let's be
honest the proofs that compilers are
doing our really stupid proofs like it's
like you know if you know this thing
over here is equal to that thing over
there and that thing where there is
equal to that thing then that thing is
equal to that thing I mean that's like
ten thousand year old mathematics you
know it's like we barely got the
compiler to do that like let's not blow
it out of proportion so now that's not
to say that there's nothing valuable
from mathematics that we can leverage
and doing like very beautiful code so we
want to use abstractions for mathematics
and we want to have mathematical models
of what we're doing I hope there are
mathematical models for the bridges I
walk across and we have some deeper
trust then like I tried real hard to
make a really great bridge and it's not
going to fall down and promise so like
so mathematical abstractions and models
are great they're fantastic so like some
of the ones that we've everyone knows
about the Mon asterisk d duopoly totally
owning the category abstract algebra
functional programming space there are
other ones the semi-group turns out to
be really awesome just slightly weaker
than the Mont way abstractions over Mont
ads or it seems like more mana ads in
mono it's are really nice you can see
these like patterns where it's like I
have this you know any mana and I'm
going to do like this thing and you have
like a huge menu of operations that
people didn't notice we're all just like
simple monitor transformers and that's
really cool like that's like not at all
a bad thing doesn't necessarily making
mathematics but it's like it's like
these are nice mathematical models the
other nice thing we get our the free
proofs of correctness with some
assumptions which I'll talk about in a
second of certain things so it's like
okay I've got dare I say a bijection
from Taipei to type B and if I have some
function from that as a reduced function
I care a lot about those reducers oh it
takes
an A and a B and it kicks out another
egg actually I'm getting Steven told me
this would happen next thing I be up
here these category theoretic diagrams
but anyways I get these like free
transforms from an existing function
that I already have on hand to this
other space that I want to use them when
the transformation is obvious and that
turns out to be really practical I'll
talk about it more later so we're
talking about mathematics I keep saying
this word theorems so who proves the
theorems so it's not the case that the
compiler is proving all the theorems in
your code when you write correct code
it's because you also at some stage
prove some theorems or like intuitively
you thought they were true and language
like closure you have like virtually no
theorems being proved to you by the
compiler and so you resort to
experimental like now they're
experimentalist they're not like
theoreticians at all that's what that's
what the tests are right we're doing
some experiments we're going to throw it
into a checker we're going to randomly
run some experiments see if our
hypothesis is true keeps looking like
it's true I guess it probably is you
know still no theorem there right that's
just experimentalism okay so we want the
compiler to prove some theorems in Scala
that's great you know as many as
possible is good and then there's this
question of like how how many are we
going to hope that it will prove for us
maybe all so the question is how to
manage the trade-off between things that
like could in principle be proved by the
compiler but in practice are just a
major pain in the ass like closure
developers are happy all day doing their
stuff and like you know for the most
part they seem to love it you know I I
guess that's cool and but the compiler
is not doing any work for them and maybe
get can build fine systems I guess
there's no real evidence that this stuff
that they're building is worse than what
we're doing I don't think there's
evidence at all for that it will be
great if there were evidence and we just
do something better but so what were
some of the winds what were some of the
concrete things that we did so we
released this library algebra it was
actually a fork of just some code that
was sitting around in scalding which is
a Hadoop library that we use which is
like it's sorry it is kind of like a
like a
a scala dsl of cascading and then we
tried to make it as more and more you
know you know more as close as possible
to scala collections api along the way
we wanted to do some linear algebra why
because a lot of the things Twitter are
linear algebraic if you think about we
have a graph we have a graph of people
interacting with tweets we have a graph
of people following other people and so
a lot of these things are linear
algebraic so if you want to do some kind
of feature extraction to do any kind of
modeling of this it's it's really nice
to think okay I'm just could take this
vector and hit it with this matrix but
actually doing that kind of calculation
on Hadoop can be really ugly like if
like if it was your job to write those
is like Java MapReduce like like you've
got more patients than me or you quit
your job like it's not something you'd
really want to do with your life so the
question was what what should the
elements of our matrices B and so there
was like oh maybe maybe along maybe a
double and it's like you know meanwhile
like you know it's like hopefully we get
to the answer soon but like let me talk
you out of meat along or double and like
let's just do like either a mono I'd
ring or group depending on the context
if we're going to see if we're going to
just add two matrices we just need the
mono eight why don't we need the model
we even ran in the semi-group well these
are huge matrices to their sparse and
most of the values are 0 so it didn't
even occur to us to start with the
semi-group because like we already knew
from the get-go that we are always going
to be dealing with sparse matrix
matrices so the zero was like really you
know front and center the ring is
necessary to do matrix multiplication we
heard a look we had like there's a great
library aspire which if it existed when
we were doing this didn't know about it
and will probably take their type
classes it looks really awesome we have
this question what are their interesting
rings are there other than numbers so
there are a few you can think of
polynomial is etc I actually don't
multiply polynomials in the follower
graph or anything but like I maybe lie
about it just to make it sound like cool
because we like doing our rubber anyway
so that's the background and so we came
up with something like this so cosine
similarity which is a measure if i want
to recommend like you might be
interested in following some person
it's a really simple totally brain-dead
algorithm that you can run and it
becomes really simple now we take a tsv
a we read it we say that it's a matrix
of row type and column type n and value
type double and we can just say code
like this where we're going to like
let's l to normalize it so each of the
rows becomes unit length and then we
just transpose a multiplying together
and write it back out now if you were to
write this job like that's like like
there's no way you can finish that in
like a one-hour interview in java like
like at the board like like it would be
a disaster like someone could not write
this code and more to the point every
time you keep doing matrix
multiplication its there's a good chance
you're going to get it wrong so there's
a big win and us saying that's a matrix
you're multiplying it like let's just
use this code we stop having errors but
then the question like like this is
nagging issue like well what if it's not
like so if you went to the spire talk
and if you know a lot of algebra it's
like well they're a lot like what if
it's not a ring what if it's wrong what
if it's a rig what if there's no
negation you're not really ever using
negation and multiplication should it be
a rig you know those giant rabbit hole
when I say programming a math isn't math
I'm saying I don't want to go down that
route of all I want to do some other
things rings are awesome I'll stop there
so let's see some of the value so here's
an interesting calculation we could do
super easily once we had like a mono it
on some like interesting data structure
so the question is the following brie
cheese or compute the set this or the
size of their followers followers so you
I'm you guys are all hugely important
people you must have tens of thousands
of followers on the twitters the average
the average is actually like a thousand
so don't feel bad like if you if you
have less than that it's because like
you got Obama and Lady Gaga and you have
to skew if this distribution that is a
super heavy tail again by the way it's
interesting is that mathematics or is
only category theory mathematics but
anyways I'll let you think about that
statistics there's also statistics in
the world not then come out much anyways
so because of this heavy heavy skew when
you do this cow
two hops out it becomes extremely
expensive so naive algorithm will be
expensive but what is that naive
algorithm so in this case here's a
directed graph we are concerned with the
second followers of a by this in this
case I mean the set enf no big deal I'm
going to move a little fast so once we
have this abstraction that we don't
think of it in the database or joins
we're just going to think the follower
graph is on the left I've just
represented this this graph over here so
is a binary matrix and every step on the
graph is hitting some vector with that
matrix and if I go two steps I'm just
hitting it twice so I see the second
power of that matrix and what are the
values of this vector well I need to
have a model that was my constraint I
need ever mono 8 on what I'm going to
propagate with so i can easily propagate
any like I'm cuz propagation I'm just
summing I don't really even need the
model i actually only need the
semi-group but what was the sparse
matrix you see all the zeros in there so
I wanted the model so in this case I for
the vector I put everyone set with
themselves so a starts with the set of
only himself his zeroth followers or
himself is he is his own 0th follower
and now once i propagate twice I'll get
the answer I'll sir the code in a second
now before we look at the code what if
we didn't know math math is awesome like
it's great to know math because if you
didn't know math this we just look like
a joint okay you'd have this totally it
would be to joins and then use some
aggregate count and everything and like
no one does like well I don't know no
one like or they're like version control
things like sequel and everything like I
like it's always just a nightmare when
you see this stuff and there's no like
you know like abstraction that I ever
really see in that that's my bias
obviously but like that's my experience
so you have all this opaque code that
hides the structure of what's going on
when the structure is actually super
simple like the cosine similarity it's
like two job I mean like two lines it's
nothing so it's great to know Matt so
here's like an implementation of this if
we weren't doing it in scalding but the
point is is
this is a very nice MapReduce job this
is microphone here usually like to wave
my hands all around and run all around
but I take the microphone now I'm not
going to go put it in time I'm being
vulnerable with you people I'm sharing
my anxieties you see so first we do a
group by we're grouping by all the
incoming edges so everyone who's coming
to me or to you we're going to group by
that we're going to shove over all of
the values V you've passed in and get
this vector I use a map here as a vector
here it's a sparse vector if you like
once I get all those values i'm just
going to sum them all up so I either get
the value or I get this zero out for
that that item you see don't pay too
much attention but I'm something this
code works for any Mon 08 and it's great
it's great that it's like like abstract
in that way and you could actually run
this and play with it and here's an
example we don't really we don't care
about graphs that small so the exact
problem becomes too expensive because
like Obama's second followers are huge
and number like Bieber second file it
sounds like well there wouldn't be that
many of them but if you go to the top
like 5000 moose followed people like all
of those people are followed by a lot of
people and they become like a huge cost
to do this kind of algorithm so what
approach to do is to do approximation
techniques so one thing you can do if
you know approximation techniques like
this like hashing techniques hyper log
log turns out to be a mono it if you
don't know that it's easy to see hyper
log log is an approximate cardinality
estimation I want to see how many unique
items have I seen that's kind of like
how many unique second followers how
does it work well it winds up working by
doing hashing a bunch of different
hashes and then keeping some minimums
along the way but minimum is totally a
modeling right so I take the maximum
possible value that's my zero minimum
clearly associative you're done so to
get a feel for how minimum works to give
you an approximate set size you see that
we take each value when we hash it from
the interval 0 to 1 so real numbers in
there or a bunch of bits if you have
more of a computer
background and then you just keep the
minimum value finally after you've done
this end times that minimum value the
expected the expected value that it will
take will be 1 over N where n is the
number of unique items you've seen so if
you just take the inverse of that you've
got in sounds pretty good actually the
variance of that method is too high so
you do various corrections to that and
that's hyper log log so we can do this
exact same code where instead of
initializing that vector with each set
of like just a set of themselves we take
a hyper log log data structure which you
can see in the algebra project and a
couple of other nice aggregation mono
aids for like streaming or large-scale
aggregation and now we've got these data
structures and we propagate those
through the graph and those are a fixed
size they don't grow as you've seen more
so with like a about a 16 killable I
think it's like 16 kilobyte which is
still kind of large data structure you
can get like less than 1 percent error
and no one really cares you know you
that's fine one percenter and you care
about ranking problems so you're talking
about the top K they're not even within
one percent of each other so you're
still going to get the rank right so if
it's your job to get the top like 500
followers like probably none of them are
we then 11 percent of each other so this
just works and then I just ran it and
you know it's a couple lines of code and
then I get this interesting answer right
away so as a huge value the answer by
the way is Obama he's not the most
followed or the second follow even the
third followed but I don't exactly know
why he's the most second followed I
assume it's because there's a high
variety of people who follow Obama where
some of the other people are more
focused like if you follow Bieber it's
like you have a really like it says a
lot about your interest but if you
follow a bomb it's like you're an
American you're like not even American
just someone interested in the president
so yeah so what was another win so
semigroups turned out to be a huge win
for us recently there's another project
that we've been working on to do
real-time aggregations and in this
project what we do is so so Hadoop and
is totally is nailed like the
reliability picture so batching and
getting that like you know reliable data
just on your Hadoop cluster like it
works great but serving that data is
painful like you can't serve out of HDFS
you have to think of a different story
there and just the time to get it into a
serving infrastructure due to queuing
delays in your Hadoop cluster or
non-trivial so so how do you work around
this so our solution is we t the logs
off once we're going to write it on to
the Hadoop cluster and then once we're
going to feed it through say storm you
can build a system on a CO whatever you
like now we want that real-time system
that's thing at the top the RT with the
pentagram the Pentagon not pentagram ah
there anything different thing we're not
into that kind of stuff I don't know
it's okay if you are anyway so uh so we
t these things off and now the nice
thing is in real time you have all kinds
of problems maybe you have lost maybe
you have like queue is backing up and we
don't want to have infinite memory so
we're just going to throw things away
but it's really easy to get or you have
duplicated messages like storm has at
least one semantics not like it most
once by default you can use some slower
transactional mode whatever so our idea
was like look let's just do a noisy
real-time in some small batching and you
see there's no edges out of those
real-time buckets only edges come out of
the Hadoop so who do okay so Hadoop gets
the law data and it keeps feeding
forward and we're doing what are we
doing we're just doing a semigroup we're
summing all the way up so we're summing
it like for each key we're going to sum
all the values for all time that's what
this is trying to do and then when we
want the real time data we just look up
the most recent batch that we don't have
online so we'll push these Hadoop
batches into some right once like
servable data structure but it'll be a
few hours behind maybe an hour maybe 15
minutes who knows its systems problem
but it won't be a millisecond behind
okay and then we'll look over to this
bounded size and more importantly
bounded error real-time read right thing
maybe it's a memcache store okay so that
one and because we have associativity we
have a semigroup
we know that when we take we look up the
most recent batch we've got and we add
in the real-time batch we know that
we've got the right value it's great so
that was a win and then I got this bad
reputation there's someone someone tweet
the mono AIDS or so last year where I
was going around Twitter saying like
okay you tell me a problem i padded some
on wood it's actually like amazing most
aggregation problems in streaming
algorithms are actually mono aids
because otherwise they're just like not
an efficient representation of the
problem so most of the things that we
are aggregating they're almost all
models it's really interesting so the
facts on the ground are that we're
developing code to be used by hopefully
100 engineers of Engineers of Twitter
it's not a monolithic structure so if
they don't like your code they're just
like okay I'm not going to use it so I
care about that I care about having
internal adoption that matters to me
some of those users use Java so like
totally going off the deep end in all
sorts of super ugly areas of Scala that
look like horrific when you try to call
them in Java is something I'm trying to
avoid a little bit not completely but
usually trying to avoid that some people
program Scala as if it were Java so they
just like fired up and it's like it's
Java with type inference and those
people are on the payroll and like
that's fine that's okay like not
everybody has to code the same way you
know so where do we go wrong where do we
make some mistakes so here's I'm going
to talk about some of the ugly stuff
that was the DS and stuff so this
stuff's not perfect even if you say it's
math it's not your you're lying to
yourself I love the math I love it but
who proves that your mana isn't on it
you're coding up your Haskell your
implements your bond but it's not bind
it's not associate if it's doing crazy
stuff I won't tell you that you have to
prove a theorem so in like like that
happens all the time and what if you
just fit what if you return error
everywhere what do we do I don't know I
don't so who st. at the monitor so how
do you who proves you're by jection is
injective and surjective and what about
runtime exceptions they're not going
anywhere you're going to get out of
memory you're going to get like you know
like you're gonna call some library and
they're gonna throw some runtime
exception you didn't know they were
gonna call you have to deal with it I
don't I don't remember any of that from
any of my real analysis classes or
anything it does not seem it all like
mathematics to me so our approach is
look we write some rights and laws we
want to code to follow we read some
scholar check for it and we chillax
don't worry about it it's not like that
big a deal man so here's a here's where
we ignore the rules just jam out code
and actually the house does not burn
down you know it's like okay you know so
here's here's our ring oh my god you
throw an error where's our unit on the
ring oh my god guess what we never call
that method it has never caused the
runtime exception and I didn't want to
like totally geek out on like massive
type hierarchies and like it you know it
wasn't a giant mistake you know no no
one was harmed okay so there are ways
around this and the the spire guys they
did invest in this and that's great and
maybe we'll adopt their work but I I had
other things to do at the time so but
the other thing to keep in mind here is
if I give you a ring without identity
and I pay you a million dollars to give
me a ring with identity you can do it
just like if I give you a semigroup and
I pay a million dollars to give me a
mono it you extend it with a like a fake
like zero value like you lift into an
option like you have the none now that's
yours your and you go on with your life
if programming is math by the way we
know that we don't like totally obsessed
like yeah we know there's an equivalence
between semigroups in mono it's not a
big deal you know same thing here it's
trivial to extend like a wrong touring
no big deal so the sad part is usually
people complain about this we even
sometimes if you believe it get people
commenting like on these giant issue
threats but so seldom do we get the pull
request please just give me the pull
request will take the code okay now how
about this how about this amazing
function crazy useful use it all the
time anyone intuitively obviously can
see that there's something wrong here
okay and but it's you do it in your code
all the time so when you put it in I
don't know oh my god wait a second not
all possible byte arrays are exactly
for this is not truly about you action
it's super useful though are there
better solutions yeah there are so
here's one better solution so we could
here's a by jection between array of
bytes and gzip bites this is a by
jection that no one can doubt that how
do we implement this though we do the
normal thing just you know do some
compression and then we wrap up the
array that we get in the end with this
decorator class that says look I promise
it's gzip bites now if this were closure
there be no types anywhere and it
wouldn't matter at all right but it's
still be a by jection mathematically
it's still a by jen right the types
didn't make it a badge action did it I
don't I don't I don't think you can make
that argument and the invert just takes
them off that's one solution that's in
the code that was one solution we took I
don't want to decorate every array with
this thing another solution um I've
never met him in life I've only met him
on the twitters and github so I don't I
think his name's jet maybe he's in the
audience maybe he's not but anyways Jed
suggested this I think it's a hack taken
from scalzi which you define this with
this thing called tag and then you can
say that you have a by jection between
instant strings which of course exists
all the 32-bit integers have one
canonical representation strings and
back and forth ok totally clear and then
you just decorate this type and say that
you're good this is kind of ugly too
what's the downside well like it doesn't
seem to work with primitives so if you
decorate like int at something that
doesn't seem that seems that the Scala
compiler can't handle that and also that
a tad is totally stripped off in Java
and I kind of care about that so that
sucks here's another solution i'm
playing with a little bit so when it
just like let's get more strict back to
the mathematics some things are by
actions some of these things are
injections on the invert we go to an
option of a we can't always invert ok
this sounds pretty good ok but now
here's the problem the scholar copilot
can't feel like there's this nice
connection between all by actions or
injections
and all injections are bye Jek shins
over that restricted subset this
actually this theorem has a name it's
the Cantor Schroeder someone else there
i'm told the obvious work with people
have never taken a lick of math and they
totally get it but but you know Cantor
can give me you know kanter needs that
40 we can we can name a theorem after no
big deal but the Scala compiler has a
lot of issues with this you've got these
now recursive to implicit types that
you're pulling in injections can take an
implicit by jection to construct them
and then there you're doing the low
priority pattern with some low priority
injections coming into play and it's
like father like sometimes deadlocks
sometimes seem to run forever don't
really know I don't really want to deal
with that don't really want to debug
that and unfortunately no and kind of
fortunately I'm not paid to debug that
so I've got to make some expedient
choices and the last thing I would like
if this were closure we wouldn't really
be that worried about it so I think that
we should leverage the type system for
what it is so we have these great
mathematical models they're awesome we
use them and they're they're powerful we
get a lot of benefit out of it but like
there's a certain uh we did well let me
I'll stop it we need to remember that
humans can and must prove the theorems
though the computer's not doing that for
you and if you can prove the theorem
without the type system is that okay I
think that's allowed I think that's
necessary okay so even if the compiler
can't see something sometimes we say
it's true and we just go forward I bet
almost all of us have as instance of
somewhere in our code and you might say
something like this is okay because I
can prove that this cast will never fail
or if we like statistics will say it
will fail sufficiently and frequently
that I'm satisfied with it and that's
still math its statistics so
I'm supposed to say this please come
help me improve scalding make it faster
work at Twitter get called names for not
knowing mathematics that's my pitch
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>