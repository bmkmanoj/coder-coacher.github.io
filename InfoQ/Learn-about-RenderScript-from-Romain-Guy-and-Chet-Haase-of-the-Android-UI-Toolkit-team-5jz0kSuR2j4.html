<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learn about RenderScript from Romain Guy and Chet Haase of the Android UI Toolkit team | Coder Coacher - Coaching Coders</title><meta content="Learn about RenderScript from Romain Guy and Chet Haase of the Android UI Toolkit team - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Learn about RenderScript from Romain Guy and Chet Haase of the Android UI Toolkit team</b></h2><h5 class="post__date">2011-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5jz0kSuR2j4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome to the renderscript talk I'm
Chet Haase and mo McGee and we are go
ahead we'll do it at the same are we're
on the UI toolkit team working on
Android future versions as well as last
minute presentations we basically both
do graphics and animation and UI related
stuff and yeah and the reason why we're
qualified to talk about renderscript
is I spend a lot of time using
renderscript since Android 2.0 I went
through the hell the first versions I
hope she'll help shape the api's and
shed just felt like it so that's why
he's talking about it's pretty much why
I do everything yeah we are not actually
on the team that does render script we
are on we're sort of a consumer of
renderscript we use it for some of the
UI stuff that we do and we're also
graphics geeks but one of the guys that
it's primarily a developer in script is
Jason Samms he wrote a couple of
articles I have the links later in the
presentation about that so on with the
show whatever it is this is the agenda
we'll get into the agenda we don't need
to go over the agenda slide
ok so first some overview stuff actually
how many people have taken a look at
render script already ok so roughly half
that is impressive and scary it is I I
think it's a really powerful thing and
it's actually been used by the platform
for a couple of releases back to 2.1
already so it's not like it's just this
brand new thing however the
documentation is pretty slim I realized
as I was writing some of the demo stuff
leading up to the talk that actually
having a talk is probably a pretty good
idea because it's kind of hard to piece
together I'd say that the best thing you
can do right now is take a look at the
STK site api's and the sample code
that's how you're gonna learn it right
now and we're working on the docs really
really hard yeah and not just the simple
code but all the live wallpapers that we
wrote for Android 2.0 2.1 we're written
with render script so there are really
good examples of very complex scripts we
won't be able to go through an example
as complex as one of our live wallpapers
here but once you understand the basics
you will be able to go read those
examples and understand what exactly
they do yeah in fact the code for those
those were a lot harder than they would
be if rewritten today because they've
written a lot of utilities on top of the
core functionality of renderscript
to make a lot of the boilerplate of
writing renderscript
code easier so anyway renderscript is
for the people that haven't touched it
and have no idea why they're here it's a
new language it's also a compiler it's
actually two compilers and it's a
runtime and the basic purpose of
renderscript is for performing fast
rendering 2d and 3d rendering
functionality as well as computation so
it's got a rendering side and it's got a
compute side and one of the ways that
you can think about this is you can have
the speed of native applications so if
you're used to doing NDK applications or
native applications on other platforms
and maybe you're thinking well I don't
know if SDK is appropriate because maybe
there's extra overhead of you know VM GC
and stuff like that well you've got the
performance of native application but
you've also got the portability of an
SDK application so and you don't have to
deal with Jayne I how many of you have
ever written jana code did you like it
okay I spent the best 8 months of my
life pretty much writing jhené aiko then
I really wanted to die at some point so
the the portability thing comes in if
you think about like writing an NDK
application you're basically compiling
it for a target architecture which is
really awesome if that's the only
architecture that the platform ships on
but that's not right so we have primary
architectures but if a new one comes out
maybe your application is not going to
work there so NDK is specific to
whatever you build for well what you
really want and what you get with an SDK
application is the ability to just run
it wherever the platform is available
right in the SDK does that through the
magic of these classes that we bundle up
into the apk yeah and the problem with
multiple architectures even today you
could decide to pick one of the
architectures that is supported by every
Android phone so if you go all the way
back to the first Android phone you have
to support on the
five it's really slow you don't get
hardware floating points you don't get
parallel 13-point computations you could
choose on v7 but then you still confuse
the neon instruction set that lets you
do four operations at the same time and
then when Google TV will release their
SDK that runs on x86 your app or network
so it's obviously a problem for highly
efficient applications and that's why we
have renderscript so we'll get into some
of the reasons why it's a portable
environment but that's certainly one of
the big selling points about
renderscript in addition to just the
functionality and performance of it so
as we said it's actually it's gone
public in 3.0 so as of the honeycomb
release we actually expose the api's and
a lot of developers to write to it but
it has been used internally for the live
wallpaper stuff since 2.1 and in 3.0
it's used for a live wallpaper still
it's also used for the youtube the
cylinder the video wall as well as books
the cylinder of you know the view of
hard covers the Front's of the books as
well as the page turning effect did you
have a question so the question is
renderscript is a public API and 3oh
does that mean you can compile against
3oh and run on the older versions no
because we change the API so a lot yeah
it's very very different from what it
used to be and a lot better ago I could
go on and on with war stories about the
early days of renderscript
my favorite one is you have these two
thousand lines of render script and you
have one syntax error somewhere the
error message you get is a dump of the
CPU registers that wasn't okay so for
those of you who have never played with
honeycomb
yeah behold 3d and I think yeah books is
not going to come in because it's not
gonna sync with my account either right
we can try yes so and this is also
render script and X ratio up in a book
and you could turn a page that is also
render script so I believe we use a
webview to render the pages and then
it's mapped in render script on top of a
cool 3d mesh that we change in real time
so this gives you an example of how we
use render script on the official
Android platform to create really cool
animations in 3d with high performance
so man years of effort going into the
latest greatest technology on top of
multi-core and GPU machines to turn a
page of paper thank you very much a fake
page of paper yes alright so moving on
the syntax that you're gonna see in some
of the sample code that we'll walk
through is based on the c99 language so
it should be very approachable for
people that have used C and C++ which is
really not that different from other
languages like Java there's api's at two
levels so as we said it's a portable
application environment and part of that
solution is it is actually part of an
SDK application so you have an SDK for
creating the activity for initializing
some stuff and then diving down into
render script code so there's an API for
using render script at the SDK level to
sort of set things up allocate memory
get things going and then there's also
an API at the render script level where
you actually write render script code so
we'll see chunks of that stuff one of
the features of render script is
interesting is that it figures out how
best to share the work on the given
architecture so not only is it portable
code that's going to run everywhere but
it's going to determine at runtime how
best to execute it so if you got a GPU
and you're doing rendering obviously
it's going to farm that out it's
basically a layer on top of OpenGL right
now for doing the rendering so all that
stuff goes into the GPU for the compute
side when you're doing calculations
trigonometric math stuff vector
operations all that stuff is going to
happen on the CPU but if you have dual
core you can actually farm it out so you
can have multiple threads running in
parallel on multiple cores eventually
you can also potentially farm that out
of the to the GPU if that's appropriate
right now all the compute stuff is
happening on the CPU you want to talk
about the for each
yes we'll see a concrete example of this
at the end of the talk we will do some
live coding but so this idea of being
able to use multiple cores so either we
can use you know two cores on the owner
Tegra 2 chipset or if we were able to
run on the GPU could run now how many
hundreds of course the GPUs have these
days and this is done with a very simple
API
the renderscript side called RS for each
and this is actually one of the reasons
why you do a lot of the setup on the
dalvik side with the the Java API it's
because we don't want you to be able
able to do any allocation from the rent
from the script because then when you RS
forage it it just makes all the
synchronization prime disappear so it's
a very simple API to use again what's an
example of that later and this is how we
run on multiple cores so if you were to
write the same thing you know using the
Java programming language you would have
to create threads and you will have to
do some synchronization and figure out
how many cores you have or maybe you
figure out a way to use OpenCL or CUDA
to use the GPU just using ice forage
will do all the delivery for you so
there's an article that I wrote a few
weeks ago and finally got around to
posting last week called Android
rendering options that explains
basically what's on this slide every
time we get anywhere near mentoring
renderscript or honeycomb then people
say well you've got all these different
ways of putting pixels on the screen
what am i you supposed to use win so
here's the way I picture it so this is
my perspective I think it's correct
because I always do so there's basically
four buckets that you can think of
there's one big bucket called the NDK
and basically if you're porting an
application from some other platform or
you have a lot of native code we've got
a native library you just want to get
the thing working on Android this is an
option that makes sense right so there's
the C code there's a GL api's everything
just works on the STK side you have
basically three options to think about
first of all there's the canvas API this
is kind of the default if you write a
normal SDK application you've got
buttons you've got list views you've got
all this you know the the normal view
hierarchy and then if you have custom
rendering you can override the ondraw
method and you get a canvas object in
there and then you call operations on
the canvas like draw text or draw a
bitmap or draw line this is the canvas
API in SDK canvas you can only do 2d so
it and also it's interesting because
it's very good at doing 2d graphics
right and as of honeycomb it's also
hardware accelerated so
the reasons that people look for other
rendering operations be at NDK our
OpenGL wrappers prior to 3.0 was that we
weren't hardware accelerated so yeah you
could do 2d graphics but if you want to
do fast 2d graphics or if you want 3d
graphics functionality then you had to
look elsewhere as of 3d 3.0 we've got
GPU acceleration for the graphic so all
of that stuff is now pretty fast there's
a question did we stick with Lipski ax
which is the the native to the library
that we use behind the canvas and did we
hardrock sorry that yes and no we still
use the skia library for some operations
but we hardware accelerated the drawing
underneath the the Java canvas API so
there's a new native library that the
canvas talks to that we've side by side
with the old skia library you can think
of the canvas API is kind of being a
wrapper on top of skia and prior to 3.0
we would call down from the canvas api
into native code and render everything
through skia now instead of going
through skya
we go to this other code that translates
that into OpenGL calls instead but some
of the rendering operations aren't
handled automatically through OpenGL
like path rendering has to be written to
a bitmap first so we use skia to render
it to a bitmap and then we draw the
bitmap through OpenGL yeah all doable
next there was the reason all the
bottlenecks that we had we software
rendering they pretty much don't exist
anymore because we use OpenGL if you're
interested we give a talk at Google IO
called Android accelerated rendering the
video is on YouTube we give all the
details and we talk about some of the
limitations and primes with this
approach yeah so the render script
samples in the SDK do not run in the
emulator yes that's correct because they
require OpenGL es2
and it's not supported in the emulator
yet there was a demo a preview of
DeMolay are supporting OpenGL ES 2 at
Google i/o it's coming yeah not only
supporting the functionality but also
supporting the performance that the
emulator needs for graphics ok so canvas
API we're done
second option open opengl wrappers there
are rappers at the SDK level for OpenGL
es1
and OpenGL
es-tu so if you want to write an OpenGL
application but you want it to be
portable or you want it to actually work
with other stuff in the SDK then you can
certainly use the opengl wrappers and
basically write a full on OpenGL
application at the SDK level it's mostly
for simple applications because there is
a certain amount of overhead associated
with every call through to J&amp;amp;I which
anybody that works with J&amp;amp;I has probably
noticed before on every platform so
every one of those OpenGL calls is
basically a wrapper on top of native
functionality so you've got to go down
through that layer every time if you're
writing a game that may not be the most
appropriate way to do it because that's
good the kind of overhead you don't want
to take if you're doing simple 3d
functionality you're just drawing a quad
every now and then you need to be
texture map that's great but one of the
primers of OpenGL is how many of you
have played with OpenGL before OpenGL
es2
ok same amount of people for those of
you have never tried it actually last
Friday I wrote a real sample for
something I'm working on and I'm just
drawing a photo on screen that's all I'm
doing
that's 400 lines of code with OpenGL es2
because there's a lot of setup involved
so even when you want to draw something
very simple in 3d it's still quite a lot
of works you have to learn quite a bit
about OpenGL so here comes render script
that will do a lot of that work for you
and also render script so render script
will use internal OpenGL to do the
rendering so it won't be faster at
drawing but all your logic will be
native code so we get rid of the pain of
initializing OpenGL and we get all the
efficiency of running native code
instead of running inside the virtual
machine question is it similar to glut
glut was a utility library for OpenGL on
the desktop yes and no I mean it has
some features like draw quite for
instance to draw a quad but it's mostly
that it will do all your initialization
for you handle the threading stuff like
that and then it's got other
functionality in there as well I compute
and vector operations and stuff that
glut didn't approach
okay so when you're writing a
renderscript application there's some
sort of basic steps first of all you
figure out what it is you actually want
to run in renderscript a couple of the
key elements to think about it and for
renderscript applications are loops that
you want to speed up or particular
pieces of functionality that aren't
going to work through the SDK like
you're doing 3d graphics so you may use
renderscript for just bite-sized pieces
of like I want to speed up this inner
loop or I want the the following effect
on this custom view and you can actually
just write that thing in render script
and it'll draw - it's a little frame
buffer and be all happy and accelerated
but the rest of the application could be
completely SDK on the other hand you may
want the entire application like the
books application to be a render script
application okay so you figure out what
it is you actually want and render
script and then you have two sides of
the render script application right you
have the render script file itself where
you write the functions and you expose
the fields that you want the data
structures all the core functionality of
what it is render script is going to do
and then you write the files on the SDK
side and these are the files that
basically initialize and create the
scripts bind to it and initialize it and
start it running and we'll go over some
of these steps in a bit more interesting
detail but this involves stuff like
allocating the memory that you then hand
over to render script because one of the
key constraints where the render script
is it allocates nothing now you can have
a simple field in there but you cannot
have an array of objects instead you
would allocate that array at the SDK
side hand it over to render script and
then read your script can operate on
that and then finally you just you know
shape your application that's easy
okay so compilation steps this is part
of the interesting technology behind
render script we use LLVM which is a
open source available filer and runtime
it's it stands for low-level virtual
machine do we use clang it's a variation
of clang okay so we actually use two
pieces of LLVM one is the front end and
one is the back end on the front end we
compile the source code that you write
the actual render script application
into bit code and then we ship that bit
code we pack that binary in with
your sdk code into the APK and then when
your application actually launches on
the device at runtime we do the other
step that back-end LLVM so we actually
have a small LLVM compiler sitting on
the device which at runtime will then
say oh ok this needs to be compiled into
device code and this is how you get the
portability that we were talking about
right because you're shipping not source
code but this bit code that is device
independent and then at runtime it's
actually installed on a device and it
knows oh this is the ARM architecture so
I'm going to compile to that it does
that last step of compilation and now
you have natively compiled code running
yes the code is cached so how do you use
renderscript from AOSP go look at
packages slash wallpaper slash basic
that's the leg wallpapers and I believe
there's one more target to add to say
that you want to compound
yeah gingerbread is final for you
because we'll see we'll see the details
later but when we compile the render
script not only do we compile the script
itself into bit code but we also
generate Java code that you need to use
from your application I think I created
a vanilla project that just built just
works and I think the three Dino
compiler knows what to do the source for
the compiler well yes and no the source
for the compiler used in Android 3.0 is
available the compiler used in android
3.0 will be made available I believe
when we open source the next version of
Android whatever we were using before
Android 3.0 which was in the LLVM I
believe we had the custom C compiler so
part of the initial step of compilation
when it's creating the bit code for the
renderscript code also creates wrappers
on the sdk side so when you put fields
and functions in your render script code
the compiler walks through those and
creates wrappers automatically in this
SDK side so that you actually have
something to call from your java code so
it will create wrappers we'll see some
of this in the sample code but you'll
you'll have a simple set and get
functions for fields and you'll also
have wrappers for the functions
themselves so you can call directly into
the functions branch and that's the part
that's an awesome replacement for j'ni
because we actually output for you all
the the boilerplate code you would write
for in Jane I to just invoke a random
native function and something
interesting and note which I just
learned today is you might worry so as
we'll see the render script code the
rendering code actually runs on its own
thread which is one of the reasons that
can be so efficient it's just hammering
on this stuff as fast as you can well
you're on the UI toolkit thread on the
SDK side and if you want to call one of
these functions well what does that do
to the render script code which is sort
of running in parallel doing its own
little thing you are not actually making
direct synchronous calls down into
render script you're instead putting
command requests onto a queue that gets
serviced at an appropriate time later so
you're not gonna actually interrupt this
stream of control on the native side and
set some variable that's going to screw
things up down there instead you're
basically calling into this wrapper code
that puts something on a command queue
and that gets serviced the next
available time okay and then launch LLVM
compiler gehen and we have portability
tada
so the way you use render script on in
your application so there are really two
ways of doing it and we're going to talk
about the depart the most common one for
now where we actually do rendering so
you just create a regular activity and
you have your layout and you can have
your buttons and add stuff constants in
the books application when we were
turning the pages of the books that's
renderscript
but around renderscript they still had a
menu that was created using the standard
UI toolkit so to use render script in
the UI you just use something called the
RS surface view it's just a subclass of
surface view that's used to render
OpenGL usually and this one just does a
little more work to initialize render
script and then from that our surface
you you can get a render script GL
object and it's very important that that
that you that you get a render script GL
object because that object is able to do
rendering if you don't care about
rendering again we'll see about that
later you can just use a render script
object and you don't need the surface
view then you just have to eat your
script and to initialize the script
which generates a lot of code for you so
you just have to call api's that are
created at compile time and then you
have to bind initialize the script
itself so you have to bind all the data
that you wants to use from the script
because remember you can't do any
allocation inside the script
except on the stack so if you want to
create I don't know for instance and
whether they're live wallpapers we have
we use twelve thousand stars retaining
some sort of a spiral galaxy that's
where you do that you bind them to the
script and then finally you indicate
what is the route script so the route
script is the script that render script
we invoke automatically on every frame
possibly 60 times per second to do the
rendering and it will be clear when we
go to the code okay so all of that was
initialization and then at runtime so as
I said render script is running on its
own thread and it's calling this root
function over and over again and you
tell it the frame rate that you want by
a return value from that function which
we'll see and there's no indication from
the SDK that's required in fact it's
probably better if you don't disturb it
if you want the highest performance
possible just let it do its own thing
you probably want to interact with it to
some extent like user interacts they
press a button this changes a value you
want to push that value down all of that
stuff is very easy but you don't
necessarily want to interrupt it on
every frame like you don't necessarily
want to run an animation on the SDK side
that is setting values that are then
being used at render script time that's
synchronization between the two of them
is going to end up costing a performance
it's probably better to just do all of
that internal stuff on the render script
side and root is called Reaper but
repeatedly and you determine the frame
rate by a simple return so how do we in
the real time interaction so like Chad
mentioned render script runs into its
own thread and there's a message queue
to interact between the two threads it's
actually how the UI talk it works itself
there's a there's a UI event queue so we
just push push messages to the to that
queue and when it's time to render a new
frame we process as much of the queue as
we can so we'll just delete our search
so as usual you have to go as fast as
you can to not miss anything it's not
like you have to avoid it for you know
everything it's I mean that would be a
perfectly fine interaction one of the
renderscript examples is exactly that's
it's a ListView that runs with the
render script you would not notice any
performance lag it's more like if you're
trying to get you know the highest
compute performance possible then you
don't want to interact with SDK code at
the same time yes so so you'll talk so
the question is about one
the live wallpapers called grass wear
from time to time we send a huge chunk
of data to the script and that contains
constants or position on the planet so
that we can change the time of the day
in the skin in the wallpaper it was done
this way because when I wrote that live
wallpaper that was the only way to do it
you could just put just a giant blob of
bytes these days you can write one
variable instead so much you can also
invoke functions at the time we were not
able to invoke functions in the render
script that's why we mentioned earlier
that the live wallpapers are both good
examples of render script and also bad
examples one of the good ones is galaxy
for instance or water yeah so we
mentioned that you can't do any
allocation from the render script so all
the allocations are done on the dalvik
side and you use three classes to
perform the allocation so we have the
allocation class elements and types and
it's only it's very important to
understand what those those things do
even though you in practice you don't
really see them very often so one you
when you want to describe a data
structure for instance a bitmap you use
the three classes so the first one is
the element the element is the most
basic unit of data that you have in your
structure so for instance in the bitmap
each unit of data is a pixel and a pixel
in a 32-bit 32-bits bitmap is made of
four unsigned bytes so to create a
bitmap allocation we would start by
creating an element that contains four
bytes and each byte can have a name so
one of the bytes would be the Alpha
another byte would be red green and blue
and so on a type is just an element and
a dimension so for instance if your
bitmap is a hundred pixels wide by 100
pixels high the type of the bitmap will
be your element of four bytes and the
number of pixels so it would be a
hundred times a hundred and finally the
allocation
just takes a type and you can see that
as the adjustable above memory that
backs to type so the type describes what
the what the memory layout is and the
location is the actual blood of memory
yeah so that's about it like I said in
practice you don't really have to deal
with those
and we'll talk talk about an
example that you wrote right so we'll
walk through it were you to manually
create these things you can see what's
involved in actual fact there's there's
utility functions that make all this
stuff much easier which we'll also see
and a lot of this code actually came
from some of the code that was
automatically generated from some
samples that we'll see today so this is
what you would actually do if you're
doing it on your own but you know what
if you declare it in render script and
access it from the SDK side it's way
easier because it basically writes this
stuff for you okay so let's say that you
have the following information that's
going to track the position and the
speed of some object for this this Flake
object that we're going to to send
spinning around the screen okay so these
are the datatypes you've got a you've
got three floating-point values here
okay so we're going to say okay I want
an element so we're gonna use a builder
object there's builders for most of
these types of classes in render script
it's a common pattern that you will get
used to whether you want to or not it
makes it handy for sort of adding
incremental things along the way and
then creating it it's like an
incremental way of doing a constructor
okay so we create a builder given the
render scripts and then we add elements
to it so we say okay I want to add a
floating point element there's lots of
standards elements that are already pre
created for you in the element class you
can refer to one of those if it's just
going to be a simple type like this okay
so I want to add an element that's going
to be my position X another one for the
position Y another one for the scale and
then I'm going to create the element by
calling the create function at the end
okay so that's the first part we created
an element second part we can create a
type given the element that we created
before this ething we can say okay i
want to type that's going to be created
by calling type dot builder we'll
construct it like that and we'll set the
dimension and i think i forgot to call
the create function so there's actually
one step missing there where you just
call create after doing the set X notice
this is not a set X position X is
actually the dimension that you're
setting so we're going to have n of
these flakes so we simply set that
dimension and that helps create the type
and here we'll use X but in graphics
there are different types of dimensions
so for instance when you do 3d graphics
cube
is a cube map is a dimension for texture
we have meat map levels it's also a
different type of dimensions for texture
so the one that's that's the most common
is set X it's just a way to to indicate
how many items you have okay so we have
the element that describes what the
types are we have the type that
describes the element as well as how
many of them there are and then finally
we have the allocation which is the
actual memory that's allocated to hold
all this stuff which is basically going
to be an array of these flakes you can
think of this as basically wrapping a
malloc at the Native level because it
basically wraps a malloc at the Native
level so we say allocation dot create
types and we pass in the type here along
with the renderscript and that gives us
the allocation that we want there are
tons of different constructors that you
can call I'm just walking through one
particular narrow example here there's a
question yes that's always sticky yep
yep yep yep haven't touched render scope
okay so instead of doing all that manual
approach of creating the element and
then the type and then the allocation
you could also say I want to create a
sized allocation and I'm going to pass
any element that we created first and
then end for this number of flakes that
we want and it'll give us the allocation
then if we also want the type then we
can ask for the type from that
allocation so shortcuts for doing all
this stuff in general okay here's
another way to approach it so instead of
creating the stuff manually all at the
SDK level we could create a data
structure at the renderscript level so
this is actually render script code
you'll see it later in the in one of the
demos that we walk through so we have
two float values for position x position
Y a float value for speed and we declare
this as a structure we've declared this
Flakes
field to be a pointer to things of that
type so this is basically an array that
we call flakes and then on the sdk side
we can say okay I want my field to be
equal to script field underscore flake
this is generated code for you it
generated from this information
specifically from that name right there
it created something called script field
flake that you can then call into as a
method passing your script you pass in
the number of flakes that you want to
create and you tell
what the usage pattern that you're going
to have and then you bind us and you say
okay I've created this is basically my
allocation and then I bind it to be
equal to that okay so having done this
this allocates the memory this passes
that down to be useful at the
renderscript level and now in your
renderscript code you can refer to
elements inside of this just as an array
so this is just as if you had done Oh
flakes equals malloc of something if you
were in C code which you're not so you
can't do a malloc okay so there is as we
said there's api's at both the SDK and
the native the renderscript level so on
the sdk side everything is in the
Android renderscript package and there's
not actually that many classes that you
need to get hold of and you can walk
through these pretty quickly but there's
sort of some basic block types that you
need to get used to
there's allocations like the stuff that
we just walked through there's types
that you should get used to there's
programs and we'll go over that in a
minute and then there's some rendering
set up stuff for actually initializing
stuff to start the scripts which is the
interesting part you want to talk about
programs yeah so programs the names that
we use our are Jarek names that are
using in graphics to talk about the 3d
pipelines so some of those names are a
little bit different when you use to
OpenGL but they are the same ideas so we
have four different types of programs we
have program vertex and program
fragments that are basically the
equivalent of vertex shaders and
fragment shaders in OpenGL at least
OpenGL es2 on the desktop you know any
version of OpenGL with shaders so the
program vertex its job is just to
calculate the position of every vertex
in the mesh so if you're just drawing a
rectangle you have four vertices and the
program vertex can at runtime modify the
shape of the of the rectangle by just
moving those vertices one by one and
that that is run on the GPU so it's very
efficient program fragment it's the same
idea except it's at the pixel level so
once once you have position the vertices
the GPU will rasterize the shape into a
series of pixels and the program
fragments job is to
I would put a color for each of the
pixels so usually this is where the
program fragment is where you do like
interesting stuff like a blur that's
where you put your texture that's where
you do color filtering all-defensive
visual effects that you've seen for
instance in games they'll done by the
program fragments mostly so if you're
familiar with vertex and fragment
shaders you can think of these things as
wrapping that functionality in addition
to the other functionality of actually
supplying values and telling it how to
how to actually supply the values that
the shaders are dependent upon so we'll
see some code later where we supply the
shader that this takes which is
straight-up GLSL in addition to binding
to constants that are then going to be
supplied to the shader it's the question
is do we generate two-bit code for the
shaders or do we use GLSL so the answer
is neither we have a pre-built shaders
for common use cases like if you just
want to texture something we wrote our
own GLSL shaders that you can use
directly without having to write it
otherwise you can supply your own GLSL
code something we'd like to try to do in
the future would be to use render script
code for shaders so you would use the
same language for shaders and programs
yeah it's just as well as a little other
functionality but you basically pass in
if you're writing a shader from scratch
you passing a string and that string
then gets compiled as part of the GPU a
GPU basically compiles it the same way
it would if you were doing it on you
know yes but but right now drivers do
not understand the render script so we
use GLSL we don't generate into a GL so
we you write to yourself why don't you
wait till we say some sample code you'll
see a little and two other programs so
the programs store is once you've
rasterized the shape and once you've
decided like for each pixel what the
color will be you have to store that
pixel onto the frame buffer or any
random target and this is basically
called also blending so this is where
you decide like whether or not you
should take into account the alpha value
of the pixel this is really simple and
you and you can't write custom program
stores and finally program raster this
is rarely used this is how you do
culling if you want to
hidden faces in the mesh or if you want
to use point sprites you know what one
sprites are that's the program I start
that you're going to use so the two
important ones are programmed vertex and
program fragment so one of the things
that just came up is whether you
actually write your own shaders in a lot
of cases you don't have to the sample
code that I'm gonna walk through later
whether there's a mix but one of the
applications I wrote doesn't use shaders
at all it just uses the pre-built ones
so if you use the builders for program
vertex fixed function or program
fragment fragment fixed function these
actually use generated shaders so you
don't have to deal with you know the
details of actually writing a shader a
lot of stuff is just gonna do something
simple like well I've got a matrix and I
have some vertices can you transform it
for me it turns out yes we know how to
do that we have shaders that know how to
do this simple stuff you can think of
the the fixed function programs as an
emulation layer for OpenGL es1
so if you're used to OpenGL es1 where
you could just do everything without
shaders then you can use that to do the
same thing if you used two OpenGL es2
you don't have to use those you can just
write your own shaders by hand this is
just a convenience and in some cases
maybe you actually want to write a
shader for one of these levels but not
the other so there's another example
we'll probably see where there is a
vertex shader because it's doing
something in particular with this custom
data structure that we have but for the
fragment shader all we want to do is
texture map each pixel well we can use
the fixed function for that side of it
okay so then there's the other part of
the SDK API so there's the the things
that are pre-existing you can poke
through the SDK and see all the classes
for type in element and allocation and
stuff the other part is the part that's
dynamically generated through the
compilation process and this is the one
that takes a look at the fields and the
functions that you expose in your render
script code and exposes them as wrapper
functions on the sdk side so that you
can actually call in to those functions
and actually compile your code that
would be nice
so we'll we'll see some of these for the
render script code that we wrote and
basically it's it's those two types of
things you have fields and you have
functions and they get exposed as fields
that you can set
get and functions that you can call with
arbitrary parameters okay so here are
some examples of that on the
renderscript code we have a couple of
simple variables here here's a boolean
and here's a simple function set new num
flakes and these are taken from directly
from my code and if you're calling those
from the SDK code this one is simply
going to call a set function for the
initial field so it says okay scripts
dot set draw FPS this is a wrapper
function that was created for you at
compile time and then you pass in a
boolean value and it magically sets it
on the boolean underneath this one is
going to call this function down there
in this case I didn't want to just set
the field I actually wanted to perform
some functionality at the same time so I
created a field to set an internal value
and then this API was automatically
generated for me given this method
description so I pass in an integer
value and it does the right thing and
then there's a render script API and
there's various parts of this there's
too much of it to go over I just wanted
to give sort of a sampling of the types
of things you can find in that API and
then we'll see a bunch of it in the
sample code that we're going to crawl
through so there's types that you would
be used to and maybe some that you
wouldn't
so there's floats and there's ants and
there's long and there's shorts and
bytes and all that good stuff that
you're used to from C there's also
vector versions of these and these are
very important especially as you get
into matrix and graphics calculations
and compute calculations where maybe
you've got these two rgba values that
you want to modulate together well you
can actually just multiply to float
fours together it'll do the vector
operation yeah and we'll see a good
example of how vectors can simplify your
code and there's a lot of variations of
the same kind of method in the same kind
of type because they all take you know
different variations of these vector
types so you can have a multiplication
that that operates on two float twos or
to float threes so there's a lot of
repetitiveness in there but not actually
that much functionality is just a lot of
good sort of solid core graphics and
compute functionality also in types
obviously you want matrices if you're
dealing with graphics so we have 2 by 2
3 by 3 and 4 by 4 matrices
you have some core functionality you've
got a bunch of this stuff to go along
with the matrix types we might as well
be able to multiply the matrices or set
a rotation or concatenate a translation
all that stuff exists clamp
functionality compute functions so
you've got all the basic trig stuff view
it expects a bunch of the math stuff
power operations Exponential's I don't
know there's there's a bunch of stuff it
was way too much to belabor by putting
it on slides and then on the graphics
side I put in some sample functions
you've got some very basic text stuff so
you can draw a text train onto the
screen draw a text string onto the
screen you can set the the fonts in the
font color you can draw a quad and you
can clear color but what you're going to
end up doing mostly if you want
performant graphics is actually drawing
a mesh so that I think the sample that I
use no it actually does do a draw mesh
draw quad is there for simple use cases
if you're just drawing a square drawing
a rectangle go ahead and draw call draw
quad but if you actually want
high-performance graphics you want to
probably issue more vertices than that
single quad at one time and for that you
would create a mesh and then you would
call draw mesh and it'll whip through
all of those at the same time this is
not a constraint of renderscript this is
just how GPUs work the more vertices you
stuff in at once the happier they are
you want to keep your GPU happy links to
more information Jason Samms is the guy
behind a lot of the renderscript stuff
and he wrote a part 1 and part 2 article
on render script I think he's also
working on one on memory allocation
stuff so that'll probably be out
sometime soon so on the Android
developer blog you can do a search for
his name and find those the article that
I wrote to sort of give the the higher
level view of how to think about Android
rendering is on my blog graphics geek at
blogspot.com and there's the Android SDK
samples we're gonna see some of those
very soon but you should just use the
ADK
and open up the samples directly you can
build and run them on a 3.0 device or
3.1 to
now for the code there's a question the
symbols come with API level 11
so Android 3.0 all right now do you want
to run the demo first so that they you
know yeah so this is a beautiful demo
that that wrote and I'm actually
really proud of him because UV shows
balls on the screen and you did
something different this time it's
awesome after like five or six years
alright so I wrote this is actually an
SDK application somebody asked for a
simple benchmarking application they
just wanted an animation running on the
screen while they did some background
processing and so they wanted something
that would show obvious performance
hiccups as they happen
so I wrote this with SDK code we can
walk through this if you really want to
see SDK code but I'm basically drawing
bitmaps I'm setting a translation and a
rotation on these things and then just
calling canvas drawbitmap and you can
add a bunch of these little droid flakes
on the screen and then you can see okay
so this is hardware accelerator this is
with the stuff that we did in 3.0 to
speed up graphics you could turn that on
off just for laughs and then there's a
frame counter over here so we're getting
14 frames a second versus 40 52 we could
pop this up take it out of hardware and
suffer okay anyway that was the SDK
application I want to do something
simple a similar with render script to
see what it would take so I ran it again
so then I have this one roughly the same
the frame counter works a little bit
differently I'm just using render
scripts internal frame counter here to
see what frame rate we're getting there
you're actually going to see very
similar performance characteristics
I must have changed the code I did one
of my last edits I was cleaning up the
code right before we came up here I must
have changed the blending mode or
something that's unfortunate anyway so
all of these have an opaque black
background they they used to be
transparent just
an hour ago this actually gives a very
similar framerate to the hardware
accelerated canvas version because
essentially we're Phil rate limited we
end up just bottle necking at the GPU on
the STK side we're pre scaling into
bitmaps and then we're uploading the
bitmaps into textures and letting the
GPU rock on it here we're basically
doing the same thing we're rendering
meshes which are touched texture mapped
quads and you know we can shove down
roughly the same number down there so
it's nice that we got that performance
from the SDK there are other things Roma
is going to show an example later where
the performance benefits of render
script are a little more obvious in some
cases and then in addition you could
have 3d functionality which I didn't
happen to explore on this one render
script it renders on the GPU yeah so
rendering is on the GPU for computations
it's on the CPU but we plan on adding
support for the GPU so potentially this
could run entirely on the GPU including
the logic of the application yeah
actually if if I had a non GPU version
of the render scripts version of the
application it would be even faster
because it wouldn't run at all so
infinitely fast if you don't do anything
that that's what's nice about trying to
scripting again we'll see an example
after this one about compute if you
write your code with render script as
you get more cores because manufacturers
add more cores in the devices your stuff
will get faster and you don't have
anything to do which is always nice I
want one core per droid so let's walk
through some render script code version
of the API this is the package name this
is important because we need to reflect
it into the correct package so that you
call appropriately from your SDK code
this is a header file of render script
itself so you can actually get a handle
on the functions that you're going to
call and render script this is the data
structure that I saw an abbreviated
version I put in a BRE be a diversion in
one of the slides so this is going to
hold information about a particular
droid
so I'd like to know the position notice
it's a float too so this is going to
have a dot X and a dot Y field inside of
it
I've got speed I've got scale I've got
rotation Y and rotation speed so this
not only holds where it is and how its
rotated and how large it is but it also
holds the speed of it because for every
frame and I would say okay how much time
is elapsed and how far should I move
this thing given its current speed and
how much should I rotate it given its
current rotation speed okay we have a
mesh object which I'm going to allocate
memory for and populate at the SDK side
we'll see that later we have two
programs that I'm going to use there's
the vertex program vertex and the
program fragment again I'm going to
allocate well I'm going to initialize
those at the SDK side and then set them
on that side and then we bind them in
the inner loop as we're actually walking
through the route function we have some
simple fields that I use throughout here
so I've got the start time which I use
for tracking frames per second I've got
pre time which I use for calculating the
inter frame delay so that I know how far
to move and and how much to rotate these
droid flakes I'd like to know the number
of flakes that I have on the screen at
any one time we can actually check if we
have an array which we which we
allocated through one of these
allocations that we'll see we can check
the dimension and then just walk that
array by using the dimension dynamically
however the way that I use that arrays I
actually allocate potentially more than
I more droid flakes than I are actually
present on the screen in a given time so
this is a temporary variable that I use
to know how far to iterate the screen
width and screen height I use
occasionally so I pass them down and in
the init function this is an integer
values for the size of the bitmap I use
that in conjunction with the scaling
size to know how large to draw this
thing there's an option to to trace the
frames per second that we're getting at
any given time so this is a boolean
variable that holds whether we're
actually tracing that out and this is
the frames counter which is used again
to track the frames per second that
we're getting so let's go down I mean a
lot of this code should look like really
approach
right it's C ok well this function calls
that function there well it needs a
forward reference to it up there before
it can refer to it pretty
straightforward ok the init script is
called from SDK we'll see that later I
want to pass in the size the width and
the height of the screen I also want to
pass in how many droid flakes were
actually starting with so that I can
initialize things correctly so I set
these internal variables here I call
this other helper function down here
with the initial number of droid flakes
and I set the pre is what the inner
frame delay is going to use as it
calculates movement along the way ok
this function is called at startup time
it's also called when I hit the more or
the less button to add or subtract
flakes on the screen it's going to at
the SDK side say ok well this is the new
number of flakes so you're going to have
it'll pass that number down here and
then we basically initialize all the
flakes that were either all the flakes
that we're adding to the array or if
we're subtracting if we're displaying
less now that we used to then we don't
need to initialize anything we just need
to set the marker earlier in the array
so as we initialize we say ok well if
I'm actually adding flakes then let's
walk through all the new flakes that
we're adding and for each one of those
so I'll just get a simple reference to
the current flake so you can see I'm
walking this through it's just like a
normal array the only weird thing about
the array was that I allocated it
somewhere else right it migrated to my
code it didn't actually start there but
otherwise the way to a way I refer to it
is just the same as I would in any other
C code so once I've got a pointer that
then I can say ok I set the position so
this is a float to object so I say ok
refer to the dot X value of that and
randomize that based on the screen width
so I'm going to position this flake
summary between 0 and the width of the
screen same thing for y I'm going to
position at 0 between 0 and the height
of the screen the speed I'm just going
to set to this random value it's going
to be at least 50 to 200 and what that
does this is you know a value that I
calculated like all great engineering
values just by you know setting some
values and seeing what worked but
basically this is how far it's going to
move per second and then in the inner
loop I calculate the elapsed fractions
and multiply it time the speed
scale is going to be somewhere between
point one and point seven of the initial
size of the bitmap so I had this initial
size of the droid flakes and they look a
little bit better if they're somewhat
smaller than that so we have a
randomized scale factor we set the
rotation value to be some random angle
between 0 and 360 and then we set a
rotation speed between negative 45 and
positive 45 hopefully all this code is
very straightforward and I shouldn't
have spent all that time explaining
every line this is if I'm calculating
frames per second then I will call this
function along the way and say okay well
it is currently this is one of the core
renderscript functions if you want to
get the current time which is kind of
important in animations okay actually if
you look at the name of the function so
here we're calling RS update Millis R
stands for render script if you use one
of the graphics function you will see
it's called rsg draw text for instance
so we use different prefixes depending
on what kind of function you are using
so all right Milly's that will return a
millisecond value and you compare that
to the previous time so we're gonna
create a delta time here and then if
we've elapsed a second since the last
time this is kind of a technique that I
use when I'm doing benchmarking your
frames per second because if you go
every single frame the numbers gonna
flash so much on the screen you're not
going to know what's going on so every
second I go ahead and say okay now how
much of I how many frames have elapsed
since the last second so we'll go ahead
and calculate the elapsed seconds we
calculate the frames per second and then
we just trace it out to the command line
in the SDK version I actually output it
onto the screen that's a little more
tedious and renderscript because there's
not string manipulation functions so you
can output a character string but
actually creating that string takes a
little bit more effort it's probably
easier to do with the SDK so I didn't
push it down I decided you know what
Tracy knew the command line show is
awesome and then I reset the frame so
that I can calculate it again later
these goes to the logcat yeah exactly so
how's the speed am I talking like too
fast or too slow okay good all right
what do you want him to shut up
that works too
I didn't propose that as an option okay
so this is the inner loop this is the
function that's going to get called as
soon as you bind to it as the root scrip
from the SDK level renderscript will
just start calling it and it'll call it
until you you tell it to quit root is a
built-in name yeah yeah it's called root
renderscript is still evolving the IDs
that you will eventually be able to
build some sort of a scene graph of
scripts so the root function is the root
of your sin graph so that's the main
entry point in you'll be able to invoke
other scripts in fact there's another
built-in function in knit which would
automatically be called init with no
args and that would be called before
your script actually started at
initialization time of this particular
application I wanted to pass in
parameters so I didn't bother to
implement that one I implemented my own
and called it directly from the SDK side
okay so every time so this is going to
get called once per frame so this is
everything we need to do to display one
frame of the animation we're going to
clear to a background of opaque black so
that's the Alpha value RGB of black
we're going to bind the program and the
program vertex and the program fragments
this is saying okay for everything that
gets rendered here these are the
programs these are the shaders that
you're going to use so in this
particular example we use only one
program vertex in one program fragment
but you should go look at the live
wallpapers did draw a background texture
than the draw for instance they're stars
and then they draw something else every
time they use different program
fragments or program vertices depending
on what they are doing right so in that
case they would probably do binds of the
appropriate shaders rendering operations
and then bind and then rendering
operations because these programs are
going to apply to whatever rendering
operations are just about to be called
okay so this is some timing information
because in the loop here I'm going to
walk through the array of droid flakes
and calculate where everything needs to
be moved and rotated to so we'll cat
will say okay what time is it now get
the Delta time calculate the seconds and
then we actually start our loop so we're
going to do a simple iteration up to the
number of current flakes that we have
we'll get a
reference to the current flake in the
array we're going to calculate the new
position so we're going to take its
current position and add in the speed
time the number of seconds so this is
the speed per second this is the number
of seconds we added to the current
position voila it moves yeah so flake
endures court is a structure that we
declared at the beginning right so
there's a forward declaration here and
then there's the Declaration of the
structure at the end so if like T and
then the array is of type flake T very
much next C and you shall not use to see
well it's a good reason to around C it's
actually really nice C I mean that's
opposed to the okay so we calculate our
Y position rotation is very similar
calculate rotation Y as adding in the
current rotation to the rotation speed
times the elapsed seconds so now I can
actually take that information of where
this thing is and what angle it's going
to be rotated to and I can create a
matrix and pass that in before I
actually render my quad so I declare a
local variable here we've got a trans
matrix we're gonna load in we're gonna
load in the identity we're going to
actually that Lexus code that I should
remove so ignore that one because I'm
gonna immediately load in a translation
so we load in a translation based on its
current exposition I'm doing an offset
of the width and height so that I
actually rotate around the center of the
snowflake because rotating around the
corner looks goofy
so we basically back it off a little bit
and then do our scale and our rotate so
we're gonna scale and rotate around the
center and then we're gonna translate
for and then we're gonna translate given
the the width and the height of the
droid again these are just it's like if
you've ever done any graphics rotation
stuff you always have to factor in well
what's the pivot point around which you
rotate yeah and you always get it wrong
every single time yes and you just you
just bang on the code enough where
you're like oh yeah that's right yeah
yeah the first time I did the OpenGL
stuff I was at CERN working with Chet
and those guys because they know how to
do OpenGL Mike how do you guys figure it
out every time they're like I don't know
we don't like we just tweak with the
numbers and the awesome thing about
graphics is you see it on the screen
it's wrong okay
I don't know what data database people
do to get their programs right okay and
then we actually upload this so this is
a render script call RSG program vertex
load mode model matrix the trans matrix
that we just created so that'll
basically push it up to be used for
future rendering operations which are
here is the only rendering operation
here besides the clear color so we say
draw mesh of flake quad and we'll see
what flake quad is in the SDK code later
basically created and populated that on
the STK side and it's just going to draw
the same thing every single time so the
reason that we get flakes in different
positions is well we draw the same quad
but before we draw it we tell the matrix
where to put it and how to rotate it and
how to scale it so then we get them all
position independently so even though
it's actually the same rectangle drawn
over and over again each time is drawn
with a different matrix which gives us
the effect that we want it's worth
pointing out that this would be more
efficient if I actually used a more
complicated mesh and a more complicated
data structure and a vertex shader to
actually be able to render many flakes
in one simple rendering operation as it
is I'm doing one quad at a time not
terribly efficient but for demo purposes
certainly did the trick yeah a good
example of that if you could look at the
source code of the galaxy wallpaper so
we use twelve thousand stars and each
star is a position that's independent of
the other stars but it's done with the
one drawing call it's just one giant
mesh that we draw in one call all right
and then if I'm drawing the stats you
know based on that local on the boolean
up above then I call that function and I
return one this is my favorite part of
all of render scripts you return a
number and that number basically says
how long it should take before calling
me again this determines your frame rate
in render script okay so by returning
one year I'm basically saying okay I'd
like to be called every millisecond
however it's going to be capped at the
effective frame rate so we get 60 frames
a second because render script knows
that there's no reason to call me any
more often than the current refresh rate
of the screen so it's going to try to
call me a 1 but it's really going to
back off and say you know what we're not
ready to sync the screen yet anyway so
we'll just wait so if this were actual
acting as a returned one then I would be
getting a thousand frames for a second
you can see the stats on the screen say
that I'm getting more like 60 frames a
second there's another magic value if
you return zero that means that you
don't want to run again for instance if
you for some reason if you want to
render on screen they don't use the GPU
anymore your return zero and then from
the the dalvik side you can tell run the
script to start again
okay so that was render scripts and then
we'll see there's three files that I had
on the SDK side there's flaky which is
the main application we're not much
interesting happens we have an on create
I think you probably know what that is
so the content view I have a simple
layout that's got a linear layout that
basically has an area for the buttons in
the checkbox and then and then we're
gonna stuff the view in a linear layout
below that so we do let me try to get
this on the screen it might work better
alright so we're going to create one of
these flaky view objects which we'll see
in a minute that's the second of three
files that has this functionality we're
going to get a reference to the
container where we're going to put this
thing we're going to add our view into
that so we've just stuffed the
renderscript view in below the controls
that are going to go in the application
we're going to then add some actions
here so when they click on the show FPS
checkbox we're going to toggle whether
or not we're spewing
stuff into the log there's more and
there's less buttons and those are going
to set up listeners and call a function
on the view class which is going to end
up eventually calling in to render
script we've got a flaky view flaky view
another simple class that basically
creates this render script GL object
that we wanted and the render object and
that's where all the actual logic of
initialization setup goes created
surface changed oh there's a print line
because everybody needs that in their
shipping application this is where we
actually create this thing we get a
surface config in that we create the
render script GL object we set the
surface on it then we create the the
flaky RS object this is the thing that
is actually going to talk to the scripts
it's going to create and communicate
with the scripts and then we initialize
it with important information like how
large are we so this is this is the
class that sort of has the information
about the window the surface that we're
going to need and then the other one is
all specifically about renderscript this
is still setup stuff you'll see the
point at which it'll actually start
executing that's in the other file the
show FPS these are the listeners that
are going to be called by the buttons
these are basically just wrappers around
function of the functionality that's in
the final class which is here
okay so flaky RS a couple internal
pointers that we're going to need
especially this one the missus field we
have this is a field that was generated
for us during the compilation process
this is basically a reference to our
array we're going to create an
allocation and then bind it to this
which is basically going to push that
allocation down to the render script
level where we can start actually
manipulating the Droid Flakes program
vertex and the program vertex
program vertex and the program fragment
are the the vertex and fragment shader
information that we're going to render
with numb flakes we're gonna start out
with 60 and then we're gonna increment
that and decrement that along the way
this is a reference to the actual script
we're going to need that for calling in
to render script functionality okay this
init function gets called by the view
class that we saw earlier we'll send a
couple of internal frames fields here
we're gonna create the script and say
okay I want to create the new script
here again this has generated anything
with these ugly underscores here that's
generated code that you're calling in to
so we're going to create this with
references to the resources and the
render script object and the actual
render script file that we created so
flaky dot RS was the name of the render
script file that we saw earlier okay M
flakes as I said is a reference to the
array of objects this is actually the
allocation that were created creating so
this does the allocation for us it says
okay given the script object given this
generated API and given the number of
flakes
I want to create give me an allocation
with the following usage pattern and
then bind the flake so we're creating an
allocation and we're passing it down to
render script this is what makes it
available with the render script level
in this variable for it to then refer to
as it walks through its loop okay we're
gonna load a bitmap normal way you load
a bitmap we're going to decode the
resource I'd like to know the width and
the height because I want to push those
down to the native level and I do that
by calling these generated functions
here set droid W Android H with the
width and height of bitmap
it's the fields they get wrapped by
setters and getters yep yeah there's I
mean there's two things that get wrapped
there's fields get wrapped as setters
and getters and there's functions and
get wrapped by other functions okay
there are different ways that I could
have drawn this as I said it probably
would have been more optimal to create a
more complex mesh and we could have also
populated this at the renderscript level
but
I wanted to show this instead I use a
simple triangle mesh builder which is
basically going to create the quad
so everything in GL if you've done any
graphics program you know everything's a
triangle unless it's a pointer or a line
right there is no quad there's only two
triangles that happen to sit next to
each other so you can create and and
there's there's different kinds of quads
there's different kinds of triangles you
can have individual triangles you can
have triangle strip which is basically
triangles that share edges and you can
have a triangle fan another arrangement
of triangles that share edges so we're
going to create our triangle mesh we're
going to basically walk through and set
texture and vertex information for every
one of these points so there's going to
be six total points because they're
going to be two individual triangles
something like that oh no there's four
points right so we're setting up four
vertices and then we're going to set up
the edges the individual triangles are
going to refer to those vertices that we
set up right so we're going to set the
texture information that's basically
saying okay I want the upper left of the
bitmap to refer to the upper left of the
quad
I want the right hand point of the
bitmap to refer to the right-hand point
of the quad and so on we set up the way
the triangles are arranged based on
these vertices then we say okay I want
to create a mesh from this mesh builder
that I just built up and then we're
gonna push it down so again it's just
like we did with the allocation with the
flakes above we sort of set up the data
structure here and then we push it down
by saying okay now set the mesh there
this is the guy that actually got issued
in the call to rsg draw mesh right so
the only thing he did with it at random
script level was to actually draw the
thing everything else happened at the
SDK level we set up the program vertex
I'm just using fixed functions here I'm
not doing anything too complicated I'm
basically transforming these things and
projecting them onto the screen and even
the projection is very easy because I
just want an orthographic projection to
be the size of the window
so there's utility functions for all of
this stuff in render script and I was
happy to use them
a little bit so you can actually see the
code okay so we call the fixed function
builder to create a builder for us and
we're going to go ahead and just create
this thing there's nothing complicated
going on here we are going to create a
projection matrix and set this so if we
can walk through here we want this to be
we basically want to populate the
constants internally in the program
vertex it's going to create a shader
right it's got these these pre-built
shaders there and it's going to expect
information about the variables that are
provided to it for instance it would
love to know what matrix you want to use
when you project this onto the screen
because that's going to go into the
calculations that figure out where to
put the vertex in space right so we're
basically saying okay I want to populate
the constants with the following
projection matrix which is going to be
an orthographic you know just straight
on 2d projection if you're doing 3d
programming you would do something much
more interesting and there's other
builder functions in there to do that
and then we're setting the program
Protex than the render script code like
that okay hopefully this is getting a
little boring now you're like yeah yeah
okay generated code set underscore blah
blah blah good okay we're gonna bind
sorry no this is the fragment code
something very similar except for a
fragment shader again I was happy to use
the fixed function one because I'm not
doing anything complicated all I want to
do is have a texture map quad at the
native level I'm using decal mode
because that basically takes this nicely
transparent back texture and applies it
as a decal on the quad and usually I get
a transparent background quad as a
result I'm not exactly sure what
happened let's see give it the formats
we go ahead and create the program
fragments we bind the texture so we
associate that bitmap that we created
earlier with the texture that this that
the shader inside the the program
fragment is going to use bind a sampler
the sampler is basically the the
blending no it's the it's how do we how
do we you fetch data from the texture so
if you want when you resize a picture
you can apply a nice filtering to make
it look better when you zoom in and out
which is what Chet is doing here so
we can use one of the built anyone lien
they are filtering is the one that you
want it looks good
so it's gonna do bilinear filtering
across the bitmap it's also going to
create MIT Maps along the way it looks a
lot better the initial version of this
didn't use I think it just used the
default sampler and there was all kinds
of flickery artifacts because scaling on
the fly without doing any filtering
doesn't look very good and then we set
the program fragments buying the program
store just using I wanted to do just one
of the canonical ones there I didn't
need to create anything custom and this
is where the initialization and starting
at the script happens so first we invoke
this method with the width and the
height and the num flakes that does then
that initialization step that we saw in
the render script code and then finally
we bind the route script so this is a
render script call saying I want this
guy to be the root of my application
that runs and after we bind that it
starts out that thread and life starts
okay so we're going to write to a very
simple application that just turns color
picture into a grayscale picture so it's
it's the same thing that's in the SDK
but I'll walk you through it as I'm
writing it and hopefully I can still
write it so we're gonna create a new
Android project so there's nothing
specific about render script so you just
target Android 3.0 or more for those of
you cons in the back I just selected the
the target platform yeah let's change
the mix that's a good idea should have
thought about that it's smart let's see
just creating the project
now am I supposed to type on here now
okay can you hear me
okay perfect so we're just going to
create the Android project so I'm going
to specify a package name and that
example that Android that SF that's that
SF that would be good and that's all so
again nothing specific about a
renderscript project I'm just going to
add a new drawable in my project because
I want to turn the picture into into a
grayscale image so I'm just going to add
a drawable there's no dpi resource
folder that's usually why you want to
put images that won't be resized based
on the density of the device and I have
a photo right here which is pretty and
that's it and now you can start writing
the code so we're going to start with a
very simple activity and because we're
not going to do any graphics I don't
need to create an art surface view I'm
just going to use an image view to
display the bitmap the resulting bitmap
so we just create a simple image view
and can you see the code I'm typing or
do you want me to zoom in in the back
well assuming anywhere cuz you you're
not responding just setting up the type
of scaling we want on the image we will
just Center the image on screen Center
crop and I said this image is the
content you have negativity okay now
we're going to write the actual function
so draw a grayscale we're going to pass
the image and the photo I want to turn
into grayscale create the function here
we go
so now we can start doing the fun part
the first step we're going to load our
bitmap so we can actually process it I'm
going to use a bitmap factory we're
going to decode that resource
and that's the photo so what's nice is
that renderscript knows about bitmaps I
would as you will see so we have a
bitmap I want to quit bees to be there
clips
be there we go okay now we want to
create our render scripts haven't
created the script itself yet but I'm
just going to set up some of the
environment so we need to create a
render script context and you can see
here I can create a render script a
normal render script context or I could
create a render script GL I don't care
about rendering so I'm just going to
create a render script context that
creates and that render script context
is important because you pass it to
pretty much every method in the render
script API now what we want to do is we
have a source bitmap and basically we
want to copy the content into an output
bitmap and in the middle we want to do
the filtering so I'm going to need the
second bitmap and I want that second
bitmap to have exactly the same
characteristic as the first bitmap so
I'm just going to create a bitmap with
the width and the height of the original
bitmap so those are all like standard
Android API so let's go create bitmap
there we go and render script can work
only with allocations so we need to
create allocations from those bitmaps
and we have helper methods to do that
let me rename that to in there we go so
I'm going to create an allocation from
the input bitmap and we have a create
from bitmap method so I pass my render
script context and the original bitmap
and that will be my in allocation and we
also need an allocation for the output
bitmap so we are going to read from the
input allocation and just output into
the output application and let's rewrite
my code sorry
so in the output allocation will have
the same characteristics as the input
allocation so we want the same size in
the same type so once again there's a
helper method for that so we can create
an allocation from create typed so I
passed the RS the Rhenish context and I
get the type from a original allocation
so now I have two allocations that are
exactly the same except the first one
oops
except the first one already has content
the content is what's in the bitmap the
second one is empty because I have not
copied anything in it and then the next
step will be to create the actual script
itself bind the allocations and run the
script so now we need to write the
render script so I'm just going to
create a new render script file let's
see gray @ RS we need to specify and to
specify the version number of the
language that we are using we need to
specify pragma the Java package name for
the generate source code so come that
example that Android @ SF and I will
have a filter function that will call
later that will do all the work and I
need to have the data that we created on
the Java side so we're going to use the
NARS allocation that contains the input
bitmap in our occasion that contains the
output bitmap note here that are not
creating a custom type so in the inject
example we create a new flag type so we
create a struct here I don't really care
because I it's easy to understand what's
in the bitmap location is just a bunch
of pixels so I could create a new
structure with the right blue and green
channel but here I won't even bother
and we'll also need a script now on the
Java side all we have to do is bind all
that stuff so I can create a menu script
I pass the render script context to
resources and the script source code so
as you can see I'm creating a new
instance sorry for the default in the
back I'm creating a new instance of the
classical script C and
SCOR gray it was automatically created
as soon as I started typing in that RS
file just created yes let me add a bunch
of empty lines there you go
sorry about that we're gonna keep a
reference to the script
stupid eclipse what is it doing
I have Oh like I said I'm the I'm not an
eclipse user okay so now from that
script we want to bind all our data so
I'm gonna set the in allocation to my
input allocation I'm going to set my
output allocation to my output
allocation it's really hard and I'm
gonna set the script variable to the
script itself and you understand why
then what we want to do is invoke the
filter function that will do all the
work and and after the filter version is
invoked we'll have all the processed
data inside the output allocation so
then we want to take the output
allocation and copy its contents into
our output bitmap
yeah so scrip see gray was jarred as
soon as I created that new file in the
project yes yes well we can take a look
afterwards if you want and then finally
I want to display my image on on on
screen so on the driver side pretty
simple we create a couple bitmaps to
create allocations for renderscript
we set up the script we invoke the
filter of function and then we copy the
result into an actual bitmap and then if
we go back to render script itself so I
created a script object here and that's
because I want to run my processing on
multiple cores so I want to
automatically split the load so for each
pixel can be processed individually on
on a different car and to do that we're
going to use the eyes for each function
and the arts for each function takes a
script as an input and I just need my
little cheat sheet here so RS I'm trying
not to use it but the other of the
parameters sometimes how to remember so
we pass the script we pass the data the
input data the output data and that's
enough set inside the input data so when
I write that line we're going to invoke
a script so the script that we're gonna
invoke here is actually this script here
we're gonna invoke the root function for
every element of the input allocation
we're gonna try to run it on an
available core so here on the forage is
yapper core well actually it's forage
it's per element inside the allocation
render script will automatically spread
spread the processing on on two cores so
here we have a bitmap and we're going to
put one pixel on core number one one
pixel on core number two when one of
them is done we send another pixel to
that core and so on so we're going to
just split the work on the only two
cores zero is the offset inside the
input education so that you don't have
to process everything I'm creating my
root function so a small difference is
that when you create your root function
you can have no parameters this is
usually what you do but when you use
forage you can actually
get parameters so my locations I know is
made of every element is 4 bytes alpha
red green blue so I'm gonna get a
pointer to a Utah 4 so a vector of bytes
and that's my input data we're going to
output it inside a you shop for so
that's the output allocation that has
the same structure and then you get
other variables that you have to use so
you get x and y so as the voyage goes
through the education it will
automatically increment the x and y so
if you need the positions within the
education you can get you can get those
here and there's an extra one I think I
need the constant for it so I don't
remember what that one does but I've
never used it so let's forget about it
and now if we want to convert a pixel
into to gray all we have to do is take
the red green and blue components we
just have to multiply them by some magic
values and then we take the resulting
value in we apply it as the right green
and blue component so you read the way
you would do that in Java for instance
you have an int that your pixel you
first have to split the int into the
four different bytes you take the bytes
you do the offense multiplications and
then you recreate the pixel here because
we work with vectors we can do something
even better
so I'm going to create a special vector
float 3 and I explain what it does so
it's a vector of 3 floating point values
and those are the values you want to use
to multiplied your pixel colors with so
if I have a pixel that comes from the
original image I'm going to multiply the
right component by 0.3 the green
component by 0.6 and the blue component
by 0.1 and the sum of those values will
become the grayscale value turns out
that what I just described is the dot
product operation on vectors so the
entire implementation is the following
we get our pics off on the input
allocation and that color fades so what
this does is we get a bunch of bytes and
instead we want to get a vector of
floating values of floating point values
because it's better usually when you do
graphics operations to work on floating
points to avoid losing Precision's
then we want to create the graphics all
so float 3 results is simply the dot
product of the RGB values of the input
pixel and our fancy vector that we just
described so here again in Java instead
of that one line of code you would have
to do a lot of bit shifting and or and
floating port versions and conversions
and here it's all done for you in one
line actually you have that code in your
old object right I wrote the same
algorithm in Java and I'll show you the
difference and then when you're done you
just have to repack the value back to
there you go
we pack the value back from floats to 2
bytes
why did I do V out yes the output
allocation is not constant okay and so
that should work so let's try to run the
code
Chris run as Android application there
we go
it's in black and white yes the original
image ministry with your enjoyment also
happens to be black right but that's
beside yeah that is the original image
it's standard standard technique for
desaturation
here there is not a single way to turn
color into black-and-white and
photographers usually are are really
obnoxious because they each have their
own way of doing it depending on image
but this is this is just a standard way
of doing it gives you something that
kind of looks good but it's not great if
you do a web search on desaturation or
grayscale you will come up with values
that look an awful lot like that there
is it to remember because the Sun is one
yes so let me show you now the the
original version that I wrote using the
Java language so in this case X will be
the the index of the pixel inside the
giant array and Y will be 0 but the X&amp;amp;Y
they are not don't see them as a like
screen coordinates they're just indices
within a Multi multi dimensional array
it turns out the allocation I pass here
is just one dimension so the Y doesn't
matter but you could describe your
you're right so that you get also why
it's a little bit awkward and actually
if I were to write that using Ice Cream
Sandwich the code would become this
because and also here we go
so in ice cream sandwich we also
generate an arse for each java method
that you can invoke and does all that
crap for you so it will get even easier
yes so the original java language code
that i have here there we go so that is
the java function that was doing the
same thing we just did here so you know
we go through the array we get each
pixel we have to get the individual
channels
some bit magic we convert them to float
some divisions and then we have to
create a pixel again out of it you could
do it on one line of code and it would
be really really ugly yes really hard to
read and and and also that version does
not run on multiple cores so that
version if you have to make it
multi-threaded you know it's even more
code that you have to write the render
script version because we use vectors it
can automatically use the new
instruction set on arm CPUs to process
for four pixels at a time it has a lot
of advantages and actually you can see
around the code I have a little bit of
profiling code so the java version of
the of this this filter runs in about
400 milliseconds the renderscript
version runs in runs in 0.02
milliseconds so it's like you know a
thousand times faster and it's less code
to write and it's easier to understand
so it's pretty nice and also next you
know next year when we get to tablet we
don't know for a 24 course whatever it
will go even faster without changing the
code no the the way it works is the
allocation nose has a type the type
tells you how many elements you have and
so it will send one element at a time to
a different core yeah it just happens
that you know the map to buy through
pixels but you could do that with a
sound processing like on a sound frame
or simple whatever all you guys do it
really depends on the elements you
describe in the case of the snowflakes
that Chad showed you know each yeah it's
really it's data you the processing unit
would be a snowflake anyway that's that
wraps it up I think I think so we have
time for questions yes you can have more
than one rat escape because you can
create multiple renderscript context or
you can swap when you bind the route
script you can swap them and in this
case I didn't even bind the route script
address invoke functions on them you can
also have visual scripts that invoke
each other or that include each other
can a renderscript Colonel come you get
to be the other one yes I believe they
can invoke the can you talk other
scripts you can pass data as long as it
was educated before so there's a there's
an example in the SDK called balls which
shows balls and that consists of a
couple of scripts so we can take a look
at the project here so you got the SDK
side here and then you have these three
scripts yes oh well let me show you
first the balls were talking about
so it's about a thousand 90 called
dynamic particles that react to the
accelerometer and they all interact with
each other so we run 910 and 100 physics
computations on the two cores
automatically it's also interacting with
the touch events on the screen so okay
so on the left here you see the three
files that are interacting with the
scripts on the SDK side and then there
renderscript side you've got this is a
really tiny one that just declares a
couple of data structures that are going
to be become allocations that get
populated in the SDK side you've got the
main script here which actually does the
rendering but then it's pawns off the
work of actually calculating the physics
to a separate script entirely so it says
okay well this script is going to be
invoked RS for each so it's going to
call the root function of this script
from that other script just like we we
saw in romance example except these are
two completely different scripts
interacting that header file was created
you would create that there's standard
render script header files that you
include just get handles to the
functions I also wanted to show some of
the generated code so if we go back to
the droid flakes example I can show you
some of the data structures that were
created for ya flaky flaky was the one
what's that
yeah yeah so we can see for instance
this was created from the flake data
structure the data structure that
basically had the float too for the
position the speed scale all these
things that you can see this is the
generated code that was created at
compile time so if you call the dot item
API inside of this thing it will return
a data structure that's basically an
exact mirror of what you created on the
render script side and here's some of
the element creation stuff that you
don't have to do if you allow render
script compilation to do it for you
so it can create the element
automatically this is sort of like the
code that I walk through on the slides
except it's done for you right so it
creates a strap ER stuff for you and
then if I call the constructor of script
field flake which is down here then
it'll basically call create element for
me so all I say is okay here's the
script here's this constructor that you
handily created for me and here's how
many of these flakes I want to create
and then it populates a couple of
internal variables and then calls that
create element thing that walks through
and actually manually creates the
element and initializes it and then you
get the type in the allocation
everything created for you I think that
was the question about the generated
code this is sort of I mean there's more
stuff in here oh here's one of the set
functions that you would call so you can
also use those generated function if you
need to set one element and said you're
right there's there's a method that
takes an index and you can modify values
from the Java side you don't have to do
it on the render script side also on the
render script said you can modify the
allocation and if you want to read the
result from Java there's a way to
synchronize the data between the two so
it goes both ways
handy links Android developer blog as I
said Jason Sam's two articles and
probably a third one sometime soon
Rama's blog at curious creature comm and
my blog at chat chat blog spot.com
and what Oh amateur is typing up these
slides
honestly fire these people all right
areas creature dot yes sir Oh vlogs
that's a good point yeah this is
actually a link to my humor blog which
is entirely different he talks a lot she
also writes a lot graphics tea geek blog
spot.com thank you yeah this will get
you a little bit closer to technical
details than the other one would that
wraps up the talk we can stick around
for some more questions otherwise thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>