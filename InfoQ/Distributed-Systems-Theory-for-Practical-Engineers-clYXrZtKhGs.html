<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Distributed Systems Theory for Practical Engineers | Coder Coacher - Coaching Coders</title><meta content="Distributed Systems Theory for Practical Engineers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Distributed Systems Theory for Practical Engineers</b></h2><h5 class="post__date">2017-11-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/clYXrZtKhGs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone and thanks for for
being here first of all I want to say
happy International Women's Day to
everyone in the room specifically to the
women the talk is called originally what
we talk about when we talk about
distributed systems but that wouldn't
fit on the website so it had a new title
whatever it is that we see on your
program my name is Alvaro I'm from
Ottawa I live in Switzerland currently I
work there remotely for a big company
from sometimes from Sunnyvale but I
cannot say which one did your guests
before I used to be a core developer for
RabbitMQ before that I used to build one
of the biggest dating site in for
Germany we were basing China so from
China
we made that website for for the Germans
so you may wonder why this will colors
this top is also called with the video
systems for the akia family the talk was
originally given in Sweden that's the
reason for this name if you think you
may invest your time at a different
track this is your last chance because
there you can find the whole blog post
with a transcription of the talk slice
and whatnot and finally this talk is
dedicated to Peter he was a great friend
he passed away last year we will always
like arch enemies on the MQ space with
7q rabbitmq so this talk is always for
Peter so distributed systems we have
candidates from the book definition
which is a distributed system is is one
in which the failure of a computer you
did not even know existed can render
your own computer unusable this
quote that you probably have thousand of
times maybe some people attributed to
jo-ann strong from the urban community
it's not from Lamport maybe it's from
Avraham Lincoln who knows but that's
time that the definition that there will
be some computer that will break your
system and you have no idea that that
computer was there somewhere this
happens every time facebook like button
go down the internet completely crashes
and what we did as developers is to make
sure that gif hub that was distributed
became completely centralized orgeat
actually so that's how good we are when
dealing with its rooted problems we
centralize everything single point of
failure whoo we can go play ping pong
at the company anyway why this talk the
problem I found when trying to learn
about disability systems is that there
is a lot of jargon there is a lot of
these special words or expressions that
are using a by a particular profession
or group and as difficult for others to
understand that you may wonder yeah but
I'm a software developer what will be
difficult for me as you will see there
are many things the many words here that
they don't mean but they mean another
areas of of computing listen so when
from the basic levels the trivial system
there are many nodes they could be
called processes and they are all used
together to solve a single problem
another key part of the tributed system
is that these nodes we have partial
knowledge there is basically the problem
and there is a lot of uncertainty about
what's going on what's the actual state
of the system and so on so this DVD
system literature will try to go around
all those things and try to solve or
provide or offer algorithms to handle
this problem like partial knowledge for
example and something I saw is that this
is a very deep rabbit hole once you
start digging
it's hard to get out so one question
could be what do we read where do we
start which papers there is one that is
called the SLP
because of the author's Fisher Lynch and
Patterson and this the official name is
impossibility of distributed consensus
with one faulty process many people will
tell you if you don't read this paper
get out of this room if you didn't read
this paper what are you applying to this
position you talk about this decision
and you don't know the SLP impossibility
what are you doing I don't think that's
right but this will happen or have you
never read the part-time Parliament aka
paxos yeah maybe maybe yes maybe not why
but that's another thing that you when
you start trying to hear the voices in
the community you will hear like you
need to know FLP you know to not need to
know pat sauce or time clocks and the
ordering of events in a distributed
system if you are applying or if you're
a PhD candidates in a distributed
systems great and you don't call that
paper then I pretty sure your papers you
check the write every paper I don't know
ask what's the current time is just to
quote that damn paper it's everywhere
and it's kinda they start there of this
whole thing bye-bye lamp or then there
is this other one for example a simple
total order broken protocol you know
which one it is some people from that
paper or related to the paper are
exhibitors at the conference that's the
paper that introduces the Zap algorithm
which is used by Kafka for example so
another one that maybe you need to know
maybe you don't need to know maybe you
just installed Kafka you know what's how
does it work or to keep editor and
finally one that was very popular let's
say two three years ago is raft which is
called in search of an understandable
consensus algorithm so there are
although all these papers but you may
wonder okay did they have only 24 hours
there are so many Netflix series I had
to watch already like you expect me to
also read all these paper make them a
serious make them like this abstract to
make one about distributed systems maybe
read it otherwise I don't care and also
they have this sense of belonging if you
don't know these you don't belong here I
don't know if that's correct because
there are many things that that can
happen in a day in a developer's days
let's say that may not involve any of
that or you just need to be able to
evaluate the difference between draft
and Zab to see if zookeeper or Kafka
works for you and that's all you need to
know then there are a lot of books I
will give you a brief brief not a beef a
brief review of some of them this is
from my library this is an ek a
furniture as you can guess yes the
problem just to give you an example this
programming distributed computing
systems this is from MIT
I bought that book the title seems that
you will help me to program a usable
system it has nothing to do with that
the author start presence in lambda
calculus goes to PI calculus actor model
and whatnot this define all those models
second half of the book that explains on
very academic languages and
implementation of the actor model and
implementation of Pi calculus and
whatnot but you are wondering how do I
program this thing I have to program so
it's very like you want to pull your
hair and then there is a whole wine I
think the wife is very well received in
that picture if for whatever the reason
you need to implement a little good
algorithm there is research already
telling you what to do otherwise you end
up with that and why I said this I used
to work when I was working at RabbitMQ
we have to fix the the replication like
everything that rabbit has it's not
ideal to be charitable let's say and the
problem is when you come up with an
algorithm from scratch like that one
what you are saying is
better that all the the let's say the
PhD researchers like Diego Unga wrong
they want from from raft that they
invested the time of a PhD with advice
or with all the input you get from
University at that level and then you
say no I could sit this afternoon and
code it'd probably be over by the
weekend no no no you are not going to
succeed and there is no unless you are
no there is no unless you are because
for for Lamport for Nancy Lynch and many
others was the whole of the 80s
beginning of the 90s to understand just
what consensus meant and this FLP
impossibility so from my point of view
if you need to get deep and work on
these things read the theory if you need
to evaluate things read the theory don't
trust me don't trust my blog post which
is a resume of all this a summary of all
these algorithms and and techniques
don't stay just us at that level or the
hacker news top post raff is not good
anymore use whatever now we need to
switch everything from graph to new how
can you stop one blog post no so what's
the problem I'm trying to tell you there
are different models on how the
algorithm will be presented one of them
sorry one of them is the timing model
then there is the inter-process
communication model used between these
nodes and the failure modes so I'll go
rhythm will be based in one of these
models let's say in the same way you can
have all P programs functional
programming on whatever you can have
different timing models combined with
different interpreters interpreters
communication models and so on and this
is very important to understand if a
particular algorithm actually suits your
problem on the timing model there is the
synchronous model in this one it says
that a process knows exactly how long it
takes for itself to execute a step of
the algorithm it not exact
how long it takes for that message to go
to another node in the network how long
it takes for that node to process the
message to reply the replied goes over
the net ball you know the time and you
know the time to process it back
that's a synchronous model do you think
that reflects the real world no exactly
everybody for the record was raising
their hand saying no so that's the
synchronous model then there is the
asynchronous model at least for me when
I read this algorithm is using the
synchronous model or we assume and a
synchro's network or a synchronous this
a single of that I think it's similar
way like let's say nettie programming or
node program images where you send a
query to the database you don't wait for
the database to reply back to you you
keep doing things when the reply comes
back you handle that query or whatever
that's how we understood a single
synchronous that particular world in the
tribunal system literature that word
means that there is no guarantees how
long you will take to process a step how
long the message will fly over the
network how long the other node will
take executing that step replying to you
coming over the network and so on so at
this model there is no timing guarantees
it's closer to the real world but it's
not it's not useful to us to know that
an algorithm may not literally not ever
finish because we have customer waiting
for our replies and say we around
someone or whatever and we need to know
what what's what's going on so that's a
synchros model and then there is a semi
semi synchronous that this one Kanda is
not really popular in the literature
base mixing box so that those are the
models then inter process communication
very easy we either have message passing
or share memory is nothing to new here
and failure mode this is very important
in failure moans they analyze how
processes will crash and will panel or
fail and what happens when a process
fails when a when a processes process is
wrong doing what it shouldn't be doing
one of them is crash stop the process
will just crash stop being gone if you
are working with an algorithm that has
crash top model it means exactly that
that process is completely gone do you
think that's how it works in the real
world like you some machine fails okay
just set it on fire because we don't
need anymore no we want it back what it
means is that in that case the algorithm
is able to keep running even though
there are some fail nodes and you need
to understand the guarantees of this
keep running with how many knows it can
still keep running and being correct
always the main interest is is the
algorithm correct is the data replicated
and I'm not losing data I I'm seeing the
right members on this network let's say
you have a membership system to say who
is online like which clusters are online
which nodes in the cluster are online
you want to be very certain about that
here what we are telling you okay if
some process crashes our at least end
process crashes we can still keep
running the algorithm then there is
crash recovery processes can recover but
here okay from where but if you have
crash recovery you know immediately you
need to have some sort of storage if
there is no storage you need to have a
protocol for knows to exchange the
information so they know that is
recovering gets all the transactions
that were missed so all those things
will tell you details about the
performance of that particular algorithm
if you need to store things on the
filesystem maybe there will be a log
what happens if the log is corrupt or
how you replicate that log or all these
problems we are trying to
we sought in in indifference algorithms
if I'm not mistaken I think raft is
either crash top or just crash recovery
but stop there because there is also
this one like omission fault here
processes they don't crash or they could
crash but at the same time the algorithm
is able to tolerate faults to reply or
or to send a message like they have to
act on the algorithm and send a message
to some other node they may fight failed
to send a message or to receive messages
and you may wonder ok but what do I care
about the difference we can have a
process that is omitting to tell the
other nodes that in goddard the
replicated data but it's able to reply
to clients so it's always receiving data
it means is up to date let's say a cache
and it's whenever clients contact that
node that they will get the latest info
even if is not specific specifically I
mean if the other nodes in the network
may think that know is down at least for
the client that knows is useful so
omissions will be two kinds again to
reply to all nodes and to to receive
messages if the node is not failing to
receive messages at least in sub today
just to name an example of something
that could be useful for you maybe it's
not useful again this is all trade off
if you want to have like a recipe or our
I think that you click things and then
you will out would you use this
algorithm all that not know we have to
think and read and understand all these
things
to choose the right algorithm suddenly
many times we choose them based on
marketing based on who has a bigger
world based on like I was not a matter
who I was really not marketing and
material from some vendor out there
advantages we are the fastest than
everybody else
ok yeah me too here is the same we need
to see what we need and we will see that
more when we talk about consistency
then there is the arbitrary failure mode
is called Byzantine failures here is
literally livin la vida loca where Rita
Martin that's that's how what's
happening here everything can happen
everything can go wrong so nodes can lie
to each other and node can tell the
other node like I haven't been receiving
your data so they know start replicating
again what happens if something like
that may occur you are you will see at
those own performance because some
notice is trying to keep up with the
rest of the system and trying to send
all messages to this node that is lying
that it doesn't have the the up-to-date
information or it can say yeah I
received your data now I start
replicating to this side and here I send
wrong info so for example I'm 35 years
old how old I am
how old I am he said I'm 37 that will be
something in in a distributed system it
could happen that yeah he say 3,500
totosai certified I say 35 but then to
the rest I said no he is saying my age
is 37 that's another failure that will
be happening here then we have the
wiretap this is very common in the news
lately
there could be an adversary that for
some reason is into our network
disguising themselves as a bending node
is doing the whole algorithm perfectly
there are no errors
there is no lice nothing but it's
constantly collecting data so my goal
isn't may try to handle that kind of
failure I think there is a report by
Yahoo that they try to study all the
faults on the production system and they
show that up to crash recovery was
useful to invest for of course depending
on your problem maybe you have a very
sensitive information like in pavement
security and whatnot that you really
want to make sure this is handled
but I guess for the average mortals may
be up to craft recovery is good enough
so those are the failure modes then
algorithm this is it's not I mean not
too interesting I say but there is
lightness and safety algorithm will have
those properties there is a paper that
explain all these concepts safety
basically saying some bad thing does not
happen during execution okay what does
that mean communication links should not
invent messages out of thin air that's a
safety guarantee of the algorithm it
will tell you that links are not coming
up with messages out of nowhere juice
will send messages in the order first-in
first-out let's say some stuff like that
unlike this is the other way around a
good thing happens during execution
basically a destination process
eventually delivers a message
also they assume these things when you
see a paper and this is telling you
eventually we will deliver it doesn't
say when but their reasoning to say this
algorithm is correct is because they
assume at some point the message will
come with an answer so it's hard to
balance so if we look at FLP
impossibility objectivity consensus we
don't fault it process Fisher Lynch and
butter some Nancy Lynch
she's like the grandmother I will say a
civil assistant she brought I will what
is kind of the Bible of distributed
systems I will tell you which book is
that later but anyway the abstract says
the consensus problem involved and a
synchronous system of processes some of
which may be unreliable the problem is
from the reliable processes to agree on
a binary value so basically is we need
to commit a transaction to name an
example do we proceed or we roll back
the transaction that's the binary commit
not commit the finally
value they need to agree and they show
that every protocol for this problem has
a possibility of non termination even
with only one faulty process and they
keep talking about different solutions
but very important asynchronous system
of processes there is no timing
guarantees even infinitely it's not like
later tomorrow some admin restarted the
system and then you came back no there
is no guarantees on what happens there
then they say in this paper we show
there a surprising result that no
completely a synchronous confusing
protocol can tolerate even a single
unannounced
process with they don't consider be
sometime failures and they assume the
message system is reliable yes but in
the real world and delivers all messages
correctly and exactly once also very
like I will say this is science-fiction
already on the terrain of scientist
nevertheless even with this assumption
the stopping of a single processor and
in a prop in opportune time can cause
any distributive commit protocol to fail
to reach agreement so why does it matter
what they say why it's important that
they say there is a synchronous
completely asynchronous network that the
message system is reliable the messages
are delivered exactly once we know this
is not kind of true why what do you
think they do that because even with
those assumptions it doesn't work in the
real world it will even less work let's
say when we have a system like the
synchronous model which is completely
not real they prove there that some
things are only possible to be
implemented under those assumptions like
you know exactly all that all these time
slots without synchronicity all those
guarantees are gone you cannot solve
this or that problem so maybe we are
trying to wing an algorithm
yeah we'll do consensus or whatever and
we don't consider all these things so we
don't consider that under the assumption
we have is not solvable
oops sorry so the question you may want
to have is what consensus anyway is a
paradigm of agreement problems the
properties is that they have termination
that if every correct process eventually
decides on some value validity if a
process aside V then V was proposed
proposed by some process you cannot vote
on a candidate that was not proposed
basically you can vote for me for the
election here because I'm not on the
ballot something like that agreement not
to correct processes decide differently
so all if the agree symbol was run to
completion everybody was correct
everybody agree either uncommitted
transaction or an abort the transaction
and then there is a uniform consensus
which says you know two processes
correct or not decide differently but
this is a different kind of consensus it
has already uniform there generally
people talk about just that one so when
do we need consensus when a set of
processes have to agree to take a common
action for example if you talk about a
Tommy blog broadcast of group membership
why I mentioned this because maybe you
think you're not implementing consensus
you think I know I just need to do
atomic broadcast or group membership
like know who which notes are part of
the of the system of the cluster and you
start calling something away I will ping
knows if the note died I would try to do
this at the harem whatever updated at
the structure notify everybody that this
note is down but actually what we are
trying to implement under the hood is
concerned so and they are kinda saying
or telling that consensus is not
solvable in a synchronous network what
is atomic vodcast is to when the correct
processes deliver the same set of
messages in the same order
usually when you need to replicate you
need to have like a trouble
q you need to have the order of messages
as they are consumed by consumers as
they enter the queues and if they are
canceled by a consumer how it goes to a
different consumer study that
so if FLP is telling us that confession
cannot be achieved then at tommy
broadcast or good blemish it cannot be
achieved either but there are people
selling products of their so that if
somebody is wrong here either me damn
somebody we pack our bags and go no
there is a paper by this guide Marcus
Aguilera is called stumbling over
consensus research misunderstandings and
issues the problem with this paper is
that this guy I used to work for
Microsoft and that is not exactly the
problem is that when he greet Microsoft
he was his website went away so this
paper you can find it if you buy a book
by Springer you know the cheap books
online from Springer so there you can
get this book with that paper it's a
book about our application so what he
says is an impossibility result in the
civil system is not the same as one in
mathematics here first they are assuming
network word you can have a processor is
never scheduled by the CPU so because
the process was never scheduled it never
come back live and replied to to the
others to name one example and he says
yeah that may not happen ever for your
case but they are saying is if it
happens it will fail that's one thing
then when you are dealing with the scale
of Alan or Twitter Apple Amazon Google
when you have billions of transactions
per per minute ever now then probably
you will stumble upon that failure
that's one thing then they are not
considering time which that's the reason
why there are failure detectors
these are protocols or algorithms let's
say to detect if another process has
died and if we introduce failure
detectors then we can solve the
consensus problem but as usually or
usual with disability stands there are
problems everything is not so easy
so the seminal paper is this one called
unreliable failure detectors for
reliable distributed systems if you if
your tongue doesn't kinda fall in
between pronouncing one of these papers
it's probably not a real one I don't
know how it works so these are external
processes to the algorithm to the
consensus algorithms you may want they
provide information about suspected
processes they have a complete
completeness property it means that
trash processes are detected and
accuracy it means that correct processes
are never suspected what do you think
about that do you think this is possible
to implement like you never suspect of a
correct process or crash ones are always
detected as we want to call it is just
have some perfect failure detector on
your problem it will be fine no it wants
this is the algorithm for for the
perfect failure detector it has a strong
completeness it means eventually every
process that crashes is permanently
detected by every correct process and
strong accuracy if a process P is
detected by any process then P has
crashed the thing is this algorithm
requires a synchronous system without a
synchronous system you cannot have that
how can you detect with a accuracy that
a process has crashed you need to know
exactly how long that process takes to
process to execute a step of an
algorithm
you cannot detect it if you like issued
running
JVM garbage collection then
work is slow some other process came
back in his recovery and I'm trying to
replicate the log there so I'm busy with
that part of the system and not really
being able to take care of the actual
algorithm and reply back to the notes so
if the process really crashed
it's just delayed how do we know with a
synchronous system that's very easy
because every process has a specific
amount of time to do whatever he has to
do but as we said synchronous system
they don't exist the closest you can get
really real-time system like in cars or
things like that but in networking
that's why there is another one which is
called eventually accurate failure
detector eventually every processor
crashes is permanently suspected by
every correct process and it has
eventual weak accuracy which means there
is a time after which some correct
process is never suspected by the other
ones so here we may suspect up a process
but then it may ping us back and say no
hey I was alive I was just dealing with
this other processor was too slow
catching up or JVM garbage collection
kick on and what can I do I just need to
wait until this is over
the other day were away on the on the on
Twitter there was a discussion between
hippy Lev and Gil teeny I don't know how
to pronounce his name the guy from the
Azul JVM and they were arguing about the
fastest implementation for garbage
collection of terabytes of the operon
like on the hundreds of terabytes around
and they were coming up with algorithms
that were doing this eight minutes so
there are that kind of scale by the way
anyway we can use these things to solve
the the consensus problem and here I
think this is one of the biggest
problems which may have in production
how long this timeout has to be just
increase the timeout
just put it two minutes instead of one
and then the program will
so it's really hard to tell it's really
hard to tell based on on everybody's
business requirement we need to see I
mean it's not the same to have like a
front store like like Amazon let's say
between Versa Sedan or replicating
Cassandra nodes it's totally different
problem a customer can not be waiting
for a minute for some with this wheel
they are loading loading loading all the
time so picking the right time out
that's I think this important problem
there was a patch inside RabbitMQ where
somebody literally wrote asleep 50
milliseconds and see if the process came
back why 51 or 51 you know it was very
arbitrary and banned like ignoring all
the things so that's a paper another
thing that you will see everywhere this
is also very important to evaluate when
you evaluate upon I gonna say mister
quorums what kind of quorum the
algorithm requires that is how many
process need to be alive for the
algorithm to keep running this is the
weirdest
wording you can find on a book but what
quorum is if you strip everything
basically says if an majority of
processes is alive the algorithm can't
keep running that for crash fault
for example the algorithm that currently
ships with rabbit requires all the
cluster to be alive and then it requires
two round trips around the cluster for
messages to be act everywhere
that's very slow and of course in these
rounds around the algorithm the some of
the nodes can actually crash go away
network partitions who knows
so what guarantees in the quorum or what
properties in quorum the algorithm has
will be very interesting when you
need to choose because you know okay I
need to at least have three nose up to
five I live all the time ten our
operations team do that some those
questions are the important ones I think
when when it comes to picking the right
algorithm I won't go over this then
final final one is consistency the
discussion kicked out with this when
this paper came out this correctness
condition for concurrent objects by the
way there is a book for Java development
and I think dotnet development by also
disorder Herlihy melissa Liddy that
explains how to implement concurrency on
the on the JVM level or or the CLR I was
discussing for example because we think
okay distributed system I have thousands
of nodes but maybe you can have
thousands of CPUs and you will have
similar problems and I was discussing
with a guy that designs Harvard and was
telling me yeah when you have different
transistor or let's say gate they also
need consensus and even what was weirder
for me was to understand that the
hardware will will do like a signal that
will traverse the whole circuit and then
it can synchronize every gate but in
between these pings that go around the
the gates they can go on to whatever
state they want what was shocking for me
was like even computers are looking at
the most basic level and we try to make
them work in a cluster of thousands I
mean know hundreds whatever it's it's
amazing
anyway linear its ability to explain
this they use concurrent FIFO queue it
will be any other data structure but
they use this one
because when you have a concurrent FIFO
queue you know what you expect if you
expect first-in first-out behavior you
also want to define what happens if
there is nothing in the queue you block
forever or you return an error beside
that then they try to analyze what
happens when many processes either push
items into the queue or they tour or
they take out and from the queue in
which order those items go to the
different processes that are seeing the
system in action so that's how they
analyze concurrency you need to think
about a data structure and what happened
with many viewers and readers and
writers
go into the data structure so there is
atomic consistency they sequential
consistency and causal consistency there
more there is a very good talk by Martin
clapman he brought up course of O'Reilly
also very very good I'm not the one to
judge it and in his talk he was very
deep into all this subject and Kyle I
fear Jepsen whoever however you know him
has this blog post is also very good
explaining all these concepts but
basically what you have is you have a
linearization of the executions process
P I J and K they will be either writing
and reading from let's say Anatomy
registry and somebody that's watching
this from the distance you will see that
this write was executed atomically here
the read was executed Tom it'll hear
this to operation derive from current
but this one was linearized first than
the other one then we have the then we
have read what does it mean why or how
do we know if this is consistent from a
linear instability point of view because
it doesn't matter that this one started
first than this one what matters is what
happened when it got is secured and this
write for three happen before the two
right
so it's consistent because this read
also CC two and this
- if here we will be seen three dad from
linear stability point of view will be
inconsistent so a process basically
reads it has to read the value that was
written when this the last operation
finish and then it cannot read let's say
older values like here even if this
process brought three if still has to
read two because somebody has brought
this but on sequential consistency it is
only matters what I see from my point of
view he doesn't matter the order of the
whole system it matter what I see from
my point of view so if I'm commenting on
on Facebook my comments are in order
they don't need to necessarily be in
order with where everybody else's
comment on that photo let's say that's
very important because linear
accessibility is very expensive all the
coordination that needs to happen for
this to be correct there is another
execution here if you wanna see the two
happens first then the three that means
this last series read the three because
the linearization was happen differently
but for the other processes after those
rights were executed the thing still
consistent Kyle is testing for this kind
of linear stability so if if project
fails the Egyptian test it doesn't mean
we need to set it on fire go to the
start of the draw that that database and
find the developers no it may perfectly
work for a different use case as in
sequential consistency or causal
consistency in causal I just need to see
that the picture I'm replying to is
there it can be commented on a picture
is not there or if somebody replies to
my comment then the causation from reply
to my comment my reply and picture needs
to be maintained
but maybe a different side of the world
there is people also commenting and also
arguing about different like somebody
posted a comma this is totally crap and
then somebody replying to that one but
we didn't see that yet what it matters
that we see our comment and the replies
to our comment in order so maybe we
don't need to invest in that maybe
that's not the problem we have it's very
nice to say Oh argue all night about
what kind and what he saw in his blog
post on is really cool and really
helpful and it's pushing the level of
the disability systems higher that's
really good but we need to understand
what it what is he testing because maybe
we say are these data based even
passages but maybe it works for a
different use case that's really hard to
evaluate and finally books because
probably you wanna say okay you talk a
lot but what do I do now this book
because I was working in airline ok as I
need to learn all these situated system
things along is a message passing
language and I say ok distributed
algorithm for message passing system
this is what I need you know when you
reach the last page of the book the guy
says we don't consider failures on this
book ok so here's what I thought it was
a scam because then he said but I
brought this book so I bought them all
just to see what was there I mean by the
way this book if you want to know what
is what are the atomic sorry what a
vector clocks Lamport clocks the version
vectors how to build spanning trees on a
distributed system how to prevent
locking at
city or linear instability sequential
consistency all those concepts are very
well explained there if you already know
this concept okay maybe this book is not
for you if you don't know any of that
it's a good book but there is there
fault-tolerant agreement or concessions
algorithm but there is synchronous there
it requires as this algorithm for a
single network so then he has this other
book Irenaeus can I tell you I fall for
that cancer then this one is for falter
and a synchronous retrieval system much
much better this is the Bible I
mentioned earlier by Nancy Lynch some
people say it might be a bit outdated
a problem I think it has today is that
the formality used to explain the
algorithm this i/o automaton something
like that that almost nobody else uses
so you will be learning things with an
explanation and a model that is not
really in other books if you want to buy
one book probably buy this one reliable
and secure distributed programming and
it's one of the few books that have the
secure word in them like they also have
cryptographic algorithms for consensus
or replication or whatever so yeah this
book has all these different models very
well explained then started describing
consensus algorithms from different
levels again everything here if you
really want to know the theory of the
what's behind you wanna get an algorithm
my paper and say yeah I understand what
this guy is talking about all this
person woman whoever is talking about in
this paper this book will like if they
find you with this book on your on your
backpack in the States today you
probably get deported why Kenneth Berman
in the eighties he created a protocol
which was useful controlling airplanes
and he was called
Isis so if you start googling about the
ISIS protocol and this and that you know
maybe somebody will Pat you down and
things but the second half of this book
has a very good discussion of why we
have paxos why we have FLP why we have a
butyl replication why there is his
algorithm what are the difference what
are they trying to solve because in the
eighties everybody was trying to solve
the consensus problem then Lynch came
with SLP and say yep this cannot be
really solved or only in this way can be
solved so then they move on and then
came all the algorithms but in the 80s
everybody was investing money on solving
a problem that was not solvable until
the SLP scene came out so second half of
a book is very very good to understand
all this consensus thing and how they
played together but don't search for the
ISIS protocol that was used to control
airplanes okay this is like three groups
or J groups or energy fair of that is
that thing
replication this has the state of the
art back then let's say 2012 maybe here
you can find this paper by this guy from
Microsoft Aguilera there are papers by
Barbara Liskov chain replication
whatever it's very very good
it's book all how it goes in detail into
every algorithm then a problem you will
use on the talk that I'm always linking
to the ACM they always have to pay for
the papers first
I think investing 200 dollars a year if
you can't do that if you can spell 200
dollars a year on your career which is
like being able to access paper for me
it's been very worthwhile I don't know
for for for you that's one thing
sometimes companies they have
company-wide
account for the ACM that's also cool
sometimes you can put it on your
education budget otherwise contact the
academics they really like to be contact
because they told me like okay
somebody's actually reading my
so here you have it read it so
conclusion as you can see there is a
very deep Brabeck hole something I
really like is computing science where
science is still a thing
you cannot wing it here you cannot say I
came up with the solution okay like I
have the fastest thing ever like some
people screaming out there okay prove it
and really prove it otherwise there's
the door there's the history of the
field matters
you cannot say also I came up with a
novel like okay who do you check before
you read know everything compare with
anybody else okay then is probably not
another and read read and great thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>