<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 Lessons from LinkedIn using Node.js | Coder Coacher - Coaching Coders</title><meta content="HTML5 Lessons from LinkedIn using Node.js - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 Lessons from LinkedIn using Node.js</b></h2><h5 class="post__date">2012-05-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hMd45Ij2DYQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm the director of engineering for
mobile at LinkedIn so my role is to
build all of the apps for phones and
tablets on the client side as well as on
the server side for LinkedIn so
everything that's on mobile is built by
my team and that that's kind of my role
oh yeah I want to just kind of get a
quick idea of types of people in the
audience how many people here are
product managers how many are designers
ok and how many are developers oh that's
good ok ok it's a pretty good ratio so
so generally what I'm gonna try to do is
walk through how we build mobile
applications and and utilize both no js'
and html5 to do that at LinkedIn it's
kind of an interesting question because
I think both the term nodejs and the
term html5 are really generic like
people have just stuffed all sorts of
technologies under those words so I'm
gonna try to go into a little more
detail on what that actually means for
us like which libraries were using and
and what we're doing there so let's get
started so you guys should be anybody
who's building products in general are
probably pretty familiar with these four
stages of building so we have the design
this is product design UI design
technical design then you usually go
into code you have some testing you know
some deploy and you do this many many
many many times hopefully at some point
you have a product that pops out so
typically for most products this is your
your typical cycle the one sort of
difference on mobile is that you kind of
are doing this across a number of
platforms the way we break our platforms
down
his iOS Android the browser we look at
as a platform and then currently the
other sort of devices Blackberry Nokia
Windows Phone 7 Samsung that type of
stuff so let's start off with design I'm
gonna kind of go through this fast you
guys stop me at any point if you want to
if you want me to slow down but I'm
gonna go through the product design
stuff a little bit faster because it's a
smaller audience for that so whenever we
start by designing our applications we
really try to separate interaction
versus visual design and so usually when
I say this a lot of people it's
difficult to understand what the
separation is so I've tried to sort of
build a metaphor that I'll use
throughout the presentation and it'll
help sort of separate when I'm talking
about interaction when I'm talking about
visual so think about interaction design
is building a floor plan for a house
you're defining what each of the rooms
are you're defining how you can get from
one room to another that's your hallways
so for example you have a living room
you know what you're gonna do in the
living room you can say watch TV that
type of stuff you know what you're gonna
do in a kitchen you know what you're
gonna do in a bathroom generally do not
have your toilet in your living room
so youyou really want to sort of define
rooms that are for a specific purpose
and then you want to have sort of doors
and hallways that take you between them
so we try to stay away from the visual
part the paint the furniture the carpet
what interior designers do and sort of
the house metaphor and then for each
room and so if you haven't already
figured it out each one of our rooms is
a screen in our world in our in our app
has and does for each screen so what
does each screen have on it and then
what can you do from each screen this is
where we start off with our initial
design and then we build for pretty much
all the platforms in black and white
first we do this on purpose so that when
we're doing user testing people have
visceral reactions to color so sometimes
they're so focused on like no I
like that it's red or blue or green or
whatever are the shadings not right so
we really focus on a black and white
sort of UI design before we kick into
full development so if you look at the
current mobile applications these are
our four rooms we have the stream you
inbox and and following and we have a
few hallways search compose and
notifications the breadth below for the
depth below three so you generally only
want to have about four rooms on mobile
if you try to get more than four rooms
people generally are lost they can't get
to the fifth room or they get they just
don't know how to get back and your
depth is less than three so when you're
in a room you tap on something you go
screen in or another screen in you
really don't want to go more than you
know three levels deep once again people
will get lost they don't know how to get
back out and they'll sort of lose sight
so what about the differences between
the platforms there's a few differences
there they're actually not that hard to
separate on screen back versus Hardware
back there's a concept of using back
versus up between iOS and Android where
your refresh is and where your settings
are and then we really use visual design
to kind of separate the user experiences
you know what do the buttons actually
look like where the paint look like that
type of stuff but in the interaction
level at the room floor plan layout
level we do not have that much
separation another thing people usually
usually ask me is you know why do you
guys have a mobile web solution why not
just have a nap
why do you really need it and this this
is sort of the answer to that so
typically when you're looking at any
sort of web-based property internet
property you have these sources of of
traffic you have SEO search engine
optimization you have email so if you
send out email and they click on it
comes back and you have organic somebody
typed in your Dominion on mobile that
would be like finding your app and
launching it manually so for LinkedIn at
least a huge chunk of our traffic comes
from email from email clicks and email
links and that takes you into the mobile
web
so for actually a lot of mobile
applications this is a prime way to sort
of initially seed your application get
people to sort of use it so let's go
into code I know I flew through that any
questions on that area like should I
just keep going keep going
all right this is the basic structure of
our our design or architecture for our
applications so I'll explain what the
percentages are in a second we have the
the four major platforms or the way we
look at platforms we have iOS native
Android mobile web and then we have
other OS azar wrappers around our mobile
web solution we have this sort of
framework that we use internally it's a
mobile web JavaScript HTML framework
I'll talk a little bit more detail about
what that is what is that html5
framework we use on mobile all of these
applications are some part built on top
of this mobile web framework so here
it's 70 70 % of it's actually built in
HTML and JavaScript and only about 30
percent Sneyd of code 80 percent on
Android is native and only about you
know 20% is javascript in HTML mostly
because of some of the performance
constraints we have on Android with the
browser and mobile web of course is a
hundred percent it's the web and then
other os's are a hundred percent from
our standpoint because we usually have
you know just very very simple wrappers
we then communicate over something we
call screen based rest api's I'll talk a
little bit about what that is in the
coming slides which then talks to our
mobile server so our mobile server is
made up of nodejs and MongoDB I'll go
into super amount of detail this to sort
of give you a vocabulary on what the
mobile server is and how nodejs works
and then we have this domain REST API
the text in talks to the LinkedIn
platform so one thing that people are
surprised by is whenever I say LinkedIn
platform they're like oh you guys have
all these custom api's that you are
using to talk to back-end LinkedIn
being all of the mobile solutions today
are built on top of literally the public
LinkedIn platform the one that you can
get to on developer 10.com so all the
functionality that you see on all of our
mobile apps is built on top of this API
so start going into some detail we'll
start off with the mobile server the
node.js a MongoDB so before I kind of go
into you know why no js' I kind of need
to walk through a little bit of change
that happened that that's happening with
html5 as a result of html5 in the way
we're sort of building these client-side
applications so I'm sure most of you are
familiar with classical model you
controller or variations there of that
truth anybody everybody who knows Model
View controller can I have hand raised
all right okay so typically if you guys
have built rails based systems like Ruby
and rails or Django and Python or if
you've used jsps in Java or any system
at all for web-based applications you'll
have a controller you'll have some sort
of templating language GRB JSP something
like that and then you'll have an or m
layer or something to store stuff maybe
you have like if you're using MongoDB
Eve and they're stuff like active record
hibernate for the Java pylons that type
of stuff and every time there's a
request that comes from the client
generally a process is spawned or a
thread processor thread I'm using them
interchangeably but they're spawned and
that socket is held open until you're
done doing your processing and then it
responds usually there's one processor
thread per request and then you have
sort of a queue of sockets that are sort
of waiting to be processed so as you go
into tiered systems you just start to
grow as a company organization I'm sure
you guys have this you've separated your
data service into a separate process and
you moved your controllers and
templating forward as you continue to
grow the number of data services you
have grows right because the domain
models that you have so for us I'm
linked in like profile is a data service
our network updates is another different
data service our inbox messages that
type of stuff is another data service so
they're separated by the type of data
they are and then I do want to make a
point on the last two they're tracking
and a background cue so usually in these
models when you're processing this way
you don't want to sort of block the
response to the user right so when a
request comes in you don't wanna block
the process so what people typically do
is they stick something in a background
queue and they respond and then they
either pull again or something like that
to effectively check if the if the
processing is done so one of the big
differences that's that's changing when
you go into html5 is look where the
dotted line is moving so the dotted line
the client-server border is above all
this stuff right the server rendered in
html5 based applications the
client-server border has moved it's
moved down here to this dotted line so
now this client-side this is running in
the browser or in an app whether it's
native code whether it's JavaScript code
it's it's sort of running down here it
needs to talk to all these backends and
you're like well ok how is it gonna do
that you really you really don't want to
sort of have one connection talking to
every single process here and and you
sort of lost the value of the background
queue right because there's nothing
sitting there to sort of help you with
that
so this is where nodejs comes in this is
really what what nodejs at least we
believe is really good for if you've
moved you know in a classic MVC model
what we've done is we've moved the views
and the controller's up here into the
browser you've moved the models back
here so you say well what's left a very
thin layer that's that's all its really
doing is some aggregating and some
formatting and another thing you'll
notice is that the background cue I've
kind of graded out it's it's gone down
in necessity because because no js' is
evented and I'll talk a little bit about
what that means because no js'
evented you're not as dependent on sort
of giving up a process giving up a
thread or giving up responding
immediately and then not being able to
wait for something to complete so why no
Jess
the two main reasons is that it's
evented and it's JavaScript and I'll
explain so for our use case and I think
a lot of people will have this use case
as you build more client based
applications html5 based or or mobile is
that most of the front-end the thing
where nodejs was sitting at the most of
what it's doing is just sitting there
waiting for other things to do stuff
it's IO bound it's it's sending requests
to back-end service to actually do some
processing it's talking to a database
that's actually trying to read off disk
but if effectively it's IO bound it's
not really doing that much all it's
doing is some string manipulation so
it's it's manipulating straighten so
front end it's sort of like a typical
example that most people do is oh I have
a user object that's stored in my
database somehow I'm gonna get it the
user object has a first name and a last
name but you want it to show up as name
in the UI so you concatenate them right
first name plus last name typical model
I feel like I see that replicated and
every piece of everywhere so
manipulation is strings so so for the
evented part the i/o bound because it's
i/o bound the evented part is really
really important because it's mostly
string manipulation the JavaScript part
is actually important JavaScript at its
core when it was built it was built to
run in the browser and for the number
one thing you kind of do in the browser
is YouTube Dom manipulation and you do
string manipulation so the v8 virtual
machine which is what node runs on top
of it's actually optimized for string
manipulation so if you look at things
like the job the job of the end python
vm the Ruby VM they have a little bit
they are they're not tuned for this case
as much it's not that they can't handle
it but they're just not tuned the third
thing is lots of persistent socket
connections
so this is really a mobile case that we
we take advantage of is on mobile I know
that all the advertising is talking
about more and more bandwidth right 3G
4G faster faster the biggest issue on
mobile is actually not bandwidth the
biggest issue on mobile is latency it is
the number of time the number of amount
of seconds it takes for you to actually
a step and you said you here I said
seconds it's not milliseconds but
literally seconds it takes you to to
sort of establish a net connect
connection means that you really want to
limit the number of times you're making
HTTP connections up to your server you
want to kind of create one HTTP
connection and then try to send a lot of
data back and forth on it so the concept
of sort of comic based connections or
long polling connections that type of
stuff has been around for a long time
but in the process based model that we
talked about before that means I would
have to have a dedicated process or
thread tied up holding that socket open
and that actually causes some big
problems because eventually as you start
to scale up that means every one of your
users is taking up a thread and at
Linkedin scale when you have millions of
users you have millions of threads
starts to cost some money so we try to
keep the socket open so we established
one connection up and we try to keep
that socket connection to open and
communicate over that connection which
actually gives us about a 20 to 30
percent boost in performance
another huge bennet benefit is that
client developers are actually doing
server development so so one of the
other issues that I always hear about
nodejs
how many of you have actually used
nodejs ok so I'll go into a little more
detail here so there there are a few
major complaints about no js' one
actually both of them are that it's
vented and it's JavaScript so so the two
things I really like about it are
usually the two biggest complaints about
it
the evented part of it actually causes
you to change the way you're gonna
program a lot of server-side developers
are very used to a model of you know if
I want to do something I spun up a
thread I do that in the background and
then I sort of
continue moving to an invented model
really requires you to have this concept
of sort of responding to events
responding to actions responding to
something happening and spreading enough
client developers are naturally attuned
for that because every UI framework
whether it's native or in the browser is
evented by definition forget about the
language it is invented by definition
right you are waiting for somebody to
click on a button and then you will
respond to it so for for client
developers it's actually been easier for
them than doing the threaded model and
trying to figure out synchronization
blocks and all of those aspects the
second half of it is the JavaScript side
of it it's a JavaScript you know it is
more recently starting to become a
language that people are embracing but
you know in the past a lot of people
were worried about while it's gonna turn
into spaghetti it's hard to understand
the code base that type of stuff if you
look in the node.js community now
there's some libraries that you guys
should definitely look at like step or
async which which provide you a little
bit of structure on how to how to
organize your JavaScript in a way that
makes it a little bit less of a chance
to go to spaghetti it's still always
dependent on the engineer you can write
spaghetti in any any language javascript
definitely does make it harder or easier
to may write spaghetti and so there's
some good design patterns by looking at
those things you'll kind of get an idea
of how to write your code in a way where
you don't have end up with sort of the
sequence set of callbacks the the last
big sort of benefit is that it's evented
all the way down so what does that mean
so there are evented frameworks in other
languages so there's event machine in
ruby twisted python in in python there's
the play framework in in Java slash
Scala
that's an i/o base so our biggest
concern and the reason we ended up with
going with node.js for all of those is
that the way in a vented model works is
that every time you do any communication
any
do anything io2 some to something else
you have to make sure that that thing is
asynchronous as well right because if it
blocks it it's just like in your UI for
all the front-end developers like if you
do something that's gonna block the UI
then it's just gonna like it's gonna
feel like the UI is blocked it's the
same thing on an invented system on the
server if you block that main thread
you're blocking all requests for the
entire server which which is really bad
and in most other systems in most other
languages the libraries the benefit of
all the libraries that are currently
there all the Java libraries all the
Python libraries all the Ruby libraries
is that they're all synchronous right in
fact we put out Java libraries to talk
to the to the LinkedIn platform they're
synchronous we put out Ruby libraries
they're synchronous there are
asynchronous versions of these things
but it's it's definitely you have to
make sure every time you include a new
third-party library or something from
the internet that they've written in an
asynchronous way and I know Jas because
it's sort of a relatively new it's not
really all that new anymore it's two and
a half three years old it's relatively
new it's come up with the assumption
that everything has to be evented so a
lot of its library sets a lot of its
modules are evented all the way down
there evented by definition and so that
just gives us a little bit more
flexibility in terms of choosing our
external libraries third-party libraries
that we use do you guys have questions
because I went through a lot of data in
this slide yeah so we did we definitely
did perf an ALICE asan just plain
JavaScript execution for like loops and
stuff like that so javascript is the v8
engine at least for the taste test cases
we ran is slower it's like 10 percent
slower but I'm not sure it really were
not CPU bound where i/o bound so as a
result it wasn't really a big issue for
us no so that that's the so his question
let me repeat the question the question
is like oh you're gonna hold these
millions of sockets open for the
persistent socket connections that's
obviously a process or a thread
okay how could you possibly be doing
that that's that's the whole point of
the invented model for nodejs is that
nodejs is literally a single process
there are no threads there are no sub
processes there's nothing it is a single
process every time a connection comes in
it's like it's it literally just holds
the socket connection it's not
associated with the process or thread or
anything holds the socket connection it
has a queue of sockets and every time
something comes in on one of those
sockets it it lets you process that data
and then it goes back and looks at
what's in the queue again there there
are no threads there are no multiple
threads so how do we scale to millions
is you know each process can handle X
literally like I don't know X hundred
thousand connections and that's how we
can sort of scale that model yeah yeah I
can I can share some stuff I can't
obviously give you guys exact details so
so generally our node instances so if
you're just doing like a you send a
request up to node and it sends you back
okay this is like the typical thing that
I see in a lot of these like bandwidth
tests it shows that oh you know a single
node instance with a single process on a
single core running in about I think
like 30 mega RAM can handle somewhere
around like 150,000 QPS it's like crazy
but that's not reality as soon as you
start writing JavaScript in and it
starts to actually do things like
actually concatenate strings and notify
stuff what we have been able to reach
for our code bases around 160 to 200 QPS
per node instance per node process
running in about 30 to 40 mega RAM so
obviously you know the more JavaScript
processing we do that that number goes
down a little bit but overall that's
that's pretty high that's higher than
most other systems can can do on a per
process level as well as in terms of
memory utilization you know 30 to 40 Meg
for a processes it's pretty low on some
of these back-end systems and then we
usually lock each node process to a
single core and that's how we get scale
on a multi-core system you can actually
tell Linux if you're using Linux or
Solaris or whatever
you lock each process to a specific core
and that gives you an optimal
distribution model another question so
this question was are we using socket IO
we are using socket IO yes let's talk a
little bit about our node slash our
mobile server and what are the
components in it and what do we what do
we use it for so obviously we have a
load balancer in the front we have nginx
nginx
we use as a webserver to be honest I
think within within the next month we're
probably gonna remove nginx and just
have load balancer going straight to no
js' originally we put in nginx because
we wanted we were we were concerned
because no js' is relatively new and we
wanted something a little more stable
the reason we chose nginx
over Apache is nginx is also evented if
you put a process based system in front
of an invented model you have lost all
the benefits of your invented model
because now you just have a different
layer with all of the processes and
threads in front of you between you and
the client so nginx is an invented C C++
based web server that you know it's
super popular super efficient now that
we're actually a little bit further
along especially since we moved all of
our static content to CDN the web server
is really not providing that much value
and so for example on the mobile server
side we still have nginx in front on the
new tablet application and the tablet
server we just launched we don't have
nginx in front anymore it's just
straight load balancer to no js' and
that's it
so no js' servers then talk down to a
few different things
MongoDB so we don't actually use MongoDB
for a ton we use it to store our
authentication keys effectively cookies
to look up a user but all of the real
data is stored behind the LinkedIn
platform and that data a lot of that
data is stored in a variety of databases
we use my sequel we use Oracle we use
react we use Voldemort so it's a variety
of databases and it just
hands-on on the use case that we need to
use for it you know for us just you know
one of the one of the issues we've
definitely run into is with MongoDB from
an operability standpoint MongoDB is the
has been the hardest thing that we've
had trouble with from an operability
standpoint and then we have a logging
server logging servers really simple
I really recommend sort of trying to
build some simplistic logging server a
lot of people sort up all of their logs
but they don't actually have something
that can grep it and analyze it there's
definitely public tools out there that
are things like Splunk which cost money
or log lea which cost money but you can
also write a simple one all it does is
build an index a text index into it and
that allows you to do some simple
histograms so you can do grep across all
of your logs and I know that sounds not
very useful but once you have the system
it gives you a huge benefit to be able
to see real time what's happening you
can kind of get a simple easy
distribution of like how many errors and
what types are they happening without
having to you know write a bunch of Perl
scripts that type of stuff
and then we have a tracking server
attracting server we actually have two
types of tracking that we do we
obviously do tracking into our data
warehouse to keep track of large sets of
actions and pageviews that type of stuff
completely not attached to a user but
the other thing we do is we have this
thing called in graphs super important
for us to measure operability it's a
counter based system so for example
every time we make a request to retrieve
a profile we increment a counter that
says profile call counter the reason we
do this on we do this on the node.js
side the counter is actually
incrementing and what you're calling the
trap the tracking server saying hey
increment 1 increment 1 increment 1 the
reason we're doing this is trying to
parse all of that information out of the
logs after is actually really CPU
intensive and it takes a long time but
if you're calculating it upfront it's
really easy so what we have is we have
these charts that kind of show us hey
you know you're making a home 50 calls a
second to profile and then we we have
charts that show us that information
week over week so we can always see when
we launch
new feature would you know hey suddenly
the profile calls a drop did we break
something or launched a new feature
profile calls went up through the roof
do we do something so it's a simple
example but we use we use that not only
for operational metrics like you know
QPS in or like number of MongoDB hits
gets failures that type of stuff but we
actually also use it completely for our
product metrics so we real-time measure
like how many people are viewing the
home screen how many people are viewing
the use screen how many people are
sending invitations how many invitations
are sent and we sort of track all of
that data real-time so we can get week
over week trending I think I covered
most of this stuff login track the
platform transport yeah Jason and Jason
out so generally the you know all of
this stuff communicates through I mean
this is obviously not HTTP based this
one goes over syslog and this one is
HTTP based and then we have the LinkedIn
platform which is also HTTP base all of
them generally have Jason in Jason now
so Jason is coming you know the request
comes in from the client we make
requests out to the LinkedIn platform
and all these different things convert
to Jason and we send Jason out so from a
node Jason mobile server standpoint
everything coming into mobile servers
HTTP Jason and everything going out is
Jason so some of the benefits of MongoDB
is that it actually because it's an
object store plus it allows you to have
this query language that's sort of like
lets you query inside objects instead of
sort of using the sequel style model we
aren't really taking advantage of those
aspects we're kind of using it as just
like a blob based storage like we have a
key in a value pretty much a key value
store and we're just having issues with
as it sort of scales up as the number of
requests go up that type of stuff it it
tends to continually eat memory and
maybe that's just a tuning problem that
we don't understand yet but I think
we're having trouble from enough from
people who understand how to operate it
very easily so for the use cases we have
I'm not sure we're get
the value versus the pain that we have
for it replica sets is another problem
on mongodb replica sets is a concept of
you can have multiple replicas and it
does automatic rebalancing whenever one
goes down so we have a five replicas set
if one goes down it'll revote another
one is the primary one of the issues
with this model is it takes almost two
minutes for to re to to pick a new
primary during the replica set sort of
downtime that means that takes our our
access to all our authentication
authentication out for about two minutes
which is not good so I'm sure these are
solvable problems and maybe we don't
have the skill set yet but we are
definitely struggling with it a little
bit we we the only thing we're storing
there is a op token so the standard API
has a Roth base token model so is that
consumer key in token and so when you go
up to any Kate you have to store a token
in a secret that's where we stored the
token in secret there that's it
somebody else had a question about it
how do we handle the security of what so
so we run over I mean we actually run it
over HTTP and the HTTP actually
terminates at the load balancer level so
we don't do pretty much it's all HTTP
inside but up to that point its HTTPS so
we have secure transfer of data if
you're asking for like storage security
oh yeah so yeah I mean cross-site
scripting um so generally in node.js we
don't do evals so if you don't to evals
you you're generally okay like you know
I would I don't we don't do that we we
do you know Jason parses but Jason
parses literally are looking for
structure Jason and not going to execute
code at all in terms of on the client
side we have a security team who does
security analysis and audits of all of
our JavaScript code and and you know we
run sort of tests against it to see if
we have cross-site scripting attacks in
that type of stuff there are other
questions
so I talked a little bit about
screen-based Jason screen-based Jason
was the way that the clients
now the html5 and native clients
communicate with the mobile server so
what does that Jason block actually look
like and what is a screen based Jason
versus like anything else
so in general so that we can sort of
limit the number of round trips we say
okay every request it's a single request
per screen so every screen has a single
request we make the request up and we
get a Jason template back and the Jason
template we get back is something like
this we have not one a time a header
that says wow this is pretty cool a
footer that's I shared by Karen Prasad
so if you look at one of the nice items
or the network updates items in on the
linkedin's main screen this tells the
client how to render it so the natural
question I get is well why don't you
just send HTML back because then it'll
know how to render it the problem is is
if I'm if it's a native app I can't
render the HTML so I need sort of like a
pseudo simple pseudo language that just
says like okay when you see a nut 1 and
you see a header okay make sure it's
bold it's at the upper left hand corner
of these pixel coordinates that type of
stuff and so we have an agreed interface
between the client and the server that
says this is how you will lay stuff out
it's not as expressive as HTML and CSS
can be we're not in fact we're trying
not to make it as expressive HTML CSS so
we don't reinvent that you have to build
another rendering engine and native code
but the benefit we get of this is that
now it's updatable on the server we want
to define a new sort of a various
another version of a not not type or we
want to suddenly instead of showing a
network update we want to show inbox
message in your nest stream we just have
to sort of transform it into this thing
and that's what the node.js layer is
doing we just transforms the backend
data into this into this model and the
UI will render it this really gives us a
ton of flexibility on the mobile side
because that means on a per screen basis
we can decide whether we want to
that screen and native code or whether
we want to build that scrape in
javascript in HTML and it really doesn't
have a significant impact on our
back-end servers and and it gives us the
flexibility on the client-side to get
performance the question is is there
impact on SEO for loading jason--
jason-- based Yva yes so this model is
very is designed around a concept that
you're building applications and so
you're right so if you have an index
file or scraper file that you've set up
that that you want like Google to scrape
or something what we've what we'd have
done is we've actually does built a
since this is a Java Script
it's Jason coming out we actually just
use a simple template that dumps all of
the content and points the robot that's
X file at that so it's not a viewable
file but it's a file that a you know a
crawler can scrape and that gives us the
ability to do SEO management that way we
also have the desktop site which gives
us a huge benefit is that we also let
them scrape that sum so we talked a lot
about the server I'm gonna go in more
into the client-side components now I'm
gonna start off with the iOS side and
talk a little bit about that so the
actual question is like you know what's
native I told you you know 30% is is
native and about 70% is web-based and
we're actually probably moving more more
web so I'd say like maybe even an 80 to
85 percent is is web now so it's native
for all infinite lists so what's an
infinite list so our network update
stream is actually an infinite list you
scroll it keeps loading more and it
keeps loading more as you scroll that's
that's effectively what we call an
infinite list we have tried so before I
was at LinkedIn I used to run the
platform and applications team at webOS
webOS was a fully JavaScript and HTML
based OS and it is really really hard to
build an infinite scrolling list in
JavaScript I have still yet to see one
that is built that is performance
not just scrolling but scrolling a list
while you're adding new elements to the
bottom of the dom and taking elements
out of the top of the dom and not having
a glitchy scroll performance as a result
if any of you guys can solve it come see
me I would love that
but that's definitely one of the places
where we stay native we also stay native
for the window manager so when you tap
on the linkedin it sort of goes into
this mode where the four four layers are
there and sort of like zooms them down
and kind of does a little cutesy bounce
and stuff to get that to happen in in
JavaScript and HTML it just really
wasn't possible it wasn't performant not
necessarily it wasn't possible we got it
to happen it just wasn't performant but
for all of the other screens that are
not these cases we've actually gone more
and more web so actually this is a
web-based screen this is a native screen
this is a web-based screen this is a
web-based screen so we generally try to
make choices on a screen by screen or
action by action basis so Android native
so here we went native with most screens
the reason we went native with most
screens is that the Android browser at
least before 2.3 doesn't support css3
based sorry hardware accelerated css3
optimizations that iOS does as a result
a lot of the simple transitions we
wanted to do a lot of the layouts and
scrolling we wanted to do just really
wasn't possible to be done in a
performant way we definitely focus that
LinkedIn on speed that's sort of our
mantra is we build simple things simple
as fast easy reliable fast being the
most important thing and we could not
figure out how to make it fast so a lot
of the screens are actually native based
and we use web views for about 20% of
the screen so this is a web based view
this is a native screen
we're definitely moving more towards
html5 as the penetration of 2.3 and
above devices happen we're moving more
and more to html5 so it's probably not
even 20% of screens anymore it's
probably like 30 or 35 but I did go we
did go more native so the question was
what specifically made you have made you
go more native and less browser on
Android and so that the the reason we
went more native that the really the
main reason we went more native is that
the browser is just less capable in
terms of performance the JavaScript
performance is slower significant slower
than iOS for us the css3 hardware
accelerated animations don't exist on
earlier versions of Android I think it's
too dot 3.2 and less or something and so
the browser just isn't as capable and if
you look at the set of devices that are
out there based on our demographic of
users that actually makes it really
tough to have to have a performance
system on Android does that answer the
question no yeah so a great question
what about chrome on Android so so
Google released a chrome baked Chrome
browser for mobile recently he was like
three four months ago the Chrome browser
for mobile is awesome
it's phenomenally good it is just not
the default browser and the number of
people that are going to download a
non-default browser on an android device
is too small for us and so I think as
the Chrome browser becomes the default
browser on Android I think there is a
huge value proposition for us like we
will we will double down heavily the
Chrome browsers are actually phenomenal
for us right now mobile web so I told
you we have this sort of mobile web
framework that we use across all our
applications so what is it what is it
based out of what's the magic there is
no magic we're using all open source
components to actually build most of our
UI we use backbone for MVC so now that
you've moved the view and the
controller's down into the client side
you need a typical MVC style mob
that you would have had on the
server-side on the client-side we use
backbone backbone j/s is a is the
library we use for that we use
underscore underscore provides a bunch
of utilities that you're that you're
really used to in most other languages
like collections classes and Java list
manipulations and Python and Ruby that
type of stuff it also provides us
templating so the you can sort of have a
template so like in in JSP LAN you
normally have a template and then you
write sort of JSP script is stuff in
there in ER B's you use Ruby
so in underscores template the
templating language is JavaScript so you
see that theme we're keeping with
JavaScript now from all the way through
on the templating side on the controller
side as well as on the backend side so
it gives you a lot of flexibility in
terms of your developers Zepto is
something we use for Dom manipulation we
use this instead of jQuery mostly
because it's built for mobile I think
gzipped and compressed it's somewhere
around 4 kilobytes which is like super
small compared to jQuery the same sage
and we use I scroll for scrolling for
the cases where fixed fixed position
elements like on iOS 5 fixed position
elements were available but before that
they weren't and I'm Android there
aren't so we use I scroll for scrolling
we use so the local storage for a
personal cache and a hash based loader
I'll talk about what that means so
mobile browsers the caches are are not
very friendly they pretty much kicked
you out whenever they they they feel
like they are low on cash so we are
using local storage as a personal cache
that means we do cache management in it
so that means we actually store all our
JavaScript files in your local storage
all our CSS files are in local storage
our photos our pictures are in local
storage we base64 encode them send them
down is text and we store them and so we
literally just store everything in local
storage and local storage also has a
limit I
think it's a 5 mega limit by default
we're way way way under the 5 mega limit
the the way we then sort of figure out
well how did you get a new version of
the the application of the JavaScript
let's say you you made a change and you
get a new version of JavaScript what
happens is when the index dot HTML loads
sort of in the Hat in the sort of
beginning of that there's a big hash
that says okay for this file here's the
md5 checksum for this file here's the
md5 checksum so when the index when the
client-side code starts to run it looks
at all of those and it compares the md5
to the md5 we have stored in local
storage and if any of them have changed
it goes and retrieves that one file but
doesn't actually retrieve the whole file
it retrieves a diff file like a patch
file and it just applies the patch since
we're all in text mode so with this
model we literally are able to sort of
you know a change for our code even a
significant change for our code to an
end user when he's using the browser and
sort of working with this is less than
like maybe a Kay of change which is
great great for us we use sass for CSS
how many people know what's asses okay
saps asses it's just a sort of
high-level language of CSS it gives you
the ability to have variables and
arguments and for loops it inside your
CSS files and then it compiles that into
CSS the biggest benefit of that is I
mean the benefit of any programming
language arguments and variables and
loops if-then statements that type of
stuff you have closure for compiling
closure is just a JavaScript compiler
does Amana fication and compilation and
removes dead code we utilize closure
heavily if you actually look at closure
really closely it's a phenomenal
compiler it does more than just
minification it will look through your
code and find dead code and remove it
for you automatically you can have it
set up to remove your comments for you
automatically so that when you do the
compression it doesn't include all the
text from your comments etc it's
actually really really good at sort of
outputting something that
that you can send to the user easily so
so we talked about design initially
product product design the type of stuff
we've talked about code we talked about
the client side we talked about the
server side so I'm going to go through
the last two stages which was test and
deploy and these I'll hopefully go
through a little faster and then what I
was going to just do is a quick little
demo on the iPad app that we just
launched to give you an idea of like
what's native what's JavaScript and like
as we kind of play with it you'll kind
of see some of the nuances of the
differences and stuff we're struggling
with so for tests for automation on the
server side we use vows to do automation
testing it's a node based module that
does asynchronous testing on Android we
use something called robot iam which is
very simple similar to selenium but for
native Android apps we use selenium
obviously on the mobile web we use
something called phone monkey so phone
monkey actually just has the phone app
open it can have it on a simulator and
it just randomly touches those parts of
the screen in random sequence like a
monkey and it does that over and over
and over and we see how long it can last
before the app crashes and like the the
the goal is is to just get the length
that it runs to be longer and if we can
get that I think what we found is if we
pretty much if we can get phone monkey
like there's threshold points if you can
get fun monkey to last about six hours
that's that's like amazingly good
because I don't know there aren't that
many people were gonna sit on the app
and poke at it for six hours straight so
in general for monkey actually finds a
good number crasher bugs very quickly
and then we use gjh unit which is just a
way to do unit based testing on we use
Hudson for build management so Hudson's
just a building tool on every check-in
we use get first
control system for every check-in we
automatically have a build kicked off in
Hudson which then runs all of these
different tests and then either passes
or fails to build in terms one of the
big benefits of one of the big models
that we use that's that's pretty big for
us is the way that all of this stuff
works and works successfully it doesn't
grow out a scale is we do trunk based
development so we literally have no
branches everything's checked into
master all of the engineers check into
master and this is not just true for the
mobile team is it true for all of
LinkedIn so we check everything into
master and everything's built off of
master everything's deployed off of
master we have an internal tool for
layout testing so it's actually pretty
cool we built a tool that will tap on
the screen somewhere take a screenshot
tap on the screen take a screenshot tap
on the screen take a screenshot the next
time you run it through it'll compare
the current screenshot against the
previous screenshot and see if there's
more than 5% pixel difference if there
is more than 5% pixel difference then
you know that the layout has changed
sometimes that's because we changed the
design at layout has changed and
sometimes because you know we broke
something and it's a really good tool
for us
we're probably gonna open-source this
tool we're working on that now we use
something called phantom js4 a
performance monitoring so phantom j/s is
a headless webkit browser headless means
that it doesn't actually render UI
anywhere but it's a full webkit-based
browser
it has javascript so the benefit is that
you can run all of your client code that
does Dom manipulation and everything
inside it and then you can sort of like
send off little signals that say hey I
just finished rendering this page oh I
just handled this click that type of
stuff
and then you sort of plot it out on a
graph kind of get an idea of where you
are
we generally run bug bashes in every two
weeks we have demos and I'll talk about
in the deploy section how often we ship
and how we sort of run stuff
so for deploying we use Enterprise
builds that are available to employees
Enterprise builds both Apple and Android
and Android I get you can you can
distribute even if you didn't have an
but Apple has this model of getting an
enterprise certificate you get an
enterprise certificate you don't have to
release your app into the App Store your
enterprise can use it anybody who is
inside your enterprise so as long as
it's on a corporate VPN they can use it
we use this and let all of the people
who work at LinkedIn get the latest
version of the app all the time we ship
everything all of the applications on
the client side as well as the server
side twice a week so your natural
question is like I don't see updates to
the app show up every two every two days
so I don't believe you so there's this
embargo model that's available on iOS as
well as Android where you can upload the
app they'll go through the certification
but then you get to decide when you want
to release it and so what we do is we
just keep submitting so we always have
one that's available to be released and
then marketing and product sort of
decide wedyn is an optimal release time
and that's based on PR timeline schedule
timelines that type of stuff so it
separates verification of the build and
submission to the App Store from launch
time and gives us huge benefit because
then we're not struggling at the last
minute the apps and the servers they
deploy independently because we have the
screen based Jason stuff so those that's
version the URLs are version so because
of a pretty good API they deploy
independently we do two-week bakes for a
really big stuff right obviously this
model works really well when you're
doing a whole bunch incremental changes
if you're gonna suddenly we do two or
three screens in some significant way we
do a big big bake we use something
called keynote it's a company for
performance and availability monitoring
from an external point of view so we
obviously do a lot of performance and
availability monitoring inside LinkedIn
but we also like to have people poking
at it from outside like that are not
associated with LinkedIn because
sometimes you know our tools lie to us
so he know keynote does that it
has devices where it's polling the
server as well as sort of like poking
things and then gives us information we
use device anywhere and you test for
compatibility testing so device anywhere
has a plethora of Android devices and we
don't want to buy hundreds and thousands
of different Android devices and believe
me there's lots of variations so you
kind of give them a version of the build
and say run it and they give you back a
report that says it worked on this
device didn't work on this device
crashes the test you test we use it's a
crowdsource testing model so a lot of
times especially at the scale that
LinkedIn is at when you have millions of
users usually the tests we find when our
testers run it are not the test that our
users find or not the bugs that our
users find and so what we end up doing
is we do crowdsource testing so we
literally just give it out to a few
thousand people let them test it and
then get their response back I talked
about our internal monitoring stuff for
QPS and uptime and then we do crash log
analysis so whenever the app crashes the
next time it launches at least for our
employees and enterprise builds not not
for consumers we send up all the crash
information and we try to track down the
crashes and that is about all the
presentation side of it I'm going to
walk you through sort of a live demo on
the iPad app a little bit okay
so let's uh let's start here so this
screen is actually
so this screen here is actually the is
an it is a native screen the reason we
did it native is to just effectively get
this that little transition
Wow so to get that to happen in the web
was really kind of tough so the rest of
this screen here is all JavaScript based
the top title bar is native but
everything else is based in javascript
in HTML so even this is actually
javascript in HTML using css3 animations
so there's nothing here that's native
based at all
the crossfade that you see there is also
in javascript in HTML so everything in
in this app we actually went a little
bit further we did actually outside of
that top little title bar and that and
this is we call this the expose screen
and this expose expose screen everything
else in the app is actually web-based so
you can kind of get a feel you can kind
of get a feel for performance it's you
know it's it's actually not bad there's
it can definitely be faster I think
that's something that we're gonna focus
on but you can get an idea of like even
the fades and even the sideways movement
so all of this stuff is you can kind of
see it can you guys see this there's
like a slight chop to it maybe I'm the
only one who knows this stuff there's a
slight chop to it that is different from
native so even the load more and this
type of stuff that's happening here this
is all happening inside I scroll hold
the refresh all of those aspects come
from I scroll
so that's a quick little demo you guys
can obviously play with the app and
you'll see you know you'll see like
slight so like you know what watch as
I'm typing the letters if they're
actually showing up at the right speed
you can see the the sort of glitches in
the way that the stuff sort of updates
you see did you guys see that you know
I'm just trying to try to point it point
out the places where there's some
slowness but overall the benefit that we
get of doing this so now you've seen it
was sort of run there what I'm going to
do now is actually go to tablet Linkedin
so now I'm running in the browser in
Safari
don't worry I'd changed my password on
purpose for this presentation and you
can kind of get a feel so you can see
the performance is the same in the
browser as it is and it's literally the
same code running in both places you
notice that we do have this so we still
can generate this it's just the
transition is slightly different
it's a crossfade transition instead of
going in and out but everything else is
fully running in the browser it's 100%
the same code there's no sort of
separation of a code base or anything
like that
so and the responsiveness is good I mean
it's it's good enough that for most
people it it feels okay and that's it I
I'll take some questions if you guys
have questions about about the app or oh
actually there was one other thing I
should probably show you guys before I
so one of the new features that we've
added and people asked me oh how did you
do this it's not native but we did it is
this so you can add your calendar so
this actually goes to the iPads calendar
it sucks in the calendar information and
then shows you who you're gonna be
meeting with by looking up LinkedIn
profiles you're like oh this must be
native this is not native this is also
JavaScript based the way we did that is
actually the webview we've actually have
like a little mini mini server running
on the device and the JavaScript makes
regular rest-based calls to the native
side to get the calendar data and then
uploads it so from the from the all of
the JavaScript codes point of view it's
either talking to a remote server or
it's talking to a local server was just
talking to a server know sort of
difference in a way that it works so and
that bridge layer that we're creating
and the wrapper for the webview we're
gonna try to open source it so that
other people can build access to
capabilities like this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>