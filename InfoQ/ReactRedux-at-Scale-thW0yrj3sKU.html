<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>React+Redux at Scale | Coder Coacher - Coaching Coders</title><meta content="React+Redux at Scale - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>React+Redux at Scale</b></h2><h5 class="post__date">2017-09-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/thW0yrj3sKU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to react and redux it's scale
if you're not here to talk about react
reacts or haggle with me about the
definition of the word scale the doors
over there or you can just browse
twitter either one the Wi-Fi has
actually been pretty fantastic today I
am turning on my remote and then going
to the next slide my name is Daniel
Cousineau I am Dooku's know just about
everywhere on Twitter this is me
standing in front of one of my more
recent projects it went pretty well this
time we only lost half the house I live
here in New York I run the front end
team and I've been helping out do some
things for the back end team at Grove oh
but for the most part sticking to the
front end team live here in New York
I run a meetup group called Queens Jess
for anyone anyone here local to New York
City New Jersey area anything like that
cool so I expect to see 20 of you all at
when next Wednesday at Queens Jas and or
Manhattan Dreiser Brooklyn is an awesome
family meetup groups so now that I'm
done plugging away I have been doing
react for about three four years
somewhere right around early like Oh 13
something like that and got in early
luckily I got in early on the flux game
so I got to cut my teeth when nobody
knew what they were doing but now we've
got this Redux thing and Redux is great
and everybody goes hey you're gonna
build yourself a large single page
application it's going to be in react
what are we going to be basing it on
we're gonna do Redux so that's the cool
thing so great you as the leader of your
team sit down as everybody wants to do
this so I'm gonna sit down and do some
research over a Saturday got your coffee
sitting down in your couch and you go
I've got a list of things to need to do
all right so I need to figure out how to
write a to-do MVC got it done now I need
to figure out how to write a production
grade application a bit of a gulf
between that reminds me of my favorite
professional drawing book how to draw an
out figure one draw two circles figure
to draw the rest of the damn owl so we
kind of need to fill in the blanks a
little bit and it's really hard to fill
in the blanks other than a little bit of
a personal experience so the way I'm
going to structure this talk is is
number one I'm going to talk about
kind of rules and rules are not
necessarily always presented as rules
but typically you read these tutorials
and they tell you things like always be
stateless always do this definitely do
this definitely don't do that and these
are what I call rules some of these are
common experience some of these are
common knowledge some of these you think
they're common knowledge either way
we're gonna examine those and the reason
why we can Samuel is there's something
to learn there's a motion and a form to
rules and sometimes you don't understand
why you're doing it why anybody
recommends them and certainly sometimes
they feel a little arbitrary like
they're kind of constraining and you say
to yourself why do I need to listen
these rules I'm in the real world and I
need to actually build a real
application but we have to remember
sometimes even though this to do MVC
tutorial and all these things are giving
you things that don't necessarily apply
to the application that you're working
on immediately kind of the motions and
forms that you went through and
following the rules can at least if you
remember why you did the rule in the
first place you don't have to follow it
but it can certainly provide some help
and insight into maybe what you're gonna
do and help guide you into when the best
time to break it is and then secondly I
cited this talk react and redux at scale
because I wanted to look really smart
and scale is still a big buzzwords so I
went with that scalability on Wikipedia
is defined is the capability of a system
network or process to handle a growing
amount of work or its potential to be
enlarged to accommodate growth when I'm
talking about scale I'm not necessarily
talking about computational scale this
is not going to be a talk about
performance that is either number one
the very hardest thing that you will
ever do because these are browsers or if
we're talking about having lots of users
congratulations
most of you here front-end developers
you already understand distributed
systems better than most back-end
developers do because you're
distributing your applications to
hundreds of thousands of thin clients
and it's running fully on there
congratulations you've already made it
what I'm talking about scalability in
terms of how do I get my application set
up so that I can actually grow it fast
enough without finding myself in a
squirrely of spaghetti code mess so that
further ado we're going to start I'm
going to go into part one react
and so this part I want to talk a little
bit about the react side of my react
Redux at scale then I'm gonna talk about
Redux and I'm gonna talk about the scale
part and this part is more of a
refresher how many people here are
already using react in production how
many people want to use react in
production how many people absolutely
hate react okay good that would have
been a bold move for anybody to do that
so there's gonna be a little bit of
refresher but some things that I find
that I constantly have to remind some
devs on that they kind of gloss over
because they don't need to so to start
out we're gonna look at a rule component
should be stateless this is a very good
rule
stateless anything allows you to
logically into it what's happening but
the reality is is while state is the
enemy it is also inevitable we're making
UI applications we're not making back in
applications that just need to pump out
a report and it's fine we're making UI
applications and they're a state
inevitable a users click the check box a
user has typed into a text box so we
need to remember that while state is the
enemy it is also inevitable it is fine
to use set state as long as you use it
proof as long as you use it the way it
is intended to be used as opposed to
just slamming it in there so we
recognize the classic form of set state
I have this is obviously hooked up to
some input element of some sort I'm
grabbing the value doing something to it
and I'm shoving it in a state this is
the most common form of set state and we
all know this however a lot of people
forget that there's more forms to set
state and they're more ways to use it in
react set state basically builds a queue
of changes that renders after each queue
of changes occasionally sometimes the
changes are collapsed into there so they
cause problems the second most common
form that you'll see of set state that
you want to encourage yourself to
remember exists is that the first
argument doesn't have to be an object
that's merged in a state it can be a
function that exists as a way to
describe describe the change that you're
making
so in this form you're saying rather
than saying this is the change you
described how to make the change how
many people here in early on in the
react made a checkbox that immediately
went to set State and they used this set
state object and then this dot state
inside of there and you keep click
that checkbox to see what happens and
all of a sudden it gets out of sync with
what you're actually clicking on it
anybody ever run across that bug alright
at least one person good I'm not the
only insane person here so whenever you
do something like this you especially
anything where you have like a lot of
dependents I call this - I tell my
developers any kind of dependent state
update if you need the state in order to
calculate the next state you use this
form you also have another common thing
that we found is is as we kind of had a
lot of logic sitting inside of the react
components we'd find a situation where
you would have set state and then you do
some sort of not quite related some semi
unrelated action immediately after after
a set state and especially if you did
one that included the state this is a
bad idea I put a red X over it just to
make sure that you really understood
that this is a bad idea can anybody can
tell me why this is a bad idea how sure
are you that this state that value has
what was set in the set state you
shouldn't be sure at all it's an
asynchronous thing so while state is the
enemy and while if you went with a
stateless component you wouldn't have to
worry about this if you were to use it
if you'd use it properly the second
argument to the set state is a callback
that says I guarantee to execute this
win set state is done and applying so
kind of the gist of this is quick
refresher let's get back on the set
state train but it's not necessarily an
evil and while you want to avoid it it
does exist if you use it properly it
becomes a little bit easier to use
another common rule is context don't use
context it hides complexity how many
people have actually used context in
their reactants how many people even
know what context is not that many hands
so in react they have you can pass down
state you have state you can passed on
props there's also a third way called
context the rule is in general people
will tell you don't use it there right
don't use it but sometimes some
complexity can be hidden you can open
yourself up to an opportunity if you
allow yourself to use context however I
will say one rule that I've had on my
team is only I'm allowed to confirm or
deny whether or not context can be used
it's kind of a foot gun
and so it's not anything to do with it's
not that I'm better than my team at
figuring this out it's that if you just
have one person kind of having a
conservative influence on whether you
use it or not it kind of helps we did
something cool in our applications so a
company I work for we build a learning
tool and we have kind of a semi WYSIWYG
editor and we have these concepts in our
lessons called cards and we wanted to
make sure that we added as many card
types as possible while making it easier
for developers to add card types and one
of the things is we want to make sure
the code that runs the editor interface
is the same exact code that runs the
view interface and we were able to do
something really cool with using context
where context is a way of rather than
having to do really long chains of prop
type passing we can do something
something that I'm particularly proud of
where we actually pass in a lookup
object through context and I can
actually create components based off of
this lookup object for those of you who
haven't spent much time in JSX in JSX
this first argument either turns into a
string which does a component lookup or
if it's a function name like if it's not
one of the components that it recognizes
it'll it'll just use an identifier and
since meta type text is an identifier
right there I can sit there and pass in
a component but the card that I've built
doesn't actually know what component
it's rendering just that it adheres to a
similar parameter so I'm able to do
something like create two separate
look-up tables of component types so I
just want to text here and it will
always display it or always show the
editor interface without the developer
working on the actual card code without
them having to worry about the
difference between edit and view mode
and then all I have to do is I have two
different components one passes the view
lookup and one passes the Edit lookup
and I'm kind of granted this adds a
little bit of complexity on top of this
system but it also hides a significantly
more amount of the complexity and it
allows my developers to go in and
edit and keep the internal code and
logic of the individual view cards
fairly slim so there's really not too
much react so those are like kind of the
two things whenever I talk to people
that do react a lot that they kind of
either avoid or don't spend a lot of
time doing they either try to avoid
state or context my advice is don't
necessarily avoid either those to use
them intelligently so we're gonna go
into redux how many of you get the joke
on this slide part two redux okay sorry
I'm really proud of myself for that one
so the most common thing I hear whenever
I talk to people who are having initial
struggles with redox is everything must
be in the store why must everything must
be in the store because it's a single
source of truth single source of truth
is the most important thing that you can
happen that you can have and this is
correct the single source of truth is a
very very important thing to remember
and have in your application the reality
is and this is going to blow your minds
a tiny bit you can have multiple single
sources of truth all a single source of
truth means is for a given piece of data
that I'm displaying on the page there's
only one and one location only where
that data is being written to infinite
number of people can read from it but
only one location only one path is
allowed to write to it so what do I mean
by multiple single sources of truth I
start writing my application I have say
a conceptual page right here with a
couple of individual components and I
have this that state that checked is
true so I have this small component here
and it has its own internal state
lifecycle just like we discussed earlier
this component right here is its own
single source of truth meaning anything
that means this not say thought checked
is going to pull it from that source and
the only thing that can update it is
that component it's a completely
self-contained single source of truth
this doesn't mean that I've pulled it
out into the store this doesn't mean
that I've done anything with it this
technically qualifies as a single source
of truth now the key thing is is the
other components don't need to know
about it we receive more product
requirements and we decide that maybe
it's
time for us to do something a little bit
more interesting with our interface one
of the first things you'll do is you'll
pull state up words and this is one of
the most common things that I suggest to
people is it's really fine
even in redux it's perfectly fine even
Dan Abramov says this is perfectly fine
in redux to have local state just pull
it up to the least common denominator as
much as possible in this case all of
these components need to know the
checked value so I pull the state up
into the parent component and provided
as props you'll notice down here these
are props and then we've got state these
components down here are not allowed to
change it the single source of truth is
this state checked is true at the top
level component meaning if any of these
components have anything different than
that one they're wrong automatically
there is only one source of truth and
then finally we can always pull out into
the store and use connect to bring into
it but at this point that value becomes
immutable for everybody who pulls it
from the store only the redux cycle is
allowed to change it single source of
truth there's also an additional play
location to store a source of truth
about states that a lot of people forget
exists and it's actually the oldest
location to store state it has been
around since CERN and the original web
window dot location your URL is a source
of states I see a lot of people anybody
here use react router anybody use
reactor out of Redux with it why I used
it initially because all the tutorials
told me to do it then I realized I
wasn't actually using it I don't need to
store the location in state there
already is a location it's in the
browser it winds automatically just
another single source of truth another
place to store it another general rule
is side effects should happen outside of
the redox cycle meaning anytime you
start dealing with redux you need to
make sure that all of your actions are
pure your updates are pure everything
like that no side effects meaning no
asynchronous calls a lot of people bring
in thunks or we prefer sagas they're a
little bit easier to test they prefer
that but you know the idea is side
effects should happen off the redox
cycle this is entirely correct but it
doesn't mean you can't have callbacks
one thing is because we were using sagas
we felt we had to keep everything inside
of a saga die became really difficult
for us to export data out and our team
was kind of bending over backwards and
writing wasting all this time writing
this extra code for something as simple
as I need to know when a persist action
is done and just display a little UI
banner this little UI banner is not
worth two days of developer time trying
to figure out the right should component
update and/or component will receive
props so we set up the standard in our
application where every action has the
potential ability to have a callback as
the last argument for the action creator
that our side effects system can call at
any time and we can do something as
simple as display or banner or even even
further down into the metal just simply
logging a timestamp to the server so
that we can start tracking titi use you
know when is the time to actually usable
as opposed to time to first byte
considering we're sending so much react
down I want to know usable not first
byte so a lot of these are as I'm sure
you're noticing a theme a lot of these
are I can write a pure application or I
can write an application that works and
ships just making sure that when you
write an application that works in ships
that you remember the reason for the
pure rules
another general idea is Redux stores
must be normalized for performance so a
lot of the examples say ok I've got my
store structure and I'm gonna store all
my posts in this array but then all of a
sudden you start dealing with how many
how many people have seen a Redux
tutorial that actually discusses the
concept of pagination from the server
it's pretty much non-existent right you
pretty much have to figure it out for
yourself as soon as you start exploring
this tecnique solution it's not
necessarily hard but you start to
realize I have to start normalizing my
store
I arrange my store by domain entities I
start making sure to deduplicate and all
these things and some people try to
avoid that they're like no if I can just
do normal you know if I can Dean Orma
lies it and have everything together
just per page it'll be fine in reality
we don't do any of this performance
it's raining this reason we do this
actually reduce complexity so we add
complexity upfront to reduce complexity
at the end I have a post on this this is
a very long URL that you're not going to
write down in time I'm gonna post it on
Twitter these slides are going to be up
you'll be able to find this where I talk
about this kind of concept of key
windows this is probably the the most
technical part of the presentation and I
may speed through it a little bit to get
to the end so you'll be able to find me
throughout the conference and ask
questions about it one of the things
that we did was we set a standard that
helped us out a lot was we set a
standard for the structure of any given
sub store if you will any given series
for the domain entities and we came with
a concept of key windows so whenever you
denormalize you just have a lookup table
you have your entities by ID the key is
the ID you've got your entity and you
can look this up you often need that for
speed problem is is sometimes you hit a
situation where you have two disjoint
sets of data like you have two disjoint
views of a particular set of data one of
them being paginating one of them not so
one example that I go to is is imagine
you have a user's page and it's a table
on Islands showing three users at a time
but I also have somewhere on this page
just playing a list of managers now if
I'm gonna duplicate this data say one of
the managers is in my paginated data but
one of the managers is not how do I know
which order the list is in and the by ID
all these kind of things so we came up
with the idea with key windows and all
key windows are as I'm just tagging
metadata about the data in my store I've
basically built an entire database in a
JavaScript object because why not that's
what we do as JavaScript developers
reinvent the wheel every 10 seconds so
came with the idea of key windows and
the idea being is is we can have our
nice normalized store D duplicated but
we have these key windows that store
information most particularly a list of
the IDS in order as it came down from
the server of the elements within this
window and then any other metadata we
want in this particular case we have is
fetching
we have our is fetching flag and then we
have our pagination data here and we
know that with browsers I've got a B and
C and then all managers I have
in a and then I can just continue on
without a care in the world the great
thing is is this kind of starts to add
depth and complexity to the store but it
starts to make things like your
selectors a little bit easy to work with
how many people here actually use
selectors to keep a wall between their
components and their store how many
people have heard of a selector function
I suggest everyone here that didn't
raise their hands look up a library
called a BRE select and read their
documentation to figure out what the
purpose of this library is I think if I
were to go back to 20 minutes ago and
add a slide I would have kicked out an
entire section and talked about
selectors I have regrets already and I'm
not even done with my talk but selector
functions are just an interface to get
to your store it allows you to extract
information out of your store in a
consistent manner but what we end up
having is is when we have this common
store structure we say every single
individual store must follow this key
window structure every single you know
section of domain entities like all of
my actions and reducers and API calls
for users all my action reduce AP calls
for lessons all these kind of things all
have the familiar pattern they all send
down the all deal of key window I can
always expect that just a name kind of
tagging the request you see here that
the key window name acts is literally
just tagging a request like I have this
fetch manager's that's just a specific
query for users and then I'm tagging it
as all managers and then every single we
actually have a single action that every
single one of our modules uses called
receive entities and that can just
receive an object of entities divided by
type and then you end up with some
boilerplate and literally all I do is
any time I fetch users I can update the
key window to say hey I'm fetching and
then receive entities no matter who
calls the receive entities as long as I
say these are the users that I'm
receiving I can shovel them in the store
and then update my key windows saying
obviously I've received some users I can
mark it as is fetching false and I can
shove all sorts of meta information into
this key window that I need to track you
can see right there you
also and so like it also makes a lot of
things a little bit more predictable I
need to show a loading icon' on the
table but not on the managers display
great
I can select users or fetching and I can
just say the all users is that fetching
right now or not I know exactly where to
go find this it becomes predictable
where do I find this and then it becomes
even easier to start adding on to it say
we've gotten to the point to where we do
need to store say an in-flight copy of
updating a user in the store if we
follow the key windows pattern we go oh
I can for example what we do is we add
an element that sits alongside by ID
that's drafts and we say that by ID is
canonical servers a canonical server
copy and then drafts is whatever the
user is updating in flight you'll notice
in the receive entities that we
eliminate what is ever in the drafts if
I receive an entity with ID a if there's
a draft Ray I discard it we have pretty
strict rules on immutability and so we
say if the server copy is newer frankly
we're ejecting the users copy out into
space because we don't right now support
merge logic and we don't want to write
the differing for merges but eventually
we can add that on that's an area that
we can easily bolt on and then all we
literally have to do is go update our
selectors and say you know what I'm
going to prefer the draft over the
canonical copy if it exists and then I
can do some really awesome things like I
want to do kind of an undo action and
get rid of the users input whenever I
need to undo I just say you know what I
just need to eliminate the draft and
that's it and I have this system so I
suggest you either find me during the
conference or look at the blog post I'd
be more than happy to go into detail
about all the different ways that we've
kind of bent and flex this and I think
you will find it extremely helpful to
your apps I could probably do a three
hour tutorial on this alone but I'm more
than happy to talk about it but the key
thing is is not the actual details of
what we did but the fact that every
single part of the story follows the
same structure and it becomes kind of
repeatable and predictable on how to
find things so now we're going to talk
about scale and the scale that is most
important to me is not the scale of can
I serve bytes fast or anything like that
it's can my team move up so one general
rule is you want to keep dependencies
low to keep the application fast I want
to use this great new library great
how many kilobytes is gonna gonna add to
my payload I want to add this lodash
thing great how many kilobytes is gonna
add that to my payload this is a general
rule to keep in mind that's really good
however it is time to let go of some of
our old nervousness and realize that
last year serving two populations in
underdeveloped countries for the most
part you can expect an OK internet and a
modern browser and it's fine to do new
things so the key is not to think less
about how do I send down less things how
to use less libraries the key is how do
I increase perceived performance so
there's a lot of people wanting to go
through and go oh well I've got this
number of seconds this number of
milliseconds and none of that really
matters how do I increase precede
performance does a user think it's fast
this it doesn't matter if it's actually
fast if the user thinks it fast that's
the only reason that's the only thing
that matters so one of the things we use
is bundling which if anyone here is
using webpack you basically get it for
free if you in p.m. install bundle
loader you can do lazy loading and what
we like to do is we like to group
sections of our app into more common
areas so you know a theoretical routes
component is I use a bundle order to say
okay everything that goes under the
admin I'm going to attach to the I'm
gonna use the bundle loader and I'm
gonna say a lazy loader which you can
see right here and I'm gonna tag it with
the name admin so that everything gets
grouped together what web pack will do
with this is this require will now
return a function that accepts a call
back and that callback is executed when
that function is executed it will call
the call back when the code that is at
the other end of that is fully loaded
webpack does this to you does this for
you for free so any of you who have
avoided moving to web pack for whatever
reasons and you want to get bundle and
go for this I think browser 5 might be
able to do it but it's probably rural
your own good luck with that and then
all you literally need is especially for
react router v4 is you just need a very
simple component that says hey listen
when it's loaded like when I'm loading
this code show a spinner otherwise if I
have it show the component and what
we're able to do is we're
able to say yes we have a lot of
dependencies yes we have a lot of these
things however mmm 80% of our users are
never going to visit the admin section
so any code that gets required in the
admin section should never be loaded for
the user and so we can increase
perceived performance for the set of
users that we care about and for the
users that we can explain away
performance problems we shove it all
under them so admin users are gonna have
to wait a couple of hundred milliseconds
longer than anybody else and that's fine
there's like three of them per customer
and so what you get is you get this one
thing if you watch the inspector down
here at the bottom you see I've loaded
this page and then now that I've clicked
into lessons you see boom I load about
361 uncompressed kilobytes over the
network right when I click on the
lessons tab and if you take advantage of
caching it gets even faster because
you'll see the whole application was
instantly and then it's 11 milliseconds
to load from disk cache and you get kind
of like these great performance boosts
where you can say the kind of most
common entry point in my application is
optimized into the primary bundle and
then all these secondary bundles and it
literally is just as simple as that
bundling feels complicated but it's
literally as simple as having this once
and this in a bunch of different places
and you're done and if you build your
application to think asynchronously it's
really not a hard problem to support
another general rule is is render
up-to-date data I need to wait for all
of my HTTP requests before I render my
data I need to make sure everything's
perfect that I'm not showing bad data to
the user most of you probably know this
but this is kind of a healthy reminder
to remind your team you don't need to
render up-to-date data you just need to
render something just get something out
to the user again perceived performance
when you load up Facebook do you have
your posts on your wall no you have a
shiny box that flashes at you for a
little bit and it fills up that space
for those of you who are paying
attention in the previous recording you
may have noticed whenever you hit a
certain section you see everything
popping in here we at our team our
front-end people do not work on any
back-end services and back in service
network in front-end services as a
result these right here our back-end
calls these are actually so there's
three calls there's a call to get this
data and then we've prefetch the data on
the other sub tabs so that we can
these kind of like row counts and you
see how they kind of popped in a little
bit later but most of you probably
really didn't notice it until I pointed
it out and the users definitely don't
notice it which is great because this
request was super slow it's like taking
like on an average of a you know a
second or two and we can now give back
in the time they need to go in to
optimize it we don't have to optimize
immediately and it's not our problem and
then another thing that we can do is we
kind of fill in holes as we pop in the
extra data so here we see loading the
home page where we pop in and then you
notice everything start popping in this
actually happens fairly quickly because
we have spent time optimizing it so if
we step through you'll see that we start
out if is it the very instant that the
application so the instant you see this
the javascript is executed and has
initialized all the Ajax requests but
nothing is returned there is no data in
this application you see no data I have
no upcoming assignments my calendar is
empty and I've got this big blue square
and I have all these there because
that'll have a lot less jitter when
everything's pop in so you see the very
first request that completes this the
what are on my current assignments that
pops in right there and you kind of
barely notice it pop in I actually as I
was putting the slide together I notice
there's a problem with the fonts and I'm
gonna have to go talk with the team that
does this page to figure out what's
going on with the fonts however you get
this really nice pop of there another
bug I noticed is is this is when we
actually have the lesson data but we
don't have the image yet and it's white
and that's something that eventually we
can optimize in the future Twitter
started doing this where they calculate
the most common color and shove that in
the square while they wait for it to
load in and then finally the image pops
in and you have the application this
data we didn't wait for it all to get
done actually in some of the first
iterations of our product we waited for
all the homepage data to get in before
we rendered it and people kept
complaining that was slow and then we
split it up and we just rendered
everything as we got it and even though
the total time was the exactly the same
people stop complaining and in fact they
were like oh thanks it's so much faster
now so perceived performance is really
the only thing that matters is just
render it in if you've got it rendered
if you don't don't and if you already
have it in the store from a previous
request render the old data before you
overlap it with the new data it's fine
as long as you update it with the new
data
so epilogue scale there's another
section of scale I want to talk about
which is has really nothing to do with
any of the react redox that kind of
stuff has everything to do with the
tooling you build around it so one of
the general rules this is more less a
rule more of a definition scale is bite
serve users concurrent how big is your
application how many people do you use
it
I do not define it this way in my
opinion scale is responding to bite
served in users concurrent how well do
you respond to going from 50 users to
500 from 500 to 5,000 how well do you
respond to that and in my opinion the
best question you can ask yourself to
get set yourself up for success for
responding to scale is how fast can you
deploy and while some of this is on your
infrastructure team and some of this is
on your back-end team for the most part
there's a lot that you can take on your
team this is the quick start from our
front-end repo at work there are seven
steps half of them are crap steps one of
them cloned this repo another one add a
line to your hosts file but in general
this is everything you need to take a
Macbook that you brought up the mac
store unwrapped it turned it on logged
in and installed node in yarn once
you've done all of that these are all
the steps you need to get this up and
running on your machine I have an
internal KP I have no project I'll ever
work on should take less than 15 minutes
to start out from a brand new mat I time
this last night I basically cleared my
home brewing yarn caches and then ran
these steps and rather than doing the
steps in there I ran a production build
which does file minify CSS file the
server via Babel and then pile minify
gzip via a web pack and it took a grand
total three minutes to have a production
ready version of the application running
on my machine and this is critically
important you may you may think that's
all that's a nice to have but I
shouldn't spend any time on it what this
means is is my machine crashes and I
need to borrow a loaner
I have only lost 15 minutes the time it
takes for me to log into the loaner and
get on it I on board a new team member
there is no excuses I should see a PR
open at the end of day one I'm going to
give you a bug that is an easy software
to bug that allows you to go in and just
see it but it should be done by the end
of the day there are no more
environmental
why these things can't run this also
means my CI builds run like that and so
I'm able to kind of get these things up
and I can iterate fast another thing
that we started using this is kind of a
humbling moment for me because I used to
make fun of all the time of the kind of
like old Flickr engineers that evolved
into like you know the Etsy's and the
slacks of the world used to make fun of
them for using feature flags and I was
like just use get branches and get flow
and all these things I've come to
realize that I was so so very wrong and
they figured this out about 15 years ago
so we started using feature flags in our
application and I really cannot upsell
this concept enough so in our
application we have this component
called feature we say this is the name
of the feature if I have it render this
what's inside the children if I don't
have it render what's in the fallback we
could probably come up with a more
elegant API we maybe not we use a
third-party service and I'm going to
plug a third-party service that we are
paying money to but there's a service
called launch Darkly that we use to
handle our feature flagging for us and
it's really great it allows me to do
this really cool thing where I can have
basically two versions of my application
running inside the same codebase and
whether or not you see it it's based off
of whether or not you have the flag so
in this particular case we were working
on upgrading our nav we this used to be
our nav right here and we're like we
don't like that we're gonna move over to
a different nav and we want to kind of
slowly roll this out to first internally
only and then a couple select beta
customers in yadda-yadda-yadda
and because the launch our Glade is a
feature for service and events and all
these kind of things I could do this
really cool thing where you know I've
got this old menu and then I we have a
responsive nav feature and I go you know
what I want to have it I'm gonna default
to true I go in and I click Save Changes
and boom I have the new nav on my thing
because we all took the time to build a
declarative you know functional
application it's super easy just go oh I
got a new flag re-render and show the
new stuff occasionally you have to do
something slightly more complicated to
go oh i need to fetch different data now
that i'm on this thing but this allows
us to decouple deployments from rollouts
and why is this important think of your
typical use case you've got two teams
working in the same codebase right
you've got one single master branch
you've got two teams working on it
and so we got the situation where team
one working on merging feature a and
then they run a deploy team two working
on feature B margin and master and
deploy and all of a sudden customer
calls in and something about feature a
is horrendously broken go oh time
to hit the stop button clacks ons firing
role back to the previously known good
build congratulations we can all roll
back to the previously known good build
however there's this entire time period
where team two could potentially merge
feature C into the master branch but you
can't deploy the master branch and you
can maybe branch off of the old one and
then eventually merge it back into
master once the hotfix is fixed
everything but unless you have like two
or three get gurus on your team this is
probably gonna turn into a nun mirja
Boleyn ight mare within about 10 seconds
and while we have some really great
developers not everybody is a get guru
and that's not something that we can
handle when we introduced the concept of
feature flags what we ended up with is a
situation like this we merge feature
area we deploy we rollout feature a all
of a sudden oh crap feature a is broken
for everybody just roll it back just
flip it back - nobody gets this flag the
application switches back because we
took the time to make sure that these
two versions of the feature the old and
the new could live same time at the same
time we just roll it back without a
deploy anything like that team to just
operates just like they were going
completely uninhibited by anything
happening on team one which allows the
velocity and the security of deployments
on our team to just go straight through
the roof we can confidently deploy I
think we do to production deploys a day
and I consider that too few we can do
this all the time because of these
feature flags that were able to turn on
and off and react immediately to change
and then a final bit is there's not
really a lot to talk about but like as
you're working on a team especially for
those of you that a leads of your team
you kind of have to think there's
systems thinking how does my team work
together and one of the things that I
found is oddly enough how can i optimize
my directory structure around team
responsibilities we can all work in the
same repo together but we work a lot
better the less often that we write to
the same files as each other even though
get is really great about merge
conflicts you still want to avoid
with at all possible because sometimes
somebody forgets to manually resolve it
the right way
so even look at the layout of your files
in your application and how can the
structure of that enable my team to move
faster to deploy faster to get to a
really good point where I'm able to
actually scale up by releasing new fixes
and those kind of things so I have some
final thoughts just to kind of wrap this
up a little bit I know that this was a
little bit scattershot and this was just
a lot of things I learned but I only had
40 minutes and I have the rest of the
conference to answer your questions
strict rules rarely 100% apply to your
application but the key thing is
remember the purpose behind the rules I
just spent a whole bunch of time telling
you how much local state was fine and
how local state owned components as you
pull them up there's multiple single
sources of truth but there's something
to be valued from understanding the
whole like oh you're your component
should be functional stateless whatever
and the purpose behind that rule is is
so much easier to intuit and encounter
logic bugs in a stateless component that
is to be stateful so if you are going to
be stateful recognize that you are
sacrificing that ease of debugging and
keep that into account when you decide
to buck against what is considered
common knowledge and at least keep it in
mind you're all smart enough you know
how to figure this out just remember to
keep that in mind it's not that the
rules don't apply and the rules are
wrong it's just that the purpose behind
the rules is still there
code behavior should be predictable and
intuitive all be realistic about the
problem you're actually solving solve
the problem that you have this week do
not solve the problem you think you're
going to have six months from now
because products going to come to you
next month and completely change the
entire roadmap and what was the point
and then the predictable and intuitive
it's key for your team it should be
really easy to go oh I just need to go
to this area of this thing inactive as
long as I can apply the same search
logic to go from different parts of my
application there's less you have to
explain less stuck in your head and the
faster your team can kind of move and
scale your application with you and the
more intuitive will your application
will be and then you will not get it
perfect the first time optimize your
processes for refactoring the key thing
is is the reason why I say don't worry
about the whole don't use local state
just get it ship it out just make sure
that you can go through and remove that
code and fix it to be the perfect thing
later on optimize everything you do for
your ability to undo it and refactor it
later as opposed to the perfect way that
somebody said on a blog post on that
orange website you should do it so with
that being said I am 15 seconds over do
we have any questions
okay so the question has asked is how do
I manage features that have been
switched off it's been fully deployed so
what we do is we have an internal
process where we set up developers are
the ones allowed to create a new feature
product owns the lifecycle of the
feature meaning as soon as the developer
creates the feature and has the code
behind it product owns who it gets
rolled out to when product has decided
that it does not 100% rolled out we set
up a chore ticket we use clubhouse when
you set up a chore ticket and we say at
some point in the next sprint or two
when we have time go in and delete all
code related to that feature branch
light or that feature flag so any like
those feature components look them up
and then remove all the old code and
remove the feature component so that the
only code that exists is the one that
has been 100% rolled out once you've
deleted all the code from the codebase
to clean it up to where only the new
stuff is in there and the old stuff has
been deleted we deploy that and then
launch Darkly their competitor they have
a competitor split that io does the same
thing they'll tell you how long it has
been since a client has last requested a
feature as soon as we've hit seven days
of nobody requesting the feature we can
be reasonably confident that even the
people who leave their browsers open
forever have been upgraded to the new
version of the application at that point
when it has been seven days since last
requested we go in and delete the flag
from launch Darkly so we delete the old
code first wait for to confirm that
everybody has it then we delete the flag
from launch Darkly so typically it's the
cycle of new feature flag the deployment
is about a week or two like by the end
of the Sprint everything's out rollout
typically takes about another week or so
but the actual teardown process usually
happens about a sprint or two later
assuming we use two-week sprints so when
I say sprint two weeks so any other
questions
all right well we'll let everybody go
early for lunch so thanks everyone</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>