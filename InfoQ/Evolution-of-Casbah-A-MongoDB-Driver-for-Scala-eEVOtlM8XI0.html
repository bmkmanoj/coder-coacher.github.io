<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Evolution of Casbah: A MongoDB Driver for Scala | Coder Coacher - Coaching Coders</title><meta content="Evolution of Casbah: A MongoDB Driver for Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Evolution of Casbah: A MongoDB Driver for Scala</b></h2><h5 class="post__date">2012-03-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eEVOtlM8XI0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so those who don't know me I'm Brenda
McAdams I am among other things with
Skeletor but I say that because I seem
to be the person at 10gen who knows
every language we support and so I get
stuck with all the weird stuff I think
I'm in charge of our hassle and Erlang
drivers now - I haven't done anything
with them I am a developer tension our
main product obviously is long way to be
among other things we use a ton of it
lasting products for all our stuff we're
using JIRA confluence we until recently
we're using bamboo but we had you know
we changed a couple things up it's still
in use for some things for us it's a big
part of our public facing stuff for the
open source so you know it's good to be
here and have these guys supporting
something that obviously it's going both
ways they've launched a product on Scala
and Mongo a lot of what's been
successful Mongo is being able to have a
good wiki and a good bug tracker and
everything else so this is really a bit
of a talk more about me learning Scala I
did this talk originally at Scala days
last year it's cleaned up and evolved a
bit since then but really the idea is
it's not just you know what is Kasbah
but how I got where I was because when I
started writing this driver from long
ago I hadn't written any Scala at all
and so it's an it's an interesting look
especially if you haven't done as much
scholar you're starting to dig into it
or digging more advanced points at some
of the mistakes I've made some of the
things that work well and a little bit
of a look at the open source process so
I'm not actually going to start with
David Copperfield here but I am an
autodidact so I don't have any formal CS
education everything I've learned I've
learned on my own I spent about a
semester in college it went really badly
studying criminal justice and psychology
obviously that's not what I do now but a
lot of stuff I do spend a lot of time
reading you know CS history you know CS
theory I'm a big fan of history as well
I mean you look at some of the stuff
we're repeating now the actor concept is
from white paper in the 1970s this isn't
new stuff it's just that we're going
back to this idea of having multiple
processes we have to deal with a lot of
these ideas are emerging again so it's
important to not ignore what we have
before and I try to bring that in
sometimes for me it's a little tough
because I don't have all this formal
theory I did start on this level you can
though which for those who don't know it
is a Commodore 64 and was even you had
to run weird commands even to start
program something like lodestar eight
comma one which turns out to mean load
everything on device eight which is the
first external floppy drive for me it
sort of dug in to starting a program and
understand what's going on fast
forwarding quite a bit though really
this started in about 2009 I was doing a
lot more work especially with data
analysis working with quantitative
analysis people to take basic data
models they put together and scale them
up for big processing so we were
starting to look at different database
backends because stuff like sequel
server couldn't do what we needed and
that's when I started digging into a lot
of new new database stuff like Mongo
Cassandra all these different pieces
playing with them getting a feel for
what they could do and also getting a
better feel suddenly for all this
functional programming because you're
working with quants suddenly you're into
this idea of everything is a function
and you're just chaining functions
together and you go back to looking at
something like Python and everything
like lambda starts to make more sense
and so it went from there and so I
played a little with c-sharp which i
think is why Scala made sense in the end
that year I'd put together the first no
sequel conference for New York and we
had about a hundred people which was as
a as a point of reference if you're
gonna put a conference together and post
it to hacker news before you go to lunch
put a cap on how many people can sign up
based on how much space you've actually
been assigned by your sponsor because
they came back from lunch and there were
like a hundred people signed up and we
had space for 15 this was actually the
first time I had worked with ten Jen
because they were nice enough to sponsor
it and didn't like stab me or anything
else but instead say okay we'll find a
venue to read I also around like about a
week after that the job I was at sort of
imploded and I found myself looking for
working it up at Novus Partners which is
where Cass ball started and they were
looking for a lot of solutions to
different problems one of which was in
some ways a database solution but also
the Java they had they had a lot of
libraries and calculations and other
things that didn't necessarily scale to
the level that they wanted and so I had
been doing a lot of reading including
things like
the Scala books and Scala seem like a
good idea because suddenly hey here's
this language we can reuse everything
that's already there I know the JVM well
cuz I've spent enough years doing Java
let's take a stab at this and then
obviously I was there for about a year
and ten Jen lured me away to come and
work on the Scala driver I created while
I was at Novus full-time which is what I
do now and among other things I get to
play with Scala for a living so it could
be worse Novus originally like I said
they had a lot of problems and they
needed new tools for which Java wasn't
always the answer there were even things
like they're doing count financial
calculations where they wanted more
control over formulas it would be great
to have portfolio a plus portfolio B and
define what that means which is
something that we get was Scala with
operators and everything else and Scala
really was the right tool
I had read Alex Payne and Dean Wampler
look I had not written any code and so I
sort of just started writing things and
started showing it to people and slammed
it in before anybody could really object
I'll admit akka was really a big part of
this so obviously in the scholar world
if you didn't know apparently Chuck
Norris's Victor clang as his emergency
contact good guy to know if you're ever
in trouble also there I he showed me
there's good Indian food in Sweden so we
were doing a lot of stuff with custom
formulas dsls and other tools so I
started to fiddle with a lot of things
but I also started fiddling with Mongo
because it seemed like the right tool
I'd worked with it before it seemed like
the right tool for certain parts of what
we were doing is essentially taking you
know the terabytes of data were
calculating putting it up on the side
and having a little slice of the
important information and we needed and
having a cache but unfortunately when I
started to look at what tools were there
none of them really fit what I was
looking for and I tried to avoid that
I'm gonna write my own but I never could
get anything that was out there to work
the way I wanted and rose to me took a
lot of things that I started to build
initially and ran with it and I even had
worked with Rose before some of you may
know her she's somewhat quiet on Twitter
but she's does a lot of the development
and maintenance on salaat which is one
of the big mapping libraries so this
started really with nothing looking the
way I wanted
I had a first played with Mongo in
Python and your Python is a very dynamic
language there's some flexible syntax
and Maude was pretty dynamic you know we
don't have static schemas everything's
flexible and the tools that I was
playing with for swift Scala and Mongo
really weren't where I wanted them to be
I had my own picture in my head of what
I was trying to do and a lot of these
were OD M's and I'm still I'm personally
still not convinced that ODMs are a
completely useful tool because I think
well soon as somebody has something that
maps to an object they do everything
with an object mapper I think they're
really good for certain things like hey
I want my user data to be a mapped
object that's a great use for an OD M
but I don't need everything to be an OD
M so for what we were doing at OD m was
completely the wrong answer the Java
driver existed but it had no support for
any scholar sugar any tricks any of the
things I could normally do you couldn't
even use apply methods and there was
something called sky Mungo which
eventually was rolled into lift and
became lift Mongo in 2.0 but it was
completely a no DM or Jason tools and
still not quite what we were looking for
and then there was something called
Mongo scholar driver which actually the
author has recently announced is
deprecated mostly because he said you
know Kasbah fills that hole it's
supported he's rolled out a new library
that haven't had much time to play with
called shapeless I think it's called
shapeless which is a or something what's
that
no no shit's maybe that's my was I
forget the name of it it starts with an
ass it's the guy who did Mongo scholar
driver o sinka on Twitter or github I
think and it's based around the Java
driver as a different way of doing odn
but now he's focused on object mapping
so here is initially when I started
really what Mongo looked like from
Python which is to me that gold standard
this is what I'm looking to have happen
I want things like I want to be able to
define a document without having to have
a whole bunch of I mean I can't even
really properly do multi-line statements
in Java you know I don't have multi-line
strings any of the other things I'm
looking for and even things like the
fact that you've got a little better
handling of dynamic types because you
know if I pull out the value age from a
document
and pull out the type it tells me it's
an in and I can pull out easily the
value of an array and you know Python is
sort of automatically handling a lot for
me that we may not get in something like
Java using Scala initially when I
started from just having the Java driver
this is pretty much what you have you
know it's a slightly big difference here
which is you know here where we have a
nice clean single block and then all of
a sudden we're declaring object after
object which is the Java model it
doesn't necessarily mean that it's sane
and we get into trouble here if we pull
out age it's declared as any ref because
we don't actually know what it is the
document is basically a map of string to
any or in this case I think string to
any ref at the time so what we get out
we have to know what we expected to be
in cast it and hope that it gets where
it's supposed to be but it's still not
entirely perfect this is one place where
I actually really strongly object it's
something that I found with Scala where
the way the casting works
I found that personally the postfix
casting is really bad because you don't
read it the same way you know I read
left to right which means that I want to
read you know basic ddos'd
doc interests whereas when it's sort of
at the end it's not always clear and
it's a little bit messy so part of what
I thought about was really tight on what
type safety I want compilation but it
shouldn't make me want to bang my head
on my desk which I found myself doing
frequently there's really nothing wrong
with that syntax if you're writing Java
most of us are writing Scala not because
we want to rewriting Java but because
it's a tool that's more flexible for
things so we've got a lot of
expressiveness
we've got fluid syntax and it's you know
it's very beautiful in a lot of ways you
write good clean code it's got its own
flow to it and I started trying to make
Scala look like Python in Mongo
obviously I you know I haven't made
Python in Scala but more some of the
same things that worked really well for
me from Python I wanted to work the one
other thing though is I didn't want to
reinvent the wheel you know the network
layer and the the libraries for power
the binary format in Mongo already
existed on the JVM as much as possible
there's no reason to rewrite those from
scratch because then every time there's
a change in the Mangla server or a bug
found I've got to fix it in two places
now I maintain both drivers and I have
to fix it in two places if I had done
that so I kept the network layer and
really just build a set of wrappers and
really added syntactic sugar which is
why originally this was called Mongo
Scala wrappers mostly cuz Mongo Scala
driver was taken but really it was just
a set of wrappers and so today this is
much closer to what it looks like you
know I have something that's somewhat
close to what I really wanted to begin
with which is that I can use the in fix
notation have everything flow in a nicer
way there is a Mongo DB object
constructor and I'll show you why in a
few minutes because I tried doing tuple
parsing to begin with and it turned out
to be a really horrific evil idea and
things like the 2:8 Scala 2/8 collection
factories and builders we fully
implement now so you can actually have a
factory constructor you can build all
those patterns that you used to use me
with constructing a Mac or something
else in Scala can more or less be
applied to the driver because you know
api's and libraries should fit into
their language as a natural thing it's a
philosophy we tend to follow at engine
with our manga-drivers we're not trying
to write a driver that's a C driver in
every language we're trying to write a
driver that's a Mongo driver but feels
like the language you're using but if
you're a Python user and you use our
Python driver it should make sense
within the context of Python and
hopefully the same thing for the Scala
driver if you used - oh this is how I
work with a collection in Scala then a
driver that provides a collection
interface should follow those api's and
one of them is you know we do have an AZ
now so you can actually say doc dot as
what you want to cast it at and then the
name so it reads more fluidly you're
saying from the document get this field
as this value and this does some casting
internally there's been some
improvements in the last three weeks to
make it compile time safe as opposed to
run time safe where I had had at run
time safe and miles Sabin and John
Anders Tegan sent me some patches that
fix it to catch a compile-time if
certain things haven't happened it's
good thing catching these things at
compile time saves you from runtime
crashes and you know some of these other
things they cast nicely they flow
there's also an experimental dynamic
support module that Jorge Ortiz put
together four to nine so you can do like
Doc got a JH and then call dot typed and
cast it as an int if you wanted to I
don't ship that by default but it's
there for people want to compile it my
rule is if you can figure out how to
turn on scholars dynamic supporting the
compiler the code is there for you but I
will not give you this tool by default
because I'm not convinced it's a good
idea because I don't want to support
people doing weird stuff with this
there's also a fluid DSL so if you've
seen Mongo before with the syntax like
this so if I'm looking for a document
that's greater than or equal to 15 and
less than 35.2 and doesn't equal 16
which is a little bit of a weird query I
admit you can you know you basically
build up a structure of documents so you
yo it's nested and we've got these
operators which fit within the
JavaScript origins of Mongo and that the
dollar is a special symbol what I found
is there's a lot of other drivers that
we're using like their own query DSL
trying to be like you know a sequel but
I know the Mongo query syntax really
well I didn't want to have to keep
looking both things up so I put a DSL
together based on here's the mom listen
Dex and I sort of get away with using
the dollar signs because I'm careful to
never name an operator the same as
something the Scala compiler creates but
you can now do a fluid construction like
this we can say foo space GTE space 15
and that compiles down to a Mongo
expression so what you get is actually
the equivalence of this and this lets
people you know you don't have to have
levels and levels of multiple
constructor calls in order to construct
a query or something else and it just
makes it easier to maintain and easier
to read the code when it's on the screen
we you know for something like not
because not actually takes a whole
document under it for a query you can
actually do something like this where
it's Ana nested block using the implicit
underscore and this all flows outward
and it's actually fully tested now I
beat myself half to death writing tests
for every single case
months ago I mean there's a number of
others that come into this so there's
things like noir which have a number of
possibilities that come in and this is
all stuff that's built up over a few
years but it's all there and it's an
example of the kinds of things that you
can pull off easily with Scala iteration
within scholar works fine now as well so
it did take a while to get here I think
the initial release that I put out was
February 2010 when I put this these
slides together for Scala days last year
I was slightly horrified to find out
there was not a single test in the
initial release to be fair you probably
can't read this back here that says
initial import it compiles and reflects
the working code in trunk but doesn't
have documentation or tests not for
public consumption use at your own risk
may or may not blow your system up so at
least I was being honest but this really
was just trying to get it out there get
it out the door for me gonna look at we
hired a couple people at Novus over that
time and people like max Ivanoff got
involved and really helping develop it
that by July we got a release out
January the next year because I was at
tangent when I got detention you know
the first thing I did was really step
back look back at what I had done and
try to clean it up as much as possible
today it's pretty solid it's used in a
lot of places including these guys just
mention they launched me a project
yesterday on it I'm finishing up Kasbah
3 now which is really things like
getting rid of any last vestiges project
originally started on Scala 2 7 so
didn't have things like name two default
arguments cleaning up all these
overloaded because you know methods and
making them one flat method cleaning a
lot of things up bug fixes better tests
etc and there's a milestone 2 of that
available now if you want to grab that
so now to really dig into some Scala
code if nobody's seen this episode of
South Park I thought it was appropriate
so really talking about you know pimping
Java code syntactic sugar internal DSL
and all the things we're gonna do I'm
gonna try not to sit here dwelling on
code slides which are somewhat hard to
read they're sort of part of the story
but we can go through those as needed
this is actually what the first pass of
Caswell looked like
I had this bright idea of there's this
whole tuple constructor system and
scholar I'll just leverage that and make
that work it turned out there are a
number of problems here including the
fact that even option is Technic so
there is no base class for tuple you've
got to pull one through tuple 22 there
base classes product so of course I
wrote an implicit conversion that looks
for product which seemed like a really
good idea until the first time that the
implicit accidentally picked up option
which is also a product as are several
other things built into Scala
this is also a really hairy ridiculous
piece of code which tries to identify
things that are only tuple twos but it
has to do that at runtime and make sure
that it's arity is only two because they
don't have some base class that we can
work off of not the brightest idea it
worked for a while this was one of those
as soon as other people started touching
the code they started sending emails
asking what I was smoking because this
really was you know and at the time this
seemed like a really good idea but this
is sort of you jump into a new language
the first thing you try to do is
something very clever um it didn't work
in this case because then it you know in
a strongly typed language like Java we
can hammer all we want a square peg is
not going to fit into a round hole
you're getting out the chisel and the
hammer maybe you'll make it fit but when
all you have is a hammer everything
looks a lot like a thumb it'll loosely
or a dynamically type language like Perl
and Python and Ruby you know round holes
can be convinced to accept square pegs
with a couple pints of liquor and
stealing his glasses in this case I
don't think he's gonna like what he
finds in the morning I the more I've
worked with Scala the more I think it
gives us a lathe instead so we have this
idea of having a very fine-grained tool
that can let us shave the edges and make
that square peg fit where we need it to
we have things like implicit sand type
classes abstract and parameterised types
what you're really you know with
covariance and contravariance we have
some really flexible things you know you
look at what you can pull off with
Scala's type system versus Java s-- and
its heads and shoulders above structural
types which not a lot of people use I
don't use that much either but they're
sort of like duck typing
I am a fan of duck typing of the concept
so I've sort of somewhat concededly come
up with my Three Laws of library design
and they are this am I helping my users
or am i hurting them and the corollary
to that is do I have any idea who my
users are because in a lot of cases I
started getting emails from people and I
went wait they're using this code in
production it's probably not a good
thing I should see how well this works
but this happens a lot you know once you
put the code out in the open source it's
out there people are using it and you're
stuck with whatever they choose to do
with it
have you accounted for all the use cases
because this is really important if you
build a library for yourself the problem
is that people are gonna start using it
in ways that you didn't account for and
that means you've got to have type
checks you've got to have compiled check
something to keep people from doing
things that are stupid or that will get
them in trouble because the worst
possible thing is things like silent
corruption or crashing in the middle of
production or crashing in a demo and
most importantly do I have any idea what
the hell I'm doing because in a lot of
cases I don't think I did at the
beginning so the rule is supposed to be
measure once cut twice but I'm not
really I'm not really a carpenter well I
haven't I don't think I could probably
put a shelf together even if you gave me
all the tools in the wood so a lot of
what I love about Scala is the compile
time checks they don't keep you from
misunderstanding things hurting your
users or just screwing up you know you
can catch things that won't work but it
doesn't mean that there aren't certain
things and especially when you get into
things like the runtime erasure on the
JVM you can think that your code
compiled all you want but the reality is
there's no information at runtime about
what the type of sequence is and so
you're kind of stuck with what's there
there's fun with type inference I'm one
of the early mistakes I made Daniel
speak has ripped me on this one a couple
times because he's pointed out that yes
type inference is good according to
scholar style guide but not if you're
writing a library if you're writing a
library every single method should have
an explicit declared return type and one
of the reasons why is you can do things
like Val x equals and then an if else
else if block
and it will capture the value but if you
don't declare the type what scholar will
do is it will choose the most
appropriate superclass of all the
different possible return types if none
of them have an appropriate superclass
your return type might be any or any
rest and so I got bug reports early on
of things like I expected X to come out
of this method but instead I got Y which
doesn't make sense or some intermediary
abstract type that I had declared or
something else it's really important it
doesn't seem like it we get in those you
know when you're putting a library
together this really made a huge
difference for me um even things like
working with manifests now manifests
seemed early on to me like the panacea
for solving every problem with type II
ratio but again they only get you as far
as did you catch every possible mistake
at compile time or is this still gonna
blow up at runtime
now manifests are really just generating
a bunch of paths without you having to
cut and paste code yourself
it's the compiler doing cutting and
pasting for you and you know knowing and
understanding the fancy features but you
need to really know when to use them and
paraphrasing things I've heard a lot of
climbs is that I think the difference at
this point between a junior and a senior
programmer
is that a senior programmer should have
the wisdom to know when not to write
code when not to pick up that fancy
feature and hammer away on it and that
really makes a difference and I think
more for me lately with cats but I've
been trying to pull code out more than
add code because there's a lot of
simplicity that can be rolled in so you
know I spent a lot of time learning new
features stuff that was undocumented
finding whatever blog posts I could code
that I could dig up one of the questions
that I had early on was how do I have
this sort of sort of type safe query DSL
where users can have custom types so
early on that dsl just really allowed
any type through the door the problem is
there's limited types to what an
operator like greater than or less than
can support but you also were on the JVM
where it's possible that some user has
their own custom definition of a number
and a number is a perfectly valid type
for greater than or less than
and as long as they tell the Java driver
how to serialize their number class it
can be stored in Mongo
but if in their query DSL they reference
this number class that Kasbah didn't
know about to begin with they're
suddenly in this situation of there's
this really cool query library we'd love
to use but we can't use it because our
types aren't accepted and so I started
with you know really hard coding this of
okay well I think string date and eval
DB object and map of string and II
should be valid operators here but this
is very much hard-coded it doesn't
account for what they're doing
believe it or not this is actually a
much better solution to the problem one
of which is yet again the constant trap
I keep falling into and Scala is trying
to find that magic shortcut to not
having to enter support for tuple 1
through 22 the right answer is to write
a quick Python script that generates it
for you like the Scala compiler has and
get over it
so in this case obviously from here to
here we're defining how to handle tuple
1 through 22
because in Mongo and a list of things
can be less than a list of other things
we also support string DB object which
is the Mongo idea of of Mongo document
or the Java drivers idea of a Mongo
document which Scala extends in array
but we also have iterable here and then
there's this last thing which we're
going to dig in a little more detail if
you've seen these before but we're
saying T is of a type where it's a valid
date or numeric type and so we're using
type classes here which are new and to a
where suddenly now as long as a user
implements a trait that identifies what
a valid date or numeric type is now in
this case in the current iteration of
Kasbah it's basically a featureless
filter that it doesn't have information
about serializing but the other driver
i'm working on which is the async
scholar driver you can actually write
all the information about how to convert
your type 2 and from Mongo format in
your type class so that it's all
isolated so now you've got user
configurable filters and validate or
animerica type as long as there's a def
of this tight class for java.util date
and it's in scope so this implicit
object has to be in scope at runtime as
long as it's there the compiler passes
anything you call date with into that
method because we don't actually do
anything with T it's simply there as a
filter and the compiler can actually
help us by making sure that we don't
pass through anything that doesn't work
you can the best way to understand this
how I figured out how these things
worked was looking at the code for
ordering and I think it was ordering was
the main one there were a couple things
around numeric math operations in this
college right in the the Scala code too
but the way that Scala does ordering
isn't is instead of having hard coding
for if you've got a list of strings we
sort it this way if you've got a list of
numbers you sort it this way the if you
look at the Javadoc or the city Scala
Docs sorry for something like sequence
the sort method expects something very
much like this declaration where it says
I T call an ordering what it's saying is
that in order to sort a sequence of foo
you must have in scope an implicit
ordering of foo and that type class has
all the code on how to compare one food
to another foo and decide which one is
correct you also as I've done can use
them as very simple filters where they
have no implementation they're just
there to pass the compiler and really
this allows you to expand and contract
what's typesafe and it makes it really
easy for me to patch things in at you
know at another release and it's really
easy to talk somebody over email on how
to add whatever support they need which
i've had people do they have some custom
data object or something else that they
want to do that seems to be a common
thing with with scholar users is they've
all come to the conclusion that jdk date
really sucks because it doesn't perform
well and it's mutable many of them go to
joda-time
which we have support out of the box for
but i've run into people who've written
their own date libraries and I'll bet
they all had problems yesterday I was
the my you know the happiest I've been
in a long time was realizing that the
site I wrote years ago
that's very dependent on dates actually
worked perfectly yesterday and didn't
have any hiccups especially because I
didn't realize it until about ten
o'clock that I should have check
so this was a first attempt to doing
this with manifests and again you know
it's a whole block of code and I should
have had a zoom on this manifest or this
compile time check they use a little bit
of the type classes to filter out at
compile time this is generating optimize
pass so I'm saying if the class that
you're passing to dollar type is a MANET
has a manifest of string then allow it
and the same kind of thing this sort of
worked but it compile its compile time
capture so there's situations where
something can can be compiled and it
compiled fine but at runtime there's a
different situation maybe it's running
on a different JVM or something else and
the implicit nature of how manifests
works sort of protects us from calling
the method unless the manifest to your
generator manifest for that type so it's
actually a really crappy solution for
this and it's funny because I had
already used type classes and I posted
this code and a gist last year about a
week and a half before Scala days as
sort of a bragging this is one of the
cool things that I'm going to explain
how it works at Scala days and Yoda
anders Teigen replied to me about ten
minutes later and with this in a gist he
says why don't you just use type classes
which again because I had already been
using type classes I felt rather stupid
because it really is a better solution
and again it's got flexibility in this
the only way that somebody could add
support for a different type would be if
they were to edit the code and recompile
the library and so here we can define
all the things that we consider to be
appropriate but the user still has
extension of them so there are context
boundaries which is a lot of what we're
using in this case we're defining dollar
type and there's an A and a is really
the user defined type we're capturing
the type that we are looking for as a
then we're saying : beasts on type and
in this case this is this context
boundary when you say type symbol :
something else what it's actually
looking for is a trait called beasts on
type that takes a type argument of a
it's implied that Scala compiler is
helping us along here by omitting the a
but in order to pass the compiled check
the compiler has to find an implicit
concrete instance of beasts on type in
scope for the type that you're trying to
pass with a and the same thing with
manifests and so the Scala compiler as
of two eight let's just pull this trick
off by just saying a : beans on type and
in this case I'm also capturing a
manifest for the compile here because
there are certain situations where I
want to look at the manifest to print
error message N or something else this
is the equivalent there there is once I
think it's been fixed in 2.10 or you
know but there's a really obnoxious bug
in the way that the scope is Scala
compiler works you cannot combine these
with your own defined implicitly skele
compiler currently can't combine the
generated implicit s-- with your
implicit s-- so it's important to know
this because if you look at the phase
printouts of scala
this is what actually is generated by
that code and so if you ever get the
error that you can't combine type
classes with implicit s-- you can write
your own version of the same thing and
this is all that it is and then there's
an implicitly operator if you within
your body of your code say implicitly a
it will give you an instance of the type
class for beasts on type I'm sorry
implicitly beasts on type a will
actually give you a copy of the beasts
on type that passed that filter and
that's you know slapped in it compile
time so quick pop quiz what does this
code do anybody I know there's at least
three people I've seen in this room who
I know know the answer to this so what
we're looking at specifically here is
insert and we're declaring our type is a
less than percent of DB object so
hopefully most of you have seen less
than : of DB object which says that a
can be any type that's a subclass of DB
AAB
less than percent is a little bit
different and in this case it's a I
think I'm they have the wrong term I
called them view boundaries I could be
completely wrong it's a view bound okay
because I think somebody told me I had
the wrong term previously this has a
little bit of extra info that a normal
boundary doesn't which is that it
flattens out to compile time with some
extra information and here's the trick
if I had declared this as a less than :
DB object unless ma was actually a DB
object it physically extended DB object
or implemented DB object since it's a
it's an interface it cannot pass this if
you have an implicit method or you have
an implicit conversion that knows how to
convert a into a DB object in an a less
than percent DB object it will not pass
but if you use a view boundary where you
say less than percent DB object you tell
the Scala compiler that it's okay to use
an implicit conversion to pass this
method through and so a compile time
what it actually looks at is that the
type is really just flat a now and
there's an extra implicit what it's
saying is that it requires an implicit
method that knows how to convert a to DB
object same thing this is also very
helpful if you want to use a view
boundary along with your own defined
implicit methods because in to 9 and
below the compiler can't combine these
things so now this is a big deal because
we have a lot of cases people write say
maps they don't actually generate a
MongoDB object they just build a map and
there's an implicit conversion available
in the driver and or they're using some
custom object a lot of people have
rolled their own simple ORM Zoro
deeanne's without touching the DB object
and they need a way to convert insert
methods but you as a library author
actually have controlled I think this is
really important it's not just implicit
for everyone it's you as a library
author having control over when implicit
can happen implicitly otherwise they
would have to explicitly invoke this and
say I want to convert this to a DB
object there's a quick look at something
I don't
not I thought I understood this and then
I was reviewing my slides beforehand and
I'm not sure I understand how it works I
sort of do but about two weeks ago I got
a pull request from John Anders who just
likes to make me look bad by fixing my
code I don't think he's using Mambo for
anything right now either where he
picked up a trick from Lyle salmon who
is also doing some miles is doing some
really cool work with heterogeneous
lists in Scala which if you're going to
any skull the next week track miles down
and get him to explain it because it's
actually really cool he's figured out
some cool tricks with the compiler to
have typesafe heterogeneous lists to do
you know the kinds of things that I wish
I could have been able to do months ago
that I don't know if he is he doing
clock on it oh great cool I wasn't sure
if he was or not the that'd be good
because I I spoke to him about it in
London at one point and he was still you
know ironing out the bugs but I know
he's been talking about it publicly
lately so miles knows all sorts of cool
and clever tricks on this stuff so the
manifests are really good for type
safety but they sort of suck when the
type parameter is not populated so I've
got that I've got a method called get
ass that's built and you can say get as
and pass a where a as a type but the
compiler does not require the developer
to actually populate a if they don't
fill a in it will try to infer it so you
can actually say Val X colon string
equals doc get as foo and it could infer
that a should be string but if they say
Val x equals doc get as foo with no type
argument the compiler will substitute
nothing if you remember the Scala type
tree nothing is the very bottom of the
tree and so there is a bug that comes up
occasionally which is I keep getting
this error that nothing doesn't work and
you know this is you know from an early
feature request and this was actually I
think Rose who asked for this Rose
wanted to not have to call as instance
of so she gets the blame
I've had support forget ass
I did at one point add something that
does a require so I do check my
invariants that the manifest for a is
not nothing but this is a runtime check
so by the time this is being thrown at
your user is in production it's too late
to fix the problem it's also not I mean
I did try to put a little example of the
code here to hint at what they're doing
wrong and I didn't think there was any
way to fix this if you you know failed
to put something in if you know there's
a check in the in the task store there
was that's a you know where you do this
and it will throw a legal argument
exception this is what you on Anders
sent me and like I said I thought I
understood this earlier but I don't
think I understand it now to be fair and
this uses the ambiguity so he's actually
declared a not knifing type class and
not he's got a nothing and I believe
what's happening is because nothing is
it the right shape to pass this get as
where it's actually defined there's
nothing it won't pass but anything
that's actually a valid type will pass
through like I said I thought I
understood it now I'm not so sure I did
but it removes the need for that runtime
check this actually this statement fails
to compile now because it's not possible
to invoke DB object and tricks and the
trick is to just paste just so that your
Landers can find them and show you why
you're wrong you know at one point this
is real quick I know we did rename this
as salvage called Kasbah now we it
wasn't just a wrapper anymore and so my
co-workers thought it needed a new name
and nobody could come up with anything
and so I was listening to the radio on
the way to work and I'm a fan of the
clash and so it's stuck
um one note on where you work I jokingly
repeatedly asked for a pony at work and
so that actually bought me a stuffed
pony and told me to stop asking for a
pony I started asking for other
ridiculous things and didn't get them so
doesn't know but yet really you know
working at both at tangent and in Novus
I mean working with people who are
supportive when you're doing open source
work and all these other things makes a
huge difference in what you're doing so
real quick speaking of ponies I want to
talk a little bit about dog food and if
anybody remembers there's an old it was
like Lauren green I think we did an
elbow commercial about how you know he
believes so much in the product he's
pitching that he feeds it to his own
dogs and then they had video of his dogs
eating what was supposed to be Alpo but
probably wasn't so there is I mean
there's a big difference between fixing
bugs and production and shipping
libraries to users type inference for me
was a total mess all the things I was
trying to do with product and other
things but they worked perfectly fine in
my code base as soon as I released it to
the world people wanted to know what I
was smoking as I said so eating your own
dog food is great but it can make you
complacent and I only implemented the
manga features I was using so one of the
first things I did when I got to Tenjin
was realizing that I all implemented
like four of the operators and the type
DSL because those were the only ones I
was using and there were like 25 other
ones that people wanted to use which is
why there's a thousand tests for this
because I made sure there was full test
coverage because I don't use a lot of
this feature so I didn't have code to
test them against um sometimes it was
only the way I was using them which
often was incorrect it turned out that I
don't know everything as much as I'd
like to think so
so yeah I've spent a lot of time writing
code probably about 15 years now and for
a long time I thought tests were a
really good idea and never actually time
to do them that's one thing in Scala
that you have no excuse for not writing
good tests because there's fantastic
testing libraries the reality as well is
that you you can keep telling your boss
when you're doing a production system
that you want to write tests because you
keep after you fix stuff at three am and
he tells you to shut up in code so
unless we want to have a new career
flipping burgers sometimes we just have
to smile and bear it but it's worth
learning to write good tests because if
you
do them as part of what you're building
it makes a big difference if you're
planning to give code to other people
eating your own dog food is not enough
this is contingent that you care about
your users and your code quality there's
certainly lots of vendors out there that
don't seem to care about their users or
their code quality I care it's you know
this artifact that I'm producing that's
some kind of you know thing that people
are supposed to judge me by you know the
world of github is you know your resume
is your code so taking the time to learn
test is good I really do love the tools
in Scala so I use Scala tests early on
bill Venters corner me at one point
because I sort of made a vague statement
about not using Scala tests anymore
couldn't remember why and afterwards I
remember the reason was simply that all
test has like ten or fifteen different
ways to develop tests they're all
awesome we had five developers all who
were writing their tests using a
different thing
and the reason we were at the specs was
at the time there was only one write and
we write a spec and this was our
solution for this will stop everyone
from picking the test format they want
understanding that we were trying to
solve a social problem with software
which doesn't help but in this case um
specs inspector was awesome I especially
when I converted the specs to I found so
many weird bugs and corner cases in the
Kasbah code that I had no idea could
happen and so that the technology there
and the way that the tests are put
together a really fantastic and
everybody keeps telling me Scala check
is wonderful I've never had time to play
with it yet I'll probably regret this
since I just said that you should learn
the tools and use them there are some
stuff for fuzzing and every and other
things that I know are really good and
it's in my plan to dig into them now
that I've got a little more time it also
helps you've got to have integration
tests and this is something that I've
been burned by I did a whole lot of the
unit tests that test can I construct a
DB object and pull things in fact he
pointed out to me somewhere where I had
a unit test that was not integration
test an integration test would have been
can I save that object to Mongo read it
back from mando and it comes out the way
I expect it to be and you have to have
integration test if there's any network
or anything else between you and part of
your code that has to be part of that
cycle and it's a mistake that I made so
I had a lot of things where I get
support requests and I go there's
way that doesn't work it works in my
tests if your tests aren't correct
you're screwed
um you should however be nice to users
I learned this to be fair I learned this
from lift lift has a bunch of optional
database support all of those are really
good at detecting whether or not the
database that it needs to test against
is installed and skipping the test if
it's not because users don't want to
have our developers don't have to
install every database even if they're
not using and they don't want to get a
bunch of other messages they don't
understand and all of these tools have
good ways of detecting this stuff so I
mean some of this I'm gonna just skip
over because it's repeating what I've
just said but higher coverage really
does relate to less bugs and that's a
good thing it means more time you can
spend writing new code instead of fixing
bugs and old code so who wants to shave
a yak because I'm apparently not allowed
to saw Oracle employees in half on stage
anymore
I'm also not allowed to bring a yak on
an airplane so this is a metaphorical
yak and this is a real quick narrowing a
yak which is one of the things that
happen when I move the specs to was
realizing that I can't just treat
Mongo's DB objects as if they're a map
because there are other attributes of
them that aren't and there's a bunch of
other code I was writing in my tests so
what I ended up doing and you can't read
this because it's too small because I
can't be bothered to split into multiple
slides for everyone's convenience it's
all about my convenience the idea here
though is this is actually a base set of
matchers for specs to Bill Venters
contributed one for Scala tests as well
which in the 3.0 release will be
available for everyone
we use them in every single test for
Kasbah three and they are matchers where
every single one of them is designed to
properly test values coming from Mongo
and account for all of the edge cases so
that you can be absolutely sure that
your code is correct I started with I'm
gonna convert the specs to and then
spent a month and a half like 18 hours a
day rewriting tons and tons of code to
fix bugs put testing in place it's
actually a good thing though so these
will be available because I learned the
value of taking my test tools and
turning them at work
to other people and then finally there's
a bit of an epilogue which is something
that people keep asking to see and
actually this wasn't in the talk
originally and over lunch at Scala days
last year Jonas Bonaire and Victor Klein
convinced me to like show this new thing
that I was working on which is you know
I'm still working on cats but I'm still
evolving it there are plenty of people
that are using and it's never going to
go away but there are also other ideas
that I want to explore and that people
really want one of which is asynchronous
there's all these cool asynchronous
libraries out there but when you have a
driver that's written asynchronously it
does things like blocking when it's
waiting for network code and that
doesn't always work in an async
framework so I started playing with well
it'd be really cool to implement some of
this stuff in pure Scala and do it
asynchronously which is where
Hammersmith came from also another class
reference not named after the tube
station in London but it makes
convenient you know coffee mugs the
project so this is really taking
everything I've learned over two years
and building a better driver I mean
Kasbah I can only do so much rewriting I
can't completely change api's from the
ground up without upsetting users and
breaking things but this is a chance to
redo it and so the only thing that's
left from Java is the beasts on code
because that's one thing that works fine
it doesn't block and there's no need to
reinvent the wheel everything else is
from the ground up it's nettie based
it's moving to be pure niÃ±o the problem
with being nettie based is if you want
to plug into somebody else's container
or even akka ships a version of
Hammersmith right now so that there's
mam go durable mailboxes and I got I get
emails every couple releases from Victor
or someone else over there of hey you're
using a different version of neti that
we are then we are in this release and
it's causing breakage what that's led me
to realize is that if I want to
interoperate with other people I have to
dump neti so I'm gonna move the pure
niÃ±o simply for the interaction um this
isn't a replacement for Casper though
and it's focused more this isn't true
anymore originally part of the part of
the argument I had to make to get
approval to work on this my time was
swearing that I wasn't gonna make this
for user space it was only for web
frameworks it's not the case anymore
mostly because other people have
contributed good code to use it from
user space there's gonna probably also
be a synchronous facade on top of it
and we're going to have Java support as
well tangent is starting to do a lot of
work on asynchronous drivers it's
something you'll start seeing this year
obviously we have support for node.js
now we're adding an asynchronous Python
driver we're working on things from Ruby
and C and other things so this fits
really well into I already had one going
for the JVM and the easiest way to get
one for Java is to just put a Java API
on top of it if you've looked at the
stuff typesafe offers like play and akka
they're written in scala but they have
really good Java api's on top of them so
there are easy examples of how to do it
well out there then I'm planning to
leverage and then using things like
continuations and/or akka to make this
appear synchronous for people who want
it and trying to share as much code as I
can so this is a quick look at how it
works and again I misjudged how big the
projector was going to be can you guys
get me a bigger TV can we wait a few
minutes generally the idea here though
is this is literally all callback based
and it's probably easier at this point
for me to post the slides online and you
to dig into this on your own but the
general idea here is we are using
iterate ease so iterate ease have been a
big deal over the last year in the scala
world I think I heard I haven't read it
yet but I think jaws surrett just wrote
what's supposed to be a really good post
explaining iterate es which is good
because I'm gonna explain it or 80s in
my talk next week and I haven't figured
out the best way to explain them to
people so I'm just going to steal Josh's
content but the idea is for doing
something like this here iterating a
cursor you know it's a chain of calls so
I'm finding from the inventory
collection but I'm actually I decided
for cleanest to use multiple argument
list so I separate out what collection
do you want to work on from what's your
query and what's your field filter in
this case they're empty but the problem
that I that turns out with an
asynchronous networking framework is
often the thread that you're called back
on to say that your initial request is
ready you cannot block on that and so
the way that a database works and Mongo
works the same way is that you have a
cursor and so your initial request comes
back with a small batch of some of the
items and a cursor ID and so internally
you
offer up those items you got and you
start iterating over them when people
call next on your iterator and when that
buffer is empty or in a smart driver
some time before it's empty you predict
that it's going to be empty and start
the work when it's empty if you know
that there are more documents on the
server you go to the server and ask for
more so when an initial version of this
I did one of these I'll just put a
thread dot sleep here for a few minutes
until I figure out what the structure of
this code is gonna do but three hours of
yelling at my laptop I was halfway on
the true home on the train and it went
oh because I was blocking the thread
that was waiting for the reply so I
called get more and then I called thread
dot sleep waiting for the callback to
happen but I was blocking that thread
from coming back so the trick is how do
you actually handle basically instead of
Abdul State iteration a tri-state
iteration where you're not allowed to
block and so the answer is iterate ease
which I think the best answer is
probably to read Josh's post on how this
works but the general idea is instead of
simply having a next method what you do
is you define you define a method that
you give to the iterative caller and
your method expects to get an argument
of an iteration state and you return in
iteration command so in this case
there's three states
there's here's an element you know
you're calling next and this method is
called every time next is called here's
an element you know there's actually
something here for you
there's nothing left on the client-side
but I've got some more data on the
server what would you like me to do so
the answer to here's an element is
typically the command next and that
command next says just give the next
element and call me again the typical
response to there's no more on the
client but the server claims it has some
is next batch and you call next batch
with a copy of yourself the method
that's going to be called when that
batch comes back and so then the
framework can go out call for the next
batch and whatever that batch arrives it
can just start calling this method again
an iterate and in the final state is AOS
is end of file there's no more data on
the client there's no more data on the
servers what do you want me to do
there's really only one appropriate
response to this which is done and done
says close out the callback chain shut
down any resources you need and prepare
them for GC you know there's not really
anything else so you knew but you can
take this model and use it anywhere do
you have this idea suddenly of multiple
states and your callback is given a
state and it can give a command here's
what I want you to do with this state in
this case this code and this test is
actually only looking at the first 100
entries and calling cursor next but if
there's more than 100 entries of in red
it calls cursor done so you can give a
different command you have full control
over what happens here and so this
allows this to be completely
asynchronous it still makes some sense
more you know sort of looking at how all
this works now the big thing and the
last thing I'm going to show is that I
did this all with type classes so
instead of having some separate area
where your register here's how I read
you how here's how you serialize and
deserialize a foo number instead
everything every method in hammersmith
is looking for the type class serialized
will be some object even our
implementation of a DB object in
hammersmith is the type class so
everything uses it there's no hard-coded
I have to have a DB object except in a
few cases where it's the only right
answer so what you actually can do here
is you can simply write the code to
improve it this is a first pass
invitation it's going to be much easier
in the next iteration but the general
idea is decoupling your Scot the law of
Demeter everything should be separated
out so that you have a type class that
says you can just plug this in it also
means then the Java driver right now you
have to do a global registration of any
serialization of dear serialize ooh that
sucks especially if you've got a couple
different contexts running in your VM or
something else having a global can make
it very very difficult and so this
really works off everything is looking
for an implicit serializable beasts on
object and it can call that serialize
will be some object the implicit to find
out how to turn foo bar number into
what needs to be there to serialize and
then back again so this is you know very
briefly way too much content for one
slide but this is becoming a priority
for me again last few months I've been
traveling I was in Europe doing a lot of
conferences and talks and training and
consulting I did very little time to
work on code and one of the things that
fell behind is this although I'm
starting to work on it again I'm like
any other open-source project it always
benefits from from contributors there's
lots of people who keep saying they're
really interested in excited to see this
project done but don't send me any code
to help me get it done so if you're very
interested in this I mean a couple guys
have ik Pennington ROS gear off sites
have done some really good work on
moving this forward initially this could
be a really cool tool and there's lots
of work that needs to be looked at
porting to akka we haven't did a first
pass I'm still looking at see if it
makes sense
looking at delimited continuations to
create that emulated synchronous API
integrating with things like lift and
salaat documentation tests some other
brilliant idea that I don't have this
middle so is going to come up with the
same thing applies really to cap on
everything else so the answer of course
will send me a pull request that's all
of the rambling that I have for tonight
but if you stay for the second act we
can start this over I have a wonderful
presentation on how functional
programming works questions if nobody
seems we've run out crying yet so that's
a good sign thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>