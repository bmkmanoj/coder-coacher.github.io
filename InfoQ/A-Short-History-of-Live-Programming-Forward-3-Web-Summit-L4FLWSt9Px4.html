<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Short History of Live Programming - Forward 3 Web Summit | Coder Coacher - Coaching Coders</title><meta content="A Short History of Live Programming - Forward 3 Web Summit - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Short History of Live Programming - Forward 3 Web Summit</b></h2><h5 class="post__date">2015-08-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L4FLWSt9Px4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming this morning
I'm gonna give a short talk about a long
topic live programming a bit of history
because I find that we're in a mode now
where a lot of people are inventing
square wheels and awareness of the
history of ideas is important so part of
this is going to just be a reminder
where some of these things come from and
some of it is going to be where they're
going and hopefully it'll be of some
interest so what is live programming
well the best way to show live
programming is to really show it and so
basically it's about evaluating things
at its root if things like this right
evaluators so the point being that we
don't have to simulate this if we write
this in a text file well ok you went
through grade school you know how to
simulate this but real programs are more
complicated and we have computers so
that they can compute for us rather than
us simulating in our mind what they're
going to do eventually when when we
deploy this in reality so that's really
all there is to it right we just want
something that does this and this has
been around for a long time
basically this is a form of what's
called a rebel read eval print loop and
that's that's the source code for the
original rebel right ultimately it's
very very simple you loop and each time
you read something which represents some
piece of program code you evaluate it
and you print it and you keep on going
so everybody has loops everybody can
read stuff and everybody can print stuff
what not everybody has is valid so eval
is the key thing here right evaluation
of being able to evaluate for
expressions in your programming language
from within itself that is what makes
things live and that is what makes all
the difference so this has been around
for a very
time so this is a teletype I am willing
to bet that nobody in this audience is
actually touched one but I have oh oh
sorry I didn't see you I apologies
yes so another one of my wrong bits
there's too many of those the story of
my life but anyway I I learned to
program on one of these gadgets and I
was very lucky to to be given access to
this valuable and sophisticated piece of
equipment and the funny thing is
primitive is that most as it may seem in
some respects it was more advanced than
the stuff that most developers are using
today because what I did with this thing
is I wrote basic programs humble basic
easy to rag on not a hugely
sophisticated programming language but
it had a repple what you do you type at
this keyboard you'd literally type
hopefully you know what a typewriter is
and when you type it would hit the page
and actually print things as you went on
and then it would answer back to you by
printing on this paper right and every
time you hit return it would go slam
kind of you know massive noise and
sometimes it would make even more noise
because when you saved your program you
may not see it here but see this thing
that's the paper tape reader and printer
so if you wanted to save your program
you got a roll of paper tape and it
would punch it so this is of some
interest to archaeologists and others
but the point is it had a ripple that's
better than eclipses okay so so it's a
very basic thing it's a very very basic
property of your architecture and if you
have it all kinds of things open up and
if you don't have it no amount of
thousands of wasted person years are
going to make up for it so of course
that I I probably shouldn't disclose
when I work on that thing but it was
about 1975 or so and the way before that
Ripple's APL for example the first
implementation when it came up was a
ripple this isn't it this is a newer one
I can tell because it doesn't have the
line numbers in it so you know I can
even tell you what this program does
believe it or not it's getting the
numbers one through six then it's
turning them into a 2x3
array and assigning it to m1 when you
type in one it prints it out and this is
very similar except it's one to twelve
and three by four array and then you
multiply the whole array by one hundred
etc etc none of which really matters
explain the syntax of APL is not
something that anyone wants to do in
public and I don't claim to it's been a
long long long time since I had any use
of of APL but it's a cool language in a
lot of ways but the point is it was
interactive there was this notion of an
APL workspace and you can write programs
and you could see what they did right as
opposed to simulating it in your head
so ripples are the first step they're a
baby step and a lot of talk about life
program today people get all excited
they have a ripple yes that's nice but a
ripple is a basically a very very
elementary thing and that's not really
what this whole thing is about
fundamentally it's about moving from
dealing with text to moving to dealing
with an experience with an interactive
dynamic experience which will bring us
to small talk so this is the alto that
is the original personal computer circa
late 70s or something and this is in
some museum somewhere and in the
background they have some sheet which
actually shows small talk code so
several points to note here when small
talk ran on this machine that was all
that ran it that and the microcode this
was the operating system it was the
whole thing what that meant is when you
have a live environment you can control
the entire environment
and why is that important let's again
have a look so here we are with our
little evaluator right and as we change
things right it evaluates and it gives
us results the result is a link if I
click on it I get an object inspector it
tells me that disguise friend is 21 it's
an instance of number it's and so forth
and oh this is good and well but what's
really interesting about this is the
liveness of the environment even though
this is just a subset of a particular
program environment the Newspeak
environment that app happens to run in
the browser no most of it doesn't you
know the full environment does not run
in the browser
for all kinds of reasons but it does
know to do some nice tricks so we have
this link here that says inspect
presenter I click on that I get another
object inspector but this is an object
inspector on the gooey object that was
presenting the thing I just saw this is
the actual presenter object that was
presenting the number 21 that we were
just looking at and the nice thing about
that is now I can find out how to
control that because now I know the
class of the actual thing that's that's
running that piece of GUI so that's
object presenter and I can look at its
source code and I can do things to its
course source code
I can change the source code if I go
look at another object now it's turned
green what I've done here is I've
changed the IDE from within itself live
right it's a very simple change it's not
an interesting change there's a reason
it's a very simple change because I want
the demo to work and I do not want to
get confused programming in front of you
all you people right but the point is if
you didn't like some widget in Eclipse
what would you do if you wanted to
achieve this well you could go look in
the source code and find out where the
particular piece of source code that
actually control this was which we did
here by simply asking it
show us the object show us what class it
is and we know its source was in the
case of Eclipse you'd go look through
the source code and try and figure this
out that shouldn't take you very long I
mean we know it starts with public
static void main we can work our way
from there you know come back to me when
you're done
of course you're not done then then when
you have this theory and it's only a
theory because you had to simulate the
code in your head as to what actually
runs this widget then you can make the
change and then you can build it then
you can go on your honeymoon or whatever
and come back when it's done building
and then you can start up the program
again and that only takes a few minutes
and then maybe you have to bring it to
whatever state it was where this widget
was actually displayed in that
particular form and see if it worked
this is perhaps the reason that this
whole sequence of events isn't commonly
done right it's incredibly hard because
live program is about reducing the
feedback loop from in this case probably
days to seconds all other feedback loops
aren't sighs aren't as bad but all of
life programming is basically about
letting you interact with the computer
having it tell you what the code does
rather than having to simulate it or
wait for it to you know go through a
long sequence of essentially irrelevant
steps that you're so used to that you're
blind to the fact that they're relevant
like building things and compiling
things and so forth right it's all about
making the thing something that you
and interact with immediately and it's
nice if the system is meta-circular and
you can actually do it to itself right
most applications probably don't need to
do that you only need to do that when
you're developing them but it's nice as
a programmer if your development
environment has that flexibility and a
well-constructed live environment will
do that for you and so back to our
regularly scheduled program
so of course inspectors aren't new
either
a therapy newer than rebels I think they
go back to about 1976 the small talk 76
I won't swear too exactly if it was 76
or so I think small talk 76 pretty much
had all the the basic features that you
see in in in later small talk
certainly small talk 80 a mere 35 years
ago all of this was was well established
but it was probably there a few years
earlier so it's not really particularly
new that you can you know have an object
inspector an object inspector is again a
lot like a ripple it's an evaluator but
the nice thing about it it's an
evaluator in scope right you can
actually see things that are scoped to
that object right if we go back and now
I'm doing impromptu demos that I didn't
plan but let's see we're in a number so
we can say something like self times two
right so we're actually in the scope of
this object so that's nice oh there's a
lot more to these tools however than
than just you know what we've seen so
with that in mind we're going to go look
at
look at this guy so we may have to zoom
in a bit on this it's not great but you
can see so obviously we can't evaluate
things and this evaluator is a little
different right it got us a result there
seven right notices there's a little
difference and this is a point of view i
that is actually worth mentioning right
some of these the original ripples you
would type in a line and then you press
return carriage return and it would in
in the case of teletype that really
meant something cuz it went the carriage
went back that's why it's called return
oh you can put that in your list of
obscure useless historical trivia that
you can amaze your friends with but it
was a line-by-line thing you'd put in an
expression and then you'd evaluate it if
you the the thing I showed you in the
browser actually evaluates every sub
expression as you type it that's
something that wasn't very feasible when
you had to actually type it onto paper
right but sometimes it's actually useful
to do that because sometimes you want to
actually have larger expressions that
might have side effects and you don't
want everything being evaluated all the
time you want to actually be able to
build up a large enough expression or a
series of statements or something before
you actually let it go and a workspace
is good for that because in a workspace
we can actually have multiple things you
know that we type in it's like a it's
like this pad of useful things that we
write down right there are similar
things in other environments and it's
you know and these are small variations
they're very easy to do these workspaces
here are really just object inspectors
on us on an object that is suitably
scoped to give you you know the whole
programming environments in the
namespace so you can evaluate useful
things but there are other things that
you can do these environments and small
talk is a good example of an environment
that's been reasonably live for a very
long time and has evolved a lot of
useful features though honestly it
evolved most of them at Xerox PARC up to
1980 it's been a bit refined since and
what I'm showing you is actually
Newspeak which is a descendant of that
- do we need all that noise behind us I
don't know
so here's another thing you can do right
we have this expression where you'll see
it's in red for a reason
it's in red because the idea is telling
me that this thing isn't defined but if
I insist on evaluating it well I get
this thing which tells me that there was
an error for those of you in the back
who might have trouble seeing this
it basically says message not understood
bla bla bla and if I click on this I get
a debugger and now actually I want to
under some cuz I know I'm gonna have to
zoom this from a different angle to show
what I want to show I want to zoom about
here probably because one of the nice
things that lets me do okay we haven't
zoomed back enough let's try this again
this says Rick create missing method
binary search for in right the point is
I got a no such method essentially
unlike Java I didn't get just an error I
got a trap where I can now add this
method on-the-fly right so if I click
this I have here a template for the
method that I was calling and I can go
edit it you know these are these are it
fills in sort of argument names and
types and the types don't matter they're
they're optional but it filled them in
base it filled them in based on the
types of the arguments the actual
dynamic arguments that I got right how
does it know that I'm going to have a
symbol an array this is but I can
probably decide to generalize these or
whatever and I can start you know typing
things in because I sort of know this
demo by heart so also
so this is you don't need to know the
syntax for any of this but I can save
this and I can go back and I can try and
evaluate this baby again and now it
stops right there was this halt in it we
go back to the debugger we can actually
look at this right this halt
that's essentially small ones way of
putting in a breakpoint right and now I
can start writing in code right I can
decide the low is going to be one and I
can evaluate that and look here right
watch this guy all right so now low is 1
and that's high is going to be the size
of the list I'm gonna do this kind of
binary search through its indexes right
I can evaluate that and then you could
argue that the flow here in the UI needs
work and I agree with you this is
Newspeak it's an experimental system
that I've been working on that changes a
lot of things from small talk hopefully
for the better which is which is kind of
hard because the bar is very high and I
can do things like midpoint is going to
be Oh plus high / - when I evaluate that
oh this is not going to be a very good
index because that's basically a
fraction right so I made a mistake and I
detect it immediately while I'm writing
the program and so I know what to do I
keep changing it ok now I've got a
midpoint and I can keep going like this
and basically build the program in the
debugger now I don't all think you
should always do that but a lot of times
it's really a useful thing to be able to
do so again the essence of these things
has been there for over 35 years
why in the mid-90s where we still
introducing tools that couldn't do that
like when I was involved in for a long
time like Java don't ask me I dunno
that's at least at some point that
wasn't the intent there's this lovely
document that is kind of hard to find
now which was one of the early shall we
call it propaganda pieces for Java and
it had this line saying the edit compile
run crash off the cliff cycle is over
because Java was supposed to fix that
except that it didn't fix that and I
could speculate why in the end the
actual you know shipping things did not
do that but that's kind of beside the
point but the fact is that we have a
whole culture that ignored all this
stuff and went off in a different
direction and we need to bring it back
and people are doing that and you
probably have heard some of the the
talks or seen some of the new tools that
people are doing there's a lot of
activity in a lot of places but this
talk is partly to talk about what some
of that is still overlooking partly to
tell you that it's not new and draw
lessons from that and partly to to move
on and speculate about what we can do in
the future so in the interests of
history of course small talk isn't the
only one like I said the lispers did a
lot of stuff in the 80s they build these
things symbolic slips machines there
were several brands there were several
companies building dedicated hardware
that ran these things cuz running these
things on stop hardware was kind of
difficult at the time the interesting
thing now is you can actually run get
emulators that run in a web browser that
let you see how these systems were like
actually old versions of like Smalltalk
76 or some of the lists of machine
operating systems you can actually
emulate them in a in in emulation in a
web browser today they probably run
faster than they did originally on this
hardware this this toy cost you know on
the order of a hundred thousand bucks in
1985 when 100,000 bucks was real money
and when I was in grad school they had
one in a lab that was kept sort of
off-limits and mere mortals couldn't
get to it because time had to be
scheduled on it and it was a real big
deal but the nice thing about it was
right this was Lisp all the way down
just like the alto a small talk all the
way down everything there was in lists
the operating system the editor the
tools you know files whatever you want
and that meant that all the liveness all
the ability to change and modify and
play with was in your hands it was a
computer that you could control right it
was your computer to do what you wished
with which is very different when you
buy a phone now and it isn't even your
phone to do what you wish with right so
we're losing something very important if
we don't insist on on these properties
and ideally as far down the stack as we
can make them now oh just a demo I
wanted to give for a long time I was
looking for an excuse to to give it just
not because it's useful but because it
is cute
so the point being that it's a lot of
this is about writing code but liveness
is a property of systems in general and
it's not always just about directly
writing code so this is squeak small
talk this guy right here let's try and
we need probably as big as I can make it
and still control what I want to control
so this is now what this this window
right here it's a small talk glass
browser it is essentially undergone only
very minor changes since 1980 and you
know I'd argue that it should have gone
undergone more changes but that again is
beside the point right and you can do
things here right so you can evaluate
here we've got a test for collections
and the test is doing set new and we can
actually do this and we get an object
inspector that's a little different but
this is an object inspector in a setting
on a set and squeak small talk and we
can ask it things we can ask to have it
printed size right and that's what size
right so all of this again this is very
close to what existed in small talk 80
and probably in small
seventy-six right back in a millennium
far far long ago but what I wanted to
show you squeak small talk has several
weird things there's a system called
etoys because the the emphasis in this
week was for a long time was on teaching
children in fact small talk originally
was a lot about children making
programming so simple that children
could could learn to program which is a
good idea because then even adults can
learn to program because we know who
learns better right so one of the things
they have is this e toy system which
lets you basically program it's designed
to program little in you know animations
and things where you can take graphical
objects and assign scripts to them and
tell them how to behave animate them and
things the point is that it applies to
all graphical objects including system
windows which is what you know this
browser is set in so I can run a script
for it and I can make it make noises and
I make it made rotate and if I manage to
grab what I'm trying to grab here while
it's doing that this requires a bit of
dexterity yeah yes nope I want to get
this baby to select stuff eventually
when I practice at home I could do this
but it's moving a bit too quickly thank
you and now it still works right nothing
has changed there's no reason that this
is the fact that I'm rotating should
interact with all its functionality
right if it's done right how many
systems are done right today you tell me
all right I can also you know I can I
can cause it to evaluate in itself and
print itself it all works while it does
this now this is not a terrible useful
thing in itself right but it does have
some advantages you can stop that right
there also
oops that's on the zoom
so I can see what I'm looking for right
one of the properties these these little
colorful things they're called halos
they are part of the system that lets
you manipulate these graphical objects
or example here I can rotate it so we
can bring it back to its proper position
and this is I can I can add scripts to
it and I can do things but I can also
disassemble it oh let's see
I don't know what I've grabbed but let's
try and move it and see what it will do
right so okay here I've copied this
thing just a subset of the whole thing
but it's its focus is still wrong
apparently I can I can probably focus on
one of these guys I know I wanted to get
on the smallest bit let's try and move
this yeah so this apparently makes a
copy what I wanted was move so one of
these icons probably does that I'm not
sure which one change size let's try
that that didn't do anything interesting
let's try and delete it yeah okay we got
rid of it
so again this doesn't seem immediately
terribly useful but think what this
means it means that your GUI and the GUI
builder are built in right if you want
to rearrange this you can start editing
it again live you can take it apart just
as you could with a GUI builder except
it's for all the pieces are fully
functional and you can apply this to a
ready-made piece of software that you
you encounter and obviously you don't
necessarily want this to be on all the
time because if it's on all the time you
know you can accidentally disassemble
your window when you're trying to do
something I've seen this happen to
people so you do want to control it but
it's very much like physical objects
right so you have a chair there or a
table and all these things can be taken
apart
they're designed so they don't fall
apart very easily but there are
mechanisms that you can apply there's a
tool you can take and grab a screw or
something and you can disassemble it you
have access to that physical reality is
is like that because it wasn't designed
by software engineers otherwise if we
had you know imagine if the universe was
designed by software engineers well it
wouldn't exist right it would never get
past the the first you know picosecond
of the Big Bang you'd have an instant
crash long before that right the the
laws of physical reality are sometimes
you could view them as constrained but
they do not allow you know incoherent
fantasies to to exist and and so that's
it's a good metaphor for us to use but
again the point being live systems it
goes beyond the code right it's it's the
ability to enter get immediate feedback
on whatever it is you're building
whatever it is you're designing whether
it's actual code or whether its
graphical artifacts etc etc so there are
a few more mechanisms that I wanted to
talk about that again aren't maybe
essential but they make a lot of sense
that came out of the small talk designs
and you know some of them have they have
pros and cons so one thing is this
notion of images or small or snapshots
right one of the things about small dog
is you can save the state of your
process the interaction wherever it was
to a file and then bring it up again
some time later so you're getting on a
plane people force you to shut down your
computer you are in the middle of a
debugging session that's fine
it'll be there exactly as you left it
when you bring it up right if you think
of the analog where is our standard
model of programming is just talking
about dead text then of course text yeah
we can save that in a file we can send
it to people there are tools that will
reopen that text right but if our model
is that what we're really programming
against is a live process that's dynamic
in time then that is something
should be able to save and reopen again
in in another at another point in time
right we can probably do that so if we
go to one of these guys let's change
something obvious about the state here
well actually we have changed right this
is not the version if I close this
without doing anything and I choose not
to save and I go back to somewhere here
I'm going to find a window where this
baby came from and I started up again
and you'll see that all is well right
this is not the changed one that I had
on the other hand if I do choose to
change it and I quit now and I save and
I bring it up again there it is so if
something seems buggy because it
probably when it starts up its got the
issues about screen coordinates so this
thing thing to move but it does it's
basically exactly where we left it and
that is a very nice property in small
talk it's a double-edged sword because
basically they over capitalized on this
idea there isn't a real because in small
talk the whole model of the war of
programming is that it isn't the program
text that matters it is the the live
interaction of the objects basically
there's a notion of a sea of objects
that are interacting and that's your
computation and saving an image saves
that and there they didn't even bother
having a real syntax for your complete
program there's syntax for for
individual methods in small talk but
there isn't actually syntax for a
complete class or a complete program
which has led to all kinds of problems
with you know integrating with source
control whatever that's one of the
things that we do differently here oh
say with new speak where there actually
is a syntax so so Tate you can take the
live thing I wouldn't say too far but
you
you should not ignore or lessons from
from the existing conventional world
which are useful things that having a
standard you know text representation of
your program is a good thing but because
of that they have they've evolved all
these interesting tools that let them
you know do things that you don't
usually see so one of them is snapshots
which are really good to have but if
it's all you have you run into problems
because it makes it very hard to
separate your program from that process
State and it's valuable to be able to do
that so I wanted to mention that
so other properties right if again we're
talking about the live program the state
so we basically have a heap that's
running and we should be able to explore
that and there are some things that
unless you put them deep in your system
you're not going to be able to do right
for example if you want to see all the
instances of a given class at a given
point in your computation most systems
will not let you do that
under any circumstance there just isn't
a mechanism to do that unless you
explicitly write code to store them away
in which case you have a storage leak
and okay maybe you can do oh you know
weak instance but again that's still
occupying a lot of overhead of extra
pointers that stuff is in memory and
essentially the runtime system can get
at it right and that's not a theoretical
thing because you get into one of the
things that these systems can do is it's
not just about evaluating expressions
live right if I want to change a class
if I want to add you know micro it turns
out I have to make a modification or
refactoring whatever I have to add
fields in small talk I add a field to
the class and all the instances in the
heap now have that field right now once
you've done that the question is well
what state is that field in what do I
store there by default it's nil but you
probably want to put something in do you
have a mechanism for actually setting
all these instances to something
sensible so being able to get at all the
instances is is one mechanism that'll
help you do that it's a low-level
mechanism it's a primitive mechanism and
it brings up all kinds of interesting
questions when you scan the heap like
are all these instances live because if
the garbage cool if you're doing a scan
of memory there may be objects in there
that are actually not live but haven't
been collected yet so there's all kinds
of subtleties none of this stuff is
necessarily as easy as it looks but the
beauty of small talk is they make it
look easy similar there's this magical
operation called become they'll
basically let you swap the identity of
any two objects so you can basically
migrate things and there's really
interesting things you can do with that
if you're doing sort of orthogonal
persistence and you have these objects
that are supposed to dynamically load
stuff from persistent storage when
they're used well it's really basically
they're acting as a proxy that when
someone actually tries to get at them
they go off and load you know persistent
storage the probe you get into all kinds
of problems with proxies with identity
but you can actually swap the identity
and turn the proxy into this new object
that you've loaded there's all kinds of
of cool system e tricks that let users
without deep X access to the runtime and
due to virtual machines and so forth
build interesting systems because the
whole the internals of the system are
exposed and manipul and have powerful
primitives to handle them so all these
things should not necessarily be
reinvented they do have to be controlled
carefully because there's lots of issues
small talk was designed in an age where
knowing that people thought about how to
teach children to program they didn't
think about you know criminals and all
kinds of obscure corners of the world
writing viruses that is one thing they
didn't really foresee and so a system
like this is not trivial to secure shall
we say right think of it if I send you
an object if I call you with an object
and I tell you here here's this object
call it and then you can actually get
its class change its class and that
change not only changes this object that
I gave you but all the other instances
of this object that you might have
anywhere else if there are people who
might
say that this is not the most secure way
to do business right now there are met
there are answers for that which are way
outside the scope of this talk mirror
based reflection capabilities etc but
keeping actually building systems that
do all answer all these things you know
if there's a lot of open questions
there's this issue of keeping your
process and the code in sync right so
you have this thing that that evolves in
some state and you change the code the
state you're in isn't necessarily the
state you would reach if you started
that code from scratch it's amazing how
often you can still you know fix things
and do things in development that are
useful to you and and shorten your
development cycle but you're never sure
that this really worked if you started
the program from scratch other unless
you really do start all over again which
is the thing we've been trying to avoid
ways of doing that or interesting other
issues is we want all the code views to
be live right so what's wrong button
look at this guy any one of these guys
right let's find a class that's more
conventional so this is a view of a
method in some actual cost classes
object subject it's sort of the the
thing that's that's behind the object
presenter the object presenter is what
you'd call a view and this is whatever
you want to call it a controller or a
Model View or all kinds of terminology
for that but the point is this is this
is dead code right if I want to evaluate
this this is a property of an instance
which instance am I talking about I mean
it's one thing to say I have some fixed
code like set new where I might know
what set is but if I but if in fact we
can do this in let's look at this guy
right so if I try to evaluate empty
which i think is an in instance file it
gives me this error right we don't know
what you're talking about because these
are instance properties and I don't know
what instance
you're talking about this is something
that I think is still wrong in in these
systems I think that you should never
ever look at dead code whenever you look
at a piece of code in an editor there
has to be live data that you can
experiment with so you can evaluate any
sub expression at all times so the
question is how do you fill that in
where do you get such data tests are a
really good idea you can get a lot of
data from tests
there's even an argument that you should
actually require your programming
language to associate some sort of test
expression with every you know method or
something so that you always have an
easy way to get this data otherwise your
environment has to go to some work to
correlate tests with code and and figure
out what it is but there are interesting
questions to be done there and we're
going to see people solve that in you
know the next few years I'm pretty sure
so what else will we see we're gonna see
time-traveling debuggers become real and
again there's this whole problem of this
that makes them hard is recreating the
state efficiently at all at different
times right you want to be able to move
back in time and ask what's that set
this variable that now has the wrong
very value how did this happen and kind
of basically debug backwards that's
invaluable it's a lot easier in in
certain functional settings there's a
nice system called Elm that I recommend
you look at which which actually does
this and it's currently targeted just at
UI but I'm sure it will evolve and
generally it may be that that live
programming is actually the killer app
for functional programming the funny
thing is the academic functional
programming community doesn't understand
this at all oh and in fact the with a
renewed interest in live programming
they've become aware that it exists
the general trend trend is to regard it
as a fad and hope it will pass but you
know I think that the real the real hope
for functional programming is the
languages that are out there that people
are you know building in the you know
outside academia which are taking some
of the best ideas from functional
programming but actually ignoring a lot
of
the unfortunate ones and so we're quite
likely to see a lot of this actually in
the functional world and I think we are
just about 40 minutes and out of time
and that's all I had to say thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>