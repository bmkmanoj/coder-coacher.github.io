<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Interpreter Pattern Revisited | Coder Coacher - Coaching Coders</title><meta content="The Interpreter Pattern Revisited - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Interpreter Pattern Revisited</b></h2><h5 class="post__date">2015-04-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hmX2s3pe_qk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the world was was just coming online
there's coming of age and there were no
smartphones there weren't even Palm
Pilots like you know that people having
devices in their hands was not a thing
if you walked up to somebody on the
street and said hey do you have a phone
they look at you funny so young William
Clinton just completed one year as the
President of the United States and Green
Day just released Dookie and the Winter
Olympics were held in Lillehammer Norway
and the lion king came out that year
friends what's in his first season and
the game everyone was playing with doom
- these were heady days indeed and in
these halcyon days Microsoft released a
preview of his of the next generation of
its Windows operating system codenamed
Chicago the world wide web was just
beginning to become a thing and you
could you know most people didn't have
it in their house you could walk down to
an internet cafe where you could exhaust
the Internet in a couple of hours you
know by searching on web crawler through
music so yeah the PlayStation came out
that year that was state-of-the-art in
computing and the Commodore
international went bankrupt and the the
latest and greatest in computing was the
power Macintosh and as we know RISC
architecture changed everything
Steve Jobs was not an apple he was at
next selling object technology and an
objective-c
to to eager customers and a company
called rational Software was developing
the first seeds of a unified modeling
language called the UML which was to
become the lingua franca of
object-oriented design
so speaking about deterring to design so
this book came out all right design
patterns elements of reusable
object-oriented software so this was
published in 1994 20 years ago so it was
written by this whole group Gang of Four
and the idea with this book was was to
apply here I'll hold it so it was it was
to apply the idea of pattern languages
which is comes from architecture an
architect named Christopher Alexander
developed this idea of pattern languages
in architecture and so the idea of this
book was to apply that to software
creation and this idea caught on like
wildfire and it actually popularized the
notion of software architecture that was
not really a thing at least wasn't very
popular notion before this book and so
this became the Bible of self-styled
software architects everywhere so you
know the book contains classic
object-oriented design patterns that I'm
sure we've all heard of you know hits
like abstract Factory and prototype
iterator is in the standard Scala
library singleton is actually built into
Scala right yeah
and you know you can like people combine
these things like you know you can have
abstracting some proxy factory beam in
your your librarian and people are like
yeah that's that's awesome but a
lesser-known
pattern it's the interpreter pattern
this one is sort of like an unsung hero
so so the description of interpreter if
you if you would all turn to page 243
and your gang of four books you can see
that the the description is that given a
language we define a representation for
its grammar along with an interpreter
that uses the representation to
interpret sentences in the language
right sounds kind of weird right and so
it's it was kind of a misunderstood
pattern people didn't really get it for
instance oh design comm now says the
interpreter is one of the design
patterns published in the Gang of Four
which is not really used and the
department chair of computer science at
San Jose State University said I'm not
sure this pattern has wide applicability
and DVA guy in one of his rants I'll
just read this out of course I loved all
of design patterns
except for pages 243 to 256 the
interpreter pattern which had the magic
property of inducing a coma-like trance
whenever I tried to skim through them I
could put on a black ninja suit and
sneak through the building and presuming
I didn't get arrested I could tear those
pages out of every single copy of design
patterns at Amazon and almost nobody
would notice but I feel this evoke
for me so some somebody uh yeah
caught me saying that at one point so no
I really think that this pattern is is
underutilized and and it's sort of it
captures an idea that that I think is
extremely useful and it's sort of
universally applicable to almost
everything so let's look at this let's
look at this pattern so what is the
interpreter pattern well the motivation
section says that you have a problem
that occurs often you express instances
of the problem as sentences in a simple
language and then you solve the problem
by interpreting the sentences now they
give an example in the beginning they
always start with an example in this
book and so the example that they start
with is a simple regular expression
language so the problem is that you want
to search for Strings that match a
pattern and then you have regular
expressions which are sort of a language
and then you interpret those expressions
using an interpreter to match actual
strings so here's the grammar for their
regular expression language so they
start with you know an expression is one
of these things it's a literal or an
alternation or a sequence or a
repetition or another expression in
parentheses an alternation is two
expressions separated by pipe a sequence
is two expression separated by and
ampersand and the reputation is an
expression followed by an asterisk and
then a literal expression is a sequence
of characters so here's the UML diagram
for that you know I'm sure all of you
are well-versed in UML by now so you I
mean it's totally clear right you have a
superclass
just abstracts and then you have four
subclasses right and the subclasses
contain instances of the superclass like
sequence expression has two alternation
expression has two repetition has one
right and so if you have this after
class and then you have these these
subclasses which are sort of the
instances I mean the cases so in Scala
we can do it like this right so we can
have a regular expression trait so
that's abstract and then we have case
classes for each one of those but that's
a little bit both for me so I'm just
going to do this so we have a sealed
trait expression and then we have a case
class for each of the rules in the
grammar one for literals one for ant
which is the sequence expression one for
star which is many and then or which is
the pipe okay and then an actual
expression in this language has this
structure this is the UML structure
diagram for one of those things and so
if you have an expression that
represents the so we structured the
representor expression you know that
matches strings that start with raining
and then are followed by many instances
of either dogs or cats then this this
would be the expression for that and in
scala it looks like this so it's just an
end containing a literal and a many of
an or that has two literals dogs and
cats right so then the idea is that we
can interpret these expressions given a
string we interpret them to see if they
match that string or not so the idea is
then given a string you know if you have
a literal then you just check it to if
the literal string matches the input
string and then or checks it either one
of the puppets sub expressions matches
and checks if both of them match in
sequence and many you know tries to
repeatedly apply the pattern so here is
an implementation of the of the
interpreter for regular expressions now
they don't actually give the the
implementation until late in the in the
chapter and because they use a they use
a mutable context so that
they pass in instead of passing this
just the string they also pass in a
mutable context and the interpreter
proceeds to mutate it and it's all
written in small talk and it's totally
awesome but it's very long but I route
in Scala I using an immutable state so
just pass in the input string and then
it returns the resulting string and what
this what this does is if there's a
literal then you know if that literal
starts with that then it matches and
then we drop the you know we consume
that bit of the string and then and or
and many actually recursive the
structure and pass the string along as
it's being consumed so so it's you know
it's a purely functional thing in fact
we can use the state monad we can use a
like from Scala's add state so our
interpreter that just takes a string and
returns a boolean and a string is
actually a state machine so we can make
that explicit using Scala sets statement
in fact they say in the book on page 245
they say that the you know the you're
encouraged to not actually you know
interpret using a context they actually
encourage using an immutable interpreter
so an actual state machine right which
is what what I've done on the previous
slide so yeah they say interpreters are
usually not implemented by interpreting
parse trees directly but by first
translating them into another form for
example regular expressions are often
translated into state machines so some
important things to note expressions are
pure syntax they're just syntactic they
don't have any intrinsic meaning of
their own right the fact that you see
and or and many that the the actual
description of the meaning is not
inherent in the syntax is not in the
objects semantics are given by
interpreting in some context but now we
could interpret with a context that
turns all the ends into ORS that would
be perfectly valid so an example of a
translation of giving semantics to an
expression is to translate it into a
state machine so then they give the
overall structure of the interpreter
pattern which looks like this and again
this is
should be totally clear right I just
have to show this for three seconds so
you have you have a client's that knows
about some context context and then
there's an interpreter that receives
that context and it consists of an
abstract expression class and then
there's a number of subclasses and here
they just say that there are in general
two different kinds there could be a
terminal expression which does not use
it not recursive and the non terminal
expression which is actually recursive
right so this looks really familiar
right
so in scala you know we have a sealed
trait and then a number of case classes
right so interpreter is actually the
algebraic datatype a turn right so it's
this closed system consisting of an
abstract super type and a number of case
classes and you know if we carry that
thought further we could say that
algebraic Teta datatypes actually our
little languages and so and then we have
interpreters for sort of interpreting
those languages for example option is a
little language that has two
instructions so one one of them is we're
specifying that there is an element of
type a and the other one is for
specifying that there is not an element
of type an eye so you have none and some
these are both terminal expressions in
that in the pattern so yeah you take a
problem that occurs often which is the
ability to say that there is the lack of
a value so that's what what option does
and then you express instances of it as
sentences in a simple language that is
in the option datatype and then you
solve the problem by interpreting these
sentences so but we'll get to what that
means - it's actually interpret option
so again option is purely syntactic
right there there is no inherent meaning
ascribed some and none right it just
some has a value of type a and none does
not but the the actual option datatype
doesn't tell you anything about what
that means right it's up to some
interpretation in a context to then
deconstruct
and figure out you know what to do in
the case that is none other if it's some
so if we wanted to take the interpreter
pattern very literally then option would
have a method like this it would take a
mutable context which is passed into
option and then this the interpret
method would proceed to mutate that
context in a certain way but then we'd
have to have one method option per
behavior that we want right so so we'd
have to have a foo context in a bar
context at any type of context that we
might want to work with option we'd have
to have an entirely new method well
fortunately all of these interpreters
are going to have a very similar
structure so what we have instead is a
fault
so fold can be seen as the interpreter
for option you give it the meanings of
the individual constructors for the nun
and the sum so you're saying in the case
of some turn this option into a B by
just using the Zed and then indicate
that me sorry in case of nun and then in
the case of some turn it into a B by
using the function f so you pass in
handlers for each of the cases and
that's what it means to sort of
interpret an option to give it some
semantics so the the astute listener
will well note that that is the visitor
pattern right so we're actually passing
in the the Z&amp;amp;F objects actually
constitute a visitor object so if we
were to implement the visitor pattern
for for option then you know we have
something like option visitor and it
would have two members one of them would
be you know have one of them would have
the shape of F and the other one would
have the just be a sort of a default
value to give in case of none all right
but we can fold any ADT we just need a
handler for each case so in our regular
expression language we can write many
interpreters that they're all share the
same structure by just passing in how we
want to handle each of the cases all
right so we can fold one of these
regular expressions
spices saying well how do we handle
literals how do we turn them into A's
and then how do we handle ends and then
many an or and so it's recursive so the
only case that really turns something
into an a is is lit right you turn a
literal string into an egg and all the
other ones recurse
over the structure using that that inner
a as the argument okay so yeah we have
some other language a that we're turning
then we're turning this into so in that
structure it didn't really matter that
our literals were strings they could
have been any type right for at least
for the case of sort of the general fold
so instead of having an expression whose
literals are strings we just say well we
have an expression whose literals are T
of some type T and then that works as
long as we can turn our T's into the
language or into the semantics a that
works out and the implementation is
identical okay but so this so the the
fold so writing the general fold like
this actually makes this pattern easier
to to see like we I mean we could have
extracted some kind of general thing
like this like we could have could have
extracted the idea that that the
literals don't have to be strings you
know from the interpreter pattern
somehow but I think writing it you know
when you write out the fold like this it
becomes very obvious that the literals
don't have to be strings okay so what is
folding really so folding essentially
replaces all the instructions in the
program so you have your expression
language and you have some expression
written in that language and folding
replaces all of those instructions with
instructions that come from a different
language but that language has to have
the same kind of structure right for
example we could fold our regular
expressions let's say they were full of
boolean s-- instead of strings then we
could use it basically as a boolean
algebra so then we could say that you
know folding in a
regular expression that has full of
bullying's passing in the identity for
the literals and then and for the
sequence thing and not instead of many
so we're saying that the the meaning of
many is actually not and then we're
saying that the meaning of the or thing
is is boolean or so the meaning of the
structure isn't specified until we give
it meaning by folding so for example
yeah using boolean instead of strings so
they actually give this example in the
book right so there's a fully worked
example in C++ really really long hairy
C++ that they so they go through this
exercise of implementing a boolean
expression language but it's totally
separate from the from the string
expression language that we used earlier
but it's very similar and has a similar
structure right so a boolean expression
is you know an or and and not and they
have variables or they have you know
another boolean expression
oh there's one case missing it which
should be constant so I see the constant
true or false
okay so then this this example is
slightly more enriched so in addition to
having the constants or the literals
through it Voss they also have variables
so you could have variables that have
names that look like strings and then
you can actually the idea is that you
should be able to interpret it and
replace those variables with boolean's
yeah so you have so you have a boolean
expression could be represented in Scala
like this so you have a literal boolean
you have and not or and then a var which
is a string so that's just a variable
name and it's not specified what that
means right what does it mean for there
to be a string inside of this thing so
what they do so the book talks about
using different interpreters in this
particular example and and they give
implementations for each of these
Tirpitz but in the book the two
interpreters are almost identical so
they have two examples that are nearly
identical to each other and then they
have two solutions to one of the
interpreter one of their examples
they're also nearly identical and so
these signatures are kind of simplified
from what the book uses it uses a so in
the book they use a mutable map instead
of the environment lookup thing here but
otherwise it's basically the same idea
so two interpreters for boolean
expressions one of them is evaluate
which given an expression a boolean
expression and an environment in which
we can look up variables right variables
named with strings and that could give
us boolean then we can interpret the
entire expression into a boolean but
also there's another interpreter which
we're given a boolean expression E and
an environment in which we can look up
expressions then we can give we can get
an expression where the variables are
replaced with sort of their reference
right but the variables don't have to be
strings right as the same as before so
we can actually write this the structure
of this interpreter so we're once and
for all so instead of using strings will
just use generics and we'll say that
variables are represented by some type a
right we have something embedded that
represent variables and that the type
that represents variables is a okay so
then we can write a fold a generic
interpreter over these boolean
expressions and then we just take a
handler we take a visitor right we take
a handler for each of the instructions
and the one that's this is essentially
the same as the one for the string
example with the difference that there's
a lookup function for looking at
variables of type v and messin up them
up with okay okay so then once we have
this sort of generic we can write the
two interpreters using just by calling
fold with different arguments so the
first one evaluates to a boolean using
an environment that's that Maps variable
stuff of type a to a boolean but the
second one returns the same expression
that it got except with the variables
expanded to their bindings in the
environment so that makes sense right
see that so we're folding and we're
saying handle the literal in the first
case we're saying handle ooh literal
just by returning the boolean and oh
actually that should be n not identity
it should be super you looking up
looking it up no no actually that if the
expression contains literal boolean
sorry literal bullying's so we fold and
for literal boolean as we say identity
for n we say ands for naught we say not
for or say or but for variables we say
and look them up look up the boolean in
the environment now in replace we just
pass in the Constructors of the algebra
so we'll get exactly the same structure
out except in the variable case we'll
have expanded it out to an actual
expression but wait a minute look at the
look at the type signature of replace
does that look familiar to anybody
yeah look at it look at it some more
it's flatmap right and so once you see
it you just like so the Gang of Four
book the bastion of object-oriented
programming contains no next right so
the interpreter pattern is essentially
the the monad pattern in fact let's look
at the structure of interpreter again
right so we have an abstract expression
and then we have a terminal expression
and we have a non-terminal expression
which is recursive right so why do we
need a pattern language at all can we
just model this in Scala yes we can so
we don't need you know we don't need
English we could just say use a higher
kind of type and so you have some
abstract expression right seal trait an
expression and then a terminal
expression carries some value of type a
and you have a non terminal expression
then that adds some structure of type F
and that structure is then full of other
expressions right but this is actually
you know a very common data time and
it's called the free monad alright so it
interpreter is essentially the free
monad pattern right so who would have
thought I'd like free monads we're in
the ganga for book and so and this this
structure is in scala said i put its you
know it's easy to write on your on your
own okay so then the boolean algebra
that did develop in the C++
implementation could look like this you
have a seal trait pull out for boolean
algebra and then you have these cases so
you have a literal boolean and then the
and or not cases just contain a they
just have holes in them but because the
idea is that bool alga is going to be
the structure that contains them the
recursion right so in the case of and it
has two holes so that says that we're
actually going to in if we go back to
the to the free thing where we see that
that
F is not going to be bull elk and if
it's ant there's going to be two
expressions right and if it's not it's
going to be one expression and so then
the boolean expression language is as
the free monad generated by the boolean
algebra all right so what does it mean
to interpret an expression in the free
monad well it means to translate it to
some other Monat so this could be the
sort of side effect Monnet or it could
be the IO monad or it could be state or
the option there could be lists there
could be any other any other monad or
any of the data type that has the same
structure basically that has some
terminal expression and some non
terminal expression in its in its
language okay so yeah monad is just
something very simple
so a monad has as pure and bind which
you can see as the terminal expression
so you can held on to that Mike's then
okay so then we have a terminal
expression which is pure and then a non
terminal expression you can see that as
being the bind case so it's you know you
have an M full of a's and then you have
a way of turning your variables of type
a into other into knives all right and
then the squiggly line thing so if we
look at the fold map signature it's
saying yeah so it's saying that if we
have a you know a recursion over this F
thing we can turn it into we can
translate it interpret it in the
language G by turning all the apps into
into G's and that's what that squiggly
line thing is it turns on F of a into G
of a for any a we can implement the
option monad using free just by using a
sort of a trivial functor so we turn off
the recursion so then we have either an
A or or unit and we can construct any
kind of language that we like so more or
less any problem that we can think of
can be modeled as an algebra like this
and we can take the free monad that
turns that into a recursive expression
language with with variable bindings and
here's one I made earlier so this is
when I worked on with with dick wall and
Jessica car and so we made this free
monad to talk to couch and so we just
have an algebra that has like one case
class for everything that you might want
to do to a Cutts database and then we
take the free mode out of that like that
we have a couch monad and now you know
we can talk about couch things in our
little language but what that means is
then given by an interpreter like this
so run couch takes that thing and turns
it into like a skeleton task or an i/o
monad or or side-effects or something so
in summary I think that you know the
game before book that if there's
anything to take away from this book it
is it's that composition is it should be
favored over inheritance and I think
that they tried to hammer that home here
a lot and and they also say to prefer
immutability over mutability they don't
necessarily say that strictly but but
that's basically what that means so
instead of having a superclass with
inheritance where you model the the
different behaviors as concrete
subclasses you have an algebra and you
model the different behavior or the
different meanings with different
interpreters that's all I got thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>