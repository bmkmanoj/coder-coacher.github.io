<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Three Keys to Successful Single Page Web Applications | Coder Coacher - Coaching Coders</title><meta content="Three Keys to Successful Single Page Web Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Three Keys to Successful Single Page Web Applications</b></h2><h5 class="post__date">2013-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/46Bu9ms9mBg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">11.8 seconds across the internet eleven
point eight seconds is the average
amount of time it takes for a page to
load as our browsers and computers and
the network has gotten faster we've
taken the opportunity to have more and
more data over the pipe to the user and
the end result the users experience has
not gotten any faster and the user is
still waiting around for web pages to
load the walk out of here at the end of
the talk
having seen the three keys to creating
an engaging experience that will keep
people far more engaged for far longer
these three keys are applicable to any
single page web application development
framework that you choose to use and
will be applicable to ones that are
developed in the future when you click
on a button on a website if there's a
reaction within 0.1 seconds you'll come
to consider that reaction to have
happened immediately that is an exact
result of your interacting with the
website and taking that action you might
even become to experience the website as
an extension of yourself and come to
love it's fast quick interactive
experience
if after pushing a button it takes a
second for the website to reload you
will begin to notice a lag you will
separate yourself from the experience
and the experience won't be snappy quick
or as interactive if it takes up to 10
seconds for the reaction to occur you'll
start thinking about something else
you'll start thinking about should I
check my email what do I want to have
for lunch
should I go surf another website and if
that action takes longer than 10 seconds
you will leave you won't wait around for
it to finish and then you'll end up
trying to come back later and see if
that action finished quite often when
this happens the result of a
error happening but not passing that
error on to the user and the user seeing
a spinning icon continue to happen and
I've had users of my web applications
come back hours later
saying the web sites still loading even
though the spinning icon because the
spinning icon is still spinning
so what does it mean that the average
web page takes eleven point eight
seconds to load when you've got one
second to create an interactive
experience in ten seconds before you
lose your users attention at all the
first key to developing an engaging
experience that will keep your users far
more engaged for far longer is to move
your logic and data from the server to
the client and to understand why this is
important we'll have to take a look at
the traditional model of a web
application this would be your standard
Ruby on Rails Python Django or any other
MVC server-side application and in fact
is the way that the Internet has worked
for most of its history the browser
makes a request to the server the server
responds with some HTML the HTML
contains requests for CSS images
JavaScript flash video and whatever and
so the browser will then request all
these things from the server and the
server will respond with them and this
can now takes up on average of about a
hundred different requests per web page
across the internet and every time you
click on a link or move to another page
it happens all over again yes there will
be some caching that gets in the way so
not all the requests are made or all the
requests half the fully process but you
still have this many amounts of round
trips going back and forth to the server
and trying to get information to load
into the page
so the first bottleneck in this strategy
is the network latency from the first
request from the client going to the
server considering you've only got 100
milliseconds in order to respond in
order to have this fast fun snappy
application the network latency can eat
it that ate up all that time by itself
then the server has to process the
request and figure out what to do with
it often this is very quick but that
request might have to query the database
in data intensive applications this can
take an awful long time and eat up the
rest of your 10 seconds but in many
applications this also happens very
quickly then the server has to process
the results of this query often
generating HTML strings which are then
sent back across the network experienced
in the network latency again and finally
the client renders the page so rather
than go through this long process every
time a user requests the page or wants
to see some new information by moving
your logic and data to the client you
can just immediately access use that
information and render it bypassing the
server the database the server-side
database and the network latency
altogether this has the additional
benefit of creating a byproduct of
distributed creating as a byproduct
distributed computing where all of this
HTML concatenate a CH tml string
concatenation that was being processed
on the server is pushed off onto the
connected clients so instead of having
to build and maintain all of the server
hardware to generate these strings and
push them back the people who are
connecting to your system are now
responsible for maintaining and building
the hardware that is going to run at
your website so it ends up being a much
more scalable and cheaper solution to
building a web app
occasion but it turns out that only
about 20% of the time spent loading a
page is due to the time on the server
and in fact most of the time the great
bulk of it is done on the client taking
the HTML and generating the page from it
it done some thinking about you know
what why is this why does the why is the
server so much faster and I think it's
because organizations are built as in
order to conquer the problems of the
backend the backend has been such a big
problem for so long that it's not
uncommon in a hundred person engineering
organization for only one or two
front-end engineers to be there where we
have 98 concentrating on the problem of
the backend as a result the backend has
been optimized as much as possible and
now all the complications have been
solved it's up to the front-end
engineers in the front end to solve more
problems plus we're compounding the the
front-end by pushing a lot of things off
of the server and onto the client which
brings us to the second key to creating
an engaging experience that will keep
people far more engaged for far longer
and that is to load only the changes in
the client that happen so if you picture
a standard slide show that one of your
friends has sent you from their wedding
and you get not just a slide show on the
page with the thumbnails of the image
but you also get all the ornamentation
around it that includes the top
navigation the left navigation adds
footers and text below there and when
you go and you click on a thumbnail when
all you want to see is the picture
refresh to the new picture you end up
with a flashing white screen followed by
a very slow page load as the entire
thing
loads so contrast that experience with a
single page of web application where
though the only thing that reloads
is the image on the page itself when you
click on the thumbnail now you're not
reloading all that HTML off the client
that takes up all the different parts of
the application so there's a lot less
commute data being pushed back over the
client because you're not reloading the
same data over and over again and you
have that snappy 0.1 second user
interaction time that keeps users
engaged with your application so the
third key to keeping users engaged and
and and around for much longer is to
plan for some the challenges that come
with the structural changes involved in
pushing code from the server to the
client rather than focus just on the
technical aspects of this which a lot of
talks have is a lot of frameworks out
there solving some of the technical
problems I want to focus on on things
that are going to come up and maybe not
as technical in nature but there are
four challenges that you're going to
encounter the first challenge being the
broken back button the second that
search engine optimization complications
the third being missing analytics and
the fourth a lack of error tracking
these are all reasons I've heard from
managers not wanting to build a single
page application and saying no we're
going to stick with the MVC approach
because how do you solve all of these
problems well with single page
application all these problems are in
fact solvable with the broken back
button so imagine if you will back to
the slideshow presentation and now
they've upgraded it to be a single page
application and when you go and click on
the thumbnails you go to the next page
into the next page well when somebody
presses that when you want to go back to
the second image chances are you're not
going to click
on the second thumbnail because because
you're using the web and you're used to
this interface you're going to click on
the back button so the back button you
would expect to bring you back to number
two but the problem is that the back
button doesn't manage the state of the
application the back button is just
manages the history of the URL so when
you click the back button you're
actually go back to whatever site you
were on before the you went to the
slideshow and this result in a very
jarring user experience as you're no
longer going to be looking at the
slideshow and might not even be on the
same site and have to figure out how to
get back to where you were before more
experience the users the web will just
push the forward button but other people
will have to go back to the email find
the link again and click on it so the
solution to this problem is to make the
URL your API to drive all changes on
your UI and interaction through URL
changes and and in doing so tap into the
URL management system of the browser's
by clicking on the then by clicking on
the back button you'll cycle back
through the URLs and the site will
update so let's take a look at what this
looks like when a user comes and clicks
on the button on a traditional
application we will just execute some
JavaScript and dialog pops up so but
rather than having JavaScript execute
immediately and pop up the dialog have
the clicking the back button update the
URL and then have the URL a change
initiate the pop-up so click on the
click on the button update the URL pop
up the dialogue so the code to do this
is actually surprisingly simple all you
do is bind a hash change event handler
on the window object and then this event
handler will function will get executed
every time the hash changes
you investigate okay what is the value
of the hash at this time compare it
against whatever strings comparison you
want to in this case we look at pop up
equal to true if it is we pop up the
dialogue else we hide it again so what
you end up getting here is a very
rudimentary router it's a method of
moving your router from your server side
to your client side and you can do
obviously you want to do a lot more
complicated interactions with it than
just this but this is the basic thought
and format behind it so let's take a
look at what that looks like an
application so you notice here is
application URL just has index.html on
it now when I go and click on the open
dialog button it updates the URL and
this URL state change pops up the dialog
then I go and click on the close button
it updates the URL through moving the
pop-up equals true from the hash and
that closes the dialog now you open it
and close it again and because you've
been activating the pop-up based off of
the URL changes the popups activation is
now hooked into the history management
system of the browser so you can click
on the back button and the pocket dialog
pops up click it again and it goes away
you're able to copy and paste to another
tab and that wasn't there because I
wasn't there before so it copy and paste
to another tab and the dialog appears so
now you've got control over your web
application and so that users can take
it and send it to friends put it on
Facebook or wherever and they'll get
back to the exact same state in the
application as it is they were when it
was sent without this all they would be
able to copy is the URL and would always
just show the open dialog
it wouldn't show up the pop up they had
come to expect the second challenge
involved in building an experience that
users will find more engaging and for
longer is search engine optimization
complications and to understand why
search engine optimization is a problem
for single page applications you have to
understand how the search engines index
the websites so searching is an index
websites through use of a process on
their servers called a web crawler that
will just go out and visit URLs it will
pull down all the HTML that the server
sends back parse it for looking for
links and then it will go visit those
links and when visiting those links it
will parse the HTML look for links and
then it'll go and visit those links and
so in doing so it'll spider its way
crawl its way throughout your website
indexing the entire thing but what it
doesn't do is it doesn't execute any
JavaScript when it goes and visits these
web pages so when you it goes and it
attempts to visit a hash tag on the end
of your URL it doesn't initiate any
JavaScript your page doesn't update no
new links are presented and it doesn't
go anywhere fortunately even though
single page web applications are a
fairly new development the system's
underlying them namely Ajax have been
around for a while so that the search
engines have come up with a way to allow
Ajax to be indexed and namely that's
through a URL remapping where it takes
the it looks for URLs that have a have a
hash bang so they have the exclamation
point after the hash tag and rather than
going and visiting those URLs directly
it remaps it to question mark underscore
escape fragment underscore equals and it
goes and requests that page from your
servers so if you develop your servers
so that they respond to this pattern
they will now be able to be indexed by
by the web crawlers and search engines
and it actually gives your single page
web application an unfair advantage
because you're able to segment your
responses according to your audience
when you know it's a web crawler coming
through to the escape fragment you can
provide very SEO optimized text and only
display the image you want you want to
appear in the search results and when a
person comes in looking at it you don't
you can ignore all search engine
optimization practices and you can focus
your text and content directly on the
audience who is coming so now you've got
your content optimized to whoever is
visiting the site rather than having to
have this conglomerate as served up to
both users so the third challenge in
creating an experience that's more and
gate far more engaging and will keep
your users around for far longer is
missing analytics and your standard
traditional MVC application the Analects
code snippet just gets copied and pasted
to the bottom of the pit of every page
and when the user goes and clicks on a
new page then that's fine the analytics
code is copied and pasted at the bottom
of that page - and the analytic stuff
gets activated on a single page web
application on the other hand it's fine
on the first request you can put the
snippet in at the bottom of the page but
subsequent requests they don't request
the new page they request data from the
server and they get JSON strings back so
if you're getting Jason strings back you
don't have this snippet at the bottom of
the page what do you do to track
analytics well there's a few ways you
could do it you could just put that HTML
snippet in the Jason and program the
JavaScript to stick it at the bottom of
the page but that's really going to be
an ugly hack a much better way is to tap
into this rudimentary router that we
created that that executes when the URL
gets updated so when the URL updates
instead of just popping up that dialog
you pop up that dialog and file an app
fire an analytics callback the N
Luc's engine telling the which user
updated the dialogue when and so you're
actually able to get much finer grained
detailed analytics because you can track
every single user interaction you can
tell what people clicked on by having
the URL be differently you can even make
a generic one where you just grab the
URL often the user and send it to the
analytics engine and now you're tracking
every single URL change on your
application so getting analytics done
for your single page web application is
almost just as simple as doing it for a
traditional application so the fourth
and last challenge with developing a
single page web application is the lack
of error tracking in this traditional
MVC application most of the code resides
on the server and so most of your bugs
and errors happen on the server so as a
user comes along and encounters an error
then encounter the error is actually
generated on the server side the server
just logs it to a file and you can and
moves on and anytime you want to go and
find out about those errors you just go
open the log file and look at them and
hey there's all your errors but on a
single page application almost all of
your code has been moved to the client
side and there's no log file for
developers to go investigate and the
errors are just log to the console and
then and then nobody can use them
because 99% of your users aren't going
to have an error console open and the
developers aren't going to be able to
see any of the errors because they're on
the client side so the solution to this
is to catch these JavaScript errors
either using a try-catch block or using
the window dot on error event handler
and sending over Ajax the errors back to
the server and then you can store these
errors in the log file as you're used to
or you can store them in a database and
in fact this is such a prevalent problem
in single page
web app development that there's many
third-party services that have become
software-as-a-service is set up exactly
to solve this problem and they'll have
lots of charts and graphs and reports
that you're probably not going to
implement so I encourage checking them
out so the as promised the three keys to
developing in a far more engaging
experience to keep the users around for
far longer or to move the logic and data
to the client load only the changes on
the page that happen and plan for the
challenges for the big challenges that
the frameworks won't that won't or don't
handle for you most of the time are the
broken back button which you can handle
through the making of URL your API
search engine optimization complications
which are fixed through the escaped
fragment missing analytics which you fix
through inputting analytics calls into
your client-side router and a lack of
error tracking which you you fix by
catching the errors and and sending them
on to third-party applications or on to
your server for for tracking yourself
alright well I want to leave you with
this and you go away remember that
you've got about a hundred milliseconds
in your application to respond to keep
the users engaged fully engaged into
your application you've got a second
before they start to lose interest and
the rhein wanders off and don't let your
applications get to ten seconds long
where users are just going to lose
interest and go away
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>