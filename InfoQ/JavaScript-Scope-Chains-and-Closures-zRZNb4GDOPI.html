<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript Scope Chains and Closures | Coder Coacher - Coaching Coders</title><meta content="JavaScript Scope Chains and Closures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript Scope Chains and Closures</b></h2><h5 class="post__date">2014-07-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zRZNb4GDOPI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for every thanks everybody for
coming out we got a great group of folks
here tonight so I really appreciate it
and I know that almost everybody here
does a lot of JavaScript stuff so
there's sort of an obvious question you
know we're here in San Francisco doing
JavaScript why talk about scopes and
scope chains and closures here and the
answer is that they're not explained
really well and the real test of that is
if you've ever had the situation where
someone asks you about how scope chains
or closures work and you start the
explanation and you kind of get a little
bit in there and then all of a sudden
you're like well and then it's kind of
like when you do this so anytime you're
saying it's kind of like when that's
usually a warning that maybe something's
not quite working so you know we want to
get a better idea of exactly what's
going on so I I don't want to point to
any particular sources because you know
I don't really think that's productive
but let's just say if you were to go out
and Google for scope chains and closures
or even just closures in particular
you'll find a lot of things on the
Internet and if you drill down you'll
find a lot of nonsense in there and I
mean just a ridiculous amount of
nonsense and like I said I don't want to
I mean I could make a whole sort of
funny talk putting stuff up on the white
you know white board I was going to say
up on the projector but I don't want to
do that because it's not really about
anything that's out there that's not
quite right it's about helping everybody
get it right in the future I think
that's more valuable use of our time so
this is what we want to do we want to
make really clear what's actually going
on so my goal is not for not just for
you know me to say some things and
hopefully it makes sense to you
my goal is actually that you can go out
and spread this information so with only
you know a couple hundred people here
there's many thousands of JavaScript
developers in San Francisco so my goal
is that at the end you know you
understand the stuff really well and
that you can easily and quickly explain
this to other people without resorting
to any hand waving so hand waving is
that's that thing where you sort of run
out of technical information and you
kind of feel like well you know I should
know this you should know this let's
just pretend that we know it and move on
because there's way too much of that out
there so we are one more
you know maybe plug for why the stuff is
important if it wasn't obvious and we'll
look at examples of this later but scope
chains and closures are not they're not
optional in JavaScript so there's no
syntax for this there's no keyword that
you type there's no special feature that
you turn on you don't get to opt in or
opt out so these are things that apply
to your programs all the time every
single time that you write a function
without them a lot of plain old
JavaScript wouldn't work at all so
really really simple things would not
work without this and we'll see why and
it turns out that without a pretty good
working knowledge I mean you don't need
a theoretical knowledge but without a
working knowledge of how these things
fit together most of the advanced
patterns that you come across are pretty
hard to understand and then the last
thing is that the spec if you guys have
ever looked up the ECMO script spec so
the spec is not meant as a teaching
document right that's sort of a nice way
to put it the spec is meant to help
implementers figure out how to implement
JavaScript behavior and it's there to
help us figure out whether particular
implementation actually complies so
there's the sort of paradox where in
order to use the spec to figure out
what's going on you already need to know
what's supposed to be going on so if you
know what's supposed to happen you can
look it up in the spec you can go
through step by step so if you haven't
seen it you should you know definitely
take a look the ACMA script spec is is
known as pseudocode and it's there to
define the behavior of a compliant
implementation it's not there to explain
how there's no examples of code in the
entire thing there's no exam out there
to explain how code works and it's not
there to explain how any particular
implementation is supposed to work under
the hood so you know when we talk about
things here tonight one warning and I'll
probably try and give this a couple of
times during the talk there's no
guarantee that any particular
implementation works exactly this way
under the hood because the idea of the
spec is that if you are a compliant echo
script implementation your runtime
behaves as if it were running the
pseudocode in the spec as long as it
runs as if that is to say it implements
the interface kind of described in human
language in the spec then it complies so
underneath the hood you're welcome to do
any crazy thing you want for performance
or for minimizing memory footprint you
know or for whatever else you might want
to do so what we're talking about will
apply to every single compliant spec and
yet it sorry implementation and yet it
doesn't necessarily mean that if you
crack open v8 that you're going to see
this inside in fact I can guarantee you
won't because you know v8 works a
different way in terms of how it
represents JavaScript objects so when we
do and I know there's a lot of text on
here and you can't read that and all
these slides will be on speaker deck
afterward so you know this is this deck
is free to give out and free to use and
what I compress everything in here
because it's it's almost a bit funny
when I go to talk about scope we figured
that we better talk about what are the
rules what are the rules of scope and
I'm going to do that I'll do that
quickly I'm gonna get that out of the
way because it turns out that the
English description of how scope works
first of all it's impossible to cover
every nuance that's in the spec that's
number one number two it's hard for our
brains to figure out the implications of
what these rules are I think that's
probably true even the folks on tc39
that are working on the next version of
ACMA script you know if you look at a
lot of their debates about old features
and new features it's clear that you
know they're humans just like us and
they're limited in their ability to
figure out what the implications are
going to be of fairly sensible
requirements that they lay down right
now so I will run down the big scope
rule summary but what I'm going to move
into that I think will be a lot more
useful is the picture of how this thing
works we're going to look at some code
we're going to pretend that we're the
JavaScript runtime and we're going to
walk through the code line by line
and see exactly what's going on and I
think that picture will actually make a
lot more sense so when we when we get to
that hopefully the picture will pay off
and usually I do this on a white board
so I actually animate it step by step by
actually drawing on the white board
tonight I knew I wouldn't be able to do
that so what I've done is prepared
slides that correspond to almost
everything that I'm going to do so I can
step through with the slides and in a
couple of places where I need to make
live modifications I'll just do that in
PowerPoint like right in front of you
and you'll see how these structures
change so okay we have to do the
obligatory rundown of the rules and this
are not all of the rules so you know the
spec contains more rules and there's
lots of odds and ends but the main rules
work like this
okay so first every JavaScript runtime
has a global scope this is identical
with the global object and unfortunately
there was never a requirement that it
has to have a certain particular name so
in the browser this is what we call
window you know we call it global in a
worker we call it self and there's no
rule that in your own JavaScript runtime
you couldn't call it something else so
there's something there as a global but
it may have a different name the next
thing is that local variables are
declared with var and those are scoped
to the function that they're declared
within so every now and again you'll
come across someone waving around this
term lexical scope like it's a magical
some kind of magical incantation lexical
scope is nothing special all of the
modern languages that we use support
lexical scope so it's not JavaScript
versus everything else it's almost
everything that we use lexical scope
just means that you can figure out the
scope of a symbol based on where in the
parse tree the actual declaration is
that's all lexical scope means is that
there's a correlation between the place
where the thing is declared and the
scope of it function declarations and by
this we mean actually function
declarations not just any old function
so we're excluding function expressions
but function declarations also produce
local bindings and those actually turn
out to have priority over VARs in the
same scope although that's a little bit
of sort of trivia if you have functions
name the same thing as your VARs you
probably have other problems
so when a variable is accessed so when
you're accessing a variable trying to
resolve a symbol whether it's been
declared or not javascript resolves it
by looking in the current scope for a
local variable with that same name and
if it fails to find one it starts
working its way through the scopes from
innermost to outermost looking for
something with that same name as soon as
it finds something with that name it
stops and that's the binding that's used
if it doesn't find any variable by the
time it gets out to the global object
then if you're trying to read something
you end up with a reference error if
you're trying to write something you get
that situation where you've accidentally
created a global so you know that's sort
of almost universally regarded as a
mistake in the language design but
that's you know almost 20 year old
history at this point there's nothing we
can do about it
so if you're reading you get a reference
error if you're writing you're going to
implicitly create a global so it's
actually going to start at the inside
and we're going to see how that works so
it turns out there's a mechanism that
makes it easier to see how that works
it's not just a rule in words so the
rule in words is yes inner to outer but
it turns out there's what we're going to
see a mechanism that makes it easy to
sort of predict how this is operating
there's also handy if you guys ever go
and apply for a job somewhere and one of
the interview questions is well how
would you implement blah blah blah you
know in a JavaScript runtime you'll
actually have no problem at all
describing how this would work because
it turns out not to be very complicated
let's say we also have a little note
down here that if an outer variable is
shadowed by an inner variable of the
same name the outer one won't be
accessible through scope resolution if
the outer one happens to be in the
global object you can kind of go around
the side right because you could say
global dot or window dot but if it's in
an intermediate scope and then it's no
longer accessible and it turns out
there's one more don't worry there's not
like ten pages of this there's only two
two pages of the big scope rule summary
hoisting sort of a bizarre word the
metaphor is that it's like moving the
code to the top of a function that's
where the term hoisting comes from but
it's not really having it doesn't really
have anything to do with moving
nothing's being moved at all there's two
different phases to running the code so
what happens is that before we get to
the execution phase on a function
we're going to do this other phase and
we could call it hoisting if we want to
where we're going to parse and scan the
body of the function looking for
declaration so we're going to be looking
for VARs that we're going to be looking
for function declarations and those
things are going to get special
treatment so if we find a VAR
declaration we're going to create a
special local variable slot for that
symbol and if we get a function
declaration we're going to do two things
we're going to create a local a local
symbol binding in the scope for that
variable and we're also going to
actually build the function object and
associate it with that symbol
so at hoisting time VARs just get sort
of a reservation they get a slot but no
actual value whereas function
declarations get both a symbol local
binding for the symbol and a value the
last main note here is the hoisting
disregards program flow logic so this is
where those strange trivia sort of
problems come from where you see a
return statement and then maybe a VAR
after the return and the question is
well does the VAR actually affect
anything and the answer is yes it does
because we're not paying any attention
at this point to the logic of the
function we're just doing sort of parse
scan work at this point now I have a
bunch of little notes down here I'm not
sure I'm even going to always take a
look I don't think we're even going to
go through any of these things so we
will ignore within here it turns out
that it turns out there is a facility in
JavaScript for sort of monkeying with
the scope chain yourself are called
width and if you're doing a meta
programming and building a framework and
you really know exactly what you're
doing that you may have a good use for
width but largely width is considered a
sort of deprecated because it's it's
roughly equivalent to controlling the
flow of the program based on data so
it's a little bit like eval and it also
breaks the optimizations that are in a
lot of browsers so width is largely
deprecated ACMA script six also
introduces blocks coping with let and
that's great that's awesome but we're
not going to talk about that here
tonight either that's sort of it becomes
kind of like a trivial side case of what
we're doing it sort of adds on but
doesn't really change things a whole lot
got some other notes down here and I
definitely recommend Kyle Simpson who's
a big open source guy
Texas and I believe he's giving a talk
that was on one of the slides we saw
earlier for an upcoming event um he has
a book called you don't know J s scopes
and closures he's actually doing a
series of books called you don't know J
s and believe me he actually does know
JavaScript insanely well but he makes
the point that actually none of us
really know what we're all kind of
always in the process of learning these
little things we didn't realize so he's
you know I say he knows a whole lot he's
incredibly humble and he's got this
great book that's actually free that you
can read or you can buy I have the dead
tree version called scopes and closures
it covers everything pretty much that
we're doing here tonight
so let's okay so now that I've gone and
done talked about a whole bunch of rules
in English that probably make no sense
whatsoever at this point let's take a
look at actual code and we'll pretend
that we're the JavaScript runtime and
we're going to look at how we process
this code and I promise this will
actually make complete sense we'll
figure out how this whole thing fits
together first a little warning this
code does not implement any actual
business rule for anything useful this
is a this is akin to the kind of things
that you'll see online where someone
will show you like a quiz they'll say
okay look at this and run this and tell
me what Z is equal to and you're like
hmm I wonder what Z is equal to at the
end of this you know I've done it this
way I've done it where we have a fake
business logic scenario but you have to
twist business logic pretty hard to get
it to cover all the strange cases I want
to cover here so I gave up on that and
I've gone back to things like ABCD and Z
but this is not actually a very
complicated piece of code at all it's
just constructed to cover a number of
scenarios so we start out at the very
beginning what we've got here is a chunk
of code and we've got our global scope
and we know that you know window has a
whole bunch of other stuff in it if you
go into your browser right now and type
window dot you'll see about 30,000
things that are injected into the
environment by the browser but that's
that's not our concern here so let's
pretend that it's empty to start with
and so what's going to happen first well
the first thing we're going to do is
we're going to actually do hoisting at
the outside level so before we actually
run anything in the script tag we're
going to do a hoisting out here so we're
going to look in the outermost level of
code here for VARs and function
declarations so we'll look here we find
a VAR b
and here we have a function declaration
for F so we're going to be creating an
entry in this scope object over here for
B and we're going to create one for F
and the one for F is actually going to
be bound to the function object that
we're calling F so after the global
hoisting it's going to look like this so
after the initial hoisting we have a B
we have an F we have an actual function
object which I'm calling lambda and I'm
putting the F in quotes because we know
that you know these JavaScript functions
don't really have proper names and any
point or to them is equivalent so
they're just kind of floating out there
we're going to call this thing F so we
have a symbol F over here and his value
is a reference to the object F so at
this point we've done the hoisting for
the outer part and we're ready to
actually start running code so we're
ready to come in and run logic starting
at line two so let's go ahead and do
that let's go run some global scope code
at line two well we've got a equals one
so what's going to happen there we're
going to look for a we're not going to
find it and so we're going to end up
creating an A out here in the global
scope so again arguably this is
something that we shouldn't be able to
do if you have strict mode on you can't
do this it probably should throw a
reference error but it does not so we're
going to end up with something like this
we're going to have an a over here with
a value 1 and then in line 3 we're going
to look up B and we already have B so
we'll just assign the value 2 to it and
we've already handled building the
function object so everything from line
5 through 19's already actually taken
place at hoisting time because we built
the function object at that point so
we're ready to run line 21 so here's
where things start to get interesting
we're going to run line 21 and that's
going to execute this function f so we
know that sooner or later we're going to
end up in F so we're going to end up at
line 6 right that's the idea we're going
to jump to some subroutine and we're
going to end up at line 6 but there's
actually a little ritual we've got to do
before we get there so just like every
language has some ritual that's involved
in doing a function call or some kind of
a jump maybe we you know put certain
values and so
registers or we push a return address on
the stack or we do some particular
ritual before we make the jump in
JavaScript there's also a ritual and
before we can enter f we need to set up
a local scope for F so what we're going
to do is first thing we'll create a
local scope object for f and here's a
place where I'm simplifying what's in
the spec a tiny bit so it turns out that
in the spec there's sort of two objects
theoretically which you know may or may
not coincide but that sort of is an edge
case and so the most important thing is
to think that we've got one object that
represents this scope and I'll give you
a couple hints from a qualitative point
of view meaning if you don't care about
performance optimization but you just
want to get the right answer you can
think of this as roughly being a
JavaScript object so you can think of it
as roughly being key value pairs and if
you're coming from a different language
background you want to think of this as
being allocated on the heap so it may
not seem obvious why that's important
now but you don't want to think about
these local scope bindings as being on a
stack this is actually an object and
it's on the heap there is a stack in
JavaScript and it's going to have a
reference to this but this object itself
is on the heat so we've got this object
set up here so what goes in there before
we can actually run the function we need
to do some setup so first thing we're
going to do is well we've got a formal
parameter on F called Z and we're
passing one so we hope that inside of F
there's better be a local scope binding
with the symbol Z and the value one so
that it'd better be in there what else
is going to go in there in every local
scope we have a symbol called this so
we're not going to talk about what this
points to tonight but in every local
scope there is a symbol called this and
it points to something so we've got one
of those we've also got that symbol
arguments so arguments points to a
pseudo array of whatever you passed
arguments is a local symbol we're going
to have that I could fill these in one
by one but they're all in the next slide
so maybe I'll come to here we're going
to have Z that's going to have a 1 we're
going to have this we're going to have
arguments that points to the pseudo
array the next thing we're going to do
is hosting on F so we're going to look
through the
of f/4 declarations and we're going to
find a VAR d we're going to find a VAR e
that's one of these tricky ones you know
I put it here just to make the
demonstration we've got a VAR e it's
after the return statement
this is unreachable code if you're
coming from like a C background you're
looking at this and going shouldn't the
compiler just optimize that right out
and you know maybe and C it would but
it's not going to in JavaScript and it
actually can't or it can behave as if it
cannot so we get an E and then we're
also we also have a function declaration
in here function G so G itself is going
to get a local scope slot and it's going
to have a pointer to the actual object G
so the actual function object over here
so we're almost ready to go we've got
the scope object we've got the
parameters we've got the hoisting
there's one last step so we're going to
have a hidden pointer javascript is
really big on hidden pointers right
we're going to have a hidden pointer
from the scope object to the scope that
it was defined in so since F is defined
out here we're going to have a handle or
a hidden pointer from the scope on F or
the scope of this execution of F to the
outer scope here and that's this pointer
right there it's this arrow so that's an
actual pointer it doesn't have a name
it's called the outer environment
reference so someday they'll formalize
this and give it a name but it's called
the outer environment reference and
that's going to be really important
because it provides a way that we can in
a simple mechanistic way do these
lookups so you know when the runtime
does variable resolution it doesn't do
it by reading the crazy rules that I
described it does it by looking up this
reference to go each step of the scope
chain so now we're ready to actually run
at line six so we're going to hop into
line six here where we have B equals
three and here's where I'm going to
actually break out of the presentation
mode I'm going to switch to a mirror
mode here and I'm going to actually make
changes to this slide oh yeah there we
go
okay so what we can do now is we can hop
in here and let me zoom so I can make
this big enough for us to see what we're
doing
and what we're going to do is we're
going to step in at line six and see
what actually see what actually happens
so line six B equals three so what
happens here we're going to look in the
local scope for we're going to look in
the local scope for B that's over here
we're not going to find it
so if JavaScript doesn't find it what
does it do it goes up this hidden
pointer and looks for it in the next
scope out so this is how that process
works of going from interscope to outer
scope it doesn't have to do with the
text at this point of the code at this
point that's already been processed what
we're doing is simply looking at an
object seeing is there something with
the name B if there is we're going to
use that if they're not if there's not
we're going to come up here and we're
going to end up doing is putting in a
three over here so I'm going to put in a
three and I'll do a strikethrough on
this so there was a two now there's a
three the next thing we've got is C
equals four so we're going to look for C
down here we're not going to find it
because it's not there
so we're going to go up to the next
scope out and we're going to look for C
here and because there's no C here but
we're doing an assignment and not a read
we're going to do that thing where we
may be unintentionally create a global
so now we've actually got this C equals
four over here maybe I'll color that
text red so we can see that it happened
later so we've created a see there
whether we wanted to or not the next
line D equals five that's pretty
straightforward because we have a D in
our local scope so we end up with a five
in there
and that should not be strikethrough so
we'll unstriped through that the next
line equals six so here's where that VAR
e is actually affecting our program flow
because we had a VAR e there is an e
slot in our local scope object and so
this six ends up down there if we did
not have that VAR e we would have ended
up putting the six and the e out here
and so that's how we can end up with a
statement like that affecting the flow
of our code now you're looking at this
going well I'm never going to write code
like that that's crazy why would ever
return and then put a var and the answer
is no you would never actually do that
that's not
how this happens here's how it happens
in real life you have some complicated
if else if else if and a year goes by
and you go back and you're fixing the
code and you go oh yeah we don't even
support this product anymore we're not
this use case doesn't apply let me go
and prune this code out so you take out
a branch which you knew for a fact
wasn't running maybe because it's
covered in your tests or you just know
for sure it's not running and something
over there breaks and now you've got to
go and fix some problem that's happened
in some other part of the system and
you're like how did that happen and
that's what happens is you've removed a
declaration that was in a chunk of code
and although that chunk of code wasn't
running the declaration was still
affecting the program flow through
hoisting so that's sort of something to
watch out for so we've got the equals
six
we already did lines 11 through 15
because that's really part of the
hoisting and that's what got us the G
binding down there so we get to line 17
so 17s got two pieces right we're going
to execute G and we're going to return
the value so we have to kind of repeat
this whole process all over again
because we want to run G so we're going
to do the same things a little bit
simpler this time because G is smaller
so before we can run G we've got to do
the same thing we have to make a scope
object for this execution of G and the
reason I say this this execution of G is
that you know every time you run a
function you expect it to have new local
scope values right so a scope object
does not go one-to-one with a function
it goes one-to-one with an invocation of
the function so if you run F 3 times you
expect to get three different scopes if
we run G three times we expect to get
three different scopes for G so if we
want to prepare to execute G we're going
to end up over here and I'll see I'll
make this a little bit bigger now for
this part I think we've done the hard
part there so when we go to setup for G
we're going to have to do hoisting first
so we look inside g for VAR declarations
and function declarations we find one of
them that's this one down here there's
no formal parameters or have to worry
about that we have this we have
arguments we have E and that last step
is the outer environment reference so G
or as I sorry the scope for this
execution of G is going to get an outer
environment reference that points to the
scope that G was defined in so it points
up to here so now you can see these
things connected together and the the
reason why we call it a scope chains
to make sense right the more of these
functions we have nested the more of
these objects we have essentially in a
linked list and so when you're looking
from the bottom up it's actually it
looks like a chain right you have this
scope over here and if you miss if
you're missing something in there you
can resolve up to here and if you're
missing something in here you can
resolve up to the global so from any
particular scope looking up its a scope
chain so now let's go in and run G and
when we run G we're going to we have
this local variable E and I mark this
over here so the e in the G scope
shadows the e in the F scope so this one
that I marked purple over here that's
that's inaccessible in G so this G this
has been shadowed the one over here so
there's absolutely no way unless we're
writing a debugger I mean if you're
writing a debugger that's a different
thing or if you're using the debugger
that's a different thing but as far as
client code goes there's no API that
lets you access anymore that's gone and
just to make the point just to make the
point a little bit clearer
these scope objects are not exposed
through any API so you know this picture
looks a little bit like inheritance if
that doesn't make sense you don't worry
about it if it does remind you of
prototypal inheritance I think that's
probably for a reason or at the stories
that brendan wrote the draft of this
language in ten days and I think when
you're doing a language in ten days you
reuse the patterns that work so this
looks a little bit like inheritance but
with inheritance we've got control over
all of the objects and all the entries
in the chain in the scope mechanism we
don't and that turns out it sounds like
we're missing a piece of API there but
it turns out that that's actually really
really helpful and we'll see why a
little bit later so okay so we have this
scope for G it's chained up to the scope
for F we've set a equals zero which is
the local Y down here the next line we
have two pieces to this so this is D
equals two times D so first we have to
do the right-hand side we have to
evaluate this so we have to do a lookup
of the D all the way on the right we're
looking up D over here we don't find it
so we come over here we look up D and we
find the five that was there and once
we've evaluated two times five is ten we
can then assign it back to D and the
assignment follows the same exact
pattern so we have two
look up D over here we don't find it we
find it over here so this D in the scope
of the FX ik you Shane just from five to
ten because of this line so this
function in here G is actually
manipulating data in its outer scope and
once we're done we can actually return
the ten so that comes back to here and
then we return from line 17 so we end up
back here and at line 21 we've got
ourselves a value of 10 and once we end
up finishing the script so once we've
done line 21 okay what happens to all
this stuff so let's just take a quick
look because it'll be important in the
next section of the talk what could get
garbage collected at this point so we
know that in JavaScript you don't have
control over the garbage collector right
that's that's sort of up to the
implementation how that works but we do
have a heuristic for what can be
collected and what can't and it works by
reach ability so it's not via a
reference counting it's via reach
ability if starting at the global object
you can reach through a reference a
particular object you can't collect it
because it might be used in the future
if you can't reach it then it can be
collected so everything with a red X
here can be collected because there's no
pointer to it from the top scope so up
here we have F but we don't actually
have a handle to this scope object and
therefore we don't have a handle to
these guys we don't have a handle to
this so that doesn't hold on to F scope
all this other stuff can go away so this
is where we get to at the end of the
scope investigation so any questions on
how this stuff works so far yeah
that you mention that the execution
context is stored in the heat because
like if you come Java programming you
know JVM like when you invoke a method
stored as a stack frame of the stack and
I was thinking it's probably the same
case in Java in JavaScript but are you
saying like closures are stored on the
heap so we're going to look at we're
going to look at our closures work in a
second so we will talk about that but
the bottom line is - all these scope
objects at least conceptually in the
naive implementation restored on the
heat so there's that weird little like
asterisk I keep having to bring up which
is that technically you are free to
create an implementation which does
everything on the stack that will create
some complications for closures but it's
allowed as long as it behaves this way
there's a question in the back yeah oh
sure I'm sorry thank you yes I will do
that
so the question was the question was are
these things on the heap and not the
stack because coming from Java we often
think of local allocations as being on
the stack so that is in a language like
Java we would think about these local
bindings being you know Z being on the
stack
something like arguments being on the
stack and then that pointer is on the
stack the object at point two might be
somewhere else but the pointer itself is
on the stack so that model works for
something like C and it works for you
know Java and you're technically allowed
to use it for JavaScript provided it
behaves differently but it's it's it
makes more sense just from a let's sort
of get our heads around this point of
view it makes more sense to think about
the naive implementation where these are
plain old objects on the heap and then
we could optimize later so other
questions before we go into closures
yeah
yes they would be and we're going to
look at that next we will good point so
yes the question was things will be
different if we return G the object and
not G with the call operator not the
result of running G and the answer the
question is yes they would be and that's
exactly the scenario that we're going to
do a little bit later where I kind of
tweak this a little bit so we can play
with what the result of that so the next
I'm going to look at here are closures
so where do the where did the idea of
closures come from what we want to do is
make this really really obvious what's
going on we don't want to say closures
are like when you have a function inside
of another function or they're kind of
like when this thing happens and look
there's something to distract me and
let's go back talk about Ajax now for a
while which which seriously I've seen
that in so many books it's just anyway
so the question is this what should
happen if we're defining a language if
we're creating JavaScript or some other
language what should we do
if the function is executed outside of
his original scope chain so assuming
that we have some kind of scope lexical
scoping rules that almost every modern
language has so when a function is
embedded in its scope chain and we're
running it where the scope chain is
right there it's kind of a no-brainer if
we can get the algorithm to work there's
no question about what's supposed to
happen but what happens if we hang on to
the function or send it somewhere and we
run it away from its original scope
chain and there is no one right answer
to this so this is a language design
issue you get to pick the answer if
you're creating a language so there's a
lot of possible answers I put three here
there's more I'm sure there's other ones
so one is you say you can't do that if
you do that you're going to get a seg
fault or something like that if you try
this and see you will generally get a
seg fault because you'll general see why
but you'll generally be dereferencing
something that doesn't exist so you
can't do that and see another answer
would be you can do that but so we'll
let people do that but there are free
variables referenced in the inner
function so in our example here we've
got a variable D here this is a free
variable right it's not local to G and
it's not passed into G so we've got a
free variable and maybe if we're going
to let you run G somewhere else we're
going to require you to give us a
binding for those free variables so this
is something that's not required but
it's actually optional in Ruby alright
so in Ruby you can create a proc and you
can run it with
binding object so you can say hey I've
got an idea of a scope chain over here
and I've got an idea of some code over
here and I'd like to tell Ruby to go and
run the code treating that as the scope
chain so you can manually do that in
Ruby and you can imagine a language
where you require that so the answer
that we have here in JavaScript
is that you can do that and the original
scope chain still magically works so the
answer which gives rise to the concept
of closures is to say yeah you can run
this function anywhere you can get away
with and will still work with its
original scope chain so that's the
assertion that's the that's the feature
we're trying to implement if we're
implementing a language that supports
closures so what exactly is the closure
itself yeah oh the sound is not so great
and probably my fault here see if we can
be I can hold this better sure so okay
so what is a closure so the closure is a
permanent link
it's a long-lived link between a
function and its scope chain it can be
used for all sorts of stuff it enables
the functionality that allows you to run
a function anywhere anytime and use its
original scope chain the closure is this
link between the function and the scope
chain and we've already seen what a
scope chain is that it's actual specific
objects that's not a mystery either
right scope chain is very specific data
structures linked together in a very
concrete way the closure is a link from
the function to that scope chain and how
does that actually work well it turns
out that you know again you can do it
however you want especially if you're
making up your own language but in
JavaScript it's actually there's a
strong hint in the spec that tells you
how this is supposed to work there is a
hidden variable on function objects
called a bracket bracket scope bracket
bracket so if you poked around with the
spec at all or read articles on
JavaScript you may be familiar with this
double square bracket notation so in the
spec hidden members that are described
as part of the internal JavaScript API
but are not exposed to client code are
marked with two square brackets so what
they're saying here is that there is a
hidden internal member of every function
which is a pointer to the scope that it
was defined in and it turns out that
once you have that little hint the whole
thing just falls down a whole problem
becomes super easy it really does
because once you have this
Poynter it means a couple things first
it means the scope chain can't go away
so we talked about this garbage
collection situation and we talked about
holding on to objects well if the
function holds on to the scope object it
was defined in that means as long as you
have the function it has its outer scope
if you don't have a function you can't
run it right so those two things kind of
some kind of cover 100% of the cases you
either can never run the function again
in which case you don't care what
happens to the outer environment or you
are going to run the function or at
least could in which case the function
is holding that outer environment for
you right there on a member and then how
do we use this well when we go to run
the function no matter where we are in
the program no matter what else has
happened we create the new scope object
for the new execution of the function
and we copy the reference from the scope
member of the function to create the
outer environment reference of the scope
object that we've created so what does
that look like in pictures because again
you know we get into trouble if we do
too much talking without pictures so
actually I'm going to skip over the
slide and get to the pictures and I'll
come back to the Y so let's add our new
knowledge and we'll make a little bit of
an adjustment to the code so what I've
done here is on line 17 I've ditched the
call operator we're going to return the
object G and the overall flow is still
going to be pretty similar so down in
line 20 we're going to grab the function
that gets returned from F and we're
going to execute it at line 21 so we
still end up running G the same object
anyway we execute and we still get the
same answer we still get a 10 out of the
bottom of this but the flow is a tiny
bit different so when we go to execute F
so if we run through 19 and we're
getting ready to run F here in line 20
we're going to create this thing here we
already talked about that so that's not
news but now we understand a little bit
more we know that we know that this
function f has a hidden scope member
that points back to there we know that
the G that was created at hoisting time
before we've even run F has a pointer
back to here and we know that the way
the JavaScript runtime can link up this
scope object here to the next one up is
by copying this reference here to create
this pointer there
so it's totally deterministic it's
totally straightforward once you see
this trick there's no mystery about how
this stuff works at all it's like a
closure is this member on here being
used to create a link between any
execution scope for F and the scope that
F was originally defined in so if we
were to step in and take a look at the
next step here so we know F and G have
scope handles nothing can get garbage
collected so far so if we run all the
way through line 20 so what happens when
we're finished with line 20 we've
returned to the object G and we've
assigned it to my G in the global scope
out here so we have a thing called my G
out here and that actually points
there's a curvy purple arrow over to
this G object over there this G object
is holding on to this scope via its
green scope pointer and that's why if we
have my G out here that's why we
actually have the scope available it
can't get garbage collected and we can
easily reuse it because we've got G and
G's got the outer scope so when we step
in and execute G so that's line 21 when
we go to run 21 we create a new scope
object for this execution of G that's
this guy over here that's not too new as
we saw that before but now we know that
where this black line comes from the
link from this scope to the outer scope
is just a copy of this green thing right
here actually go back one so this green
this green link on G just gets copied to
make that black one and that's it so
really it's just you know the whole
mystery just goes away and so now we
could say well when this is finished
here at line 21 when that's done or
let's say we finished 21 what's elbow
eligible for garbage collection now well
this picture looks a little bit
different so this was a question we had
earlier and I said yes it's going to
look different so now because we have my
G over here and my G holds onto this
G down here at the bottom and that G
holds on to this scope over here and
that scope is holding on to a bunch of
stuff it means that the objects on the
right with these red arrows sorry red
X's those can get garbage collected but
the stuff on the Left none of these
things can be garbage collected they
were all got pointers pointing to them
so that stuff's going to stick around
and if we run G any time later we can do
the same trick again because G's still
there and the scope that it points to is
still there so I'm going to rewind here
a tiny bit and talk about this stuff but
I wanted to skip over so we could get to
the pictures I think the pictures are a
little easier to digest at least they
are for me so why are closures important
because that's the next thing people
want to say well this is great that's
really interesting but why are they
important can I just ignore this and my
JavaScript will run okay and the answer
is well no not really there's two
situations where closures are used what
I like to call the implicit and the
explicit implicit is where you're using
closures without even thinking about it
but if you didn't have them you'd be in
trouble explicit is where you're
intentionally doing some kind of a pony
trick with closures so and there are
some useful things you can do with that
too so let's just take a look at this
right here so this this block of code
this would not work if we if we do not
have this closure rule so if we ran line
two we've got some data over here line
three this is about the simplest
asynchronous code we could write so
we're calling set timeout that tells the
browser we'd like it to schedule an
event for roughly a thousand
milliseconds in the future and that when
that event triggers we'd like it to run
this code in here so we'd like it to run
the stuff at line four but by the time
line four runs our main block of code
here is done so if we didn't have the
closure rule then when we were writing
this code we'd think well this data in
here that should be this data out here
because the scope chain rules does that
should be the case the lexical scoping
says that's true but there's there would
be no guarantee that the outer data
would actually still exist so and if
this if this is helpful for you would
all imagine what this would be like and
see if this doesn't make sense you just
ignore it but if if it's helpful imagine
what this would be like and see so me
line - looks like conch char star data
equals some info and of course there's
no set timeout and see but pretty much
every platform has something like it so
you call the Windows or the Mac OS C
call that schedules an event and you
give it maybe a function pointer and you
give it some kind of a timeout and
eventually hopefully the operating
system runs this code that you gave it a
pointer to and it does this console dot
log so maybe that's some kind of a
sprint F or something like that and it
gets to data and what happens well now
bad things happen right because data is
a reference or it's a pointer in this
case to something that was on the stack
but when the stack unwound it's gone so
what you've got now is either something
that's off the end of the stack or has
been replaced if there's other stack
frames there so this doesn't really work
if we don't have closures so this this
pattern here is what I call the implicit
use of closures so behind any kind of
asynchronous coding where we want to get
data from before the asynchronous event
- after the event through the scope
chain we need closures to get that to
work that's the implicit the explicit is
what we're going to talk about for this
last little section here which is it
turns out that because there's no client
API for working with these scopes so you
remember a little while back I mentioned
that these scope objects are there there
are references to them but there's no
client accessible API that lets you mess
around with them because there's no API
for them these represent the strongest
encapsulation mechanism we have in
JavaScript and JavaScript as we all
learned the hard way over these last
five six years is very weak on
encapsulation that's sort of the you
know the weakest piece of the whole
language and so we've done a lot of work
to try and rebuild that and that's this
that's closures on the module pattern so
if we have exactly one mechanism for
encapsulation and we want some
encapsulation that's what we're going to
lean on so pretty much every other
language has some system for this so
like in Java we have you know classes
with different visibility levels we have
packages we have interfaces versus
implementations we've lots of layers of
encapsulation in languages like C we've
got header files versus you know
implementation files so I can give you
the header or I can give you a library
you can run functions in that library
without
actually knowing what the code is inside
there in JavaScript we know the default
is everything ends up in one big pile so
the module pattern is a way of doing a
specific trick with closures in order to
give us a way to separate interface from
implementation and what we're going to
do is create a function use its local
scope as our internal area we can put
our local variables any private state
helper methods anything like that inside
and then what we're going to do is
return from that function an object that
represents the interface so it's going
to look like this so here's an example
this is a really really simple module
that just has one private data member
it's got some string in here well object
anyway called data we could put whatever
else we want in here we've got a couple
of functions defined we have a get data
that prints it out and a set data that
stores something else in there and we're
going to return an object with just the
get data and set data so the result of
this and you may this may start looking
more familiar because pretty much every
library in JavaScript that you're ever
going to see on the Internet is going to
be wrapped in something that looks a
whole lot like this the reason is that
we have a local scope for this function
and that allows us to stash our data and
whatever else we want to stash and when
we execute this function we're going to
grab just the interface this thing down
here that's being returned so we can
choose to expose just what we want
and we've actually that's sort of the
one really nice piece of encapsulation
mechanism that we have in JavaScript
yeah
so the iif ii is not my accessors my
axis is the thing that gets returned
from so it actually can't even if it
were to use you know arguments Kali or
if you put a name up in here or
something that would be a handle to the
function object but not but neither its
scope nor its return value so you
wouldn't have to worry about that so IIF
e stands for immediately invoked
function expression it's just a fancy
phrase for this pattern where we create
a function and then immediately execute
it and then grab the return value so
it's very much just like writing a
regular function and running it the main
difference is that if you were to write
a regular function and then execute it
you'd create this extra symbol you don't
need so if I made a function here called
say build accessors and then I run build
accessors to obtain my accessors at the
end of the day I'd have both my
accessors and build accessors hanging
out and what I'd like to do is come up
with something in a perfect world where
I don't leak any extra symbols so I only
get the thing out that I want out so
that's that's sort of this pattern here
it's not super required for the con you
know for using closures the way I'm
describing I just put it up here because
there's so much code that uses this
pattern that it's worth getting
comfortable with I guess yeah
Oh would I prefer it to prototypes for a
module or four you mean for creating
objects so it depends what you're trying
to do if you if you really want private
stay then this is really the only option
because with prototypes everything is
accessible you can always walk the
prototype chain and do whatever you want
so if you're arranging business objects
and creating relationships between them
that's a case where prototypes often
make more sense because you know you
trust yourself and you're trying to
share stuff with yourself and the
prototypes effectively hide things you
don't want to see but when we're
building modules that will eventually
get integrated into a bigger application
like you know let's say each person here
was working on a library and I'm going
to integrate those all it's like I want
to see your API I don't want to see any
of your implementation and you don't
really want me to see it either because
you might change it later and you don't
mean to depend on it so in that
situation the modules make more sense
and so when we're integrating pieces
whether we're using something like
require Jas or you know implicit sort of
integration like an angular we're going
to be using something like this
so I have a couple of other links on
here I won't you know I'm not going to
go through these for you but I'm like I
said I'm going to post this deck so you
can look at them later of all the stuff
on the Internet
there are very few articles that do a
really nice job of this but I really
like this one
I don't know this gentleman but I really
love the piece of work that he did here
describing how scopes closures and scope
chains work with reference to the spec
it's a little bit thorny er than what
I've gone through in here because he
does include that extra side case that
has to do with dealing with whiff so
it's a tiny bit more complicated but
it's a great place to go back to for
more of this and if you're interested in
where the heck did the word closure come
from anyway who was the first person to
sort of pitch this there's a little
article on the bottom it's really short
maybe half a page that talks about that
so you know hopefully it's clear why
this stuff is useful at this point so
scope chains and closures underlie all
the stuff that we're using not just your
basic asynchronous code but all the more
advanced patterns so some constructor
based patterns combine constructors with
closures object definition patterns and
a lot of libraries are implicitly used
closures so for example an angular a lot
of the things that you make are wrapped
in a function and so they automatically
leverage the closure module pattern
events and callbacks we talked about
more advanced async control flow stuff
so modules and dependency management
functional programming patterns so if
you're dealing with things like bind
trying to figure out how that works or
how you can implement that promises and
other monads generally rely on
converting functions into objects or
wrapping functions and other functions
and where do you store your state you
store it in a closure so all of these
more advanced patterns depend on
closures and where do we go from here I
would say please if this makes sense to
you then spread the word and take this
you know take this deck spend a little
time to get familiar with it presented
at your own company presented at school
present it wherever I've so many times
I've heard people and I mean people who
are very good developers doing great
work say things like yeah you know the
Scopes in JavaScript are kind of weird
you know it just kind of does something
this let's just end all that because
it's really hard to be taken seriously
when your language involves things that
are full of mysteries and nobody can
really explain it without sort of hand
waving and begging off so let's just
make this really clear and say that it's
nothing special and the more we can
demystify this the better it'll be for
everybody so that's pretty much what I
had to talk about here if you have any
questions we have a few more minutes
maybe two or three more minutes so so
performance implications so in terms of
in terms of cycles execution cycles the
impact is minimal in terms of memory
there's a potential cost because like
anything else in JavaScript if you're
holding a reference so we know es6 we've
got weak references but that's the
future and it's not really what we're
doing today with regular hard references
any function you hold holds the whole
scope chain so on the one hand you're
potentially holding a bunch of objects
which you may or may not need but here's
where it gets interesting if you need
those objects then you need them right
so it's not a leak it's an issue you
need to optimize in your code if you're
holding on to things in the scope chain
that you don't need sometimes people
will look at that and go well that's
essentially a leak you're using the more
closed more functions you hang on to the
more closures you're hanging on to the
more stuff you're hanging on to and it's
going to eat up a bunch of memory but
there's a really easy fix for that so
and I think I even have an example I can
show on here so here's an example I was
if we had more time I was going to maybe
show this in a browser but here's an
example of this module pattern it's the
same thing I just had up on the slide so
let's suppose that in here in the module
we have a buffer some very large piece
of data in real life it might be
something like a UN to eight array that
has megabytes of image data but here
we're just going to pretend that it is a
big piece of data it's actually a string
so let's suppose that when we get to the
end of this here we realize that okay
the way this code is currently written
we're going to be holding on to buffer
forever where I shouldn't say it forever
as long as I have accessors I have the
buffer but I don't need the buffer so
what do I do to fix this well it's
actually really easy I come down in here
and before I return from this function
I take buffer the symbol and I assign to
it something small like a number like
three or seven or no so now what I've
got is the symbol buffer is in scope and
the symbol buffer will be in scope
forever
but I'm not actually leaking the data
that goes with buffer so if buffer
pointed to like 10 Meg's of image data
what I've now got is the reference for
buffer which is you know maybe 8 bytes
or something but I haven't got the
buffer so this is all you have to do is
profile your code look for the big
objects that you don't need and then
clear them out before you return from
the function yeah well I think the I
would have to look at how v8 handles
closures so you know I'm not going to
give you a counter-argument without
knowing exactly how the implementation
works but I guess what I would I would
say sort of the the really I don't know
maybe the silly answers would be you
know always profile first it's never in
a you know it's not necessarily a
problem until it's actually a problem so
that's you know if true for all
performance issues the second thing is
that v8 is always doing other new
optimizations so you don't want to make
a big compromise in your architecture
for something that like in two weeks
might come out and be optimized so it
you know we don't want to write sloppy
code hoping Google will bail us out
that's not great either but I would just
I guess I would just be cautious about
it and see like whether it's really an
issue and if it turns out that it's
something you're doing a million of like
if you're processing like really tiny
sprites in a game and your performance
is critical the objects are small and
you have a lot of them then you know
that maybe there's no defense for this
and actually you just go with the
fastest thing today so you know
definitely do what you need to do for
performance anything else out here yeah
that bracket bracket scope we can't
really access that can you you can't
despite my
practical scope you ah
well so it's funny you should ask that
you cannot access it in client code
there's no API for that but you it is
actually there you can see it in Chrome
in the in the debug or if you want so
for example if I come in here and I I've
just this is just running that page I
was just looking at so we have my
accessors get right we've got some so I
get is it get data to get data so
there's the object if we ask chrome to
dump out the details on this if I go
into a console dot der on this object so
now we can expand it and we can see all
of the features in here so in this
object there is a thing called function
scope and if we expand that we can see
there's two two entities in here there's
global which you can always get to and
there's closure which is all of the
stuff in the scope chain outside of G it
doesn't include this guy's locals I
could we had more time I could
demonstrate that but this does not
include locals it only includes the
parent scope so it is actually here and
you can debug with it you just can't
program against it so awesome well
thanks thanks a lot I think we're out of
time for this
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>