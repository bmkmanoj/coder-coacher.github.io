<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Get MEAN! Part 2/3: Adjusting to Changing Tides with MongoDB | Coder Coacher - Coaching Coders</title><meta content="Get MEAN! Part 2/3: Adjusting to Changing Tides with MongoDB - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Get MEAN! Part 2/3: Adjusting to Changing Tides with MongoDB</b></h2><h5 class="post__date">2014-11-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1kI07pHrbgE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so um my name is Matt and so
there's my twitter handle and I am a
co-founder of the websites inkster do we
can go and learn about angular mean
stack or whatever rather than plug that
though I'm actually gonna shamelessly
plug two of my friends book Diego and
dal wrote a book and it's coming out
sometime soon so buy it they tell they
tell me it's good I haven't seen it
alright so what is Mongo Mongo is a no
sequel database it is open source and is
developed by a company called MongoDB
formerly 10gen it is a document store
database which essentially as Ward
mentioned is very similar to JSON
objects and it doesn't have a set schema
which really makes it like just
incredibly easy to manage and maintain
why would you use Mongo and why does it
work with the mean stack well it offers
a substantial amount of flexibility
especially over your typical relational
database style so it's really good for
unstructured data it does complement
nodes goal of JavaScript stack through
and through specially the main stacks
and storing data is very much like
storing JSON objects and it also has a
lot of really cool advanced queering
features like mapreduce and geo queering
so there are two big concepts to know
about MongoDB one are their collections
and collections are akin to tables and
sequel traditional sequel they contain
documents and you run queries on
collections now we have documents
doctrines are very similar to rose in
SQL they're queryable and they can be
nested as were demonstrated well I guess
you closed in it updates on documents
are atomic and they have a set limit of
about 16 megabytes so to begin with
we'll go ahead and install in quotes our
MongoDB driver and node so we'll do an
NPM install def def saves and what this
will do is write to the package that
JSON file so in the future we'll be able
to
npm install and then however Mongo
driver just pop up be really great
here's some code that looks like for
connecting to the MongoDB from within
our node server pretty simple pretty
self-explanatory you get a you call a
connect function and you get a callback
that has the database object now
typically what you want to do is you
want to reuse the same connection for
your entire node application and then
they do also you can also do connection
pooling with it and unfortunately
requiring the DB objects with the native
Mongo driver is actually fairly
difficult since it needs to be
initialized synchronously with the
Express app we do have an example in our
on the Express or on the github
repository so you can go ahead and check
that out if you interested in doing it
there's also a substantial number of
third-party Mongo libraries that will
take care of this for you for the
presentation that will be using the
native Mongo driver and now on to the
live coding portion of this so and
that's not what I want to show all right
so you can make this bigger ok yes I'll
see this trend eggs work out all right
so I pick it up we reward left off we
have a file that has all our functions
and these are exported and then they are
hooked into route so this is hooked into
our / AP I route and we're going to fill
up these functions now so to begin with
the first thing that you typically want
to do is you're gonna want to create
like an index route and the first thing
you want to do is return a list of all
questions that might be in the database
so to do this we create start by
creating a query object and I should
note that we have this object called
questions which is essentially is a
collection object as I mentioned about
collections there a series of documents
and we're going to call a fine query on
the collection object like this now what
this does is this actually doesn't go
out to the database just yet and we can
modify this query in several different
ways and hopefully we'll get to to being
able to do that later on the talk for
now though we're just going to call
query to right here and what this does
is this actually instructs the node
program to go out to the database and
query for the questions now as Ward
mentioned we want to have her
handle so if we have an error go ahead
and throw it next otherwise we're just
going to send back the questions to the
user word are explained to you guys
postman so i will be using that in this
demonstration here we have a route i
don't if you guys can see this hopefully
you can because i can't make it bigger
so anyways we're gonna go and send that
and you'll see that we're now getting
three questions back which has been
pre-populated in our database and this
is all working awesome next up we're
going to have our get singular question
by ID now for using this function we're
going to go ahead and do it by using a
method on the Mongo driver called find
one pretty simple and it's operates on
collections as we mentioned by the way
the syntax for creating a new collection
is just like this so what this does is
this creates a new DB collection on the
questions collection so call find one
here and what we'll do now is we're
going to pass in an object ID now as
word mentioned talk a little bit more
about object ids here the object ID is a
12 bite based by bison type and bison is
the JSON format essentially that MongoDB
uses natively the object ID specifically
is guaranteed pretty much to be unique
the first four bytes are a timestamp
that represent millisecond since the
epoch or second since Deepak and then
there's a three bite you can identify
our to buy process ID and then just a
three by random counts the underscore ID
field is very similar to the ID field
that's typically created in sequel
databases so it's very good to query on
so going back to this go back here and
do the same function with our callback
and with up about that one error there
and then we can also do again not that
one res JSON and sent a question back
now if we go back to our postman we can
now have this get questioned by deer out
and this is a string formation of the
bison object or I'm sorry the ID object
and we can go ahead and search for this
guy here and now we have this question
its return you can see we have a four
votes
a name associated with it and then some
text all right so now we can retrieve
some questions so let's go ahead and
figure out what it looks like to create
a question we're gonna have some code
here and what this is going to do is
it's going to take the information from
the post request and parse it out into a
text field that we're going to use to go
ahead and insert information so the
first thing to do is to create a
JavaScript hash that has our question so
you'll see here we're creating a new
datetime our nude 824 now and then the
text obviously and then the name of the
person who associate and we're gonna
start off with 0 now we're going to call
is going to call the insert method on
the questions collection again and we'll
just pass in the question variable and
call our callback function
alright so now if we go back to the
postman route we have a sample question
that we're gonna create what are this
will go ahead and click the send button
and as you can see this thing has been
returned back and what this means is
that has been successfully saved the
database now MongoDB also has a very
nice repple make this bigger and this is
kind of what the console looks like so
if we query for the collection we call
DB questions and then call the fine
method here and then pass in a blank
query so we get all them back and we'll
actually do a dot pretty method which
would make this nice we can see now that
the question we just created has been
actually successfully added if you guys
can see that oh there you guys go top so
we know it's been actually accessed and
entered in the database and we can also
again confirm this by calling our index
method which returns all four questions
that we have sweet all right now for the
fun part so this is where we do an
upvote or we we initiate the up though
route for our questions so this allows
people to be able to vote a question up
or down we're not going to restrain them
necessarily by the number of votes they
could have though our web interface will
probably stop them from doing it right
now as you can see we're just parsing
out the vote from the grey parameters
and then we're going to call this
function called find and modify and I
let's talk a little about this this is a
little different from a typical MongoDB
call which would be the update commands
the update command we could use however
it does not return the question itself
back it's kind of a fired release so we
won't be able to get the question back
and we won't be able to return it back
to our front end which is a requirement
of the front end so to begin with we
will search for the ID
all right now the second parameter of
this thing is actually interesting it's
a sorting parameter and this allows us
Mongo to sort the objects so because
we're clearing by a unique ID right now
this is not too important but if we were
say to query by an author we could sort
them according to a different field and
then only update the first one that's
been that are in the list now the second
part is actually gonna be our update
parameter and Mongo has this function
called increment which allows us to
atomically increment any variable inside
of the document so the syntax for this
is going to look something like this so
we have our vote count variable or a
vote count exceeds we filled inside the
document and we can update up updated by
the vote amount finally we have an
options field and the only option we
care about for this particular example
is new true by default what manga is
going to do is actually going to send
off the question of the update question
and then return back the question before
was updated by specifying the new equals
true we're actually gonna be able to get
the updated document back and then
finally of course as always the callback
all right so now if we go to our postman
client again I hope you guys can see
that we can upload a question
theoretically up syntax errors
all right tries again there we go all
right so now we have a vote count of
five if we press this again it's just
going to constantly increment 7 a-9 etc
we can even go over here we can upvote
it by three so if we send this now 12
going to go to 15 afterwards and this is
all against saved back to the database
if we'd like we can also decrement it by
one fantastic 13 12 so that's all
working alright and then the final
portion of a typical propagation is you
want to make sure you can delete
comments so to do this we're going to
use the find and remove function of
MongoDB and again what this looks like
is just dot find and remove search by
the ID and pass the function that'll
take the question back so if we'd like
to we can not return the function or I'm
sorry not return the question however
and and that would be the remove
commanded Mongo the finder move command
will actually go search for the document
and then remove the document and return
it back to our clients so we can check
to see if those successfully removed so
as always have the error function now
because of this the only way that we
know that the function has been or that
the question has actually been removed
is if the question has been returned if
no question is returned and there's no
error than we know that there wasn't
actually a question so we're going to
check to see if the question exists and
if it does exist we're going to go ahead
to a res dot status of a 20 for which is
going to be defined in our API spec and
then just not end which will send a
blank body back now if there was no
question then we have this function here
that's will throw an error automatically
and let the user know now in the postman
will go here and test out our delete
route so if we click the delete button
on this question we see that no content
was earned but there's a 20 for status
which means that our function completes
successfully if we try and press this
button again we're going to get the
error message question not found which
means that again everything is working
perfectly fine
alright so this is typically the point
when you might be able to have like a
prototype you have a demo you deploy it
you have some people uploading it and
it's great everything's going fine
you've got a live system however we've
all probably been here when a new
requirement has a period right and your
boss is going to come to you and he's
gonna go ahead and say like hey you know
what would be awesome is like we would
really like you to just be able to
classify these thing by categories also
it would be just super swell if you
could keep track of the individual votes
and when they were actually submitted
and you're like man already got this
production I don't necessarily want to
do any sort of database migration or
mark with that fortunately MongoDB you
don't have to so we're going to go back
up to a vote for question or actually go
back up to our create question first and
we're going to go ahead and when you
creating a question we're going to add
two new fields here the first one is
going to be a category if you guys can
see this alright first one's gonna be a
category and then the second one is
going to be the array of votes that war
was talked about previously and what
this vote the array of votes does is it
actually creates a bunch of sub
documents are going to be associated and
nested inside of the original Mongo
database document this also allows for
things like atomic operations inside of
the sub documents which is really really
a powerful now if we go back and we
check our rest are our create post route
and we try and add a new question hit
the send button
and like Ward we forget to save all
right tries again and now we have a
returned with a category of Express and
we have an empty array that represents
the empty sub documents have been nested
inside our document all right now we go
to our update vote our vote upvote
method function and what this one is
actually going to look like is now we
use this function that's built into
Mongo called the push which as you can
probably guess pushes a sub document on
to a document array so the document
field is votes and will push a sub
document call called votes on to this
function or the array and it'll just be
very very simple relic food the vote
count which will be like you know 1 3
negative 1 whatever what you want and
then also a time a time of when the vote
was actually submitted so now if we go
back to post ma'am and we want to update
the vote by 3 we now have this function
that returns and we now have our votes
sub doc we've now have our votes
associating the sub document we can of
course change this make it like 100 and
we now have 3 100 and then the vote
count has been incremented accordingly
and what's really powerful is again we
did not have to do anything at the
database level we do not have to migrate
any tables or creating tables we didn't
have to add any rows to it right all we
did was just tell Mongo we wanted to
insert these fields and then let us do
that all right so
I'm going to go back up now to our index
method and we're going to add paging and
paging is obviously something that's
that's pretty cool and it typically
requires two sorts of functions you need
to be able to limit the amount of
questions that are returns and you need
to be able to skip a certain number of
questions so that you can load the first
time the second time to third tan etc so
to do this we are going to
use a function that was previously
written called get query options alright
and what this functions going to do is
it's just pretty simple it'll just parse
out what the limit is and what the Skip
is if it exists now one of the really
cool things about Mongo is that you can
assemble queries on the go so you create
this query object and as I mentioned it
does not actually go back and it does
not actually create a query until we
call the 20 right function so now that
we have this object we can continue to
limit it skip it and later on we'll show
how to sort it as well so now if we go
back and we add a query parameter to our
get all questions we can now limit it to
two questions that we want to return and
you'll see here that only two questions
have been returned if we want to skip or
offset by two we can do that as well and
we now two questions but both of these
are going to be completely different
than the previous two by default Mongo
sorts by the the ID so in so which
typically is a time inserted because the
timestamp built into the underscore ID
field alright and then finally we can
also add sorting and what what the
sorting looks like is it actually looks
like this object right here right and
what we essentially have is we can sort
by vote count and negative 1 is
decreasing and pretty much what that
means is obviously the top vote or the
most uploaded question will be up here
first we can also sort by depth I'm
created so this will be the most recent
or least recent question first and we
can go back to our postman route and we
can test this as well so now if we go
here and we specify votes or vote
these things are going to appear in
descending order of vote counts so 115
there we've got to here and then 0 and 0
all right now finally one last feature
of MongoDB that I want to show you guys
is something called projections now
something that's pretty a typical
situation is that documents can get very
very big and they have a lot of fields
and for certain queries you might only
want to retrieve a certain fields you
might only care about for example the
name or the text you might not care
about the nested array of votes but
maybe just a vote number so we can use
is we can use a Mongo database
projection in order to only retrieve the
fields that we actually care about so
what we'll do is we'll have this very
this object called fields and what we're
specifying is is a one next to the the
fields that we want retreat you'll note
that the votes array is not specified
there so when we complete this query it
will not actually be returned now this
thing this fields array can be added to
multiple different queries we will just
be doing it with the finds one and then
as always call the to a right function
on it right
alright and now if we go back to the
postman client and we call with the
projection operator you'll note that
we're returning a list of arrays but or
a list of questions but none of these
sub documents have been returned because
we did not specify that inter protection
all right that about actually wraps up
the MongoDB portion of this I was
instructed by MongoDB if you guys want
to learn more about them they have
another event that's happening cember
third to meet up in San Francisco come
learn about it and then finally we have
right now we have the live demo that's
up there's a link to it will about to
take a break so feel free to go here up
the vote on questions of questions and
then Alicia will be up after the break
to explain what the front end looks like
and how we built it so it guys very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>