<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTML5 Video Full Throttle | Coder Coacher - Coaching Coders</title><meta content="HTML5 Video Full Throttle - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTML5 Video Full Throttle</b></h2><h5 class="post__date">2012-12-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FDYjHrpg5Lc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm going to talk about html5 video and
sort of look at platform choices and
ways to sort of build tools to deal with
all the sort of complications that come
into delivering video to lots of
different devices and browsers and with
html5 I'm Michael Daley I work with a
company called Kaltura they do an open
source video platform and I do the
front-end architecture for that platform
so we've heard a lot today about the
promises of html5 from a lot of
different speakers so I mean we had this
idea of sort of harmonic vendor
collaboration with you know cross vendor
sharing and spec process in which people
are working together this idea of right
once and have it work multiple places
sort of this ideal of Java from the late
90s somehow being actualized all of a
sudden with multi-vendor participation
we had the idea of performant
applications something you know
something where html5 would be capable
of rendering experiences that were
comparable to native applications
through the extensions through the CSS
animation properties and through WebGL
and and accelerated canvas etc and we
had this idea that this platform would
be updated because we're now living in
like this network software system right
like every all these devices are
connected to the network why wouldn't
they be running something more recent
and and of course unicorns rainbows and
kittens I mean like it basically wasn't
possible and just like unicorns not
going to happen unfortunately what do we
have in its place we have inconsistent
spec by n knot not all the vendors can
agree and especially a slow process when
any
Beck runs up against sort of native app
functionality and something that if I
mean if you if you especially in the
mobile space I mean desktop we have this
sort of competition for innovation in
the html5 browser platform but when it
comes to mobile we sort of start things
start getting a little slower when it
when the feature directly competes with
something that's already supported
natively we have all these middleware
solutions that have to come into play
and some which will I mean I look a
little bit at the culture of solution
later in this talk but also of course
there's numerous systems that have been
built to sort of bridge these gaps and
some of them are quite good and
inconsistent performance you know I we
never really had the promise of sort of
accelerated web experiences is still
just that a promise and of course the
the network connected devices for some
reason are not using that network
connectivity for good not putting it to
good use so we get you know these
android 2.x devices are still really
dominant in the market with something
like twenty five percent we stand you
know and then not only that we have sort
of this a lack of support for systems
that are still out there for some reason
so we have you no no we won't be getting
ie10 for windows vista for example and
you know not to mention XP machines
which won't even try to worry about
those but you know there's delays and
sort of pushing out updates and then so
how does that apply to html5 video we
have all those issues with the general
html5 platform but then on top we have
some other things some other problems
like codecs and playback we don't we
don't just have one codec we have WebM
h.264 I mean The Situation's getting a
little bit better it looks just last
week the Mozilla one of the principal
Mozilla developer has posted an update
on a few of the tickets and it looks
like Mozilla's going to come around for
h.264 support I mean especially for
mobile because of the hardware
accelerated chipsets that are available
but then also also on desktop they're
going to try to just reuse the
assisting a truce of h.264 support
within a given platform so they're not
going to really compromise on they're
paying for h.264 restriction of the fact
that it's an open source project they're
giving it away is free software but it
will sort of tie into system level
components for decoding h.264 we have
display layer inconsistencies so if you
start building this nice GUI for your
html5 player all sudden you realize it
doesn't show up on the iPhone because we
have a native playback on the iPhone
device we have playback invocation
restrictions for example autoplay this
is something that you know seem on the
surface seems not like a big deal you
just you know if you're on iOS you just
have to click before you can play but it
comes it gets complicated once you have
you no more complicated things like if
you want to have a thumbnail then
asynchronously load your your library
all of a sudden you can't you know get
that initial speed on the loading the
page because it you now have to invoke
the video through a JavaScript
asynchronous include and now you if you
haven't captured that click in a clever
way you're now you have to have these
are cooking again to start the video so
you have to do tricks to work around
that and then multiple video asset
playback mean this is just a natural
limitation of some of them old hardware
just doesn't have support for multiple
agents explorer decoding pipelines and
so you stuck with just a single video on
the page which again you know depending
on how you design your system if you're
not looking at that issue you could
think of some neat solution to you know
inject an ad in a separate video tag and
then pull it out and it would look
really nice on your desktop Chrome
experience and then when you bring it
down to your iPad or iPhone or Android
device for that matter all of a sudden
things start breaking down so what are
we going to do to get these kittens out
there we've got to build some
scaffolding and roll them along
we have to know the platform limitations
as I was discussing earlier we have to
sort of take a look at what what you
know what classify the different
browsers so that we have a way to decide
that's interesting okay yeah so sort of
say you know these these group of
browsers can have these sort of features
these groups of browsers and devices can
have these sort of features have a way
to sort of communicate to client I me
because a lot of this is not it's not
that like I don't know it it's that you
know your your client that wants you
know certain experience comes to you and
say says how come it's not auto playing
on iOS or how come it's not you know how
come I can't alkem users can skip my ad
on iPhone or whatever it is you know
like there's it's important to
communicate the limitations of the
platform to whoever you're providing the
services to so that you don't get caught
in hot water I guess or I mean just just
let people know what's going on like a
lot of people just don't know so it's
important to let people know and there's
some good resources for sort of figuring
out all these different platform
limitations i mean its stack overflow
google of course is a great way to just
find out what's going on and then
there's a few publications of people
have written and the can i use website
of course I mean I'm these resources
have been referenced quite a few times
throughout the conference I'm sure you
guys have seen them before so now that
we know our our limitations of the
platform we got to look at our goals for
delivering these videos experiences and
we have to sort of think about so
approaching this problem from in terms
of what we were trying to do from ovp
perspective is online video platform
perspective is we need to you know look
it are we going to have one player or
many players you know how are we going
to configure these things are we going
to embed into a controlled context or an
unpredictable and if you caught the talk
before he was sort of outlining all
these sort of iframe issues and how how
can we sort of leverage that to sort of
contain our player skinning one source
getting lots of times you know like what
type of skinning framework are you going
to propose you have to sort of find the
right balance between things that
are already set and things that can be
configured you don't want to lean to it
too much one way or too much the other
way especially if you have to map it out
to flash as well so if you want to
support ie8 for example and then there's
platform trade-offs like like on iOS you
can you can do a full screen request but
now you no longer have Dom overlays so
what does that mean either you do sort
of a pseudo full screen within the space
that the platform allows you or you go
out to the native full screen you get
the full player content experience and
then just sort of deciding which one of
those you you're going to go with and
letting it the end users are sort of
configure that because you know if they
if they whole business models around
monetization of content then they're
going to need to not let people skip ads
but if their model is just around
promotion promoting that a particular
video delivering out however they can
then they'll probably be fine with you
know showing the native iOS player and
then again thinking about whether we're
supporting mobile or just supporting
desktop so there's different features
and desktops you can take advantage and
we'll get into each of these bullet
points in a second more detail and then
supporting plugins or sort of dynamic
configuration again that's a sort of
when you have like large set of features
to choose from coming up with the
delivery strategy that still enables it
to come arrive to the client quickly but
not pre establish what plugins any given
clients going to enable sort of like a
resource loading system and of course
you know the basic rules of any software
project you want it to be fast robust
and maintainable so like I mentioned the
for online video platform flexibility is
really key so a lot of those questions
are going to be yes we want everything
and then we end up with not just a
player but a player platform so
something that can be invoked in lots of
different ways and can be you know if
they want to deliver a video to a
blackberry we're just going to you know
an old blackberry we're just going to
send a image tag with a link to the
video ass
you know we're not going to render out
the entire player but then some system
to pick and choose between all those
different issues is what we sort of
build and part of that is sort of like
this architecture for on page plugins
versus in pit in player plugins and we
sort of map that out like we have a way
to configure something so that it works
within a player context and then also as
an on page context and we'll get into
that a little bit more detail that that
basically means the idea with the player
platform oops sorry the player platform
is that you're not only able to
configure the player itself but also
sort of on-page services around that
player so that may be backup playlist or
any of these other things and then but
but we unify the configuration through
this sort of single k widget concept and
I think that proves to be useful in
terms of delivering rich widget features
I think some other talks of referred to
this as well sort of trying to figure
out the best way to deliver you know
again and you're delivering script to
some other somebody else's page so it's
it's always tricky to write your code in
such a way that it doesn't get messed up
with would be one client wouldn't client
pages do crazy things and we can look at
some example we can look at that real
quick if we want to this is for example
I just want to quickly highlight the
difference between a on page playlist
and a playlist widget so and we support
both right like so if you want to have
sort of like a self-contained iframe
that that's this this whole thing is
inside an iframe if it's flash it's just
rendering the whole flash Swift with the
different playlist items our vendor
didn't in flash vs a on page playlist
where the content is added to the page
and then the client can style it with
CSS on their page and so this this piece
of the page is not in the iframe is
actually living on the clients page and
then they can you know play with it and
do all their JavaScript tweaks to it
that they need to do
without sort of crossing that sort of
sandboxed player or santabillie sandbox
widget you know and but if they if they
need the whole playlist to be sandboxed
then that's what the other that's what
the other one was yeah and again so if
you're approaching this problem from
it's sort of a generalized problem
really when when you're approaching this
providing software services to web page
embedding context you have to sort of
decide where you're going to draw your
lines of abstraction and what's going to
be safe and what's not going to be safe
I mean to that point I mean you want to
keep your code in a sandbox and that's
basically what we do with sort of an
iframe embed for the for the player
itself and just to get it a little bit
into the technical details of how that
works we use something called I mean I
mean you all know what it is I assumed
friendly eye frames which are I frames
that are built out on the page itself so
it's not it's not a cross-domain request
for an iframe it's an iframe that
through javascript is injected into the
page and there's a few quite a well a
few reasons for doing this we avoid
asynchronous issues so post message is
an asynchronous call if you're dealing
with sort of real-time video
applications and like you want to say
you set the current time of the video
player to some new time then if it was a
a synchronous call then all sudden if
you tried to read that property in line
it would not have been updated yet so
you'd have to set up a complicated proxy
to bridge that gap which we did
initially but now we've moved away from
that and we have friendly iframe so
you're able to directly access all the
properties on the the player itself and
without any of those aged synchronous
postmessage issues also post message
gets kind of slow on some of the other
so post message goes all the way back to
like IE 8 and if you were sort of
wrapping a delivery mechanism that
included flash or something for one of
the older IES you could things get slow
and
and we also want to look at well anyway
so that's basically summarizes the
iframe situation we support we support
the player being invoked through a
cross-domain iframe as well but then we
don't have the JavaScript API and it's
important distinction to think about
like if you're gonna if you're going to
have to set up your own JavaScript code
on the client page anyway for to handle
the postmessage interactions you might
as well do a friendly iframe and have
total control there's no point in trying
to have an API on both sides of the of
your iframe when you could just have a
friendly iframe and have much more
flexibility and control over the player
itself and accessing its properties and
stuff another another thing we run into
is the thumbnail in bed which we
referred to earlier sometimes like on a
blog or on a website with lots of videos
we could have it's very quick to render
players if they're just an image in a
link but it takes very long to render
them if they're if it's a full iframe
player and everything and the idea here
again is to simplify the way people have
to do that if they were to do it
themselves they would you know they
would put their little link on there on
the page and then it wouldn't work
because on iOS like we discussed earlier
they would press play and then they
would inject the player and then if
without the user to click on that new
domme they want to be able to play the
content so what we do is we have a black
video source when we issue a play on the
you know and then wrap the asynchronous
response around it and then switch the
source on the black video tag so you
have to do a sort of little tricks to to
make usable experiences I guess is the
point there and then when it comes to
skinning again we want to retain
flexibility so we have a few different
skinny models it depends what your type
of project is or what you want to
accomplish but
some you know for some things I mean I
know a lot of people here would probably
promote pure CSS based skinning just
because you you have a little bit more
flexibility in terms of theming the
player or if you want to you know engage
put the player into a different context
you can have a little more flexibility
if you know if it's just a CSS file then
you can just manipulate it pretty easily
if it's but not everybody's like CSS
ninja so sometimes we just have to let
people throw some sprites on the page
and just map them out and some and some
folks integrate that way as well but the
important part is that it the the
configuration layer makes it easy to map
it map out whatever you know if you've
map it out to a particular CSS file you
still have the sandboxed player within
the iframe so you're not you know you
don't risk your site CSS screwing with
the player but if you want to be able to
load your site CSS into the player I
don't know if you have some overlays or
whatever they're the configuration
mechanism in supports invoking local CSS
the relative paths where necessary
getting back to the platform trade-offs
again we were just as we mentioned
earlier you sort of have to enable
clients to make those decisions
themselves because you don't want to pre
decide how things work right like so if
you know different clients have
different use cases and different needs
so you just have to let them issue those
trade-offs and there's a lot there's
actually quite a few of them if you you
know start dealing with all these
different platforms and things I mean
for example there's a proprietary or no
I don't know about proprietary but
there's an extra there's an actual
attribute that you can add to the video
tag to opt in to apple airplay like for
playing so if you watch a video on your
iPad or your iPhone and you want to play
it on your Apple TV that you have to add
a little attribute to your to your video
tag to support that and little things
like that and sometimes you want turned
off sometimes you want to turn it on
depending on your content android of
course the big there's what kind of like
this gap in the android platform right
now we're adobe said you know we're
cutting off flash and google said we're
going to ship chrome but they didn't
quite line up so now you have the stock
android browser shipping on all the
android for devices which you know is
fine I mean they and Android you know
they did a good work on improving the
browser from what it was but Android for
stock browser is not mobile chrome by
any means when especially when it comes
to media and all the things that you
need to be able to do there so we're
kind of in like this little limbo land
right now but I think eventually chrome
will propagate the Android ecosystem and
things will be less painful but again
letting letting users sort of if they
build out sort of a html5 experience or
they don't want to support flash they
can have options for making that happen
and many more I mean I could I could
pull up the page if you want to see
there was well if the internet was
working i could pull up the page there
goes I mean they're just lots of
different configuration options that
people need to be able to do ok and then
how do we make it all fast so again we
we have like a lot of plugins available
this is just because the nature of sort
of an online video platform as you start
sort of supporting all these different
providers so like for ads there's six
four or five providers for analytics
there's another four or five providers
and then for player features there's all
these different player features and you
know so altogether the library becomes
massive you know like I guess the
payload if for a full featured player to
be something like two Meg's or something
really big because there's all these
different plugins and features that get
developed independently but and then but
then we need to be able to deliver that
to the client very quickly and what we
do is we use a resource loader that
dynamically packages them or player so
you still get the as few requests as
possible while
retaining flexibility for arbitrary
plugin combinations and likewise for the
we exploit the fact that we're using
this iframe to again package anything
we're going to need and that single
iframe request so that at the end of the
day you get like very few requests as
possible and you can see the source here
I mean this is just our iframe you can
see like we have all the player metadata
all the player layout configuration all
the plugins that it's going to use all
that information is sort of packaged
into a single payload with the iframe so
that you're able to maximize the speed
in which the players delivered to the
client and we sort of favor within the
within our system I mean it I guess you
have to measure the trade-offs for
whatever system or widgets you're
delivering but we lean towards a fewer
requests over cache miss which just
means that we don't like round trips and
and we and of course you have to make
some trade-offs in terms of saying you
know maybe this maybe we could group
these resources and give them a long
expire and then maybe the plant when
they visit the player again they would
already have that resource versus
something they visit some arbitrary
other player but at the end of the day
we lean more towards a single request
just because I mean the entire payload
ends up being you know less than a
second of the video playback it's more
important to avoid those round trips
because if you're gonna be watching
video online anyway you probably have
enough bandwidth to to stream it the
video in real time so you at least
knowing that you can lean towards fewer
round trips because you know round trips
take a certain amount of time so you can
factor that in and then of course you
know no need to go into this detail
because that's not what this talks about
but of course you want to run your
automated tests and you want to make
every feature every feature is both a
demo of the feature it provides the
documentation for configure
the feature and it provides the
automated test for the future so you
have a unified sort of manifest for
every feature that encapsulate seeeeee
its entire life cycle across its use
cases that you need to support for
maintaining that feature and that that's
an important aspect of sort of scaling
out when you have all these different
people working on all these different
pieces just to keep things relatively
sane and then taking advantage of
desktop html5 this one to talk a little
bit about like how the you know the
desktop html5 experience is sort of
racing ahead from relative to the mobile
html5 experience and that doesn't mean
just a good opportunity to sort of
explore like what type of future
applications will be able to support
like the as i mentioned like the as
mentioned previously in the conference
like the media source api for a pending
bytes to video up player that's lets you
write like an adaptive streaming layer
and pure JavaScript and you know if you
look at it today if you're sort of
rationalizing it today you say well it's
you know that's only in Chrome I don't
think we can really rationalize spending
effort to develop HLS or that adaptive
streaming solution today because it's
only in that browser but you have to
sort of look a few months ahead and
assume that things will make their way
out to mobile I can show it can show a
quick sample of experiment that i did
with WebRTC and again it's just it's
just good to you know explore all these
different possibilities as they become
more and more accessible this was a
video wall where it doesn't really work
very well this is a single user but if
you
open up a new a new user oops sorry okay
okay that's interesting or my other tab
go okay
I don't know if it's me Trey
I found that WebRTC stuffs a little
tricky to develop for because you're
always sort of video chatting with
yourself and that can be tricky
especially with this resolution okay
well I think we're going to do it able
to show it this is just a video wall
that's triggered through the internet
archive did this project to allow a
bunch of different to index all the news
programming so every every day they
capture like 30 or 40 hours maybe more
like 100 hours of footage and this is
just so that and the index at all with
the closed-captioned feed so that you
can sort of search through all the news
coverage and what this application does
it just sort of has multiple people
watching a particular set of news and
then you're able to sort of if you're
both watching the same thing which this
is no it's not going to be dimmable on
this resolution I think but anyway it
shows a little crap not going to skip
this but it does it shows a little video
chat of both of you creating sort of a
space where if you're both watching the
same news coverage then all of a sudden
you have sort of like this video
conversation that opens up around the
content that you're watching together
which is kind of a fun experiment to try
to think you know what kind of
applications become possible and I think
would be worth noting that although so
in the in the beginning earlier in the
days I remember somebody mentioning that
you know that these the WebRTC you know
like oh this is existed in flash for a
long time you know what's so different
about it in html5 I think the main
difference is that you can do it in a
few lines of JavaScript you don't need
adobe communication server on the
backend you don't have all these
proprietary protocols you have this open
approach and I think it'll enable some
more interesting possibilities and I
guess might the whole point of this
little side section of the talk is to
say keep exploring the upcoming features
of the html5 library and those are
usually going to be happening in the
desktop space to just have a good
perspective on what type of features you
want to be able to support in the few
sure ok so I think that's about it
there's the URL for the slideshow a lot
of that there was a lot of links I
didn't click click on but yeah so thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>