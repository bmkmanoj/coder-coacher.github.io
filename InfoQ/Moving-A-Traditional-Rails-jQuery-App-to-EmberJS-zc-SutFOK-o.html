<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Moving A Traditional Rails/ jQuery App to Ember.JS | Coder Coacher - Coaching Coders</title><meta content="Moving A Traditional Rails/ jQuery App to Ember.JS - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Moving A Traditional Rails/ jQuery App to Ember.JS</b></h2><h5 class="post__date">2014-04-08</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zc-SutFOK-o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Miguel Madero I have been
developing software for like almost 20
years for the last year or so I have
been working with sorcery what we are
trying to change the way that our food
industry works so disrupting an industry
is hard as we all know and i think we
are giving it a good shake and one of
the program we have is a commerce
platform that helps chef's order their
food from from their suppliers and we're
going to talk a bit too there with this
platform today we'll talk about the
evolution not so much out how we are
trying to evolve the food industry but
more about the evolution of our code how
our code how to have to evolve in order
to actually meet some of the goals that
we have as a business so I'll speak for
about 40 minutes or so feel free to ask
some questions we're on a small group so
feel free to ask some questions as I go
and if I don't have time to take them on
the spot and we might have to talk about
those later just as a quick survey here
who's using javascript just please stand
up if you're using javascript now I'm
not racing hands just please stand up if
you're using javascript
pretty much everyone okay yeah I was
guessing after like I had a different
number on the ruby meetup so okay no no
come on come on don't sit down yet so
raise your hand if you if you have neat
and tidy well tested JavaScript sorry
actually nah I got it completely wrong
if you don't have neat tidy and well
tested JavaScript please raise your hand
yeah good portion of you okay so raise
one leg if every time you add a feature
it feels like the complexity of your app
like increases dramatically yeah now now
do five push-ups if okay okay let's not
listen do the push-up just down that
then that's how that would look so push
ups are certainly hard it just
developing software is hard especially
if you're like just doing these push-ups
with one one arm one leg developing so
but also becomes harder if the
complexity of your application keeps
growing as the size of the application
grows so there are certainly a lot of
things that are outside of our control
by market changes and are the
environment changing we could still
manage them but those are completely
outside of our control something that is
certainly a completely in our control
it's is the quality and the
maintainability of our code base however
sometimes we lose we'll lose track of
that and we lose we lose the ability to
control that
so just as a just as with with rails
sorry I'm missing the road yeah so just
as with rails and with other frameworks
in the server we have certain patterns
and certain practices that let us reduce
the complexity or at least keep the same
level of complexity as new features are
added to to the to to the code base
unfortunately with javascript is one of
the main offender like client-side code
quite often it doesn't have those well
thought out designs and well thought out
practices and more and more nowadays is
just becoming easier but that's
certainly something that impacted us
here so just just a bit of context in
this product we started working on it
about two and a half years or so the
product kept evolving as a company grew
when we hire salespeople and we acquire
new customers and we went pretty quickly
last year from getting one of the first
mbps out there's of a new product and
having a first place order to then
having hundred orders and a thousand
orders and then just write a write up
about that time where we can see there
but right at that time we were helping
exchange that picks head from from the
butcher to the to the chest and we
started feeling the impact of the
maintainability overcoat a so quite
often we have problems with
maintainability it's because we are not
managing appropriately or technical
depth that certainly what was happening
in our in our case this is this is a
diagram that I stole from
from marketing folder oh sorry that
something wrong with the animation there
all right I yeah I adapted a bid to
reflect her a what was happening with
also he he defined technical day on a
quadrant on different types of technical
depth that we could acquire so we have
reckless and deliberate all the way to
reckless and inadvertent and in the
other side prudent and prove it and
deliberate and prove it an inadvertent
so I think we had a combination of all
those four we will certainly not paying
too much attention to how we were
managing that technical depth and that
turn out into our velocity instead of
looking steady or velocity was looking
more like our burn down chart sir
velocity was going down while or boredom
child was just converting into a flat
line and we started measuring the
quality of our coding WTS per minute so
we only call for an intervention or a
retrospective and we all complain and
bitch a be a bit about the quality of a
cold and what we could do better and
that led us to start thinking about
amber or other MVC frameworks in general
we did a quick evaluation of folders and
we ended up going with with Amber and we
decided the first step will be to write
a quick prototype on how our application
one portion for application would look
if we were writing a completely number
so these were the main takeaways sorry
so one of the goals of doing this was
really learning we had another pressing
feature that we couldn't actually
deliver and we have been trying for a
couple months or II had been sitting in
the backlog we needed to support offline
our certain parts of our application
needed to work offline but with the
current code base that was really hard
to do so we wanted
to have offline support and we want to
learn a bit more how something like
amber could help our the main time
maintainability of our code base so
after a couple weekends and a couple of
weeks a working this prototype we
identified our models routes and views
I'll get a bit more into that we found
that actually copy pasting or existing
HTML into into this new prototype was
like a quick way to get up to speed and
migrating some of the code to to amber
again I'll go into a bit more into that
and then we knew we could get data
across the wires we just cracked a quick
API that wasn't the main focus of this
prototype then we pick build tool just
because those build tools are always
needed and as your application grows we
certainly need to maintain maintain
things better with a build tool so our
model aim we had
we had a lot of logical party in our
application in her back and we were
using rails and rails with active record
sort of leads you by default to have a
huge domain model or one domain model we
can take to think of it as the model
only there are ways to break that and I
really will have things better structure
into services or into complete verticals
with their own a api's and their own
separate domains think of ordering an
accounting so unfortunately we had just
one model at the back end but as we were
going with these apps and if if you guys
are thinking of writing an MVC
application or we are already doing that
I'll heavily encourage you to start
thinking of a client-side domain model
as something separate from your server
side domain model and try to structure
that Morris remove everything that is
not needed and everything that is just
specific to that one application so we
have separate applications for
accounting separate applications for
ordering and all of those have a
different different domain so if we
think of that as the context in which
different domains lib so in the business
model or the server-side model we have
multiple users but then the clients that
we only have one user so that data on
its own it's already simplifying our
domain then a set aside we have multiple
orders but then on our ordering
application we only have one active
order at the time so again that's
simplifying a bit the domain we have
buyers and vendors but then on the on
the client-side version of this model we
only have a single buyer so again that
that makes it simpler so we also have
different technologies so we have active
record that is coupled to the database
just because that's how active record
work but then on the client side we have
multiple sources we have local storage
we have a rest api and we have we use
web sockets for some real-time
communication then
on that side is optimized for storage
because of the physical a way that
relational databases work and here we
are optimizing it more for queries and
commands over that is normalized he is
heavily denormalize on the client side
just to put it more in concrete terms
this is up one part of the product
domain and this is how it looks in
JavaScript so you definitely don't want
to work with that on the client side you
definitely want to work with something
like to look for like that so yeah let's
do a quick demo
by the way this is yeah this is called
am the product domain looks client-side
so we only have a handful of fields and
then for another of the applications we
also have another product domain which
uses a different API and has a different
structure so in another application then
that same product model is slightly more
complex because it has different
requirements all right so
yeah let's have a quick look at how we
need some of that so we for the
prototype all right all right so we have
an indirect awesomer problem we're
trying to solve we couldn't we couldn't
keep delivering at the pace that we
wanted to be delivering for our
customers because we're maintaining our
application meaning adding features or
fixing box was taking us to LA too long
amongst other reasons because of the
quality of our JavaScript code base we
also had other customer requests like
supporting offline a lot of users a a
lot of chairs use iPads and they wanted
to have go to the invent that inventory
room and they're dry goods a closet and
then use their iPads and a spot what I
don't have Wi-Fi so that's something we
couldn't do unless we heavily riorca
tected by our front end
yeah wait
so a quick way in which we started was
ok this is this pretty much a chunk of
HTML that we actually care about and we
identified all of that we literally just
went there and say copy all of that put
it into one of these templates let's
call it a script type text handlebars
and then throw it in there let's get the
JavaScript on the HTML for a second and
that was looking well not close at all
but the markup is there now obviously
the part missing there is the style
sheet so we could probably just grab
that response there good
all right and here is one I prepared
earlier and we just throw a bunch of CSS
there and we had a first good version of
our application rendered by amber is not
doing anything yet so now at least we
had a starting point where we could keep
hacking adding features and breaking it
into our models identifying controllers
identifying routes and I will get a bit
into what all of that is in a second so
so we had that that's already remedy
number and I'll be lame right now all of
the template is in the same place and so
far we don't have any controllers or any
logic there and all the CSS could still
use some some cleanup but now the next
step we took is trying to identify
different routes and amber uses route
every time you navigate from one place
to the other similarly how different
servers IP frameworks use route so as
you can see that the URL changes every
time that I select at least there on the
left hand side so we are going from
kitchen house to pastry and breakfast or
we go to pastry / vendor ID so this
panel there at the bottom that's the
amber inspector so we identified some of
the of the route amber already gives us
a lot of routes by default then we went
ahead and identified how we were going
to decompose this into multiple views
and initially as we are progressing with
a prototype a lot was just living on the
on the main view and then slowly we
started breaking that into obviously we
have products there so we had a product
which has a list of we have a list of
products with a bunch of product on his
row and then we have this list on the
Left which became another list and its
own template and and then we have list
per vendor which are these 10 we're
seeing on the left hand side so we
started breaking that and decomposing
those we literally started in
identifying all of those components and
then broke the markup and make it a very
dynamic
so yeah well I'm here I'll show you a
bit of what this part of the product
does a as I as I mentioned earlier the
product has different areas and one of
the main ones is is ordering a we have
an accounting reporting and a few other
we could think of them as applications
now but then the the ordering
application that one of the main ones
that we have but that's also one of the
probably simplest ones so this is a
business to business application so here
buyers already have a predefined list of
vendors that they frequently buy from
and they keep buying the same products
in a regular basis so they by later
today and they buy the same type of
letters in three days and three days
from now that they buy the same type of
letters again and again so they create
this list think of them as playlist in
itunes so for the kitchen house and for
empty or for the salad bar they have
certain ingredients that they frequently
by and then each of those is broken down
by the Bender's that carry those items
the application allows them to move
things from one list to the other and
then they cool with the filter items
there if something is not within the
least approximately normally by then we
show them the full catalog of products
and then they could add them to the list
of frequently bought products and then
obviously they could buy them that the
whole point they could also add them to
a different least they could optionally
show more information there and they
could open the details of the products
or remove them from the from the guide
hey this is a collab already a platform
so different chefs could be buying
products and we we see who's buying what
and when they added that so so we can
coordinate within the within the team so
in a nutshell that
the first product that we make ready to
to amber
so the the other part was a quick API so
we had the HTML we identified our models
we identified our views and template and
template so we decided to write a quick
API just to send the data and here the
easiest thing for us for that prototype
was just to write sequel queries and
then just send them the data sorry
that's that Ruby yeah so I was just a
quick and dirty way of life proving that
we could actually do this eventually
that API we've got rid of that and the
other ones kept kept evolving him yeah
we are still using active record and
some of those queries are done doing
active record
sorry they didn't understand the
question correctly juicing active record
yep
alright
yan i forgot to mention so we picked a
build tool they're different tools
available they will let you compile all
of your handlebars all of your templates
and all of your javascript and they some
of these tools are specific to 2-under
in the sense that they they know where
things are and then put them in the
right namespace based on on where they
are located and they follow a certain
folder structure so on this prototype we
started using ember app kit which uses
es6 well now it uses he yes unless you
write es6 it transpires that to
javascript on after the prototype we
actually have to move to amber rails
because that fit better with the asset
pipeline that we were using and we
didn't have enough time to invest into
making that work with with Amber up kid
and you're likely going to be using
something else that fits and what
whatever else you are already doing for
for JavaScript but it's important to
just keep that in mind so for this
prototype we identify models route we
started by copy pasting generate HTML
had a quick API and the bill to
now quick intro to Amber I already
mentioned a few of the concepts some of
these might already be familiar to a lot
of you let's get a bit more into those
this is a super quick trimming of intro
to amber just for context so number we
have views and templates there are
slightly two different things that let's
just think of this view layer without
worrying too much now the difference
between those two so we have views and
templates that get the properties from
the controller if you're using backbone
and an angular and this might be a bit
familiar to you already this is
different to a typical template on a set
aside a scenario in the sense that in a
server side in server side you normally
render the template once and then the
template is just disconnected from from
the actual controller and the model
behind so here the view is active and
half as you are interacting with it as
properties in the model or the
controller change then the view will
reflect those changes so the template
gets the properties from the controller
and then the controller in turn just
decorate the model meaning is wrapping
the property that is that the model has
and it also adds properties of its own
that's the place where we will define
actions as well so if you look at that
name yeah Lester bye-bye look at how a
typical interaction would look so a user
would go to your side either by clicking
your link on google or typing the URL
directly in the browser then that URL
will be parsed by the router this is the
ambler router and then based on how you
define your route it will identify what
route will handle this particular
request again different than than most
server-side framework rouse here are
hierarchical meaning if you go to
products / product 1 / edit it will
actually render three routes for those
for that part of the pad so you have
three active route that will be taking
control of different parts of the of the
template so its route will have its own
model its own controller and its own
view so each of those route will be
responsible of rendering the view
loading the model creating the
controller and then binding those three
together once all of that is rendered
then we are waiting for other user
interaction like the user clicking a
link or clicking a button and then that
interns will result in an action being
booked in the controller and then what
the controller will in turn let's say
call the router to navigate somewhere
else or we'll go to the server get more
die more data and update the data and
that data will be then updated in the
interview so that's amberina 34 minute
interim
so what did we do next so we we brought
that throwaway prototype we learn after
bit and we decided to then move to a
small chunk of the application so we
said we really have one or two weeks and
we decided together to take a really
really small chunk of the application we
decided to do something that we don't
really impacted more the core of the
functionality but it will still be
representative enough that we could just
keep building on top of it was tricky
restart because we felt that Amber was
more ever wanted more to take to either
take all of the interactivity of the
page or or we were really not sure amber
will behave well we're certain parts
were donee number another password on
outside of amber with regular jquery and
the typical JavaScript code especially
when there is some relation between
those two like someone could drag and
drop a product and drop it into
something that is rendered by amber so
it turns out some of that work really
well I'll just yeah just quickly show a
couple a couple things and
alright so this is our list element and
alive for at least look like so we
already had a bunch of data attributes
and a bunch of we could ignore the rest
and a few classes and all of those
classes were used by legacy code by our
legacy javascript in order to do things
like decide what to drag-and-drop where
and what to do when you actually drop an
element into into that a lie so turns
out that just by keeping those classes
and maintaining those data attributes
every everything else for the most part
after a few bugs and issues we will
actually get things to work in a hybrid
model like amber will render markup that
our legacy code wouldn't will understand
we also we also got some libraries that
were working quite well for example we
had a an error notification library that
talks to honey badger and sends SMS and
notifies those are certain events when
it errors happen or certain events
happen client side so that library will
pretty much just reuse and we hooked it
into some of the amber a hook to handle
this type of errors so it was really
straightforward just to reuse existing
libraries
so for this a small chunk of the
application we relied a lot on on legacy
on the legacy markup we were able to
reduce existing libraries and we have
data synchronization and offline support
I skipped that part but all if I have
more time I might show you a bit of that
later so then we finally pushed up to
production and we were not sure about
what to do next because we had all the
requirements and we had actual so we
have other pressing needs and doing a
big refactoring was like harder to
justify to the business until we realize
beside him that was sitting on our
backlog made it higher in the priority
so some users were complaining that the
site was taking somewhere between 10 and
15 seconds between 10 and 15 seconds I
don't know how it I don't want we don't
get to decide him before but it took us
a while and eventually that was a top
priority we quickly valuated a bit more
what which will doom we broke it into
areas that we needed to optimize we
realize that a lot of that was because
the views were taking out 2.2 seconds of
the total rendering time a rails is just
awful when it comes to rendering views a
so we were I was expecting that querying
an active record was going to be the
main culprit of all of this it turns out
that rendering views was one of the of
the worst part but this is only server
side and that's not 15 seconds don't
have that from the time with we send the
data as and the time that it took on the
network and then once we once we got
everything to the client the time it
took to render that that's what was
actually contributing for the most part
on these
2 15 second delays so we forgot about
optimizing controllers and then we just
focus on a it looks like we actually
need to do something client side so we
decided to rewrite everything rewrite
everything but riorca tect everything
gradually into the duty number we knew
from the prototype that rendering was
way faster we already had a solution for
offline so we knew that that time that
we spend in the network we were going to
pay that cost once and then we'll just
be synchronizing data so we wouldn't be
sending a lot of data all at once except
for that first time that we are
synchronizing data and even for that we
had ways to optimize it so due to some
pressing requirements of making this
team perform better we decided to now
take a bigger chunk of the application
and do that a number
so well one of the benefits of doing
this is one of the side benefits is
overly we winded up optimizing
performance I'll get a bit more into
that but let's show some code first this
was one of the controllers that was
doing shares this one's when this was
this one was one of these low ones aim
so that code was really complex just to
get products filter by benders filter by
term and category and a few other
attributes it is not that complex but
the logic here was really really complex
and yet that could have been done better
but we were the there were a few
variants here a a lot of things that we
needed to consider if we had a least if
we have end early we had if we were
using solar already work wearing
directly to the database once we wrote
it into an API this is how the
controller loop so this is the Search
API that ended up replacing that other
controller that I just showed you so we
had all of the products already stored
client side and we all we have to do is
just search in in solar or search server
based on the term that they were
providing and everything else was
already a done and filter client-side
based on the ids and all of what that
API was returning was ideas of products
so we were sending really really small
payload so that really improve
performance the JSON de Guiche and it
was really small in comparison to all of
the market that we were sending before
every time that someone was airship
searching for something
when we did that and we took a bigger
chunk of our application it was still
hybrid we couldn't rewrite everything
just in that in those two weeks that we
had to do it so some of the
functionality functionality was still
don't buy the legacy jquery an orgy
legacy javascript but now we found that
not only amber needed to generate market
that was compatible with that a legacy
code but also our legacy code have to
talk to amber to get certain pieces of
data like what is the active list or we
modify something and now to Amber to go
and refresh the data so to do that we
just didn't want to we didn't want the
legacy code to have access to everything
that number will do or to all of them
classes or JavaScript objects in in our
amber application so we created this
class we this object that we call legacy
bridge and it exposes a few simple
methods and all it does is gives an
access to those key features that the
legacy code needs in order to interact
with with Amber so that's a that's a
bridge between the two worlds yeah all
right and just to wrap up some quick
before and after
this is some of the code we were riding
before he saw a lot of a lot of this
code was was forcing us to think of
classes in order to find elements or
thinking of a the markup in order to do
certain actions so instead of thinking
of you need to find something that is
not hidden that it has a certain class
and then click it we were writing things
that make more sense in the context of
our application like do we have a note
and then this property note is really
easily expressed by saying we actually
have a note or the length of this array
is greater than zero and then this
property can be bound to the markup to
make it do whatever we need to do or to
add a class to somewhere it but now that
helps us think more in terms of the our
domain instead of thinking in markup and
classes some other example of it before
and after a a lot of the market that we
had had a bunch of classes that were not
really just used for styling but they
were actually or they were not use
semantically or for styling they were
actually used to imply behavior like
unclick do certain thing or data
distributor is that or the distributor
ID is that value or this is expanded and
and all of that could actually live
somewhere else not exactly in your
markup so our markup is way cleaner now
now we only have the classes that we
need for for styling and for semantics
purposes
say that if some of you are familiar
with Amber that line of code here I
actually like it looks a bit more like
this just because amber requires two it
adds a bunch of metamorph acts to your
markup but that's for the most part of
something that we could ignore and that
is going away on other versions of a
future version of amber
all right so while doing this we we
simplify the server-side code we wrote a
communication layer that helped us a
bridge between legacy the legacy code a
number with the before and after well
now we're thinking more in terms of our
domain instead of thinking more in terms
of markup classes and data attribute we
remove the behavior or or the state from
from our markups and our markup only
represents the structure and don't get a
chance to show now we have better
structure in our application so it's a
bit easier to know where things are
sorry it's a bit hard to read there but
for this application for example
ordering we have computation controllers
and helpers and it's easier for someone
working with this application to know
where things are previously we only have
a bunch of loose JavaScript files all
laying around that's certainly something
that doesn't require amber in order to
do it better but certainly using amber
or something similar sort of forces you
to do it the right way
alright so you two just to summarize so
we had some benefits of doing this oh
really we improve the performance by a
lot significantly we change the
structure of the application we made it
more maintainable we improve the
development developers velocity and we
improve developers happiness we reduce
that WTF sperm ended metric and it's
certainly possible to do these hybrid
amber legacy app integrations and we we
as we go we kept rewriting other parts
of our application of our website into
other number applications and we use
some of the same learnings from from
this first exercise so yeah that's it
for me then thank you very much go to
the big top yep mmhmm yeah the question
was if we are using with y2j yes no
we're not using that we are using the
rails asset pipeline which does its own
weird thing and it doesn't work no worse
well our day as required
for the client-side persistence of for
offline support for offline support them
so the main part of offline of offline
support we did is to have some data of
line and then some features we will
actually do them offline we persist them
into local storage and then once we come
back up then we synchronize some of the
changes yes amber has some support for
local storage but we actually ended up
with writing a lot of writing a lot of
that ourselves but they are having this
other structure made it easier for us
him yeah that's a really good question
so and we have a really good designer
and it's actually really really good at
about a cssm riding all of the designs
but he's also really good at with
JavaScript and he's using a handlebars
and riding some of the amber a templates
himself when it comes to so we have two
different workflows for something new he
might actually just write HTML and
JavaScript and then we might just use
that HTML and move it into amber if he's
maintaining something or enhancing
something we already did and he's just
making it pretty or making it better
than what we did as developers him he
will actually just go to amber and then
pick it it's relatively simple for him
also to get started without having all
of the back end as long as we give him
the models to work to work with we could
give him some fixture data and he could
just start working from those models and
that data and hacking around without
depending on on all of the back end so
it actually makes it really easy for him
to get up there
speaker</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>