<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon: Android Internals Overview - Marko Gargenta.mov | Coder Coacher - Coaching Coders</title><meta content="AnDevCon: Android Internals Overview - Marko Gargenta.mov - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon: Android Internals Overview - Marko Gargenta.mov</b></h2><h5 class="post__date">2011-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MlxiQNijniQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">we're going to talk a little bit about
the internals of all Android and and
before we do that I'm just going to tell
you a little bit about myself for those
of you who haven't met me before
so my background is in javis I'm not I
don't have a strong C C++ background at
least in over the last 10 years so I've
been doing Java before it was named Java
so from the mid-90s and the last couple
years have been extensively working on
Android and Android internals so I've
been doing a lot of sort of in poking
around the internals of the operating
system building custom roms etc
modifying the platform as well as
developing the applications I'm also the
author of the upcoming learning Android
book which should be coming on next week
there's a sample I believe available
somewhere so you guys can take a look at
it but the book is also available in
draft copy free of charge at learning
android.com
so you can you can get it from there as
again it's a draft so it's not the
complete version it's not the final
version I also frequently speak at
conferences such as this one also spoke
it also a couple of times I Triple E ACN
and so on and one goddess so let me tell
you then a little bit about what we're
going to do today so we're going to talk
about what happens when the system boots
up right so how does everything get
started what are the bits and pieces
that that get started up we're going to
talk a little bit about the layer
interaction which i think is kind of
important to understand for any anything
that has to do with internals you sort
of have to understand how the different
bits and pieces of the platform
communicate and in the context of that
we're going to talk about the NDK a IDL
and and that's about it so that should
be
what we can fit into an hour so in terms
of the the startup of the system
what basically what happens when you
turn on the device is roughly this so
I'm going to kind of walk you to this a
little bit step-by-step so essentially
as you guys know entries is built on top
of Linux so we start a whole bunch of
Linux daemons initially and these are
the low-level things that you have to do
with power management memory memory
management you radio starts as part of
the daemons etc so these are some
low-level Linux related things they're
not necessarily very much related to
Android in terms of things that they're
providing on top of the the Linux OS so
that that starts up first secondly what
we're doing is we're starting we're
starting up the runtime and the runtime
is basically a whole bunch of system
services that have what we're going to
talk about system services here as well
but runtime is basically their C
counterpart the native counterpart right
so these are the bits the bits and
pieces that sit much lower to the to the
kernel then then these system services
here but they sort of go hand in Ken
they're basically registered with one
another but before we can start the
system services which by the way the
blue roughly correlates to Java so
things that that is in blue the blue
boxes you know that it's a Dalek or Java
based code essentially discerning before
we can start anything that has to do
with dalvik or Java we need a zygote
process zygote is basically a pretty
warmed up version of any future any
future application that is ever going to
get started so essentially if you think
about it when a user clicks on a on a on
an app clicks and roll button wants to
start up an application what's what
happens is we need to launch an entire
new process right one application
essentially become runs in you know in a
separate each application runs in a
separate Linux process altogether
so we got the long pole onto the process
on top of that we need to load the
virtual machine right because we're
going to need a VM on which we're going
to load up our application so all these
things take a long time to execute
memory allocation etc that's usually
expensive so to make things faster the
Android team essentially came up with
something cause I got and what that this
is is all that pre warmed up and ready
to go
right so every future version of any
application is going to have its roots
in zygote right it's going to it's going
to be forked essentially from this
process and zygote gives us that pre
warmed up virtual machine and we end the
process and everything set up to go so
once we get a I got going which includes
the VM itself right once we get that
going we can launch system services and
system services are essentially bits and
pieces of the platform at this point so
this is the this is the Java code right
or dolly code these are the bits and
pieces of the platform that provide that
rich application framework environment
for applications right so for example if
you're writing an app and you want to
play a music or you want to find out
your GPS location or you want to find
out what Wi-Fi networks are available
etc you need to tap into specific
services right so these are the services
that are constantly always on always
running on platform system services so
so that starts up next we call them in
Java we usually call them managers or
that they're backed by it by your serves
right so once this starts up at that
point we say the system has booted so
this is sort of the chronological line
what we said with what we say the system
is done is completed with the boot is
completed and at this point we can start
the actual applications so basically
like I have the line here so this is the
chronological order of things right once
we have all that done we can launch our
applications so that's that's that this
is just you know any any usual
application that we make
running so let me show you this in
another way on a little closer to the
actual device so I have an emulator
running now I just put it up nothing
really special about it what I'm going
to do is I'm going to adb shell to
connect to the actual device which in
this case it's not fining so this
happens every once in a while so you got
to do a big kill server and adb start
server hopefully reboots that connection
this is what the tools are sometimes not
perfect so let me see it be devices and
the emulators back online connected to
my laptop so I'm going to go editor
shell now and we're in so at this point
I'm connected to the actual shell of the
device but do a ps2 just see what the
process is what processes we currently
have running on the device this is
basically what what we have here so init
process is just like on any Linux
platform that starts everything right so
that's that's the beginning of life on
on the platform next what we have and
you can sort of see the process IDs
everything so you know it's
criminological based on the IDs so next
what we have here is a whole bunch of
this Linux native demos that gets
started and this is basically where
we're starting our runtime processes
here right so these are now the
android-specific
granting processes so this is a service
manager the this is for example the
radio demon already interface layer
that's starting up here and at some
point we start up zygote okay so that's
basically correlates to this point in
time here so at this point we're
starting as I got and the run time is
already started up so once we once we
kept I got started so these are also
parts of the runtime so this is also
native code that starts up this is our
adb daemon so this is what's
facilitating this connection back and
forth between my laptop and the actual
device it starts up here at that at this
point once design
is has been started we can start
anything that has to do with dalvik code
right which also includes our system
server and so this is the system server
that's starting up started up here you
can actually see that the process ID the
pan process ID is ID 33 which correlates
to the Zygon process ID right so
basically that's where it it comes from
let me show you what that like this so
basically the system's this is forked
over to this box to create the system
server process inside in which all our
services or managers run right so this
is where your location manager Wi-Fi
manager connectivity manager bluetooth
manager telephony manager you know all
these managers basically they're running
side of this box as a single process so
that's that's that's that
at this point we're we're done pulling
so everything that falls after that is
going to be the Android apps right so
these are various Android applications
that we can study them so it's very very
much chronological as well in terms of
what happens you know in terms of the
the actual you know PS command
seeing the processes the actual order
but all this is in init RC file so so
that's why it's specified and but like I
said D or it's very much important that
the cycle starts before any anything
dalvik related starts up so many
questions we'll just the boot up process
so far yeah Indian RC yeah so if you
look at so basically there's a file
right here in it RC file and and that's
it's almost specific to Android you know
in a way that it's different than
typical Linux distributions there's a
there's a it's very well explained you
know in a text file in source so I can
actually show you this file really
briefly but what I'm going to do isn't
going to load up I'm going to load it up
from source as opposed to doing
it from from so let me just load up my
image for the Android source and excuse
I'm going to do vol gingerbread I'm
gonna open it up here so you can just
take you no longer to start up because
it's loading all the directories should
actually do this so in in source it's in
system folder city core and that's where
see the root door and that's where I are
in it RC is so let me see if I can open
it up like this to show you I guess it
just my system is a little running a
little slow it will eventually open up
as well so this is the file that's
basically basically specifying you know
the order of the startup order of things
so this is where we start ups I got
process and it's critical to everything
else and you know it's you can also see
that they're dependencies that
everything else is dependent on zygote
so exact it dies it's everything else
needs to be rebooted and that may or may
not work actually
if you kill like kill - 9 for examples I
go so if the system is going to be put
but usually doesn't come up doesn't come
back up properly all the time so so
that's a little bit about the the
startup process any any other questions
so on how things of this starts up when
it's yeah um how much does I got saving
time in terms of the the start of time
I'm not sure exactly how much it saves
intermedia I'm not I'm not understand
sure but you know the keys to make the
user experience as as good as possible
in terms of starting up the application
so that's what we're starting with
to to help up and the design of Android
is such that we have a very we have a
sandbox for each app right so each app
is a totally different Linux process
unlike for example you know Blackberry
or some other systems where the the
applications are are come separated in a
Java layer so here we're doing that
separation in the C layer so such we
actually need a copy of the VM for every
single every single instance every
single app right yeah
yes so exactly yeah to see exactly it's
a C process but it it is going to load
up the instance of the VM so that when
you are for kid you basically have the
VM ready not many I have I have my
consumer phone um we can just kind of
you know that is totally non modified
regular phone so I can we can compare
the notes with that as well so now if I
connect my physical phone through this
I'm going to do adb - D shell to connect
to the device shell right and I can do a
PS from this device and as you can see
it's pretty much pretty much very very
much similar right so in it starts
everything a bunch of demos start up
they're slightly different right so
there are different sets sets of demons
and that has to do with things that are
sometimes proprietary to the device
there's going to be a lot of driver
related stuff you know it's the whole
world that that is I'm not that familiar
with but at some point we're basically
starting up our service manager which is
the C implemented C part of the Android
code that backs the certain the oldham
and all the system services and we're
starting couple other things but here
again is I got starts up and after that
we start everything else so you can see
that that PID is the parent of the
system server right and once the system
server is done this is one we actually
completed bullying this way we send a
broadcast message in
would complete or in broadcast intent
and at that point we're starting up
everything that gets to do with with
Android so these are all the Android
apps that's what that's what I'm
referring to so I have quite a few
running so it's very much comparable in
terms of that on usually the init init
files are going to be quite different
I'm not quite different but it going to
be different but that's usually done on
the platform in a way that let me show
you it's a good way to show you let me
show you now from the actual so the
actual system so LS so in it in this
case I only have one in it but on this
one on the amulet emulator we actually
have two in it right so this is
basically the amulet in it our C file
that is specific to the emulator
goldfish is a is a nickname for emulator
for some reason they're always named
data fish to the Stroud and so on but
goldfish is refers to the emulator so
this is the emulator specific init init
gold and cat it and you can see the disc
over selling certain things that our
emulator specific such as for example
what to use for its internal IP address
you know that battery level things that
kind of like you know it's always at 50
percent and so on and so on so this is
all set in that specific Android
emulator specific RC power
um so when it's yeah
so so okay so the question so the
question is how come the amulet it takes
so long just just to start up so what
would what we're speeding up so let's
draw the let me let me let me tie this
because it's not working very well so
let me draw this line here right so this
is what we say the system is booting up
right your from you are saying that this
part here is relatively slow right and
but but that's not what you're trying to
make faster that is not our goal our
goal is to make startup of this faster
so that's why we have zygote we want to
make this start fast it's not it's not a
big pain point for the user that the
phone boots up really slow right because
you know you put it up once a week or
something right but it would be a big
pain point if starting an app takes a
long time right so for example iPhone
fix start up by putting up the photo of
the app the image of the app while it's
actually cranking the background and
putting up the the actual application so
in Android we you know focus more on
actually making things faster for real
as opposed to faking it there's a
question why does the emulator takes so
keeping so why is the emulator so that's
not well so why does this part here take
a long time to start so keep in mind
that the what we're using an emulator
not a simulator so I keep telling people
you know this sounds very similar but
they're quite fundamentally different so
this here is a virtual machine right so
we are running exactly the same code
base as we are running on on this right
so it's it's ARM based code and so forth
so we're not simulating anything so the
fact that they have a dual core you know
eight gigs of ram macbook pro doesn't
really matter I'm running the same code
base and
as I'm running on the physical device
now why it may be slightly slower than a
physical phone is purely because of the
emulation so you know when you when you
amulet whenever your amulet thinks
you're interpreting the binary code base
so that is very slower but we're gonna
do some compare going to do some testing
on speed later on with a with the NDK so
we're going to see you know you could
get some fundamental differences between
physical phone and emulated phone and so
on so so when it's all said and done
here when we finish booting up we
basically had this right this is the
stack many of you have seen this picture
before yeah so at the end of the day
everything is up and running looks like
this so the bottom of it all we have
Linux right it's backing the native
libraries which are basically C C++ code
that is there to back this part of the
system right and at the end of the day
you know application people you know
developers write apps right so as an
application developer you want to write
an app that's going to talk to something
that's available to you in the
application framework that's why Android
is so appealing right because you've got
this rich framework you can just tap
into it you can you know get things done
quickly like for example figure out your
GPS location etc etc now for the
framework to be able to get a job done
it needs to talk to the libraries right
it needs some kind of backing from the
native native code base and in those
libraries in turn then sometimes need to
talk to the actual hardware by
connecting to the - - you know the
drivers and things of that nature so
that's just called stat what the stack
looks like that's our standard sort of
Android stack now what I want to get
into is talking a little bit about the
interaction between the various layers
of the stack so what's interesting to us
so you know this is not a conversation
so much about writing apps right that
was the talk yesterday but what's
interesting to us is called the various
parts of the system actually communicate
across these boundaries right across
this various boxes and in keep in mind
while my stack looks really nice here
right everything is like ideal you know
I really sort of segregated and compared
putting compartments and such on you
know when you look at the actual source
code it's not quite like that so things
are much more mixed together so it's the
picture looks nice but it's not like
that on the the code base so what
happens is in terms of this interaction
between parts of the layer different
parts of the stack is we essentially
need to cross couple of boundaries right
so on one hand this part here of the
stack is mostly Java all right and this
part of the stack here is mostly C code
so one one one boundary that we kept to
kind of bridge is is this one here right
the second the second issue that we have
is when we want to have one application
talk to another application remember how
we said in Android each app is sort of
an island on its own right it's a
separate Linux process with its separate
UID
separate permissions everything's
separate right so if basically if you
want to if you want to have one part one
application talk to another application
we basically need to be able to
communicate from one process or call it
process one to another process of call
it process to it right okay so those are
sort of the two main main boundaries
that we kind of got understand how to
how to bridge because everything else is
you know boils down to Java and C which
presumably you guys know so I'm not
going to you know worry about that too
much but what's interesting to us is
called to make this communication across
the the world of Java in the world of C
and process one to process two so that's
where the layer interaction basically
comes in in there are different ways to
do that and what I'm gonna do is I'm
going to show you a couple of scenarios
for a couple of different frameworks
that exist in the system right now so
this is courtesy of you know
source.android.com and the actual what's
in the boxes doesn't really matter that
much don't don't get
calm details too much at this point but
basically for example this is the audio
frame or this is how you you write an
app you say I want to play a song right
like you want to play a little you know
music and what happens what happens next
is your your code is probably
interacting with the media player which
is what you would find in the
application framework right that's
that's what you program against that's
what use now this is the world of job to
cross over to the world of see we use
something called j'ni Java native
interface right so that is basically our
bridge to the world of C code which is
basically everything below roughly this
line and so media players communicating
to media player counterpart in C so this
would be the C implementation of of that
you know of that code basically the
native supporting the native methods in
Indo Java code that in turn may load up
some libraries to C libraries that in
turn may then communicate eventually to
some kind of audio driver so yeah so
what we're using here is basically we're
using j'ni to cross from the world of
Java to the world of C okay so this is
just one scenario right so another
scenario is the camera and video
framework so it's a little more involved
but basically what I wanted to point out
here is that unlike just a media media
playing music which is more or less just
a set of libraries when it comes to for
example camera we actually have a camera
service running so camera service is now
example of that something that is
running in a totally different process
right so we have we have now the problem
of bridging process one to process to
communication right and what we are
doing in this case is we are using
something called a binder IPC mechanism
binder inter-process communication
mechanism to go from one process to
another process again so that's that's
that's basically the android-specific
way
of doing that of course you can do you
know you can just open up a socket there
are many different ways you can
communicate between multiple processes
but what Android brings to the table
that's sort of new is the is the binder
IPC mechanism so what what that looks
like now basically let me show you a big
stack picture so basically what we have
here is we're going to have the binder
to bridge this and we're going to have J
and I to bridge that right so that's
essentially what those are the two tools
that we have at our disposal when it
comes to working with the entire stack
with looking into all the bits and
pieces of the stack is that so far make
sense any questions of that yeah I
believe it student sea level as well
yeah we're going to do an example with
the job of version of it but the the
binder is implemented in c yeah
select me so let's start any other let's
start then with the J and I how many of
you actually use J night before okay
most of you alright so um great so Jana
is basically a Java native interface is
just a java thing right it's it's a con
it's nothing nothing more than a
convention on how we're going to name
things in C so that Java knows how to
call it in however when I call from C
back to job so essentially it's just a
naming convention for to facilitate that
what's important to kind of understand
is that J&amp;amp;I code in other words your C
code native code still runs on top of
the same java virtual machine or the
same vm that that your java code runs in
toggle as well so this is what you would
typically do when you're doing something
with some j'ni code there's nothing
really Android specific in here right so
this is just a plain old Java so you
write a Java source code you compile it
you get a class file that class file
goes on top of the virtual machine and
that's where it gets interpreted if
there's anything declared native in that
class file you compile it to Joe does
J&amp;amp;I which is the tool that comes with
the jdk right and that produces
gather file this is your dot H file and
then what you do is you implement that
gather file in C you link everything you
compile it to get your dynamic library
dot SSO file right and that dynamic
library gets eventually loaded by the VM
so essentially when Java wants to call C
or C wants to call Java it doesn't it
doesn't work like this it actually works
like this so the Java code goes to the
VM and the VM loads the library in
Oxford right so that's sort of a that
sort of how it happens in the world of
janaki yes yes so for our purposes so
for our purposes so far everything is
the same yeah you know in dalvik and in
Java so I'm kind of using those terms
interchangeably because there's nothing
really too specific about it
so which tools are Java so Java age is
just a standard Java tool there's really
nothing so that as I said it ships with
the JDK so you guys should have it as
part of JDK Java development kit yeah so
so far this is just a plain old Java now
the next topic is basically something
called a native development kit anybody
played it or played around with NDK
couple yeah cool so um so NDK and the
kit brings couple makes life simpler
brings couple things to the table so
here some things that NDK brings to the
table so for one it provides the entire
tool chain on to compiler code right so
when you're compiling your Nate your C
code you are compiling it for the
platform that you're the you know the
device platform so in other words arm
most likely right or in x86 so finding
those setting up those cross compilers
can be very painful I did some of this
before NDK got released and it's one of
those things that takes you know a lot
of time unnecessarily so NDK solves that
entire problem by providing the tool
chain you know nicely packaged secondly
what NDK also provides is a way to
package the the libraries
with the with the apk file itself so in
other words if I don't know if you guys
notice but in the in the unit RC file
which is so slow okay in the unit RC
file we specify at the top of the
environment and the only thing that we
have in the environment as the in the LD
library path is the system Lib folder or
there's also the vendor look but that's
beside the point
so system lab folder is the only place
so in other words if you look at a file
system of the device which I'm just
going to pop pull up here so if I look
at the device file system this is the
only place where this is the place where
all the SOS go all the libraries now the
problem with this place is that it's not
a read-only file system right it's not a
problem if you're building a custom ROM
you can easily put stuff in here but if
you want to have a native code the chips
with your with your application this
this is not a place you can put so
that's the problem the solution to that
problem is to basically put the library
of your library alongside with your
application so it basically goes into
the app specific sandbox file system
directory right so each app as you
probably know put has a slash data / -
it's sandbox so for example I think it's
I think this is the one that I'm using
right now so this is a sandbox for this
particular application and the ESL file
goes into this folder right so so that
to me that's a big deal because it
solves the distribution issue so now you
can put your native code in your app in
your app and you can distribute your app
to the market - you know everyone as
opposed to having to you know create a
customer custom run to the superior code
so so that's a big deal it also provides
a set of header files that are
standardized and it also provides
samples and the documentation for that
so in terms of the NDK why would you
care about it why would you use it right
we're still
talking about the application
development with native code so why do I
even go into sea realm so one of the
reasons the main the main reason for
that is performance really NDK is sort
of developed in my mind with the
motivation for to support games right so
that's why a lot of a lot of sort of
standard headers you have to do it for
example mad graphics that sort of stuff
right so it's really for for things that
are computationally intensive people use
it for four different purposes as well
me you may have legacy code some C
libraries that you want to include as
part of your project and you just don't
have time to convert it or don't have
interesting converting it to job so in
that case you can just basically wrap it
in you know with the j'ni interface so
those are some motivations whether keep
in mind that your your Esso a library is
still going to be sandbox inside of the
same process as the rest of your
applications so having something in C
C++ it doesn't mean that it's going to
be able to accomplish from security
standpoint anything more than Java can
do right yeah so what about the Flash
plugin I'm not I mean I'm not sure you
could put your library on the SD card if
you want to manually manage where you
you you put the library and then load it
from that place so you could basically
manually manage the location of files to
know them you know explicitly but and
what NDK doesn't sort of removes that is
responsibility you don't have to worry
about it you just create a library in
your download yeah and so that's
basically the motivation for NDK and why
you would care about that so the steps
to create to using NDK as sort of I sort
of outlining here like this so basically
what happens is you write some kind of
library your Java library and you may
leave certain methods declared native
right meaning you're not implementing
them in Java you're just saying que
there shall be a method
implemented somewhere native you compile
your Java you get your Java class file
no big deal there but then what you do
is you recompile your class file or you
apply Java age to your class file to get
the header file so this is again your
dot H file now what you do is you
implement that in C so you write C code
to implement the the actual header file
you create a make file and you compile
everything into the dot dot s so false
so this is now you know dynamically this
is now linked from Java to the Esso
right and then you write your
application that actually uses that so
the application is no longer concerned
with the fact that some parts of of that
library are actually implemented in C
yeah so about the sandboxing so this is
the product this would this would be the
process right so in so this is the an
application process it cuts it it's got
its own like library it's got its own of
the dalvik virtual machine it loads what
I call the building blocks or components
so these are your services activities
providers receivers so all that is part
of a your application context right to
your application so well it's the dalvik
gothic virtual machine lots of the
library right just like the Java Virtual
Machine loads of the libraries so that's
it gets loaded by the VM so VM actually
communicates to the library so the VM is
the one that resolves your cost to
native so when I say when my Java code
says I want to call native code the VM
actually resolves that in to the actual
C C++ implementation of that so we're
going to see this in code shortly so so
this is basically the steps you know
sort of like in lines and circles so
here's what I'm going to show you an
example that they took typically build
and it's basically a I was looking for
an example that I can really quickly do
very important C in Java so here's a
very simple algorithm and something that
kind of you know gets so
or really quickly gets really slow right
so Fibonacci is perfect for that so if
you burn out you again is just to
Bonacci of zero is zero
Fibonacci of 1 is 1 and then it's a
recursive formula so if you cannot G of
n is people not G of n minus 1 plus
people not your bandmates do right so it
gives you this kind of sequence so what
I wanted to do is I wanted to build an
application and I wanted to basically
use both both algorithms and see what
the speed differences and these are
roughly the steps but let me show you
that in code instead so so you had this
little close let's start like this so I
have this little application here and
typically what I would start work is
writing the Java libraries so this is a
just a plain old you know Java code it's
got nothing Android ish in it right so I
have a this is my simple implementation
of people not change out write recursive
I also put included a one out everything
that can be done recursively can be done
non recursively as well so this is one
of the iterative implementations of the
same algorithm right so now so that's
basically my my java code now for my
native code what i did is i simply said
i declared it
you know here and i said its native so
in other words look for it elsewhere
right so my native version of of the
fibonacci is recursive is going to be is
declared here and the authority version
is declared here i also need to make
sure that they load the library where
this is actually going to be located
right so that's the first step that's
that's that roughly corresponds to to
this here right so we wrote the native
library and stuff right so now what we
need to do is we need to use java age -
j9 now this is one of those things that
eclipse is not automating these steps
yet I know people are working on that
but so we kind of get to do a couple
steps manually but it's not too bad
so what I'm going to do is I'm going to
go to my mic my command prompt and I'm
going to go to my my workspace of
Fibonacci I'm going to go to the bin
folder right because that's where my
class files are so from here instead of
changing the class path so from here I
can say Java age - j9 and I can say I
want to come on up apply it against that
class so calm Maracana and then live
right so what this tool does is it
basically analyzes the class and you
know anything that's declared native it
takes that into account and creates a
corresponding header file so what's what
we got here is there's this file the
header file alright now this guy default
doesn't really belong in the bin folder
so one of the one of the ways that you
know I usually organize this and it
seems like everyone else does as well as
create a Jane I folder that hangs off of
your project so this you know top-level
J&amp;amp;I folder and put all the although see
the native related code in this folder
so I'm going to CD into that I'm going
to actually move this file so calm
underscore to J&amp;amp;I folder I'm going to CD
to j'ni folder and so that's that's
where we have that farm app so that file
looks like this so this is their
standard Jane I file and refresh it so
this is that file that got automatically
generated the only things that you
really care about in this file are this
signatures right so these are the method
signatures that correspond to things
that were declared native so in other
words when we said here I want to have
fib n for fib native be declared declare
native right so the Jane I notice that
this method is going to be the
coordinator since this method is in a
class called comm dot mark on about
Phillip right and the net method name is
fib and that's why we have such a long
function email so it's job on the score
column Arcana fib lip fib n right and
these are the standard exports this is
the dirty turn type so J long
so basically ji standardizes the on the
pipes since C doesn't really have a
standard so just go align it with with
the Java primitive type size and so this
is our return type and this is our input
the DN that we are inputting into the
into the function now these two
variables are always going to be there
basically Jane iean V refers to the
environment itself in other words the
virtual machine in J class which could
be J object if I had it non declared
static so the fact that I have a
declared static gives us a reference
back to a class as opposed to the
instance of a class
in other words object so that so the
second parameter is either going to be a
j-class or J object in this case a class
that refers to the class that that that
called it in the first place right so
that's basically the signature of the
got generated by generate Java Java h2
so at this point we have the header file
right arm so we didn't write it we just
got a daughter generated our next job is
to basically implement that that header
file so we're only writing these files
right this is the only thing the only
things that were really implementing and
also for something that's using it so
the secret for this this implementation
of this is fairly straightforward so
what you do first is you make sure you
include that gather file right on and
then you basically copy/paste to get the
signatures of your methods so there's my
method one and one function to write and
then you implement so in this case I'm
implementing by calling the local
functions which is basically the
copy/paste of the the same algorithm as
we have in Java I you see this is our
fibonacci you know just Fibonacci
recursive here in Fibonacci
non non recursive here right so it's the
same same code we're going to run the
same algorithm but in natively in any
job so at this point at this point we
have to see implementation of those
things that could declare native so the
only thing that's missing is the make
file the make file looks like this I
usually just copy-paste it from one of
the samples that come with the NDK so
that's that's simple simplest way to
create your make fall alternatively if
you want to read about make files and so
on I'm not sure if I'm online but
source.android.com under porting there's
the build system is explained and
there's a link for there's a cookbook
that explained you know gives you common
make files for you know basic stuff so
that's not a place to kind of look look
at the how to how to put it together so
once once you have basically the header
file the its implementation and the make
file all you have to do is you have to
build it so you do that by simply doing
NDK build and that's going to take the
make file read it compile everything and
create DSO file so this is the this is
you know the cross compiler and
everything happens in here right so this
is dramatically simpler then if you were
to setup your own tool chain and worry
about all the all the details of of
combining all this so NDK build just
does a lot of good stuff behind the
scenes yeah that's I just learned about
that so the mortar dev team are
apparently apparently created in the
integration for NDK into eclipse it
right now it's available as part of a
Sequoia project which is a separate
download into eclipse so you guys can
look it up so I haven't played with it
but apparently does because a lot of
this sort of manual steps that they are
kind here it's been on so at some point
is going to be control less to save it
and everything gets really built as well
just like Java this so yeah that's great
so
so at this point what happened is we
basically got the library directory
created here and this is new so this is
the output of of and of NDK build
there's also the obj folder which is the
intermediary files but the final library
is right here right so when we when we
push this application we install it onto
the device like as you saw it it ends up
in two slash data / dat especially our
app slash libs folder right so that's
why it's going to be located so what I'm
going to do next is I'm going to run
this this application I also have a you
know the activity that goes along with
that in other words something that uses
this code but I'm not going to discuss
that because it's not really a topic of
this conversation it's how to write
applications just standard activity so
I'm going to run this I'm going to run
it on the emulator first and let me
rotate it so that it fits better let's
see if it's going okay so it's coming up
now so I have it here so basically what
I can do is it can enter some kind of
code some some number for my Fibonacci
sequence we can solve it something small
like 20.3 click on go and so these are
the results that that I got so basically
the the Dalek recursive version took
about so this is the result which is
should be equal right it's not
interesting to us too much but what's
interesting is the actual time so what
we're comparing is the Dalek recursive
to native recursive right yeah so that's
that's one interesting number and the
second interesting number is the DES
number here which is basically the
iterative version of dalvik versus the
native iterative version of of the same
author it made yes so I timed the
iterative algorithm is
substantially faster so if you time it
in milliseconds you're going to get like
rounding errors it's going to be like
either 0 or 1 so I change it to
nanoseconds
the first one is my crib
so it takes takes a long time right so
now what you're really looking for is
the oral order of difference right so
this is about you know these numbers are
fair it are the same order right 260 mm
and actually they're not they're
different verses the systole apparently
it's slower to run it yeah let's go with
the number let's go with a large number
like 25 so this what we get right um
yeah so the numbers are I mean the Nano
timer is not this precise and it's we're
going to get much more of a difference
between these iterative versions but
what's interesting is for the recursive
version we're consistently going to get
about one or the order of a magnitude
difference right it's going to be 10 20
times
Floria so so Dalek is a registry base
not stack based so it actually doesn't
work very well with stack based
applications which recursion is it's
actually the opposite so my
understanding is that the if you have a
code that that uses a lot of recursion
you're you're not you're not going to
get a good performance from dalvik and
it's also not something that a
just-in-time compiler can kick in and
optimize and help out with right so
that's my understanding of it now when
it comes to iterative the just-in-time
compiler can actually optimize your code
and the the performance is going to get
about the same right very quickly but
there's obviously a certain cost
involved with J&amp;amp;I Bridge as well so
that's why native version may actually
appear to run slower
just because we're timing it from Java
we're timing the actual bridge over to
native and then the results back so so
those two are sort of you know toss
exactly the time spent native has to be
worth working well yeah so does the NDK
build code the does the indicate build
put the lib into into the apk no it
doesn't it simply puts it into the lips
folder and basically when you apk
builder is going to put it into the apk
once I hit run button right does in the
end the note the apk builder doesn't so
there's a that's basically a naming
convention so that this folder lips is
supposed to be the way it is so if this
folder exists with this naming
convention the apk builder is going to
look for this librarians going to place
it in a proper place that's basically
the platform that we were so in this
case we were building for ARM arm II ABI
exactly so what that's that's a good
point so see for example when we install
it so if I can if I if I build for x86
presumably able to have a different
subdirectory here as well so since since
we're we have a native code we may have
multiple versions of the Lib the Lib as
so file right and then the proper
version is going to get installed is
there a tool like trace view to for
native code I'm not as part of Android
so trace view is driven by Dalek so so
the information actually comes from
dalvik it doesn't come from so we don't
you know the C code is the black box in
that case so trace view doesn't last so
it treats native code is black box but
but I you know when I used to do C
programming many many many years ago I
remember their toes native to see that
that to do that sort of profiling so but
not that I know much about I so the
question is you kept the Esso you
install the app but the the Lib doesn't
seem to be there he stole it again I'm
serious I just did that I was what with
couple hours ago when I was preparing
for this and I started from scratch and
I was like wait what just happen why is
it
why is it not there and exactly that
think happened and I just ran install
again and second time around it worked
on native code debugging GDP is there
there's a you know a DB support GDP
bridge so you can you can you can you
know use that so so so if another
application wants to use the same lead
file you and presumably that's not an
application that is written by you so
you can you can put it the same context
in other words if you have two
applications that you sign with the same
mom of ki and they live in the same
package then they can share develop file
but if their toys separate applications
then the Lib files are off-limits
because the Lib files the libraries live
in their sandbox parts of the file
system so yeah there are limits yeah so
in terms of the NDK compatibility as
long as you stick to the libraries that
to the headers that are guaranteed to be
support it you're fine right so that's
part of the you know that's part of the
what NDK is it's basically says these
gather files are going to be supported
for a very long time
right you could be using some other some
other libraries for example people used
to it go directly to blue c library
before a bluetooth was available as a
java api but that's not really
guaranteed to be around for forever so
so what i wanted to do is so so this is
this is one part of the equation that i
wanted to cover with you guys and that's
that's basically building a by the way
i'm running it for a frequency of 33
just to see what number we get and
that's the numbers week I believe Oh
right now so keep in mind that I'm
running all this in the UI thread which
is a big no-no right in a big you know
final application and we discussed this
yesterday so this should be running in
async task it'd be a perfect candidate
for that so that way you know we would
have we could run for much larger
numbers and we would not get the ANR
right application not responding but
that's that's a different that's a
different conversation that's we talked
about that yesterday
so this is going to take some time to
process 33 is about the limit that I can
push this web without without the ANR
coming - so is that a number yeah yeah
so that's the number so 35 seconds
versus one second right and what's
interesting is when you turn on trace
beyond this and actually analyze the
execution you can see that there
gazillion recursive calls happening in
Java and that's basically what's taking
like 99.8% of time or something so so
that's that's where that's where it's
low the second piece of the equation so
we talked about right so what we what
we're discussing here is how to bridge
the you know those two divides the
divide between Java and C and we saw
that now I want to briefly talk about
how to bridge this divide which is
basically process one to process quick
communication right so one of the tools
that is available to us is something
called the end of the binder IPC right
and the access to that is via the
Android interface definition language or
a IDL so basically a binder is our our
our system for doing the IPC calls right
so if I have one application say for
example this is my my application that
wants to know what its GPS location is
so this application would say hey I want
to get the the system service for
location so it gets the location service
right referenced it and then it would
say location service what's the last
known location for instance right so
that call goes through the binder driver
it gets Marshall then to the appropriate
service right for the service to execute
and then it goes back in this way back
to the application again now what's
important with the the IPC magnet is I
practiced mechanism is that it's a
blocking call right so it's a it's a
synchronous call unlike intents which we
discussed yesterday in the workshop
which are basically a sickness right so
they go and they get placed in the queue
and then the low
picks them up and so on so it's a
different different mechanisms so this
is a blocking blocking all communication
so what I have here is I just wanted to
show you an example of how this
application how to how to do this so
what they're going to do is we're going
to create a service an application here
which is going to be a service and it's
going to be a simple logger service so
you're going to basically say hey blog
something for us remote logging service
that's that's all it is right so we're
going to have a simple client that is
going to make that remote call to the
logging service to log something and you
know and that's it come back once it's
done with a lot right so these are going
to be two separate processes living in
two separate VMs yeah what are the
limitations for the binder in terms of
moving the data across I'm not sure what
the limit is on that but you know if
you're moving a lot of data
maybe the binder and maybe the IPC is
not doing the right thing right because
the other tool to care at our disposal
is our the content providers and they're
sort of designed specifically for for
you know dealing with data across the
boundaries application bombers so let me
let me show you this example here so I'm
going to close all this so first of all
I'm just going to run it first to kind
of show you what it is and so you can
see it so this is a simple app that is
going to log remotely so on one hand I
have is going up oh my god I have a
client and it simply has a button right
and as I click on the button this is
going to make a remote service call to a
servers service no service you can't
really see so for that purpose I'm going
to basically run the adb logcat here and
let me see this goodnight I'm going to
disconnect my physical device in this
case so this is my lock at not much
interesting stuff going on until we
press click right so click click click
and that's basically logging that
something is that something is going on
right so we
see that there's a message and we're
going to look into this code how this
works another interesting thing that to
notice is that if I do if I do adb shell
PS you can see that we actually have two
separate processes all together so
there's they're totally non related to
each other there's they're two separate
applications from two separate people
and two separate packages they happen to
be signed with the same key but that's
not very relevant in every other respect
they're they're separate apps right so
the client in the server's so typically
what you start what you do is you start
by defining your interface for the
remote something and so that it is how
long's trying to open it detects mate
versus open it here so that interface
looks like this and it's basically this
is basically the a IDL code and a LDL is
essentially you know inherited from
ideal which is the core by interface
definition language right so in many
ways it's very very similar but it's
also very similar to a Java interface as
you can see so in this case what we have
is with finally package we're basically
defining let there be an interface we
call it dialogue service it's got two
methods log D and log the reason why I
put two methods is because the this one
is only using primitive data types which
makes life very simple right so string
is sort of a primitive data type in this
context so it's it's fairly simple now
this is where things get a little more
complex because I now have a proprietary
I have a custom object that I want to
send across the process lines well if
you have something like that you
actually have to create this object into
as a parcel so it needs to be a parcel
parcel both data type that can actually
be you know sent across the wire from
one process to the other so that's why I
sort of you have the second example just
to kind of demonstrate that and that's
going to be in in this IDL file called
the message so let me briefly show you
so defining the actual cost
data-type message is fairly simple it's
fairly simple because it just basically
say let it be parcel yeah
now the Java for it gets a little
trickier but or we're going to get that
later so what happens when you add the a
IDL files there's actually integration
for this in a clip so it clips is
automatically going to run a ideal tool
from the SDK and process this file the
interfaces and create the stub files
so this auto-generated file that's
extremely ugly is is an auto generated
code right from by by a ideal tool so
that's what that looks like and you
don't really care too much about what's
inside of it but basically that that is
the that's what explained the marshaling
an army are showing and data back in
home across to the binder so you don't
typically look at this file too much
because it's busy um now what we need to
do is we need to provide the
implementation of a service yeah so
we're not defining an interface we're
simply declaring a message is a parcel
now the Java for it is going to be
interesting we're going to again if you
use the closet's a custom class you know
you have to declare it parcel and you
need to then provide a implementation of
it I'll get to that next but I want to
show you just the the the service how
the service works so to implement during
the to implement the remote service so
remember um well depending on I'm not
sure how you guys use services but in
most most people use services and as in
Android as as a unbound services so in
other words the the on bind method is
usual is something that we ignore we
usually focus on on start command on
destroy right so those are usually the
methods of people implement like for
example in a music player application or
something like that so that's a non bond
service in this case we're implementing
a bouncers that's what the IDL basically
provides so what that means is we need
to provide the implementation for on
bind and we need to return a binder on
that implementation
is really a pro is ready the stop for
that implementation is provided by that
auto-generated code right so you
basically just say I want to return that
and that eclipse is actually going to
fill in this for you and give you all
the methods that you need to provide so
you essentially just need to provide the
meet of the actual function or method
right so you need to say what happens
pretty modeling right so at the end of
the day that you're just filling in this
piece of code and that piece of code
right the Eclipse is going to create it
you already have this table Auto
generated for you and eclipse is going
to tell you what you need to implement
to do cab to implement all the
unemployment methods and so that's what
the remote service looks like it's this
part is fairly straightforward now it is
and you also need to of course declare
it in the manifest file to say hey you
know this is going to be it's going to
be a service and it's going to be
available for other people to bind to it
so that's what we're doing here we're
declaring it here and I'm basically
picking or creating some kind of action
for which this service is going to
listen for so this is how clients are
going to bind to that service and this
could be any piece of text that you come
up with but this is pretty standard to
use the actual full-fledged name of the
interface um so once we have the service
done the next part is to do the client
and for the client what we're doing is
basically we're we're copy pasting the
same IDL stub so these are my ideal
files because the client needs to know
the same needs to know what the
interface is to the service that's why
we needed the ideal on and and then what
we're doing in the client is we need to
connect to that remote service so this
is where things get a little interesting
so we were concluding here is I'm
basically creating an intent that
defines what we're going to connect to
and I'm saying bind to that service bind
to that remote service right but what's
important here to know is that this
happens asynchronously as well so this
is
find is going to finish really quickly
but it doesn't mean that we're going to
be actually bound to the remote service
at this point as a matter of fact we're
not going to be bound until the next
iteration of the looper right because
the looper is actually going to just
pick up the next job at the next once
it's done with this to actually do the
binding on the results of the binding
are then communicated back to us via
this service connection clause so that's
what this serious connection process so
we basically to provide a class that
implements this interface that simply
says what happens when we got connected
or when we got disconnected okay because
this is asynchronous so this is
something people usually sort of don't
get because if I was trying at this
point to communicate directly log
service dot blog for instance right this
would fail because we do not have log
service bound yet again I'm sorry no it
will care it's guaranteed to fail it's
100% is going to fail so that's because
keep in mind that there it I was showing
this picture yesterday keep in mind that
what things happen inside of the
properties of the system so instead of a
system we have something like this right
so this is our process and so we have a
single looper on a single thread right
in this this guy's doing jobs serially
one job at a time and it blocks so while
it's processing that method I think that
was on create that I was in right it
wasn't you know an create right so while
it's processing this job here it's not
processing any other job so the fact
that this job says bind to a service so
we're inside of on create here inside of
a looper that says bind to a service but
that's merely going to generate a new
message on top of the queue for the next
time around to do something so you need
to actually finish on create first be
done with it go back to the queue pick
up the next job which says by no sirs
so is this ever multitude you could help
yeah you could have multiple threads
right but but again we we had this is
still going to be asynchronous it's
still going to be on somebody's queue
and there's still going to be a looper
processing that looper skew right so you
could have multiple threads but that's
not going to make this I know you have a
single thread you can simec a single
looper per single thread so these are
basically one-to-one there's a
one-to-one relationship between a looper
in a queue right so they in yeah yeah so
that's basically so at some point we
then bind and at that point log services
finally available this is the first time
that the de log service is available Oh
in the log service what happens when on
a successful bind you're going to get
back an ID binder that's the binder that
we are returning here as when we say
return
you know the stub right right we are
saying return new box service stuff so
that arrives here as an eye binder which
we now need to cast to our particular
service and for that again we use that
stub the doctor generated code it gets a
little confusing on a client side just
because of this asynchronous nature of
the actual binding process right yeah so
you know most of us is app developers
we're used to using system services and
you just say get system service and you
get the system service and exactly the
same stuff is happening the difference
is that the system services already
bound to the context so you know you
don't need to actually do the bind right
that's that's what the difference is I
think there's a presentation tomorrow
specifically on system services I think
it's going to be more on the lower
levels yeah I have on click here and I
can log as many times as I want
yeah
so yeah so a log we can call log service
as many times as you want one thing that
I didn't talk about is the message so
the actual message dot java
as i said needs to be a parcel right to
be able to be something that you can
send across the wire and if i have a
simple message that contains a string in
a text what that really means is you
need to provide a way to read a parcel
in write and you need to provide a way
to dry the parcel out
so basically it's kind of like a
serializing in java but not really right
so you're basically converting and live
object into a stream that can get also
really created on the other end so that
and you also need to provide this
creator as well but but you know you
know in a nutshell you need to read the
tin and and write it down to be able to
make up to make it a parcel yeah yes you
still need to create an ID IDL file yes
so yeah so the question is why do they
why do they even need to define define
this here as an action while then I just
say build an intent and spell out the
name of the class I wanted to provide
the clear separation that I have no
intricate knowledge of what the class is
and so forth so that's why I would not
use explicit intent I'd rather use an
action based implicit intent in this
case yeah yeah is there a way to keep
people from running running your service
yes you can either you can add any
permissions right so you could request
that you can require the color to to own
a permission to connect and so forth
right yeah so can you dynamically choose
the implementation of the interface oh
yeah well you could but that you would
have to right you'd have to put we have
to create a factory method I guess
yourself right to provide that there's
nothing dynamic
think about that so binder is using
shared memory to make so that's why it's
making things things supposed to be much
faster dam is copying yeah it's you know
what so if you guys go to running
Android comp this is basically chapter
14 and 15 and so it's um you know what
they try to boil down into so that's
outline there all the code is there I'm
going to make the these three
applications also available for download
here so on this on this forum blog post
so I'll make about the dog the code
available yeah
I'm if any if you have any questions
over here but otherwise thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>