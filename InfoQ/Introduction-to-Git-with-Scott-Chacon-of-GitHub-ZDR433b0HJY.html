<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Git with Scott Chacon of GitHub | Coder Coacher - Coaching Coders</title><meta content="Introduction to Git with Scott Chacon of GitHub - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introduction to Git with Scott Chacon of GitHub</b></h2><h5 class="post__date">2011-07-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ZDR433b0HJY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's talk is going to be an
introduction to get so for those of you
using get today already this talk will
show you a little bit better
the sort of the internals and how to
think about it as a different version
control system than what you probably
have used before git and for those of
you that are new at it you know it's
sort of an introduction so hopefully
this will help you ease into it if you
want to start using it so those of you
that did raise your hands for the
Eclipse thing the eclipse foundation is
moving most of their projects to get so
clips itself we'll be using it primarily
for most of most or all of its projects
in the next couple years and there's
been a lot of work done on Egan I'm not
going to be showing any Eclipse stuff
any really Java specific stuff it's just
going to be command line stuff but if
you use a GUI or if you use a plug-in or
something most of the concepts should
transfer over fairly well so so this is
the the introduction again okay so real
fast let me introduce myself so you kind
of know why I'm up here and give you
some some resources some takeaways from
this talk since I'm going to be speaking
I tend to speak fairly quickly so unless
you're a really good note taker or
something you if you want to go back and
reference what I've been talking about
I'll give you some some resources so my
name is Scott Cohen I work at github has
anybody been to github for okay about
half cool so it is a source code hosting
site so it's it's a you know you if you
have a get project a source code
software project in git you can push it
a get hub and will host it for you for
free if it's open source if we do like
paid private stuff is how we make our
living but I've been there for about
three years now I also did this site
this is the official get web site so if
you go to get SEM com is where you'll go
to download git for Windows or for Mac
or you know get the source code forget
if you'd like to there's links to
documentation there's a documentation
tab things like that so this might be
really useful to you if you want to
install git
going forward you're not using Eclipse
and you just want them to come in
line or find some some documentation or
something there's another site that I
did called get reference site so get
revved org all this stuff I'm going to
be talking about today is on this
website sort of the shorthand this is
sort of the the reference material for
the stuff that I'm covering today so
it's not everything that you can do and
get it is the most used options for the
most common commands that you're going
to be using and you it sort of groups
them by what you do with the verbs right
so some of the verbs go in more than one
section but if you want to figure out
how to do branching and merging those
are the you know the five commands that
you're probably going to be using and
the most common options to those
commands finally this is a book that I
wrote pro git which was published by a
press they were kind enough to let me
create a commons license this so you can
read it online for free that it looks
like this you can read the entire book
online you can download PDF from OB or
epub or whatever I believe we have all
of those available and if you want to
read on your iPad or something like that
but this is a full book that is free you
can even get the markdown source for it
if you want to translate it or it's
available in a bunch of different
languages as well but if you need it in
another language then you probably won't
understand what I'm saying so this is my
email address if you have any questions
feel free to contact me you can say Java
talk or something and what your question
is you talked about this whatever I'd
like some more information on that more
than happy to answer your questions some
people prefer to ask questions over
Twitter that's my handle on Twitter as
well alright so that's more than enough
about me
some leave-behinds for you from this
from here on out you're on your own I'm
not going to pause for you to take notes
but if you do have questions please do
raise your hand I'm more than happy to
answer questions in the middle of the
talk if something is unclear or you want
more details on something and if I don't
feel that it's relevant I'll I won't
answer ok so what does get so get is an
open source distributed version control
system designed for speed efficiency so
that is the sort of official line of get
right but there's a couple important
things in here one it's open source so
you can go it's like you know any other
open source version control system is
GPL you can download all of the source
code it is very kernel hackery
it was written forward to manage the
Linux kernel so it's it's kind of
difficult to understand it some ways as
big monolithic C database or source so
code but you can't go on the website the
icons a little bit different now looks
like a little penguin but you can
download the the source code open it up
see what's going on if you really want
to do that it's a distributed version
control system so how many of you use a
distributed version control system that
is not yet has anybody used anything
else mercurial or bizarre possibly okay
just a handful of you so it's a
distributed version control system so
this is a different class of version
control system and it has some
implications to it being distributed so
in a centralized version control system
which is what you have probably been
using what most of you how many of you
don't use a version control system at
all I'm just kidding I'm not going to
make you raise your hands the the in a
centralized version control system so in
perforce or in subversion or in does
anybody use anything other than perforce
for subversion clearcase thing else
mercurial
okay so in a centralized version control
system in perforce and subversion in
clearcase what tends to happen is you
have a database on one server on one
system somewhere and that's that's your
server database and there's a clear
differentiation between the roles of the
client and the server and the clients
tell the server I would like to start
working on this project and they
download a snapshot of that project
whatever the latest one is and they
start they can start working on that and
they can check in incremental changes of
some sort to say here's an update here's
a way of making this codebase better and
computer B does the same thing and
probably gets it at a different point
but they they have to enter they have to
operate through this central server the
entire database lives on the server if
you lose this central server and you
don't have a backup of it you're screwed
there's basically nothing that you can
do you have maybe some of the later
snapshots but that's about it sometimes
it's even difficult to recover them and
click in cases of things like clear case
yet distributed version control systems
are different so what distributed
version control systems mean is you
don't check out a vision of a project
and start working on it you clone it
usually the verb is clone get clone you
give it a URL to clone and what clone
means is clone it means take every bit
that's on the server right now copy it
to my local hard drive and let me start
working on the database locally so you
don't have to be online for most
operations it tends to be very fast
because you're just operating in your
local
file system there's no network latency
overhead to deal with if the sexual
server goes down everyone has a copy of
the database you can do backups of you
can have a database on a central server
on some server that everyone has access
to but it doesn't mean that it's any
different than any other node in the
network right you can push and pull
directly to peers and you can push and
pull to a central server and it really
get does not care what how which one of
those you do yeah there's a couple
different options so yes you could
that's tends not to be what you want to
do because most of these are personal on
laptops and things like that I only mean
central server in that that's what
everybody has right access to in order
to collaborate or you know read access
to in order to collaborate and so that's
that's a central point for people to to
to synchronize their work right it's not
special really except that they have it
as an alias in their in their local
profiles so if that goes away you can
either put up another another system
that everybody has SSH access to or
something and take any of these
databases and put it there and then have
everybody redirect to that and that's
fine you could designate one of them but
unless it's it's permanent
semi-permanent then people are going to
have to keep changing their aliases but
yes as far as git cares all it needs is
another database that is similar to the
project right so it is a it is a fully
distributed system just about every
operation except synchronized so what
you do is you get a copy of the database
you write new snapshots new commits to
that local database and then you
synchronize it with other ones and so if
you have a centralized want everybody
synchronize it at the same point and
make sure that everybody's sort of in
sync at the time of pushing or pulling
right at the time of synchronizing those
databases so other than that everything
is local there's a couple of different
implications one is almost everything is
very fast right if you're running a git
law if you're running a log of the file
system or seeing a log of a file what is
the history of this file or the history
of this project or branch for something
it's just reading data out of your local
database so it's really really fast
right if you're doing a diff it's just
doing it off your local database you do
not have to you can do it on airplane
you can do it offline you off VPN which
is really important right you don't need
network access to any other system in
order to do just about everything so
it's very fast
it means every clones are back up there
it's really difficult to lose a system
entirely right everyone working on the
project has in some state a backup of
the system and you can work offline or
off VPN right if you get on the train
you get on an airplane
you don't need network access for almost
everything that you do in version
control it's only when you push when you
you know pull that you actually need to
access the network there's no way of
getting around that everything else is
local so you know you don't need a
network to do all of these things to
merge branches right to commit changes
to get other revisions of a file to
compare to to some older point in the
database you don't need the network for
any of that stuff sure yeah you can you
can set up a local repositories you can
have a remote which is just another
version of the database it knows about
you can clone your own report your own
repository to another one on your file
system and push and pull to that if you
want to and you can do you can do pushes
and pulls over file colon slash last URL
and that that works just almost exactly
the same use the same mechanisms as
going over HTTP over SSH or any of the
other protocols that get will allow so
if you want to test stuff out you can
certainly just clone your repository
somewhere else in your file system and
add that as a remote and push and pull
to see what's going with what's going to
happen but it's also very easy to just
create something on github or you know
any of the free hosts and and play
around with with open repositories yeah
it uses its own proprietary database
they get databases is it is its own but
it is very easy to inspect and also use
some tools on how to do that if you want
to look in the database if you'd like to
do that it's okay so it's immutable so
you will here at some point in working
with git if you get into it at all about
rewriting history how many people have
heard rewriting history in terms of git
so git does not rewrite history there's
no command and get that will rewrite
your history what git does when you do
something that that is called rewriting
history when you do an amended commit or
when you do a rebase or something like
that
which I won't really be going over those
but if you get to that what good is
doing is it's writing a new history and
then moving a pointer right and so if
you delete a branch you're not deleting
the work in the branch you're deleting
the pointer but the data all stays in
your database if you rewrite your
history you're not losing the old
history you're simply
the pointer to it right you write an
alternate history and then move a
pointer over and so if you want to get
it back you can either drop a pointer
there and I'll get branching is really
just pointers you can either drop a
point in there or you can go through a
log it keeps a log of everything you've
been doing so you can always go back
it's very difficult to lose that and get
once you've committed it right if you
write get commit you can always rewrite
that history differently but it's very
difficult to lose the data itself right
it keeps it around for a long time if
you if you when you clone when you
actually push data over the network it
only it only pushes stuff that's
reachable so you can do what I'm saying
rewrite it rewrites it locally right
when you push you can force put I mean
you can delete it on the server and then
just push a new one right with only the
stuff that you want that's reachable the
stuff that's invisible through normal
commands will not be pushed over the
network so you can you can easily do
that it's just it's a difference of
changing the sort of pointers around and
then wiping it out and starting over
right and it's it's actually not that
difficult to do okay so the final thing
that's sort of a big mind change is if
you're used if you're comfortable with
version control and it's a version
control system that is not get you're
going to hate get you will hate it when
you start using it you will hate it
because it is very different in the way
that it thinks about version control it
is very very different than subversion
or perforce or systems that have been
around for a very very long time and so
they're in the backs of our brains at
all time as this is how I do version
control because it's the only way that
you could do it for the last 20 years
basically right from RCS till now it's
been basically the same system right
subversion perforce are our alternates
of RCS they still work basically the
same they still think about their data
in basically the same way so git does
not and so this is I want to try and
give you an idea of how get differs and
how it actually internally thinks about
its data because if you think about it
this way when you're using it I think
you'll get a lot less frustrated the
easiest thing to learn get and to like
it is to completely forget about version
control as you've been doing it and try
and rethink it in the terms of git right
think about it differently when you're
using it don't try and think of how
would I do and get what I used to do in
perforce when I want to do this try to
think about it in these terms instead so
most of the version control systems are
file based Delta storage system so what
happens is you
have a couple of files and try and go
through this kind of fast when you
commit when you add I'm sorry when you
add when you add a file when you say get
a SVN add readme SVN add hello or
whatever system you're using what those
systems do is they create a log for each
file it is file based right it's file
centered so it creates a log for each
file and it puts some version in the
file log when you change something if I
change a you know a string in this file
and I commit it will save a delta in
some manner sometimes it's you know
sometimes it it keeps the the latest
version and then Delta's backwards it
depends on the system but it adds some
version to the log of that particular
file right so you have version two of
hello and you sell version 1 of readme
if you rename the file this is where it
gets hinky because you have a log of the
file but you still want the the history
of the file right so what you need to do
is you create a new log and you have
some pointer that points back to to the
older file this is what it used to be
called so you have these sort of
explicit renames that says this is what
the file used to be called so if you're
traversing the history you have to jump
over to this log and then go backwards
from there because that's what it was
called and so on and so forth right so
it just for every snapshot that you have
for commit D it has to go through and do
some amount of calculation to figure out
what the snapshot was by the the
versions of each log that that are
reachable in that commit does that make
sense is that how you think about
version control out of curiosity some
some people do some people don't this is
how subversion thinks about it right
this is this is how the system itself
thinks about this data and some people
have carried that over it depends um it
does not think about data this way right
yet thinks about data as snapshot so
when you say get add it is not adding
files to like creating a new log it's
not saying I want to add this file to my
version control system when you say get
add it says I want to add the content in
this file to my next commit so you run
it every time if you change a file you
run get add on it again because it's not
saying it's the first time I've seen
this file it's not adding new files this
confuses some people it's saying the
content that's in my working directory
right now for this file I want that to
be in my next snapshot right so it's a
very it's a different usage of AB so
that's confusing sometimes but what it
does is it takes the content of that
file it ignores the file name it just
takes the content it
checksums it with a sha-1 hash it puts
that content in its database in a key
value store basically and then it gives
you back as the key the Shaw the the
checksum of the content right and says
if you ask me for this Shaw I will now
give you back this content does that
make sense
and it does that with hello and you say
get add hello dot C it does that again
when you say get commit what it does is
it it records a manifest then it calls
it a tree a tree object but it records a
manifest that says it's sort of like a
directory listing if how many of you are
familiar with like POSIX a POSIX system
plastic inodes and directory structure
directory listings and stuff so this is
very similar right this is sort of based
on that so you have this directory
listing that says here this content
right and here's what the file names are
for all of these and it checks sums that
and gives you a checksum back for that
that's key for that as well
so if you ask it for that checksum it
gives you that that manifests back right
the directory listing and that's
recursive so there's where there's trees
that point to other trees and stuff and
then you have a commit that has your
message my initial commit your your user
name your email address the dates that
this happened and then a pointer to one
tree to the root tree right and it says
this is the manifest for this commit
this is exactly what it looked like and
everything is check summed so you can't
change any data and get without changing
the way that you pull the data out of
git which means it's cryptographically
secure right you can't you can't
everything you get out of git is the
exact same bits you put in because the
way that you access it is by the check
sums does that make sense
so so this is the the readme file if you
say when it's checking it back out it
says if I ask it for c3d bla bla bla bla
bla it's a big 40 character hash it will
give me back whatever that value is
whatever that content is and if you ask
it for this this is the content for
hello gives you back that content now if
we change the file like we did in the
previous version in the previous system
it sees different content right it check
sums differently it does not look at
that file it doesn't have a log for that
file it just sees new content that it
doesn't has not existence in its system
before puts that content in gives you a
shot back when you run git commit it
gives you back a new manifest that
simply points to a different points the
same readme so it's sort of like a
our link right it's like reusing the
block pointer so points of the same
content for the read me different
content for hello right there's no
there's no history of hello unless I
walk through these and compare manifest
to manifest to see what changed from one
to the other and there's also a pointer
from commit be to commit a it points to
the one it was based on right so you you
can get a diff what was introduced by by
comparing the manifests that each one
points to if you rename so this is where
it gets kind of interesting if you
rename the file and you run git commit
no new content is added to the system
because you added you you didn't modify
any files right there's no new content
that exists on your system all you did
was change a file name and so what it
does is it puts it in and it just reuses
the same pointers the same shah's the
same check sums for the for the content
right it says these are exactly the same
things that are just under different
file names yet does not store explicit
rename information the way that get
figures out that you renamed a file is
by looking from one commit to its parent
and saying what files disappeared in one
and appeared in the other and our
content similar right and it's a jurist
'ok it's 50% is is what the default is
you can change it you can say assume
renames are 30% similar is a rename file
or assume it harder assume at 70% okay
if you look at this there's a lot of
waste right these two files are stored
fully the reason why is because it's
very fast to write it that way you don't
have it get does not have to figure out
the Delta compression while you're
writing the file to disk so it stores it
this way initially when you push it over
the network what it will do is Delta
compress these files against each other
but it doesn't necessarily have to Delta
compress a file to another version of
the same file I can Delta compress any
content to any other content in the
system right however it gets the best
Delta compression and you can say get
take more time and make me a smaller
pack file make do more Delta compression
on this make a longer Delta chain you
know take more time to figure out how to
get the most savings out of this and
it's very very good at it for text-based
files
and then if we change this or something
and we say copy the file this time right
it puts new content that it sees in puts
in a new manifest and interestingly if
we copy a file and add it back
again it will simply use the same block
pointer for both right so it uses sort
of hard links within the trees and also
interestingly if you recursively copy a
directory the these point two subtrees
so if you recursively copy a directory
and you don't change any of the files in
that directory it will store it will
hard link directory structures which
POSIX won't do right but this can so so
anyways this is how almost every
centralized version control system
thinks about its data and this is how
git thinks about its dead and I think
this is much simpler right there what
they did is a very simple database a
very simple structure and then complex
algorithms to do interesting things with
that right but this file structure has
not changed since one dot oh I mean not
it hasn't changed for three years
probably in almost any way you can still
read old file systems that were done
several you know at almost to be very
beginning of git because it just really
hasn't changed very much just the way
that it works with this data has changed
okay so what I want to do real fast so I
have some pretty pictures and stuff like
that but what I think I want to do is
deviate from the slideshow a little bit
and just show you an example of using it
on the command line okay because I think
it's interesting
ignore my friend all right so I'm sorry
I have to do this I'm a ruby guy I'm not
a Java guy I just know Ruby so create a
little rails app
okay so here's my my little rails app
that I just made right so let's say that
we want to do some development on this I
kind of want to show how get school so
this is not a git repository yet right
one of the interesting things about git
is that you can use it you don't have to
have extra nodes you don't have to have
a server in order to have a local
database right you can use it like if
has anybody used RCS cool the cool
people have so you can use git like you
used RCS can everybody see this is this
okay so you me to make it bigger send
any better so you can use git like you
used RCS so you can say get in it and
you have a git repository this is how
git repositories are created initially
and then you push them up to a server
somewhere or you can initialize them
around on the server if you want to but
that's fairly rare so you create a new
repository get an it I have a repository
now if I say get status I can see all of
these files are actually let me I mean
this is hard to see you I think that's
easier to read so I have all these files
right that rails generated for me so I
can say get add dot that adds everything
to my system I can say get status again
it says here's all the files that are
new and I can say git commit and right
so it's fairly simple right so I've just
done a commit if I say git log I can see
that I have one commit and I was telling
somebody before that you can actually
well I'll get to that in a second okay
so this is my commit right now let's say
that I want to do something so and git
has a very nice branching system so I
want to show you the branching system
real fast so if you say git checkout -
be checkout switches branches so it's
sort of like SVN switch you say get
checkout - be blue and let's say that I
I go in here and I want to change my
background let's see our RGB okay so now
I have a I mean let's be honest a
beautiful blue background color right so
now if I say sorry stop I'm going to
stop doing that
that's an alias that I have if I say get
status get that's get an alias forget
status - yes if I say get status it will
say here's the file that you've modified
right if I say get commit right now it's
not going to do anything because I have
I have to say get add I have to say add
this changed content to my next commit
so I'm going to say get add public and
then if I say get status it gives it me
- it gives it to me in green and I can
say get commit blue background okay
so you can see that if I run get branch
I'm on my blue branch right I said check
out - be blue that created the branch
and switched me to it so now I'm on my
blue branch if I say get check out
master then it revert s' the files in my
working directory right so when you
switch branches it modifies your working
directory so if you add files or
something it will and you commit them in
a branch and you switch to another
branch it will remove it from that from
your working directory right and go back
and forth so you can't switch branches
unless your working directory is clean
there's a command code get stash to
clean it in the meantime and then you
can make it dirty again with those sort
of does it like saves a patch of
everything that you've done and then
allows you to apply it later but yet
using it effectively assumes that you're
going to use one working directory for
all of your branches you're not going to
have separate working directories for
multiple branches right you do
everything in wanting you fast contact
switch between them so now if I say I'm
on my on my master branch now get check
out - be think of something else we can
do email and I go in here you can see
that this was reverted right that's not
the blue color anymore and so I go in
here and I do something silly
let's see I'll take this and I'll put in
my email address into the little sidebar
here
you can use get diff to see what you've
done I can see that I added that I can
look at the website I've added my email
address in the sidebar there there's a
little shortcut you can do that so you
don't have to run get add-on everything
you can say get - a git commit - a will
automatically run get add-on everything
you have modified that where that was in
your last commit not untracked file so
it's very similar to SVN commit in what
files it it decides the stage oops and
now I can switch back and forth get
check out blue I get my blue background
but no email address I get my email
address but no blue background so I
right so I can switch back and forth
between the different contexts that I'm
working in and I can share these with
people and people can work on them
separate right so you don't have to do
it's very uncommon for for people that
are using git as a team to use things
like feature flags right where because
you don't have to commit everything to
trunk right it's not it's very easy to
create branches and work on them
independently and merge them in later so
now if I wanted to to move them together
right let's check out master where I
have neither of them I can say get merge
email and I get my email get merge blue
and I get my email address and my blue
background right so I can merge the
context together fairly easily and get
is very smart about doing merge as well
and giving not giving you conflicts all
the time in fact an interesting thing
that I can do so I don't know how many
of you did yes
so rebase is a little bit more complex
than this then this intro I I recommend
fetch and then merge manually rather
than pull but I'll get to that if I if I
actually get to that point in the
presentation a little bit later but
rebase I actually I would almost always
if you're doing it within a corporate
corporate environment I would almost
always recommend using merge over rebase
in basically every instance personally
but we can talk about that afterwards in
more specific detail if you'd like to so
now I can actually go back go back to my
blue context and you can see that it
took my email address away when I switch
back to blue right because that I left
that context back there I only merge
them both into master
when you do emerge it only affects the
context you're currently in right so you
can always go back so interestingly what
I can do is I can go back and I can
change this color again so let's do
something even prettier and then I can
go back to my master branch and merge in
the blue branch again right and so now I
get the prettier blue color with my
email address right and so you can do
reintegration merges so if anybody's
ever tried to merge a branch in
subversion into trunk more than one time
like merge it and then go back and do
more work on it then merge it again has
anybody done that no because you've
committed suicide right you're not in
this room right so it's very easy to do
and get and and that's actually a really
powerful tool it's a really powerful
tool to be able to do that because what
it allows you to do is the following
scenario say I say you have you're
running on my sequel and you want to
switch to Postgres or something like
that
right you have to go through or even
better you want to internationalize your
site so you have to go through all your
view code and you have to change
everything right every damn string and
your whole thing you have to put some
wrapper around so if you're working on
that and it takes you a really long time
to do and other people are working at
the same time on the app they're going
to be changing those view codes and so
you get to the end of your two-week long
process of putting tea wraps around
everything and then you merge your
branch into master what happens all
right you have 500 conflicts right
everything conflicts and it's awful so
what you do what get allows you to do
because you can do reintegration merges
very easily this way is allows you to
say create a branch called
internationalization start doing work
and then merge into that branch from
master every day right and if you merge
in every day you only have conflicts in
the last 24 hours or if you merge in
every two days you only have conflict
since the last time you merged in master
never gets modified it never sees
anything you're doing but you're keeping
your branch up-to-date with master right
and so you get to the end of two weeks
and then you switch back to master and
merge and I tune in all of the work has
been done for you it simply does a
fast-forward which I'll I'll explain in
a minute and it's done right everything
you can do everything in this in a
specific context and you don't have to
worry about it you just merge and
the one you want to keep up-to-date on
right so that is why people like
branching emerging because you can do
the fast context switching this way go
back and forth if I you know if I wanted
to go back to my email branch I can
still go back and it just takes out all
the blue stuff that I've been working on
in the other branch yeah you do fast
forward only merges on your main branch
so when you do a merge get lol is not a
command uh so this is what the graph
looks like right
it keeps the the merge history which is
how it can do the three-way merge at the
reintegration merges easily you don't
have to specify merge base because it
can figure it out from the graph but if
you want to make sure that you're not
you're not doing any any merge work and
master you can say when you say get
merge you can say merge ffs only blue
like that and it'll make sure that the
branch you're merging in kanri if you
follow the history of the branch are
merging in it can reach the branch or on
right which means it's it's newer it has
merged in the work you're on at some
point and so it will only do
fast-forward merges right if it is
diverged in some way it will not allow
you to do that which means you can't you
can't fix it you can't have any merge
conflicts if FF only works there will be
no merge conflicts because it just moves
a pointer up the up the up the graph no
it has to go up you can set the policy
on this on the server if you want to
right if you own your own get server you
can put in hooks that enforce that or so
that was the demo so now I'm going to go
through some of the stuff that I did in
that demo and show you sort of behind
the scenes like what is happening what
does get doing right so the first thing
that you want to do if you're using the
command line is you want to set your
username and email like if you're using
Eclipse it'll make you do this when you
set up the plug-in but if using the
command line there's no central server
to authenticate to to to say these
changes I'm introducing are from this
user right the user database is not on
some central server that you
authenticate to so what happens is you
tell the system who you are you right
because you all your changes are being
written locally right you write all your
changes locally and then you push to the
server and if you have write access it
trusts you right
to that use you are who you said you
were when you wrote all those things it
doesn't verify this data again you can
set up hooks and stuff to verify this
data if you want to but usually it's if
you have SSH access to the machine then
you're part of the company and you know
you're trusted to do this sort of thing
you also probably want to set the
coloring on so you get the nice coloring
stuff that I have there as well there's
also if you use if you use a shell and
you want to do the sort of stuff I
highly recommend using the bash
completion stuff the shell completion so
there's e shell and bash and C shell I
think and it'll do stuff like you can
type like you can say oops if I have it
on it'll give you stuff like your the
what branch are in right so if I can
figure out what branch I'm in all the
time so now I'm in the master branch
because it says in my prompt there and I
can say em tab and it'll tab complete
branch branches and stuff like that so
it's very nice okay so those are things
you want to do so now get a repo so the
first thing that I did was I ran get in
it to create one right you can create a
repository you can go I used to do this
in my keynote presentations I still do
sometimes go into the dot key directory
because in Mac it's a directory or you
can make a be a directory and just run
get in it and start version control in
keynote right where I don't have to do
one big massive thing I can just version
control the directory you can go to any
directory run git init and just start
version controlling that directory
because it's so easy to do just run get
in it and start running git add git
commit right it doesn't you don't have
to put it anywhere you don't have to get
somebody to provision it for you so if
you're going to get in it this is what
happens it creates a dot git directory
which you didn't see because it's a dot
file right so it's sort of hidden from a
listing but you can go into it you can
look at it right now when you run git
and it just creates a skeleton it is not
like subversion it does not put a dot
git directory in every subdirectory of
your project it's not metadata this is
your database if you tar this up and you
email it to somebody or you put it on
some server you can untie it and that is
now a node right that has all of the
data that you need when you do a clone
this is what comes down and then we have
our file in the directory there so now
everyone get add dot and we commit now
the only real difference if we look in
this docket directory again we see a
couple differences one is
in the object subdirectory we have all
these objects right this is the data
this is a database forget it just writes
one object it writes it into a file
named the Shah named the checksum right
if you open this which is basically just
an unzip you have to use gzip there's a
little weird header on it but if you
just unzip that file what you get is the
raw data right the one of them is the
file contents for hello world one of
them is the directory listing the tree
the other one is the commitment data who
you were what date you did what your
commit message was right the commit
message the commit object points to the
tree and then the tree points to the
blob so if you can get the commit one
you can traverse the pointers to find
everything in the database although all
the objects are reachable does that make
sense how do you find the commit right
so the way it finds the commit is
through branches is through these
references so if you go into refs heads
it has all your branches if you wanted
to create a branch that pointed at a
specific commit you could actually say
echo and then a sha and then redirect it
into dot get slash refs heads anything I
want and that will create a branch
called anything I want because all the
branches is a pointer to it I'll commit
but this gives us a thing where I can I
can cat that get a sha that will point
to the commit I can open that up that'll
have a pointer to the tree I can open
that up that I'll have a pointer to the
blob and then I've reached all of the
objects in my database right so this is
how it works on the lowest level but you
don't really need to know that I just
think it's interesting the other way the
common way to get a git repository is to
run git clone right so this will instead
of creating a new one this will clone an
existing one so it gives you a database
that was on some other system and just
gives you a note of that right a copy of
that database so you say get cloned give
it a URL it'll take get colon is an
unauthenticated URL so it's almost
always read-only it's very uncommon to
have unauthenticated with write access
but it's unauthenticated it's a special
to get it will use SSH SSH will
basically take any URL that SCP will
take if it's a git repository on the
other end and you say git clone and you
could as SCP it then you can say git
clone and it will clone over that
repository it just piggy backs on SSH so
if you can authenticate as that user
over SSH then you can
you don't have to set up a get server it
uses SSH so that's the easiest way to
set up a server if you're doing yourself
there's also H CPH TPS file colon slash
slash there's a couple different than
ones but what happens is it will give
you a specific binary file with just the
data that you need for whatever you're
pulling down which in this case is all
of the branches so all of the reachable
data in the database pulls it down you
can see the total 591 there that is 591
objects that are coming down in the in
the binary data that I'm getting so what
we did where we added one file and did
one commit that's three objects this is
591 it's still not that big there's
probably only maybe 100 commits Senate
or something probably less and then it
will give us a check out of whatever the
newest thing is so we have some starting
point right so it puts it in directory
we can go in there start editing stuff
start saying get add and git commit
interestingly though you don't have to
do git commit it's not write to the
server right we can go in we can clone
somebody somebody's repository we do not
own we do not have write access to and
just start committing in it right just
start working on the project we can
worry about getting it commit getting it
upstream at a later point okay so then
you record a snapshot so the basic
workflow for recording a snapshot is you
say you edit files so you know if you're
cool you use vim otherwise you can use
anything else right you you staged the
changes with git add so you say git add
whatever the file path is that says this
file as it looks like on my disk right
now I want to be in my next snapshot
that I share with people when I run git
commit you review the changes with git
status or get diff yes and you run git
commit it will commit the version of the
file when you ran git add it snapshots
that when you say git add you you could
actually say you know you could say git
add on a whole bunch of files and then
remove every file in your working
directory except your docket directory
and run git commit and it will still
work yet commit by default does not look
at your working directory at all git
commit will take anything you run get
add-on plus whatever you had originally
checked out because it's just modifying
what you had originally checked out and
it commits that as a snapshot
and then you can push that and pull and
and merge that and things like that a
basic or workflow if you are so inclined
if you want to work in the subversion
style is you can just edit stuff and
then say git commit dash a and that will
stage and commit everything I don't know
what the team provider and eclipse does
what options it has for these things but
I believe you can do interesting things
actually even easier the reason why this
exists like why even have git add at all
like rot why make you go through that
extra step right there's actually some
cool things you can do with this by
having this middle area one thing you
can do is you can say get add dash P
which is dash patch or any a lot of the
gooeys will do this as well which allows
you to stage sections of a file right so
if you've modified a file and you put a
bunch of comments at the top and some
some business logic changes in the
middle of the file you can say and you
just want to commit the comments or you
want to commit them separately so it's
easier for peer review you can say git
add - P and it will prompt you hunk bi
hunk
do you want to stage this part yes or no
do you want to stage this part yes or no
and you go through that whole system and
then you say git commit and whatever you
said yes - that goes into the snapshot
not necessarily what's on your working
directory right so you can be very
specific about saying here's all my
whitespace changes that you really don't
need to peer review that much and then
here the business logic changes I really
need your attention on right instead of
having them all in one big commit
because you worked all week on it and
never committed it so it allows you to
make sort of last-minute decisions to
craft your commits nicely this this will
blow that away if you do get add - P all
over the place and then run git commit -
a it will just stage everything and not
not care what you had done so be careful
with this choose one or the other okay
so some behind the scenes a little bit
when you run git commit it's funny I
like to move around when I talk and but
I have to be here so you can see me
doing this basically the whole talk
so when you say git commit what happens
is it will give you output that looks
like this and what most people's
favorite part about git is is this this
is your version number right this is the
first however seven characters of a 40
character Shaw there is no 1 2 3 4 5
there's no monotonically increasing
version numbers because there's no
central authority to delegate them right
there's no way when you do a commit and
I do a commit we're basically
be working on private branches when we
sync them together it depends on who
pushes first right on what end and we
could push two separate servers and then
have somebody else pull those down and
merge them together there's no canonical
database that can say one two three four
five and you can see that it branches
and merges all over the place like you
saw in the graph so what happens is that
is that git doesn't even try it doesn't
even try what it does is it writes all
those objects even the commits as
objects named after the shah's and then
when you synchronize your database when
you push to another database or when you
when you fetch something in all it does
is take every object you don't have yet
and throws it into the same namespace
because it knows there aren't going to
be any collisions right so it just adds
every object you don't have yet and a
couple pointers so it doesn't have to
worry about trying to merge files or
anything like that when you actually
synchronize databases does that make
sense
so there's no human readable version of
these you can run get describe on one of
these and it will give you you a version
of this route that is more human
readable relative to the last tag that
you made which is kind of nice for going
over email and stuff and it's but it
still embeds part of the show on it so
it can it can be non-ambiguous yeah yeah
so the question is there are different
operations to compare your local changes
from the last thing that you did in your
local changes to the server right and at
a new any coming changes from the server
so I'll get to that in the last section
if I get to that but basically what you
have to do is when you fetch you get you
get the commit chain the commit hits the
the chain of commit snapshots that have
been created by other people and pushed
to that server and you run git fetch it
will pull them onto your local system
and you can compare the last snapshots
in each of those right there's no
there's nothing that will compare
something directly on the server you
have to pull that database into your
database and then compare it locally so
there's no difference between comparing
something on a remote branch and
comparing something on a local branch
because what you do is you make your
remote branch local branches and you
compare it just like you would compare
any of your two branches right that it
would be the master like I want to see
the difference between my master branch
and the master branch on the server or I
want to see the difference between my
master branch and my blue branch right
there's no difference between those
operations that they as far as get is
concerned everything has to operate
locally so you pull it local and then
you do the comparison locally yeah
do a git clone you're just getting the
master branch history you have to do an
additional know by default when you run
clone it will give you every branch
that's on the server it will check out
one of them locally so that you have
something to work on but you will have
bookmarks to every other one and so you
can compare whatever you've been doing
to either what it was based on or to any
other branch that came down when you do
a fetch by default it will pull down all
of the brand all of the new branches on
the system as well so that it's easy to
collaborate yeah so I actually already
went over this and I want to get to the
other stuff so I'm going to go through
it kind of quickly but if you ask it
what this is it will give you raw data
back right that is this is the commit
data and it has a point of the tree and
a pointer to the commit that came before
and if you ask it what that tree is it
will give you back raw data that looks
kind of like this right here are the
files and all of the the contents that
those files are and if you asked it for
the parent it will give you another
commit object and so on and so forth
right so this is how git keeps its data
it's just a series a directed graph of
snapshots so when you say get check out
it actually pulls all that into a file
called the index and then from there
into your working directory so you can
actually modify it and then you modify
the files and then you want to get add
and it will checksum them and overwrite
the entry in the index and then when you
want to get commit it only operates on
the index so this is how this is why if
you delete all of these in your on git
commit it doesn't care because it is it
already has all the data it needs in the
repository and in the index and it will
just create the commits and trees that
it needs to fulfill that all the blobs
happen when you run git add and will add
them to the database so it doesn't
really care what's in the working
directory necessarily
okay so branching and merging so given
that branches are pointers into this
graph so I showed you the graph before
in my history right if we look at this
oops we can see we can see this graph
right masters at the top and then its
parents are blue and whatever came
before on master and then its parents
are blue background and you know that
what is now the email branch but you can
go through the history the pointers the
branches are you can see it designated
here email blue master there are simply
pointers into this graph right this is
the farthest place that master is right
now this is the farthest place that blue
is it can go off in different directions
right if you wanted to
bye-bye undid this blue would be sort of
off by itself you can have different
heads right so a branch is just a
pointer it's just a reference into that
into that history into your database
somewhere and they're easy to move in
they're lightweight so the way that you
branch is you say get branch will list
your branches will create new branches
and checkout will switch between them
right so you say check out this branch
check out this branch and I'll switch
the current branch that you're on so
let's say that we have this commit and
by default get in it will create a
master branch so you will almost always
see master branches in repositories
because it's the default and most people
in the entire world are too lazy to
change defaults right so that's why
almost everybody has a master branch
it's not really necessary it's just
another pointer and then the last
concept of get is head so you'll see
head every once in a while and what head
is head is your current branch it is a
symbolic reference it's a reference to a
branch right so you always have head but
a head will be pointing to one of these
other pointers to one of the branches
that you're on and it means your it is
the parent of your next commit it is
what should be checked out and you're
working what was last checked out in
your working directory so anything
you're doing should could be comparable
to this is your last known state of what
your working directory was right so if
you say git branch ITN if we want to do
internationalization on our app we can
say get branch i18n I did check out - B
I'll show that in a second but what that
all that does is it drops in a pointer
right if you say git branch something it
will take no time at all because all
it's doing is writing 40 41 bytes to a
file and then stopping it's just
creating a pointer on your system now if
we run git branch you can see I did this
earlier it lists out the branches we're
on and it puts a little star next to our
head is right this is our current branch
there's our current context we're
working in if we look in the refs file
if we actually cat one of these files we
can see it's just the SHA so it's a
fairly simple system now if we check out
ITN what that does is that moves head
over to point to ITN instead and if
necessary it makes your working
directory look like whatever I you KN
points at right when you say get check
out ITN it makes it checks out that into
your working directory that's why it's
called check out the branch - which is
actually sort of a secondary function
but
it makes it look like that in this case
they're both pointing at the same thing
so it's a no op it doesn't really do
anything right if they were in different
places it would make your working
directory look like whatever you were
switching to this is important in a
second so if we commit it writes the new
data in the parent of the new commit
snapshot points at whatever head is
currently pointing at
so whatever head is at that is going to
be the parent of your next commit and it
moves whatever heads pointing at forward
the only branches that move are the ones
that head point set right if you are
ever scared about doing something and
get the easiest thing to do is drop a
pointer just say get branch where I was
do whatever the hell you want and as
long as you don't have where I was
checked out it's impossible to lose what
that last commit was does that make
sense
because it will never move pointers
other than what a head is pointing at so
you can just throw random pointers in
your database if you want to have some
place you can get back to you easily so
you commit commit it moves that branch
pointer up you say check out - B issue
53 master so this is a little more
complex command all this is doing is
it's creating a branch at a previous
point so it's creating a branch called
issue 53 at master and then checking it
out immediately so it does this this is
equivalent to this I could check out
master and then check out - B issue 53
which would create one and switch to it
or I could do all three of these check
out master create the branch check out
the branch right I keep all of these are
equivalent most people like check out -
B because usually when you create a
branch you want to switch to it you're
creating it because you want to work in
that context so we commit we commit
right it goes off in a different
direction alright it writes it writes to
the same database just goes off in a
different direction and we have all
these pointers so now we can see what
gets seized if if you say what happened
if you say get logged - that's tad or
something - see what all the files were
changed in each commit what it's doing
is it's just comparing we can see it
right from our initial manifest - the
second one we added a file we didn't
change any other ones it can tell really
fast because it's just comparing the
check sums right and then the second one
just changed that issued C file that was
introduced does the second branch
tighten n branch adds a new file
modifies that file the second commit but
also modifies the hello dot C file right
so we know what get knows at this point
so merging this is why merging and get
is fairly easy because
what it does when you run git merge is
you check out the branch you want to
merge you want to modify you want to
merge into so we want to modify the
master branch we want to we want to
update it to have this new work so you
say check out master merge whichever
branch you want right all of these these
commands are very simple they usually
just take one argument which is the
branch you want to do something with
check out branch merge they just take
one so I want to merge in issue 53 so it
does a calculation it says is the commit
I'm merging into reachable from the one
I'm merging in because if so what I want
to end up with like if you think about
this I added a new file as you see and
then I modified it right if I merge in
that context what do I want my master
branch to look like then what's that
yeah issues you want it to look like
issue 53 like that same snapshot right
it's not going to be any different so
what it does is the easiest possible
thing which is called it fast forward it
just takes that pointer and moves it up
it doesn't create a new data in the
database because it doesn't need any new
any new snapshots that makes sense now
if I say get merge I teen and at this
point they are not in there one is not
reachable from the other right and so
it's not going it's going to do a non
fast-forward merge it has to create a
new tree it has to create a tree that
has issue dot C and ihn C in it right
that's what I want I want both of those
contacts together so I need a new tree
so what get will do is it will walk
through the histories find the first
common best merge base some commit it
can use as a merge base and it will use
that in a three-way merge to as the
merge base so if it if it needs to
figure out something so in this case it
can see just by looking at these hello
dot C is different right and so if it
doesn't have a merge base it would have
to try and merge them together but in
this case we can go down to the merge
base we can see hello dot C is the same
on one side as it is in the merge base
so it didn't care about that file so all
it does is choose this side it chooses
the side that changed right it will only
make you try and resolve conflicts
it will only possibly have conflicts if
the file changed on both sides of the
branching and so it just takes the two
new files because there's no conflict
there slaps them in their shape chooses
the one side and you have no merge merge
problems not even the possibility of
merge problems in this is true
you'll merge right and you didn't have
to calculate the merge base or anything
like that it does all of that for you
and will continuously do that for you so
it's very nice and then moves master up
and now masters there and we can go back
to any of our older contexts if we want
to okay so that's merging that's how
merge merging works if you do get a
merge conflict which is both sides of
the merge changed the same file in the
same hunk right and so it cannot merge
it together you can have well so what it
will do is it will put in merge conflict
markers and it will stop will not do
that final commit for you and create
that commit data with the new tree it
will stop and you can run git status and
see what files are still unmerged right
or if you add the same name file to both
sides it will do this and give you a and
B and you have to manually merge them
together if you open up the file it just
gives you some version merge conflict
markers just sort of standard ones that
way you can run if you say git merge
tool it will open up a visual merge tool
if you want to use a Raxus or k23 or
emerge or VI MD for perforce or anything
like that right it will any of those
will work to help you solve these
conflicts if you want to or you can just
go in and do them by hand oh really oh
you guys are going to be here what I'm
just kidding
okay so when you're when you finish the
the conflict when you when you've solved
the conflict the way you mark it as
resolved is again you run git add
because what you're saying is I want the
content as it looks like right now to go
in my next commit which is going to be
the merge commit right so you use git
add for resolving as well get add is
used all over the place but really it
has the same semantic context which is I
want it what it looks like right now to
be in my next commit yes okay and then
merge tool will fire up any of these kf3
to get if blah blah blah there's a whole
bunch of them and and allow you to do it
through a graphical context if you want
to and then at the end you run get
commit to finalize the merge commit the
merge right so it's a little bit it's
not super intuitive unfortunately but
it's not difficult to do right so run
run get status to see what's left
you can also there's also other cool
things you can say git log and then one
of the the conflicted files and it will
show you the commits that modified that
file in the two sides the two commits
introduce the changes that are now
conflicting which is actually kind of
cool yes nope if you if there's no
conflict it will automatically do the
commit you can say get merged - - no
commit and it will stop it will just do
the merge of any kind and it will stop
before it so you can modify stuff or
change the message or something because
it doesn't auto generate a message for
the merge commit yeah yeah if you say
git commit and then like a message and
then a list of file names or one file
name it will automatically add those and
then commit them but it's fairly rare to
do that unless you did a lot in
subversion and it's just carried over
yeah you can do git commit dash a and
that will automatically stay or you can
say git add - capital a that will add
like every file that it sees or get add
- lowercase you will do what commit - a
would do but then not actually do the
commit it's just to add portion of that
so there are get add has some options to
make some of the things easier there's a
ton of options I just you know it the
important point is that there's three
different sections there's your working
directory which git commit doesn't
normally care about your index your
staging area that you have to stage
stuff in with get add and then get
commit looks at that and then head moves
to whatever you did when you want get
commit right head updates as you do that
okay so reintegration merge is already
already sort of talked about this but we
can easily go back to one of our
branches commit to that branch and then
go back to master and merge it again and
the reason why it's easy to do
reintegration merges is because we don't
have to figure out the merge base again
it's not a complex operation right since
we you can see the merge commit keeps
pointers to both parents that it merged
together when we go and try and find a
good merge base it can follow both
pointers right the same commit is still
a common commit right the first commit
is still a common commit like it was in
last merge but also a common commit is
three ACD one over here right so it sees
that as a better candidate and it uses
that as the merge base and so when it's
merging it doesn't have to go all the
way back it just simply sees what the
difference is since the last merge and
it it it uses that right so you can
continuously merge in from branches and
it will try to figure out the best merge
base to do with that and it's generally
fairly simple okay so some of the
reasons why I think branching is cool
just real fast I kind of went over them
already but the the reintegration merge
thing is really cool
well but you can use it in several
different ways right you can use it to
try out an idea you can create a branch
work on it and then if it doesn't work
out go back to master and just delete
the branch right it's very easy to do
that or you can isolate working it so
you can have a branch for every ticket
that you work if you're working in
Bugzilla or something a branch issue 53
issues 86 issue 102 and switch back and
forth them as you're working on them in
parallel right or leave one there for a
week or two and then come back to it and
update it and start working on it again
it's very easy to do that right so
isolating your work units is nice
instead of doing like feature flag
development right where you're like
don't turn this functionality on until I
want it to go live or something like
that right what you do is you keep it in
a branch and maybe you keep it updated
with the master branch and then when
you're ready you simply merge it in the
master branch and does it fast forward
right if you yeah and then the final
thing you can do is long-running topics
so all of these things which are really
very different things are all managed by
very simple system which is create a
branch with a certain name check out the
branch back and forth merge the branch
right there's no complicated options to
these that you need to use right they're
all very very simple deleting branches
you can say branch dash D and with lower
case D it's safe it it walks the history
make sure that that branch is in the
history is reachable from where your
current head is and if it is it will
just remove the pointer if it's not then
that means it might have unique work on
it so it will not delete it by default
so there's a safety mechanism in lower
case D if you just want to get rid of it
if it was a bad idea and you're like if
anybody in my company sees this I'll be
fired because that was really stupid
you just hit - capital D it will remove
the point of the data will still be in
your database but it's not reachable by
anything so it'd be very difficult for
someone else to see it's not going to be
pushed ever right
okay so pushing so this is the the last
section this is remote so now all of the
stuff that we've done except for clone
so far has been entirely local all of
these things are you could perfectly do
them without ever hitting the network at
all without even having an Ethernet card
in your who uses a thern anymore that
having a wireless card on your computer
so it does not have the concept of a
server right it does not have the
concept of a central server what it has
is the concept of remotes which are here
are URLs of
any kind to other databases other nodes
of this project that I know about and it
doesn't actually necessarily need to
even be of that project you could have a
point to any any other git repository
though that gets kind of weird so don't
do it but you can basically say here's
another URL that is of this project it's
some meaningful node it can be my
friend's computer so I can fetch from
his stuff right if I just want to fetch
directly from them it can be you know a
bunch of different people you're working
with whatever you don't have to have any
or you can have 100 it doesn't really
matter
give me the staging server it can be you
push to deploy whatever so the concept
of that is a remote and it's really just
an alias for a URL so if you clone so
let's say we have a git repository on
our server on our company server
somewhere and it has two commits and a
master branch when you clone you get the
database you get all the same objects
that the database hat that that database
has you get it locally and you get two
things one is you get all of the
branches on the server so in this case
they have master so we get origin slash
master when you do a clone it creates a
remote for you automatically called
origin by default you can name it
something different you can delete it
immediately if you want to it doesn't
really matter but it gives you a point
of this is where you got this data from
initially if you did a clone if you do
in an it you will not have an Origin if
you did a clone you'll have an Origin
slash and then every branch right origin
slash Master origin slash this that's
how it namespaces it so that your
branches don't interfere with those
branches which was a earlier question
right all of the branches on that server
Origin slash whatever if I add NIC
individual as a friend and I just want
to see what he's working on I can add
him as a remote if I have read access to
his repository
okay I'm Adam has a remote named Nick
run fetch and then I have Nick slash
master right and so I can see the
difference between my master Nick /
master Origin / master okay so that's
what ordered slash master and then
usually it will give you a branch by
default that you can start working in so
usually it's named after whatever the
the head on the server is you designate
one of the server has a head as well
that is the main branch of that server
so you get you get an equivalent of it
now Scott clones the same thing it's
exactly the same thing so now there's
three versions of this database sitting
around now if I commit I create some
awesome feet
it just goes into my database I've done
two commits here right Nik does a couple
of commits adds his awesome feature
right we're all working on the master
our own master branches and I can see if
I do a diff or if I do a log like what's
the difference between origin master and
master I can see just my two commits
right what have I done since I can
compare those branches now git push is
how you share changes with a system with
with another server and what it means is
if you say git push origin master what
it says is its git push and then a
server or an alien' you can put the
whole URL again if you wanted to but
it's usually it's easier if you have an
alias just write the alias name and then
what branch you want to update on that
system so in this case what this is
going to try to do is communicate with
the server and say I want the master
branch on the origin server to be the
exact same as the master branch on my
server or on in my database I want them
to point to the exact same place that's
all it does it does not do merges on the
server at all it does not do any if you
modify a file and Nik modifies a file
and you both try and push but they're
different files it will stop the second
pusher right it will not try and do any
work on the system all it does is this
contacts this server and says I want to
make your branch name this my branch
name this if you want it to be different
you can do a colon I want my master
branch to be master colon
you know Scott I will make my master
branch a branch name Scott trying to
update a branch name Scott on the system
so the conversation goes like this I
want to push some stuff service says
here are the list of the branches I have
and what they point to your client walks
through the history of what you're
trying to push and says cool I can see
that so it would be a fast-forward merge
if I were to try and merge it so since I
can see it in my history I will I will
update it on this on the server so it
takes the difference just transfers the
difference once that's in place and
everything's good it moves the pointer
so now the master branch on the server
is pointing at the exact same commit as
the master branch locally that is all
push will ever do ok so when it gets
more complicated is now when Nick tries
to push he wants to get his changes up
there as well so the conversation goes
like this is the same conversation
basically Nick says I want to push some
stuff
says I've got master at 9005 Nick walks
through his whole history reaches every
commit he has in his whole history of
what he's trying to push up and does not
see that right it's not that it's not in
his database maybe it's in his database
but he's abandoned it or rebased or you
know rewritten history or something it's
that he cannot see it in the history of
the branch he's pushing up if he walks
all the parents and so since he can't
see it if he were to update it what
would it do right if he were to push if
we were to force this push what it would
do is it would make master on the server
point two eight zero nine one it would
effectively abandon they would do a non
fast-forward it would it would do a
branch change right it would just switch
the master branch on the server over to
something different it would abandon
those objects on the system and then
when Scott fetched it would look weird
right because it wouldn't have his old
data in it so so since that would be
mean technically you can do that but
don't do it since that would be mean
your client will refuse to do it right
it will say your push is rejected and
don't take that personally it has
nothing to do with you as a person it
just says if you were to do it you vo
you would be abandoning you would be
abandoning people's changes on the
server so what you have to do is this
you have to fetch down see so now Nick
will say git fetch pull down the
difference and now I have origin slash
master at the same point that the master
branch and the origin is and then I can
merge them like I can merge any other
branch right so I say get merge origin
slash Master origin slash whatever and
that will merge that branch in and now
when I push right if I do the same thing
get push origin master all right I want
to do it again well I have I haven't
changed right masters at 9005 awesome I
can see that somewhere in the history of
what I'm trying to update and so it puts
the difference up and then moves the
branch and then that way by rejecting
things that that you know aren't
contained in what you're pushing it it
makes you not overwrite stuff without
having it be very complex on this on the
server right the server logic is very
very simple so that's out that's how
pushing works now if you want to push
another branch if I had some other
branch over here issue 53 that had gone
off in a different direction and I want
to work with Nick on this branch but I
don't want to commit it to master right
I don't want to be working on master to
collaborate
want to work with Nick on a different
branch it doesn't matter master is not
special in any way so I can just as
easily push that branch up as well so I
just say get push origin it should 53 I
want what I want a branch name the issue
53 on the server that is pointing
exactly where mine is which is the same
thing you would do if you push an
existing branch to update a branch right
saying I want to master branch that
points out wherever my master branch is
if it exists it does the check if it
doesn't it simply says you're all the
branches I have I don't see the branch
I'm trying to push so I'm not going to
be losing anything so I'll just do it
right the server will simply accept it
and so it just copies the difference
creates a new branch on the server and
now when Nick fetches he will get all of
the branches on the server by default
that's what clone will set up a fetch
spec that looks like just give me
everything on the server when you do a
fetch and now I have origin /e 253 so
now Nick if you wanted to work with me
on it could create a branch there start
working on it
get pushes you 53i fetch down and merge
it in with mine you know work on it you
push as you're 53 and so we can we can
just work on that and ignore master if
we wanted to do that does that make
sense
okay so that's how it works pull
if anybody's use pull is a wrapper
script it simply does it get can have
this context of where this this concept
of what are called tracking branches
which is a mapping between a local
branch and a branch on a specific server
so when you're on that branch and you
say get pull what it will do is do the
fetch of that branch from that server
pull it down and then automatically try
and merge it in so this this this makes
it a little bit easier if you're working
if you're always working on the master
branch this simplifies things because if
you do a push and it says rejected you
say pull it will fetch down merge it and
then you say push again immediately
right or fix any problems that there
were all the merges happen locally but
this makes it easier if you have lots of
branches that you're working on this can
often confuse people because generally
get when you do a push it will not set
up that branch to track so when you do a
pull and you're on a branch that is not
tracking it will say it'll it will do a
fetch and give you the normal fetch
output and then blow up with like this
huge thing that's like I don't know
what's happening I don't know what to
merge in and what to do and it has like
these huge thing it's like you're fetch
spec is often there's sideband errors
and de-multiplexing you're like what the
fuck is happening so
so what'd you do what I like to do is
not deal with that just not not worry
about tracking branches it's usually
easier to do what I say to just do the
fetch do the merge make sure that you're
on the right branch and merging in the
right branch right take three extra
seconds do it manually and then push it
up again and just deal with push and
fetch and that's it right and do the
merges man because that's your doing
what you're telling it to do it's not
trying to infer stuff right which which
really confuses people a lot of times
unless you are very comfortable with the
concept of tracking branches I would
stay away from get pull but all it is is
affection emergent okay so I want to get
to one more thing I think I've done the
remotes enough so I'm going to do the
fastest version of this I've ever done
so if we have two files one commit will
have four objects right the two contents
one tree the one commit so that's we
have if I push it to a server I can push
it to my own server that I have right
access to but I it's public I give given
everybody read access to right and then
I want to work with people on its own it
clones it gets the same object Jessica
clones it because the same objects does
it commit they both push to theirs that
has the same property everybody can read
it but only they can write to it right
and then they email me and say here's
the URL that has feature a I can add in
as a remote I can add just as a remote I
can fetch Nick pulls down his stuff I
get Nick slash master I can fetch Jess
pull down her stuff I get Jess slash
master I can merge them all together to
update my master and push up and then
they can fetch from that to get each
other's work and that will scale out to
thousands of developers right this is
sort of how the Linux kernel does it
where you don't deal with ten thousand
developers you deal with your sub
project right and everybody you have
write access to yours and read access to
everybody else's and you can have this
sort of hierarchy right this distributed
system so this is this is how github
works right this is there's a forking
thing where you fork it you get your own
writable thing it's very uncommon to
have like commit bits in projects where
you're saying you're the core team that
can commit to this open source project
because what is far more often is you
have one or two maintainer x' and then
they just have trusted people that they
pull from all the time and don't really
check the the merges as much because
they're trusted right that is a commit
bit is tis for the maintainer to trust
them so that's where all the objects
have been okay so that's multiple
remotes so the last thing I want to do
get logged get log walks your
in history so you can actually look at
this history so when you saw before I
did this get lol that is an alias and
I'll show you what that does right now
so if you say git log what it will
assume it's exactly the same as get log
head right it assumes this is my
starting point and I'm going to walk the
history show you every commit I can
reach from head down so it walks it
master it head puts master master points
this so I'm going to start walking those
these are all the commits that are
reachable so I'm going to show it to you
in an out in a in a flattened format
like this this is all of the commits
that have that have worked together to
get to this point to have the snapshot
you now have in your working directory
and you can see all of the data right
side a side B it just flattens them
together and then for each one it has
the full committee sha the author the
date and the message you can also format
this though and this is really
interesting for doing things like change
logs like not change logs that you put
in a thing generally but like what is
the difference between these two
branches in it in the most simple format
so you can say - - one line it'll give
you the same data but just much simpler
right not all of the metadata just
here's all the first lines of all the
commit messages you can say you can give
it a different starting point one line
is your 53 what are all the commits on
issue 53
here's the three here their commit
messages here's a different starting
point you can say - - graph this is a
cute way of seeing a graph in ascii on a
command line most of you will be using a
GUI probably and it will just show you
this in GUI form actually most of this
will just you can do on the GUI but if
you're using the command line there's
some cool stuff you can do with this but
the important part bla bla bla all and
decorate so these this is what you're
seeing when I say lol is it's running
one line graph decorate right and so I
get I get this sort of nice thing so I
don't have to fire up a GUI every time I
want to see what the graph looks like
and then it has here's a world my
pointers are so this is what I have set
up you can set up aliases if you're
finding like like I was saying no F F or
F F only for merges if you want to set
that up as a thing that you do all the
time you can set up an alias where you
say get FF merge and you have it expand
to merge - - FF only or something or if
you have something really long like this
you don't want to type out every time
you can set up an alias fairly easily
and run that okay so this is the last
thing this is very important because
it's fairly difficult to learn unless
you like read a book or come to a talk
and I'm usually the only person talking
about the story of stuff but log subsets
so because it's a graph you can do graph
operations on it right which are
interesting which are meaningful so if
you do this some of you will see this as
branch B dot dot branch a that's another
way of doing this exact same thing I
like this because you can put multiple
arguments on the command line and it's
it's easier for my brand of parts but
what this means is show me every commit
reachable by branch a that is not
reachable by branch B right and so what
that is is the the difference it's the
reach ability difference between the two
what does every commit that's reachable
from one that has been merged into one
that has not been merged in together and
so you can do stuff like this right what
is what is in issue 53 that's not yet in
i18n that I have not merged into i18n
right so you can say here's issue 53
everything reachable here's i-10
everything reachable that's the
difference that is what is unique to
issue 53 relative to i18n right does
that make sense so now well if you say
get log it will just show you those two
so that gives you a nice difference
right so what is in my topic branch that
I haven't merged into master you'll want
to ask this all the time here's a whole
bunch of branches I have what is unique
to them is there anything unique to them
can I just delete them without losing
any data right so you can say what's in
ie10 that's not a master here's
everything reachable by 18n there's
everything reachable by master that's
the difference this is the one commit
that's unique to the branch if I were
deleted that is the commit I would lose
right if I were to merge it that's the
commit that would come in so that's
interesting right because that is what
that branch represents I'm surprised
more gooeys don't make it easy to do
this because it's the most useful thing
and get to me right what does this
branch mean so here's a quiz and if you
are a large or an extra-large I have a
t-shirt for you that is this beautiful
t-shirt right here so I'm going to do
extra large first so only extra-large
people can answer this
what does this do this is effectively
get incoming right if you do a fetch and
then you run this you have to do the
fetch because it because the log will
not look at a remote but if you do a
fashion then you run this this will show
you the equivalent of get incoming right
what is on the master branch I just
pulled down I have not merged into my
own master branch yet or whatever
branches you're interested in but this
is incoming what is on what is on the
server that I just sink down that I do
not have in my working context right now
now only large people can answer this
really way in the back what's up what
take somebody else now no wait can you
what's the what would what would what
question would you answer perfect oh now
this get outgoing right these are all of
the commits that you've committed that
you have not pushed to the server yet
because this does not update until you
can't check out origin/master it will
not allow you to do it because the point
of it is so that you know where these
branches are on these on these remotes
so this is outgoing if I run git push
this is this will this is what will go
up this is what I will share with people
right now if you merge origin/master
into master this will cease to give you
output but this still will right it will
give you the exact same output even
though you merged in origin master into
it because it's still these commits are
still not in origin master this ceases
to give you output when you do the push
does that make sense but the same thing
can be applied to any branches in your
system what is in this branch that's not
in this branch what are what is the sum
total of all of the unique commits
across these three branches that are not
in either of these two branches right
you can do not this not that it works
just fine yeah no none of these run
nothing that log does goes over the
network
this is cached this is after fetch yes
it does it doesn't log so whatever log
output looks like normally it just
restricts the output of the log to just
this set so it can so that's a lot those
are log options so if you say get log it
gives you the log if you say
I get log - P it will give you the the
patch introduced in each one if you say
log - - stat it will give you the files
change you can see public index on that
second one and you can also do no merges
so here's the index was changed their
index machine this is not really that
helpful
so if for each commit I can see what
files are changed and how what's the
sort of general change was and if I want
to see the actual patch I can do - P but
any of these restores the actual patch
right so any of these restrictions any
of the this branch not this branch take
all of these options so I can see
basically a list of patches that I
haven't pushed yet if I say log master
not origin master - P right that's a
list of patches and vice versa okay so
that's it these are the commands that I
introduced not really going to go over
them because I've gone far enough but
these are all the Distaso that I've did
twelve commands right this is not this
is not ridiculous right this twelve
verbs this does 99% of everything you're
probably ever going to do and get does
your day-to-day workflow and there's a
couple options to some of these in get
reffed org will tell you what the useful
ones that I think are useful are
including this this branch not this
branch syntax if you want to review any
of them but that's it that's that's
basic kit so those twelve commands so
I'll take questions they're stickers
here and thank you very much
yeah so the question is get pulls down
snapshots now Delta so do you have to
deal with a lot of branches you don't
want to deal with so sort of if you say
get branch I mean it depends on your UI
right so I use the command line most of
the time it depends on your UI your all
of the sorry about that here all of the
the branches I'm currently working on I
can delete them whatever if I say remote
or branch - RI get all of them right so
here all of the ones on the server as
well so that can be sort of overwhelming
but generally I don't look I don't like
look through them right so I know the
context that I need to be interested in
to work on whatever I'm working on it
tends to be fairly easy to parts them as
far as like space things with snapshots
not deltas it actually does pull down a
pack file that's all Delta fied and so
it pulls down gene general much faster
and much less than subversion does even
clones are I've seen a clone of a
similar project take more time in
subversion with a checkout where you're
just getting the last version because
it's so over HTTP because it's so bad
versus git which is very very efficient
at it yeah so the comment so there's a
multi-part question how do I convince my
boss to use it if we're not and how do I
so it depends on your boss right how you
convince them and how big your team is
and stuff so though what are the
objections that used to be GUI support
the use did not be very good GUI support
for it if you're a Java developer and
using eclipse get gooey or egit plug-in
will be shipping with indigo I think
will be actually shipping with indigo
and it is very good now it was not very
good a year ago so egit yeah eclipse get
the eclipse get plugin but so GUI
support is getting a lot better there's
gooeys for macs that are nice that you
can pay for there's a number of them
there's gooeys for Windows there's shell
extensions and stuff so what's that idea
for almost all IntelliJ IDEA a lot of
the IDE s have good plugins now so that
that is becoming less so that was more a
year ago how you convinced them I don't
know I put up a website called why git
is better than XCOM where I I summarized
the sort of high end stuff it's not it's
not
here's fair on site a and fair inside B
it's very biased towards get but it's a
good summary right these are the these
are the arguments so there
that or you can sometimes it works to
list out companies that are using it so
like Android is using it right so if
Android can do it in a company that big
din and so Motorola and Qualcomm and all
these companies using it because they
are and they're seeing clearcase
actually sucks why are we doing this and
paying money for it so a lot of them are
switching over to get so sometimes that
works it really depends yeah yes so so
can you use SVN with or can use git as a
SVN client I think it's sort of the the
question and there is for more data or
for more information on this there is
get another system so there's a get in
subversion section on here but there's a
tool that comes with it's actually a
really good bridge called get SVN I mean
compared to SVN SCM bridges go it's it's
one of the best ones which is not I mean
it still has to work with subversion so
it still has the limitations of
subversion this this points out a lot of
problems you can run into but basically
you say you know get SVN clone or check
get us me and check out I think and then
it pulls it down you say get s VND
commit and it will commit to the
subversion server but you can do all
your local stuff and get I think that
was it so if you have any other
questions come up I'll still be here for
a couple minutes so thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>