<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript: Choose Your Own Adventure! | Coder Coacher - Coaching Coders</title><meta content="JavaScript: Choose Your Own Adventure! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript: Choose Your Own Adventure!</b></h2><h5 class="post__date">2014-08-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/__8eIX0QFXU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well well
back from lunch I know that I get the
speaking to you while you're in your
food coma so I appreciate you showing up
Kyle Simpson known as getify online
thanks for being here and today we are
going to go through a little bit of
heresy we are going to talk about
ditching the JavaScript standard and
making your own JavaScript and that's
going to be quite controversial but
we're gonna jump into that in just a
moment
real briefly if my clicker will come on
real briefly I'm going to talk to you
about this book series that I've been
writing it's you don't know Jay s and
it's a series of books this is the first
in the series there'll be five total
this one's on scope and closures the
second one has just come out that's on
this and object prototypes and all of
them are available for free that I'm
writing up online that you don't know
Jay Escom so you can check them out
there and then if they're useful you can
purchase them that would be useful I
have about 10 of these up here at the
podium so afterwards the first 10 people
that come and ask can get one for free
and then I am also doing a workshop
tomorrow those of you that are attending
my workshop there is a slim chance that
the shipment of the newest book will be
in for those of you attending the
workshop so we'll see about that no
promises okay so we are going to jump
right in with this javascript
choose-your-own-adventure and hopefully
those of you many of you have sort of
that recollection of those choose your
own adventure books I certainly love
those so I just thought to be sort of
silly to start this off I would go
through a simple little
choose-your-own-adventure so you are
Brendan Eich employed at Netscape in May
of 1995 and your boss asks you to design
a new language for the browser but gives
you only ten days to complete it choose
your next adventure to agree and give it
your best shot
turn to page 39 to laugh and walk away
turn to page 262 many of us maybe hope
that he had walked away and turned to
page 262 but in fact we see that Brendan
did go ahead and give it his best shot
it was a proof of concept so I just want
to remind you of something that Brendan
Eich has said I probably should have put
this on a slide but a very famous quote
that he has about there is that he he
said JavaScript had to look like Java
only less so be Chavez Duncan
brother or boy hostage sidekick and
worse it had to be done in ten days or
something worse than javascript would
have happened and that last phrase is
sort of instructive so the next time you
find yourself wanting to complain about
the language think about what it would
have been had he chosen to go to page
262 all right let's try another one
let's put ourselves in the place of here
you you have learned the ins and outs of
JavaScript but there are lots of things
that are still bugging you for example
the fact that empty array is equal to
the negation of empty array and it's
just too bearable to go on you can't
handle it anymore so choose your next
adventure to give up on JavaScript and
move on to the language go turn to page
nan otherwise to explore your own custom
JavaScript
turn to page 2.01 e to the second okay
so enough of the silliness but seriously
I am suggesting that I think it's time
for us to at least consider the idea
that standards aren't the thing we
should be pushing for there has been a
lot of effort and I don't demean any in
any way shape or form the people that
have been on all the standards
committees and all the efforts to
standardize our technology the Wild West
that we used to have that I I was
definitely a party to was not good so
I'm glad that we have had some
convergence but I think it might be a
natural and healthy time for us to
explore this idea that maybe we need
less standards and maybe we need better
tools so the heresy today is going to
suggest something along those lines I'm
going to start out with something very
simple I'm going to invoke one of the
most common religious battles that
everyone has probably faced the Battle
of spaces versus tabs and if you
download this slide set you will see
that in one inside there is spaces and
in one side there's a tab and I'll let
you decide from looking at my github
account which one I choose but this
religious battle about spaces versus
tabs and and some people say there's
only one answer and some people say well
it's just sort of a stylistic choice
what about semicolons versus non
semicolons that's a big religious battle
now just as a little bit of a side note
let's understand what is happening with
semicolons semicolons are being
automatically inserted in JavaScript
when you omit them in places that they
are required by the grammar in a say
asi is an error correction routine so I
have this to say to those of you that
are so fond of dropping all of the
semicolons from your code essentially
what that tells me is you want to write
the most error-prone program possible
that still correctly compiles in the
JavaScript engine I prefer to write
correct programs and not try to stray as
far from correctness as possible but
that's just my take on semicolons but
what about these sorts of debates
because they divide teams and they
divide industries and I want to pose
this question what if your team did not
have to agree on such things what if it
was possible to use tools to solve this
problem and you could go on happily
about your day writing spaces and the
guy next to you can write tabs and then
the lady sitting next to you can decide
to do semicolons and the person next to
her can decide not to do semicolons and
all of you can collaborate on the exact
same codebase what if that was possible
would that be better than the arguments
that we currently have about these
things and I think yes so I've said
about this this this task to create a
tool that I call Ezra I haven't actually
written any code yet because I got
derailed by the fact that unfortunately
there were some some problems with the
standardized AB syntax tree when you you
know when you parse code and it wasn't
keeping certain certain sorts of things
so we're still working through that
problem but the idea the plan for this
tool is that it's configurable two-way
code formatting so there is one
agreed-upon standard that you check in
to the repo and when you check out code
from the repo you'll your configured
Styles transform the code before it
shows up in your editor to your
preferred styles removing semicolons
changing spaces two tabs whatever you
feel and then when you're done writing
code and you save it back instead of may
get a linter complain at you and say oh
you did the wrong thing why not just
have the tool fix it
smarter tools make for better developers
when you run into a problem in your
development process and the language and
the team culture and things like that
are the things that are getting in your
way that's a sure sign you need a better
tool so this is just a crazy harebrained
idea there are style checkers out there
but all they do is just complain when
you don't adhere to some particular
style
I've never understood why they don't
just fix those problems but my
suggestions here actually go much
further than code styles how many of you
have ever seen this movie anyone
recognized a frame from this movie it's
an old old-school movie the name of the
movie was 12 Angry Men about a bunch of
guys in this room deliberating over some
murder trial or as I like to call it the
tc39 committee meetings I'm it's a total
joke I've never been to one but I know
that they deal with lots and lots of
problems and they're always arguing back
and forth about stuff and I see their
notes afterwards and so I just imagine
in my mind that they're that they're
getting together and sort of trying to
agree upon these things now I tweeted
out this slide as a joke some time back
and actually one of the main maintained
errs of the spec tweeted me back and he
claimed that he was definitely the guy
in the in the pinstripe suit so that's
Alan wharfs Brock in the pinstripe suit
there in the corner but what if you
could customize the JavaScript language
itself to your own liking what if it
wasn't just about code Styles but the
actual structure of the code that you
write could be made to conform more to
the way you like to think about things
in the way that your brain likes to
write code because I'm willing to bet
that many of us have idiosyncrasies that
are different about the way we approach
than some other member of our team and
rather than focusing so much on trying
to train away all of those differences
what if we embrace those differences and
let tools smooth over the problem the
first idea that I'm going to suggest
along these lines is called sweet Jas if
you haven't heard about sweet Jas it's a
set of JavaScript macros it's a system
for JavaScript macros that was proposed
a few years ago and it's so awesome that
Mozilla decided to adopt the project and
get behind it officially and it's even
more awesome that the tc39 committee has
all but basically said pretty sure that
an es Evan ESA time range somewhere and
their macros are going to show up in the
language so whether you like macros or
not it's a fact that it's coming and
that grows can solve a lot of problems
for us I want to show you just a couple
of quick examples of the sweet Jas
macros and I'm not going to fully
explain all of their syntax you can go
to the suite JSTOR website if you'd like
to understand a little bit more about
how they do what they do but I
just wanted to kind of show you a quick
example of how they you could decide as
a team to fix certain parts of the
language to work in a different way and
everybody can sort of agree on that so
as an example if we have the the
time-honored task of taking two
variables and swapping their values and
we didn't want to declare the temporary
variables and do all of that junk of
course by the way es6 has an answer for
this it's called destructuring but
setting that one aside for just a minute
if you wanted to solve this problem of
swapping we can declare a macro as you
see here and that NGO called swap and it
takes the two variables and it assigns
them an it uses a temporary variable
inside now it creates this in such a way
when it rains pour code to run in the
engine it creates this in such a way
that it's totally safe that variable is
renamed to something unique that won't
collide with any other variables in the
program and it works exactly the way you
want but the main key is down here on
line 13 you don't have to worry about
those implementation details whenever
you need to swap two values to just
simply call swamp macros are very
powerful and important in a lot of other
programming languages many would argue
that it's been sort of an omission that
javascript hasn't had something like
this for a while I'm very excited about
the fact I've got a lot of learning to
do because I don't fully understand the
syntax yet but I'm very excited about
the fact that we're going to get macros
in the language another slightly more
complex example but one that I've run
into many times I want you to look down
here it's a little bit hard for you to
read but look down here at the bottom
have any of you ever done in your coding
needing to test for something X and X
dot y and x dot y dot Z and we can't
just do that third test because if X or
Y are undefined or null then that
property object access is going to throw
an error so we end up having to do all
three of those checks and it's
ridiculous and we we pollute our code
with all kinds of ridiculous snake thing
like that we can create a macro called
nullity this is directly from their site
so I didn't even make this up it's a
great example but nobody allows you to
specify that I want to know a nullity
check x y&amp;amp;z and it will split out
however many levels of object property
axis you have there because it uses
itself you know it uses a loop in here
so it will split those things out and do
the checks for you and all you need to
do is write what you see down here on
line 29 you just write the nullity
sorry I don't want that advance so
quickly you just write the nullity like
you see on line 20 and then it does that
check for you so macros are a very
powerful solution to many of our
frustrating issues with coding and
basically what I'm suggesting here is
there are things that we hope some day
JavaScript will fix for us but we
shouldn't necessarily think that we are
handcuffed by just waiting around until
some magical future time when they get
around to making that a priority and and
even then there may be things that we
want to fix but they really can't fix
them for the entire language for various
reasons macros are a good sort of
pressure release valve for those sorts
of concerns but I want to go even beyond
macros I want to up the heresy even a
little bit more and suggest that for
instance you could decide your own
individual self that there's something
about the code style the code mechanics
that you don't like about the language
and rather than fighting that battle to
sort of convince the tc39 committee and
get somebody to agree to it and the
changes and and how unlikely that sort
of thing is maybe you just need better
tools so let's start with an example one
of my favorite examples block scoping if
you've never done if you never code it
in a language that has block scoping the
main idea here is to be able to declare
it a variable inside of a block as close
as possible to where the variable is
going to be used if you know how
variable scoping works in the rest of
JavaScript it hoists to the top of the
function which is fine but oftentimes we
do things like for VAR I because we want
the eye to be long only to the for loop
and we've only had the ability to sort
of stylistically suggest that up until
now but coming as of es6 we're getting
this capability to swap out our var
declarations in certain places with a
let declaration it's sort of a cousin to
the var keyword but it will hijack
whatever existing block that happens to
be in and attach the variable only there
so in this case a will not be available
outside of the loop so not only can we
stylistically signal block scoping like
this variable belongs to this small part
of our code but it will enforce it with
an error if somebody tried to use that
variable in error outside they would
actually get an early error of the code
would throw an error when running your
program so there's a lot of value I
think to block scoping however
I've played around with block scoping
over the last couple of years sort of
seeing the syntax and things like that I
have been bothered by one particular
thing and that is the implicit nature of
the hijacking of block scoping I tend to
prefer more explicit structures in my
code I tend to prefer creating an
explicit block that I'm going to declare
some variables for so let's take a look
at an example of why this can sometimes
be a problem here I have an if statement
with several let declarations in them
and by the way as a side note let
declarations don't waste to the top of
the block so if you put them in the
middle of the block and you accidentally
reference them before you've put them
you're gonna get an error unlike
variables in JavaScript the VAR
declarations which do hoist Lutz will
not so you do have some extra mental
tacks here and you also have some
refactoring tax if you decided to take
the if statement from line six through
eight and move it out as I often do now
you have to worry about the fact that
you have variables that you're gonna
have to bring along because they've been
implicitly hijacked by another block so
you have to be careful about these sorts
of things it's not that you can't write
code like this but it will create extra
mental taxes you refactor your code
perhaps all of you write perfect code
the first time but I usually will write
one piece of code and wrap an if
statement around that and a for loop
around that and a try-catch around that
and then move some stuff around and
eventually accidentally my code starts
working correctly and for me I'm a
little bit worried that there will be
some extra mental tags so wouldn't it be
nice if we could get the benefits of
block scoping with a more explicit
structure it turns out there is such a
structure as you see here on line 3 the
form the let block form allows us to
create an explicit block where we bind
variables specifically to that block
rather than hijacking another one now
there's some people that hate the extra
indentation indentation to me isn't that
big of a deal what I like about this is
that there's an explicit block for me to
reason about and I don't have to
separately reason about block scoping
along with the other behavior of that
block like an if statement so I have
these two nested let blocks and if I
were to do my refactoring those are sort
of like visual clues to me that I block
some scope that I need to worry about
and pay attention to rather than
searching through hundreds of lines of
code for this tiny little let keywords
so I think this is a superior syntax
gives you the same capability but it's
more explicit and unfortunately in all
of their wisdom the es6 committee
decided to reject that syntax from es6
they preferred the other one the more
implicit syntax and this bummed me out
for a while but then I got to realizing
we can just fix that with better tools
so what exactly is it that I'm
suggesting here is it democracy anarchy
Oleg our key whatever that is heresy yes
all of the above I am suggesting that
you just say to hell with the standards
and create tools that let you write code
that doesn't get in your way that
empowers you to write better code more
quickly I've come up with a list of
these ideas of things that I've run into
in JavaScript that I don't like the
mechanics of how the language works and
I decided to sort of put them underneath
this this code name of foil script I was
eventually going to write a language
called foil script now it's just a list
of things that I want to create tools to
fix about JavaScript so you might start
to wonder well how on earth would I go
about writing such a tool if you're
suggesting I write these tools how would
I go about writing such a tool myself
from scratch if you've ever done
anything I'm sort of a compiler nerd so
I understand some of these but if you've
ever done anything where you've tried to
parse through a piece of code with
regular expressions and you'll note very
quickly that javascript is not a normal
language that a regular grammar that can
be parsed with regular expressions
because you have stateful things like
strings and you have stateful things
like regular expression literals and
things like that so you can't just
easily put a regular expression around
an arbitrary piece of code so how would
you go about instead of writing a full
compiler how would you go about it and
I've run into this problem over and over
again and I finally realized the real
problem is pre identifying those sets of
stateful literals like the string
literals the line comments the
multi-line comments the regular
expression literals the new template
syntax coming in es6 those are the real
problems if you could pre identify those
in some way and sort of remove them or
set them aside then you could parse
through the code in a much easier
fashion because they're the real
complication here and so I wrote a tool
to do exactly that to parse non-standard
or partial JavaScript and it's called
literal Iser it uses a set
what I call heuristic lexing methods to
go through your code and find those
literals based upon the rules of grammar
and pre identify those split them out
and then give you a set of tokens that
you can parse through yourself in a much
easier fashion so it's done a lot of
that heavy lifting already and I already
am using this in a couple of my tools
remember the block scoping turns out
that we can solve this and I did I wrote
a tool called letter it will parse
through JavaScript code looking only for
this pattern using the explicit let
block syntax that we see here and by the
way I didn't invent that syntax Firefox
invented it over a decade ago I just
think it's a great syntax and it just
hasn't been standardized but maybe
someday it will
so letter goes through and it finds
those things and it transpires your code
much like CoffeeScript or some other
tool would do it transpile is your code
so that it will run in standard browser
engines so you already have build steps
that are doing your minification and
your concatenation and your linting you
just simply insert another step in your
build process that pre-process use your
code and changes it from that code into
something that will work and you wonder
how will it work what does it transpile
here's what it writes you'll notice it's
quite ugly it's forcing a try-catch
condition very little-known fact as of
ES 3 way back in December of 1999 we got
blocked scoping in the language by
virtue of the catch block variables
declared as catch blocks our block scope
- the catch block which means I can
force a try-catch condition and get
actual true block scoping today in all
JavaScript browsers and all engines now
you'd never write that sort of code
that's madness but you'd also never
write the code that comes out of the
CoffeeScript compiler this is compiled
code now some of you may be saying well
what what happens if I don't want to
write that kind of crappy code someday
and I want to target only es6
environments i've already got you fixed
you just simply start passing a - - es6
flag to the tool and it transforms your
let blocks into this totally valid es6
syntax it creates an explicit block and
it puts the let declaration at the top
this is the pattern for the suggestion
of tools that I'm talking about creating
these targeted tools to fix
problems that you have instead of being
always banging your head against the
wall until eventually you decide well
I'm just going to go to a different
language we can make better and smarter
tools and by the way is law it you may
think that this is just some sort of
crazy invention that I came up with this
is the official tool from Google called
tracer compiler it's endorsed by the es6
the tc39 committee as the way for you to
bridge from es5 into es6 and guess what
happens when you use let declarations
they create those try catches it is the
officially endorsed way to do it and the
browser's are already working on making
the performance of trycatch not so high
so that this isn't a penalty in your
code so that's just one example let's
talk about some other examples I won't
show you tools for these things but
let's talk about some other examples of
things I'd like to fix if you've ever
written code like this where you needed
to negate some sort of operator and you
would like it to not require you to put
the the negate symbol with the open with
a parenthesis pair around it perhaps
you've never wondered but I certainly
have why couldn't I just put them in the
gate right in front of the end keyword
why couldn't I just smush the two
together because that's what I really
mean that's semantically what I'm saying
is I want to know if foo is not in bar
and it's sort of this weird grammar
syntax that I have to wrap parenthesis
around it and negate the whole thing so
what if we could write a tool that or
very simply take these unary operators
and smush them together with binary
operators so we have not in not instance
of and not and instead of having to wrap
those parentheses around things I think
it would make my code better I don't
know if you like that syntax but it's
just one of dozens of possible
suggestions that we can make tools to
make the JavaScript work for us here's
another example I actually do this a lot
in my code I don't know whether you do
but I end up having a lot of situations
where I have this optional parameter or
this optional clause on the end of my
turn Aires where it's usually I just put
in a placeholder like undefined or null
because I'm I can't really use the or
guard because I don't want it to
actually be the value of the test
awesome greater than one I want it to be
this value and if it
not possible to assign it I just want
the undefined or the null or whatever
but I got to thinking one day why do I
have to write : undefined all over the
place why couldn't that be an assumed
clause so I could clean up my code and
it turns out you very simply can write a
rewrite rule a transpiration rule that
changes that code into code like this
and the code works exactly the same way
and you'll notice those : none defines
have just been removed from my code but
it will still transpile to put those in
another example slightly more complex
any of you that have ever done any
studying about the this keyword and how
this keyword works I like to think of it
or I like to call it promiscuous this
binding you have a function that is of
this keyword and depending on how that
function is called in various different
scenarios there's up to four different
ways that this keyword can get bound and
it might work in one scenario and then
you pass it as an event handler to
jQuery and all of a sudden you don't
have to write this keyword so the
traditional solution to that is what we
call hard binding the dot bind keyword
that was added on the function prototype
as of es5 so we create these functions
that now are forced to be a particular
this regardless of how they're called
which is a decent solution except I
often find myself somewhere in the
middle between the two I don't want the
fully promiscuous this binding but I do
want the ability to override the hard
binding when I need to use the function
in a different way in other words I want
both the flexibility and the
predictability I don't want to have to
trade off well turns out there's a
pattern for that and it's called soft
binding soft binding essentially creates
a separate or override default this
binding when you don't have any other
binding in play but if you do put in a
more explicit binding it allows you to
override it so it fixes that problem
whether this keyword falls to the window
object but it doesn't prevent you from
overriding it soft binding is of is an
important feature and there is a
proposal to bring something like that
eventually to the language I don't know
if it'll ever happen but you can write a
utility for it which I have I call it
soft bind does exactly what it just said
it allows you to create a function that
will test every time whether or not it's
been the default binding and if so it
provides an alternate default otherwise
it allows you to override so for example
down here this foo
Bijan it's a little small to see but you
can check out the slides later fou obj
here is a soft bound functions and when
I call it normally it uses my override
default in fact when I assign it into
another variable and then call it off of
that object it uses the new one so I'm
able to override that soft binding and
when I pass it into things like set
timeout or jQuery event handlers it uses
the soft binding as the default and
finally it allows me to explicitly
override if I want to so the soft
binding just prevents me from falling
through the window object which is
almost never what you want now I use
this sort of utility in my programs but
you can see it's kind of ugly and clunky
having to create your own thing and
stick it on the function prototype we
could fix this with syntax this is my
own idea using the pound symbol between
an object and a function would signal go
in and make it so that it's soft bound
so that the something function is soft
bound to the awesome object and you use
it exactly the same as you do in the
previous slide about another example
again this is not something I've
invented this is called try catches
where you want to conditionally decide
if you are going to handle an error or
not there are certain types of errors or
certain error conditions that you want
to handle on other ones you want to
allow to continue to propagate out so
this is how we normally do it we put
these if statements inside of our catch
block and then we have this ugly thing
at the bottom where we have to throw we
have to rethread if we haven't chosen to
handle it explicitly through one of the
other clauses that sucks but I didn't
invent this syntax but there's a much
better way of doing it it's called
conditional catch clauses again about a
decade ago Firefox invented this syntax
I just think it's something that our
auto ought to have already been
standardized and maybe someday it will
but it's extremely easy to write a tool
that transforms your code from that into
something that works in the browser I'd
rather write that code than the code on
the previous slide so what this all
comes down to again sort of coming back
to the silliness of it what it all comes
down to is I want you to have JavaScript
but I want you to have it your way
instead of being forced into some her
path that works for the entire global
population of all JavaScript developers
I want to remove the things that are
preventing you from being effective at
your job now at this point there's a
really important question that you
should be asking yourself how on earth
will I possibly collaborate with other
members of my team if everybody picks
their own JavaScript there's no possible
way for me to have all of this stuff you
know in the same repository it'll be
totally an arc you own it no it doesn't
have to be that way in the exact same
mindset is what I talked about with
style checking we can create these rules
that rewrite our code using what I call
in versatile transforms which means that
it can transparently with the same rule
sets we talked about with code Styles it
can transparently rewrite the code to
something that looks the way you want it
to look and when it's checked in it
rewrites it to the standard that will
work in browsers and that everybody's
agreed upon for the repository and it
goes both directions so it allows you to
cooperate with other people you know the
only thing that it doesn't really allow
that very easily is you can't really
pair with somebody who writes a vastly
different style than you but if you've
ever tried to pair with somebody that
writes a vastly different style than you
you've got bigger problems than whether
or not you know the if statement looks a
little weird to them so I don't have a
solution for that but I think in versa
Balaam's can actually work and I've
proven that with some of the tools have
already built
remember this example look at the two
side-by-side all we have to do is decide
when we see this in the repo and you
have that rule turned on in your tool
that when you check it out from the repo
you don't want colon undefined it just
simply takes those out and then the
reverse of that the inverse of that is
whenever you check code in that doesn't
have those if it's not grammatically
correct it just adds them in it's as
simple as that
now the tools can be even smarter they
can allow you to sort of create you know
layers on top of these things or decide
that a group of people want to share the
same set of rules there's all kinds of
possibilities this is research I don't
have fully baked solutions for a lot of
these things but I've already proven in
concept that we can create a subset of
the things that you would want to
rewrite about the language can be done
as inversa betrayus forms which means
that we just need to build the tools to
do it
let me give you some examples of tools
that are already out there that are
gonna aid you in this process you don't
have to invent all of this stuff esprima
an acorn or two very popular javascript
parsers so if you've already pre
identified and removed things from your
code that aren't valid JavaScript like I
talked about with literal Iser then you
can parse the rest of your JavaScript
JavaScript your standard JavaScript
using these tools es code gen goes the
other direction it takes parsed code and
it regenerates code so you can modify
the tree to inject extra stuff put your
extra code styles in put your extra
forms in and then simply pass it into es
code gen an actually generates the
string of code es scope and es levels
are analyzers for your scope for example
if any of you have ever had trouble
where you're trying to figure out your
variables and your VAR self equals this
and all that stuff these are tools that
can go through your code specifically
and understand all the levels of scope
including all the levels of block scope
and they could for instance combine
scopes together if you've declared
something too low in a scope but you
don't need it to necessarily be there
and it can figure out that it's okay to
move it it can change where it's scoped
or the reverse it can put things very
low if they're only being used in one
location
Istanbul great tool for looking at code
coverage it can tell you if there are
places in your code base that aren't
being covered right now by tests you
should be testing everything by the way
let me give you one other side note all
of this heresy about writing your own
JavaScript I want to give you one sort
of caveat here it is not an excuse to
not learn JavaScript and to not
appreciate JavaScript I am NOT
suggesting that this is the right
approach if you just hate JavaScript and
you're banging your head against your
desk every single day and you're not
interested in learning how it works you
do need to understand the language first
but if you invest that time and you run
up against things that are preventing
you from getting your job done I think
these tools can fix those sorts of
problems more tools es traverse it will
analyze your abstract syntax tree the
results of your parsing it will analyze
that allow you to put hooks in and
rewrite things on the fly in a streaming
fashion es lint it's one of the linters
out there there's other ones like Jas
hint of course but es lint
incredibly configurable so you can
actually use es lint to verify your code
as you're running through these parsing
you can even write custom es lint tools
for your non-standard JavaScript finally
Plato and JS complexity org will
actually analyze the cyclomatic
complexity of your code and suggest ways
for you to undo some of that complexity
if you've got too much nesting of your
functions or you have too many recursive
function calls that can find that stuff
out and help you identify it and fix it
there's a phenomenal amount of tools and
I didn't even list all of them so this
is not something you have to start out
completely from a blank slate with no
idea what to do there's a lot of tools
that you can build upon all you have to
do is have the motivation that it's
worth it
let me suggest to you some things that
you might do to fix your code what about
auto correcting misspellings of variable
names how many of you've ever had you
struggle with your tools and you're
finding a place to do that what if a
tool could figure out that you've
misspelled a variable name in one place
and use the same name the correct name
everywhere else and it just fixes it for
you and alerts you so you can fix it in
your source code safely rearranging your
scope consolidating your declarations we
talked about some of these things
already automatically reducing the
complexity of your code refactoring
boolean traps if you write api's that
have five different boolean variables in
the API of the method signature
what if we could automatically rewrite
those things so that it wasn't falling
into the trap of a false being you know
the same thing as an undefined you could
optimize the performance of your code on
the fly and the list really does go on
and on if there's ever been a pain point
that you've run across in your
JavaScript code there's a good
possibility that a smarter tool could
help smooth out at least some if not all
of those problems I think we've gotten
so pigeon holed into well you know
whatever javascript is in the browser
that's the only code I can write and the
people that went to CoffeeScript didn't
think that way the people that jump
script from JavaScript to CoffeeScript
said let's get a better language a
better language for me to author I don't
care what it runs in I just want to have
a better language to author here's a
secret if you don't know the computer
doesn't care about your source code at
all source codes not
Computers it's for developers as few
human beings you need to find source
code that works the way your brain does
so that you can be the most effective
developer possible and if javascript is
in that language frankly that's not
going to bother me if you jump ship and
go to go or whatever but if javascript
is that language and you're just running
across these issues maybe tools are a
better way to solve it some other talks
that you should definitely look at these
links are too small for you to see but
if you get these later this is a talk
the future of JavaScript language
tooling and another one is called
building JavaScript tools both of these
talks are fantastic and some of the some
of the ideas that I've got have come
directly from there so check out those
talks as well let me give you one more
thing to end with this is an example
that somebody just actually gave me
earlier today on Twitter they were
complaining about this coercion nature
of JavaScript and they were saying well
I had this one problem where if I called
the function it worked properly but if I
did a comparison with the function and I
had accidentally forgotten to put the
parentheses there
then I got a false but I wanted it to
throw me an error and I'm not about the
fact that JavaScript coerces that
function to a number and it doesn't it
doesn't throw me an error if you're
having trouble with your coercion x' and
your other things in your program and I
know it's very in vogue to sort of blame
that as a deep flaw of the language I
don't think it's a flaw at all I think
coercion is awesome the third book in my
series is all about type and coercion
and I'm suggesting to you that I think
it's a tool you can learn and use with
every other tool in the language I know
I'm in the minority on that but if you
look at this particular scenario and if
this is something you've ever had a
problem with or if you've had problems
similar let me suggest to you another
tool that can fix this problem
it's called restricting strictmode org
it's a tool that goes through it parses
your code it wraps all of your
comparisons in type safe checks it runs
your code on the server so this is not
stuff that gets deployed to the browser
but it runs through your code with
sample input and then it reports out an
error that shows you if you're doing
unsafe checking like for instance it's
kind of small to see here but it'll do
to your checks with your less than and
your greater than and it'll only allows
those with numbers and strings so if you
ever have a
all you that gets to it that's not a
number or string it'll throw it an error
and say you're doing something unsafe
tools can fix a lot more problems than I
think we've been willing to admit and if
nothing else I hope that's what I've
inspired you with in this talk today
it's not honor to be here I appreciate
your time very much it looks like we
might have like two or three minutes
left for some questions if there are any
yeah yeah so the macros are oftentimes
the question was when do you use a
function call that wraps up some code
versus a macro oftentimes the macro
looks like a function call but it
doesn't always so macros actually can
rewrite the way your syntax looks it can
it can look like a function call but it
can actually change the way your
operators are working so I would say
macros are for fixing mechanics of the
language where functions are for
abstracting logic good question let's go
out and build some better tools thanks
for being appreciated</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>