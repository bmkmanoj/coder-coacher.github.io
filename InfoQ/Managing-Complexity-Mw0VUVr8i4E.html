<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Managing Complexity | Coder Coacher - Coaching Coders</title><meta content="Managing Complexity - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Managing Complexity</b></h2><h5 class="post__date">2012-08-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Mw0VUVr8i4E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody think thank you for coming I'm
richer villain real developer mama and
what cloth is an old IV killer who
specializes in villages fire clothing
and accessories currently under the lead
of the TV builds internal tools to
manage the supply chain and we have many
systems that work together and deal with
the virus infected what club doesn't he
broke so fast in the last few years
after so fun we realized that we had to
revisit architecture so we start
investigating into service-oriented
architectures and at that point it was
really new to us oh but right now but
right now sorry for right now you have a
much better understanding on how to make
it work so application complexity is a
really really broad topic so I'm just
going to cover a few points and I think
I'm going to really help you whenever
you want to sit with our your own
systems maybe you're working with our
really large monolithic application and
it is becoming increasingly difficult to
keep it organized or you have decided to
break it up into multiple components
when you're not how you're not sure how
to accomplish it success
for example that mop up we have a lot of
application or a main one it is filled
with one and it is huge that's a wand of
the best one that is responsible for
almost everything at Mach com+ also it
includes many internal tools that we
used to manage our store also we have
tons and tons of reports and what you
see here is probably even less than half
of its functionality did you start the
screen
so the beginning we thought their
problem was that we were not running the
latest version of rails but the more we
thought about it it became obvious our
problem was this really large ification
so what is a problem working with a
really large application is really hard
there's so much complexity because there
are so many dependencies between all the
different components and this makes it
really likely to have very highly
complicated so every time we make any
change we have to be really really
careful not to break anything so even if
with what the change is very small and
most of the code is not even modified it
is still necessary to run the whole test
suite and for a monolithic application
it takes about an hour for that reason I
always loved working with newer smaller
applications at least for me I feel I'm
most productive at the beginning of the
project and when you wish it was always
like that well the solution is simple we
just increment in a lot of small
applications that work well together but
how do we make them work well together
this can also be very messy because all
the components need to be interconnected
having a distributed architecture it
doesn't necessarily make your code in it
simpler it can make your application
market price for example what happens
when multiple applications need to work
with us in data what is the primary
source of truth if you really need to
make a network code every time that you
need a resource partner
web service and what happens when the
communication in any of the different
component system we certainly don't want
to build a system that requires all of
its components to be available at all
times otherwise urban end up with a
system that is more writable and with
more points of failure than having our
monolithic application as you can see
building that is driven architecture is
not trivial there are a lot of
complexities a competent but once you
get past building the foundation all
those complexities are going to move
small compared to building and working
with a large application so is there a
secret sauce to make it work there are a
lot of really good solution but for me
was understanding how messaging queues
work of course there contexture is going
to vary depending on the needs of your
company so when we use a message and
Hugh it becomes a cool between all the
different components and it allows us to
have many small applications that work
all together
the pre series of talks had a really
good introduction about messaging q so
I'm not going to go really even
explaining what they are but here are
the basics in case you missed it so
publisher broadcast a message slowly
subscribers in every anybody that cares
about that message we're rather than
sending this message directly to them he
uses an exchange which itself uses cues
to store all the messages while they get
delivered and this is key with this
which is so part of our availability
problem we don't need to worry that an
external system it's not going to be
modified well it's unavailable so once
it comes back online is going to receive
all the messages in this so what makes
an application complex a difficult to
manage I believe this will save a highly
coupled code that knows way too much on
the whole environment so every time you
write any piece of code really think
about what is the responsibility of that
component and try to see with that
anything further just broadcast a
message and there will be other
applications and services that are if
that interest that aren't interested in
that particular action so just let them
do that also try to keep every single
component as independent as possible and
cash as much information as it makes
sense this way you will not depend on
the availability of additional services
so rather than holding a restful api
every time that you thoughts on every
request just use your favorite key value
store a relational database or asset
search engine like solar to keep all the
information that you care about store
locally so in all these cases you will
not need the cash when you receive
messages indicate
that their resource has been updated so
right now we just solve two problems
first we remove the latency during a
request by not using external services
and we're now able to easily join
information between many systems because
like for example if we use of relational
database we can continue using ESCA
sequel joints so let's go over an
example let's say that we need to create
an online store and sell physical
products pretty much like lock lock it
super simple basically we just have to
sell products and send them to the
customer that's pretty much it right
well not really there are other actions
that need to happen after the order is
placed first we need to mark the order
has completed we need to bikram at the
inventories we need to notify the
inventory our customers with an email
now probably we need to create a big
ticket I'm just going to be used for
about the warehouse also if we use
caching in our site we might need to
expire it because maybe the product is
not available anymore if we need to
change the parts badge to sold out and
maybe our finest team just requested
that they want a transaction log and
into the database after a practice or
and I could go on and on with other
actions that need to happen after a
proactive soul but I think you are
getting the gear with this so if we put
all this code in a single occasion and
executed sequentially we're going to end
up with code responsible for knowing the
whole workflow about the product sale
and it is really not your responsibility
to all this I think this might be okay
if you have a really really small
project but it's going to get really
complex very quickly and it's not going
to be very scalable when you
many teams and every team has different
responsibilities in everybody's touching
the same code base so let's simplify
this a little bit so now imagine that
the code responsible for completing the
order only needed to mark it as
completed and that's it it is really
another responsibility of the order
check out to do all the other actions
that we talked about previously so then
we use our messaging huether notify that
our product has been sold and there will
be other subsystems that care about the
sale of products in each one event is
responsible for completely different
actions so the finest team they can have
a logging the need and the we can add an
inventory service that can't determine
the available units and by doing this we
achieve something really big it is that
we don't have to do it for them because
every system have just did it by
themselves we have that you have the
finest tea that little by themselves and
the other service as well so then if we
let's go back to our example so then we
be given tory system detects that a
product is no longer available after
sale you can send a product sell that
message and our catalog is interested in
that message so when he gets it went to
expire some caches and he can regenerate
like for example the products batch to
indicate up the part of the souls so
make this faded off lot cleaner right
well there's a huge reason why message
and Q's having come very very popular
lately and to be honest I couldn't I
didn't really see the benefit of
distributed architectures did I started
working with messaging queues and I
thought that distributed systems for
more complexities of benefits so I hope
that this this example makes it simpler
for you
so let's continue with our example who
owns the inventory information and what
happens when a product is returned or
not products is found effective it needs
to be taken out of inventory certainly
the the store is healthy only
application that hears about inventories
because it's not it's for responsibility
to keep how many products are available
so if we take this responsibility out of
the store should we really pull an
inventory service every time that we
want to render up a catalog page and
even like if we do we need to check the
inventory whatever we want to complete
an order they certainly want to show
accurate information for customers but
we should always try to avoid external
dependencies whenever working with this
ruthless system so remember that I
suggested to use caching as much as
possible well that's apply to our
inventories so if we catch all the
products that are available in our store
let's say we can use something like
credits for this when the product is
sold we can quickly determine the values
so let's say that we have five products
available and we sell one it's not
really hard to estimate how many
problems who are going to have available
after the sale is done and you guess
it's going to be 4i it's not very hard
so after that the sport will modify that
made a sale and the inventories service
can t currently low value of inventories
so then after that the inventory service
can't broadcast
but the inventories for that product
have been updated answers our stories
subscribe to inventory adjustments they
can keep track of how many products are
available even if other systems are
modifying the inventory and by doing
this we basically took all the co
responsible for managing and inventories
out of our store and we must and we
moved it to the inventory services and
now we don't even rely on the
availability of our inventory service to
complete the order i strongly believe
and no single component should own a
message you really want to be able to
shift application responsibilities
around and other components shouldn't
really care who is doing what so
whenever you had a message type just
think about the what is within your
whole system where if it works so if
you're using rails and sees is very easy
to accomplish it completion by adding a
gem that can abstract the communication
between your application and the message
in queue and it also is going to define
all the requirements of all the messages
and this is also an easy way to document
all the messages are available for both
publishers and subscribers if you're not
convinced convinced yet I have three
more benefits so when you're going to
have fast and simper test why because
you're going to help us model for
component also you're going to have a
smaller memory footprint so every
component is going to use less memory so
you're going to go to the benefit you're
going to be able to put more instances
from surgery and also your sins we are
going to have less files for components
is going to be a lot easier for you to
find what you
have to change this is an overview have
a message if you can fit within your
infrastructure so web app can talk
directly to a messaging Hugh who are
restful api i would recommend trying to
talk to a messaging few as well as much
as possible but sometimes you need a
response so in that case you will use a
you will call the rest away the other
also like rails itself cannot be
subscribing to the message in queue so
probably you're going to add something
like an event even that it's going to be
listening for this for this messages and
it's going to translate the messages
into actions and we're going to use
something like rescue to me to fuel this
Johnson so then some workers can take
care of them so remember this to avoid
complexity each component should be as
independent as possible and have a very
defined responsibility and know as
little as possible about the rest of
infrastructure it shouldn't really care
who does what it should only care that
another piece of infrastructure is going
to take care of certain actions that it
cares about and that it is going to be
notified when it is it stirred to do
something thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>