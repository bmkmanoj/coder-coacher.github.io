<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>JavaScript Libraries: Choose to Reuse! | Coder Coacher - Coaching Coders</title><meta content="JavaScript Libraries: Choose to Reuse! - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>JavaScript Libraries: Choose to Reuse!</b></h2><h5 class="post__date">2012-12-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OGZB7lq9-Mk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you for coming hello San Francisco
always wanted to say that so my name is
jeremy khan and i wanna i want to start
this talk off with a simple showing of
hands who here loves to solve problems
by writing code awesome that this is
whatever be in the room that's why i was
hoping for who likes to solve problems
again and again by rewriting code
multiple times I'm surprised there's
actually a nonzero number so most people
don't and we shouldn't because that's
not that's not what programming is about
we want to reuse code to solve our
problems this talk is going to cover
three main things I we're going to talk
about some some high-level patterns for
code reuse we're going to talk about how
to write your own JavaScript library
that you that you can share and reuse
for yourself and I'm going to show you a
small project that I've put together to
make it all a little bit easier this is
the goal for today we want to make this
work everywhere that we wanted to run
this is just a simple AMD compatible
module it's it's getting a file called
library and it's creating a new instance
of it it's a pretty simple goal but it
can be a little bit harder than you
might think so first off hello again Who
am I and why you're listening to me my
name is Jeremy Khan I'm a web developer
at YouTube and I love writing open
source JavaScript libraries I've written
a few for fun of my free time and it's
it's a really good learning a really
good learning exercise and I've made
some cool things with that you want to
find me online I'm Jeremy sakana on both
github and Twitter so check me out
I love this quote no problem should have
to be solved twice this is taken from
Eric Raymond's how to be a hacker guide
believe it's step two is it was meant in
the context of more UNIX hacking and
like more old school like C++ type
things but I think it really applies to
the concepts of code reuse and not
wanting to you have to rewrite anything
so it's a bit of a contortion of the
original idea but I think it still holds
code reuse is king this is what we want
to strive for writing things once and
reusing them again and again now when I
say code reuse I don't mean copy and
paste it's kind of a weird kind of a
weird terminology connection but copy
and paste means you're Lily taking code
and you're copying it around the file
and you're just creating more complexity
and you're killing your maintainability
and that's bad code reuse means that
using the same piece of functionality
for multiple uses from different points
of your code base that's good so you're
isolating the complexity and you're
making main maintainability much easier
by localizing all your problem-solving
into one specific area for a specific
for a certain problem so here are two
large patterns for code reuse that we've
all probably heard a lot don't throw
around a lot frameworks and libraries it
seems that not a lot of people actually
know what the real difference is so
we're going to go in and we're going to
we're going to really define these terms
a framework as a mechanism for
structuring application this is more of
a higher high level tool and you
basically it gives you an entire
skeleton for how to build an app and you
just kind of fill in the little gaps
with your own application specific code
examples of frameworks include ember
angular knockout and closure there's a
few others but these are the big ones
especially ember and angular these are
the newer tools these are great so if
you're building a large application that
you want the scale definitely check out
these frameworks
a library is a little bit different it's
a little bit smaller and scope than a
framework in a library is just a module
for solving a specific problem you can
almost think it is like a utility for
solving a certain need that you might
have examples that we know and love are
jquery backbone require and underscore
the list goes on there's a ton of really
great frameworks out written by the
JavaScript community so how do these to
compare there's a lot of confusion as to
what you know what to find something as
a framework and what defines as a
library it turns out there is actually a
very strict differentiator and that is
something called inversion of control
inversion of control I it basically
refers to what is controlling what in
your application and what I mean by that
is that frameworks control your
application code and your application
code controls libraries so it's a bit of
a hierarchy so you've got frameworks at
the high level application layer in the
middle and then your libraries at the
bottom which there can be any number of
so what that means is that you can have
any number of libraries but you really
only want to have one framework one way
to think of this is that a library is
like your wrench and a framework as you
let is like your entire workshop you can
have many different ends of tools you
can have you know it wrenches and
screwdrivers and buzz saws and whatever
you need but you only really work with
within your one big you're one big
workshop also you don't have like multi
tools because well get and then a second
but we're not focusing on the frameworks
today today we're talking about
libraries something that is really
awesome and they were usable solutions
for common problems now when it comes to
actually writing a JavaScript library
there's really no spec or standard
there's really no quantified set of
rules to follow it's just some basic
best practices that have emerged out of
real libraries out in the wild and
really with what the way that I look at
it as is its it's the comparison between
very good ideas and extremely bad ideas
so let's check out some extremely bad
ideas first so we know to avoid really
when you're writing a library you want
to follow the same principles as writing
unobtrusive JavaScript so the things you
don't want to do when you're trying to
do this is you almost most importantly
is you don't want to modify built-in
prototypes you don't want to extend or
augment objects prototype or array or
anything like that because other other
third-party code in your environment may
be expecting that to work a certain way
so your best bet is to leave things in a
natural neutral state so don't modify
these prototypes you also don't want to
make assumptions about the environment
that your code is going to be running in
what I mean by that is that if you have
some code that's dependent on certain
WebKit api's you may not want to use
those let's not say that you can't you
can use web kit or gecko specific
libraries or specific api's but you
either want to normalize that
functionality across the different
environments or you want a thoroughly
document that your code will and won't
work in certain environments another
thing another thing to avoid is
excessive dependencies you want to make
sure that your code only uses external
dependencies that it actually needs
that's again that's not to say that you
can't use dependencies just kind of be
aware of of the bloat and the the
technical that you're bringing into your
project when you require more and more
dependencies a good example of what not
to do is that a while back I found this
timer library that was I think less than
1k was the small little utility library
but it required jquery and i looked at
the source and the only reason that it
required jquery which is like a 30k
library minified in gzipped the only
reason it required that was to use the
dot each function which is not really a
significant component of jquery in terms
of the overall code base so that doesn't
exactly sorry that person's in the room
by the way but that's an example of what
not to do so what are some things that
we do want to do what are some good
ideas to follow for writing unobtrusive
javascript libraries the the easiest
low-hanging fruit is to minimize your
global variables you generally don't
want to expose more than one global
variable and if using something if using
AMD compatible loader such as require
j/s then you can actually get away with
exposing no Global's at all which is
awesome you want to make sure that your
library has a small and focus scope want
to keep it simple as mentioning before
that you want to avoid things like a
multi-tool and what I mean by that is
that if you're working at a workshop
going back to that metaphor you have a
bunch of specific tools for everything
that you need to do you know specific
screwdrivers and wrenches and so on and
so forth and if you you probably don't
want to use one of those multi tools
because it's usually not very good at
any one thing doing anyone any one thing
well and it's also kind of unwieldy so
keep your libraries small and focused
and your library should just work the
best kinds of libraries the ones that we
really love you just drop them on the
page they do their promised and they
don't do anything else they don't break
any other code a great example of a
library like this is moderniser you just
load moderniser it does some tests and
put things in put some classes in your
code and it just does its thing and that
is the kind of API that we want to see
another thing that you want to do if
you're writing JavaScript library is to
adhere to a standard module
compatibility format so these are the
big four right now we've got common j/s
AMD UMD and es harmony ekta script
harmony so how do these break down
the high level common GS is what's used
on the server this is the the package
format that node uses am d stands for
asynchronous module definition and this
is a great tool for loading modules in
the browser asynchronous is in the name
so it can actually get multiple modules
asynchronously and then load them and
resolve the dependencies on the fly so
that's great if you need to make
multiple requests UMD is sort of like a
love child between common Jas and AMD
I've used it myself but it look it looks
promising enough and it's great if you
need to normalize between the
environments but it kind of muddies up
your code a little bit so take it with a
grain of salt and last one is es harmony
because the JavaScript language authors
have realized that this is a problem
that needs to be solved at a language
level so they're working on a
specification to actually build this
into the language it's not quite ready
to roll yet but it is in the works
always be testing your code you should
never not be testing your code and it's
especially true if you want to
distribute a reusable library you want
to make sure that your code does as
promised and an automated testing suite
is the best way to do that you can think
that as a way of proving that your code
does what it says it's going to do
there's great tools out there for this I
think the big three right now are qunit
jasmine and mocha I prefer qunit because
it just kind of works jasmine and milk
are also very good they have a bit of a
different syntax but definitely check
out whatever tool works the best for you
so I love semantic versioning and this
is something that not a lot of people
talk about it's kind of like people kind
of generally accept the concepts of
semantic versioning but it's people
don't really think about the actual
definitions of it so when you've seen
large open source projects such as
jQuery or Linux or something like that
they've usually got a number number dot
numbers for Matt and that sometimes it
hears the semantic versioning
so you can see the definition for
semantic versioning it's actually a
pseudo spec you can see it it's ember
org it was written by the website was
written by tom preston Warner who is the
CEO of github I believe but it basically
breaks down to these three different
parts you've got three version numbers
major minor and patch and the most
important number to this versioning
scheme is the leftmost number which is
the major version in this case we've got
0 12 dot 6 the idea what the major
version is that if you're not one point
0 yet if you're at zero dot whatever dot
whatever you're free to change the API
because it's still considered to be in
development and unstable not that you
should go willy-nilly just changing the
API because you may have lots of users
such as backbone or node but still the
API is free to change and instill you
know conform to the standard but once
you get to 1 point 0 or above the API is
effectively locked down so if you change
the API such that it breaks current
users of that major version so if you if
you're in version 2 dot something and
you change the API so it'll break things
for current users of two of that major
version you have to increment it so it
becomes three dots something about
something so it's it's a way of kind of
promoting more stable api's and you know
putting some more thought into how your
AP is going to look before you actually
finalize it the middle number is the
minor version you can you're you're free
to make API changes that aren't that
don't break backwards compatibility and
this is handy if you just want to add
certain features to your API but still
you know not break things for older
users in the last version is them is the
patch version and this is just for small
little bug fixes that come up and this
shouldn't break anybody's code the
reason that we have this semantic
versioning scheme is so that we can so
that users can make sure that certain
version a certain major version of code
is going to run on their system so they
can freely upgrade to the next major
version of a package and know that it's
not going to break their code we want to
optimize for the modern developer in the
modern developers tool chain so what
does this look like here are three big
package managers NPM ender jam Bauer and
yeoman the thing the ones that we really
want to focus on here are NPM Bauer and
yeoman yeah my color scheme is good
there under and jam are a good projects
but they never really caught on that
much and a little bit older so it's
better to look towards the future at
things like NPM in Bauer because they've
got more community support at least for
the moment and it's got a little bit
more there's a bit more developers
backing them it looks like the omen
isn't necessarily a package management
tool it is a it does get code onto your
system but it it's a it gets packages
but it also does a whole lot more and I
believe that Paul Irish is giving a talk
on that tomorrow so if you want to learn
more about yeoman which looks really
cool you should see his keynote so
there's a lot of details if we want to
write JavaScript industry bid it and
make sure that it works for everybody we
need some way of kind of reeling in all
the all the madness so we can build on
top these are on top of these roles
I built a small project called lib
temple is a template for unobtrusive
scalable JavaScript libraries it's a
it's a library template not a template
library so it's a bit of a distinction
there the idea is that you take lib
temple and then you just change what you
need to build off of the pattern that
it's already set out so you can add more
and more of whatever you need to it it
is that you don't use it as it is it
doesn't really do anything as it is it's
more of an educational project that you
can build on if you want to check out
the source code it is on my github it's
right there I didn't really know to do
about the name because it is a library
template I didn't wanna give it like a
weird name that would you know you know
might mean something else so I just
called it what it is and took out some
letters so it's lib temple it is modeled
after two libraries that I've written
called recap II and shifty these are
some some animation libraries that I've
talked about in the past and the reason
I wanted to use these projects is
because I developed a pattern that
worked really well as building these out
and adding more features and making them
work for me and it's also important to
note that I didn't come up with a lot of
these patterns myself few small parts
but most of it was taken from from other
projects that i had seen especially
jquery there's a lot of great ideas from
other projects that can be that were
used to make this all this whole thing
work together so what does a limp temple
library look like well it uses a kind of
more old-school object-oriented
constructor patterns so you basically
exposes one single object can give it
static properties in private and public
properties
this is how we create a new instance of
a lib temple library and the the object
that it exposes called library you're
definitely going to want change it
change it to something a little bit more
helpful for you if you if you decide to
build on top of this so we just create a
new instance of it and you'll notice
that this is actually taking from that
from the snippet at the beginning of the
presentation where it was wrapped inside
of a require block so i'm going to show
you the the structure of all the files
but the thing to keep in mind is that
all these files are meant to be
concatenated to concatenate it into one
single file you don't want to use any
single file of this whole project by
itself it's all meant to optimize
development for you the developer so you
can easily compartmentalize
functionality into into separate files
here are the five file types in lib
temple intro and knit core module and
outro nao intro and outro is the idea
that I completely stole from jQuery
because it's so awesome and intro is
just to be getting part of a function
closure and outro is just the the the
ending of a function closure so what we
wind up with is something like this so
we've got intro some code in the middle
and then an outro and what this does is
it just it just protects everything that
we're doing inside of the inside of code
there from the global scope so really
intro and outro are just kind of like
tiny little files ramping things up a
little bit let's take a look at in it j
s so in it GS is kind of your doorway
into the library this is what what
bootstraps the whole thing and gets code
running in and gets code into your
environment it does something kind of
handy it normalizes AMD in non AMD
environments I actually took this
pattern from um DJ s which is linked up
at the end of this presentation and what
that means is that if you want to load a
Lib temple library through a script
loader such as required a s you can do
that and not expose any global variable
which is great and if you're not using a
script loader if you're just using
script tags you can lib temples
compatible with that too because of this
abstraction layer so and it's still
pretty small we still haven't like it
made any functionality to make this
thing live or breathe yet and that's
what core is for so core creates the
library object a few slides back I
showed you a new library and then
friends and that's what that's what core
is creating it's creating a constructor
function and it's also creating some
basic utilities that are available to
all of your modules so let's take a look
at what that looks like so it's a little
bit ugly but let's focus at the top here
we have some basic utilities that can be
used by all of your modules everything
that's in this highlighted section is
going to be within the scope of all of
your module files which I'll explain in
a moment but you can define anything
that you need a constant any kind of
private methods whatever you need and
the real beaten bones of this is this
we've got this wrapper function called
an it library core it just gets context
as a parameter which is either the
global object if you're not loading it
via AMD or it is the AMD context that
you loaded it in and all this does is it
creates the constructor function and it
can do any number of things like adding
methods to the prototype or just adding
any other utilities that you need but
this is how you start creating this is
how you start with uh creating the
object
so now that we've got an it in core out
of the way we have any number of modules
I put a little asterisk next to module
Jess because you can have one or many of
them they do that they're modules and
you can kind of pick and choose what you
need and add them at at will library
modules are awesome this is kind of the
fun part of a Lib temple library now
when I say library modules in this
context it's a bit of a weird
terminology admit I shouldn't know what
else to call them so when I say library
modules I don't mean AMD or common j/s
modules or anything like that when I say
modules in the context of lib temple I'm
really more referring to two different
files so a grading is a great real-life
example of this pattern is again jquery
so if you look at the source for jquery
like under the source directory you'll
see module C files for Ajax and core and
animation CSS and a whole bunch of
others and the idea is that they're that
they're separating code out in two
separate files so it's easier to develop
so it makes sense when someone wants to
add or change or figure something out
they can just go into whatever you know
module it's named after so it's it's a
way of optimizing for you the developer
of the library to keep your sanity not
have one giant file for everything so
what is a what is a Lib temple module
really doing and I just want to say that
you again going back to the
differentiating the different module
types is that you don't want to you
don't ever want to use us a module by
itself it's just it's part of the build
process so these modules are just a
wrapper function that just decorate the
object that was created in core
so here's an example of a library module
it's pretty similar to court because
Cory actually is a module it's just a
module of some extra sugar on top but
inside of this wrapper we're just we can
create more constants create more
private variables or private methods
that are that are specific to that
functionality and we can also add static
and prototype methods again the idea is
to only add things that we really need
in this particular module so if this
module is doing things that are that are
CSS related we would have them in this
module not another one and this wrapper
function gets called in an it which is
where everything gets tied together and
bundled
so we have this nice pattern for
separating code out in two separate
files and keeping smaller files that are
easy to manage what are some other nice
things that live temple gives you it
starts you off with a with a reasonable
same directory structure it's not that
big of a deal but some people yeah
they're not really sure where to start
when structuring it structuring their
directories for an application so I I've
taken a lot of hints from other larger
projects and kind of distilled it into a
more generic pattern I've given you a
unit testing bootstrap with Q unit so
that it's really easy to start writing
tests you don't have to use Q in it but
it works and it's pretty easy so that's
the default but the most fun thing is
the build script now this is the this
does some pretty cool stuff lib temple
uses uglify j/s who here is heard of
uglify just before okay about half of
you great it's awesome it is a
JavaScript compiler and it can
concatenate concatenate and compress
different JavaScript files into one
single minified binary that's that you
can then deploy to your users but it
does something that not a lot of people
are really talking about it lets you
create custom binaries let's dig into
this a little bit more
compiler directives rock so compiler
directives are not a new concept it's
actually from this is a decades-old
concept the C and C++ guys have enjoying
this for way longer than we have and the
JavaScript community is just finally
catching up with great tools like uglify
the idea behind compiler directives is
the ability to customize your binaries
for specific targets so if you wanted to
have the same code base compile into a
target for for the browser and for node
and for arduino and for OS 10 or
whatever you could just turn off certain
flags and customize your binary at Build
time so the syntax are doing this is
uglify GS is a little bit wonky it's
kind of a kind of a hack but it works
and let's say that we want to have some
debugging code that gets exposed only
for our unit tests but not in the
compiled binary or for the deploy binary
so we could have some a variable called
debug it's going to check to see if
debug is undefined if it is undefined
we're going to globally define it as
true and then later on on the code if we
want to add a certain test hook function
we can just see if debug is truthy and
then just expose that that function
globally so here's kind of an ugly
snippet from the build script but it's
called uglify JS for a reason but the
relevant part here is right in the
center here so we can see that we're
defining debug as false so when uglify
GS goes is compiling your code it's
going to assume that the variable debug
is false so let's look again at the code
inside of our source it's going to see
it's doing a type of debug equals
undefined well false isn't undefined so
it's actually true I'm sorry debug is
not undefined so it's not going to mark
it as true and then later on the code
it's going to see if debug is true and
that code is never going to get run
and the way that this works is that
uglify is kind of using two features of
itself to make a better feature and when
it sees code that can't be run something
that's for example marked in a false
statement like this would be like if
false then it actually removes that code
from the compiled binary so we can
conditionally turn off and on certain
segments of our code and this is really
handy another way to think of it as I
said before is you can compile you can
make optimized binaries for node so it's
the exact same pattern if no Jas is true
then we expose this node J a specific
method globally and this is how I would
look in the build script you just add as
many of these compiler directives as you
need so there could be one for debugging
node browser the sky's the limit so this
is pretty cool now the point of all
these little tools that I've built into
lib temple is to build better tools we
want to find patterns for building
better tools and we want to build a
community because this stuff is awesome
and we don't want to have to rekey pre
solving problems so let's stick to some
better practices for writing better
tools a great a great place to find new
tools is my co je s com micro GS is a
website that is created and maintained
and is maintained by Thomas Fuchs of
script oculus and Zep doe fame and it's
just this really nice repository of
curated micro libraries meaning they're
under 5k so you could check out the
libraries on this list here and see what
works for you and just see what people
are making so definitely check it out
thank you were there any questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>