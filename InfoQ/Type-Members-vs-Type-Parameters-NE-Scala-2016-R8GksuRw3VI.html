<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Type Members vs Type Parameters - NE Scala 2016 | Coder Coacher - Coaching Coders</title><meta content="Type Members vs Type Parameters - NE Scala 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Type Members vs Type Parameters - NE Scala 2016</b></h2><h5 class="post__date">2016-04-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R8GksuRw3VI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ok hello last talk of the day you've
you've almost made it I'm going to talk
about type parameters and type members
I'm gonna last quick question who has
who has used both type parameters and
tight members somewhere in Scala code
who has used only one or the other hand
suits are almost going up which like
you're not you're not confident about a
missing to it but the Scarlet does have
these these two different different ways
of dealing with her what was it was a
very similar concept and in the in the
in the ten years or so that I've been
programming scholar I've I've been aware
obviously that both of these these
features are available and until I
started preparing this talk I was never
really I wasn't really sure about the
reasons why I wanted to use one or the
other my experience evolved over those
over those years I was learning scholar
to get some sort of intuition but I
never really had a formal understanding
of why why one or the other is better
for certain circumstances so let's let's
get started you're probably very
familiar with something like this it's a
it's a type with a type parameter you
will know list you will know int nothing
special and this is this is what it
looks like in usage we have a we have a
very simple value called access which is
the type list of int and there's there's
the value nothing nothing too scary yet
and this is a simplified version of the
the definition of that that list now we
could have implemented that all the
designers of scarlet could have in front
of that with a type member instead let's
call it m this for member member list
this is this is a little bit different
we don't have a type parameter anymore
and we have to specify type and give it
a give the name now if you wanted to
write down that type or the equivalent
of the type we saw before you would
write it like this
you maybe haven't seen this this before
with the with with the bubble on the
right hand side the type refinement
where we're specifying that the element
type is int but this is basically
equivalent to list of int as we saw
before you're probably more familiar
with writing the type in in this form
where you just don't bother with that
refinement but that's effectively the
same as saying well we don't we don't
care about the parameter we don't care
about that inner type value and if we if
we were writing the same the same type
with the same specificity with type r
anders this is what bit right we'd have
the we have lists of underscore which is
which is equivalent to list of tea for
some type t someone specified type T so
it's an existential who's who's happy
and comfortable ex essentials here
that's very few people okay I'm sure
they're not they're not that complicated
but they're they're one of the one of
the kinds of types in Scala that you you
hopefully don't see too often and and I
think that underscore in list will
probably make you feel a little bit
uncomfortable because if it feels like
this there's something wrong there where
we're submitting that type information
which we would normally have but we can
actually write all of these all
combinations of parameters and members
and universal and existential so where
the type is fully specified that that's
universal that's universally it's
universally quantified as a type which
means everywhere we know what that
everywhere that specified me know what
that that inner type is and I don't know
if you can see the cursor there you'll
notice something about these these two
ways of writing mmmm existential member
types and universal parameter types
they're shorter than the other two
options so the syntax in Scala is very
much biased towards writing
mutters universally quantified and
writing type members existentially
quantified so this is this is really
important if we if we wanted to
universally quantify a member or x
essentially quantify a parameter we
would have to write one of these two
options here which I mean they're
they're just long and cumbersome it's
really not what we want to be writing at
least not frequently in in scarlet code
but you can you can do everything you
can write all of these all combinations
of these things you can even I don't if
anyone recognizes what what I've written
here anyone this is this is the same
this is the same thing did i do I hear
an F it was the founder polymorphism if
you've ever ever seen this before this
is kind of a bit like a recursive type
type parameter here we can write that as
a type member if we really want to we
can we read all this all this stuff here
but it's it's completely possible and it
works in basically the same way it's
just that this is a very strong case for
suggesting that a type parameter would
be more appropriate than a type member
so I had some speaker speaker now to
Ashley which were meant to tell me what
why i was showing all these slides but
I've long since departed from this
script so yeah anyway so if we had an
instance of an M list here are
memberlist this is our this is our
mocked-up type member version of our
list and we give that the type M list
we've we've all of a sudden lost all of
the the information we knew about the
type member which we can see on the
right-hand side is is int it's an end
list of int but as soon as we ascribe
this type here M list without the
refinement we've lost that information
and we can never we can never gain that
back unless we artificially cast to the
type again and the same thing in an
entire parameter format like this and we
have this we have this big hint that
some something's being lost by this
there's underscore you can see here but
here's an example where that doesn't
matter if we had a method which was
basically just getting getting the
length of a other list when we're not
actually using any information from the
type parameter here so we can we can
call this method with a list of int list
of strings but the return type is int it
doesn't matter what the type is so we
can very safely and very comfortably
ignore it we can make this an
existential and the we have we have this
choice as to whether we whether we make
a parameter whether we have make an
inner type of parameter or a member and
it's cases like this that sort of
indicate to us which we think is the
more appropriate solution if we're
frequently finding we're calling we're
referring to a type hiding or forgetting
forgetting deliberately forgetting the
information of the inner type then
that's may be an indication it should be
a type member if we're frequently
needing to add the refinement to our
type members to do our types with the
type members to specify what that type
is that's probably an indication that it
should maybe be a parameter but in all
cases you have the alternative you can
always you can always write it the other
way if you want to and an indication as
to how frequently you'll need to go one
way or the other is how much of the API
how much of the public API of that type
exposes the the the inner type here now
this is sort of the exceptional case
where we've got some list which has a
lot of methods that do refer to the the
type like just they apply method you get
you get a value from it for the head
method it uses the the the type of the
list in the return type of of that
method call but this is this exceptional
case we have length which doesn't refer
to it at all it always consistent
returns int so
it's a matter of judging it's a matter
of judgment as to how much the API you
think needs to needs to track that type
and how much doesn't and I mean there's
various reasons why you might want to my
way might want to forget forget
information i'm going to show you show
you an example here this is a little toy
type class i'll let you glance this for
a second this is a type class for
joining joining a collection of things
from one type into another type so
joining a collection of characters into
a string for example i'm not going to
show you any any implementations but
it's called a joiner it takes an element
which would be the sort of the character
type and i've implemented it with a
return type are also the return type r
which i've i've chosen to use the type
member for and it's only got one one
useful method join which takes a
sequence of elements so maybe characters
and returns a string or whatever is
appropriate and we might use that that
Joyner in in a method like this so we
call we call this method we pass it some
characters and the compiler will go off
and look for an implicit and it will it
will find an implicit like this one so
maybe we've got a character join us
somewhere in scope and the type of that
is joiner for characters where the
return type is string is that is that ok
is everyone sort of sufficiently
familiar with type classes or the vague
idea to to appreciate that now can
anyone tell me what the type of j is
sorry you said ladder no so as you it's
been resolved miles you put your hand up
go on so there's a couple of possible
answers and okay so um that the compiler
knows a little bit more than maybe you
realize in in in within the signature of
this method so you might look at this
and think Jay well the type is obviously
joiner of tea I mean it says joiner of
tea there but the compiler knows a bit
more than that it knows that the type is
more specifically J dot type it knows
exactly which implicit gets resolved i'm
going to tell you it's this one and it
knows that the type of jay is joiner of
character with the refinement of our
equals string so it knows a more
specific type within the body within
that that method signature so what that
what the compiler actually knows is
something like this and excuse the
perform a ting which isn't isn't great
but it means that for this for this
method here we can actually refer to j
dot r and the compiler will know by
virtue of the implicit that's resolved
that r is string and that the return
type resolves to string now this is a
this is a really subtle feature of
scholar but it's actually quite
fundamental to a lot of things working
as well as they do and then we just call
Jake join and that will return the data
are type which which we know is is
string does that does that make at least
some sense even if you're maybe not
encounter this exact this is that
situation before okay now if we were to
write the same thing with type
parameters we might have two parameters
element and then we've moved we've
promoted the the are type the return
type to a parameter now and again we're
returning our but we have to rewrite our
do join method we have to add this are
in here that we with now well in order
to
you have this r2 pass it from the
parameter here to the return type we
need to track it through the method
signature and in order to do that we
need to mention it we need to we need to
define that there is an R that is being
tracked through here in order to be able
to return it here now what this means is
that it's sort of polluting the the
method signature a little bit and
consequently if we wanted to call to
join explicitly specifying the type T we
have no option but specify our as well
whereas are we would actually prefer
we'd much prefer to be inferred so this
is this is a again it so it's quite a
subtle case but it's a clear case where
a type member is actually a better
solution than a type parameter so I want
to talk this hum doing for time but I
wanted to talk a little bit about
variance so this is one big difference
between type members and type parameters
Oh what seriously what is it no go on
right okay I believe you i'm sure i've
seen examples of this i would I've
interested to have an example next time
I give the talk but if if the if the
video or anyone else didn't hear that
Daniel saying that actually it's it's
more than it's more than just the
annoyance of having to specify that our
it's that we sometimes we say summers
can't even write the type r or that yeah
right sometimes the compiler simply
can't compute the are when it's in tight
parameter position whereas whereas it
can when it's a type member that's
referred to it as a path as a path to
that type thank you that's a that's an
even better reason than the reason I had
that slide in there for so so variance
is one one big area where type members
and type parameters differ and type
parameters can have variance annotations
they can have a plus or a minus on the
parameter now that it's not it's not
true to say the type members don't have
variants they do but they don't have
definition site variants so why do I
know how they are so just just just to
quickly hello mr. slide now just to
quickly recap if you have a covariant
type we've got a trade treat cough
covariant which is covariant in its
parameter a we know that we can we can
we can say that actually app that plus
isn't meant to be there we know that a
cough of runtime exception is a subtype
of golf of exception simply by virtue of
it being covariant and runtime exception
being a subtype of exception you can
think of this if you like as the the the
the subtype you're super typing
relationship between the parameters
being promoted to the outer types as
well by virtue of the the covariance and
the arrow goes the other way if it's
contravariant but that's a that's a
longer discussion but what happens here
if we try and convert that to type
members we have no way of specifying
this type to be covariant or contrarians
so what is the relationship between
these two types what are these one of
these question marks is it is it
subtyping is it super typing is it is it
equality well actually there's no
relation between these types because
when we use an equal sign here
this is invariance and foo foot of food
whether with T equals runtime exception
even though there's a relationship
between runtime exception and exception
there is no we can't infer any
relationship between foo of those things
so that there is no there is no solution
to this what we can do is we can define
a subtyping relationship so we can say T
is a subtype of runtime exception and
aunty is a subtype of exception and then
the inequality or the type inequality
holds so this is equivalent to
covariance but this is used site
covariance when I say you cite I mean
that the site at which you write the
type down and this this is this this
also actually but we miles and I looked
at this yesterday and the same thing
works for contravariance we can we can
turn this area the other around and this
arrow will change the other way around
as well this this becomes obviously a
lower bound then so it works as you as
you as you might hope and make me more
as you might expect but as you might
hope it too so the we can we can one
last thing we can do is we can we can
actually convert that we can we can
convert you cite variants to type
parameters so we can actually define
this same subtyping relationship for an
invariant type with a type parameter
provided we write provided we specify
that the youth site that our type is a
subtype of runtime exception and
consequently and also subtype of
exception then that will hold so there
is there is equivalence between type
members and type parameters for you cite
variants for definition site variants
that's only available with annotations
for site parameters
so why don't why don't type members have
have variance well the benefit we get
which is probably part of a maybe a
longer talk and maybe it's not even
worthy of talking about too much because
it's not that useful is that we can
defer we can defer a lot of the checks
that get done at the definition site we
can defer them until the the point where
the the value is instantiated with with
type members so that that is what we
gain we can write code with type members
that aren't constrained by any variance
that we that we wouldn't be able to
write with variant type parameters so to
summarize summarize some of these points
by default type members are existential
when you when you when you write the
type down and conversely type parameters
are universally quantified but because
they're University quantified we always
have to track them and that's that
sometimes a disadvantage and using types
with with parameters means we sometimes
need to introduce parameters to methods
which use those types in order to track
them across the signature and as Daniel
pointed out that actually causes more
problems because it means we can't we
can't actually infer them and use use
those types in in all cases type
parameters support definition site
variants where it was and that that was
my last point where as well the addition
point I was can make is that whereas
both type parameters and type members
support you site variants but they are
very very similar they are
interchangeable in most cases you will
probably find yourself refactoring code
between one and the other when you
encounter one of the little esoteric
cases that I've mentioned it or possibly
others i haven't mentioned so largely
largely it doesn't matter too much
but I I still having having having gone
through the process of trying to
formalize this and trying to understand
the logic I used to decide which is most
appropriate I still can't come up with a
better reason or bit better a better
explanation than to say it's it's still
the one that feels right most of the
time and you you have to work with them
you have to practice practice using them
to gain some sort of intuition either
that's probably the most disappointing
climax to to both a talk and a
conference but but the answer is do what
feels right and I'm gonna say first of
all thank you for listening but before
before we move on I'd like to also thank
at adelbert is he still here he very
kind well he both both he and I
submitted basically the same talk for
this conference and he kindly stepped
aside allowed me to get i hope i hope
i've done it justice and the other
person who's not i'd like to thank his
steven compal who wrote a really
brilliant series of blogs on there on
type level org they go they go beyond
anything i've discussed here by an order
of magnitude i can recommend reading
them and to spending time trying trying
to understand the details i think he did
6 6 or 7 articles 8 ok so there's yeah
well well worth reading and so at that
point i will say i do have any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>