<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fragments for All: Android Open 2011 | Coder Coacher - Coaching Coders</title><meta content="Fragments for All: Android Open 2011 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fragments for All: Android Open 2011</b></h2><h5 class="post__date">2012-03-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sCQ8EcM0HM0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone to the last session of
the conference to close things out so
welcome my name is Ken Jones I'm a
senior instructor with Maricopa we D
specialize in the open source training
including Android and so what I'm going
to present here is a session on
fragments it's kind of a continuation of
this honeycomb ish dr. topics about the
actionbar the last session if you were
here and so now I'm going to tell you
what in the world these fragments are
and how to use them now
you may probably have already heard a
little bit about fragments in case you
haven't what exactly is a fragment well
it's a class that implements a portion
of an activity so it's going to either
represent some portion of the interface
or some type of operation that we want
the activity to be performing now the
rationale for fragments is to provide
more modular activity design as Android
was rolled out to tablets so you know
the the layouts used to work fine for a
little handset but wouldn't necessarily
look good as they scaled up to full
tablet size you know a lot of unused
space
well the resource system has been around
for a long time to be able to provide
alternate sets of layouts depending upon
the screen size and orientation but you
know if you put a lot more things on
that could be that means that we need to
hook up more behaviors to them as well
so that was the challenge that was being
faced and so that's why fragments were
introduced so that we can have a class
encapsulating both a portion of the
layout and the behavior that we want for
that layout and then an activity will be
able to compose itself of whatever
fragments are appropriate for the screen
size and the resolution that we have so
as I was implying there the fragments
that we create must be embedded in
activities they cannot run as any
standalone entities so it's know so you
ever going to see Franklin just kind of
lying around on the screen by itself
most fragments
we'll define their own layouts of views
that will just become incorporated into
the overall activity view hierarchy but
that's not required turns out we can
have a fragment that has no layout
whatsoever it turns out to be a rather
useful technique to have I'll show you
some examples as to why being white want
to do that later on now
if you've done any type of Android
programming you're probably quite
familiar with the lifecycle of the
activity class and different life cycle
methods that are invoked well because a
fragment lives inside of an activity
it's going to have its own life cycle as
well so we're going to see how the life
cycle of a fragment mirrors that of the
activity that is contained in it now in
terms of actually you know creating that
given T that then uses the fragment
we'll see that there's two different
approaches we can use one is if the
fragment can be what I think of as a
static part of the activity it's created
as soon as the activity is created and
it's always there in the activity but we
also have the capability of
instantiating fragments at runtime and
adding them to an activity and then
dynamically managing these fragments for
interesting effects as well so I'll show
you both techniques for fragment
management so you want to do fragments
well if you're programming in honeycomb
or later there's a set of classes and
the primary ones that we're dealing with
are shown here on the screen fragment is
going to be our base class from which we
derive all of our fragment subclasses
all of our specific implementations
thereof fragment manager we'll be using
to interact with the fragment objects
that are part of our activity and then
we'll talk about the purpose of the
fragment transaction class and how it
allows us to perform an atomic set of
operations on a collection of fragments
in our activity now these were
introduced in honeycomb in API 11 so if
you know that your target is going to be
honeycomb or later you can use these
directly but what if you're trying to be
compatible with older versions you want
your application to run in Gingerbread
or Froyo or even you know earlier like
Eclair well that's where the
compatibility package comes into play
compare
package provided by Google is a job in
library that we can incorporate in our
application and it implements support
for fragments and other honeycomb
features loaders being the most
significant of those and it does so in a
way that's compatible all the way back
to donut to version 1.6 so each of the
classes that are used for manipulating
fragments are part of the standard
honeycomb API and later are going to be
reflected in this compatibility package
and they were pretty much the same as
their counterparts in the latest Android
platform so for detailed documentation
of all these classes and methods from
the compatibility package you can
reference that now when you download the
compatibility package you can also use
Java doc to generate documentation of
those those classes if you want to do
that as well so one thing to make note
is that if you are using the
compatibility package and you're making
use of some of these compatibility
classes that are listed down here below
those look rather familiar but notice
that the package names are different
here those are what you're gonna be
stuck with it's not as though these
packages are smart enough to try to
determine well what version of the API
does the actual device app am i running
on honeycomb and if so switch over to
the native implementations on the system
so to speak so if you are using that
ability package that's what your
application is going to be run against
no matter what version the actual device
is actually running now that means that
as new features get added to the api's
Ice Cream Sandwich comes out and that's
your new classes and methods to the
fragment capabilities if you're using
the compatibility package you're not
going to get them even if you run on Ice
Cream Sandwich so just be aware of that
and of course many bugs are detected and
are fixed in the mainline release it
might be a bit of a lag before those are
reflected into that ability package
you'd have to download the new version
of compatibility package and rebuild
your application against that as you can
see three primary classes fragment
fragment manager and fragment
transaction are going to be present in
the compatibility
package there's also one that we're
going to have to use that is unique the
compatibility package it's called
fragment activity you must use fragment
activity as the base class for all of
your activities that are going to be
using the fragment capabilities as well
as loaders if you're going to be using
loaders in your activities as well so
that's one of those things it's really
easy to forget particularly if you're
taking an existing code and you are you
know retrofitting it to use fragments
it's really easy to forget to change
your base class for your activity
there's also the issue of well that's
fine for just a standard activity but
what if you're using preference
activities of base class or list
activity when there's a an icehole
convenience there well we'll see that
there's something in in store for us
that we'll be able to use instead but we
still have to use fragment activity as
our base class if you're using
compatibility package download this you
can use the SDK manager it's part of the
standard Android open source our
repository just grab that and install it
once you've got it on your development
system you then need to add the jar file
from the compatibility package into your
project and then include it in your
projects no bet now you can certainly do
that by hand you know go to your SDK
folder or look in the extras folder find
the jar file for it you know copy it in
there and then update your build path
but in the latest versions I have the
Eclipse ADT plugin there's nice little
convenience you can just do a
right-click bring up the
context-sensitive menu for your project
and then near the bottom there's set
Android tools and there's add
compatibility library there now when you
do that if you've ever tried this before
you notice it actually goes out and
fetches the compatibility library live
from the site so it's always been to try
to fetch the latest and greatest version
and install that so you don't have
network activity that might fail ok so
before we get into actually creating in
fragments let's take a look at the
fragment life cycle so just like our
activity class and most of the other
application components are based on the
template method design pattern fragment
base class all those
same type of pattern there are a few
dozen methods that are defined on the
fragment base class and so for us to
implement our own fragment wheel
subclass fragment and override the ones
that make sense for us that we need to
implement customized behavior now the
most important methods TVI keep in mind
we're going to be those related to the
lifecycle of the fragment and these are
very similar to the lifecycle methods
that we see for an activity in fact six
are the seven basic activity lifecycle
methods are also present on track the
only one that's missing is on restart
and fragment does not have an on restart
method now the fragment you know
implementation the purpose of all these
lifecycle methods are very similar there
is a slight difference that we'll
discuss in just a moment but for the
most part if you know what you're
typically do in a non start or a non
resumed and in activity you know what
you need to do in a fragment as well the
fragment supplements this list of
lifecycle methods with five additional
ones I think I count this correctly and
so those are mentioned down here at the
bottom the first one that's invoked in
the lifecycle of a fragment is on attach
and this is notifying the fragment after
it's been instantiated that has just
been attached to an activity and the
fragment will get a reference to the
activity it's now hosted in as its only
argument after the on attach then the
oncreate method of the fragment is
invoked this is our chance to initialize
our fragment and then oncreateview and
so that's where we're supposed to
actually create the view hierarchy for a
fragment so the fragment the overall
fragment initialization and the visual
and view initialization are separated
out the two separate methods so that's
something else that you might not have
to adapt existing code to if you're
taking existing activities and
transmogrified than them into fragments
how many people have transmogrified so
that's that's our own great then after
all on create view these system is going
to invoke on activity created and this
is lying the fragment know that its host
activity has now been completely created
so this will be invoked only once the
activities on
method has returned so if you need to
hook into that that's our point okay at
this point we're now into familiar
territory on start we'll be invoking the
pregnant is become invisible on resume
when the host activity is becoming the
foreground activity on pause when it's
no longer the foreground activity on
stop when it's no longer visible and
then we get a difference again rather
than just a straightforward destruction
there's a non destroy view method where
we're supposed to tear down the view
that we created and our on create view
that's normally done for us
automatically but if there's any
additional type of cleanup that we need
to do for a fragment we could override
it and do it then then we have our on
destroy and then finally there's an on
detachment that letting the fragment
know it is no longer attached to the
host activity and once that method
returns then the fragment object will be
marked for garbage collection so one
things that isn't in the documentation
is that for all of these lifecycle
methods except for oncreateview
you have to invoke the superclass
version of the method if you overwrite
so if you're providing your own custom
implementation of onstar upon pause on
detach or anything else
you must invoke the superclass version
of that method if you don't chose an
exception which the documentation told
is that but it doesn't count at all
partly the only exception is
oncreateview so we don't need to invoke
the base class version of oncreateview
there's really no point to it's a it's a
it's a do enough and no op stub method
that's all it is at least that's what it
isn't compatibility library i'm assuming
that's what it is in the formal
honeycomb source though I've not been
privileged to see that okay so if you're
going to be creating your own fragment
you're gonna have to create your own
subclass of the private base class and
so you know typically you know you're
going to implement some sort of on
create method you will have an on create
view if you want to have a visual
interface for the fragment like I said
that's optional you might not need that
in which case you don't need to override
that method and then you would use the
other methods in the way normally what
onresume you probably allocate extensive
resources that
cost love battery life or monetary cost
and then you would release those type of
resources in your own boss okay so let's
say that we want a visual interface to
our fragment well we're going to have to
create some sort of Triton layout and
that's going to be taking place in our
on create view callback method so we're
going to have to implement that now the
return value on create view is going to
be the route view of the fragments view
hierarchy so somehow we're going to have
to create that view hierarchy now we
have the same options that we do when
we're creating a view hierarchy for an
activity we can either do a programmatic
way where we create all the objects by
hand in Java code and set up all their
properties and hook them all together or
we can do the declarative approach where
we create an XML layout file and then
inflate that layout of course that's
usually the simplest way to do it and
I'm a lazy programmer so I'll take the
simplest way whenever possible now
because that is the most common pattern
that we see the designers of the of the
uncrate view method went ahead and
supplying this with a layout inflator as
one of the arguments that are passed
into oncreateview also passing in the
reference to the view group that is
gonna serve as the parent of our
fragment who knows that might be a
linear layout or a relative layout or
whatever type of layout the activity is
allocated to host its fragments so
here's an example where you know it's
just a typical layout file that put
together for a fragment you can see that
we have a route geometry manager in this
case I used a linear layout because it
was a rather simple layout put together
a few components in their text view that
text and button nothing here that is in
any way different from what you'd do to
create a layout for an activity this is
going to be one part of an overall
activity's layout so now that we've got
our class or yes I did
I missed the Java code so I'm just
showing you how you'd actually you know
inflate that in the oncreate view method
when we unmagnified that a little bit so
you can bear see all this
so just focusing on me oncreateview
we're using the inflator parameter that
was passed into us and we're breaking
its inflate operation the first argument
is the resource ID of the layout that we
need to inflate so here's just a
resource file that I created for my
fragments layout the second argument is
the view group that's going to serve as
the parent
well that was passed in as the second
parameter to the oncreate view and then
the third parameter that argument that
we want to provide to the inflate
operation is false we're saying that we
want the inflator to inflate or layout
but not attach the layout to the parent
container now that seems odd at first
because say well don't we want our
layout hooked into the parent is that
the whole point of it well yes yes
however the system is going to do that
for us automatically when we return our
view the root of our layout hierarchy
from oncreateview the system is
automatically going to attach it to the
parent layout at the appropriate point
in time so if we provide a value of true
here it's going to be trying to hooked
up twice that's not going to be very
successful so you always put a false it
now at this point we could do any of the
rest of our UI setup that we needed to
do for example if we need to install
listeners on buttons or other types of
objects we could do so so here I'm
showing an example of just using the
fragment itself as the listener for the
button click operation so just as you
might do with an activity and overload
it with additional responsibilities such
as listening to button clicks we can do
the same thing with the fragments that
we create as well yes
well for a fragment I cannot think of
any case where we ever provide true here
I mean the the layout and flavor is a
general-purpose class in in Android so
it's what's used in general like when an
activity when you do a set content view
it's actually responsible for parsing
the XML if you provided and layout and
doing all the inflation and then
attaching it to the route view of the
entire window itself so because it is a
general-purpose it does have that
parameter we can choose to or false but
for a fragment we always want to use
false to defer that to the system itself
okay so what next well we've got our
fragment now defined we've created the
fragment class we've got our we've got
our layout traditionally different put
into an activity somewhere so the
easiest way to use the fragment is to
aesthetically include it into an
activity layout so let's say that we've
got an activity layout file well we can
actually use this element type fragment
and yes that really is lowercase F
fragment to just indicate where in the
activity we want this fragment to appear
we want to then specify the Android name
attribute and provide the fully package
qualified class name of the fragment
that we want to include and then any
layout attributes to control the size
and positioning of the fragment within
the activity's layout now every fragment
that we create has to have a unique
identifier so that we can you know get
access to it programmatically and
there's a couple of different ways we
can do so one is that we can supply a
unique android ID attribute here in the
layout to identify it another
possibility is to provide an android tag
which is just an arbitrary string that
we assign and we'd be able to do lookups
on the fragment at runtime using that
now if we fail to do either of these in
this approach this static inclusion of a
fragment it's going to try to use the ID
of the fragments container it's its
route view of its hierarchy but you
really should use one of these ways of
uniquely identifying fragments when you
insert it so here's an example of an
activity
we're decided to include a couple of
fragments you can see we use the fully
qualified class name and then any type
of layout parameters that we'd like to
use okay so that's static and that's it
now let's talk about the fun stuff the
interesting things where we want to
dynamically create and add fragments to
our activity at runtime
people swap these things out and do
dynamic behavior now the first step in
doing that is to get a reference to the
fragment manager now the way you do so
depends upon whether using the honeycomb
API S or the compatibility package in
the honeycomb API is the activity class
has yet fragment manager and it returns
a reference to the fragment manager on
the other hand if you are using the
compatibility package the fragment
activity has a get support fragment
manager that you have to use that's
really easy to make that mistake to call
the wrong method call there I've done
that several times there so make sure
you're using the right one okay so now
that we've got a reference to fragment
manager we need to begin a fragment
transaction even if there's only one
thing we're going to be doing on one
fragment we still need to start a
transaction and we do that by invoking
the begin transaction method on the
fragment manager and this is going to
return a reference an instance of a
fragment transaction object okay so now
we got our transaction object we're
ready to go so if we haven't done so
already it's time to instantiate an
instance of our fragment we just invoke
its constructor new my custom fragment
or whatever it is we got that and then
on the fragment transaction we're going
to invoke this add operation and we need
specify the view group that is going to
be a parent of the fragment and we do so
by specifying its ID now optionally we
can also provide a string tag to
identify the fragment as well now once
we've executed the add then we need to
commit the transaction by executing the
commit method on that fragment
transaction so putting it all together
this is what it's going to look like
getting your fragment manager which over
way is appropriate the honeycomb API or
the compatibility package there we're
getting our fragment transaction we got
our fragment
at it we commit it sensible if only were
that simple
there is a catch it has to do with
trying to buy sideways one time
configuration changes you know if you've
done any type of and reprogramming you
know in a runtime configuration change
this system bounces the activity it
destroys the activity and then it
recreates the activity so it can refresh
itself with all the new configuration
options and your new resources that
needs to load up in the new
configuration well once a fragment has
been added to an activity if the
activity gets balanced if it gets
destroyed and we've created because of a
runtime you know reconstruction
configuration change like that the
fragment gets automatically recreated as
well automatically which is great unless
you were planning for that because if
you happen to have like this code here
creating and adding fragment in your
oncreate method of the activity and you
just always do it well now you've got
the old version of the fragment they got
recreated and this new one you're adding
in as well and there are these things
that not really documented very well you
find it out the hard way when your
applications break so what do you do
well you need to figure out are we
getting recreated because of a
configuration change or is this the
first time through and the way we can do
that is in our activity check bundle
that bundle is I've been containing all
you know the runtime configuration of
the old activity that is being recreated
now if this is the first time the
activity has been created that bundle
argument is going to be null and so
that's your signal ah I need to create
all my fragments from scratch if that
bundle argument is not null we are
recreating the activity because of
configuration change and that means that
we should not recreate any dynamic
fragments they are already being
recreated for us so it's a simple test
here's an example doing it in the
oncreate where we just check that bundle
that we get and our activities on create
if it's not null then we do our dynamic
fragment initialization and adding
otherwise we skip this step
okay now what about saving your fragment
state you know the whole idea of a
runtime configuration well what if
there's additional state information
that I need to save
well in an activity there's the on set
instance State method
it's invoked automatically by the system
when it needs to save the state of the
activity usually because of
configuration change and it's provided
with a bundle
well the fragment class has a non save
instance state method as well and it
works pretty much the same way as the
activity class the fragment is going to
automatically crawl its view hierarchy
any views in the hierarchy that have IDs
it's going to invoke their on saving
some state methods which will you know
say whatever dynamic State those views
have and then as the system recreates
the fragment it will use that
information to resuscitate my fragment
in the state they was producing now I
have some additional information that
wouldn't normally be taken care of by
this default behavior I have the option
of overriding the on save instance State
in my fragment and then I'll just be
putting it into a bundle just like you
would in an activity and then I would
use the values from the bundle in my on
create my on create view or my on
activity creative method those are the
three objects that the bundles provided
to now there is one difference here
versus an activity a fragment does not
have an on restore instance state method
so you can't override that in a fragment
by the way you could in an activity know
if you've done any work with activities
and you've had to save state information
of an activity because of configuration
change you know sometimes that this
bundle isn't enough you've got some
heavyweight object that you want to
retain across instances you know you
bring the activity down bring it back up
and say wait a minute I got a lot of
data that I pulled off the the internet
or you take a lot of calculation to come
up with I don't want to recreate all
that from scratch and so the activity
has a technique where we can say Oh we'd
like to have the system hang on to this
object for us and then give it back to
us once the activities that we recreated
it's not all that obvious to do it's a
cab clunky and if there's multiple
pieces of information you want to
you know it's not an insurmountable
problem just bothersome turns out there
with fragments it's a lot easier the
fragment class has a method called set
retain instance it just takes a boolean
value and if you give it a boolean value
of true you're asking the system to
automatically retain this fragment
object in memory as the activity goes
down and gets recreated and so it's not
as though it's getting destroyed and
recreated in the same state it is
hanging around in memory retaining all
of its state information and we can do
this for as many fragments as we like so
if we've got you know three or four
fragments we could set regain instance
to true on all of them if they all have
important information that I don't want
to recreate from scratch now when you
set a retaining instance state to true
then what's going to happen is that when
the activity is going to be recreated
the fragments on destroy method will not
be called and then it's on create method
will not be called either and then
fragment will be retained in memory but
all the other fragment lifecycle methods
are invoked in the typical sequence now
one thing that I did get burned by when
Iced experimenting with us and learning
more about fragments is that if you use
the set routine instance to true then
the bungo passed to the fragments on
create view and on that could be created
is always going to be null now I've done
logging and I've determined that the you
know the the what's it called I really
forgotten the name of it the on save
instance state methods don't gets called
so I thought it was storing information
into a bundle but no that bundle just is
ignore it it's not returned to my
fragment when the fragment is you know
being invoked through all these methods
that's because it didn't get destroyed I
assume as the is the rationale there
okay so this means that we don't really
need to use that activity classes on
routine non configuration instance
method anymore which is good because
it's impossible to say thank you mister
code completion otherwise I'd never type
exactly
and that's why it has been deprecated as
of API 11 in fact if you are using the
compatibility package you cannot use the
activities on retain non configuration
instance method in the fragment activity
class it's probably compatibility
package it has been overridden and
marked as final the fragment activity is
using it for its own internal purposes
of retaining these fragments and loaders
and it doesn't want you messing up with
that so if you were using on retained on
configuration instance that is something
that you're going to have to change as
you port code choose your fragrance okay
now just an aside here it's pretty
straightforward what if you want create
a fragment with no left now why might
you do that well maybe you just create a
fragment because you want to maintain
some state information or perhaps you
wanted to manage a thread or an async
task and you'd like that to be retained
across activity bounces and you'd say I
don't need the actual visual interface I
just want it to store all this
information okay well fragments are
easier to do no need to create a layout
file no need to overrate oncreateview
well that case out we actually use these
well you're just going to instantiate
the fragment object you know invoke its
constructor and then we're gonna use a
fragment transaction add method to add
it to the activity in this case we use a
different version of the add method
we're not going to be adding it to a
container we use a two argument version
where the first argument is just the
reference to the fragment being added
and then the second argument is a string
which is the tag that we want to assign
to this fragment so that we could then
programmatically access it later on so
this is just an example of how we might
go about doing one of these but what's
the same pretty much as dynamic way
adding a fragment with a way out it's
just that the add method is slightly
changed I've mentioned that sometimes we
might need to go looking up fragments
well that's what fragment manager can do
for us it has a couple of methods for
that one is find fragment by ID and just
give it the resource idea of the
fragment returns a reference to the
fragment if it's currently
existent within the current activity and
there's also the fine fragment by tag
just give it the string tag and it too
will return the fragment reference if it
exists or null if it doesn't exist in
the activity currently of course if
you're gonna be manipulating the same
fragment over and over it's usually best
to retain a reference to that fragment
and just cash it in some sort of you
know instance field of your activity now
so far the only dynamic fragment
operation we've dealt with is the add
operation bringing a new one and putting
it into an activity but the fragment
transaction class has several other
methods that we can invoke as well
addition to add there's removed it says
we are going to be destroying this
fragment completely unless we're gonna
be using the back stack and I'm gonna be
telling about the back stack and its
purpose in just a moment but remove says
we want to take that fragment out of the
activity replace is basically doing a
remove and add alt once you're going to
identify a fragment that you want to
remove and give it a reference to
fragment you want to add in its place we
also have the ability to hide or show a
fragment this does not destroy the
fragment it does not destroy the
fragments view it simply toggles the
visibility of the root view group of my
of my fragment that can often be a
lighter-weight operation corresponding
show for that and then an api 13 they
added two new ones detach and attach so
you can read up about those basically be
catching it restoring its view hierarchy
but retaining the fragment instance it's
not a destroy just you know detaching it
from the view hierarchy and then attach
we can reattach or previously detached
component once again discovered through
hard trial and much error those static
fragments the ones that you include in
an activity layout you can't do any of
this with you can't go around removing
and replacing them you can hide and show
them but that's the only thing you can
do you can hide a static fragment or
then you can show it but you can't
remove it you can't replace it if you
try to do so your applications going to
blow up often in unpredictable ways but
then sometimes it's very confusing
because you do an operation it looks
like the fragment still on screen
you try manipulating the fragment and
you get illegal state exceptions or no
pointer exceptions or other types of
weird behavior
I haven't found this documented anywhere
interest you know kind of that knowledge
that people get very well the grapevine
like this yes well there's some slight
overhead in using a fragment versus just
putting it all directly in activity but
overall the the overhead is going to be
minimal it's not as though you know
fragment operations are taking place
multiple times a second typically fairly
infrequent operations and I've not
noticed any significant performance
degradation using fragments versus just
putting it directly in that giving it's
a lot of detailed checking of the memory
impact of you know how much memory does
using a static fragment versus how much
memory using a dynamic fragments you
know perfect would just be a number of
temporary objects that be created they
would have to be garbage collected at
some point I my gut tells me that I'm
using dynamic fragment manipulation I'm
probably creating a lot more temporary
objects that will then require garbage
collection static is simply inflating
the view once and then it's pretty much
there it's more it's it is well I'm a
friend I have to do is take this offline
because I have several more slides to do
so we can talk afterwards if you like
okay so so what do you want to do if you
want to do some fragment manipulation
well first of all you have to begin a
transaction just like we did when we did
a simple ad then perform any number of
fragment operations you want it can be
on any number of fragments they can
actually be in different containers it
doesn't matter
add your moves
cetera and then you finally do a connect
to apply the transaction to the activity
just a note here is that you can only
commit a transaction prior to the
activity saving at state so technically
the commit has to take place before the
activity would invoke on save instance
state the whole point is is I could be
on savings and state is trying to pickle
the state of the activity so it can be
resuscitated later on and if you're
trying to do some fragment manipulation
the same state is known Walker and
resent the last gem you know the last
state of the activity so you'll get an
exception you try to do that after the
on save instance state but you know this
is showing an example of doing some
fragment transactions and for all these
fragment transaction methods you get a
reference back to the original fragment
transaction object so it allows you to
do method chaining like this to kind of
abbreviate your code if you like to now
the manipulation that we do we have the
option of including in a back step so if
we're working with activities if I am in
one activity it launches another the
system is going to remember the task
stack the activities that we're going
give da didn't launch B and if I do a
back button it would then destroy the
top activity and take me back to the
previous activity so what if I've got
fragments incorporated in my in my
activity and I've been doing dynamic
behavior
well the default behavior is that if I
press the back button it destroys the
activity it doesn't matter how many
fragment transactions I might have
committed it just says that I could be
stopped but I do have the option of
taking all these fragment transactions
and incorporating them into the back
stack as well in my fragment transaction
as I'm doing a manipulation any type at
all adds removes replaces or anything
else if I do an ADD to back stack method
before doing the commit that's telling
the activity remember this state and so
then if I were to do a back button the
user presses the back button it will go
to the previous fragment state before
that transaction was committed and so we
could stack up as many friends acts
stages we like and back back back back
back it's only once we popped all of the
fragment transactions off the stack that
pressing the back button again will
destroy the activity okay so action bars
option menus can fragments play with
those - why yes they can yes they can
so my fragment you can say hey I've got
a set of action bar items or I've got
some option menu items that I want to
include now for us to do that in the
fragments on create method the fragment
must invoke set has options menu telling
the activity Hey Hey look at me I've got
option menu items okay so once we've
done that then in our fragment class we
can provide our own implementation of an
on create options menu saying when the
option menu is created here are the
items that we want to include in it and
then we would provide an implementation
of all options items selected so that we
could detect if any of the items that we
created had been selected and then
optionally if we want to we could also
provide implementations for the other
option menu manipulation items like on
prepare on options close and non destroy
now the activity needs to work and play
well with this so we've got my activity
then what it needs to do in the activity
on create options menu for example it
can do its own setup of optional items
it can say I've got three that I want to
add but then the activity must invoke
its super version you know the base
class version of the oncreate options
menu to say oh and now let's go ahead
and do the rest of the setup and so the
fragment activity or the activity base
class would then look at all the
fragments that registered as having
action items and invoke their on create
options menu similarly in the in the
activities on options items selected it
should look for any items that it added
and then invoke its base class on option
is selected method so that it can then
propagate that call down to the fragment
so they can detect if any of their items
had been at it now what about the
dynamic behavior what if a fragment gets
added or removed
one time well the system takes care of
that Franklin gets added that has
optional items those get automatically
added to the options menu or action bar
if that fragment is hidden or remove
they're automatically taken place so the
action bar always reflects the current
state of the visible fragments that are
incorporated in the activity and so just
an example of code that would do this
this is an activity so we're showing
that the on create options menu here is
invoking the base class so it can do the
fragment initialization and then
inflates its own menu items in returns
true to indicate go ahead and display
the menu in the options item selected
somebody you know selected one of those
items or in this case we're testing the
ID the item selected and looking for any
that the activity put in it and then if
it doesn't match any of the activity put
in it we just say let's kick it up to
the base class on options item selected
and let it check all the fragments the
fragments then would have their own
implementations the oncreate indicate
that they have optional items the
oncreate options menu to then inflate
their items into the menu and then the
selected to check for the ones that they
explicitly add again yes so hope you got
well in that case then the overflow
options menu would be displayed full you
know options menu or some way the action
bar those are dendup in the overflow
menu of the action bar okay know we've
seen how the activity can create these
these fragments and how frightens can
contribute items there and in menus what
other types of communication can take
place
well activity create the fragment it's
got a reference to the fragment so
basically any public method on that
fragment is fair game so it can directly
access those public methods no problem
if you didn't retain a reference to the
fragment you can always work it up with
the fragment manager using fine fragment
ID or fine fragment by tech what about
the other way well the fragment class
has a get activity method which will
return a reference to the hosting
activity and then I could invoke any
public
it's on my activity then contained
within for example you know I could say
hey I'm an in fragment here and I want
to get up to my activity and I want to
go explore its new hierarchy find view
by ID manipulate the things directly
anything public I would have accessed it
but you probably don't want to do that
and so I'll tell you both best practice
approach to that in just a moment I do
want to make one comment here though
once we're talking about interacting
with the environment is that the
fragment class is not derived from the
context base class the fragment is not a
context and so if you need a context for
anything within your fragment you're
going to have to obtain it you can
either you know just use the activity
object music yet activity and use it as
a context or through the activity you
could invoke get application context to
get the application object is the
context and so particularly for anything
that's going to hold on to a reference
to a context for a long period of time
you're probably going to want to get the
get application context yeah you don't
want to hold a reference to an activity
that the system is trying to destroy so
don't hold the context longer than you
do it need it okay so some just general
some best practices here one designed
for loose coupling and this is one place
where I think that the examples on the
Google site really are bad if you take a
look at you've got this article and
selector you know fragment and an
article Heuer fragment and you've got
the article selector that's asking the
activity hey activity I need to check
the container that you've got over there
does it actually have the other fragment
visible and that is really tightly
coupling this fragment with the way it's
going to be used you know what if you
wanted to reuse this fragment as a
standalone fragment and another activity
well suddenly all of that introspection
of its environment doesn't apply anymore
so you really want to be careful about
making your fragment too aware of its
hosting activity because then that's
going to greatly reduce the amount of
reuse now on the other hand is kind of
difficult to avoid the other way I mean
the activity has to have certain
knowledge of the fragment to interact
with that so that's okay because you're
usually designing the activity knowing
the
capabilities of the fragment saying the
activity needs to do this and the
fragment is a core component of that so
that tends not be the big issue the big
issue is tight coupling of the fragment
to its hosting activity so one of the
best ways to avoid this Java interfaces
you define callbacks so you say okay
this fragment is going to have a set of
callbacks as defined by an interface
that it provides and so then we can
register a listener to detect these
events going on in the fragment so we
can either have the hosting activity
implement the interface if you want or
you could you know provide a
registration method on the fragment
where we could register any listener
object as long as it implements the
appropriate Java interface so here's an
example we're creating a fragment
definition here and what we're saying is
that we're going to declare a nested
interface called on title selected
listener and say there's only one
callback method called on title selected
so if you want to be a listener this is
the method you have to implement now if
we decide that we're always going to
require the activity to implement the
interface where we could go ahead and
check for that in the on attach method
of the fragment as the fragment is
attached to the activity we could then
just try to do an assignment try to take
this activity cast it to the listener
type if that there is a class cast
exception hey you're trying to put me in
an activity that doesn't know how to
listen to me
and so you're just gonna bomb out at
that point but as long as the cast is
successful now we've got a listener and
so as something interesting occurs in my
fragment I can then just go to the
listener and invoke the callback method
to add register and so there's just
activity source code showing you the
implementation how we doing on time I'm
assuming I'm pretty much out okay I
can't tell him where I am
oh four or five how'd that happen okay
so then this gets to the other best
practice I was going to point out using
the activity as I call it a switchboard
so just basically saying the activity is
where you should have the communication
so the fragment doesn't know am I in an
activity
with another fragment they work and play
with is that other fragment hosted and
another activity it shouldn't care it's
the activity that should know how to
glue everything together and so through
the callbacks that a that a fragment
could could invoke the activity could
then determine all this this fragment
has indicated something has occurred I
know that I the activity I'm hosting a
companion fragment I would just invoke
the proper methods on that companion
fragment to invoke its behavior but if
we've had to refactor it for a smaller
screen where both fragments wouldn't fit
into the same activity well in that case
we write the logic in my activity to say
well in that case I'm going to have to
start another activity where I know it's
hosting that other fragment so don't
make the fragments have to go and figure
out where these are put that logic in
the activity I'll make those fragments
more reusable is keep in mind fragments
don't have intent filters they can't
detect intense went on activities can't
so that's another thing to keep so that
pretty much exhaust the time there's a
few other things here I'm not going to
have fun get into if you're interested
the PDF that's available on the
conference site will talk a little bit
about more about implementing dialogues
using fragments and talking about a few
other specialty fragments the list
fragment which is a predefined fragment
that hosts a ListView it's kind of like
the analogy of a list activity a
preference fragment which you know sets
up a preference screen for you pointed
XML preference resource and they'll
create the preference screen and all the
editors for it so it's the analog of the
preference activity and there's also a
special web for a web view fragment that
is a fragment that's got a pre-built to
a web view set sitting at just a
convenience there as well
so that's that's it then I'm gonna be
hanging out if there's any questions
afterwards but this point</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>