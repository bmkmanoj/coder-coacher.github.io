<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Chome GPU Team: Graphically Speaking with WebGL | Coder Coacher - Coaching Coders</title><meta content="Chome GPU Team: Graphically Speaking with WebGL - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Chome GPU Team: Graphically Speaking with WebGL</b></h2><h5 class="post__date">2012-05-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sdpvstBQRp4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Ken Russell I am actually not
Neil trivet not the president of the
Khronos group but I am the chair of the
WebGL working group I will be presenting
Neil's
slides given that he is in Dublin for a
Cronus face-to-face meeting and the
topic that I would like to talk to you
about today is the ecosystem around
WebGL and WebGL which are two of the
graphical and compute acceleration API
is that Cronus is developing for the web
so the the topics that we'll go over
first will do a very quick introduction
to 3d I mean has anyone programmed using
3d graphics before here in the audience
small percentage like one person okay
so we'll break down a little bit how the
3d pipeline works talk about the need
for accelerating api's like 3d like web
CL and then go into a little bit more
about what exactly these api's provides
to the web echo system we'll talk a
little bit about WebGL tools and
frameworks that help developers that
aren't too experienced with your 3d
graphics actually get stuff onto the web
quite easily and then we'll talk a
little bit about going from 3d graphics
to actually lower-level computation and
how web CL can accelerate these sorts of
computations in the web browser and then
talk a little bit about actually it's
Neil's favorite topic and it's also a
pretty cool one what if we could do
augmented reality applications in the
web browser involved with that moment
that entail what would that take and
then we can have plenty of time for
questions and my colleagues in llamó
from Google who also works on the WebGL
implementation on in Chrome will next
talk about WebGL in more detail showing
you exactly how you can construct a very
simple scene from nothing to having at
least a shaded triangle on the screen
and possibly more topics we haven't
actually synced up on all of the slides
that he will be presenting today so
question number one what what is
real-time 3d graphics I mean you've all
seen it in the movies it every film that
comes out nowadays
has CGI for all the special effects they
really don't like to put actors at risk
anymore nowadays falling off horses or
anything like that all of this stuff is
done in the safety of a studio with
plenty of crash pads around and then
computer graphics is added later to make
it look realistic and anybody play games
computer games okay there there it is
pretty much every game that comes out
today on PCs on mobile consoles is has
some element of 3d even if it's only a
2d game you typically have parallax and
other effects done using 3d effects
using you know multiple planes that are
whose textures are uploaded to the
graphics processor and who are
translated around using commands that
are sent down to the GPU so 3d graphics
fundamentally is the science and art of
using computers to create and enjoy
beautiful and interactive experiences
and the piece of silicon that makes this
possible in real time is the graphics
processing unit or the GPU and did
anybody here play doom when it came out
I mean I love to do we when I was in the
in college we hacked doomed to death not
only did we play it a lot late at night
but we also took apart the level files
and and did things with them so we we
had the privilege of having some silicon
graphics machines which were the top-end
graphics processor is really super fast
CPU central processing units that you
could do a lot of physics and other
kinds of simulation as well as amazing
graphics pipelines and this is you know
there were the genesis of the entire 3d
ecosystem today so we took Dhoom apart
and took the level data and did things
with it like put the user you know you
the person into the doom environment or
put virtual interactive creatures into
the do environment and had them
wandering around so not just monsters
and you know chainsaws but actually like
dogs and cats and hamsters wandering
around the the halls of these huge doom
levels and it was a blast but you know
that the techniques were fairly limited
fairly limited what you could do back
then because all the 3d actually had to
be done on the central processing unit
at least on PCs and that's why do's
visual effects were kind of blocky and
then doom 4gl came out where it was
actually running on the graphics
processor in Silicon Graphics machines
and that was another major step forward
in terms of speed and it's a mystic
quality and since then you know quake
came out and a ton of other games and
nowadays you see the the Samaritan demo
that was shown at I think that was at
SIGGRAPH 2011 and it's just incredible
this is running on like I think two
Fermi cards from Nvidia I mean it takes
that much graphical processing power the
two highest end cards side-by-side in
order to get these amazing lighting
effects but but the active system has
just evolved dramatically and and the
effects that are possible even on a
mobile phone today are pretty amazing
and we'll show some examples in a bit
now and what's super cool by the way is
that this is all real time you can do
these think these kinds of effects it's
60 frames a second that's what's so cool
about it you can imagine an effect that
you want to put in front of the end user
and you can get it to them you can
deliver it to them over the web as we'll
discuss and get some amazing visual
effects that run on every kind of
computer out there be it a handheld cell
phone or a high-end workstation so
what's 3d basically 3d is a bit of a
cheat okay it's it's an art of faking
what looks photorealistic by doing some
by using heuristics that have been
developed over the years the earliest
sorts of 3d effects were fairly simple
first of all you have you know that
things that are closer to you appear
bigger things that are further away
appear smaller this is a very
straightforward geometric relationship
that is I guess technically called
perspective projection but you can
actually draw you know using just high
school geometry similar triangles
showing the relationship of objects the
objects perceived size depending on how
far
way they are from you and it really just
amounts to dividing by Z the farther
away in the z-coordinate the object is
from you the smaller it appears to be
because you're dividing by a larger and
larger value as it goes away from you so
the earliest 3d was basically just
taking the the vertices of your 3d model
perspective projecting them and then
shading them in such a way that it
looked like there was some kind of light
effect going on but the the heuristics
have dramatically increased over the
years and again we'll touch this and
touch on this a bit more so there's
usually some kind of a database or some
stored representation of your 3d models
and the surfaces of the objects that
you're gonna be displaying on the screen
are broken down into a grid of it not
just polygons but actually triangles ok
the triangle is the key element of 3d
graphics does anyone know why the
triangle is the key element of 3d
graphics anyone anyone it's it's
actually a really simple answer the
triangle as opposed to say a square or a
quadrilateral it's it's absolutely
determined which plane that triangle
lies in I mean the three corners of the
triangle determine actually a plane in
3d space
if you have four points it's a bit
ambiguous they don't necessarily have to
lie on a plane they can twist a little
bit and then you have to decide okay
well if I want to disambiguate what
surface I'm trying to represent do i
connect this diagonal or do i connect
that diagonal okay this is why the
triangle is used as the basic primitive
on graphics processors that there is no
ambiguity about how it's going to be
rendered okay how each of the points
that are inside the triangle show up on
the screen so the surfaces of the 3d
objects that are rendered with WebGL
with any of these api's are broken down
into a grid of triangles a mesh of
triangles and the points of the
triangles live in a 3d coordinate system
3d space
early in in the previous fixed-function
3d ecosystem and we'll talk about what
that was and where we are now you would
associate a material with each vertex
you'd say this is blue or it's shiny or
something like that and the the graphics
card would figure out how that vertex
was supposed to be colored depending on
that information so for example if you
have a blue vertex out here and it's not
shiny and you have a white light source
pointing at it it's gonna be blue
because you know the white light source
is illuminating this diffuse blue points
excuse me but if the vertex is is shiny
you may get a bit of a glint coming off
of the light source right okay and for
that reason the the vertex would
actually show up white not blue which is
interesting right so you get different
visual effects depending on the kinds of
materials you apply to the 3d models
that your you're displaying and finally
the vertices of course are positioned in
a 3d coordinate system right this is the
the typical thing that you do when
you're a computer graphics programmer
you make your right-handed coordinate
system positive x positive Y positive Z
and then you position your your objects
in the scene and it's linear algebra
it's matrix math that allows you to
represent how these objects move around
in the scene okay so how does it work
the first thing that's done is on a per
triangle basis the graphics card
projects via the vertices of the
triangle onto the screen typically there
are there are two matrices involved in
this one is the the Mott well maybe
three one one is typically called the
model matrix and the model matrix moves
conceptually anyway moves your object
around in the 3d space okay
then there's the viewing matrix the
viewing matrix decides where the camera
that's viewing all of the objects in the
scene is supposed to be placed and then
finally there's the projection matrix
and the projection matrix warps space in
this way that we talked about you know
if you see the perspective projection
and there are different projections that
you might
choose for example you might want
orthographic projection an orthographic
projection is extremely useful for
computer aided design okay and it's a
different view because it doesn't
actually have the foreshortening that
the real world does with perspective
perspective projection there are other
two-point perspective projections that
are really useful in architecture where
you have actually two vanishing points
not just one and all of these can be
represented using the appropriate
projection matrices but once you've
multiplied using just linear algebra the
vertices of your models through these
matrices what you ultimately get is
points in 2d okay
and it's basically minus 1 minus 1 so
one by one it's a unit or maybe two
times unit coordinate system and that's
ultimately what OpenGL and what WebGL
work with and so ultimately they boil
down to a 2d graphics API believe it or
not anyway once you have the triangles
on the screen okay you have to figure
out which dots which pixels are going to
be colored in and that's what the GPU
does part of what the GPU does alright
now once we've figured out which points
which pixels were gonna color we have to
figure out how we're gonna color them
and this is where the the shading
techniques and some of the other
heuristic tricks that have been
developed in the 3d space come in so for
example with smooth shading typically
what you do is you take the points of
the triangles and you figure out what
the color is supposed to be at those
three points it's gonna be different
right because each of these points is at
a different location relative to the
light source for example you know maybe
this from this point on this triangle is
closer and this one is farther away and
they're pointing in different directions
so they're gonna get shaded differently
this one is gonna be brighter because
it's pointing at the light source this
one's gonna be not as bright because
it's pointing away from it so in smooth
shading you compute the lighting at each
vertex and then you interpolate the
colors of the vertices across the
triangle okay there are techniques for
getting enhanced real
and at a low cost like texture mapping
where you take an image and you wrap it
around your 3d model okay this was one
of the first techniques that was
developed on Silicon Graphics
workstations to dramatically improve the
realism of the scenes that you were
looking at because you didn't have to
send down a lot more triangles in order
to get something that looked much more
visually realistic and environment
mapping and is another nifty trick and
we can show a demo later where it you
actually consider your object to be
living in a space and the space is
defined by an image or actually a set of
images so you put your your objects in a
box and you consider the objects to be
reflective an environment mapping when
it's rendering the triangles it'll
bounce array off the object and figure
out what part of the environment is
being reflected off it and hitting the
eye and it gives you a very very
compelling
you know realistic looking mirrored
object and and these were some of the
techniques that were developed in the
early days of Silicon Graphics
workstations so what happens when we're
rendering our triangles the the pipeline
basically goes in the top down here
first we Traverse our object
representation our scene database and
figure out what we're going to be
rendering this the the representations
differ dramatically depending on whether
you're doing a real-time game whether
you're doing a some kind of an
architectural or CAD application but
fundamentally you have to you have a
bunch of 3d objects that you're gonna be
rendering and you have to iterate down
them to figure out what you're putting
on the screen then you may transform
them okay you move them into their
appropriate place in 3d then you say
okay well based on their current
locations in 3d and the current
positions of the lights in the scene how
are they shaded okay and then finally
they are they're rasterized they're
converted from you know a vector
representation where they're just three
points in space and they're actually
converted into what pixels are going to
be filled in on the screen okay so this
is sort of the geometry phase of the
pipeline and then
there is the rasterization phase of the
graphics pipeline where the actual pixel
by pixel operations are executed for
example interpolating the colours of
each of the vertices that triangles okay
to get the right smooth result figuring
out which dots on the screen are
actually visible because these triangles
if you consider my laptop screen to be
the edge of the screen the triangle
might go off-screen okay and then this
vertex down here wouldn't actually be
visible so the triangle be clipped at
the edge of the screen and then finally
the pixels are actually written to the
to the screen to the frame buffer so
here are a couple of diagrams of actual
3d pipelines and for comparison we're
going to show what the mobile phones
used to look like which is on the left
and what mobile phones today look like
which is on the right so on the left is
mobile phones from I don't know vintage
early early 2000 2001 2002 these
mimicked but the 3d functionality that
was on desktop PCs at the time okay and
it had heuristics like lighting texture
mapping environment mapping they had a
little bit of additional fog for example
they had you can actually see these
stages by the way in here so if you can
see my mouse this is the part of the
pipeline that would implement the fog
function all right there was actually a
special purpose thing in the graphics
pipeline that would compute fog to give
you a little more realism in terrain
rendering for example but it was very
very specialized right I mean if you're
if you're indoors for example you don't
need fog right so the previous pipelines
were a collection of heuristics that
allowed you to get pretty compelling
looking graphics and it was realized
that it wasn't enough because the the
people who were designing these
pipelines couldn't come up with all the
ideas that the graphics programmers
wanted to put in practice right all the
visual techniques that they wanted to
achieve so the major shift that occurred
some years ago is the introduction of
the programmable graphics pipeline now
you can actually right
small snippet of computer code and
uploaded onto the graphics card have the
graphics card run it and that is how it
figures out how the pixels are shaded on
the screen this is really cool this is
what WebGL is built on this is what all
phone all smartphones today are shipping
with it's called OpenGL ES 2.0 and this
shift from the old fixed function
pipeline hired on to the programmable
graphics pipeline was a major major
paradigm shift it was an incompatible
API shift so basically old applications
had to be re-written for the new API
structure but it gives you much much
more control over how your 3d scene
works how your pixels are shaded and it
lets you do amazing effects that you
could not possibly do with the fixed
function pipeline and we're gonna show
some examples that in a bit so now I
have to step back and put on my business
hat for Neil and talk about a little
what the Chronos group actually does so
the Khronos group is the organization
that develops OpenGL and develops OpenGL
ES these are the the standard 3d
graphics api's that run across multiple
platforms like linux and mac and windows
and they are creating open and
royalty-free acceleration API standards
okay and their focus is on graphics it's
on audio it's on any really any kind of
dynamic media either input or output and
we'll talk more about all of the stuff
that's going on in the Cronus group in a
bit and the Cronus group tries to
develop ap eyes they're very low-level
okay well just above the the silicon
just above the lowest level graphics
driver because historically there
there's never been any agreement on
higher level 3d graphics api's although
there's been some miraculous 3d graphics
ApS developed over the years
SGI silicon graphics had a couple of
wonderful libraries called open inventor
and performer I used both of them back
in the day and they were just a pleasure
to write program code for they were easy
to use easy to get 3d graphics on the
screen but unfortunately for some reason
and I think the reason is that they
don't
they don't admit enough use cases
fundamentally they don't allow you to
write maybe highest-performing games on
them because they're not targeted for
the game model representation they
didn't succeed but OpenGL tries to be
just a layer above the graphics hardware
than any other higher-level api's that
you want to build it's responsible the
application is responsible for doing it
and this has succeeded that paradigm
that technique so Kronos tries to target
the lowest level API so that they will
have the most that the highest
applicability to applications and Cronus
by the way is also a an industry
cooperation consortium okay any company
can join it there is an IP framework to
protect members from to allow a safe
development of intellectual property so
you can have like a two-year time window
for development of actual graphics chip
and collaborate with others that are in
the Chronos group and that that IP will
stay safe within the Khronos group so
there are a lot of members again any
company is welcome to join there if you
are an open-source software developer
and you have something strong to
contribute I actually think that the
Chronos group would be open to possibly
waving the the membership fees but a lot
of lot of Industry participation and by
the way it's a very unique forum because
for example in the development of WebGL
the browser vendors can talk directly to
the graphics chip makers we could say
okay Nvidia AMD here are some
constraints that were under can you
please make your graphics chips work in
such a way so that we can make the Web
API work better and these things happen
these sort of synergistic relationships
actually happen within Kronos
so some of the things that Cronus is
developing today WebGL is down there
we'll talk about that WebGL is built on
OpenGL and OpenGL ES the 2c based 3d API
is for again multiple platforms there is
a standard for doing vector graphics
open VG there is a new standard for
doing high performance low latency audio
called open SL and opensl es the the
Coolatta format is developed by Cronus
as well this is an industry standard
interchange format for moving 3d models
from one application to another and
there's some interest OpenCL how could I
forget the ability to to use the
graphics processor which is a real
high-performance floating-point machine
for general-purpose computation so you
can do matrix math physical simulation
very very quickly on your home PC and
one of the new forays that Chronos has
made is called stream input which is a
really really cool input API that tries
to define semantics for different kinds
of inputs that you might receive into
your application and lets the
application negotiate what it wants to
receive from say the phone because the
phone actually has a lot of sensors in
it and you want those sensors to feed an
input into your 3d game that you're
running
hopefully in WebGL and the browser on
the phone so Cronos develops all of
these kinds of standards to meet real
market needs and help drive industry
adoption across multiple platforms so
ultimately you're trying to drive user
experience you're trying to make some
amazing visual experience or visual and
audio and input experience that the user
is going to remember and the the new
mobile silicon that has advanced GPUs
built in is that the key thing the key
innovation over the past say five years
that's really driving the ability to
deploy these things everywhere not just
on a big workstation or a big desktop PC
but also things that you can take with
you so I'm pretty sure that this is the
the Nvidia product line okay and
expectations for acceleration as they're
as we go forward but you can see that
it's actually getting in like
performances exponentially increasing on
these mobile devices the performance of
a mobile phone today is dramatically
higher than what it was just a few years
ago so the the experiences that you
develop on the desktop can now be run on
a mobile phone I mean if you just think
about the way that the computing
industry in general has gone over the
past 20 years you had your Apple 2
a long time ago and now you have a
handheld cellphone that's like a
thousand times more powerful than it is
amazing and these are the kinds of
performance increases that we're seeing
in mobile GPUs nowadays that this is
neat because it really lets you write
your 3d application once deployed on the
web and run it everywhere so Nvidia in
particular in the Cronus group in
particular are interested in in getting
this these experiences wrapped up in the
web so that we can collectively write
our applications and deploy them
everywhere ok and the question is how
can the web browser actually pull in all
of these features like rich audio rich
graphics input devices cameras computer
vision all into one experience how can
the web browser be the vehicle for
deploying all of these kinds of portions
of the experience so let's talk about
each of the the sub components in a
little more detail first of all OpenGL
ES which is what WebGL is built on is
the OpenGL sub set that was designed for
mobile and embedded devices OpenGL ES
even the 1.0 version but in particular
that the 2.0 version erased all of the
legacy api's from the 3d development
over the past 15 years and it got down
to the real core of it like what do you
really need in order to put triangles on
the screen and control their their pixel
colors that you can get amazing visual
effects OpenGL ES 2 which is what WebGL
is built on is that API and it actually
is now the dominant API for mobile
devices pretty much any device that you
see shipping with say you know the
Android operating system the the rim
playbook the Apple iPad and iPhone are
all built around the OpenGL ES standard
so this is the one API if you need to
learn one API this year I would
recommend that you learn OpenGL ES
because it will let you write 3d
applications for all of these devices
and
it doesn't matter the language that
you're writing in really you'd have to
just understand the the API and its
semantics and OpenGL by the way is the
basis for many high-end content and
engines such as it suffers rage unity
Unreal Engine for example so we we
already discussed this but basically the
the OpenGL es2
programmable pipeline erased a ton of
legacy from the 1.0 pipeline and gave
you the ability to write a piece of
program code that runs it's actually two
pieces of program code one which runs on
every point of your triangles and one
which runs on every pixel that those
triangles cover on the screen and those
two abilities the ability to move your
points around in 3d space and then
control exactly how they're colored are
the two key elements of being able to
develop really amazing looking 3d scenes
so what's WebGL WebGL brings the OpenGL
es2 API to the web it brings
three-dimensional graphics to the web
without any browser plug-in does anybody
remember VR Mel from back in the day
1995 era few of us all right this is
it's not maybe you know brands new
concept it was tried 15 years ago but
VRML really didn't take off and you know
there's plenty of guesses about why that
might have been the case but in my
opinion WebGL is actually quite
different it's a different situation it
brings a lower-level API to the web one
which everybody can build on top of and
make more powerful libraries more
powerful experiences and and and
fundamentally the JavaScript engines of
the web browser have gotten a lot lot a
lot faster since 1995 and that lets you
write much more application code and
customize its behavior in ways that you
couldn't do with VRML because Vera Mel
was a bunch of fair
big building blocks but with WebGL the
building blocks are much smaller and you
can put them together you know you can
put many more than together in your
applications so basically your
application can be much much more
customized than it could have been 15
you know 20 years ago with the the VRML
solution that's why I think that this is
gonna work and why it already is working
and it is bringing accelerated 3d
graphics of the web there's no question
about that there are lots and lots of
demos and I'm gonna show you some of
them today and show you where to find
more so WebGL hooks into the html5
canvas element and interoperates pretty
cleanly with all the other Dom content
that you have on your page so in
addition to being able to overlay and
underlay text and build your UI is in
HTML you can also bring in images from
your web page and use them as textures
in your 3d scene so it builds on top of
the infrastructure that's in the web
browser and so the the convergence of
things like faster JavaScript engines
wide availability of OpenGL es2 and
multiple browsers running on multiple
platforms really makes this the time
that I think this is going to succeed as
a concept 3d on the web just go to a web
page and you you have this amazing
interactive experience so there's an
echo system around WebGL and it's it's
really interesting this is a cool
diagram of what's actually going on in
the working groups so on the desktop
side the opengl architecture review
board evolves the capabilities of the
graphics processors that you see in
workstations and in PCs ok so the
leading edge functionality typically
does come out on desktops
then that these ideas come down into the
OpenGL ES working group okay from OpenGL
and there you know distill down and
maybe simplified maybe some features are
removed so that the API can remain
simple and the silicon can be simpler on
mobile phones but that's what shows up
on your smart phones and that that
direction of a flow of ideas is what
happened and what allowed OpenGL es2 to
develop shader based graphics for your
and WebGL is building on OpenGL ES so
that as the phones evolve in capability
so will WebGL and also so that WebGL
will run on all of these devices so
WebGL exposes the semantics of what's on
your mobile phone even on the desktop so
it doesn't expose everything that you
can do with your desktop graphics card
but the wonderful advantage is that if
you write to WebGL your content will run
on the mobile phone you don't have to
write three applications for desktop for
iPhone for Android you write at once on
the web it's simple to deploy runs
everywhere reach millions and hundreds
of millions of users that's the promise
and let me point out by the way that
that OpenGL ES has fed ideas back to
OpenGL okay to define a core profile of
the API that removes legacy features
that there's a very there's one very
simple way of doing every operation that
the 3d card can do and WebGL is feeding
back into OpenGL by way of informing the
creation of necessary security
properties so that you can safely go to
any web page and run 3d content and know
that it's not going to mess up your
machine in any way so there's a real
nice feedback loop between all of these
api's and it's really going on this is
this is actually happening we have
almost daily conversations between these
working groups and things are evolving
and I I'll show you how to find the
WebGL working group list but I would
definitely encourage you to follow these
discussions if you're interested in how
these api's are progressing so what is
WebGL look like inside okay
it's a fairly large stack of software
you have this web browser right what's a
web browser it's you know large large
amount of code to do layout and
rendering and interaction all these
things and WebGL hooks into this so at
the bottom level when we work our way up
you have the
the OpenGL implementation on the desktop
PC or on your mobile phone you need the
OpenGL ES implementation in your mobile
phone okay
that's what the GPU vendors provide this
is what NVIDIA provides what Andy
provides what Intel provides what you
know all of the mobile vendors like
imagination technologies in power VR
this is what they provide I should point
out that on Windows chrome at least and
also Firefox are using a translation
library currently to work around the
fact that some of the desktop PC OEMs
don't actually ship a viable OpenGL so
WebGL can even run on top of direct3d
today using the angle translation
library so anyway once you have the
graphics library at the very bottom then
the the web browser actually provides
WebGL to you there's a lot of C++ code
involved to get WebGL rendering into an
HTML canvas element and make make me go
fast ok no plugins required this runs
today in Firefox in chrome it runs in
Safari with a little checkbox that you
have to turn on and it runs in opera
next opportun ok so on on the desktop we
got wide vendor support for this
functionality once you got the web
browser running your application comes
down in the form of an html5 web page
with JavaScript the JavaScript drives
the WebGL API and makes your 3d models
render and go and there's there's plenty
of middleware by the way plenty of 3d
libraries that let non expert 3d
programmers get compelling really
nice-looking content that runs really
fast on the screen with very little
effort 10 lines of code and you can have
you know spinning textured box that you
can actually interact with using your
mouse pointer using three J s and I'll
I'm happy to provide pointers to these
things you can find them very easily
there are some links in the in the slide
presentation and certainly on the WebGL
wiki which is a good resource so the the
way that the web page renders is a
little bit different than the way the
typical OpenGL applications
used to surrender typically even just
have a big window you do your drawing
there were two buffers the back buffer
and the front buffer and in order to
avoid seeing glitches as the triangles
were drawn onto the screen the the
OpenGL application would render into the
back buffer and then what it knew that
it was done rendering this frame it
would say swap buffers and then the back
buffer would become the front buffer the
front buffer would become the back
buffer and at the next time the the
electron gun inside the CRT went at the
top that's when it would start to render
the other buffer now the web browser
works completely differently it's got
its own composition architecture so
basically the the webpage engine takes
the HTML content that's on the page and
makes a kind of a bitmap of it like it
renders it into some picture you may
have video elements you may have the
canvas tag containing either 2d or 3d
content by a WebGL and all of these
images are actually represented as
textures on the graphics processing unit
and they're drawn back to front so that
you can get nice blending between them
and you can actually have multiple
layers which is is cool so you can have
a background you know gradients and then
your WebGL content and then some text on
top of it and all of this stuff is just
all the rendering of this the
composition is handled automatically by
the web browser you don't have to worry
about it all you gotta worry about is
making your nice 3d scene and writing
HTML that gets all the effects that you
want it's it's really cool because back
in the day if you wanted to do text in
OpenGL it was a real difficult
proposition there were libraries but by
design text is not part of the OpenGL
API but it is part of the web browser so
it's really easy to put text and other
interactive elements on top of your 3d
scene and build your entire UI in HTML
and it interacts seamlessly that's
that's cool so how does your WebGL
content interact with the rest of the
web page ok
as I mentioned that the 3d content can
actually be you can overlay and underlay
the webpage with your 3d I would like to
show you a demo so let's hope that I can
get back to it exactly that webpage okay
let's go to the WebGL wiki let's go to
the demos let's go to this simple thing
okay here's a shiny teapot and it's
sitting on top of a web page so we can
actually select the text of the HTML and
just by using absolute positioned HTML
elements you can get this visual effect
trivially you know hey look it's 3d
sitting on top of my webpage easy right
it's like two lines of code to make this
work actually since I'm no CSS expert I
was trying to figure out how to get the
teapot to sit in the center of the text
and tried all these Auto
C autofill CSS rules and wasn't able to
get it finally just use the center tag
which any of you who consume a lot of
HTML will probably laugh at and it
worked from HTML you know 1.0 for 1994
but because the web has amazing
factoring compatibility that still
worked and and and yet you know you
didn't think that you'd see that effect
on a webpage when they invented the
center tag right so the center tag
carries forward and actually allows you
to position your your 3d content in the
way that you want depending on the
effect that you want but but the point
is that it's really really easy to get
the 3d stuff to interoperate with the
HTML that's that's the high-level point
here okay so so you can do your entire
user interface in HTML in fact you can
develop the user interface separately
from your 3d app and you can act so you
can have one group of designers doing
the UI and one group doing the 3d and
then you can just plug them together you
don't have to have them all working on
the same code base it's really if things
interoperate really really nicely as I
mentioned before you can pull in other
media content into WebGL you can pull in
video tags you can pull an image tags
you can pull in other canvases you can
pull in other WebGL rendered canvases
and use them as textures in your 3d
scene so that you can wrap them around
other objects or shade them or do
embossing or other filters on the
graphics processing unit so that it runs
really fast you can use 3d graphics for
your web user interface I mean you could
actually use a big canvas and render
WebGL into it and get your mouse click
events and figure out what objects are
hovering over but then you can you know
have the the objects fly by as you go
into a menu system that's actually deep
as opposed to you know spread out all
over the screen so you can make really
unique and very different kinds of user
interfaces then or you typically see on
the web today using WebGL and using the
fact that you can interoperate with the
the web page around you okay
there's an experiment that both Google
and Mozilla are working on I'll show you
a demo that lets you take a portion
actually it's it's really the entire web
page and get that rendered content into
WebGL so that you can then take your web
pages and and wrap them around you know
a cylinder or sphere do crazy kinds of
you know rippling effects or cloth
simulations and and so these have
security ramifications unfortunately but
they so they can't be accessible from
ordinary web pages but if you you know
trust the website that are going to it
should be really really seamless to
write an application that does the sort
of visual effect so we're seeing some
really nice back-and-forth interaction
between 3d and the surrounding web
environment so let's talk about where it
stands now and I'll use this this
opportunity to give an update on the
current WebGL spec so um last year last
March
the first version of the WebGL spec was
introduced call it 1 dot oh and and this
was developed by four major browser
vendors Mozilla Apple opera and Google
working very very closely with Nvidia
AMD Intel and other GPU vendors in order
to produce this specification that we
believed was portable
that could run on mobile phones that
could run on Windows I could run on Mac
and Linux and it could run identically
okay and it actually was not trivial to
do this and if you want some more
technical details we can talk about
these semantic differences between
OpenGL ES and desktop OpenGL and some of
the emulation that has to go on there
but anyway the first version of the spec
was released last year that was a great
step forward now at the same time a
couple months later the the typed array
spec came out has anybody programs with
these on the web today
attempt to raise yeah one person okay so
when we first developed WebGL number one
problem was how do you get your vertex
data onto the graphics card wasn't
possible to do with JavaScript because
JavaScript arrays can hold any kind of
object they can hold numbers they can
old strings they can all objects they
can hold undefined they can hold null
anything you want goes right into a
JavaScript array they're great but
they're not efficient so for OpenGL you
have to know exactly how your vertices
are laid out there's no question about
it
you have to know that this is a floating
point value and the next thing too is
the floating point value and then you
know it's followed by four bytes which
are your color all sorts of very
low-level details are required in order
to to develop an OpenGL app so the WebGL
spec or the module working group
actually designed a typed array spec and
that allows you to talk about how you
are laying out numeric data and giving
it to say the graphics processing unit
and then it was split off in the WebGL
spec because it seemed to be more
generally useful than just WebGL and now
it seems that it's the standard for
using binary data on the web which is
pretty awesome so that was a nice no
contributions say from the WebGL
ecosystem to the to the web so the type
to race back came out around the same
time last year
and there's some really cool stuff going
on there too
the one of the new things that is that
has just come out is the ability to give
to transfer data but
threads anybody use web workers anybody
random web worker anybody so web worker
is a JavaScript script where you can
basically start up another thread in
your web browser running a different
piece of JavaScript and you can use this
postmessage api to send data back and
forth between your worker and your main
thread so it's cool and they're actually
implemented with operating system
threads so you can give some work to the
worker to do and it can chew on it for a
while without blocking your user
interface and then give the result back
the problem with workers is that because
of their semantics they cannot share
data with the main thread okay so you
can't get you couldn't get efficient
computation of lots of data and then
give it to the main thread for rendering
for example but the typed array spec had
the opportunity to contribute there and
solve this problem and it we I think we
did we worked with basically all of
browser vendors including Microsoft by
the way and slightly extended the
semantics of the postmessage api for web
workers to allow you to give a block of
data to another worker okay so you've
got your type terrain you're holding on
to this massive block of data like you
know tens and tens or hundreds of
megabytes and you say transfer and the
thing goes into like one of those you
know sliding drawers that you see at the
bank in a slide thing in and then the
the worker has access to the data and
you don't have access to it anymore okay
and then when the workers done producing
its results it transfers it back to you
and those transfer operations are zero
copy and basically zero cost that's cool
all right so now you can actually do
multi processing in JavaScript and we've
got some preliminary demos showing the
speed ups that you can get by actually
taking advantage of the multiple cores
on your machine and there's a lot of use
cases for WebGL like mesh downloading
and decompression image downloading
decompression and transcoding there's
some really cool new results in this
area you can do physics lots and lots of
amazing use cases scenarios that you can
reach with this functionality
that's in the type of respect so what
have we been doing over the past year
the type the transferable support was
actually part of that work but there's a
new version of WebGL coming out we're
calling it 1.1 and it fixes a lot of
corner cases in the original spec and it
makes the spec much more portable the
behavior is much more tightly defined
and you're basically guaranteed that the
WebGL implementation under your
application is gonna work the same
across all these devices that's what's
new this is about to come out we are
focusing heavily on security if anybody
has questions about that habit of field
of fixing bugs and corner cases in the
original conformance suite and we're
taking WebGL out from under the
experimental flag so you're just gonna
say get context of WebGL
once multiple browsers are passing the
conformance tests on multiple platforms
I must say that today we are waiting for
OpenGL driver bug fixes in order to pass
the conformance suite on at least two
platforms getting closer though okay but
these are bugs that have to be fixed
that really can't be worked around in
the WebGL implementation itself and
honestly some of them are pretty
long-standing so anyway once those bugs
are fixed we anticipate that going
forward you are going to see very very
predictable behavior of not only WebGL
but also OpenGL across a wide range of
platforms where previously there were a
lot of corner cases that weren't
actually covered and where applications
had to do workarounds and so WebGL is
feeding back into this this ecosystem if
you take a look here this this table is
a bit old but if you go to can I use
comm which shows all the html5 features
and shows there their deployment WebGL
is getting out there so it's it it's
fairly wise widespread support at least
if you look at the numbers of web
browsers that are supporting it if you
look at market share there's a
conspicuous absence of one particular
browser that doesn't claim to support
WebGL today and I don't have anything
more to say about that
all right let's do another demo so if
you go to the let me think here what's
the best way to find this you go to the
WebGL wiki and if you didn't see how I
found that you just go to WebGL wiki or
if you go to say you some search engine
doesn't matter which one
WebGL wiki okay the top hit is the WebGL
public wiki on the corona site and here
you can go to there's a lot of links
there are a few simple demos that we
developed very early in the working
group but those aren't the interesting
ones if you go here to the and so the
user contributions there's a ton of
libraries a ton of demos a ton of just
examples that show just incredible
incredible effects so if we look for
this project was actually mainly done by
Mo's and my colleague Craig Tavares at
Google and he's got a bunch of really
cool tim was not all of her 3d by the
way but some of them show how to do like
really fast 2d graphics using WebGL the
first one that he did was a response to
microsoft's IE fishtank demo and you may
remember that the I fish tank was 2d
fish you know wiggling around a little
bit flying around on the web page this
one is actually a 3d fish tank in a 3d
space with light rays fish and sharks
with laser beams that shoot out of their
heads you can see so this is much more
compelling and that this I think that
this was developed in collaboration with
human engines I think they did the art
assets and some of the rendering
techniques for this so it's it's a
pretty canonical demo that we use for
performance actually performs
measurements because even though the
scene is fairly complex and you can see
if we go to like a thousand fish you
know it's quite a lot of fish it still
runs at 60 frames a second and it should
the graphics card is barely breathing
hard doing this kind of
content which is really amazing so WebGL
strain to expose this power of this
graphics car to your application so you
can develop cool content like this and
we're you know iterating on this and
doing more and more advanced demos going
forward so anyway all the source code
for this is out there so you can see the
tricks that Greg did in order to achieve
really good performance of these these
kinds of scenes show some more in a bit
go back here okay we already went there
you user contributions on the WebGL wiki
tons of stuff 3j s is arguably the most
popular WebGL library right now and it's
got it's really easy to use I mean that
that was mr. doob the original creators
point got to be easy to use ten lines of
code got a got a 3d scene on the screen
that's the point
and it definitely achieves that goal so
who wants to hear about WebGL security
okay let's do it
I got more to talk about than is on this
slide so there was a flurry of articles
and activity around WebGL security last
summer there was a little bit of truth
and a lot of fear uncertainty and doubt
so I'll be clear the air here the WebGL
API is 100% secure it is impossible to
access memory that doesn't belong to you
okay out of bound this means out of
bounds reads or writes either on the CPU
or on the graphics processing unit and
it's also impossible to access
uninitialized memory according to this
API specification and many of these
assertions are tested thoroughly by the
WebGL conformance suite where the
behavior is actually defined in such a
way that you can test the results and
make sure that the assertion is true so
these are properties of the
specification okay the spec says that if
you index into an array in your vertex
your fragment shader that you cannot go
outside the bounds of that array that
you're indexing now OpenGL ES doesn't
provide that guarantee but the WebGL
implementation does this is the level of
security that is implemented by the web
browsers so the only question that
remains basically about WebGL security
is can you provide a really lousy user
experience as possible to say lock up
your graphics card for a long period of
time now this is a long-standing problem
the graphics industry the GPU doesn't
multitask in the same way that central
processing units do so you can't go in
and preemptively terminate a graphical
operation that was submitted to the GPU
you basically have to wait for it to
complete but Microsoft actually
innovated in this area and developed a
mechanism for Windows that lets them
reset the graphics card and the driver
on demand so if something goes drempt
dramatically wrong you get maybe a two
second hiccup in your user interface
experience and then the monitor powers
off and comes back on and says so-and-so
graphics drivers stopped responding and
was restarted okay that's the experience
on Windows
it's actually not bad you get an
application notification when that
happens and you can respond to it so two
things have happened in the opengl
ecosystem on on linux and mac
specifications have been developed for
basically accessing the same kind of
functionality of resetting the graphics
card if something bad happens and these
are being implemented today by GPU
vendors and some have already shipped
this functionality the web browsers have
already incorporated the functionality
so Chrome for example watches for these
graphics processor resets and does
something in response if it can be
conclusively determined that WebGL was
responsible it's not going to run WebGL
anymore for that webpage it's gonna say
sorry
WebGL contents on the webpage cause the
graphics card to reset and that's a bad
user experience and we don't want that
to happen to the end-user and this is an
uncommon occurrence but it's one that
has to be guarded against I mean I'm
sure we can all appreciate that
we don't want even by accident to lock
up our our end users machines and
certainly not you know over and over
again so the web browser is defending
against this and we are going to be
designing more a slight additional
amount of user UI in order to prevent a
web page from repeatedly doing this okay
so basically if it ever happens we're
gonna prompt the user put something up
these are facing you know the graphics
card reset or something like this or you
know WebGL stops working do you want to
continue yes or no try again or no thank
you
so the user gets to decide whether or
not they they want to continue running
the content and we as we discover actual
driver bugs that are causing lock ups
like this we are putting test cases in
the WebGL conformance tests this is a
slightly tricky way of getting all of
the GPU vendors to really make their
drivers robust so that they can't get
away with implementing some feature in a
half-baked way that has the possibility
of locking things up they've got to make
it work if they want to say that WebGL
actually works in their GPU
and this is already having a very
positive effect on the quality of
graphics drivers I can definitively
state in the state that so anyway the
the arbor bus'ness OpenGL extension is
the key thing that is giving us the the
kill switch for the lowest level
graphics operations and then the web
browsers are building more security on
top of that and we're really getting
very close to conclusively solving this
problem and that to me is is actually
very exciting because it's a
long-standing issue in the graphics
industry and if we solve it then we can
just with with great confidence deploy
amazing user experiences over the web by
the way that last bullet point is
correct longer term the graphics
processors will do multitasking and then
they can you can just you know kill the
rendering command in the same way that
you could kill a process on a computer
if it goes goes awry so we've pretty
much already discussed this you proud
did did anybody hear specifically about
the cross-domain image access problem
that came out last summer about WebGL
like okay yeah anyway basically issues
that that came up in this area have been
conclusively solved not only in the
WebGL spec but also the HTML
specification
so basically WebGL secure develop your
content with confidence okay I'm gonna
go a little faster through some of the
rest the slides because I want to get to
some demos and questions but the the the
cool thing about developing your app for
the web as opposed to developing like an
Android and iOS and some kind of maybe
it's a steam game or something is that
you get to write your app once it gets
deployed everywhere and you get to use
the wonderful infrastructure that's in
the web browser to do not only your
output in the form of text or buttons or
something but also to build your entire
user experience using HTML that's why
it's cool I'm privileged to have some
colleagues who developed some pretty
cool WebGL content that and they're by
the way it like longtime OpenGL hackers
and at least one of them said that WebGL
is the best opengl development
environment he'd ever used he just hits
shift reload and he sees the new
javascript code that he wrote
and it is really cool I mean I did a lot
of Java OpenGL work back in the day and
it was still painful to do the compile
step put the jar on the server you know
and then hit shift reload now you just
edit it in your text editor save it
shift reload and the reload time is
really really fast because the
JavaScript engines have been heavily
optimized so it's a great development
environment and there are amazing tools
built at the browser's to the root and
one another reason again that you would
want to develop for the web as opposed
to say an app store again you cover all
the devices you don't have to worry
about different app stores for different
devices even app stores for the web you
don't have to worry about it you may
have to worry about your payment model
depending on the kind of application
you're building but as long as you have
like a login screen to your website and
you can you know Fedder a tax s to your
your content based on whether or not the
login has access to the thing you can
put into your own payment system and
then still deploy over the web so a lot
of a lot of cool infrastructure that's
already built on the web that completely
applies to the development of 3d on the
web a lot of tools a lot of libraries
good development environment good
debugger support good mobile Devourer
support you can connect your Android
phone to your PC and it's a bug with you
know the other debugger it's amazing ok
amazing stuff so I don't really want to
talk about this does anybody care if I
skip over there's another effort to put
verbal back in the web browser
declarative 3d for the web not
integrated in any way I'm not a big fan
of going in that particular direction
because I think that it shovels a lot
more code as the web browser that
doesn't really belong there but there
are other reasons for doing it like
accessibility and but I'm not an expert
in this area so I prefer to focus on the
WebGL stuff so Chronos is actually
contributing more than just WebGL into
the web Belka ecosystem and the next
couple of slides we'll talk about web CL
but there's there I think that there
actually is an opportunity to to develop
the the low-level API is in parallel
with the ones that binds those little
API s into JavaScript that's what WebGL
does
but OpenGL es2 previously existed and so
WebGL was a natural binding of that
functionality open to the web there are
other specs that Cronus develops like
open CL like open SL for sound like open
CV for computer vision like stream input
for pulling in like every kind of device
Under the Sun into one nice unified API
that's semantically driven and there are
lots of opportunities for exposing more
of this functionality that is on the
native PC up into the the web echo
system and the Khronos group is working
very well I think with the w3c on on
WebGL on typed arrays and on other
collaborations so I look personally look
forward to more of more of this so in a
breeze through the web CL slides here
but basically in addition to being able
to do 3d graphics with your with your
web page with your PC the graphics
processor has been repurposed to be more
of a general-purpose processor so you
can upload little snippets of C like
code onto it and do actual computation
like physics simulation for example and
that's what open CL provides an industry
standard way of doing computation using
your graphics chip and I mean there's
not much more to say about it it
basically lets you write really high
performance kernels that run everywhere
because all of the graphics devices are
supporting the OpenCL you know base
functionality so the ability to compile
these see like kernels and run them on
your device even if it's a mobile phone
that behavior is specified across the
industry so web CL is an initiative that
Chronos is working on and actually the
first draft of the spec just came out
like within the past week so I encourage
you to go take a look and provide
feedback to the working group but
basically it exposes OpenCL to
javascript so open CL has specified
behavior
across a wide range of devices and that
is the you know the key property that's
necessary in order to expose it to the
web because the web works the same
everywhere so you need your compute
environment to work the same everywhere
web CL brings the lowest level
primitives for accessing the graphics
card as a compute device to the web and
that lets you do some pretty cool stuff
you could actually write new languages
for the web better auto parallelizing
and host them on top a web CL so it can
be a new building block for dramatically
extending JavaScript in new directions
it's pretty cool so I recommend that you
check it out and try out the prototypes
that have been developed by by Samsung
and by Nokia so I'm gonna skip through
this that the slides are all available
by the way so you can go back and refer
to these but I do want to show one
demonstration from Samsung this this
link this YouTube page is linked from
the from the slides but basically this
is the this is a cool little I'm gonna
leave the sound off and talk over it
it's cool demo of Samsung's webseal
implementation running in the browser
they do two comparisons first they they
make a deforming model okay
that is doing all sorts of physics
simulation and it's it's for now the
simulation is off okay and the next
thing I'm gonna do is turn on the
simulation and it's gonna be running in
JavaScript okay okay so they're getting
like one frame per second or one frame
every two seconds okay something like
that maybe two frames a second not very
fast and the reason is that this is a
really hard problem for the CPU to
compute it's a much a problem much
better suited for the GPU which has
massive parallelism so this part of the
video shows they're open their web CL
prototype do
the physics simulation of these
deforming bodies and you see it's
interactive rates it's like you know 100
frames a second so you can get massive
speed ups by taking advantage of the
floating-point performance of the
graphics processor from JavaScript
depending on your application so not
much more to say about that there are
definitely areas where or fields where
this kind of ability is is a huge huge
win so that's what web CL is aiming to
provide going forward you can envision
really cool stuff going on you can
vision video input coming in by openmax
or actually maybe just by web RTC but
basically one way or another you get
your video frames in from the camera and
you feed it into the open sea the
computer vision library to do object
finding and tracking and then you feed
it into your JavaScript code which does
some sort of you know 3d model of the
scene that it's looking at does an
overlay of some 3d graphics on and then
uses WebGL to compose the video with the
3d overlay and then you can take your
tablet and look around at the world and
CEO the subway station is in that
direction or free pizza in the kitchen
or you know all sorts of useful
information where's the bathroom you
know and and I think that the web would
actually be an ideal platform to develop
these kinds of applications in and it's
becoming increasingly possible so with
that I'm gonna just ask everybody to get
involved in the development of these
specifications especially I mean if you
have interest in 3d graphics please join
the WebGL public mailing list and at
least watch the discussions if not
participate there's we're improving the
we're fixing corner cases in the spec
every day we're developing not
developing but let's say that we're
pulling a new functionality from the
desktop 3d graphics environment to in
order to increase the kinds of visual
effects that you can do with WebGL and
the the entire ecosystem is evolving
quite quickly and it's it's actually
really exciting to see as multiple web
browsers implement
new features you can see demos coming
out just everyday so I want to show some
demos and points out by the way that
there are at least two mobile browsers
today that support WebGL its opera
mobile and Firefox on Android and I
expect more mobile browser
implementations to support WebGL in the
near future
actually rim PlayBook is a third so
anyway without me pull up a couple of
demos and let me call for questions if
anybody has a question please just raise
your hand interrupt me please Becca
that's a good question the question was
when can we expect a web CL to show up
in real browsers I don't have a
prediction for you on that but what I
would suggest is join the web CL public
mailing list provide feedback on the API
and help the working group move it
forward to a point where the spec and
its security properties are specified
well enough that we all feel confident
in deploying it these are the main
issues another issue
another issue is that so we've seen how
WebGL was implemented at the top of this
angle graphics library an angle provides
OpenGL ES semantics on top of direct3d
if you assume that the the target that
you're gonna be hosting web CL on top of
is actually direct compute as opposed to
open CL on Windows you may need some
work may be necessary there more Minds
thinking about that particular issue
would definitely help accelerate the
deployment of the spec so if you have
any experience in that area I would
highly encourage you to get involved
question up here okay so this is a this
is a question a point the the question
point was that I was advocating using
WebGL as the mechanism for deploying
onto mobile devices but since mobile
browsers aren't really supporting it yet
it's not really viable to replace doing
an app store deployment I expect this to
be the year of WebGL on mobile there are
already two browsers supporting it
be actually there's more than two that
there
Nvidia has released a WebGL
implementation on their Tegra hardware
that supports Android that is really
really fast they spent a lot of time
getting the composition architecture to
be fast so they could get the WebGL
content to the screen very quickly and
so the point was that WebGL can't really
replace these mobile app stores yet and
that that is true okay but if you if
your time horizon for the development of
your content is something like six
months I think it would be safe to
target WebGL as what you you know how
you write your app so that with the
expectation that maybe six months from
now you're gonna see a wide range of
browsers supporting WebGL and mobile
that's a personal opinion I can't
promise you no release dates or anything
like that but given that WebGL was
specifically designed to run on mobile
devices I think that this will be the
year that that happens there's it's been
a bit of a difficult road getting to a
certain point of conformance and cross
browser and cross platform behavior on
desktop machines but the Bumble devices
were specifically designed for this form
of the OpenGL API so I think that it'll
be easier to get it running on mobile
devices now that we have all this
infrastructure in the browsers for for
doing it on the desktop alright I think
I should probably give you guys a 15
minute break so thanks for coming and
look forward to seeing you again soon</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>