<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ricky Bobby's World: JavaScript &amp; Our Obsession with Speed | Coder Coacher - Coaching Coders</title><meta content="Ricky Bobby's World: JavaScript &amp; Our Obsession with Speed - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ricky Bobby's World: JavaScript &amp; Our Obsession with Speed</b></h2><h5 class="post__date">2014-08-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0wgDGTgOPds" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi
oh thank you thank you everybody for
coming along I'm Brian I am supposed to
be helping organize this conference but
I really just I was part of the company
that was organizing send too much Dave
and Taylor did a ton I'm really grateful
so I wanted to talk about performance
and you know in JavaScript and this talk
is kind of like a two-part thing so the
first part I'm just gonna rants on my
opinions about a performance it's gonna
be just like slides and comments and
whatnot the second part is gonna be my
ideas for optimization on performance
since stuff so I hate performance but
I'll show you how I think we should
optimize performance so if you're bored
with the talking on the first part hang
tight I'll show you a bunch of code on
the second part and just you know oh I
guess I'll take questions at the end but
not trying to be a troll or be mean or
anything I just have my opinions and
thought I'd share them all right so you
guys we've got a problem
we have this like perverse obsession
with speed right now do you guys when
was the last time you saw a micro
benchmark was it in the last 24 hours or
is your hand if you've seen it's
basically every time I wake up and I
look on blogs hacker news whatever it's
just you know this is faster than that
and that's faster than that and there's
you know we should use closures not new
or new thing closures or no for loops
and this and that and you know I'm not
saying that these things aren't good
movies also got like you know full-on
books and people like spending a lot of
their time learning JavaScript execution
like you know like micro optimizations
and how the stack frames work and all
sorts of crazy stuff way low level but
the typical JavaScript developer is just
making apps and we have a lot of other
things to learn besides this stuff you
guys and so I have this uh
there's a brief history of why I think
we might be where we're at right now
you know performance as the number one
highest thing that we we are into so
back in the day there was these you know
hard statistics saying like oh people
will leave your site if it doesn't you
know render in like under three seconds
or whatever and so that launched all
these like you know performance stuff
and we've got v8 coming along with
chrome and these browser Wars and here's
squirrel fish and squirrel fish coming
around corner now there's trace monkey
and it's like this anthropomorphic like
you know track race thing going on but
they're all they're all basically saying
like Oh JavaScript execution speed is
faster here and so you watch you know we
sat here and watched as people crowds of
people went to different browsers and
we're like oh yeah that's where the jam
is okay and then you got this sad sad
state where the native developers were
like oh you guys are so slow and native
is so fast and you know html5 will never
work and you guys need to stop trying to
make apps and slow slow slow Java
scripts too slow you got Facebook
leaving right and and LinkedIn saying oh
we got to go native now and this isn't
just the front end you got Ryan Dahl
writing his manifesto and people saying
like oh yeah note it's so fast we've got
a code you note cuz it's fast and never
blocks and you've got these you know
these charts and stuff that's saying oh
all these others they block and we don't
block and then LinkedIn is like we lost
all our servers and we have one
developer now and it's a billion times
faster this actually went back and got
corrected right that's fine but go speed
so you guys so people on the server side
like you we've got a lot of performance
people in the node community you got all
performance people or at least people
like shivering in the corner like oh I
gotta go faster I got to go faster in
the front end and it's leading I mean
like obviously performance is great we
all want our apps to go fast but you
know I just there's some bad parts to it
I'd say so for one we have this perf
care annoy a thing going on where you
have people saying like oh can I use
semicolons is that fast enough you feel
like oh big switch statements that
should be is that good I can do that
right and of course it doesn't matter
here's somebody trying to inline
javascript for the JIT like
help the JIT along it'll be faster right
so I mean whatever here's some wildly
inaccurate search results I did I didn't
know how to search for for loops so I
did for I which is like eight million
and for J which is like seven and a half
million there's a much you know a bunch
of other letters and there's so many
reasons why this doesn't work and then
this is like half the results for a for
each and I was like okay you know you've
got like fifteen and a half million for
like a for loop and like four million
for for each I tried to search map but
it just came up with a bunch of nonsense
but you know it just kind of gets across
the feeling that I get whenever I go see
like I'm seeing people write code and I
see for loops all over the place I'm
like why why are we still doing this
this is so weird
and if I go search google for more
inaccurate search results to back up my
claims we have a performance in
JavaScript is what is 134 million fast
JavaScript is 177 million maintainable
javascript is something like half a
million
it's a hundreds of millions compared to
half a million so as we know speed and
maintainability are often at odds not
always I think Dalton's gonna give a
great talk later on something some stuff
that might prove this wrong but I have I
have you know just I think a lot of
people just you know when they write
their optimized codes it takes a lot
longer it's a lot more complex and you
know here we have our just map that's
exposed to on the left side is the you
know the for loop that's if you look at
any benchmark it would just stomp map
into the ground you should never use map
blah blah but if you look at this we've
got the our closure bug you know out in
the open we've got all these loose
variables it's really complex and hard
to look at and map is really concise
even though it's dog slow here's a quote
from stones blog I'm not saying that
right is it stoian um anyway he's he's
uh he was saying you know namespaces are
fantastic but dot property lookups are
slow so we can't have namespaces and he
goes into you know of course this is
extreme object Abba script optimization
I don't think he's suggesting that you
do this in your app but sure enough
somebody I'm working with you know
couple like a year back is
like he's dot notation that's too slow I
was like oh my gosh you know so like
it's not helping its these these micro
optimizations it's like it's cool to
know but you shouldn't we shouldn't be
all experts on this we should just kind
of like let the frameworks and libraries
kind of work on this so we have a global
variable caching you know on the left
side we've got our extra variables and
like you can get out of sync and it's
extra code and we're basically like oh
yeah the JavaScript execution context
has to like leave the function and go
look up the variables and on the other
side is just there honestly you know I
watched some great talks on what the JIT
can do and it's like it probably does
this stuff for you I'm no expert but
people are doing this today in our
community and here's just an example of
how performance can be at odds
it's unrolled loop here on the left and
then just a normal for each if you don't
know an unrolled loop is is some I guess
eight might be the magic number for
unrolling a loop but it's basically
turning a loop into a sequential process
so that's that's one thing you've got
the perf Maranoa people worried about
you know every little decision growing
up into a bigger and bigger and bigger
decision of oh no like if I didn't write
all my loops and for loops it's gonna be
a slow app and I'll never know how fast
it could have been and it's it's not
it's not a good situation for
maintainability so there's another
darker side of this is people people
tend to come up with new ideas often and
they'll say like Oh check out this new
medam programming technique I came up
with or aspect-oriented programming is
really neat or DCI or whatever it is new
things come out and they're met with
like an angry mob of performance people
that are like that'll never work we
cannot do this it has to look and read
like see always new ideas are not
welcome and so this is for j/s and I
want you guys to be aware that like
every time you go and leave a comment
with a benchmark saying this will never
work you're basically just smothering it
and telling all the new people and all
the new ideas you know like we shouldn't
try that you can't try that we have
stop so here's just an example and this
one's with you know like currying
someone's like oh it'll never use this
even though Don might be the bottleneck
if you do hit a bottleneck it's it's
gonna be occurring and I'll never use it
and use it in production and you know
you guys remember when the promises and
callbacks things came out they're like
oh callbacks and promises are slow
thank goodness promises one though that
was awesome
and then Pete Hodgson he's talking today
he had a great post on why you should
program or how you can program without
this and you know basically doing all
these cool little uh you know
object-oriented things through closures
and you have truly private variables and
whatnot but if you looked at the
comments it was just ripping him to
shreds and it was so sad because of
course you can do this in your
JavaScript it's not going to be that
slow unless you're really looping
through like ten thousand things and you
need to have the prototype to look up
the method really quickly but um yeah
it's just new ideas just being shot down
and thrown away I don't know if that
idea is necessarily new but it's fun so
what does make our stuff fast right if
you just go check out your page speed
scores it's not talking about oh you
know what your raw JavaScript execution
speed is your bottleneck you guys you
should really optimize your loops and
such I mean it's mainly like oh yeah
compressor images you know gzip try to
reduce your server and you know in
response to somebody asking Paul Irish
you know about like selector speed you
say this hey you're not allowed to care
about performance unless you can
catenate all your JavaScript have it at
the bottom unify your CSS and jsg zip
all your assets losslessly compressor
images so on etc yeah and you're just
not allowed to care about it until you
do all that stuff and I have a suspicion
that a lot of people aren't doing this
stuff they're just like scary they're
scared to write higher-level nice code
because they're like oh I wanted to be
fast and I don't know what makes it fast
because I just see blogs all day so I
did a bunch of tests at my house and I
was gonna share them with you but then I
got scared to share them with you so I'm
not going to basically because it's you
know there's no real way to you know
benchmark real life applications but
this is what I found in my time
and I encourage you to go do your own
tests so basically in every single web
app I've made in JavaScript over the
last like five years I've done an ajax
call I've done some JavaScript and then
I've done some templating or put it on
the screen that's all I do every day day
in day out and that JavaScript stuff
that's coming from the server is usually
paginate 'add usually already in a
decent-enough format I mean I might
split sort do all sorts of crazy stuff
to it but even then it amounted to like
nothing and so optimizing my app if you
like flip it around your app code is
that 2% that's all you're working with
and if you're just like ripping it apart
trying to be fast you know of course
everybody will tell you find your
bottleneck optimize it but I think
there's a lot of people who don't have
time or the mind to go do that and
they're just scared and there's writing
imperative code for no reason so you
could look at this really easily in the
web inspector and you'll see this pie
chart and that yellow part or orange
part I can't tell I'm not colorblind but
you can't tell what color that is the
yellow or anyway so the whole thing is
that's just JavaScript called the Ajax
call and then it returned or a
JavaScript did this Dom worker and then
it returned it's not JavaScript so you
might be thinking it's all JavaScript
but no it's mainly all this other stuff
it just gets lumped into JavaScript
because that's the caller and you can
look at the self time and try to figure
it out but even then it's really hard to
figure that out so yeah we have people
who know this stuff and they're working
on this stuff every single day and
they're making libraries and in trying
to help us get faster and they're
experts and I think that you know we
should use their stuff and just let them
be the experts we don't all have to be
the experts on micro optimizations and
JavaScript execution and all this stuff
another thing is javascript is a single
threaded interpreted language so we're
not going to be the fastest yeah like
it's we're kind of starting with a limp
here see then you get people like TJ
Holloway Chuck like writing like oh I'm
frustrated I'm gonna go to go cuz goes
so much faster and it's like well if you
put performance as the top thing in in
your community
there's going to be more performant
things out there because they're
compiled and they're distributed and
they're threaded and all sorts of stuff
right and this is I like this quote
though because it says I'm frustrated by
nodes direction which favors performance
over usability and robustness and I kind
of agree I feel like everybody's just
very performance aware maybe because of
that history stuff but I think there's a
lot other things that we could be aware
of so this is going into like part two
where you might get some more code not
just my my opinion so meanwhile back at
our lovely ranch there is there's it's
you know we're not really placing that
much importance on correctness and you
know I was trying to think about what is
the strong point if if javascript is a
single threaded interpreted language
like what are the things that would make
somebody say I use JavaScript and
JavaScript is the reason I'm like you
know there's so many reasons to use this
language and I thought hey it runs
everywhere right it runs for node BOTS
and it runs for you know like on the
server and the client and phones all
over the place
but you go do that and it doesn't look
like the same language everywhere here's
a some node code on how to do a HTTP
call here's a browser node browser node
browser that's what's crazy
um so different and this is low-level on
purpose so we can build abstractions on
top of it and luckily TJ Holloway talked
before you left
wrote a super-agent and now this is the
same for both and the good part about
this is its high-level its declarative
it works in many environments and you
know you don't have to worry about like
doing all this close to the metal stuff
it just works so I think we need to
spend more time on doing stuff like this
rather than becoming performance experts
of course you have to be a performance
expert to be doing this lower-level
stuff so it kind of uh you know catch-22
but the idea is that we want to write
bigger more maintainable stuff so
application developers once they learn
how to write a good app they can go
learn you know other things like
security and
how to progress the web and not how the
JavaScript actually works under the hood
so let's get into declarative coding for
a minute because I'm really into that so
if you don't know what declarative
coding is this is sequel it's you know
you just write your query in one
expression you say what you want not how
you want it or how to get it or how to
do it so this is just you can let the
sequel folks optimize all day long and
your expression doesn't need to change
if your application code was like this
you would not need to change your
application to optimize it right it
would just be optimized under the hood
so if we look at filter as a JavaScript
version at the top that can be optimized
all day long but down below that's not
very easy to optimize there's no level
of abstraction it's not very declarative
and so on etc so this is how I write
apps
I get really overboard with with
declarative functional stuff this is
from our workshop but the the point is
that there's so much wiggle room for you
know changing the implementation of it
under the hood and once you get into
that stuff it feels really good because
it'll run in any environment and and you
can implement it differently and you can
optimize it and I think that's a better
way to write apps and maybe we should be
working more towards that maybe not this
functional stuff but declarative so as
far as part-2 goes I'd want to write an
app like that but it's not fast enough
so what if we could have our cake and
eat it too so let's check this out so
optimization number one for high-level
declarative things this is called loop
fusion I've talked about this before and
this probably people are probably
familiar with this so up at the top it
says hey the left side where we're
mapping the function f we're iterating
over a whole entire list and running F
on it and then we're iterating over it
again and running G on it that's the
same as just iterating over at once and
running both at the same time and we can
actually that top is you know valid code
that I would use now just instantly
recognize and
place with the right side as it's fester
and down at the bottom is the chain
syntax might be more familiar so to make
this more concrete we could run through
a list and capitalize everything and
then grab the first letter or the second
time is much faster
it only iterates once and capitalizes
and grabs the first letter and here's
the same thing in chain syntax I'm
showing you that for a reason because I
think we should be doing that and I'm
not saying there are people plenty of
people doing that but I think we need to
do more of that so guess what it works
for functors and monads to you guys a
list I don't you don't need to know what
a functor on a monad is but you do need
to know that if you're writing stuff in
a functional style almost everything you
do is in functors and monads so a list
is one it's just a container type and it
is a functor an timon add so everything
you can do for a list you can typically
do for these other things so if I was
going to map over my monad I could
actually fuse that mapping so here's
another cool performance optimization
from the declarative high-level
programming world shortcut fusion so
here we are
it basically says if we have a fold or a
reduce and we're doing that right after
building a list we're building with this
G function we could just shortcut that
and call the G function let's look let's
take a look at that don't worry about
the type signatures I just wanted to be
a jerk this is a way to do it in
JavaScript you've got a build function
and build all it does is inject the
concatenation operator I just used this
push helper here and a empty list and
that will just basically inject that
into the reduce format but if we do it
that way you could you could basically
say if we're gonna first map over an
entire list and square it and then we're
gonna basically fold that list down to a
sum or reduce that list down to a sum
that commented outline is the is
equivalent and it can do the exact same
thing
in one iteration so it's just like loop
fusion but here where we're fusing folds
so that's pretty neat and here's the
exact same thing in kind of like low -
syntax down at the bottom so you could
replace that chain with one that does
the reduce this way you don't have to
map over everything and then sum it you
could do it in one one go that kind of
you need good producers and good
consumers the things that build up lists
and the things that consume lists and
here's just a short list but it's
basically everything that you would
expect right like any all sort by map
filter can cat like these are things
that you do all the time it's not like
all these are the only things you can do
but check it out
it works for functors and monads - it
doesn't just work for a list we can
actually shortcut
you know fuse our monads and functors
and that's amazing if you're if you're
expressing your entire app in it they
call it deforestation if you're
basically every step of the way using
these these objects it can get rid of
all the intermediate objects and do
things a lot more efficiently so let's
talk about something you probably do
know here's memoization so raise your
hand if you know what memorization is
okay great awesome but the idea is that
if you have a function that takes some
value and runs it it the second time
it'll actually remember the output for
that input and the second time it runs
it doesn't actually run it it just
returns the output it's just cached and
you can do that for any pure function so
here's it in action if I call add 20
with 10 then I call it again it doesn't
run the second time it just remembered
it because it was 10 and then the third
time it does run because it's a
different number but if I ran it again
with 11 it would return me without we
wouldn't run again so you can just wrap
that around any function right this memo
wise thing and then it'll just remember
it but what people don't realize a lot
or it trips up a lot of people here is
that if you're if you're memorizing pure
computations here's a future that goes
get and goes and gets posts futures are
just like promises except you have to
tell them to run they won't just
so they end up being pure but what
happens here is we make a new future
that will go get us posts for whatever
ID like ID number five and the second
time we call get posts with five people
might feel like oh no you just cashed
your posts that doesn't work but no
we're just returning that same future
that we'll go get our posts so we don't
have to make new objects every time it
just returns a thing that will go get us
our posts so you can totally do that for
you know things that seem like they're
not going to be impure but they are
actually pure so here we call a get
posts with two it returns us a future
call it again it returns us the exact
same future and then three it returns us
a new future that we'll go get posts so
these things aren't getting posts
they're not promises there are things
that will go get posts so it's just a
post or a future basically with the
value inside of it that hasn't happened
yet and we could also do this with a
jQuery and so we have this to i/o helper
from monae ajs chris meyer has made it
his slogan was when you actually
absolutely absolutely have to use
javascript which depressed me but the
idea is that you have a you know this
thing that will go get all the trolls
right everything with class troll and it
doesn't actually do it it just returns
us an i/o of something that will do it
and then we run i/o and we run i/o you
might see it called unsafe perform i/o
and it will get different things each
time but the fact that it was memorized
is it's just saying it's gonna return
you that same IO it doesn't have to go
construct a whole new i/o every time so
that's pretty neat so needless to say
that works for functors and monads it's
pure computations that can all be
memorized basically your whole app can
be memorized here's a parallel code so
here on the Left we're showing the
associativity rule if we run it doesn't
matter how we group our inner calls we
can call F with the result of x and y
and your you know F with the the other
result the inner ones run first and
that's fine here's an example here's AD
and you know you guys might say oh you
can add two and three and add that
result of five or vice-versa it's also
commutative which is pretty neat but
that means we could write it and we
doesn't matter how we group it right we
can just write as many things inside of
this as we want give it a list or a very
attic add basically and this can be
parallelized and you might be thinking
no I can't
this is JavaScript we can't do
parallelization of course we can we've
got River Trail coming out we've got web
workers we can spawn child processes
there's ways to do parallel code we just
hinder ourselves and don't try because
we're all like oh no imperative me but
mutability blah blah and we don't have
any really nice declarative syntax that
allows us the freedom to go try to
implement this stuff because everybody's
JavaScript is like for loops and things
that's like well I can't make it
parallel because it's too it's too
low-level so here's another way to do
parallelism it's applicative functor
syntax but basically what we're saying
is and you don't need to know what this
stuff is I'm just showing you stuff that
is really high-level and does things so
one example is down at the bottom if we
want to do three long-running
calculations and then collect the
results basically what this is going to
do is return futures and the applicable
instance for futures well wait till each
one is done and pass the results to
collect results right but the idea is
that it can be run in parallel and there
isn't any effort going into that because
nobody's really doing it and it doesn't
have to just be for futures it'd just be
for normal things like validations just
normal calculations it's just the way
you express this is totally declarative
there's no step-by-step instructions
there's no sequence no evaluation steps
like first we run this line then run
this line we could just consume it and
do whatever we want under the hood so it
works for functors and monads to you
guys I just say functors and monads
basically saying like you know like
applicative functors are functors i
don't know that this isn't a functor
syntax duplicative but the idea is that
the things you're expressing your entire
app in can take advantage of this stuff
particularly mono in the case of the
parallel associativity stuff so I want
to talk about some cool ideas that I
have
because I you know I've got this time so
here's the example from lodash docks on
chain and you know we're gonna sort sort
them by age then map this string over it
and then grab the first value and then
extract the value from it it's actually
a comonad but the idea is that if each
step of the way it didn't actually run
it just built up a computation to run
when we call that dot value basically it
lazily builds up a computation for you
then we could say oh hey instead of
running immediately we noticed that you
called first right after map so why did
we map the entire list when we could
have just called first and you know we
can actually do some fusion there or at
least rearrange it a bit and this is a
you know these are these high-level
declarative ap is that we could be
coding with all the time give us the
flexibility and freedom to do that it's
turns out there's already a library that
does this I don't know if there's many
people using it but I think we could
combine efforts and try to do some more
lazy coding in lodash which is my
favorite library for doing this kind of
stuff so here you know you can see a map
uni take but nothing happens till that
bottom line see that unique Ran's from
what I'm doing one to a thousand we call
that each and it basically extracts the
value from that computation it basically
says like run this now so everything
else up until it doesn't do anything but
build up a computation it's like the
command pattern there's basically a
promises you're saying do this do this
do this and it's not going to do
anything until it actually gets resolved
or until we call each you know and you
might be familiar with this style
through bacon Jaso react or somewhere
reactive J s or rxjs I mean a lot of
these different you know FRP libraries
and stuff do this but we could just do
this for every day code just build up
your computation and we can compile as
we code we can kind of make these
optimizations that's a pretty neat idea
so that works for functors and monads to
you guys can you believe it it doesn't
just work with lists we could work with
all sorts of different data structures
and put computations inside them and if
you're expressing your app in a
functional way you'll probably have
kind of this like monad stack and as you
put computations inside its taking into
account asynchronous programming and
things like that so null checks and
whatnot and this is really powerful
because you can do optimizations
throughout there's other ways you can do
this stuff here's a puffin fresh wrote
this like rephrase he basically ported
Haskell rewrite rolls over so down there
is the loop fusion we were talking about
earlier if you map and map that says
consume the app and like just every time
you match that replace it with this
that's a way to go about it I'm not big
on the pre processing stuff but you know
something we can do today basically
another way of going about this instead
of run time compilation and we could
also take it a step further by inlining
all our functions and then running the
rewrite rules things like that so this
is just a handful of ideas and and
optimizations from very high-level
declarative code that if we're writing
high-level declarative code we could be
sharing our JavaScript code in different
environments we can be optimizing under
the hood we could be putting our effort
towards this instead of everybody trying
to learn where this you know the
execution context goes and then like you
know what everything is doing under the
hood we could be working at a very high
level for application developers and
yeah that's really all I've got so thank
you so you have questions or just want
to like yell at me about performance oh
sure yeah that that is the point um you
basically there's there's techniques for
compiling as you code or whatever and
it's a lot like a promise you just store
functions in there and perhaps as you
storing them you could say oh I just
followed I just had a map and a build I
can do our shortcut fusion and then you
just keep you know doing that and I
think nothing happens until you kind of
run it it's like you're setting up
dominoes so and then you push it down
and as you're setting them up you can
just have this little mechanism that fix
it up so today I didn't repeat the
question I probably didn't repeat the
question did I
it's about lazy jeaious and you know you
missed the point of
I didn't express the point well you know
it could compile as it goes what's up
well that's yeah III think that anything
is production ready if it runs but
that's my opinion I'm crazy but I I
think that there's probably a lot of
problems with it right you shouldn't
just go out and start using stuff but
like Christian said right before this
like use it find bugs like let's try to
write the stuff we want to write because
you know like if you're writing what you
want to write they'll optimize around us
they'll optimize the code you'll have
way more wiggle room and you know like
you know if somebody was talking about
this the other day like how the
JavaScript actual engines will you know
like optimize to what you're doing and
it's like why not do that yeah man I'll
try I mean yeah I'll totally help you
man this is a you know lodash maintainer
back here Oh excellent yeah I'm very
happy to work on that I'm the last
person that should be working on
performance I should have admitted that
first but I would be happy to try to
work on stuff the idea is that I think
what I really wanted to express this
people they learn enough in JavaScript
and they get to a point where they're
like well what do I learn now and then
the they see blogs and speakers and all
this stuff every day about performance
and you know you need to know how
everything works down in the metal and
then they don't learn like oh well why
don't we write you know higher level
things or work on that stuff it's all
very very very low level and it's I
think we should be as application
developers not as library developers but
as application developers working on
that so but yeah I'll totally try to
help let's talk about that later any
other questions
so oh I have a workshop tomorrow if you
want
but yeah it's a space burrito
other questions alright thank you guys
so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>