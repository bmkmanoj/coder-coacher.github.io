<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Web Components &amp; The Future of the Web | Coder Coacher - Coaching Coders</title><meta content="Web Components &amp; The Future of the Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Web Components &amp; The Future of the Web</b></h2><h5 class="post__date">2013-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mx3YPCRNQ3A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Rob Dodson by a freelance
front-end developer consultant e type
person here in San Francisco we're going
to talk about tons of stuff this evening
so if there's not a lot of time for Q&amp;amp;A
at the end you can always hit me up at
my blog on Rob Dodson me or on twitter
or on github we're going to be showing
lots of really cool stuff in this
presentation I'm going to put these
slides up for you all to mess around
with I'll throw that URL out at the end
of the talk but you know just in advance
if you want to mess around with any of
the stuff that we're talking about
tonight you're going to want to have
Chrome Canary you're going to want to
turn on some of these settings in your
browser so that you can actually play
around with all this technology because
everything we're talking about in the
talk is super new super bleeding-edge
crazy all right what are we going
to cover if you guys saw the
announcement we're talking about web
components this evening and some of you
are probably most of you are probably
like what is web components I don't know
what that means so we're going to cover
what the actual term means and what the
whole component model for the web is
we're going to talk about all the new
specs and standards that collectively
make up web components there is no one
web component technology we're actually
going to be talking about four different
technologies which kind of interlocked
like Voltron and become this amazing
awesome thing and the last thing we're
going to talk about it's how you can
actually use some of these things today
in all modern browsers like I always
hate it when I go to a presentation and
people like look at this amazing stuff
you can use it in six years so
everything that we gonna be showing
today is stuff that you can use right
now fair warning there's going to be a
lot of code in this talk I've given it
to designers before and they've kind of
just like glazed over halfway through
but I think if you hang in there you're
going to be really stoked about
everything that we talked about today
and everything that you learn my hope is
that you guys are going to leave tonight
feeling like this you're going to be
really pumped by where the whole web
platform is headed where web components
are head
and everything that we're talking about
so I want to start things off by asking
kind of a rhetorical question of the
audience because I think it really helps
to set the tone and the context for
everything we're going to be discussing
and I want to know for those of you who
do use Twitter bootstrap how do you use
twitter bootstrap in your app and we
need to think about how you get twitter
bootstrap into your app and it's okay if
you don't use twitter bootstrap it's
okay if you have no idea what I'm
talking about it could be how to use
foundation how do you use kendo UI how
do you use jQuery UI how to use jQuery
plugins really what I'm asking is how do
you use all of the third party code and
widgets that you bring into your app how
do you go about that so I'm going to go
through this sort of narrative and
perhaps this will feel familiar to you
and perhaps this will help us illustrate
some of the problems that we're dealing
with today on the web so if I want to
use some third-party code in my
application typically what I do is I go
find the documentation for that that
widget or that library or whatever these
are the dots for a Twitter bootstrap so
I find the thing that I want and then I
just copy a whole bunch of code and I
throw it into my app because they're
like oh yeah you want to use the navbar
sweet grab all this HTML throw it in
your app include our CSS wallah you get
an app bar you know you get this sweet
little widget but you usually don't want
one widget you usually want a bunch of
them you want a bunch of these like cool
new widgets so you go back to the
documentation you find something else
that you really like in there maybe like
a carousel maybe pagination something
like that you grab all the code for that
and you throw that into your app and you
do this over and over and over again so
you've kind of built this application
it's just full of boilerplate code that
looks like this it's all this sort of UI
code that you yourself did not write and
so if you perhaps leave a line out then
the whole thing breaks and you're
wondering why it broke and it also means
that your app becomes sort of harder to
maintain and harder to change because
you've just got all this stuff floating
around everywhere I think we can do a
lot better than this I think this is
right now this is like the current best
in breed way to build front and applique
just go grab bootstrap and throw it in
there I think that's a problem I think
it's what we're doing today is kind of
the ikea approach to building web apps
we're just taking a bunch of bits and
pieces and cobbling it together and
sometimes there's things left over and
we're like well I hope I didn't need
that but we're just kind of gluing all
this stuff together DIY like I think
that this this step right here is is our
main issue instead of copying all the
things I think it should look like this
I think it should just be use the thing
if I want a navbar from Twitter
bootstrap I should just be able to use
like a Twitter bootstrap navbar tag and
then the only code that i'm going to
write is going to be the code that
actually pertains to my application the
only links that are going into that
navbar are the ones that I care about
and all that other UI code I don't need
to know about I don't need to know how
the navbar got created I don't care so
so this is the problem that web
components are trying to solve this is
what we're going to be talking about
tonight ok so the term itself web
components it's kind of an umbrella term
it's actually a bunch of different
technologies which collectively let us
do some really awesome stuff so first
among those is it gives us the ability
to create our own HTML elements we've
shown that previously with that
bootstrap tag but that's not all it does
it also gives us the ability to
encapsulate our CSS styles so if we
write some CSS and we put it into a
component that CSS is protected from the
parent document and it means that our
component is going to render exactly as
we intend it to we don't have to worry
about you know the parent document
having more specific CSS or important
tags or anything like that it's not
going to affect the rendering of our
component which is huge if you write a
lot of CSS web components also give us
the ability to react to changes in our
component with lifecycle callbacks so
when someone adds one of our components
to the page when they take it out of the
document when they change an attribute
on it we have all of these JavaScript
callbacks that we can run to react to
those changes render our component
differently firing an event load some
more data whatever you want so these are
sort of the sexy high level overview
kind of like selling points of web
components
but the most important thing about web
components is that when we're working
with them when we're defining these new
tags everything that we're doing all the
all the syntax that we use all the api's
that we use are the exact same ones that
the browser makers use when they
implement their own tags so when the
team at Mozilla or the team at chrome
when they are implementing the video tag
when they're implementing the textarea
tag all of that all of the AP is and sin
taxes that they used to do that are now
being exposed to us the developer
community so these are first-class tags
that we're building and that's pretty
wild and pretty insane it also means
that it's a very short hop to go from
successful web component to new standard
in the browser right and today we're
dealing with huge problems where to add
anything new to the browser takes years
it takes us like six years to add
something new to the browser the video
tag was proposed in 2007 it's 2013 and I
think there's probably some of you in
the audience you still consider that
like future technology you know like
I'll use the video tag someday when like
everybody is on board with the video tag
but not today that's a problem if we're
trying to compete with iOS and Android
in the sort of mobile space and those
libraries can evolve really quickly
we've got to be able to evolve quickly
as well so what are some cool things
that we can build with web components
let's imagine you're trying to build a
database library ok and the way that you
do that today is you write a whole bunch
of JavaScript the user needs to bring
that into their application they need to
instantiate it configure it they need to
pass it some data I need to call some
methods on it they need to find a place
on the document where your charts going
to show up it's a lot of back and forth
between your HTML and your JavaScript
when you think about it it would be cool
if we could just have a pie chart tag
and in your page you could say hey right
here I would like to have a pie chart
and voila you may get a pie chart you
know and maybe you can figure it with
some attributes but that's really like
the extent of your interaction with the
pie chart you don't really care how the
pie chart got made you don't care about
the library that made the pie chart you
just asked for a pie chart you got it
show of hands how many of you have
worked with or know what markdown is mmm
most do you okay so markdown is it's a
it's a language for sort of pre
formatting your text and if you've used
stack overflow or github they use it for
their comments it's really handy and it
would be awesome if you could just have
a markdown tag and just start like
writing your whole website in markdown
right like when that'd be awesome and
that's entirely possible like this is an
actual tag that I've made using web
components that just renders markdown
and imagine the cognitive like wait that
that would take off of your mind if you
were building the same sort of like
comment system that that stack overflow
or github has and instead of having to
like grab all the users comments turn
them into markdown render it put them
back into the document you could just
say hey so long as the user writes mark
down over here it's going to render and
I don't care how it happens I just know
what's going to it's a lot less work for
you to deal with so that's kind of the
the why of web components hopefully I've
sold you on the why of web components
let's talk about the how and as I
mentioned before web components are an
umbrella there's no one thing that makes
up web components it's for different
things and you sort of used them all
together the first of the those things
is templates templates are how you
scaffold out your component it's the the
reusable bits that you're going to stamp
out over and over again in the page next
is shadow Dom a show of hands how many
of you have heard the term shadow Dom
not necessarily know what it is but
you've just like heard someone say it
yeah and it sounds really cool when they
say it right like you're like how shadow
Dom yeah so shadow DOM is how you
encapsulate your component it's how you
guarantee that your CSS styles are
protected it's how you guarantee that
external javascript is not mucking
around inside of your HTML next we have
custom elements so custom elements are
how you extend the browser it's how you
extend the HTML language really and the
the custom elements are custom HTML
elements so the pie chart tag that I
showed before the markdown tag that I
showed before the Twitter bootstrap tag
those are all custom HTML elements and
lastly there's imports so imports is
just how we take all of this stuff pack
 together and load it into our
document the same way that you import
CSS or you import JavaScript you can
import custom elements so here's the
equation for web components that will
sort of give context to everything and
help it all makes sense keep this in
your head as we talk about the different
specs you've got templates plus shadow
Dom equals custom elements you take a
little bit of scaffolding you put it in
a little bubble where it's nice and
protected you give it its own tag name
and then you just import it into the
page so we're going to talk about each
of these so you kind of know how they
work by the end of this you guys will be
able to write your own web components
which should be a lot of fun I'm
starting with templates templates are
inert chunks of Dom that can be reused
throughout the page basically means it's
little blobs of HTML that you can just
like clone and stamp out elsewhere on
the page if you've worked with libraries
like mustache or handlebars before
basically the exact same thing but now
it has its own tag this template tag
that you can use in the browser so when
you're working with a template you can
put any kind of like valid markup you
want into it you can put paragraphs you
put SVG you put canvas whatever is like
valid markup on the page and put image
tags inside of it and when you put an
image tag in it or anything that
requires an external source like a video
tag on audio tag you can actually leave
the source undefined while it's in the
template because well it's in the
template it's inert the browser doesn't
really care about it and the nice thing
about that is you can then define that
source at runtime when you like grab the
guts so the template and stamp it out on
the page you can put JavaScript inside
of a template and that JavaScript inert
it's just like sitting there it's not
going to do anything until your template
goes live in the document when you're
working with a template you just query
selector the the template tag itself and
then you ask for its content so there's
this new content keyword and that's
going to give you all the guts of the
template and then you can actually throw
that onto the page so using a template
looks like this up here at the top we've
got the same template that i was showing
a couple slides ago it's got an image
tag in it that doesn't have a source
paragraph some JavaScript that's not
doing anything right now and then down
here in this little script block we're
going to query selector the template
use jQuery before and you're more
comfortable with jquery document query
selector is basically the same at just
writing dollar sign i'm sorry nan query
selector the template and then using
that content keyword we can actually go
inside the template and give that image
tag a source at runtime and then we can
just append the content of the template
to the document body so when we run this
some things should happen hmmm let's see
if I can run this guy so our script
block is going to go live because now
it's been added to the page the HTTP
request for our image goes out and comes
back so our image loads and then we see
the rest of the content of our template
down there so it's just like stamping
out a template using any other library
that you've worked with before there's a
few gotchas when you're working with
templates first there's no built-in data
interpolation which means if you used to
libraries like mustache and handlebars
you know that in those libraries you can
have like a JavaScript or a JSON object
on the page and you can just use little
curly brace tags to like pipe the data
from that object into your template
native templates don't do that the
browser makers wanted to leave that
process up to us but I say it doesn't
like work yet there's already libraries
which have added this this functionality
so it's there it's just not there
natively the other thing to know about
templates is that nested templates do
not automatically activate so if you've
got a parent template child template
inside of it you take that parent you
like stamp it out on the page the child
template does not suddenly start working
you've got to actually query each of
them separately and append them to the
document separately okay so that's
templates that's that's the first part
that's how we scaffold out our new
components now let's talk about shadow
Dom shadow DOM is a beast like there's
no way that we can even cover a fraction
of what it actually does in this talk
you could have an entire conference
about shadow DOM and there will be
conferences just about shadow Dom in the
next few years but we're going to do is
we're going to talk about the high-level
stuff so you can at least start being
productive with it and you can start
like poking around with it and
understanding generally how it works
you might feel like that at the end in a
nutshell shadow Dom provides style and
markup encapsulation you take some HTML
take some CSS and you put it inside this
little bubble and you decide which bits
are going to be public to the user and
which bits are going to be private which
bits like people aren't going to be able
to access and as a mission before the
really cool thing about shadow DOM is
that's the same technology that browser
makers use today when they implement
their own tags like video and like text
area so let me give you an example of
how that works we got a video tag up
there and you when you use a video tag
you just need like one line of HTML to
make it show up you're like yeah I want
a video here's the source for the video
i wanted to have control so use this
controls attribute but if you if you
think about it you're getting a lot for
just that one tag not only do you get
the video player but you get a play
button and a scrubber and a timecode
volume slider all this stuff right and
you didn't write any mark up for that
you're just kind of showed up and you're
like oh sweet well that's awesome glad
that I get that for free um what's
actually happening if we open the dev
tool so if you open the chrome dev tools
and I'm going to big in these so you
guys in the back and see so I'm trying
to make em huge so you click on this
little gear here and inside the devtools
if you scroll down you'll find this
thing that's a show shadow Dom right
there all right turn that guy on and
then you can go and spect your video
element so here's our video it's kind of
squished in there but that's our video
tag I can actually open it up and
there's this great out document fragment
in here and it's like what's that thing
and there's this dip in here and as you
sort of work your way deeper into the
video element eventually you'll see oh
hey like here's the play button and like
here's the scrubber here's all the
internals of my video player and the
browser makers have just implemented
them with HTML and CSS but they've
hidden it from us they've like put it
inside of this weird grey
documentfragment thing and I don't
I don't normally have access that I
usually don't see that thing so this is
the shadow Dom this is this secret place
that the browser makers previously have
only had access to where they could hide
markup and hide CSS and the reason why
they created it was because they needed
a way to guarantee that every time you
use the video tag that it would look the
exact same regardless of what you
already had on the page so you needed a
place where you could hide all these
things and they've actually been using
it for a really long time like inputs
text area you know they also have kind
of like a little bit of like styling to
them it's also because they're built
using the shadow Dom so when you're
working with the shadow Dom there's like
a few terms that are sort of important
to know the first is that the element
that's hosting all the shadow DOM is
known as a shadow host this first little
document fragment in here it's called
the shadow root that's the first
descendant of the shadow host inside of
the shadow root you've got all these
divs those are all called shadow nodes
and the whole thing is protected by this
little barrier called the shadow
boundary and the shadow boundary is what
prevents CSS from like bleeding across
it's what prevents JavaScript like
external javascript from traversing
around inside of here if someone's using
jQuery to look for like every div on the
page they probably don't want the divs
inside of here because we've like
explicitly said that you shouldn't touch
those so the shadow boundary is what
ensures that that separation so just to
like reinforce this visually the shadow
host is the element like holding all the
shadow Dom in the previous example it
was the video tag or it could be like a
textarea tag input tag or a tag that you
define the shadow root is the first node
in the shadow Dom it's that great out
document fragment and the whole thing is
protected by this shadow boundary and
that's what's keeping external CSS out
it's keeping external javascript out so
conceptually these are the main things
that you need to keep in your head when
we're talking about shadow Dom creating
your own shadow DOM is actually really
easy you just every like HTML element
now has this new method create shadow
root so you just call that on your
element after you selected it and I'll
show you how to do that
so to start off we've got a little div
here I'm going to give it a class of
widget and put some text inside of it so
that's this guy down here at the bottom
it says hello world and then in the
JavaScript we just query selector that
div we ask it to create a shadow root
and then we set the innerhtml of that
shadow root to a string of HTML we're
going to have like an emphasis tag that
says like I'm inside your div so if we
run this you'll actually see hello world
is going to change just say i'm inside
your div and if we actually inspect it
we can open it up and just like the
video element now we have this great out
document fragment and instead of there
we have that little tag that we wrote
this i'm inside your div tag so we've
we've taken some content we've like
hidden it in the shadow Dom you guys see
that okay now here's something that's
important to note hello world the
original text content that we had in
there it did not go away we did not like
destroy it or obliterate it or anything
it's still there it's just not being
rendered by the document or sorry by the
browser and that's a really important
distinction to keep in your mind that
only descendants of the shadow root only
the stuff in the shadow Dom actually
ends up being rendered by the browser
and so we're going to talk later about
how you can actually like pull things
out of the shadow host and into the
shadow root because you would you
definitely want that but for now keep
this in line because it's a really
important distinction to know all right
so I mentioned that when you're working
with CSS in the shadow Dom that the
styles that you use are protected this
is crazy to me this is like the coolest
thing about shadow DOM and if you've
ever written a lot of CSS and you've
been frustrated by like CSS specificity
and all these other things this should
make you feel better about the future of
your job so here we get a template
because we're going to we're going to
put a template into the shadow Dom
that's totally cool that's actually very
good thing to do inside of the template
we got a style tag in the style tag
we're going to say hey I think all h3s
should be white with a background of
tomato okay and tomato is like a
built-in CSS
color it's not something fancy that I
did and then we've gotten h3 inside of
our template that shows as a shadow h3
header so we're gonna take all of that
and we're going to put it in the shadow
Dom do that we query selected the
template we query selector our little
widget down there we ask the widget to
create some shadow root and then we
clone the guts of the template and we
throw it into that shadow root okay so
what we get is this thing at the bottom
that says a shadow h3 header and you'll
notice that the text is white the
backgrounds tomato and the other thing
to notice is that right above it is an
h3 header that just is like from my
presentation and the two look nothing
alike the two are not affecting one
another even though I have a style tag
and I've throw it into the document that
guy right there did not suddenly like
turn white and get a background color
and likewise this guy down here is not
using that typeface so they're
completely separate and that's thanks to
our friend the shadow boundary now when
you are working with styles in the
shadow Dom there's a few really like
high-level flags that you can use to
affect how you think style should be
interpreted and inherited and whatnot
the first is called apply off their
styles this is a this is like a boolean
value that you set on your shadow root
my default it's set to false and it
means that it's not going like like
author Styles any sort of styles in the
parent document are not going to be
implemented in the shadow Dom they're
not going to render if we set this to
true if we like toggle this to true then
it's going to allow those styles to come
into the shadow Dom it's going to allow
the the styles from the page to start
affecting our elements in the shadow Dom
so my h3 header starts to use the same
typeface as my other h3 header it starts
to use the same margining as my other h3
header my style tag where I where I set
a color to white and its background of
tomato that is also being applied but
I'm now inheriting author styles as well
so that's apply out there styles it can
be true or false by default it is by
default it is false the other one is
reset style inheritance so again you set
this on your shadow root this is also
false by default if you set reset style
inheritance to true it's kind of like
turning on the ultimate CSS reset have
you guys use CSS resets before like in
your apps right so while my h3 header is
not using any of the Styles my sorry my
shadow h3 header this guy down here is
not using any of the styles from the h3
up there it is still styled right like
it is centered for instance and it's not
using that type face but it is using the
same typefaces all my body text so it is
inherited some styles but if you set
reset style inheritance to true it's
going to like reset everything right at
the style boundary so now it goes back
to being left a line and it starts using
x bold and it's like 18 point or
whatever this is like the browser
default my style tag is still being
applied but everything else has been
reset so that's reset style inheritance
pretty cool other interesting things
that you can do remember how I said that
the element hosting all of our shadow
DOM is referred to as the shadow host so
we can actually style the shadow host
from within the shadow Dom this is good
if you want to add like rollover
behavior and stuff like that to
whichever element is holding all of your
content so there's a new CSS selector
it's this like colon host selector and
you can use that to actually style the
element holding all of your shadow Dom
the host selector is a like functional
selector it takes arguments so you can
say hey if my shadow host has a class of
skinny or if it is inside of an element
with a class of skinny I want you to
apply certain styles so you can use this
to like theme your component depending
on the context in which it is being used
whatever element is sort of nested
inside of it can change its appearance
which is pretty interesting you can also
use what are known as custom properties
so inside of your shadow style tags you
can say hey I think h2s should use a
font family and I'm going to set it to
this variable this is like css3 variable
syntax
so I think my h2 should use a font
family of variable header font I'm not
actually like specifying what the font
family is I'm just exposing a variable
and in the parent document someone can
implement that variable and say oh cool
I think bar header font should be
courier and that way they can actually
reach into the shadow DOM and style
something that I've exposed to them but
they don't have to know the particulars
they don't have to know the inner
workings of of my my shadow Dom which is
really handy because it means that you
can expose like sort of a limited set of
variables for people to mess around with
but then you can change the internal
structure of your shadow Dom all you
want you can mess around with the HTML
all you want and the users you know the
user and it's never going to break ok so
that was styling let's talk a little bit
about content so I mentioned before that
you can pull content from the shadow
host into the shadow DOM and you might
want to do that for instance if you're
building a button and you might have a
button was like really elaborate markup
in the shadow Dom but you still need the
label for that button to come from the
user so to do that you can create an
insertion point using the new content
tagged insertion points look like this
inside of your template you can say ok
I've been h2 and inside of my h2 I want
a wild content to appear and whoever is
actually using our element can then just
pass in some text they can say oh yeah
widget should have Jigglypuff inside of
it so when the browser composes these
two you end up with a while Jigglypuff
appeared for the Pokemon fans mmm the
content tagged by itself it's kind of
like a catch-all it's basically saying
hey any Content that you have inside of
the shadow host I would like for you to
try to render that inside of the shadow
Dom that means you could have like a
thousand lines of HTML inside of this
widget div and it would try to render
all of those you probably don't want
that you probably want more granular
control over how content appears inside
of the shadow Dom so you can actually
give your content tagged a select
attribute and with the Select attribute
you can use CSS selectors to pick and
choose which things you want from the
shadow host and where they should appear
inside of the
shadow Dom so that looks like this up
there at the top we've got a few h3s
says like last name content select
anything with the class last name and
render it right here select you know
first name content select anything with
a class first name and then here I've
got a content tag that's selecting with
MP quotes which is sort of like a wild
card it just means any other content
that what's not selected try to render
that right here when the user is using
our shadow Dom they can say okay here's
my here's my widget div I'd like you to
say hello world I've got a span here of
class first name raw I've got a span
here class lasting dodson throw that in
the shadow Dom the interesting thing is
that when it renders it renders
according to everything that we listed
in the shadow DOM and it since we used
content selection and insertion points
we can actually totally rearrange the
way the source actually appears so we've
we've basically like flipped the order
that everything is rendering out of the
host into the shadow Dom this is really
crazy it's really powerful because it
means that the user doesn't have to put
things in the right order it means that
so long as they use the right class
names or like IDs we can just choose how
things will render for them and that's
really powerful because it means that
the user could swap out one shadow Dom
for another you know and so long as you
know it's by the same author or whatever
it could completely change the
appearance and they never have to touch
their source okay conceptually I know
everything that I just said over the
past like three minutes was a total
mindfuck so Eric bidelman from google
put together a wonderful tool this
shadow Dom visualizer which will
actually let you write shadow DOM and
write like host node HTML and it will
just show you where everything ends up
which is really useful when you're first
getting into this and you're like okay I
think I understand how this works but I
have no idea actually how this works so
this is a really handy tool and you're
first getting started after you've done
this a few times so you'll you'll learn
to just like into it this and it as it
is not as confusing once you've worked
with it for a little and one last thing
that I want to show this is like
brand new so this just landed you can
actually style into the shadow Dom from
the outside using two new CSS selectors
one called the Hat and one called the
cat and the cat in the hat selectors so
I know I said that you know the shadow
boundary makes sure that the user can't
like accidentally like get in there and
start styling your element and that's
true they can't accidentally get in
there and start styling your element but
you do want to allow them the ability to
reach in if they absolutely need to so
that's where the cat in the hat selector
come in so the cat selector are sorry
the Hat selector this guy it's like
single carrot guy right here we'll go
one level deep into the shadow DOM and
allow you to apply a style there and if
you remember our content tagged from
before right like you can take content
out of the shadow host and render it in
the shadow Dom so that means you can
have shadowed on inside of shadow Dom
you can have like a shadow Dom inception
going on and that's where the cat comes
in the cat will let you pierce through
every layer of the shadow DOM and style
all the h2s inside of it so cat in the
hat that just landed in like chrome 33
brand new so um you guys are the first
to know ok so that was shadow Dom that
was a lot I know thank you for hanging
in there let's talk about custom
elements ok custom elements are new tags
that we create that extend with the
browser can currently do if you remember
the equation from earlier templates plus
shadow Dom equals custom elements so
this is the part that we're getting to
you get a template you're hiding all
this stuff in the shadow Dom just like
the video tag right you've got this like
cool one-liner of HTML that people can
use now let's just take it a step
further let's just define our own tag
for it so to do that we use the register
method which is a brand new method
that's been added to the document object
and you call document register you pass
in a tag name for whatever your new tag
is and you need to pass in a prototype
like a JavaScript prototype for it
there's two requirements won the tag
name must have a dash in it so it's got
to be tagged dash name or you know X
Dash fooooor
I dash widget that tells the browser hey
this is a custom element this is not
like a native a native element that's to
prevent someone from accidentally like
naming something that you know later on
the browser makers want to use that name
as well so that's kind of how you
namespace your element of sorts the
other thing is that your prototype must
inherit from HTML element and I'll show
you how to do that that sounds
complicated it's not okay so to create
our custom element the first thing you
want to do you want have a template you
know a template full of cool stuff in
this case we're just showing that you
would like query selector some template
somewhere full of markup and then you
need a prototype that extends HTML
element so you can do that using
object.create you can say hey I want a
new prototype and using object.create I
can just extend HTML elements prototype
that's that's really the extent of it
you don't have to worry about like
complex JavaScript inheritance I know
that's a confusing topic this is all you
got to do this one line right here on
this new prototype that you're creating
you need to have this one call back this
created call back this is like when the
parser is working its way through the
document and it sees our tag it's going
to check to see if it has this created
callback defined on it and if it does
it's going to run it like as soon as it
sees it so this is where you kind of do
all the setup work for your tag and
we're going to do here is we're going to
create our shadow route now we're going
to append the content so our template to
the shadow root okay we're just going to
like make sure something displays the
last thing we do is we call document
register we pass in our new tag name we
pass in the prototype that we've just
defined and we have like a new tag now
so using it really straightforward we
can just use our new tag name because
we've registered it we could also do a
document create element and pass in our
tag name the same way that you do
document.createelement image or div and
we could also call new widget so when we
call a document register it actually
returns a constructor to us if we choose
to expose that the people they can just
call new widget and add the the element
to the browser that way all right we
talked about the created callback which
the the browser runs as soon as it sees
our tag there's other really cool handy
cycle callbacks that we can use to build
up deconstruct manipulate our component
there's the interview callback which
gets run whenever one of our elements is
actually added to the page there's the
left view callback which is run whenever
one of our elements is removed from the
page and both entered view and left view
were previously called inner document
and left document you'll actually see a
lot of tutorials out there that use that
nomenclature don't use that nomenclature
it's being removed the last thing is the
attribute change callback and this is
really handy so anytime someone
manipulates an attribute on one of our
tags it's going to run this callback and
we're going to get the name of the
attribute that changed we'll also get
the old value and the new value so we
can react to someone like manipulating
one of our components you can also
extend pre-existing tags you don't
always have to just create a new tag
from scratch you can extend it
pre-existing tag and when you do that
it's called a type extension element so
if you want to just extend the button
tag you could still just call document
register you still got to give it a tag
name and then you pass in this extends
option so you're like it extends the
button tag and the prototype that you
pass in needs to be the prototype for
that element so HTML button element
instead of HTML element when using your
type extension element you can say
button is my button or document create
element button my button it really
depends on how you prefer to work with
these elements if you if you want to
inherit all of the things that like
anchor tags give you already then maybe
do a type extension element if you want
to create your own tag from scratch that
works as well yes question
yeah that's a good point actually yeah
like when you say extends button um well
I guess it's because you could also
extend a like a custom element that
you've already created this might just
be laziness on the case of the browser
makers that's a good question yeah oh I
don't know cuz yeah it seems like you
should be able to just say my button but
again that might just be something that
the browser makers put in because they
preferred that syntax so in terms of
like okay so why would you extend
something so you can inherit all the
things that it has like href and things
yeah right I don't know you'd have to
ask Google yeah okay so one thing that
you will see in a lot of examples is
people creating custom elements like
this where they do it declaratively they
use an element tag this is something
that was briefly added to the browser we
could just have an element tag and I
could have like templates inside of it
and do a bunch of other stuff this has
been removed like every tutorial I see
creates custom elements like this and
this has been removed so if you guys are
like researching this afterwards and
you're like oh hey this looks like the
much more straightforward way of doing
it it totally is the more
straightforward way of doing it but it
was taken out just because they were
having problems sorting out the
execution of when all the JavaScript
would happen or the order in which all
the JavaScript execute okay let's take a
break okay we are past all the painful
code for a little while ok let's look at
let's look at some cool stuff what could
we build with custom elements what could
we build now that we have access to you
know the ability to find our own tags in
the browser so i use MailChimp on my
blog for people to like sign up for my
newsletter these things look very
distorted on here normally doesn't look
so crazy like that but if you've used
male tramp views wufu or some other
service like that
give you a whole big blob of HTML that
you need to add to your page maybe a
whole bunch of CSS bunch of JavaScript
that you need to add your patient you
just go like chuck that into the bottom
of every page right that kind of sucks
especially if it doesn't look like the
rest of your code maybe they use
underscores instead of dashes or
something you know stylistically you
don't like it so I created a mailchimp
tag and all it does is it takes all the
MailChimp stuff and it just squishes it
down into one tag it's it's close to a
one-liner it's much less good than what
I normally have to work with when I'm
using mail champ if you do data
visualization there's a lot of back and
forth between JavaScript and your markup
on the front end it would be cool to
just have tags like this where you could
just spit specify hey I want a pie chart
donut chart bar graph and you just
configure them with values attributes so
you can passing an array of attributes
and that will just like set the way
those tags look and what if it wasn't
like you I at all that you were working
with what if you wanted to work with
more behavior type stuff so there's a
library out there called moment j s and
it's really cool it basically takes a
string of text and converts it into a
date object for you so you could pass in
October thirty-first 1983 or something
and it would just turn that into a
JavaScript date object right so I was
thinking okay cool let's make a moment
now tag let's just like encapsulate that
behavior into a moment now tag so we can
use the data object like in a paragraph
and we don't have to write any
JavaScript for that and then I was
thinking okay cool let's let's take the
moment now tag and let's just nest it
inside of a moment format tag is the
moment for Mac tags the only thing it
cares about is that its first child
exposes a date of some kind and then it
can configure that date using these
tokens and since moment for matt has a
consistent API the only thing that cures
about as its first child exposed as a
date you're gonna have a moment parts
tag and the moment parse tag someone can
actually pass in text and we'll turn
that into a date object and you can
actually combine like all of these into
a moment from tagged so the moment from
tagged just wants to see whatever
whatever two children it has inside of
it so long as they produce dates of some
kind it's just going to find the
difference between those two dates so
the cool thing
about this is it doesn't even have to be
like the moment library that you're
using so long as you expose a date in
the same way that the moment from tagged
like knows to consume them you could
have different tags inside of there but
this is kind of like some of the weird
crazy stuff that you can start to do
when you're not even thinking about you
I anymore you're just like what if I
just started putting JavaScript inside
if you're like what happens so pretty
interesting so everything that you see
on the screen no java script was written
to make any of that happen that's that's
all just like paragraph tags and those
tags down there okay last thing we're
going to talk about its imports and this
will be really quick imports load
external documents into your page is
basically how you pull in custom
elements right now working with an
import super straightforward use a link
tag the same way that use a link tag
when you're working with CSS there's
just a new relation type so normally you
say link rel equals style sheet now you
say link rel equals import and you point
it to some HTML file that you would like
to pull into your document using imports
very easy easy in your head you just
link to whatever HTML file you're
pulling in that's the actual like import
that I use to pull in all of those
charts that you saw and then you just
use your tags there's no waiting to see
if they've loaded there's no like a sink
checking that needs to go on you just
use your tag you can assume it's there
the same that you can assume CSS is
there which is really handy so that's it
collectively these are the technologies
that make up web components now the
support is spotty for sure Google Chrome
has everything that you need Firefox is
working on a lot of this stuff they've
actually got an open ticket to implement
shadow DOM and it seems like they're
like halfway through that IE is IE and
then Safari has some of the stuff in it
because it was originally in WebKit
before blank and WebKit forked so it's
like in Safari and I know that recently
they've been participating on the
mailing list and they've been like all
right let's let's talk about these
custom elements and everything so it
sounds like Apple is intro
in this as well if you want to play with
this stuff now though I'd recommend
using Chrome Canary you need to go into
about flags and you do turn on all these
different like experimental features and
make sure to turn on show shadow Dom in
the developer tools like I did that
earlier if you recall and that's if you
want to do native web components which
is awesome and i highly recommend it but
i don't want you guys to like coming to
this talk and be like well great like i
guess i'll use this in 10 years i wanted
to show you how you can use them today
in all modern browsers so to do that
there's this really cool library from
google called polymer and polymer is a
collection of polyfills which let us use
all these web components everything that
we've talked about today in all browsers
all modern browsers that includes IE 10
and above Safari 6 and above Mozilla has
a variant of this library called X tags
and that works all the way down to ie9
but it doesn't have all of the like
additional features of polymer if you
don't know what a polyfill is a polyfill
is just a collection it's like a sorry
it's a JavaScript library that sneaks
support for a cool feature into a
browser that does not support it so IE
basically now if that was all polymer
did that'd be really cool with polymers
also a framework for building web
applications so it adds all the cool web
component stuff but it also adds all of
these new technologies all the stuff
which is some of it is being like
standards that are being debated right
now some of these are just like total
like future things they're not even
traps yet we get web animations pointer
events template binding no binding and
model-driven views a lot of really cool
really powerful stuff packed into this
framework including all the web
components stuff and using polymer to
declare your own custom elements is
really easy it's a lot easier than doing
it the native way you just include
polymer and then you have a new new
element that you can use polymer element
and can give it a tag name whatever name
you want to up there it's like my
element I don't know is that me maybe
it's my head
you can put a template inside of polymer
element and polymer is smart enough to
know oh if there's a template inside of
this tag I should just turn it into
shadow Dom so it'll just like do that
for you and you don't have to write any
JavaScript to make that happen and you
can just use your element you're like
off to the races so this element down
here hello I'm on polymer element that
is using this polymer tag when you are
using the polymer element tag you can
create attributes and you can expose
these to the user and these become like
automatic bindings within your tag which
is really neat so here it says like I've
got a tag called fav color and I'm
exposing an attribute of just color
inside of my template I can say okay hey
I want an h2 and I want I wanted to say
my favorite color is and i'm going to
use curly braces to actually buying to
the value of that attribute and then in
the script tag i'm going to call the
polymer constructor i'm going to pass it
the name of my tag and then i'm going to
pass it a prototype object that's going
to have a default value for that color
attribute so when the user actually uses
our tag it's going to say okay cool I
want this fav color tag I want to set
color to purple and that just shows up
and we don't have to write any glue code
to make that happen the bindings just
work which is really cool what's also
really interesting about these bindings
is that they're like live two-way
bindings so as they change the element
changes and again you don't have to
write any code to make that happen it
just happens so here it says polymer
element the name is color picker the
attribute that I'm exposing is again
that same color attribute inside of the
template I've got this little span down
here and I've got this input down here
I'm going to bind the background color
for the span the text value for this fan
and the text value for the input all to
that color attribute so if I like go
over and start typing in here I can
change it from tomato to like sky blue
and like as I'm typing it's just like
updating inside of my element or I think
early wood is a really cool built in
color or papayawhip so you don't have to
actually like do anything to make these
bindings update they just update for you
and if you've seen demos of like angular
Jas maybe this starts to feel very
familiar and look a lot like their demos
and in fact there is a lot of overlap
between angularjs directives and web
components and there's a lot of talk
between those two teams about having the
project's kind of like maybe conjoin in
some fashion okay where's my cursor
every the last thing you need to know is
that when you're working with polymer
you still have the same lifecycle
callbacks which you can use to react to
changes the polymer team shorten the
name of them so instead of created call
back it's just created instead of
interview call back it's going to you
left you attribute changed okay there is
way more on this topic then what we're
going to have time to cover tonight so
to continue your further education if
you're like really interested in this
stuff I would recommend that you I'm
going to post these slides up for you
all to to go see definitely check out
web components resources that is kind of
like the one-stop shop right now to you
know learn all about web components it's
Eric bidelman from google collected all
the resources into one page which is
very handy html5 rocks has awesome
articles on web components check out the
polymer project check out x tags from
mozilla it's similar but different from
polymer brick is a whole bunch of UI
elements that the team at Mozilla has
already created that you can actually
start playing around with which is
really fun custom elements io is like a
registry that people have put together
of polymer elements brick elements
native custom element so you can go
there and you can browse what people are
already making and lastly check out the
chromium dashboard because it has the
status of all of these different specs
not just in chrome but also in Firefox
ie Safari etc if you're interested in
like any of the components that I showed
in this talk they're all up on github
fork them
break them do whatever you want go crazy
just like don't launch them in a
production unless you're crazy person
and yeah thank you guys uh yeah thanks i
hope i hope you're leaving here excited
by where we're headed with web
components and by where the web platform
is going to be in a few years so thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>