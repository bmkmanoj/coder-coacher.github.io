<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Java Evolution of Eclipse Collections | Coder Coacher - Coaching Coders</title><meta content="The Java Evolution of Eclipse Collections - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Java Evolution of Eclipse Collections</b></h2><h5 class="post__date">2017-12-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CW3kWD-tqo0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thank you so much for coming
my name is Kristen O'Leary and I'm gonna
be talking today about the Java
evolution of eclipse collections so
brief agenda for what we're going to go
through today a quick introduction about
myself
what is Eclipse collections for those of
you who don't know and then we're gonna
go through a bunch of new features that
were included in the 8.0 release this
this release coordinating with the Java
eight release so we included a lot of
new changes that correspond with new
Java 8 features as well so we'll talk
about optional collectors default
methods and then we'll take a look at
our primitive collections and how they
can work with Java 8 and then we'll take
a look forward into what's going on with
the pending Java 9 release and then if
we have some time I have some other
stuff we can look at too so a little bit
about myself I'm a software developer at
Goldman Sachs
I am a contributor to GS / Eclipse
collections for the last five years so
Eclipse collections was formerly known
as GS collections prior to that it was
developed internally for about 12 years
and I have been in Eclipse collections
kata instructor and contributors so the
kata is our set of tutorials so if you
don't know what eclipse collections is
and after this talk you want to check it
out or learn more about it I highly
recommend you take a look there so I can
point you to that at the end and I'm an
eclipse collections advocate so I've
been in a lot of cool conferences
talking at the goldman sachs booth
eclipse booth about eclipse collections
spreading the word about it and just
teaching people about it so what is
Eclipse collection so just before I get
into the slide show of hands who has
heard of eclipse collections before
knows what it is ok great and then out
of that group who uses it in their
projects awesome ok so for those of you
who haven't raised your hand hopefully
this talk will encourage you to take a
look and try it out in your Java
projects so Eclipse collections is a
feature-rich memory efficient Java
collections framework it was open source
in 2012 as gs collections as I mentioned
and now with our eight auto release we
are now compatible with Java 8 and above
so prior to the its auto release we were
compatible with versions 5 through 7
starting with a deado we're saying
you're only compatible with Java eight
because we wanted to leverage a lot of
the new things that Java eight brought
about so we'll look at a lot of those in
a minute our Eclipse page is eclipse.org
slash collections and other good
resource there's all types of links
they're links to our github account
links to the kata memory performance
charts other talks things like that a
good splash page for you to learn about
it and also most importantly eclipse
collections is open for contributions so
if you do use eclipse collections and
you want to contribute back to it you
think there's something missing that you
could use we're more than happy to take
your contribution so you can click on
the link below to learn how to get
started with that so new features in 8.0
so version 8 for Java 8 as I mentioned
before a closed collections work with
Java 8 you could use things like lambdas
and Method references no problem they
actually worked really well with our
existing API but that's pretty much all
you got you couldn't use any of the new
Java 8 specific features that were not
available before so we didn't require it
or embrace it really so version you
changed that so now if you have Java 8
code it's a very very easy transition to
eclipse collections and if you have
eclipse collections code it's way easier
for you to use Java 8 features like
collections and streams so we'll take a
look at a lot of examples coming up for
that so one of the first things that's
new with Eclipse 8 is that we our
functional interfaces now extend the
Java 8 functional interfaces so this
gives us some new Interop with Java 8
features directly in our own API so I'm
gonna cover all of these methods coming
up next reduce reduce in-place detect
optional if you're familiar with the
Collector's class in Java we have taken
it a step further and made our own
collectors class called collectors 2
again we'll cover that shortly we've
made use of default methods so we've
been able to write a lot of new features
on our interfaces and we've gotten a lot
more features with less code and
primitive collections in Java 8 we'll
talk about some of the specialized
things you can do there and how it
compares with the Java 8 primitives so
the first thing I'm going to talk about
is optional so again show of hands who
uses optional awesome me too
I love optional I think
it's a great feature before I get into
optional specifically I'm going to just
quickly walk you through our domain so I
have a lot of code examples coming up
and the domain that these code examples
come from is we have a list of people
each person object has a first name a
last name and a list of pets each pet
has a pet type a name and an age and pet
type can either the cat dog hamster
turtle bird or snake just an enum to
specify what type of pet it is so we're
gonna walk through some examples made-up
that involve this person pet domain so
back to optional it is a new JDK feature
for those of you who don't know and
directly from the Javadoc it's a
container object which may or may not
contain a non null value if a value is
present is present will return true and
get will return the value so basically
it's a way for you to avoid null pointer
exceptions it's a way for you to wrap
your objects around and so you can check
beforehand if they're null or not so it
saves you a lot of those nasty errors so
we think this is great now where can we
use this in Eclipse collection so rich
iterables detect with is one example
rich iterable is one of our highest
sitting interfaces and we have a lot of
api on it that our collections inherit
from so detect with is essentially you
can read the Javadoc but it's
essentially a way to iterate through a
list and you're saying find me the first
object in this list that satisfies a
certain predicate so it will return to
you the object if it finds one but if it
doesn't it will return no so this is
kind of a great case for us where we can
start incorporating optional into our
framework so that you don't have to deal
with getting back null values so what
happens
so from Licata this is taken from our
set of tutorials we want to find mary
smith so in this example the stock
people is our list of people and we're
saying detect with the first parameter
is our method reference to this method
on person called named and the second
parameter is mary smith so we're
basically saying find me a person in my
list called
mary smith if she's there she will get
such a big person object but in this
case mary smith is not in our list so
we're getting back a null value so what
happens when i throw
my assertions I get a
nullpointerexception because Mary Smith
returned back null so pre Java 8 there's
a couple ways we can solve this or
excuse me eclipse collections 8 oh
there's a couple ways we can solve this
we could write a simple null check say
if person is null create a new object
and then my assertions the tests will
pass this probably looks familiar to a
lot of you I've no I'm definitely
written code like this before but it's
not the prettiest it's not the greatest
another option before the atado release
was we could call detect with if none so
we could find Mary Smith or create her
so again this was prior to the it's Auto
release we have this other method which
is basically saying find me Mary Smith
if there's not one there create a new
one that solves our problem that's great
the test passes but now with eight auto
we want to use things like optional
they're really handy and we're not so we
want to find Mary Smith or create her
but instead we are calling the method
detect with optional so now we don't
have to pass that third parameter in and
instead of getting a person object back
we're now giving an optional wrapper
with the type person so she's either
there or she isn't so now we're saying
optional or else get so we're saying if
the optional is null get us a new person
which is then created and again the test
passes so again a nice way for us to do
you handle nulls and use it with a Java
eight style I think it's really really
useful so collectors what is a collector
who uses collectors in their code today
yeah a few streams I'm sure you use them
a lot that's awesome
okay so again new feature in Java 8 it
is a way to implement a mutable
reduction operation so basically
something we can do is accumulate into a
collection so again if you're familiar
with streams I'm sure you've used this
before and the JDK has several built-in
collectors so let's take a look at some
examples so in this these are all just
plain Java examples no Eclipse
collections yet so in the first example
we have our list of people we're calling
stream on it and we're mapping each
person to their first and
and then we're saying put that into a
list for me which is collectors dot to
list and so what that does is it takes
our stream and it puts everything into a
list of first names and the output is
Bob Ted and Jake
similarly something else cool that we
can do is instead of doing any type of
mapper anything we just want to get a
sum or a total of something in this
example we're calling stream on people
and we're saying collect collectors
that's summing int person get number of
pets of it's taking each person's number
of pets summing them and returning back
a total to us so these are really cool
and we wanted to wait for our users to
use collectors as well with an extended
API based on all of the features that we
have in Eclipse collections so starting
with a todo we can leverage collectors
awesome so we now have some built-in as
well collectors too there's really no uh
interesting naming convention here it's
just if you're typing collectors in your
IDE hopefully the autocomplete you'll
see collectors too and you'll be
inspired to use it so basically just
copy the GDK name but we have a lot more
built in as well so let's take a look at
those so in this example we are
collecting into a bags we have a list of
people we're mapping each person to
their pets or flat mapping and streaming
those again and then we're collecting
into a bag a bag is an eclipse
collection specific type essentially
behind the scenes it's a map of items
account so when you get this back
conceptually the bag looks like dog -
cat one snake one being those two dogs
one cat and one snake so since this is
an Eclipse collection specific type this
is a great way for us to leverage
collectors - if you wanted to put
something into an eclipse collection
site that doesn't exist in the JDK so in
the next example we have our list of
people we're streaming again we're
filtering the people who have cats and
now we are collecting them into an
immutable set so Eclipse collections has
a full immutability complement and
library so if you want to use any type
of immutable data structure you can use
collectors too to put them in now if
you're streaming originally so now we
end up with an immutable set of person
and the contents is Bob okay so this is
going to be a diagram that shows
you scratches the surface really of a
lot of the main types of collectors to
api's that you can use so we have most
types so you thought you saw things like
to immutableset
we have things like to mutable lists set
to sorted set above all things that
currently are not exactly on the JDK but
we have like my maps bags etc you can do
things like collect select reject things
that are somewhere in the JDK but if you
want to use those types you certainly
can we have primitive collections which
again I'm going to cover in detail
further but we have a full primitive
collections library as well so if you
want to collect into a primitive
collection you can do that using one of
these and again these are just some
examples there's way more we have a full
set of multi maps which is again an
eclipse collections concept not really
in the JDK unless you wanted to
implement it yourself so you can do
things like group by say to list multi
map or two immutable bag multi maps you
can see we have all these varieties of
different types of multi maps that you
can use so any type you want it's
probably their miscellaneous we have
some extra API that I think is really
cool so for example chunk basically puts
things into batches for use you can say
chunk my collection into twos and it
will create batches of size to partition
make string we'll look at in the next
example and then zip and zip with index
will return back to you a list of pairs
so again all API that exists on our list
sets maps etc directly but if you're
using collectors now you can use these
as well to get into those collections
okay so here's some nice ways we can see
some Interop with collectors and
collectors too these two examples
produce the same exact output but let's
take a look at how they're different
so in this actually I'm gonna look at
the second example first we are we have
our list of people we're streaming them
we're grouping them by their number of
pets and then we're saying map each each
pet to a string and if you do each
number of pets to a string and then join
them by commas so what we're basically
doing is we're getting an output of how
many pets each person has whereas
the first example we're using collectors
grouping by again which is the JDK one
but we're using collectors to make
string so as you can see we achieved the
same result here but it saved us a
little bit of code and I think it's a
bit more intuitive so this is a nice way
they're not mutually exclusive so you
can definitely use them together and to
your benefits it'll save you some time
and maybe some lines of code there any
questions before I move on and I'm
saying a lot of material fast yeah sure
a multi map is basically a map where
there's a key to a list or a set or
something else of values okay
default methods so who uses default
methods I'm just going to go through all
the lists okay for a framework like
eclipse collections which is very large
default methods really come in handy so
we'll walk through one example so as I
mentioned rich iterable is one of our
highest level interfaces so if you want
to add new functionality and we don't
use a default method we have a lot of
cascading things we have to implement on
the way down so default methods are a
great way for us to add new features
without having to write all of the code
that we would have to otherwise I mean
this is probably overwritten in a few
places but for the most part makes our
lives a lot easier so reduce in place is
a method that produces the equivalent
result as a collector so all the things
we've seen collect passing in a
collector this will do the same result
so why do we need this so in this
example we'll show simply we have a list
of people we're streaming them we're
filtering them based on their pet type
see who has dogs and then we are
collecting them into an immutable set
whereas in the second example we are
using reduce in place instead so we're
not calling stream
we're just saying select people who have
dogs and reduce in place so this is the
API we could use if we are not in the
stream sense but we still want to use
collectors so in this second example I
didn't call stream at all but I can
still pass in a collector and get the
same result so the contents of the set
is Bob and Ted there are the people who
have dogs where this really
comes in handy though is if we use our
immutable or lazy API so currently as it
stands today if you were to use the
Eclipse collections immutable library
you can't call stream on it same thing
with our lazy iterables you can't call
stream on them subject to change in the
future but for now this will not compile
as is so if we want to use collectors
reduce in place is our way to do that
without having to conflict with the
stream API and still keeping the types
that we want so in this example we're
calling as lazy by the way as lazy and
stream are pretty much the same thing
because streams evaluate lazily so at
this point stream is no longer available
we're selecting people who have dogs and
we're saying reduce in place collectors
got to set and notice that I'm just
using a JDK collector in this case and
not using Eclipse collections and I just
end up with a plain old hash set so
again a nice way for us to use
collectors in the situation where we
wouldn't have been able to otherwise
okay primitive collections so we've had
primitive collections since G s
collections 3.0 s we've had them for a
really long time they are a memory
optimized collections for primitive
types we have a similar interface
hierarchy to the object collections we
try to keep the API as similar as
possible there are some gaps so if you
use them and you find something missing
feel free to contribute it back and we
have symmetry among the primitive types
meaning it doesn't matter if you're
using an int long float double etc we
have the same API because we code
generate all of our primitive classes we
don't hand write off all of them that
would take forever so we have symmetry
across the primitive types which is
really nice so how much didn't in cost
this is one of our memory comparison
charts and it shows you the benefits of
using primitive collections if you can
versus an object collection so the
orange is the JDK ArrayList of type
integer and then the blue and green
respectively are GS collections and
trove and their memory performances with
an int list or an int array list of
seasoning so again as your element size
increases its it really does save you a
lot of memory so something to consider
if you're dealing with things that could
potentially be primitive so Alyssa
vintage shirt versus an int list Java
has object and primitive arrays but as
you all probably know primitive ladies
really have no behaviors besides like
Java does not have primitive list sets
or maps so primitives must be boxed and
boxing is expensive we have reference
and a header and alignment so this is
just a quick comparison chart between
the primitive versus JDK collections
that you can get with Eclipse
collections versus the plain old Java
collections so as I mentioned we have
primitive list sets Maps and stacks and
bags and vs. you'd have to box all these
in the JDK and for things like bags
you'd have to create a map first and
then box them since bag isn't readily
available for you you'd have to
implement it yourself where this becomes
interesting is with the stream API we do
get primitives but only for int long and
doubles so if you want to use the lazy
API on eclipse collections you will get
all eight primitives so as I mentioned
Java only has three primitive streams
and long and double to get into the
primitive collection side of things you
would call in stream dub versus stream
dub for creation they have specialized
lambda expressions and they are
interchangeable between the primitive
and the object types these new streams
lazy iterable is especially essentially
our version of stream API and we have it
for all eight primitive types you would
call as lazy on your collection for it
for creation and the API is similar to
the object and type specific and again
we have specialized functional
interfaces as well
these can now be used in Java H streams
to which we'll take a look at and as
we'll show in the next example they are
reusable which is pretty cool so use or
reuse so streams are like iterators once
you use them you can't use them again
so in this example we're creating an in
stream of one two and three
and we're calling min get us int we get
one great and then when we try and call
max on the stream we get an illegal
state exception with it saying the
stream has already been operated upon or
closed so unfortunately we can't reuse
this stream once we've already used it
once whereas if you have a lazy interval
you can use it as many times as you want
so in this case we're creating a new int
ArrayList of 1 2 &amp;amp; 3
we're calling as lazy on it which is
essentially the same type of API and
we're calling min we get 1 we call max
we got 3 no problem we're done so again
an interesting thing to consider if you
plan on reusing these types of things if
you want lazy evaluation this is a great
way to do it so now I'm going to walk
you through some code examples using
primitive collections and what you'd
have to do in both streams or the lazy
api's so we want to filter pet ages
appearing only once so in the first
example we have our list of people we're
streaming them we're flat mapping each
person to their pets and then what I
find interesting here is we have to call
stream again because wants to be flat
map on the pets we're out of the stream
we have to create anyone and then we are
collecting them with our favorite
collectors we are grouping each pet by
their age and we're counting how many
there are of that age and she set stream
then we're saying filter each get value
equals 1 and then we are collecting them
into a list so what this is doing is
we're saying get all the pet ages filter
the ones that equal 1 and return it to
me so we end up with a list of a map of
entry integer too long and the output is
3 appearing once and for appearing ones
whereas if you want to use this using
primitive collections and lazy API with
Clips collections you have your list of
people you call as lazy you flat collect
the pets collect int which when we say
collect int that's our signal that now
we're going into the primitive side of
things we want to get the int value not
the integer value when we call pet get
age and to bag so at this point we are
we have an int bag we don't have to
worry about oh we went back to the
object side as soon as you enter the
collect end stage if
it knows you're using a primitive
collection and you don't have to worry
about it going back to the object side
we call shoe bag we call select by
occurrences which is our way of saying
tell me the occurrences that are equal
to one so we get the same output three
and four and we end up with a primitive
collection instead find the mode of pet
age so find the most occurring pet age
so we essentially this is what we call
the collections top occurrences so in
the first example we have our list of
people we're streaming them or flat mat
this is all the same as before we're
getting the pet ages and Counting them
now what we want to do is we want to
sort the occurrences comparing by value
and then what's interesting here is we
have to call reverse so we get the most
frequent pet age on top and then we're
saying limit one get me the first one
and then collecting it into a list and
the output is two occurring twice
whereas in Eclipse collections if you
use a bag you already have the API
called top occurrences so we're calling
as lazy we're flat collecting the pets
we're collecting in of their ages we're
calling to bag on them and we're saying
give me the number one top occurrence so
again we're getting age to current toys
so this example is very similar finally
spring gum pet age you'll see the only
difference is here between the last
example and this one is we don't have to
call reverse here because now we want
the bottom occurrences sorry Jim
question
bags are not sorted now it's basically
in that behind the scenes so so in this
example we're just getting the bottom
once we don't have to reverse them but
same idea three occurred once whereas
when we called top occurrences here the
only difference is now we're calling
bottom occurrences so we occur at once
alrighty so Java not so who's excited
for Java 9 yeah yeah lots of enthusiasm
back there that's awesome so Java 9 as
I'm sure we know will introduce many
interesting changes to the
Java ecosystem so just to name a few
we're gonna have the module system and
internal API encapsulation so Eclipse
collections must in bold must change in
order to be compatible as it stands well
as it stood prior to the 8.2 release we
need to include some fixes to get ready
for Java 9 ourselves so one of the
examples that we ran into trouble with
is methods using reflection so we need
to change our methods that use
reflection in order to build so I'm
going to show you a quick demo as to one
of one of the things that we had is a
problem and I'll show you what we did to
fix it ok so full disclosure this is the
eclipse collection SCADA I have
repurposed it for my demo but the most
important thing actually let me make
this bigger ok much better
so we are using version 8.1 0 this was
our 8.2 was really some Friday's so with
this one we have not yet included any
Java 9 types of fixes so cute ok so I in
this demo I'm using one of our youth
static utility classes called
ArrayList iterate so I have an ArrayList
of people you know we would typically
never never do this with the club's
collections because you don't need to
make ArrayList we have our own versions
of lists but for the purposes of this
demo let's say I'm using some legacy
code and I just want some API on an
ArrayList so I have my list of people
and I am calling ArrayList iterate dot
all satisfies this is going to return
true or false based on some kind of
predicate my first parameter is my list
of people and I'm saying do all my
people for all my people check to see if
each person has a pet of type cat and
then I'm going to assert false that all
people don't have cats so what happens
when I run this so as you can see we're
running with Java 9 and I get an
exception in initializer error caused by
java.lang perfect buh-buh-buh-buh-buh as
you can see what this is
basically saying is you were using
reflection on ArrayList and you can't do
that anymore so how do we fix this so
that our users don't run into this
problem if they're using Java not
switching switching IDs okay now I have
number two so so in this version I am
using 8.2 which was just released on
Friday with some of our fancy job and I
fixes so I'm going to run the test again
and it passes right so what did we do so
our problem lied within this set
accessible method calling true on it we
can't do this anymore with Java 9 we
can't use this reflection sadly
unfortunately so what we had to do was
add this new data equals null and size
equals null so that these fields were
initialized and not just thrown away
this this catch block was originally
empty so what this is how we fixed it in
order just to pass it through
unfortunately this means that when we
iterate through our array lists this was
done for optimization purposes we don't
know exactly what the implications of
that are to see speed-up slowdowns I
have promised I would write a jmh test
to see how the differences are but TBD
so unfortunately can't do that anymore
can't optimize our iterations but we're
still able to work with Java 9 so again
that's just a very small example of one
of the things we had to do so
workarounds for reflection this isn't
interesting if you're curious
now with the open JDK I can open it if
you want but basically what this is
saying is if you're using reflection and
you're not and you want to use Java 9
but you're not quite ready to get rid of
all your reflection calls you can avoid
this with the command line arguments I
forgot what it is but it's basically way
of flagging saying ignore all the
reflection types of errors but because
we're a framework we proactively solve
the problem because we wouldn't want to
use to have to do that on account of us
you want to at least make sure we're
compatible we're ready we won't cause
you any troubles when Java 9 gets
released so with that I think we have
some extra time so here are some links
to the 8.2 release which again was
released on Friday has a lot more of
these Java 9 types of fixes if you're
curious and looking the second link is a
link to a presentation given by Donald
robbery staff stolen at JavaOne back in
September and it's all about collectors
so if you thought the collectors piece
was interesting to you it's definitely a
good piece to check out to see even
learn even more about it and
specifically how to create your own and
then since we have some time and I
always get questions about this we have
a presentation linking to some of our
memory benchmarks and performance tests
so I'm gonna open those up and just give
you a quick look at what we have they
make this bigger okay so we have done
all these types of memory tests to see
how they perform and how they scale
especially Derk elections frameworks and
the JDK itself these are a bit older so
this was wrong with Java 7 and GS
collection so clearly they are not the
most current versions but we do keep
these tests checked into our github
repository so if you want to run them
yourself and see how they run on your
machine feel free so they're all
available and you can check them out
yourself here's an example of I think
this is no this is just a plain object
one showing the differences between
using a mutable list which is RDS
clark's GS collections eclipse
collections version of a list versus the
JDK ArrayList versus a linked list where
things get more interesting is memory
savings with maps so we were comparing
to the JDK hash map to eclipse
collections GS collections collection
same thing trove and a JDK hash table so
a little bit more interesting here
here's another one with mutable set with
it which is our version of a hash set so
you can see here you're really starting
to save
with memory savings behind-the-scenes
bags since there are no JDK equivalents
we have a comparison versus Google's
concurrent map and so they're okay and
now here these this is the one that I
believe I showed in my presentation so
showing you the savings of using a
primitive collections list versus not
again
primitive Maps versus an object map
primitive sets and goes on I can leave
this up or if you want I can just leave
the link up so everyone can take a look
but we do have a lot of interesting
statistics here so if you're curious
feel free to take a look with that
that's pretty much all I had so I'm
happy to open it up to questions any
questions yeah for Java 9 you had about
the internal API is on the slide which
ones were you using I'm sorry said oh so
in this example so for Java 9 this was
the problem when we called set
accessible on data this is what caused
the issue for us anybody else all right
did I miss anybody behind the poll hi
thanks and the how do you manage to
reuse the what was it called the lazy's
was it interpol extreme yeah do you like
create one new one under the cover so do
you just reset it at the end so we the
way we have our API we never made it an
issue you can reuse them as much as you
want for what I don't know the design
reason why strings are like that but
that's the design decision they made but
for us
we just never put in that that
restriction that you have to use them
once
except for Java 9 can you tell us
something that might be coming up on
your roadmap um I can show you let me
pull up let me pull up our github so
this is the cauda if anyone's curious
but I'm going to go with you main page
so these are some polar crusts but we
have our whole issue tracker with things
that we want help with as well as things
that we want to do so you're free to
take a look here and or if you want to
contribute feel free also but this is
pretty much where we document all the
stuff that's upcoming and things that we
might need help us if anyone wants to
add to them alright thank you all for
coming and feel free to come up and chat
some more</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>