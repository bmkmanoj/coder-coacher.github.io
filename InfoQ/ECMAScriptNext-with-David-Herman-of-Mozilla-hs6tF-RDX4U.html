<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ECMAScript.Next with David Herman of Mozilla | Coder Coacher - Coaching Coders</title><meta content="ECMAScript.Next with David Herman of Mozilla - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ECMAScript.Next with David Herman of Mozilla</b></h2><h5 class="post__date">2011-02-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hs6tF-RDX4U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm here to talk about Ekman script dot
next whatever that version number
becomes probably edition six but you
never know edition four never came to
pass
so Ekman script out next is a long time
is the product of many years work but
it's it's coming relatively soon as
standards go so we actually have a sort
of a deadline coming up this spring
where we won't be accepting new
proposals anymore so we're getting to a
point where we're going to move into
more of a refinement mode where we've
got the proposals that we're working
with and we're going to start refining
them and calling them we have a rough
target of 2013 for actually shipping a
new standard but 2013 may sound a long
way away that doesn't mean that browsers
won't start implementing features as we
go along in fact one of the features
that we'll be talking about later
proxies is going to be already shipping
with Firefox 4 so features are coming
browser vendors will keep working on
these as we're refining and finally
finalizing the spec one other thing
that's important to realize is that this
new version of JavaScript is going to be
opt-in so by default if you say scripts
type equals application JavaScript just
as you would in the past you'll still
get Edition 5 of JavaScript but if you
want to opt into this new language you
can set the the version mime type I just
put next here as a placeholder the exact
syntax is and actually decided yet but
by making this opt-in we're actually
giving ourselves a little bit of leeway
in the design to be able to make some
backwards incompatible changes we're not
going to go wild with this we're not
going to make this a radically different
language but it does give us a little
bit of flexibility to make some
incompatible changes to make the
language as a whole better okay so
tonight I want to talk about three broad
themes that I would I would classify the
next version of ekam script into one of
these themes is is fixes this is trying
to try to fix some of the bad parts of
JavaScript
and this is where that opt-in is is
really helpful some of these are
expressiveness so they're making it
easier more convenient and more concise
to write in the good patterns the good
idioms that have kind of shaken out over
the years as people learn to write
effective JavaScript and some of these
are just raw power they give you the
ability to do things that maybe in the
past you couldn't do it all or maybe you
could technically do but they were
prohibitively expensive so I'll just
talk about these in order starting with
some of the fixes all right one of the
pain points of JavaScript has always
been the implicit arguments object
that's just bound by default it's a
little clunky that it's got this big
heavyweight name arguments and that you
don't get to control what the name is
it's always called arguments but even
more painful is the fact that it's like
an array but for whatever historical
reasons it's not actually an array it
doesn't inherit from a readout prototype
it's also annoying that often times you
find yourself writing a function that
maybe takes two or more arguments like
this one does and what you all you
really care about is the array of the
remaining arguments but you end up
having to slice off the part of the
entire array and of course because it's
not actually an array you can't just
call arguments dot slice you have to do
this painful jujitsu where you pull out
the slice method call that methods call
method and pass arguments as that this
and this makes me really sympathize with
Doug who has to explain this to
newcomers to the language I mean this is
just it's it's tough on newbies but it's
also tough on anybody trying to read
this code it's distracting and then of
course if you want to actually call
another method with that you know with
with that resulting rest array you have
to call the apply method which is also
kind of inconvenient so what we're
planning on for the new language is just
a concise way of saying I want to bind a
variable I can give it whatever name I
want here I'm calling it rest to
whatever the remaining arguments are and
I want that to be a real array this time
we're going to get that
so it's actually going to inherit from a
readout prototype so you can use all the
the raine methods you want but in fact
if all you want to do is splice that
into another call the syntax here makes
it easy to do that as well so these are
the kinds of things that are fixing some
of the mistakes of the past and just
making it a little less painful a little
less inconvenient we've recently been
talking about fixing a past kind of
strange aspect of the language type of
usually kind of makes sense but the
there's this one weird corner case the
type of null is object this is from
surprising it also makes it a pain to
write type testing code because you have
to do this extra level of check okay now
I know it's an object sort of except now
I have to check if it's null as well so
this is one of the places where we're
really just toying with the idea of
breaking backwards compatibility and I
think I think there's strong enough
motivation to do this but I think it's
quite likely to happen I should
interject really quickly and say that
nothing I say here is absolute or set
and so on it ain't over till the actual
spec ships so I'm not here making any
claim definite claims about the future
I'm just sort of giving you the the
current state of the committee's
thinking as I best interpret it this
will also want to say people have
questions or comments at any point feel
free to interject alright another pain
point this is one of my personal
Crusades in in JavaScript is the the
fact that the global object lives in the
lexical environment the scope chain of
JavaScript so if you have an unbound
variable that you write to or read from
rather than that being an early error a
compile time error it uses the global
object in a very dynamic way so this is
an example of a common very easy to trip
over bug in JavaScript where you assign
to a variable and you forget to declare
it with var at first and what happens
well you don't get an error instead it
just it just happily goes ahead and puts
that in the glow
object and carries on merrily well this
is even worse if you have a couple
pieces of interacting code that both
happen to make this mistake so here we
have two functions that both forget to
locally declare the variable I and now
they're actually fighting with each
other over that one single binding so
this code is going to completely break
because as the outer one calls or the
top one calls the bottom one the bottom
one is modifying the state of the top
one this function is not going to do
anything sensible so these two
undeclared uses of I really ought to be
an error that was a mistake that I made
as a programmer and I would like to be
told as soon as possible and we know how
to do this this is lexical scope this is
something that is a well understood
feature of programming languages so
another change that we're planning on
making for ACMA script next is to
actually make this be an early error so
you would actually get a compile time
error saying hey you used a variable
that you never declared this is also
useful if you just fat-finger a variable
name you know you happen to spell it
wrong and and now you're referring to
some variable that doesn't exist
currently what happens is your program
just goes insane and later on you find
out you know something's not working and
you have to work your way back till you
finally find the place where the error
came from often it doesn't manifest for
awhile so it only shows up later on
maybe you didn't even test that
particular path through your code and so
it doesn't even show up so you've
already shipped your code so this is
something we can do at compile time
and it'll just help catch silly kind of
trivial bugs but bugs that can be a real
a real pain in practice all right
another pain point the hoisting
semantics for variables in JavaScript
this is another one that's I think it
was actually originally intended to be
easier for beginners and ends up I think
being more of a problem for beginners
than anything else so here's a common
bug that people trip on all the time in
JavaScript we have some while loop and
we bind out what we think is a local
variable and we set some
call back say some eventhandler that
refers to the variable else so so here
this function is is a closure it's got a
lexical binding referring to the outer
or lexical reference referring to the
outer binding else but the problem here
as all you tried-and-true JavaScript
programmers surely know is that else is
in fact implicitly bound either in the
global or the or the nearest enclosing
function scope so what we thought was a
fresh variable binding each time through
the loop was not it's in fact one single
binding that's getting updated each time
we go through the loop and so each one
of these closures is actually pointing
to one single binding and by the time
you actually call that you're just going
to get the last value that it was set to
and once again your program behaves
erratically it's hard to track down what
went wrong so the usual way people work
around this is what I've heard recently
referred to as if he's immediately
immediately invoked function expressions
where if you want to introduce another
local scope for your VAR bindings you
just wrap it in a kind of useless lambda
a useless function that you immediately
apply and now you get the behave that
the behavior that you want but your code
is a lot more confusing it's a lot
uglier I was recently teaching a class
on web game programming to undergrads
and this this kind of thing undergrads
were running up against code like this
in the wild and they were getting really
confused this this really tripped them
up so when you kind of learn to be a
good JavaScript programmer you learn to
stop focusing on those bits of noise and
you filter out the parts that are let's
sort of have low information content but
that's not the way any of us wants to
write code we'd rather our code said
what we meant and didn't say anything
other than that so for for eccrine
script next we're going to introduce
introduce a new kind of variable binding
using the keyword let that simply gives
you what you expected in the first place
it's block scoped instead of function
scoped so now you don't have to use the
immediately invoked function expression
you just kind of get what what you
originally wanted in the first
place the slogan that we've had for
years going back to the ACMA script
edition four days was let is the new VAR
where it's our intention to make it such
that you actually never need to use var
ever again
if you don't want to you can just use
let as a drop-in replacement it'll work
in the cases where it worked before and
generally it's just going to work better
unless you were relying on hosting to
the function level but but by and large
let it's just sort of a better way of
doing bar I think I saw a question okay
yeah I should make that clear what I'm
describing here is ongoing work on a
standardization committee none of this
is stuff that's necessarily shipping in
any browsers yet but some of them come
from work that we did back in the ACMA
script Edition for days and so some of
this stuff in one form or another is
actually shipping in one browser or
another primarily SpiderMonkey and
firefox so let does exist and has
existed for years in SpiderMonkey in a
slightly different form than what we're
probably going to end up with in the
spec but to a first approximation it's
basically this feature that we're
talking about but by and large most of
the features I'm going to be talking
about tonight do not exist in any in any
browsers what what features there are
that that have been implemented I think
are almost exclusively in Firefox but I
can I'll try to point them out as we go
along so yeah the the rest args that I
talked about is not implemented anywhere
the change to type of is not implemented
anywhere let is implemented in
SpiderMonkey but I'll try to make that
clear as we go in
oh I'm sorry spider monkey is just the
name of the JavaScript engine that ships
in Firefox so in Firefox let has been
implemented for several years okay so
those are a few of the fixes to the
language so let me talk about some nice
idioms that we're gonna make more
concise in JavaScript here's one that's
just I think just really kind of sweet
people in JavaScript to really enjoy the
fact that functions are first-class
values they get a lot of mileage on
out of that I mean especially with
callbacks for event handlers but we're
starting to see some functional idioms
like map for each and reduce that have
been introduced in in more recent
browsers and the the syntax for function
literal is it's just a little
heavyweight in JavaScript you've got a
write F UNC tion and for the return
value you have to add re tu RN so we're
going to introduce a nice new very
concise literal syntax that people have
been toying with different names for
them hash functions except a hash
function that's something else in
computer science so maybe sharp
functions Mike shaver wants to call them
pounders because they're spelled with
the pound sign whatever you end up
wanting to call it there are two
benefits here
one is that fu NC tion is now spelled
sharp so you save a bunch of characters
there but the other is this a nice fact
that you don't have to say return
anymore
now you're just going to get the what's
known as the completion value and the
ACMA script standard as the result of
the function and we'll come back to that
in a couple other places in the talk you
had a question the question was for from
minifiers this this could be really nice
but what about functions that actually
do want to return a value and in fact
that is what's going on here so this
function is returning the result of L
sighs now if you want a function that
doesn't return anything but you want to
use this syntax you can wrap the result
with the void operator or could put a
semicolon and some dummy value
afterwards you can do early returns yes
yes yes so you can still use return but
the completion value is there's a sort
of an implicit return around the whole
thing yeah yeah okay and this is
actually a more recent feature so
there's probably some corner cases we
may still have to work out okay actually
this goes back sort of to the fixes of
the language one of the one of the
continuous pain points of JavaScript is
the the binding semantics for for this
so this is sort of the simplest example
I could come up with of a really common
bug that happens almost every time I
right a constructor in JavaScript I mean
I shockingly get this wrong almost every
single time here we have some node type
maybe it's a note in an ast or it
doesn't really matter and it's got a few
fields and maybe one of those fields is
an array and we use the for each
function on that array for each takes a
function as its argument that it's going
to call on every single element of the
array and I want to refer to this dot
type of the node well that's not how
this works in JavaScript for each is
actually going to call this function I
believe in in non-strict we'll get the
global object in strict mode I believe
we will get undefined for this but in
either case that this is not the list
that I expected it to be so we're not
going to up and just change the
semantics of function literal of the
existing function literals but for the
new function literals
we're actually simply going to have this
be lexically bound so we no longer have
to do the VAR self equals this trick
that that every JavaScript programmer
has to learn if you use these pound
functions this is simply lexically bound
I don't I think I don't have an example
on the slide but if you do want it to
take this as the sort of implicit
parameter you actually make it explicit
by saying sharp open paren this comma
and that's your way of saying I want the
this that comes from the call site so
you actually get explicit control over
which this you want but by default you
actually get the lexical binding
semantics which is half the time like
what you expect so that's another sort
of fix that might might have fit in the
first section as well okay then the the
next one is very near and dear to my
heart this is something I've been
working on for quite some time I've been
working with a postdoc at Northeastern
University in Boston on the design of a
module system for JavaScript so the
design pattern the idiom that people
have come to use in JavaScript when they
want to write modular code you can sort
of - at least at first just
use objects as modules so if you want to
share a bunch of functionality with
somebody you can just give them an
object and maybe bind it in some
standard location so my simple example
here is I've invented a new language a
new library for dealing with animations
and so I'm calling it sprite core and
one of the one of the constructors that
I want to make available to users of
this library is the canvas constructor
you can imagine many more features in
here but we just start with this little
object with a canvas constructor well
one of the first things that you have to
do when you're writing a library is make
sure that you're not trashing the global
object all over the place so once again
you start using these immediately
invoked function expressions the if ease
you wrap your object constructor with
this function that you apply immediately
and maybe you just want to give it a
standard name for the global object so
it always knows when I'm dealing with
the global object this is where I'm
touching the outside world everything
else will be a local variable it's just
sort of good practice to keep separate
the local from the global but we still
just returned this object but when you
really want to be a good citizen on the
web you want to make sure that well
maybe somebody else had a library that
they called sprite course so if for
example you study the the source of the
jQuery library you'll see that it uses a
pattern where they say let's just to be
safe
save the original definition if there
was one sprite core and we'll create a
local function called restore again to
be good citizens to make it possible to
restore to the previous value of sprite
core in case I happen to step on
somebody else's toes but then we have to
make sure to share that restore function
with the rest of the world via this
return object so we put it down there in
the bottom and before we know it I've
added all of this boilerplate just to
kind of have the standard functionality
of a module but the only parts of this
code that are actually relevant to the
functionality of this module or the
parts in blue the rest is boilerplate it
doesn't have to be this way but we need
new functionality in the language to
make it better so we're adding a new
module form that kind of sweeps all this
extra work under the
for you so now you can just declare your
module sprite core and you say export
for everything that you want to share
and now people can just use your module
it's bound to the name sprite core like
it was before or better yet maybe you
just put it in a separate file now you
don't even have to put the module
declaration you can put it in a separate
file and simply say what things you want
to export and this is about as minimal
as you can imagine the code getting this
is just saying what you mean which is
what we always strive for in language
design so the next question is well if I
put it in a separate file how somebody
actually going to use it what is the
client see what's the clients interface
to this module well if you look at what
people are forced to do right now in
JavaScript any kind of i/o requires that
you use callbacks so if you want to load
a file over the web maybe you use xml
httprequest or maybe you use a library
like requirejs but in any one of these
cases you have to provide callbacks that
are going to be called by the event
handler or by the event queue when the
actual data has been loaded off the
network this is the asynchronous i/o
model of JavaScript that's just built in
yeah sorry the question was why am I
using the future tense and the answer is
poor use of English yes so so this is
the bad old days here which are actually
now and the next slide is unfortunately
you know probably a couple years into
the future but but it is coming and
we're working hard so right so the
problem here is that whenever we have to
use callbacks we end up sort of
inverting the control flow of our
program we end up with this very strange
shape to the code where the core of the
program is actually buried somewhere in
the middle and that's just an
unfortunate way to have to program
especially if what we're dealing with is
simply using a few modules I mean in
most languages if you want to just
import a few modules you throw that at
the top of your program and then you
don't think about it ever again and the
rest of the code just to use modules if
I have to wrap my entire program and a
bunch of requires and then put the body
somewhere off to the right that's going
to make every program difficult to read
and there are people doing heroic F
it's right now to build libraries that
do what they can to avoid this but
they're sort of just stymied by the
basic IO model of JavaScript and this is
where you actually need to change the
language this is where library authors
don't have the tools they need to make
it better we actually need to improve
the language so with the module system
that we've been designing you once again
get to write in a direct style you
simply get to the client so this is what
the client would see now the client
simply gets to say module sprite core is
that source that is located at that URL
and the IO the reason why we can get
away with doing this is that the IO is
going to be performed at compile time so
there's no need for callbacks because
none of this corresponds to any sorts of
runtime io
the other nice thing about this is that
we let the client actually come up with
their name that they want for the
library so when a couple slides ago I
said we could actually eliminate the
module declaration entirely and put it
in a separate file the library authors
no longer naming the module it's the
client that gets to name the module and
that I claim is the way it should be
clients know best what they want to give
as the name for your library to make
sure that it doesn't conflict with
anybody else and when they make sure
that it doesn't conflict with anybody
else that means that the module writer
no longer has to do those crazy tricks
to save the previous version of this
name and make sure and it doesn't rely
on everybody being a good citizen so
library authors can just quickly ship
their their library throw it in a file
and the client gets to decide how to
name it and that just immediately takes
care of the naming conflicts so a
question here first I think the question
was people use the terminology are these
modules Singleton's meaning if you
require the same module multiple times
from the same URL do you get back a
single instance or does it reload
separate instances and the trick here is
at the sort of basic language semantic
level we're allowing for the fact we're
allowing for the possibility of caching
the results but in the browser it
actually doesn't make very much sense to
have multiple requests for the same URL
give you the same end
since and the reason for that is that
there's no really straightforward notion
of are these two URLs the same for
example if I ask for Mozilla org slash
Dave Jay s versus wwsz org slash Dave KS
I might know that that's the same file
and I might expect them to be treated
the same but there's no way for the
language to know that in fact I could
ask for the exact same URL twice at two
different times and the server could
deliver arbitrarily different bits
servers can do whatever they want
whenever you do a request so on the
client side in the browser what our what
our design does is it actually gives you
a separate instance each time and so
generally speaking you'd want to put
these kinds of declarations further up
in your program and those bindings the
name bindings now you can share those as
much as you want but I'm just gonna
leave it at that for now because that
there's there's a lot that goes into
this and we could talk more offline so
the question is are the modules always
loaded in order is there a way to say
that you can load these in different
orders and maybe in parallel this is the
static portion of the module system
there's a whole nother level of dynamic
module loading that I'll talk about just
a tiny bit towards the end that gives
you a lot more control over when you
want to do things the downside of that
is that you have to work in callback
style again but with the static system
they actually just get loaded in order
now that said there's nothing preventing
the compiler from actually loading the
bits and doing all the compilation in
parallel it's just that the actual
evaluation of the code as it executes
the body of each model module has to
happen in order and that's really
important because first of all
JavaScript does not it has a run to
completion model it has this notion that
your code executes sequentially and if
and modules can have side effects they
can they can save global State they can
they can share state if you start having
the language semantics kind of
non-deterministically doing these things
behind your back it's going to make it
very hard to understand the behavior
your program so we're trying to preserve
that sequential nature of JavaScript but
if you want the more flexibility in the
more power you get that with the dynamic
API uh let's see
all right so the the last little piece I
want to talk about here and again I
could talk exclusively about modules
this is this is something that I've put
a lot of time into but I'm just going to
give you highlights here so you you can
import out of a out of a module because
these modules are known statically that
means that we still have static lexical
scope the the compiler understands
everything about the button the bindings
that you get locally so here we have
import sprite cord star that's going to
import the canvas constructor but if we
spell canvas wrong we still get our
compile time errors so like I said in
the first section we want early errors
for misspelled variable names or unbound
variables we still get that with this
module system so that's it for modules
for now happy to talk more later this
structuring that now this is one oh I
should say modules are not yet
implemented anywhere I've been working
on a prototype implementation in a
JavaScript interpreter that we use just
for experimentation called narcissus but
it's not shipping in any browser we do
have a Firefox add-on that lets you
actually play with dropping that in as a
replacement for the built in engine but
that's just for experimentation it's not
a production quality implementation so
there are no there are no shipping
implementations of modules yet we're
still working out some of the details of
the design but it's it's coming in to
shape the structuring however has
existed for a number of years in Firefox
I think it also exists in opera I'm not
sure and I think that that's it the
structuring just makes it really easy to
do a lot of things that you otherwise
have to bloat your code with so a common
pattern in JavaScript is to take an
options object as a single argument as a
sort of lightweight way of doing keyword
arguments so maybe we have an element
constructor where you provide a single
object that has a width property a
height property and a color property
they're all optional this code just lets
you say that directly instead of having
to write line after line after line of
VAR w equals options dot with VAR h
equals options dot height just get to
say that right in place or for example
if you have a function that returns
always returns a two element array then
you can just directly in place bind the
two elements of the array and it
automatically D structures the result of
the find function so again this is just
quick highlights but the structuring is
fabulous once you start using it you
wonder how you ever lived without it
yeah so the question is can you have
nested d structuring and you absolutely
can so you could say like if you knew
width was a pair you know it was a two
element array you could say with : Open
bracket X comma Y close bracket so yeah
the structuring can be sort of
arbitrarily recursively nested okay
that's destructuring
generators I don't have nearly enough
time to go into the detail of these
these are a bit of a high-powered func
functionality but generators are
something that have been the idea came
from Python and in turn that came from
sort of decades of programming language
history they're sort of the idea of
co-routines and and Firefox has had them
for several years the idea of the sort
of main driving use case at least in my
mind for Y generators are useful on the
web is for dealing with this kind of an
inversion of control that you get
especially in call back heavy code so
kind of similar to before where we were
talking about modules here maybe we just
have several different files that we
want to load via xml httprequest and
again we find this strange inversion
where by the time we actually get all
the results we want our code is way far
on the right embedded in the middle of
this strange shaped code and this is
another one of those big pain points
that people complain about in javascript
all the time so generators without
getting into too much detail allow you
to write code like this now I I'm using
a little sleight of hand here I'm
actually using
library that I've written called J s
task that library is less than a dozen
lines of code so it's really not a very
heavyweight abstraction but it just
makes this example a little bit easier
to read so imagine we create a new task
think of this sort of like a thread but
it's a cooperative thread I'll explain
what that means in a sec so this task
takes a thunk it takes a function that
it's supposed to run and that function
is now going to do each one of these
loads
but before each one of these loads you
see this yield keyword what yield means
is I want you to halt what I was about
to do and suspend the rest of this
function to be called later and
basically that gives us the ability to
do this kind of back and forth style
with the i/o and the callbacks again I
don't really have time to go into too
much detail but the point is that the
shape of this code looks a lot more like
the shape that you want to write when
you're doing a whole bunch of sequenced
IO operations in JavaScript so this is
another thing I'm happy to talk about
more offline but I think we'll leave it
at that unless people want ask questions
sure so the w3c agonizes over these
kinds of problems that the API design
that you're forced into with JavaScript
execution model whenever you're doing
any kind of i/o such as storage file
file i/o this comes up all the time and
what we're trying to do is give sort of
one solution that can make a lot of
these things easier I think time will
tell how it affects people's actual API
design but this is existed in JavaScript
in in Firefox for years and add-on
writers for for Firefox use this a lot
they find it find it a lot more
convenient so I'm very optimistic that
this is going to make it into the
standard and it's going to make a lot of
API is easier to use so in MongoDB you
find yourself inserting a bunch of
records and you don't care individually
what order they get inserted in but you
do want to wait on eventually all of
them
I entered into the database is there a
way that you could use something like
generators to express that where you can
still allow for non determinism locally
but then deterministically wait on the
whole thing just a first guess would be
no that's not possible but I am NOT
going to swear to that because it's it's
a fun problem to think about offline we
could talk about the parallels in
Haskell which is which is really
interesting but yeah and at that I think
we'll offline it more questions on
generators before I keep going I
apologize that none of this is in depth
enough I'm trying to give some sort of
highlights of the language and show just
how much cool stuff we've got coming in
JavaScript ok that's fixes that's
expressiveness we'll see how much of the
the power features we can get into that
last one was kind of creeping towards
power features all right but some of
these are just straightforward things
that are just really hard to do hard to
impossible to do if you want to create a
hash table a map that uses arbitrary
objects as its keys in JavaScript
there's no way to do this that is an
order n that I know of unless you're
smarter than I am because the only
operation that we have to compare
objects is equality we don't even have
ordering of object identity so you can't
even do login you have to do an order
end scan every time you want to look
something up in an object table in
existing JavaScript you have to do an
order end scan so we're just going to
give you Maps we're gonna give you
object keep Maps and they'll be
efficient and that sort of ends that
sets is the same basic idea except if
you want to map where you don't care
about the values you could always
implement sets in terms of maps but it's
a batteries included kind of thing it's
just nice to have out of the box but on
top of that sometimes you also want maps
where the keys are actually held weekly
and that's even more of a power feature
it's not something that you necessarily
come up against all the time but
infrastructure or sort of infrastructure
writers framework framework writers find
the need for this they're also certain
really interesting idioms you can do
with this there's any
I'm called soft fields that's really
nice it lets you take an existing object
and pretend like you're adding another
field that no one else can see to it by
storing it in a side table but you want
it to be a weak reference because if
this object goes away you want that
entry in the table to go away so that's
another use of weak Maps again something
we're just going to put in out of the
box and not implemented in any browsers
that I know of I think there's a patch
waiting to land in Firefox that
implements weak Maps already so that's
probably coming fairly soon but it's
after Firefox 4 um but uh that's just
something you can't do right now you
can't implement that yourself in
JavaScript proper tail calls this is one
I'm very excited about it's one I've
been trying to advocate for for years
and it looks like it has broad support
from the committee so I'm feeling very
optimistic about it so here's an example
where I think proper tail calls could
reasonably be called for there are
different ways you could write a
function like this but let's imagine
you're implementing some little bytecode
interpreter in JavaScript
maybe you are implementing CoffeeScript
in your and you're compiling
CoffeeScript to byte codes and then you
have a bytecode interpreter well that
bytecode interpreter typically is going
to have one big switch that goes over
every possible bytecode that you could
be looking at and that code quickly gets
out of hand it's a really big block of
code this example is 10,000 lines of
code because I say so
you'd really like to be able to factor
this out into multiple helper functions
but the problem is you want to be able
to do things like continue or break you
want to be able to control the control
flow and if you put that code into
separate functions you can't use
continue or break anymore
there are tricks that you can do to kind
of pervert the code to to do this tricks
known as trampolines but one way that
you might actually want to write the
code is using a jump table so you write
your VM function simply as a function
you look up the next byte code in your
unit that your program counter is
pointing to and that and you look up
that byte code in a table that you store
it on the side and that table just
Taine's functions that you want to
decide what to do next the functions
that want to continue in the loop when
they're done simply call back into the
loop when they're done the functions
that want to abort the loop simply don't
call back into the loop but if you try
to write this code in existing
JavaScript it's going to run a lot
faster than you expected it to because
it's going to die almost right away with
a stack overflow
and the problem is what you're trying to
do is continuously call back into the VM
is the last thing that you do when when
this OP edie handler calls into the VM
it's saying I'm done I've got nothing
else that I need to do I just want to
jump to the VM but with improperly
implemented tail calls it's going to
hang on to this stack frame and you're
going to hang on to more and more stack
frames as you keep going through the
recursion and pretty soon you're gonna
blow up so what proper tail calls says
is implementers of JavaScript are
required not to hang on to that stack
frame unnecessarily and that makes this
code work so I don't know how often
people are going to use this but it's
there if they need it and there are
certainly styles of programming that
people use to good effect this is one
continuation passing style is another
one it's the kind of thing where it's a
fairly advanced style of programming
it's not something you use every day but
when you need it you really find you
need it and if you don't have proper
tail calls you're just kind of stuck
yeah this is a great question so the
question is why is this considered a
change to the programming language
instead of something that implementers
can do and it's a good question it's
it's it's a common question and the
reason is that unless programmers can
rely on this sort of quality of
implementation they simply can't use
this style so if two out of three
browser vendors implement proper tail
calls and it's not mandated by the spec
it's just considered an optimization
well you just can't use it because the
codes not going to work it's going to
blow up with a sec trace in that third
browser that doesn't use it I shouldn't
have said three there's many more than
three
browsers if n minus-1 out of the end
browsers but so by mandating this in the
spec we're saying all implementations in
order to be considered valid
implementations of the next version of
Ekman script are required to provide
this level of quality of implementation
then programmers can know that they can
rely on this and if it doesn't work on
one of the browsers they can call up
their browser vendor and say hey you're
violating the spec and you it's a little
bit hard to write test cases that
demonstrate this but you can do it like
you can do it with with eval you can
call a function and see if it blows up
with a stack trace so you can write test
cases that show hey browser X is not
correctly implementing proper tail calls
because it's blowing up with a stack
trace and that's what the finger and say
this is an invalid implementation of
JavaScript but that's why it's a it it's
necessary to standardize this because
otherwise people just can't rely on it
so the question is why not have a an
explicit operator that says hey I want
to do a tail call here that sort of puts
it more overtly in the language that's
certainly a a possibility that we've
talked about and there's a fairly wide
design space here the the simplest
answer is this is the minimal amount of
change required to the language without
having to introduce new keywords or
drastically change the language it's
also something where there's there's
trade-offs either way the implicitness
means that it's easy to miss when you're
reading the code that oh this relied on
being a tail call so it could be nice to
have the explicit operator but the
explicitness if you go with the explicit
operator the downside of that is that
you miss a lot of opportunities for tail
calls where you just may have forgotten
to put that in there this is one of
those things where there there's
trade-offs no matter how you go
traditionally languages with proper tail
calls have them implicit we're actually
working on another language at Mozilla
right now where we have explicit tail
calls and we're kind of forging new
ground there but yeah it's it's
debatable I tend to prefer the
implicitness in scripting languages
but yeah we could we could certainly
discuss it so the question is to do any
existing implementations have property
of calls and no none of them do it's not
always trivial to implement when the
underlying language doesn't have proper
tail calls so C++ doesn't and all of the
major browser vendors implement
javascript in C++ so it's some extra
implementation burden to do this but
it's not impossible it is doable and and
we will be working on this very soon I
think at Mozilla we've got a couple bugs
on file we got a ways to go but we are
we're planning on implementing this
binary data yeah so there's there's no
straightforward way of representing
binary data in JavaScript usually people
just encode it in strings and more and
more people are wanting to do i oh you
know network io file IO were they're
manipulating binary data and different
libraries and different Java scripts
embeddings are designing their own api's
but this should just be built into the
language so I've worked on this a fair
amount it's just to give you a quick
flavor the binary data spec basically
lets you introduce new types new binary
data types that are actually first-class
values so point to D here is a value
it's an object that represents a sort of
schema for binary data of a certain
shape so here it's a struct type which
has two fields x and y they're ordered
first X than Y and they're both UN 32s
and RGB is another struct type that's a
triple r g and b of unsigned 8-bit
integers and you can nest these types
inside of other types so we can create a
segment that itself is a struct
containing 2.2 DS and an RGB but these
these sort of schemas for binary data
can be used as constructor so you can
construct new instances of binary data
and the nice thing about having these
schemas is that means that the VM can
implement them as dense packed binary
data so they have very space efficient
representation
so here we create this new segment and
it's given initial values for everything
so you never have data in an
indeterminate state the way you do and
see this is JavaScript we don't want any
non determinism that's unnecessary here
and we certainly don't want memory
safety issues so you always have to give
default values for everything or
actually I think in some cases we we
have reasonable defaults defined in the
language okay so this gives you the
ability to create binary data kind of
similarly to the way you do in
statically typed languages but in a
dynamically typed language by having
these first-class type descriptors so
this could be used for things like IO
libraries like the w3c is working on a
file IO library and we're working as
fast as we can to to provide this to
them so that they can build on top of
that so maybe we have a record data type
that describes some record in a in a
file format and then we might have some
input stream that lets us read from a
file and by passing it the the type
schema we get back a chunk of binary
data that is densely allocated so again
you get really good space efficiency out
of this this is one of those things
where you can do it in JavaScript using
strings but it's clumsy it's error-prone
and it's inefficient I don't know how
many of you have seen some of the
amazing new things coming out of the
next-generation browsers with WebGL but
people are doing 2d and 3d graphics
right in the web not using flash not
using Silverlight but actually built in
as core functionality of the web and
those are all built on having very
efficient representations of binary data
and now WebGL uses a simpler form of
binary data called typed arrays which
are not quite as flexible and convenient
as as what we're working on so we're
working with the WebGL folks to try to
be compatible with future versions of
WebGL so that they can build on the
libraries that we have yeah so I'm not a
graphics programmer I throw words like
texture up on the screen and hope that
that makes sense to people who do know
about graphics proxies again a power
feature that I'm I can't possibly do
justice to in just one slide and just a
couple of minutes
but proxies are a really neat new
reflective metaprogramming facility now
this is one that actually is implemented
in the pages of Firefox 4 were the only
ones so far who have an implementation
of it but by putting it in a standard
hopefully all the browser's will
implement it so on the left hand side
you have sort of a typical view of
objects in JavaScript you say obsequious
new see you're going to get a new object
that might have some properties of its
own and it has an implicit link to seize
prototype you know to the object pointed
to by C's prototype and you get this
prototype inheritance chain and all the
operations that you know we all know by
heart in JavaScript follow the same
pattern well the proxy library lets you
create your own kinds of objects that
have their own kinds of semantics and
you can kind of give them unlimited new
ways of doing the standard operations
that usually follow this fixed pattern
so the way you do it is you create
what's called a handler object that
describes callbacks for all of the basic
semantic operations on objects like
getting a property setting a property
querying a properties attributes this
handler has all these callbacks and when
you say property proxy don't create of
the handler you get back this new object
that's called a proxy that's delegating
to those callbacks that you gave it for
any one of those semantics operations
this is a really powerful thing and it's
so general that sometimes people's eyes
get crossed when they look at and they
say well what am I going to do with this
well the up the the possibilities are
limitless but you know here's a few
things to maybe get your imagination
going maybe you want to create an object
that's just like some other object
except you want to log all of the
property gets maybe for debugging sake
you want to say I want to see every time
that somebody is asking for a property
and I want to I want to just generate a
trace that I can use for debugging
afterwards so you create an object
that's just like the original object
except it also logs all of the reads off
to the side or you could do the same
with logging rights you could sort of
log anything that you want one that I
use recently in a library that I was
writing was a sort of
mixin object where you create an object
that's actually delegating to two
different objects for its properties so
this is sort of a completely different
inheritance protocol than the one that
you get by default with with prototype
inheritance you can also implement catch
owls so maybe you have an object where
you want to be able to say if somebody
asks for a property that it doesn't have
I want you to call this other function
and and fill in for the the property not
found operation so these are just a few
examples of the kinds of new semantic
operations that you could define for
yourself using proxies the question is
is that valid syntax to make a call
inside of the function yes absolutely
this is just a function call for an
argument of another function proxy is is
not new syntax it's just it's just a API
so proxy is an object that has a create
method so I'm just saying proxy dot
create you know method call with an
argument and you can always do function
calls in an argument context more
questions on proxies again this is
another one that I could I could spend
an entire talk talking about I think
this is the last one so module loaders
and again it's a power feature not when
I have a lot of time for so module
loaders are a reflective API a dynamic
API that let you define hooks that get
called when somebody does a module load
so module loaders let you create new
contexts where you can create new
semantics that you might want to use so
one example is you could create a module
loader that recognizes URLs that end in
dot j s as being JavaScript but
recognize URLs that end in dot coffee is
being CoffeeScript and actually compile
the source down to JavaScript before
they hand it back off to the JavaScript
engine and similarly with Python so you
can create a module loader that actually
recognizes several different programming
languages and mix those in one program
so this is just a simple example of a
program that uses three modules from
three different languages together you
could also create module loaders that do
compile time checking
when they look at the source code when
it comes in and say this violates some
property that I want all my programs to
have and reject the program and you get
a compile-time error so for example if
like Doug you don't like the - -
operator maybe you have a lint checker
that says I disallow the use of - - so
it looks at the source code before it
gets sent off to the underlying compiler
and rejects it module loaders also give
you the ability to create separate
isolated context separate isolated state
where you're running different sets of
code so it actually lets you do things
like security patterns where you're
calling untrusted code and you want to
make sure that that code can't trample
on any of your state you create a new
separate module loader in which you're
going to eval that code and it's given a
new separate state a new global state so
here we maybe have some code that stomps
on jQuery and stomps on Yui and you want
to make sure that it's not something on
your jQuery on your yui so you create a
separate isolated context to run that so
security is one reason but it's not just
security there's a lot of new
cloud-based code editors that people are
working on these days and one of the
things you do when you implement a
JavaScript editor in JavaScript is you
have to eval this other person's
JavaScript code well you want to make
sure when you're when you're running
their code in your editor that their
code isn't trampling on the editors code
so you can create a separate isolated
module loader in which you run their
code and that way you kind of protect
the meta level from from the program
level
so again modular is our high-powered
sort of low-level feature but they they
add a lot new power to the language I
think yes we are at the end of my little
lightning tour of ACMA script dot next I
just want to finish by saying that
you're in charge we're the committee
here to serve you and your feedback is
invaluable so we have public forums
where you can talk back to me obviously
tonight I'll hang out as long as people
want but we also have a public mailing
list es discuss
org that the whole committee hangs out
on that it's up its hosted at Mozilla
but it's the entire committee that's on
that mailing list we also have a public
website that's sort of embarrassing web
coding skills of myself working with a
designer to make it look not quite so
ugly ACMA script org has some resources
about the language wiki ACMA script org
is where we do the the committee design
work so we have all of our draft
specifications up on that wiki so you
can look at everything that we're
working on we're doing all of our work
in the open and then of course on the
other side you've got me I'm open to
anybody who wants to talk to me as well
so that's all of the ways that you can
find me online and happy to answer any
questions people have so don't be
bashful
please feel free to to talk back to us
and let us know your thoughts all right
thanks very much for your time and
attention I appreciate</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>