<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Low Down on Web Components | Coder Coacher - Coaching Coders</title><meta content="The Low Down on Web Components - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Low Down on Web Components</b></h2><h5 class="post__date">2014-08-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1eI38L43pos" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for having me my name is Eric
Bren
I'm on the ember.js core team but I'm
not here today
amber I'm here to just talk generally
about web components and share some of
my findings and out of curiosity how
many of you have played around with web
components already all right so like
definitely less than half alright cool
so hopefully this won't be too basic you
guys will come out learning some of the
basic web component proposed web
component api's and everything so cool
so again yes tom erik i had a bigger
beard in that photo so what are web
components web components are basically
a group of standards that will will
mention a second and i believe and i
think the the web components spec
authors would also agree that basically
their point is to make building reuse a
bit make building web UI sharing web UI
components and reusing the code on the
web much easier than it is today and so
the primary driving force behind web
components right now has been the google
chrome team and so the google chrome
team has been working on web components
actively for the last two to three years
i believe so this is a comb what i'm
going to be showing you is a culmination
of their efforts over quite a long time
and some of these concepts have been
actually in development and been worked
on for even longer than that and so i've
been lucky i've been able to go down to
a mountain view and hang out with the
godfather of web components dmitry glass
cough so here's our nice selfie as you
can see the beard is looking a little
little fuller than it is today and so
the web component specs we're going to
talk about there's basically four of
them and those are custom elements
templates HTML imports and shadow DOM
and so let's get started by talking
about custom elements so custom elements
are probably the easiest and the easiest
part the easiest spec to understand and
it's also I think what most people when
we're talking about web components they
are thinking of custom L
so you know you're probably used to
today doing something like this where
you know you're setting up some markup
structure in your document in your
application setting some kind of ID or
unique class name on it and then in your
JavaScript code you're pulling your
executing some JavaScript going into the
Dom trying to find those elements that
you know are related to the component
that you're trying to instantiate and
and then you use something like a jquery
plugin to you know kick that off and you
know basically today jQuery plugins are
kind of like the lowest common
denominator way of sharing UI code
across different applications and across
frameworks as well so you know basically
the idea behind custom elements is what
if we just simplified this to a custom
tag and this custom tag can have its own
a you know class that defines all of the
life site that has lifecycle hooks and
can define basically and instantiate all
the JavaScript related behavior for this
for this piece of you I so so how do we
create this custom element well today is
custom element API looks something like
this hopefully this is big enough for
everyone michi see if i can boost it yes
I also needed that so basically today we
don't really have a class system in
JavaScript right now we've got one
coming up but today basically you end up
writing this this lovely set of code and
so just to real quickly talk about each
one of these callbacks here or did walk
through the code what we're doing here
is creating a prototype object for our
the component we're building and then
we're setting a bunch of callback
functions on that object and these are
standard hooks defined by the custom
element api api and so created callback
you can kinda you can think of as the
instantiation hook this is kind of like
your constructor function and the
attached callback it means the Dom node
has been already instantiated in a now
has been put inside of the document
so detached is the opposite that's been
pulled out of the document and then
attribute changed is a callback that
will get fired when any of the
attributes of the element change and
we'll see an example this we're going to
do some live coding and build a little
simple component in a minute so then we
call the document register element here
which does the work of actually
assigning the tag name here which is the
first argument to the prototype object
for our custom component and so it's
possible for you to also add any other
arbitrary properties or methods onto
this prototype object to define the API
of your component but this API is a bit
facepalm E but thankfully we have es6
classes coming and so now there's that
there's going to be a nice clean way of
defining your custom element classes
you'll actually be able to extend the
built-in HTML element class or any of
the other subclasses of it and you'll
get a nice much simpler syntax for
defining all these callbacks as well so
this will be great so without further
ado let's dive right in I'm being ballsy
and trying to do some live coding here
so let's see hopefully the resolution
will not be god-awful alright cool all
right so let's go ahead I will bump the
font size for y'all so we're going to
define a file called custom element HTML
and so this will be just a standard
boilerplate HTML document and what we're
going to do here is just throw in a
script tag and we're just going to
create a component called my component
so we'll do my component prototype
equals object I create HTML element
such boilerplate and then what we're
going to do with that is get our actual
constructor function I would have
document out register we're going to
call this my dash component and we get
to pass a lovely-looking hash with
prototype
alright so that gets our element
registered let's go ahead and bring this
up in our oh boy this will do this
alright so hopefully we're all good no
errors so let's week let's try actually
use it well let's actually implement
some callbacks first so we can go ahead
add the created call back and so again
this is the callback that's going to get
fired when our component our custom
element gets instantiated right and so
the simplest way to instantiate our
element is to obviously just drop it
into the body here and so let's let's
see how this works alright that's good
we hit our break point and so if we look
at this here we're going to see that
it's an instance of my component and it
two strings to HTML element so that
seems good and so created callback is
that created callback is where you're
going to do the kind of work that
related to any kind of instantiation or
set up of properties or attributes
related to your element you might
actually create the any sub dom that you
might have any Todd you would do an
create a call back the attached callback
is where you're going to actually do
things like setting up your event
handling and so things like you know
event handling maybe calling off to
jQuery if you wanted to do some rapping
of jQuery plugins inside of web
components the attack the attached
callbacks place to go and the detached
call back of course is going to be the
place where you're going to want to tear
down any of that stuff you did in the
attached call back and let's also real
quickly look at the attribute changed
call back so this one actually gets some
arguments
alright and so just for the sake of
understanding the life cycle of these
callbacks let's actually manually append
the my component our component to the
Dom so that we can watch all these
callbacks get called in order so first
things first we'll go ahead and create a
new instance this is just going to use
create element so you can call document
that create element just like any other
element pass in my component and I I'm
just going to throw two buggers in
between each step here and we're going
to call document.body.appendchild to
bring it into the DOM and then we're
going to do a set attribute here
and then we'll go ahead and remove it
from the down as well all right so let's
see how this this lovely set of
debuggers fire so we can go ahead and
create our element and as we would
expect to create a callbacks you get
called and so there it goes we append
the child we're going to see the
attached callback get called now here's
the here's one of the more interesting
kovacs setattribute is going to trigger
an attribute change callback and inside
here we'll get the name of the attribute
the existing or old value of it and the
new value of it as well and then of
course remove child is going to trigger
the detached call back so pretty simple
stuff and you know hopefully you can see
the usefulness in this I mean basically
the the real the real value here is
standardizing around these callbacks and
having a you know everybody no matter
what framework you use use elements HTML
elements at the core right and so when
you're talking about distributing UI
components it's very attractive to build
at a level that every framework can
understand and that's obviously the Dom
element level so um from here let's jump
forward hopefully I can oh come on of
course it doesn't just work
boom great all right so so let's just
quickly recap how we how are we kind of
doing this stuff today again like I
mentioned at the beginning where if
you're using something like a jQuery
plug-in your tend to do something like
this and you know configuration is going
to get passed in to that jQuery plug-in
call if you're using something like
ember then member provides a something
similar to custom elements today which
is basically we create you handlebars
helpers automatically when you register
a component class in your amber
application and so inside of your markup
you can just drop in Curly's my
component and then you can pass in key
value pairs and those can be primitive
values or they could actually be
databound as well and so in an upcoming
version of Ember we're going to actually
enable you to just write this custom
element syntax and that will actually
delegate over to the the handlebars
helpers that live underneath that
actually do the work and so this enables
us to have something like custom
elements in browsers that aren't going
in older browsers that aren't going to
support you know the custom elements API
aren't poly fillable as well so that's
kind of cool in angular today we you've
got several different ways of kind of
doing something similar to custom
elements there they're called directives
and you can definitely do the cut the
straight-up custom element approach
which is just too which is called an
element restricted directive and so this
first example here shows that it lose it
soon this first approach toes you can
just you know use it like we would
expect but they also have an at the
house so they have several different
forms but I think the most popular ones
are the element and attribute restricted
so here you can actually just drop in an
attribute saying my component and
that'll automatically trigger angular
upgrading that element to something
webcam element esque and so the cool and
exciting thing is that angular 2 point 0
has actually said that they're going to
be adding web component support as a
first class citizen
so that's that's nice because that means
potentially these things can be used
across ember and angular applications
and again pollen also polymer which is a
cool library that's basically built on
top of all of these new web component
primitives it has a you can use
obviously web the component in this in a
similar exactly a similar way as you
would expect but they have a really neat
little declarative form which is
actually a custom element self so if you
use polymer element and pass a name that
will actually do the work of setting you
up a custom element name to my component
you can put some markup in there and you
can immediately start using that and if
you need to you know that's that's
mostly for simple simple use cases but
you can do that and also then go into
the JavaScript side and actually define
your custom element using their sugar
EAP is for doing so so I think
personally as a framework author and an
enthusiast for web technology I think
the really exciting thing about custom
elements and web components in general
is the potential interop story that can
be unleashed and so this is still a nun
this is still somewhat unchartered
territory but we're working together
both from the standard side and in on
the framework side to try to find a way
that ember angular polymer you know etc
can all build you'll be able to use
these components in any framework
potentially build them inside of your
application extract them use them in
another app and you know that's to me
one of the big promises of custom
elements is since it is kind of this
lowest common denominator mechanism for
defining and sharing this you these
elements you can actually envision an
interrupt story being possible and so
the
proposal if you're looking if you're
interested in looking into it is called
note bind and so this is basically a
mechanism for how really the unsolved
problem here is how do different
frameworks data binding solutions work
across these elements that can be shared
and so that's what no deadline is is
trying to address so this is cool
obviously we're use i'm using developing
chrome and custom elements have shipped
in chrome so you're able to use them
without a flag today the firefox team
has begun implementation I've heard that
they have it implemented and it's
working I was unable to find any
documentation about where it was flagged
or what the vendor prefixes were or
anything so otherwise I would have
showed you it working in firefox but
this stuff is actually usable in
browsers without native support google
the the google polymer team actually as
part of the work of building polymer and
created a polyfill library called
platform j/s and so platform jess is
usable there they say they target all
modern evergreen browsers and so the
idea is you can drop in this javascript
dependency and get support on browsers
like Safari and ie opera so opera is
based on the blink engine now so chrome
typically has a feature opera has one
too so so yeah it's pretty exciting so
the next topic the next spec that I want
to talk about our templates and
templates are actually probably a lot
the templates pack is actually a lot
simpler than probably you think of when
you think of the idea of a template in
in JavaScript so templates are actually
just a mechanism for declaring fragments
of markup and enables us to easily clone
and insert them around so here's a
simple example basically there is now a
template tag and this is a round in
chrome we'll see in just a second we can
use this today and so the idea is you
can define one of these template tags
you can put any arbitrary markup inside
of it and then you can very easily fetch
it out of the Dom call template content
clone node and this will actually create
a clone of all the content inside of
that template tag and then you can
append it somewhere and so you know
today if you want to do something like
this you're probably thinking well this
isn't what's so fancy about this this
isn't that big of a deal so today if
you're doing this kind of thing you're
probably using something like a div and
your display you're doing display none
and so template tags by default do not
have any rendered output so this is just
kind of you can kind of think of it as a
declarative way of doing a document
fragment right you can just put a dot
you can basically create a document
fragment inside of the DOM and so you
know if you're if this markup is getting
generated by your server you're able to
actually have your server a mint mark up
that isn't going to have any rendered
effect on the clients machine and so
again you know another strategy and this
is a strategy we utilize in ember land
when we're trying to in our starter kit
in non build tools style environments is
we you use a script tag with a custom
type and so basically anything and tie
it inside of that script tag just
becomes text and then you can suck the
text out of that element with inner text
and then you can go and inject that into
the Dom you know and then clone it from
there if you need to so the the big
important and the big important feature
about templates are that they are inert
and so what this means is that you know
I'm sure if you've tried any of these
other approaches one of the big even
though something's displaying none
doesn't mean that that interpretation
and rendering of something that isn't
visible doesn't still have an effect on
the user's environment and so a common
example of this our image tags so if you
wanted to have a piece of you know
template code on your machine
your clients machine and that hasn't
been displayed yet and you put an image
tag in it it's going to download that
image immediately and so you're
potentially bottlenecking your
applications boot time by loading a
bunch of unnecessary assets that you
know aren't going to be displayed right
away the other big one is script tags so
if you have a script tag inside of that
template that script tag will not
actually execute until it is in appended
to the Dom so let's take a quick look at
templates
so we'll drop in a template tag with an
ID oh thank you thank you all right
there we go we'll drop in a template tag
with an ID call it my template and so
let's just start off with a super simple
example we'll do the good old hello
world and so will write some code to
grab this template out of the DOM and so
if we look at template content here this
is going to be a nice thing again about
templates are this dom is actually
parsed as well so you get through the
parsing phase and this done these that
this dom is extremely quick to then
clone and append versus an approach like
the script tag approach you offload the
parsing until you actually suck the text
out and jam it into the dom and so you
end up paying a little bit of a
performance cost there so we can go
clone the content will get a clone and
then we can just drop that into the body
alright so easy right not so bad so
let's actually prove that these
templates are inert so if we go ahead
and drop in an image tag here I'm not
appending it and if we go to the network
tab we are not seeing that image
appended right whereas if we were to do
some want some existing solution right
if this was just some div here hopefully
this is obvious but I'm just proving it
to you that it's true hopefully I'm not
wrong that would be embarrassing his own
chrome has some new optimization where
they don't load images all of a sudden
oh I have double the ID
so so yeah as you can see even though
it's hidden right that image got loaded
and then of course hopefully if that's
true as well it's obvious that putting a
script tag in here is also going to get
executed right even though it's
off-screen right so this inert this
inert property of the template tag is
quite handy yeah so as I mentioned
briefly the idea is that the temp the
contents of the template tag actually
get parsed by the browser and the Dom
nodes uh you know the initial Dom nodes
get created and you know they those
nodes have some special properties like
this inertness in the cases of image
images and scripts and the advantage
here is that it's actually clone node is
the fastest way to generate Dom in the
browser and so it's actually extremely
fast to take that already parsed and you
know generated template Dom clone it and
then jam it in somewhere in the
application whereas if you're doing the
script tag approach you're going to be
paying that like inner HTML cost as that
user interaction might be occurring that
is going to be parsing and then ending
it so depending on the amount of Dom
that you're creating that might actually
be cost prohibitive in a certain
circumstance yeah
so yes every time you well every time
you clone and append right because if
you append if you're taking a node in a
pending at multiple times you're just
moving it I think right so well so it's
not the sole so the idea is that the I
don't actually think the template tag
does anything to specifically cash it I
think if you do not clone you can
actually steal Dom out of the template
tag and then the next time you try
cloning it it won't be there anymore so
you need to be careful to actually clone
the contents of the template tag here
which is what we're doing on line 15 and
so now you know just to show you again
we refresh now that outlet that alert
doesn't get fired when we append it it's
going to get fired right and then
there's our success message and and then
of course if we were to continue to
clone and append then we would see that
same we would see the same thing happen
again right make sense only Oh
recursively yeah so clung on by default
is non recursive not deep and throop
mains do it deeply any other questions
before moving alright cool so that's the
template tag pretty much so let's move
on
I don't know why I can't get over there
easily all right so templates you you
should really think of as there are a
very low level primitive right there
basically a nice new way of having a
markup of generating document fragments
via markup rather than via procedural
JavaScript code and so you know my hope
is that and I think you know the hope of
the spec offers is that this is a this
the template tag is cut is basically you
know our foot yeah you know dipping our
toes in the pool here around this whole
templating problem and is going to be a
primitive that enables something higher
level to be actually implemented in the
browser and so you know it would be cool
to see some simple data binding systems
and potentially be standardized in the
future as well and so what I mean by
that is something like this right like
this is the kind of thing you're used to
already with your existing libraries and
tools libraries and frameworks today so
it would be nice if we could in theory
create a template tag put some special
markup in it and then you know met this
magical render i just realized my cursor
does not actually show i'm looking at my
notes uh so this render method here
could perhaps take a JavaScript object
and that would automatically populate
you know any of the data bindings inside
of the dumb so it would be cool if
something like this existed right but
not yet sorry so it's important point to
note it's an important point here that
while there's a lot of hype and crazed
around web components there's actually
still a void for frameworks and
libraries to fill and so we will do that
so the next spec that on talk about is
HTML imports HTML imports enable you to
include and reused HTML documents in
other HTML documents so this is kind of
a little bit of a mind bender you can
kind of think of it as you know just
like you can link a style sheet into a
document you can also link a another
HTML page into a document and so really
what this is all about is as you've seen
with
the you know with our exists well we
haven't will you as you could might
imagine with templates and with custom
elements we've got both HTML markup and
JavaScript code now and the idea behind
HTML imports is like wouldn't it be
awesome if there was an easy way a
one-liner way of bringing all of those
assets you know the the markup that
JavaScript and the CSS into a page with
you know without without any build tools
without any real conceptual overhead and
so here's an example we're just dropping
in an import and then now magically are
we have an element that we can use right
and so like I said this is a really dead
simple way it's it's it's meant i think
be as simple as possible and it is
designed for that in mind but the really
cool thing about this but it has you
know some some exceptions and some some
complications behind it is that the cool
thing is that if you're if the imports
you are using happen to share common
dependencies those will only get loaded
once so imagine you're using you know
jquery and several different components
or several different you know HTML
imports and you know those as long as
those j queries are coming from the
exact same URL they will only get loaded
once and so that's kind of the the
gotcha so you know it's AI think a
really good the way I view HTML imports
are you know there's several open use it
there's several open questions in my
mind about their production capability
their production use but I have not seen
anything simpler for somebody who's
perhaps new to the new to web
programming for them to be able to you
know in go grab a URL from for a
component or have downloaded something
to their local machine you know and put
it in their local directory for them to
be able to bring in something that they
can just then use as a tag in their
existing markup this is a really great
solution to that problem and
you know but again for production use I
think you know there's actually some
tools that have been developed to
actually do proper packaging and
concatenation like you would expect like
you probably are doing today in your
production applications around HTML
imports but again this is these things
are very new so let's take a look at
HTML imports so work yes thank you I'm
sorry can you use a link inside of uh
yeah I don't see why not so CSS is also
included in this right no it doesn't get
it sandbox but we're going to talk about
shadow Dom in a second and that's what
we'll we'll take care of that for us so
here we are very simple document in our
head we're going to do a link rel import
href equals some you know import let me
just going to say imported element
something
and so now ideally we want to be able to
use that imported element inside of our
page I can type alright so now we're
going to go create an imported element
that HTML file to import and so I've got
running a little short on time so I'm
just going to copy and paste this over
so there's a little there's a little
funkiness going on here and around the
document object and basically the idea
is I don't know if this is going to end
up being the way that it is in the final
spec or anything but or the final
implementation but basically the idea is
here technically the document of this
other HTML file is different than the
document of the originating file and so
I'm doing some trickery here to
basically grab the document from our
HTML import that HTML file and so
therefore we're registering the element
on our imp the person importing us not
ourselves what's that I believe window
is the same but I don't know I haven't
actually tried let's find out so let me
real quickly this is fine except i
called it imported element so we'll
throw a bugger in there and why don't we
do something silly like
window dot it's me
all right um
let's do HTML cords import import all
right so window and so we hit our
breakpoint window dot it's no it does
not look like window is the same I'm
sorry oh maybe good quite a good point
let's find out I can actually maybe use
the attached call back but yeah you
might be right so let's do this a
different way let's actually check
inside of here maybe try doing it the
other way around
all right did I not set a breakpoint I
didn't save all right so that's
interesting okay yeah so it looks like
the window is the same we just have been
ordering issue with my initial check so
so yeah basically all I'm showing here
just focus on the original intent of the
demo is that we've got our custom
element defined inside of this other
HTML file right which we are importing
via the link rel import tag and then
here in the attached call back all i'm
doing is just enter HTML in a string so
that this element actually has some
content so it's working great that's all
there is really two it about HTML
imports
alright so here's the complicated and oh
wow I'm already out of time um here's
the complicated part of the talk which
is shadow down and so I'm not going to
talk i'm not going to dive too much into
shadow Dom because it is it is complex
but the important thing that I want you
to get out of and associate with the
concept of shutdown is that shadow Dom
enables encapsulation of the DOM and so
what I mean by that is a couple things
the most important bit which is as the
gentleman up front here asked about
earlier is does it isolate the Styles
you know does HTML imports isolate
styles no but shadow Dom does and so
let's try to whip together an example of
this and not only does it isolates tiles
it also helps you kind of reason about
these these you can you can it enables
us to think in dom api's as well and
i'll try to i'll try to point out what i
mean by that exactly before completely
run out of time here so here's an
example a code example so this is how
you use shadow Dom there is no
declarative API to use shadow Dom by
default you polymer exposes one but
basically the idea here is that you can
create a template and you can define a
style tag you can put a link tag in here
import some CSS and then you put some
markup here that you know is being
styled obviously and what happens here
is if you if you check it out we create
we grab a reference to our template we
clone it then we create a div and then
we ask this we call a method on this div
element called create shadow root and so
what this does is it creates another you
can kind of think of it almost as like
another complete document in a way so
almost like an iframe e type thing right
where you're basically you've got a
separate Dom hierarchy now and you can
put things inside of this and we shall
we go ahead and just it looks like it
operates like a node so you can just
call
you know shadow dot append child drop
the clone in here and then you can
append that element that the original
development to the to the body and so
now what's going to happen is is that
this P style which is extremely generic
right and you which you would normally
avoid using in your application actually
is not going to leak outside of the
shadow root of this div so let's try to
get a simple example of this working so
another thing to think about another way
to think about shadow DOM is the way
that I like to describe it is that the
shadow DOM is kind of like the layout of
your component and so you get to
separate the layout and its styling from
the contents of the component that the
user is providing right so the contents
the user provides is actually styled
based off of their applications style
sheets not the components so all right
the we are really short on time so let's
see here maybe I can reuse one of these
examples um it's probably easier to just
alright so we're going to basically just
ah thank you I'm epic fail at this let
me actually grab this stuff
alright so we're going to grab a
template here and so what we'll do is ah
thank you you guys are so helpful yep
we're going to do that just one second
so um
uh so let's go ahead hopefully this will
just run all right cool right so so so
again this is really kind of like for me
this has been one of the biggest missing
primitives on the web that really gets
in the way of code sharing because all
it takes is like one library to have a
colliding style or you know class name
or ID or whatever right and it blows up
and there's not really much you can do
so shadow Dom's you know kind of the
solution of this and before chef Dom
there was the concept of style scoped
but it looks like for all intents
purposes style scope is dead and stuff
shadow Dom will be the solution so real
quick let's finish up the deck I guess
oh yes mirror
alright so um did the demo all right so
to wrap up web components are bringing
new features to the platform that
hopefully you can see are going to
really help to enhance developer
productivity we've had a lot of work
done to like add features to the web you
know like api's that allow us to get
access to device capabilities and do
video conferencing and stuff but we
really haven't focused on up on features
that help make us more productive doing
our jobs and I think web components is
kind of the first big step in that in
the right directions with ruts that
unfortunately you know as the way of the
web work a year or two away from the
stuff actually landing natively and all
of the browsers that we probably need to
support but as you know browsers browser
development is happening at a much
faster pace than it was years just a few
years ago so and you know it's important
to realize while these features are
coming the library and framework folks
are going to still play a big important
role to help all of you start using some
of these features today even though they
might not be natively implemented and
that's awesome so it's a really exciting
time to be a web developer with all this
new stuff so thanks so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>