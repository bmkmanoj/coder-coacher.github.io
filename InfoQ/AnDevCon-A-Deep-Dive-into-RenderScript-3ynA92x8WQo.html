<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>AnDevCon: A Deep Dive into RenderScript | Coder Coacher - Coaching Coders</title><meta content="AnDevCon: A Deep Dive into RenderScript - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>AnDevCon: A Deep Dive into RenderScript</b></h2><h5 class="post__date">2013-12-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3ynA92x8WQo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so today we're going to talk about
kind of take a deep dive through it my
name is Larry Schieffer and before we
get started I'll tell you a little bit
about me
CTO and co-founder of high Q's LLC we're
an engineering consulting firm
specializing in mobile and embedded
platforms working from the bootloader
all the way up through the application
space I've got over 16 years developing
embedded and mobile device software an
extensive experience throughout the
software stack and that includes
numerous operating system so Linux
Android Windows and various art AUSA's
I've been working with Android since the
first AOSP release and since it was
first publicly available and have been
doing native development and debug along
with your typical java application and
framework development even before the
NDK was available having the lead
architect and developer on three custom
Android platforms for various customers
and I'm an experienced trainer I've
spoken here a 10 Devcon before I've also
developed some training classes for
Pluralsight which is an online training
provider and I also do in-person
training for the new circle so today
we're going to talk a bit about
renderscript and we're going to talk
about what renderscript is and we're
also going to talk about what it is not
there are some important things to
understand there we'll go through some
typical use cases some people have some
misconceptions about what renderscript
is and so you know I want to kind of go
over some of those and then we're going
to talk about the anatomy of a script
basically how you create one and how you
actually leverage and use these things
will also go through some performance
comparisons I was hoping there would be
a projector in here and unfortunately
there's not I will show a demonstration
on a nexus 7 and on unfortunate I'll
just have to hold it up for you all to
see the pretty screen but we'll also
talk about some performance numbers and
then we're gonna go a little bit through
some of the debugging and pitfalls you
have with dealing with renderscript
it continues to evolve so we're going to
go through some deprecated and new
features that are available in render
script and then what I call the Manby
I'm the curtain so we're gonna talk
about kind of the underpinnings and do a
brief overview of what the system is
doing under the hood to actually enable
this functionality we can do some Q&amp;amp;A at
the end
but you guys feel free if you've got
questions as I go through just let me
know I'm happy to answer any questions
as we go through this so first thing
what is renderscript it's
high-performance computing that's what
it's intended to be for it's a
customized language it's based on c99 so
it has a very c c++ like syntax it's
fully parallelized and it's optimized
for hardware as long as the OEM enables
that functionality so it allows you to
leverage the capabilities in the end
hardware to its fullest
it is target agnostic and extensible and
we'll talk a bit more about that so a
little different than the NDK where
you're building for a specific hardware
device and you have to be very cognizant
of what you're deploying upon with
renderscript
the code that you write is target
agnostic it natively executes on the
device so even though it is target
agnostic you still get the benefits of
native code execution so all that sounds
really great but what is renderscript
not it's not a general-purpose
programming language so it has a very
c99 like syntax but you can't use it for
your everyday application development so
therefore it's not a framework
replacement you couldn't use this just
like you can't use the NDK to replace
your typical java application logic the
same holds true for renderscript
you can't use it to replace the
framework it's also not an NDK or a J&amp;amp;I
replacement okay while it runs at the
native level it's not a full-on
replacement and we'll get into some of
that as we go a little further into this
so some typical use cases for
renderscript and I feel like I'm going
really fast so if anybody has any
questions just slow me down okay
image manipulation is a big one if you
look through any of the renderscript
documentation you're going to see a lot
of information and
about manipulating images and that's
usually what the examples are and in
fact that's what Google uses it for in
the latest version of Android
so with KitKat the image editor or the
photo editor that's built into the
device is actually using render script
under the hood to do the image
manipulations for efficiency as well as
all the filtering you can use it for 3d
graphics computations and a lot of folks
really thought there'd be a nice tie-in
between render script and OpenGL and in
fact it kind of gone that way for a
while but as we'll see later those api's
were deprecated they found it wasn't a
good fit and it actually has much more
use beyond just graphics so you can
actually use it for a lot of other
intense computational work I've seen
some posts online of people using render
script to do h.264 implementations and
their own custom codec implementations
and you absolutely can do that because
it's meant for number crunching so it is
all about number crunching it's all
about manipulating data and doing the
kinds of things you want to do very very
efficiently on your hardware so what
does the anatomy of a render script look
like okay it's integrated with the
virtual machine in android and the
virtual machine is in control and owns
all of the memory so everything that you
do memory wise it's all managed up in
the Java layer so up here in the
framework your application is going to
allocate objects which get put into
memory and it can read and write through
them and then over an interface to the
render script there's a binding so that
the render script engine knows how to
manipulate this same memory and it's
doing that via some reflected class
layers and it's a very important aspect
of this to understand as you see as
we'll get into some code here in a
little while so it is a master and slave
type relationship where the Java code is
the master and you can call render
script via a reflected layer now if
you've looked at any of the release
notes for the latest KitKat I'm sure
most people in this room have they've
also opened up render script to be used
from the NDK however
as I'll touch on a little later the
documentation for that is basically nil
there's nothing there the renderscript
documentation on the Java side is there
but it is a little sparse and it's kind
of hard to understand on the NDK side
there's really none so you're kind of on
your own there so for most of my talk
I'm going to talk about it all being
managed up here in the Java layer
because really from the NDK layer I've
not had a chance to dive into how that
works and how you can actually use it
because there literally is nothing to
work for him so again here in the
android framework you've got your
activity and you're gonna have a render
script context and then an object which
represents your actual render script
code and you're gonna call through to
the render script runtime by way of this
object in this reflection object which
will then actually execute your code
within the render script engine running
at the native level so all that sounds
great how do we actually write one of
these things what are we doing well the
first thing you have to do is you have
to declare some special pragmas at the
top of the file okay it's one of the
first things you have to do and you
always declare version 1 and then you've
got a pragma which declares your render
script I don't know can you guys see
that all the way in the back okay you
can good you basically tie in the render
script with what the package name is in
Java and that ultimately is what's going
to cause the render script compiler to
kick out a Java reflection class which
belongs inside of this package so this
creates that mapping for you you can
have an optional and knit function which
we'll talk about that here briefly and
then you have what's called route
functions you can have one or more
especially with the newer versions of
Android early on you could only have one
and the route function is really where
all of your data comes in and all your
data goes back out okay there are some
set forms and as I found you know going
through and refreshing my slides in my
demo today it continues to evolve with
the API so in fact I found that this
form here while it used to work
in API level 16 or 17 with the latest
set of tools this form of the root
function doesn't work anymore and it
doesn't tell you at Build time it's not
until run time that it just hurls all
over you there are probably some
exceptions to that that you can do with
some special attributes I'll talk about
later and so that's what this means here
that you get to decide what your root
function looks like so with the newer
versions of renderscript and the newer
API levels you can actually define what
you want your root function to be
previously it was set you had to follow
a specific form you can have constants
and variables inside of your render
script and you can have other helper
functions which work along with your
render script you can also call other
scripts but there are some limitations
in what you can do there so the anit
function it's completely optional it's
up to you whether you even want to use
this and it's effectively a constructor
if you've got any type of initialization
work that needs to be done before your
render script can actually get going and
be used this is the place to do it it's
called one time before your script
actually gets executed it takes no
arguments and it gets no return values
so you're not gonna get any inputs as
part of the in it and it's not something
you can trap ahead of time it's really
just for any kind of setup you're gonna
need before you can get going that's
hard-coded okay now I touched on the
root function before now one thing
you'll find in the documentation is the
root function is also commonly known as
the kernel and so you'll see a lot of
you know this word used interchangeably
with the kernel function so I'm sorry
with the root this is the main entry
point of your script this is where all
the work gets done and this is where you
process your data items you're gonna
chew through whatever memory has been
shared from the Java space and you're
gonna output whatever it is you need to
output it can have multiple forms like I
touched on before so when render script
was first introduced back in honeycomb
there were some fixed forms that you had
to follow originally you had to have
exactly two arguments and then it was
expanded out you could have the two the
same two in-and-out arguments and then
you could also pass some user context
data to it
starting with Ice Cream Sandwich in API
level 14 the same two API soar forms
existed but now you could also include
location information and you'll see that
in the demo here in a little while
excuse me where you typically use this
for something like a bitmap where you
want to have x and y coordinates you
want to know where in your data set you
are and there's actually a third form
now where you can have a z coordinate
you can look at it in three dimensions
starting with API level 16 your
renderscript can have a completely
custom root function it's up to you what
it looks like and you can also have more
than one although as you'll see that
with renderscript there's lots of
caveats and that is one of them I'll
talk about shortly
so constants and variables these are
available only within your script
so if you remember just a minute ago I
mentioned that you can call other
scripts from within your script and that
is true caveat there as well but you
can't access variables in other scripts
from within your render script you can
only touch your variables in your
constants now in that reflection layer
up in Java
your variables do get automatic accessor
methods so you're going to get a getter
and setter so for example if I define a
32 bit integer called width in my random
in my render script code I'm
automatically going to get JavaScript or
I'm sorry Java code which this is my
reflection class here and we'll go into
some of this in a little more detail in
a minute but you can see that I can set
the width on it and I can also get it
back out of the render script so my
variables that I've defined in render
script automatically get these accessor
methods as part of your build process
structures and pointers
but they are very special and you have
to deal with them accordingly they can
be used directly if they're global
within the renderscript
and they also get accessor methods and
there's a whole separate reflection
class that gets created for your
structures and it is kind of complicated
I'm not gonna go into a whole lot of
detail here this is one of the areas
where there actually is a good amount of
documentation and some of the help
now memory for pointers are allocated up
in Java just like everything else Java
side owns the memory on this and it gets
shared down with the renderscript
so what you do is you bind it you take a
memory allocation up in Java and you
actually bind it over a special call
down into your render script so it has
access to that memory now your
structures can also not nest pointers or
erase they have to be fairly flat
structures anybody any questions so far
I feel like I'm moving about a million
miles an hour yeah they are very similar
for whatever reason Google chose to go
this path rather than through OpenCL so
OpenCL has not been included in the
framework or added as a stable library
as part of the NDK in fact I believe the
person at Google who originally came up
with renderscript and put it in here
works very heavily on OpenCL so there
are a lot of similarities in it why they
decided to go this route rather than an
open CL I I couldn't say so in
renderscript you can define your own
functions these can be called within
your own render script or you can call
them from up in Java so like everything
else you do get a Java accessor method
as part of your automatically generated
reflection class so it like the getter
and setter it automatically includes
this invoke and that's how you know
you're calling a function so if I define
this in my render script where I'm
simply just taking some data and I'm
adding it to some internal data
structure of my script from up in the
Java layer I can actually call that
function I can feed it data from the
Java layer now this is different than
what you would do for your your
computational piece of this you wouldn't
want to use this for computation this is
really good to be
data down into your renderscript you
know for it to have or to invoke some
special function in there possibly for
setup or something along those lines you
don't get any return value okay that's
why it's important you don't necessarily
use this for your computation you can
help augment your computation or feed it
some information but really this should
not be the main part of the computation
so calling other scripts scripts can
call other scripts as I mentioned before
but you can only call the compute
function the compute kernel within
another script you can't call you know
like back on my previous slide where I
had my add data function I couldn't call
that from within another render script
you can only call the root or kernel
functions and again like everything else
all of your render script instances are
managed up in the Java side so even if
you are going to call one render script
from another render script your first
one it has to be fed the information
about the second render script from your
Java side so something like a function
like we had on the previous slide you
could use to inform your render script
of the way or the render script name or
handle to call for the other one this is
very useful for built-in intrinsics and
I'll talk about this in a little while
with regard to the platform supports and
some of the the things that have evolved
over supports some buildings you can do
things like blurring image data and that
kind of thing so this is very useful for
that where you can have one person call
another script script groups are another
piece that's been added over the last
couple of api's
to render script and this allows you to
change scripts together so now instead
of one script having to call another
script and being the way that it needs
to call another script you can actually
set all this up and just and the
framework handles it you know very
efficiently for you
so I've talked about the anatomy of a
renderscript and how do you actually
write one let's talk a little bit about
how you call it from the Java side the
first thing you have to do in your
activity is you're going to call the
static method called create and you pass
it your context this renderscript
object is really your renderscript
context you're going to use for all of
the renderscript calls as you create
your script reflection class so here I'm
going to create my reflection class and
this name will make a little more sense
basically pre-generated version of my
script and I'll talk some more about
that here shortly because it's important
understand what that is but this
reflection class they're all derived
from this base script see abstract class
and this basically defines the things
that you can normally call in the form
that you can call these different
classes you're then going to set up your
data on the Java side and this is done
via allocation objects and this creates
the mapping of what your data looks like
in Java for what it expects down in the
render script now you would invoke the
script and you'll see that it uses this
for each prefix so kind of like when
you're calling the accessor methods for
variables you get your get and your set
if you want to invoke a function you get
this invoke prefix well here for your
route function you get for each and it's
kind of a funny name but what that means
is it's running your render script in
parallel okay it's looping over all of
the data you want to feed your script
and so that's what that name really
means is it's for each data point in
your allocation I'm gonna call your
route function so that you can process
that data chunk so once this returns you
then need to get your data out of the
allocations so that you can actually
manipulate it up in the Java space now
that you've got the results so you do
have to do some marshaling there so I'll
give you a quick demonstration we're
gonna do a Mandelbrot fractal and a
couple of different implementations of
this thing so let me hop over to some
code so if it becomes too much of an eye
chart or it may it's hard to understand
this stuff you can definitely look at
the code on your own okay so the
activity for this is pretty simple I'm
not going to really spend a whole lot of
time here other than to say it creates
it creates a window with no title so
we're going to take up the full screen
and then I create this fractal surface
object and fractal surface is
just a surfaceview and this allows me to
they should basically initialize things
and then ask the surfaces created as
it's changed i can update it with data
from the generator okay it's just a
generic way of doing this the other
thing the activity does to make it easy
to move between is i hook the key up key
down the volume keys and will cycle
through all my different generators okay
so up here in the surface you'll see
i've got a number of generators defined
i'll show you a java implementation a
multi-threaded java implementation
renderscript a native NDK and then a
multi-threaded native and we'll look at
the performance differences but i also
want to look at the code differences and
the complexity differences because
that's one thing that you have to look
at as a trade-off here okay every one of
these is a subclass of what i've called
fractal gen or a fractal generator class
it's an abstract class that stores some
basic information and your concrete
implementation has to provide two
methods a get name so it describes it
and i can display it on screen and then
generate so it takes a bitmap just as an
integer array and it just needs to
generate data into that bitmap okay it's
a very simple API just for this example
so if we look at the java version
i'm not going to take any kind of credit
for a mantle broad algorithm or anything
pulled it right from wikipedia so
nothing none of this is kind of look you
know really all that complex but it
works and it does a good job so here in
the generate implementation on the Java
side for those that are familiar with
Mandelbrot fractals should look pretty
familiar for those that aren't there's
plenty of information out there it's
basically going to iterate over every
point in your bitmap and depending on an
exit condition for you know some certain
mathematical
pounds or if it hits too many iterations
it'll break out of the loop and that
however many iterations it went through
to get to those one of those two exit
conditions is what determines what we
pull from our pallet and how we color it
okay so it's not overly complex but it
is computationally intensive because it
is very iterative in nature okay so you
can see it walks through an outer loop
basically the entire height of the image
and then for every pixel in the width of
the image on each line it's going to
iteratively do this calculation where
it's doing some some multiplication and
some modulo operations and ultimately
determines its breakout condition by the
number of iterations that it's gone
through and the maximum number we set or
if it hits a certain stop value so it's
it's moved beyond a certain point so
once we get the palette index based on
the number of iterations it's been
through that loop we set that into the
bitmap and we return when we're done
okay so if I fire this up on the Nexus
and I apologize I forgot to get a
projector so that this would be easier
to see so the people in the back this is
probably going to be extremely hard for
you to see it is strapped to landscape
mode so it looks nice and pretty but
you'll see it's rendering for its you
it's using the Java and it is done
screens kind of dim so it might be kind
of hard to see and it is displaying some
number and some information about how
long it took to do the computation okay
and I'll go through that here in a
second since I can't really show you
guys on screen what that looks like so
one of the things you'll see here is as
I go through each one of these the
algorithm is exactly the same there's
some slight variations to it but the
code is going to look very very similar
in each of these implementations so
multi-threaded Java it's again the same
algorithm but now I use a thread pool
and I'm basically going to feed a thread
pool with the data to manipulate however
that could get really expensive and ugly
to create objects to feed the thread
pool for every pixel in this bitmap so
what I do instead is I feed it a line at
a time I basically tell it here's your
line do every pixel in this line and let
me know when you're done okay so it sets
up the pool and then once a generator is
called remember we're walking line by
line so we're going to feed the thread
pool with what I call this new generator
task and I give it the y coordinate and
the bitmap to write the results and now
I wait on a semaphore that each of these
tasks is going to set when it's done and
I make sure that I get through all the
lines before I call it totally complete
and this algorithm should look basically
the same just that we're doing one line
at a time so this is that inner loop
that was in the previous version let me
see if I can adjust the brightness on
this to make it a little easier see much
better okay so that's the previous
version so now if I go to a
multi-threaded Java you can see it comes
up significantly faster okay
so now let's get to the renderscript
version that's why you guys are here you
know who cares about the Java version
right so we do some initial setup you'll
see like I mentioned before we're going
to create our render script context
create an instance of our reflection
class and we're gonna feed it this
resource and I am going to talk more
about this resource here in a little bit
now unlike the other fractal generation
implementations the two java ones I
showed you excuse me they automatically
get the width and the height from the
superclass but because we have to
coordinate with the render script side
of things
I need to feed at that information so
the width and the height and the number
of iterations as well as palette data I
need to feed that here and part of the
in the constructor as I you know build
up the render script so the palette is a
little different as well because it's a
giant integer array in the way that I've
done this and so just like the data that
I need the computational engine to you
know copy into or to do some number
crunching over I need to feed it this
pallet data and the way I'm gonna do
that is over a memory binding so if you
remember I mentioned that your memory is
managed up in the Java side and if you
need to feed a pointer down to your
render script you have to call a special
bind function this palette and you'll
see this momentarily in the render
script this is a variable that's a
pointer it's a 32 bit integer pointer
down in my render script okay so when I
call bind here I'm telling it that this
allocation object is an integer array
that I've created and I set the total
size and here in the builder and then I
actually copy the raw data that was
passed in as part of my construction and
then I bind it and I tell the render
script this is where you can find that
data okay so down here and generate our
generate function looks strikingly small
in the Java side now so we create a
bitmap object based on the integer it's
a mutable bitmap now I create an
allocation based on that it
map and then I call my for each route so
this is gonna call the colonel down in
my renderscript
to do what it needs to do over that bit
mem once it's done I copy it back out
into the bitmap object get the pixels
into my integer array that I ultimately
need to pass back to the surface okay so
there's a little bit of extra copying
going on here this could probably be a
little more efficient than what I'm
doing but for a simple demonstration I
thought it was good enough so let's look
at the render script side of things now
Eclipse does automatically build this so
if you drop a file in in the usual
directory layout with your Java code the
Eclipse build engine knows how to pick
this up build the reflection class and
do that if any of you are IntelliJ users
it's the same thing it'll pick it up now
with Android studio they did it a little
bit different you don't drop your render
script code in here with your Java code
instead of in the source directory
you're gonna have an AR s directory and
then you build the same directory
structure by package name and drop your
render script files in there okay so the
build is a little different and
unfortunately as we'll see here in a
little bit with debugging render script
builds along with debugging is not
always the most informative thing so
your render scripts may not build and it
may not give you much of an indication
as to why so if you're playing with
Android studio I would expect some
problems there or potential problems
there so really quickly you'll see the
same kind of constants that we're
defined in the Java code because render
script needs to know about them and then
these variables that are defined within
the script itself and there's my palette
pointer that I had to bind memory with
and if you look really closely you'll
see that here I'm also using my set
accessor methods to set those variables
during my initialization
all right so here my root function you
can see I chose to you I'm using the
form with the bitmap to take my output
data and then my location within the
data this algorithm is probably gonna
look really old in the same now since
we're looking at the same thing over and
over again but that's important too
because I want you to see that because
it has a very C like syntax
it's basically C 99 and even the Java
looks very similar to this it's the same
algorithm it's the same code okay now
the difference here is we're on the
multi-threaded Java side I had to break
it up I had to figure I had to make a
choice right I break it up by line and I
feed it data here on the renderscript
side the render skip compute engines
doing that for me okay if it decides to
do it by line by individual pixel it's
up to it as far as I know this root
function gets called and it's told this
is the exact x and y coordinate you're
working with right now okay so however
it decides to paralyze that for that
hardware is up to it
so my complexity is really not any
different than doing it up on the Java
side once it's into this implementation
but this is for a single point right the
one other variation here you'll see we
get our pallet index and now I need to
write into the output the alpha red
green and blue values based on the
pallet information so I shift that
around and insert that in there so if we
look at the actual implementation and
what it does so remember this was the
last version with Java we'll look at
render script and we're done already
okay so it's significantly faster and
we'll look at some of those numbers here
in just a second anybody have any
questions over the render script side of
things okay one more real quick because
on the native side the implementation is
multi-threaded or single threaded and
it's really down in the native code that
it makes that decision so on the Java
side
it's part of our constructor we tell it
whether or not we're going to be
multi-threaded and the number of threads
this right here if you look at the
underpinnings of renderscript and what
it does at the platform level this is
more or less exactly what it does for an
implementation in the native CPU so if
you're not taking advantage of a GPU on
the device and it's just running on
let's say the arm core it tries to
figure out the number of available
processors and it's bonds that many
threads so that it can feed each of
those threads so I do the same exact
thing here okay and then we're going to
call generate and down here you'll see
that generate is a native method okay so
the usual J&amp;amp;I magic ensues
and you know we'll set up some internal
data structures similar to the Java side
I basically create a thread pool however
many threads I'm told to make down here
where it's entered in the J and I
generate function I'm going to create a
pool which was that structure up at the
top just like on the Java side I create
some a mutex to basically know when I'm
done and each of the threads can
basically signal me when it says it's
done with data so that I can feed it
more information and then we set up you
know width height iteration the same
kind of things we had to do on the
renderscript side we need to coordinate
that with the Java side and then you'll
see here if threads is more than one we
actually spawn off a thread pool feed at
a bunch of data and work so just like
before and then we wait around for it to
be completely finished and make sure
that we've made it through our total
done is our total height we've made it
through every line in our bitmap okay
however if it was just a single thread
we call just a special function internal
to the C code that says you know do this
single threaded and we're back looking
at our same algorithm again so that's on
the single generated version I'm sorry
the single threaded version here on the
multi-threaded side in our thread we're
feeding it just like on the Java side
line by line so I need to walk through
every pixel on a line but there's a
little more bookkeeping here you'll see
that this is a lot more complex looking
than the render script side because I
have to manage the threads I have to
know what data I'm getting I have to
know what worked to pull off I'm just
using a simple linked list now once I've
got through all the bookkeeping and I've
pulled something off of my list I can
actually do the work and I can actually
manipulate the data and stick it into my
bitmap
okay so if we look at the native side
and what it does here this is going to
be single thread of native and it
happens pretty quick okay multi-threaded
Natives is really quick okay any
questions over the code anything I've
shown there pretty good all right so now
after all that everybody's probably
going okay we flashed a bunch of stuff
up on the screen what does it really
mean numbers-wise all right
I took some averages running on my Nexus
7 it's a little different on different
devices because they have different
capable different capabilities so just a
straight single threaded Java we're
about 2.7 seconds to render that image
on average multi-threaded Java we
dropped to 1.2 so we do see some
benefits with multi-threading as we
would expect no renderscript
we suddenly dropped to 680 milliseconds
so there's a pretty significant boost
there single threaded natives about 1.1
seconds which was actually kind of
surprising to me that single threaded
native came out really close to
multi-threaded Java but you know it's
interesting data point and then you've
got multi-threaded native which is
strikingly close to the render script
side so looking at it graphically it's
smoking fast so you can see that you
know the render script in the native
code are actually really really close ok
and the complexity in my opinion was a
lot less in terms of writing your code
any questions over the numbers all right
so now debugging it's very limited ok if
you're used to source level debugging
you're in for a treat
you've got RS debug is about it okay and
it's really just a very primitive printf
and you can't even really treat it like
printf okay you don't get variable
arguments you basically get a fixed
string and a number of data points that
you can output and that's about it okay
there's no source level of debugging
available on this thing if any of you
have worked on other embedded systems
not Android not working at the Java
layer with all these fancy IDs you'll
probably right at home here okay for
those of you who have not it's a good
challenge
take it up so sometimes you have to get
creative there are some capabilities in
the platform that I haven't talked about
you can send messages up to the Java
side so you could feed the Java side
some information and you could have your
own framework if you will if you really
wanted to spend the time on it so you
could feed your java code some data and
have your java code be a little you know
sexy or with the way that it about put
things but you got to be really careful
there the last thing you'd want to do is
maybe set a breakpoint there lock up
your CPU or your GPU it probably kind of
hard to do with the way that the
framework tries to paralyze it and you
know keep everything running in the
background but there is some potential
there so be very careful some of the
built-in features again it's all about
computation so you've got standard
mathematical functions trig functions
logarithmic you know vector matrix math
all those capabilities are right there
in render script just like OpenCL you
have a lot of that same capability okay
basic drawing functions so you can do
some basic drawing functions within
render script right into say but not now
there's some intrinsic scripts and I
touched on this a little bit earlier
you're gonna manage these just like your
own render script but there's special
objects that you can create that come
with the platform so the form looks a
little bit different but you can
effectively treat it just like a render
script that you've created you can call
it directly or you can chain it together
with other scripts the intrinsics tend
to be very graphics heavy ok you're
going to have a lot of blurs and blends
call
matrices convolve operations y UV in RGB
conversion those were all built into the
platform and available for you to use
okay
opengl was in for a while now it's out I
couldn't tell you why they decided to do
that other than I think they tried to
maybe you know just my speculation they
wanted to emphasize that this is meant
for any type of computation you want to
do not just graphics even though most of
the documentation kind of points out a
lot of graphics examples okay now with
Android 4.4 it is available in the NDK I
mentioned this earlier you won't find
any documentation on it if you download
the latest NDK you look in the docs
directory you're gonna see a render
script subdirectories are there and
you're gonna get all excited and go yeah
there's HTML there and really all it
does is point at the header files so you
just had kind of have to go spelunking
through header files to kind of figure
out how it works on the native side
alright so some trade-offs most of you
have probably already figured most of
this out but you get big performance
gains by using render okay it's portable
I didn't touch a whole lot on this but
one of the things that if you've ever
built something in the NDK part of your
make file you have to specify what
architecture it's targeting okay so the
first version of the native
implementation here that I ran on this
nexus it was dog slow and I realized
this because I just put arm architecture
instead of arm v7 okay makes a world of
difference in what gets compiled and
what's generated there so with the NDK
you really have to pay attention to what
architecture you're targeting and you've
got to build that into your make files
and each one of those libraries gets
bundled as part of your apk here in
renderscript it's portable okay
and I'm gonna talk about that because
some of you were probably scratching
your heads going how I'll touch on that
here in just a few minutes it's fully
paralyzed so like I mentioned when I was
talking about my native implementation
if it's running on the core application
processor of your SOC it tries to figure
out how many core
there and it spawns that many threads to
handle it if it's running and taking
advantage of say a GPU it's kind of om
specific what happens there but it still
fully paralyzes that and tries to
leverage what it can out of hardware so
it leverages the best of what the SOC
has to offer it's a familiar language
most people are probably used to seeing
C or C++ and it can be easier to work
with in the NDK for those building
purposes you know building reasons but
it is limited ok so some of the cons you
have to deal with the cross language
runtime coordination if you're already
used to dealing with the NDK this
probably isn't a huge hurdle for you
having to deal with you know the J&amp;amp;I
interface it simplifies that a little
bit but you still have this cross
language coordination of data ok you got
a whole new set of api's to learn which
in some cases are not documented very
well poor documentation I keep
emphasizing that because unfortunately
it's not cutting any better it's still
really hard to understand some of what's
going on in there and there's poor and
limited debug support it's still
changing like I mentioned earlier that
route function in my mammal broad
implementation taking an output my core
is the original implementation of that
for those of you who are going to pull
from the github repository later if you
go back through my revision history
you'll see that in an older version of
this it actually had an input and an
output and it worked great until I
upgraded into the latest tools this
morning
shouldn't have done that so when I did
that it certainly barked all over it and
it really wasn't at Build time where it
gave me problems it was at one time and
so the build worked flawlessly it had no
problem that stick it on the device
great it did the Java run it did the
multi-threaded Java one skipped to
render script crashed ok with no
explanation of what's going on tried to
hook up a debugger to it debugger
doesn't even catch the rash I mean it's
dead as a doornail and knowing so much
about why that's happening luckily I
managed to figure out that it was
because they changed that form with the
X&amp;amp;Y coordinate they don't expect an
input in that case anymore so I had to
modify the code there so a lot of it's
still evolving it's still changing so
it's a little bit of the Wild West but
you know it's one of those things you
have to weigh as you're deciding whether
to do this the supported Android studio
is a little bit poor and not documented
so like I mentioned before you have to
put your code in a different place than
you did traditionally they've also
introduced this support library which
takes renderscript support all the way
back to Gingerbread and unfortunately
that Gingerbread support library will
not work with Android studio so
deprecated an API it's really just the
opengl so all your mesh program
fragments all the different things that
they had added to render script to take
advantage of OpenGL they've now
deprecated and you're not really
supposed to use that anymore
new features intrinsic sar relatively
new that wasn't in the first version
that came out around API 16 I believe
script groups which are pretty cool but
you won't find a whole lot of
information on them multiple kernel root
functions I mentioned that before
and custom kernel root functions so you
can define what data you want to feed it
it's completely up to you
filter script is another new feature a
new API I'll touch on that here a second
and then the support library I just
talked about a moment ago which is
available all the way back to
Gingerbread
it requires eclipse or ant no Android
studio I think they're gonna change that
in the future but you know who knows
especially now with KitKat being focused
on lower-end devices and reducing the
memory footprint there there's probably
not a huge push to support Gingerbread
through the support library but you know
time will tell and now you can use it
with a native code so most of these
changes have just happened since
jellybean ok so there are all relatively
new things you can see this continues to
evolve script groups allow you to change
together I've mentioned these a couple
times over the course of the talk the
reason these are kind of neat is they're
more efficient the renderscript
engine handles all the routing of the
data so instead of you having to call
one script get the data out call another
script to get its data out or call a
script and tell it what other script to
call or have it hard-coded in your code
down at the render script level the
render script engine can take care of
that for you ok it's touched upon in the
docs but there's really no details ok it
requires at least API level 17 for both
your minimum and your target ok so 17 or
newer and you're basically going to set
up using this script group builder a
chaining of all these scripts together
ok
so you basically add your kernels to a
group okay using an add kernel call and
you pass this kernel ID and then you add
a connection between the kernels in
these different scripts and you go whoa
whoa whoa we've talked about root
functions we've talked about all kinds
of other things what in the heck is
kernel ID you're not gonna find any
information about that either
it's an undocumented reflected method
called get kernel ID and your specific
root function you have to use a special
attribute in your code to define it as a
root function you can't use just the
default route it won't work it won't
automatically generate you want so you
and
I touch on that here in just a second
with this attribute but once you do that
you can get this kernel ID and now you
can patch these things together and the
connections there's a couple of
different forms you can add a connection
between data types from one script to
the other to call the root functions and
then there's also some ability to take
one scripts output and just feed it
right into member data in another script
okay it's very handy for intrinsics so
the intrinsic class is again kind of
specialized forms of these and they hide
a lot of the renderscript functionality
and they have built-in documented
methods to get you want to bridge
together or chain together really
confusing because you really don't know
how to get the kernel ID so custom in
multiple kernels i've touched on this
it's touched on than the docs but
there's very few details about it and
this is that attribute I was telling you
about so you define this in your render
script and that tells the compiler and
the engine that this is now your root
function okay and it's going to generate
multiple for each and then your root
name that you use here okay the compiler
airs if you mess this up our bizarre and
really kind of hard to understand
unfortunate there's not a whole lot of
information on that the multiple root is
in concept it's not in the name so
you're not doing overloaded functions
you can't have you know one defined as a
kernel root that takes these two inputs
and another one that takes you know a
couple of vectors and call them both
root the compiler will say no sorry
can't do that so they have to have
unique names they can't be overloaded
names now filter script I just kind of
briefly touch on this this is intended
specifically for image processing
so whereas renderscript is for any type
of computation and the documentation is
very
heavy filter script is really what they
intend to use for image processing it's
intended to be even more generic you use
an FS extension rather than an RS but
it's basically still render strip light
the built-in types cannot exceed 32 bits
okay which is a little different than
render script because you can have a lot
larger you also have to put a special
pragma at the top of your filter script
which is telling it to relax the
floating point so you don't have to do
full floating-point operations and your
inputs and returns cannot use pointers
at all okay so it restricts that memory
binding and you have to declare a custom
rule filter script you can no longer
depend on the default just root function
all right so what I call the man behind
the curtain so we talked about it before
the the java virtual machine and RS
engine they coordinate with each other
with the virtual machine being the
master and the render script being the
slave so Java reflection classes and
basically it gets compiled into what's
called bit code for render script okay
and here's kind of a flow of what
happens your render script code goes
through what's called LLVM and you get
your reflection class up on the Java
side and then you get this bit code
resource both of those get fed into a
apt to create your apk okay and you get
your package you probably scratching
your head going bit code I've heard a
bytecode we talked about Java here in
Android all the time what in the world
is bit code ok LLVM is another type of
virtual machine like technology and it
outputs optimized bit code for an LLVM
engine ok its platform agnostic it's
highly optimized an Android finishes the
render script compilation at runtime so
what happens is when your apk gets stuck
on one of these devices that supports
render script the first time that it's
launched and it needs
that resource the renderscript piece
goes hold on I know this is renderscript
and I've got a bit code resource because
remember we fed that into the
constructor and if it hasn't ever loaded
it before it goes off and it finishes
the compilation and basically takes that
bit code and turns it into native code
so your device has an LLVM compiler
actually on it to support renderscript
and it compiles and links this into
machine code for your SOC and it could
be something that's just for like your
arm v7 or something the OEM is provided
that knows how to take it on the arm v7
and communicate with the GPU and feed
the GPU data it's also cached for future
use so this happens the first time you
run this render script and the output of
this compilation gets cached and it's
used the cached versions used as long as
you don't update the apk from that point
forward okay the first time you run it
sure yep right and do it install time I
have not heard anything or read anything
that says they're going to do something
about it
right now all the code basically the
first time you instantiate it it goes
out and checks a cache and if it's not
there it kicks off a build for it behind
the scenes so I don't know what their
plans are to not possibly do that at
install time it certainly might help the
first time you load something ok in the
end what ends up happening is you get a
special shared library that either
renderscript engine that runs as part of
your application knows how to link
against and that's how you get that near
native performance or basically native
performance so on the framework side
it's comprised of Java J and I and a
bunch of native libraries ok and there's
a whole slew of them here you've got you
know the render script piece you've got
the J and I that that works in
conjunction with that render script
itself which is all written in C and C++
and then the actual compiler and then
there's this driver piece okay it's
primarily
all done in native C and C++ so the Java
side of this is pretty thin
it pretty much calls down J&amp;amp;I and calls
native code to do all the work okay
that's the piece that's very platform
specific so if you pull down AOSP
and you look at the source code here
you're gonna see an implementation
there's the base implementation that'll
be for the application processor that's
running Android OMS would need to
provide their own customized version of
this to take advantage of something like
a GPU or a DSP or something along those
lines and that's one of the things that
they've recently done with KitKat it's
made some optimizations here and I've
tried to work with the OEM so that the
Nexus 4 the Nexus 10 Nexus 7 and Nexus 5
all see some performance gains because
they've tried to optimize these and take
advantage of the GPUs so your
renderscript class if you remember when
we walk through code this is the context
for the scripts and it manages the
native threads which are all done in P
threads just like I did in native code
to do all the work okay
this was also what maintains that render
script cache okay so the cache in your
application you know of compiled code
basically that bit code to a native
shared library it's an app private cache
that's available just to your
application and it manages native
instances of the render script objects
so this script C class is the base we
talked about this a little bit of your
generated class it's a subclass of
script and base object and it loads the
bit code and compiles it if needed so
the context manages the cache and it
works in conjunction with the script C
to actually do the compilation if it's
needed the first time it's run or if you
update your apk and that render script
resource has changed
it'll recompile it again okay the
instance defines an ID for the render
script of the context so there's some
coordination going on between these two
things
so all of your for each invoke getting
separate rap calls to renderscript those
are all handled inside of here down
within the framework so if we look at a
diagram of it you basically have your
script see for your script which goes
into the render script engine crosses a
J&amp;amp;I boundary and feeds data into worker
threads and that gets passed off to your
bit code library which has been compiled
to whatever the platform supports
whether it's just the application
processor on your SOC or to take
advantage of GPU DSP whatever okay any
questions over all that that's a great
question I think it's up to the OEM so
if you're going to take advantage of GPU
the OEM would have to make sure that
they provide an implementation to not
starve off OpenGL operations or 3d
graphics operations right I think you'd
probably run into the same kind of
problem with OpenCL right you have to
have that kind of coordination and
scheduling there and unfortunately
there's nothing in here that you know
I've seen that lets you tweak or update
the way that that behaves ok now
certainly one potential gotcha that's in
here you know from what I've seen of the
base implementation which uses the the
application processor of your SOC it
spawns enough threads to match the
number of cores so there's some
potential for starvation there if you're
doing a lot of work and I've not looked
close enough at the underpinning so I
kind of touched on it here so you kind
of you guys get a peak at what's going
on with that man behind the curtain but
you know what is it really doing under
there how is it scheduling those threads
is it truly just feeding enough you know
for enough threads to match all the
cores because if so yes you could
potentially starve off the system any
other questions
okay so it's a powerful computational
framework it's c99 based so it's
probably gonna look familiar to most
folks here okay
you've got trade-offs versus pure Java
and native J&amp;amp;I your performance is close
to native it's a little less complex in
dealing with J&amp;amp;I particularly if you're
gonna do parallel operations you do have
inherent inherent parallel operations on
a multi-core device or even be able to
feed to something like a GPU if you do
your own native spin with your own J&amp;amp;I
you've got to manage all of that
okay this takes away some of that
complexity it will take advantage of a
GPU or a DSP if it's supported by the
OEM okay
it is device architecture independent
because it does finish that compilation
once it's run on that specific device
and your debugging is very very limited
all right you do have some built-in
image processing intrinsics I would hope
that they'll continue to evolve this and
possibly provide some more intrinsic
based on demand right now the biggest
thing we're seeing it in is image
processing and that's what a lot of
documentation focuses on but you can use
it for a lot of other things and it does
continue to evolve so hopefully it'll
continue along that track you use Java
reflection classes to access your native
runtime all right so here's a bunch of
links for you
this is upped it has been updated since
the the conference slides were fed I
made a few tweaks to it so this copy URL
is you can get this presentation up
there and all this is up to date on
there the SDK documentation AOSP source
code and then the github for the fractal
code is down here at the bottom
you may have any other questions all
right thank you for your time</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>