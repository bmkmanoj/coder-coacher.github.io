<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Microliths to Microsystems | Coder Coacher - Coaching Coders</title><meta content="From Microliths to Microsystems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>From Microliths to Microsystems</b></h2><h5 class="post__date">2017-11-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NotiE8Mm8F4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone thanks for having me
over here Peter and NQ con this talk--i
says might have the sort of peculiar
title from markoulis to Microsystems but
now I'll try to explain what I mean
throughout this in essence it's track
history it's a talk about but marker
services but from an architectural and
especially distributed systems
perspective so we get a little let's get
right into it we've been spoiled by by
the once believed almighty monolith hail
monolith right with this single seek
sequel database and one thread being
spawned per request and and and sort of
this like this strong coupling and that
sort of has given us survey a
environment where we can where we could
assume one single now essentially that
we are like you full full control over
time and there's just one present you
can make a lot of assumptions and
simplify the world quite a lot by by
being allowed to have such assumptions
but the problem is that it's really a
fictional or a fairy tale world really
and and it's and it's it's we're sort of
living in this illusion that this is
real life but it's not really and it's
it's it's it's robbing world where we
could at least we think that we could so
comfortably for forgetful forget about
the University classes and distributed
systems that we learn in ten twenty
years ago
well knock knock who's there
reality we have been living and in an
illusion quite often quite far from
reality actually it's just to look
around and see I mean the the systems
that we are built in this monolithic
simplified world doesn't really match
any of this is anyway I mean how the
other world actually works and I'll
explain what I mean by that throughout
this this this talk you know today most
applications are deployed on everything
from you know mobile devices to to soft
offer running and multi-core often
quad-core processors now nowadays but
all the way up to this huge cloud
environments we're running thousands of
nose
often eight to sixteen core machines and
where user sir expects millisecond
response times uses are extremely picky
and demanding that nowadays and and and
reliability has to be I mean close to
one to walk to one hundred percent is of
course not physically possible but we
need to get quite far there if the
system's down for too long I mean users
will go to a competitor and you will
lose business in the end and and so it's
a fact that traditional architectures
and the way we build software up till
this point or a lot at least up to the
point by five seven in some cases ten
years ago simply does not cut it anymore
we need new tools and new ways of
thinking new ways of modeler of the
world in software in essence we can't
make the horse faster any longer
and we need cars for where we're going
so it's really time for us to wake up
time to retire this monolith and and so
start decomposing the system so into
discrete services that can be scaled
individually that can be that can fail
individually it can be replicated
individually as also that can give gives
us tools to scale the organization which
is lot what micro services is all is all
about it's not just an architectural
patrimony meet time to mark it with the
larger organization so these services
have have so have had men have had many
to knit names over the years we've sort
of done full circle once again as an
industry if you've been around for more
than ten years um and you see the signs
we're back to square one again
but I think we were getting a little bit
better each time around so so to speak
and I also think it's important even
though micro service is extremely hard
to not just drink the kool-aid micro
services come with the cost and and and
you need to sit down and look at what
you actually want to achieve and see is
it worth to pay that price very often it
is but sometimes it is it depends on
team size and and and your reliability
guarantees and and and etc etc and it's
really the fact that no one really wants
a micro services it is just as
concurrency just as distributed systems
just as eventual consistency etc it's a
necessary evil it's a means to an end
not just something that we should just
apply to everything because it's cool
and because we read about it on info
cube but today we got to take a look at
micro service system from Foreman from
not to do from the sort of scaling the
organization perspective but but from an
architectural perspective and put it in
its true context distributive systems
okay so let's say we want to slice the
weather model if now we want to slice
that up into into individual discrete
services for scaling for reliability etc
let's it might be a classy je
application servlet CG bees have been
using Oracle as a sequel database or
whatever deployed in WebLogic server or
something like that so very often too
often I say we end up with something
like this we have is a single instance
services they are communicating over
synchronous HTTP sometimes over s most
often over asked you each one run in a
docker container and then spin spin spin
it up in the cloud etc with using
regular crud we create read update
delete talk them talking through JPA
down into sort of often one single
database who would discrete schemas
would must be okay absolutely if you
know that you can't cheat and call into
each other's serve you of the world but
this is often now when we're out there
so seen us or state-of-the-art
the problem is that we haven't what
we've done is that we built it as
ourselves to set of single instance
micro model is what that's that's what I
call micro lifts where source state and
behavior is still capable them and we
have synchronous execution across
throughout you know calling down to the
database and synchronous communication
across these services essentially taking
every method dispatch and just making it
into a rest call I mean you might be
able to scale the organization through
well-defined protocols but you you won't
reap any paper if any of the Ben
it's from an architectural standpoint
that market services actually can can
give us and that's what I'm are talking
about it I call the macro list for a lot
for a lot of reasons one of them is that
they have extremely sharp edges right
you should expect to get hurt if you get
if you start playing with these things
and you know by definition they are not
elastic because the single instance
can't scale and they are not resilient
because a single instance is cancer of
self feel i mean you will sure it can
come back online but you will lose
business during during the downtime all
right so just relying on a single
instance just won't cut it so in this in
the spirit of carl he would call here is
one cell the one actor is no actor
actors coming system i say one micro
service is no micro service micro
service they come in systems okay just
like we humans i mean we we work best
when we even though all of our human all
of us are autonomous we think in in an
autonomous fashion we act independently
etc of each other but we we need to
communicate and collaborate with others
to solve to solve problems and it's in
this communication and when we help each
help each other out that we can really
solve hard problems it's also actually
ending in the communication in etc
that's all the most of the problems
arise right them intermón sir through
not understanding each other etc and I
think that also all the servers and
matches we're very very well into micro
services or key architectures as well
that it's it's it's both survey
something is a really good tool but it
also something that can post a lot of a
lot of challenges and the thing is
what's hard in micro service designs
really not the micro service itself it's
all the things around them I'm sort of
things like discovery coordination
security replication data consistency
failover deployment integration with
other systems etc etc right and it's
also true that as soon as reserve exit
the boundary of this safe world that the
of service kids or be we we enter the
Rubies wild ocean of non-determinism
this the craziness that we call just
distributed systems where you know
distribute systems is really really hard
it's worth where systems can you know
fail in the most spectacular ways you
know when we're messages get dropped
reordered garbled and and we're failure
detection that's understanding if a
buddy is down it's it's nothing but a
guessing game it's impossible to really
know for sure if the one you're talking
to is down forever if he was just you
know do under heavy load or if we just
we'll be back and we'll be back in a
second it's doing GC etc we're actually
we'll never come back up so you need to
start guessing and you need to take
educated bets on on who's up and off
etcetera this also it's it might sound
pretty terrifying this is the good thing
is this also the world that gives a
solution for these all for all these
hard problems solutions for resilience
for elasticity etc simply because a
single instance can't help us much with
that you need to start introducing the
network so I really think the system's
start need to start exploiting reality
you know and one of the main benefits of
microservices it gives us a lot of good
tools sort of how to exploit reality to
build systems that really mimics how the
world actually works and that and that
includes both its constraints and its
opportunities and you know there's power
scene constraints and then powers can be
liberating so and one of these
constraints is for example that
information has has latency it's the
fact that information simply cannot
travel faster than the speed of light
and this can often travels considerably
slower
this means the communication of
information has latency and as Pat Helen
says that the contents of a message are
net are always from the past when
when it arrives - you told us represents
another they serve another now
essentially it always you know they
represent and others are present
something that already happened and in a
way sir we're also looking into the past
it's a fact that reality is simply not
consistent not in the real world in this
monolithic world sure we could we can
often assume that to some extent at
least if you multi-core processors etc I
mean sure you can you can try stop the
world with locks etcetera but but it's
really not true not even on a single
processor nowadays but but it's
definitely not true in a distributed
system then this latency is actually
very noticeable okay but still we're
trying to sort of hold onto this
illusion of that now is is absolute that
there's one single global a consistent
present and you know this the cost of
maintaining the solution is very very
high it's it's it can be be defined as
two things contention which is like
waiting for shared resources to become
available after when someone's holding
on to them using them or coherency which
is that the work that needs to be done
for - for to serve components or
instances or something - to have a
common view of the world essentially and
this affects daily life I mean if we
think about it it's also one way sort of
just just living with the fact or
reality but it's a little bit also very
true in computer science and and and the
first one contention is is defined by
arm dolls law which is the the dot the
dotted line here like that shows that in
the fact the effect that contention has
is that it gives us diminishing returns
so in this way this way for you right so
when you start adding more resources
it's not it doesn't scale linearly but
it's it flattens out more and more and
after a while it's not worth adding more
resources because the contention eats up
all the benefits but the truth is
actually closer to Neal Ginter scale
Universal scalability law which which
shows that when you add coherency on top
of
of the of the contention you can
actually start getting diminishing
returns as when just adding more
hardware CPUs or nose or whatever it
actually started in tune to decrease in
inefficiency and and and and and
throughput so and you know I mean it's
latency gets higher it's this illusion
cracks me one more and more so there's a
larger difference between the present
and the past in distributed systems and
once again that's a quoting Pat hell and
in a distributed system you can know
where the work is done and you can know
when the work is done but you can never
know both okay this is the fact this is
something that we need to embrace and
work with not against and we need to one
way of is like the architecture systems
that we try to minimize coupling and
communication you know in a coordination
is that water air said it's extremely
expensive and it's even more expensive
in a distributed system because the wait
times are longer and stopped the world
is longer etc and it really puts an
upper-bound sort of ceiling or what can
be done in terms of scalability
elasticities your reliability and you
know etc also things like in low latency
and things so you know the need for
coordination means that individual
services can't make process progress
individually but has to wait okay and i
think it's very important that we that
we preserve understand the words are
really unnecessary they can only do harm
that we need to start enjoying the
silence to quote Depeche Mode here and
and and and and it's Bob Monkhouse says
write silence it's not only golden it's
seldom misquoted we should just love in
a way we need to start to learn to shut
up and then avoid this chapter between
the services absolument
to cut it down to a bare minimum at
least and it's also the fact that we
have to rely on eventual consistency not
because it's cool and because there's a
lot of you know the no sequel database
vendors tells us to but because it's a
fact of life it's how the world works
really we do once again we shouldn't
fight reality we should embrace it and
things will actually become simpler not
simple but simpler I think through to
actually reach the goals in the band
reap the benefits that we want and once
again no one wants eventual consistency
it's a necessary evil it's not cool it's
useful and there are two helpful tools
that will help us with all everything
I've talked up to this point now that
we'll talk a little bit in more detail
about this is reactive design so
embracing the reactive principles of
software design and using events first
domain-driven design is finally a great
way to model the world that that puts us
on a path towards building systems that
embrace reality okay hurry up for that
you don't have a choice we can always
leave but yeah
so there's been a lot of confusion
around will react with reactive
programming is versus reactive systems
and I mean you know reactive is really
hyped that's been and and and too much
perhaps I mean same thing with
everything that's that's that's that
that's hype that it's like reaches peak
of you know inflated expectations and
then it you know comes down to the real
world and and and I we might be there
now but but I think there's a lot
there's a lot of good things coming out
or that it is being overloaded as well
right because you know all concepts and
ideas need to evolve to stay relevant
and and if people you know weave into
more more things intuitive something
even better might come out but but so I
think personally I think reactive
programming reactive systems are
extremely important both of them but but
at different levels in the program all
outright or in system design and I'll
explain what I mean shortly reactive
programming essentially means that come
in is a way of building individual
services that that have very good
performance and utilization as
cetera using things like async this
asynchronous techniques non-blocking
algorithms and things like that back
pressure you need to make sure that you
have resilience between all your stage
you see of the component etc while
reactive systems sort of takes a more
holistic view of the world and and and
and more I mean a full system design we
reveal the world and that's what we have
serve are are they are articulated in
the reactive manifesto however to
achieve that you often need to rely on
reactive pro pro pro programming but the
promise of reactive systems you know
building on a message driven foundation
is resilience and elasticity is that it
fits perfectly with what I'm talking
about here today so in but but we
actually programming I think it's a very
important technique I mean we need to
start embracing a synchronicity more and
more I believe and and a synchronicity
means different things to different
people I mean some some think about
asynchronous i/o which means that it was
essentially is it's all about not
blocking threads
there's minimizing concurrent contention
etc and while asynchronous communication
is about not blocking requests so these
more which is also extremely important
of course them and Surya asynchronous in
non-blocking i/o is as I said it's all
about being as cost efficient as
possible make efficient use of the
resources that you have and giving them
up when you're worried when you don't
use them for others to use ok and and
and you know contention we've already
seen in in this diagram and all flaws is
one of the things that hits you first
when it comes to efficiency and and
that's why I think I mean being the
weakest link in the chain matters so
trying to make sure that your whole
pipeline is asynchronous all the way
it's extremely important and hear things
like reactive programming techniques
like reactive stream specification of
these type of things
ARCA streams Oryx Java are these type of
techniques really help but but also it's
also you know alongside a async I think
this is e
important to form a reliability and
resilience perspective to to embrace
back pressure I mean it's it's all about
flow controls but it's it's about that a
fast producer should not overwhelm a
slower consumer essentially and and why
why why why why does that matter I found
this video on Twitter in a completely
different context but I think it really
illustrates the need for back pressure
very well see these guys they didn't
start stand the chance right against the
fish here's here's clearly that that I
mean having some some sort of way of
telling the fish to slow down with then
it would be beneficial okay so so so
there is a need to have a sort of have a
back channel I mean events flow this way
you need to have a way of propagating so
hands to say I can't keep up please slow
down etc and and and here's where the
reactor screens specification come seen
is it's a specification that was great
it was it was started by like that but
we invited in your Netflix pivot little
Oracle or Twitter and others to to to
create sort of joint specification
because it's not it's not worth anything
if just one library does it everyone
needs to participate all the way up to
the client that might be the one the
serve starting off this this storm of
events so if we now apply reactive
programming to this market list I mean
if you can look some something like this
you have this blue dark blue box series
that we should wrap the whole thing in
in in you know in reactive programming
by Vice or making it asynchronous
replying back pressure streaming where
appropriate etc okay I think we also
need to we need to sort of make sure
that the way we the way we communicate
with the world is asynchronous as
possible and also sort of embraces back
pressure through asynchronous messaging
for example using perhaps car
as a message bus or something like that
or using streaming as a way to
communicate between services not just
really relying on synchronous request
reply I'm not saying that all that
should just be thrown out the window
sometimes it fits the use cases very
well but it should not be the default
communication paradigm between your
services so by doing that yeah it can
look something like this we have now
arrest messaging and streaming along the
side by side so I think we're we're
getting there but we still have a single
instance of this macro service which is
by defined with the by definition not
scalable and not resilient okay because
but it's equally important to understand
that micro service does note that that
does not come in systems they also come
as systems and what and what do I mean
by that I mean that in order to build
truly reliable micro services we need to
think about them as a system in itself a
distributive system and that's what I
call a micro system so here you have the
title of the talk right from markoulis
in single incident services to micro
systems I don't know I don't know if it
works it was just something that we
brainstormed up but but you get the
picture I hope so we really need to move
for a mark of this to mark to micro
systems and and one of the first things
that we need we need to do here is that
we need to separate the stateless
behavior in the service from the
stateful entity okay and why is that
yeah it's because then we can start
scaling them alongside to two different
accesses they have very different needs
and very different server
characteristics in how we can and how we
can scale them and by doing that we'll
look something like this likely we split
up this the stateless behavior in this
green box here from the stage full
entity and then we can start so say
you're working with them in different
ways so to speak scaling stateless
behavior is actually quite easy this is
what we see now with Amazon lambda for
example yeah the only did this whole
service
you know trend this all is all about
that that you can automatically just
just spin up as many instances as you
need for the time being and then just
scale scale it down you know the whole
thing in in in in all the in distributed
system design in general is state so
scaling stateful entities on the other
hand we're not that lucky it's actually
a lot harder and and while I'm at it I
just have to rant about what people call
stateless architectures like I don't
think there's there's no such thing
really as a stateless architecture it's
just someone else's problem you're just
delegating it to someone else which we
see in one way I might feel nice because
you're not responsible anymore but on
the other hand you know someone else is
and now sitting in their lap hoping for
the best so so often I think it's better
for the embrace state as part of of the
up there of the system because it's
really it's actually one of the most
fundamental things in your system and
fully embrace it and take control over
it and manage it in a good way instead
it's also a fact that this entity now
actually can become an escape route from
reality I talk a lot about embracing
reality but now we actually have have an
opportunity of living in this illusion
you know that that that we have full
ownership of of time because we have
isolated our domain I'll talk more about
that
you know in a way that we can we can
assume that we are the only one that is
touching it right so that's can simplify
the world a lot for us
so now we can start sort of start
scaling these the stateless behavior and
the stateful entity individually I mean
in my it might be that if we have a sort
of a very processing in any intensive
system which means that you we need to
run hundreds of above of stateless
services but but
it'sit'sit's we but we don't need a in
any anywhere close as many as much
processing power to persist it right and
and in the end in the simplest fashion
we we we probably run around two
instances here like for for for scaling
state any sewing in somewhere one is the
main replica that we always talk to
while the other one is syrup it's hot
standby often that is sufficient but we
also have the opportunity here actually
to have to have some have multiple
masters that that takes rights and and
and but then we have to do the work to
figure all that out to cook the
causality etc a bit in between in the
end we're actually doing some work on
that now in yanaka persistence and logon
that we're using CR DT so I don't know
if you know about that it actually
detect causality to do master to master
replication of the entities but I want I
won't go into that here so but in
general reactive systems can really help
us here just to scale these two row long
alongside the these are the two
different dimensions here to really make
it resilient to make it elastic I mean
go to a reactor manifest and read the
basics but in in general reactor systems
are based on asynchronous message
passing now that is sort of the
foundation and that gives us a way to
build truly loosely coupled system that
can be adaptive where you have all these
autonomous component that can sort of
collaborate where they're where you
break free from the strong coupling that
that you have because everything's
happening in a synchronous fashion and
and it all is it's also sort of the base
is the foundation for things like
isolation and mobility that we'll talk
about and mobility through the
foundation for forever
elasticity and it in essence pacing
message passing allows two things allows
us to decouple our system into sin in
time and and decouple the meantime is
what gives us concurrency
it can give us
concurrency on a single thread through
interleaving right that's what nodejs
and another event loop style programming
malls do and that's good right but it
also but but but but that's sort of a
little bit more of an of an event based
model it's a true message passing allows
us to spread it out in space as well so
you have if you scale it or scale it or
make its or decoupling it in time and
space and this and it's decoupling in
space that gives distribution and
mobility in us and ultimately also
elasticity's we start making makes or
scaling after multiple cores or multiple
machines taking advantage those are all
the promise all of the cloud as well as
rely reliability you can have more than
one source or a party that can take over
if another one fails etc and it's all an
asynchronous message passing through the
essence of reactive systems is also what
what gives us what we call location
transparency and and and and that and
it's that's quite a fascinating subject
actually because it what it allows us to
do there is we have one single
communication abstraction being sending
message from A to B that scales across
all dimensions of scale it's the same if
you communicate I mean within the core
within I mean sir bits between course
between sockets between different CPUs
between containers between servers
between racks between data centers I
mean across the world is the same
abstractions the same programming model
you don't need to I mean you know sort
of use for example threads and locks you
know four four four or even regular Java
concurrency for for working with with
within within the processors and as soon
as you want to talk across they need to
bring in message oriented middleware or
whatever some other USB or whatever
we're all sockets but actually lives the
abstraction layer and unifies it all so
one way working across all dimensions of
scale and the nice thing here now is
that gives the runtime the ability to
change that the topology asks the system
is running
and then this Indian in this talk we
talk about microservices it actually can
have too much then services running on a
single machine just in two different
course and and it and the communicate
wouldn't with message passing and then I
mean the next second it has migrated
over to another machine the same
communication abstraction works for the
for the sender that actually
communicates nothing has changed it's
now out of process okay but no one needs
to really know the latency of course
willing will increase but that's the
really only way you should know so it
gives a lot of a lot of freedom in order
to to build dynamic systems that change
as they are being used which is really a
must in most cloud environments today
because you have no idea I mean how
predictable that the the usage patterns
will be and in a location all
transparency
location transparency really is what
enables mobility dynamic dynamic City
and an adaptability and and it's it's
really what gives us serve as I said the
chances for moving things around you
know I think the the Metallica quote was
quite apt here you never know where your
home is right I mean wherever you're
wherever you I lay my head is home and
and it's really the path towards
building truly reliable and resilient
systems I mean it enables decentralized
architects your bulk heading for full
isolation replication failure detection
supervision all these things that puts
us on the path to build self-healing
systems and I don't have time to go into
much more detail here but it's the same
thing that puts us on the path towards
LA elasticity through all the through
decentralized architecture things like
epidemic gossip protocols Nachman
masterless architectures etc where where
everyone's equal and then the system can
adaptively grow and shrink as needed as
it being is location transparency is one
of the keys here that puts us on the
path to building through the elastic
systems and I think that this is the
benefit of applying and embracing sort
of their reactive principles so so by
doing this nicer of this in this serve
okay
diagram you can see we have reactive
programming now inside each one of these
node as his dark box I don't have in a
point with this I don't know you can see
yeah
reactive programming is it's really nice
for for making each individual node here
as efficient as possible while reactive
system sort of is sort of embraces the
whole service to making the whole
service as reliable throughout all these
different parts all making up this micro
system so to speak okay so how much time
to have 5060 minutes again so how hot so
how can we sort of think about this and
model this than ingénue I think we need
to start thinking in terms of what what
I call consistency boundaries and and
try to serve think what is the
consistency boundaries for a boundary
for mine for my mac mac for my macro
service and try to minimize the scope
and minimize the part so the the the
data that needs to be strongly
consistent okay and and it's really good
- don't not start with the behavior here
sure you can but in my experience is
often better to start with the data and
look for the minimal data set that you
can do that you that you must have like
full consistency in and think about the
data integrity guarantees and and
denormalization all these things and and
and and when you have that that that's
through the essence then you have the
data model for your service and then it
can add behavior to that and by
minimizing this this this data set you
open up for more freedom when it comes
to to have small services that can scale
more easily minimizing coupling and Pat
Helen has a really nice frame before how
to think about this where he talked and
thinking about this this or this
consistency boundaries you talk about
inside data that's our current present
that's the stake in our service outside
data that data called blast from the
past just you know the
represents the past from other services
entering or current now or current
president and between services is what
he calls hope for the future it's almost
something poetic about that right we're
that that that is the commands that
arrived or sorry the commands that we
send asking someone to do something and
hopefully they will comply and do it but
we have really no guarantees not even
that they will actually get this command
and know what to do okay and and here I
think a great tool in order to model the
world like this it's advanced first
design I think domain-driven design most
people here probably know the main
driven design and it's a great tool been
around for quite for quite long but the
the problem with it is that most people
start you know thinking about the things
certainly the thinking about what are
the domain objects and categorizing that
etc so that gives us a way of makes us
focus on structure of things to to early
event events first domain driven design
serve teaches that we shouldn't we
should not focus on the things the nuns
like we've been told told to in classic
orbit oriented design as well but what
happened what happens in the system what
are really taking place who's talking to
who who's coming where where does you
know things end up how are the flows etc
because this is the events in the in the
system so I think we should really dive
in to the to the to the sort of modeling
through the events first and let the
events define this bounded context that
can that can later become or our service
and you know events represent facts and
sir facts about the domain facts about
the world facts was really going on and
so the question is and what is a fact in
fact represents something that happened
in the past something that have already
happened that is the fact facts are
immutable facts don't just you know
you know so you come I mean we can't
just create facts out of the blue I mean
either facts enter our system from
someone else
that's how facts Kenda can serve a crew
or we can derive a new fact from older
facts essentially derive knowledge from
older knowledge and we're not talking
about alternative facts here just so you
know sorry I yeah so I couldn't keep I
couldn't help it so what are the facts
then then we we should we should really
sort of come in like a detective to
crime scene and start like try to mind
the facts try to distill what are the
facts and hear events storming a sip is
if it's a technique that's been starting
to become quite popular in wishes for
bringing all the stakeholders all the
domain expert programmers in one single
room we work with with post-it notes and
try to understand what are they what's
happening in the system what are the
events in the system and then how they
are related
etc and it's very important to
understand how the how they are causally
related because causality it really
really starts to matter here the first a
happens the causative this fact that
sort of then causes B to happen etc also
once centralized approach to do that its
event logging what we'll talk about
later and more distributors or
eventually consistent approach is using
MC are you tease conflict-free
replicated data types vector clocks
these are often used by by the tools
underneath to make sense of causality
and you might ask them okay but what
about mutable state I mean facts are
immutable whatever immutable state and
can't I work with that I think the
mutable state has its place but it needs
to be contained it should should never
escape the service you know it's it's
okay to work with with with with with
mutable state within this sort of low
locals or --have and completely non
observable to the rest of the world
doing your computation but as soon as
you're done with the computation you
should you should create a fact out of
that
and publish that to the world salars can
react on on you know and work with with
on a stable ground etc and and you know
disk space used to be extremely
expensive and this is the reason why
most sequel databases use in place
updates the destructive updates and and
but but now disk space is is incredibly
cheap and there's really no reason to
not keep all history around forever you
know all the sequel databases they use
in in you know they have the the the the
transaction log in use event logging
underneath not just exposed to you so so
so if we ask the programmer is one one
even one in mine history answer or or
even more before that of course let me
sort of store history we need to do all
kinds of crazy stuff you know have
history tables etc etc while the
transaction log is actually available
underneath and I think this is this is
wrong right I think that that today
since the disk space is so cheap there's
no reason why we shouldn't work with the
real thing the transaction law to the
amount log and I think that crowd is
really dead there's really no reason to
use update and delete anymore we work
with facts facts just accrue we create
facts append facts we read facts and
that's it you can't change the past
so really update is just a hoax really
delete as well even though we sometimes
wish that we could change the past it's
unfortunately not tapped no not
available to us so we should favor event
log in event logging is really about
causality drawing the facts in the order
as they arrive hopefully the order that
that they happened to if you're multiple
you know facts happening in in different
places of the system might be hard to
actually know what the cause of
causality order is but usually it works
it does that in in real life most of the
time and here event sourcing is a great
tool you might have heard about event
sourcing it's it's real about storing
all events in an event log on disk as
they arrive it really it's great to for
for doing things also doing things like
not you're storing the history but also
to do things like replay on failures you
guys replay it up and bring the
component up again you can you can
replay it for her you know for auditing
reasons for debugging reasons etc and it
fits very well with messaging and with
event based systems because you already
have the events in the system already
why not just store them and you're done
so you know the log is really data based
of the past not just the database order
of the present where time is the index
hard time you can see we really did see
our time progresses and how facts are
laid out alongside this deserve this
axis and and also event logging server
gives us relief such tools you know to
avoid this is in famous or Victorian did
relational impedance mismatch that all
of us that have you know you use
hibernate or JPA etc have struggled with
because you can really have an optimal
representation in memory in your objects
in your services while they are stored
in an optimal way look at disk and
another pattern that it's really nice
alongside it goes in concert with event
logging or event sourcing it seeks is
CQRS you know you know command query
responsibility cigarette segregation and
it gives us a way to serve decouple the
riddler the right side from the red side
and this is also very important might be
you you might have a like a write mostly
system so then it so then you have the
chance to scale that independently of
the red side or if you have read most
list system they can have one over by
two should always have three actually so
you have see but then they have like
like three nose for for writing and 30
nose for
etc and yeah it also the biggest benefit
however is probably not in the scaling
and the reliability but it gives you the
chance of storing each the right side
and the right side in the optimal format
for for each data model you might want
you might have have if use event
sourcing the optimal form is definitely
about event logging the single writer
principles the no contention gets right
to this bang bang bang bang extremely
efficient but it's extremely hard to
query that in an efficient way so so so
if you separate the read and the right
side that then you can have you just
would have a query mechanism or sorted
whatever data model that makes most
sense for querying on the real side
might be time series base might it might
be sequel databases if you want to use
me role in a sequel or something like
Cassandra some column database graph
databases or whatever so you also see it
really gives us more options for for
both data modelling and and query so if
we if we take a look at this a little
architectural diagram here if we then
take it advantage of events or see and
and seeks and CQRS and answer the frame
of the pad he'll and talked about here
then we have or client create commands
here then our commands will enter our
service and and yes stuff will happen
will will will will process them many
execute our business logic and and and
and that will sort of create a command
that will sort of send down to the truth
to the entity which which creates facts
out of this fact that that state change
has happened and this is nothing that
you then can take can take back these
facts then we will store restore in
their in their in the in the right mall
in the in the event log as they come in
then while the the right model can then
emit these facts to whoever I mean for
auditing for for debugging
might be other readers or for
replication might be other readers but
one reader of this can be the read model
that that stores it in the optimal
format for reading for Crowe queering
etc so I think then here we end I end up
with with the system that really has a
lot of improved scalability
characteristics you can scale the the
the stateless behavior completely
independently of how you scale the
persistence and you can also scale the
rear side and the right side in India
independently of each other and it also
improves resilience here yeah for a for
obvious reasons because you have you can
look you know and in any number of
instances running here they can they can
take away any number instances here I
mean in these things are usually
clusters search services as well so one
question that that always get is what
about transactions and if I really need
transactions what should I do
yeah to quote Pat Pat Helen again and in
general application developers simply do
not implement large-scale scalable
applications assuming distributed
transaction this is the great paper that
he actually did an update for last week
putting this is like from 2007 or
something I think I wrote this but he
didn't update the last weeks putting it
into a little bit more context of now
but I really encourage you to read it so
what should we do then yeah who Grace
Hopper once said that it's easier to ask
for forgiveness than it is to get
permission okay if you can't coordinate
with someone and be sure about something
what do you do then yeah you take an
educated guess okay that condition will
will will will will hold and if you're
wrong what do you do yeah you apologize
and you you perform some sort of
compensating action you know flowers for
my wife or something like that it
usually works so we and we humans use a
protocol of some guests apologize and
incompass
and I really think that since this is
really how the world works I mean other
other other examples are you know over
booking flights you know I mean I've
like way too much and way too many times
I've sort of come to come to the gate
and and and and and the flight is
overbooked and and the you know the the
flight attendants try to bribe them
themselves out of the problem by issuing
vouchers you know meal vouchers are
usually completely useless or travel
vouchers like it's lucky if you want to
travel even more with that airline but
but anyway and the same thing with ATMs
you know they actually allow it to -
deEtta to deduct or sort of - to to
withdraw money even if they can't access
the mainframe in the in the back taking
a taking and educated guess that you
probably have coverage for that money
that you want or that you're about to
with will that you want to do withdraw
and if they were wrong when the when the
when this or when the link is
established again it will it will deduct
your account
- sometimes a negative balance and you
have to pay the interest for the fort
for that so it's really how the how the
world works is once again trying to
serve embrace reality in how the world
actually works and that will simplify
the world and when one one patron that
sort of makes use of this I want time to
go through now because they're 18
seconds left is is this saga pattern
which serve gives us or in short a
service or decompose your flow into
discrete chunks so transactional chunks
in which each serve action has a reverse
in compensating action and and this
allows you to have a synchronous it's
asynchronous communication between each
of these stages across different
components and if something wrong
happens here then we can reverse the
whole transaction by just issuing it was
invoking the compensating action for
each one of these of these stages that's
so the in a way that gives you
the transfers transactionality that you
want without paying the price in reduced
availability like we always do with X a
transaction that never cease never works
so this there's a lot more to say but
probably overwhelm you already so but in
summary don't build build systems of
micro lists micro services come in
systems distributed systems but they
also come as systems each market service
need to be a micro system and that has a
lot of implications because that means
that each micro services in AES is a
distributed system sir practices that
connected that can help us here is by
embracing the reactive principles
standing on solid ground like the work
of Pat hell and Jim Gray and and you
know Joe Armstrong and Robert Verdi
Erlang systems these things work it's
just that we haven't really understood
how well they work yet and also embrace
event first domain-driven design I think
it's an excellent way of a modeling your
system and put you on a path towards
building systems the micro services that
really is not just for scaling into
organization but also take full
advantage of the architectural benefits
or building distributed systems so
that's all I had yeah sorry one more
thing you don't have to sort of built
all this yourself actually there's a lot
of frameworks out there that does help
you one of them that that does it seem
very much in the spirit to what I talked
about is it's the one we have a live
band called log on yeah it's it's it's
for Java and Scala if you happen to
programming these in these languages so
that's something I encourage you to
check out because these things are hard
and and we built this you know from what
we experienced from from from who from
building micro services on ARCA our
customers building our core services on
an octa and play for the last eight
years and so we're wrapping up the
patterns and the best practices of doing
so go to logon framework or comm if you
want and I also wrote a little book
about about Marco services architecture
from a reactive perspective is free it's
freely available you can download
for free in this URL it's very short
just looking this one is or I'll in many
books so that's all I had thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>