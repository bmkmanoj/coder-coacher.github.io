<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Vaadin, GWT, and Client-Server Hybrid Apps | Coder Coacher - Coaching Coders</title><meta content="Vaadin, GWT, and Client-Server Hybrid Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Vaadin, GWT, and Client-Server Hybrid Apps</b></h2><h5 class="post__date">2014-02-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nmttjyBPuxc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I won't be speaking about Varden I won't
be speaking about Google web toolkit at
least not two months so what I wanted to
speak about this hybrid applications
this is a bit of a new type of approach
for building web applications and from
there we go to vote in and Google web
toolkit as well but the main topic would
be this hybrid up roads for building web
applications so my background I'm from
boarding and you know this bar in it's
actually a Finnish word meaning female
reindeer so that's the background of the
words and the team is from Finland
that's reason for 20 guineas word so
hybrid applications who knows which car
is it yeah so it's aight aight so that's
really nice hybrid car that has
basically both ends in and us as well as
electric motor inside and it's actually
pretty amazing car in a way that it can
generate a lot of power and it can
combine basically best of the both
worlds so the second car is this one
anyone any guesses you didn't expect to
hear about cars in this print desert so
this is a serious merciless I guess this
BMW is costing something like 130
thousand USD is this is costing like
hundred thousand USD is pretty expensive
cars and the third ones somebody's once
said that if you are throwing your
iPhone in San Francisco always are
hitting this car so this is also pretty
expensive like sixty seventy thousand
usd's so if you compare these three cars
you see that this Merced is this is our
traditional luxury car you get
I don't know how to do miles per gallon
so it's eight point six liters per
hundred kilometers so it's costing like
15 16 bucks per hundred kilometers so
it's pretty expensive to drive but at
the same time we have great rains you
can basically drive from coast to coast
because there are gas stations
everywhere we test lights goes in a way
that it's really cheap to drive I mean
basically costing like one USD per
hundred kilometers but at the same time
you have to find out someplace to charge
it so it's it's not that good when
you're offline or off the grid of course
these guys are building the grid all the
time so it might be better over the time
and in between is the hybrid solution
very try to combine the best of this
ball two worlds in the one car basically
have unlimited range because you can
stop by and fill the tank anywhere but
you still have the good size or type of
the electric car so what does it have to
do with apps so you all know how web
applications work I mean like rich web
applications you always have a back end
you always have a web server on top of
that then there is some kind of
communication channel and then you have
a javascript-based client-side user
interface and this is what traditionally
is when people speak about rich web
applications they are speaking about
having a javascript-based you I on the
browser side and communication channel
amazingly like rest over eight sacks or
sandwich that and a web server sending
over data from your back-end this is
less known a service are you approach
where you only have the web server side
and these two guys are fully automated
so instead will you program in these
parts the framework does it for you and
there are multiple frameworks that are
doing just like this so if you taking a
look of the like basic JavaScript stack
you are required to write all these four
layers
if you look at the google web toolkit
there is a brilliant way of compiling
from java the java script so instead of
writing in javascript directly of
writing in java compiling that and
optionally you can go over and right
part in javascript as well but you still
have four layers and both of these are
strictly client-side you I approach so
it's more in it's a bit different beast
you are required to write the
server-side UI layer and of course you
have the back end but because you can
write any of these layers you can
actually build clients are you ice with
boarding and you can build server sell
us with Vardon and this is a bit strange
approach having like to program models
in one framework so if you are comparing
these combine basically one layer versus
three layers there are like pros and
cons in balls if you are having one
layer only it's quite obvious that they
are writing less code you're writing
less layers yourself so it's basically
half the code how to maintenance much
faster to develop but if you are writing
all the layers by yourself then you have
full control over the whole experience
you know when the 8x calls are shoot
over the wire you know how the dome is
manipulated exactly so you have more
control over in in three layer approach
so more productivity with the server
driven or server and then approach and
more control with the client River
approach I guess client driven approach
needs no introductions you all have
written some Ajax apps right but a quick
poll who has used google web toolkit
before on for guys who has you spot him
before only one guy okay i hope you are
then learning something new so the
server-side approach is such that you're
writing your user interface in java
programmatically like this piece of code
over here putting couple of components
on this
green wiring up and wearing up an event
handling code that shows a notification
when we click this button this gets run
on the server side but what actually
happens when you go with your web
browser to the URL running voting
application you actually get the bunch
of HTML Javascript images and so forth
and the good side is that you are not
writing this yourself they come with the
framework so and and while this is like
a bit over a Meg of different stuff it
gets compressed and ready to around
hundred que todo and this what you get
this is you you could say it's a
terminal or client for this framework so
this basically can render any of those
you are component supported by the
framework so whether you have like
hundred you views on your applications
on one of you or million views the
amount or download code is still the
same your download a hundred K or 200 k
depending how many widget you are using
so the first thing is that you get this
UI on the screen when you start
interacting with the UI what happens if
the framework automatically sends an HX
call over the wire so it's it's actually
rest-based it call having some hundreds
of bytes in it basically encoding what
are the actions that the user is doing
clicking a button writing a name on the
text box and this gets routed back to
your code running on the server side in
real JVM and your cliq listening code
can do whatever it wants it can take
synchronous call to the backend ask
something from the backend modify the UI
as it wishes and then framework takes
over and somehow sends instructions back
to the client that how the UI should be
changed these interactions are encoded
as changing as well and at they are like
on the logical level so they basically
are saying that hey please put the text
over
they're both the tree on the left side
of the screen and that kind of stuff so
hybrid apps I guess the question is when
you should be using client-side approach
when you should be using service or
approach and what would be the use case
for combining these for the client side
like really strict use cases offline if
you are used you simply cannot do
offline application with servers our
approach of course if you are please
you're running on the server side and
you don't have connection you don't have
you don't know anything about
application so then you have to go to
offline also low latency applications
like games or pretty obvious you don't
want to go over the wire when you are
playing a game and same goes with the
scalability if you are willing Twitter
or gmail you really want to offload as
much of the computation to decline such
as possible because the servers are
expensive on the other hand if you are
building a banking application where you
test have like 10,000 users not millions
of users service are not that expensive
anymore because you can handle basically
tender the user with one or two servers
on the server side it's I would say that
the use case is use it everywhere where
you don't need to be on the client side
it's quite a bit cheaper to build
application on the server side just
because you are only going one layer
instead of tree it's also a bit more
secure because all of your code runs on
the service are you are not exposing
your UI layer called the client side
it's kind of a black box instead of you
showing the rest of all the users how
you you I works what can validate or
other and so forth and of course you
have full Java platform so your code
your UI code runs on real JVM on the
server side you can use all the
resources on the server side you can use
any language that can be run on JVM so i
have seen scholar getting quite a bit
more popular for one in you eyes lately
and you can do crazy stuff like i think
the most
where stuff was when somebody wrote that
one and you I with COBOL and that that
was ugly so hybrid tries to combine best
of these two approaches but the downside
is of course if you are having two
engines in your application at the same
time you are adding complexity you have
the understand both of these approaches
at once but on the other hand you're
going to get best best of the both
worlds for it so let's take an example
this is a small mobile application it is
more of a demo application than real
application but maybe I should show that
live so let's see this is a application
for meter maids who are giving tickets
to you so our guys were questioning
whether this is a positive the more
example but I guess this is a typical
application very want to have offline
mode so I'll just click through the
different views so you can there is a
normal map view there is like list of
shifts who is working over there some
filtering for these interactive
statistics and and so forth all of these
views are built on the server side so
actually when i'm clicking something
over here this place goes to amazon
servers running somewhere and all of
this UI is built in java ticket view
though this is built off for offline use
so now when we have connection it's
connected all the time the disservice
our application if it would be dropping
connection let's take a look at that so
now we don't have connection anymore we
can still continue to use this UI
actually it should be detecting in a
while that we don't have a connection
anymore
I hope so it now detects that hey this
is in offline and we can still write a
ticket for for parking on a handicap
Sonnen maybe take a photo okay I don't
have a real camera over here but take a
photo on what else let's write real
ticket we probably need some wiggle ID
and that's it save it so now we have
said 11 ticket to the local store so the
use case would be that the meter
medicine in a parking garage and there
is no reception over there and she still
has to write this ticket so when tip
connection is back on if we get word
Lanigan when the connection is back on
we can try to reconnect and it says that
hey we have one unsynchronized item and
it sends that back to the server side
and put the application back to the
online mode so that kind of one way of
using an application where there is
client-side parts and server-side pots
so how is watering related google web
toolkit or you should call it goo it
nowadays not google web toolkit anymore
you terribly what just like few guys who
know about do it so one way to learn
about good would be to go wit project
org it's a really comprehensive site
about grid we basically collected all
the material around GUI to this one side
and also we are renting a good
conference this week on Thursday and
Friday over here in San Francisco so we
have something out of 210 guy sign up
for
or the conference so anything you want
to know about good that would be the
place to be so quick course to do it you
have three part in your application you
have your user interface written in Java
you have some widgets written in java
and and you have like based java classes
these red boxes comes with come with the
framework so there is implementation of
basic widgets and there is
implementation of basic java classes
these are put to Java to JavaScript
compiler and this compiles one version
for each browser basically try to kind
of work through the browser differences
instead of you trying to kind of figure
out how to go around member leaks in ie8
or something like that the compiler
tries to do that for you and it's pretty
amazing compiler another thing over
there is that it's really optimized
compiler so if you are looking at at the
good sides for using good for your web
applications I would say that the most
basic and most important thing would be
static typing if you are building a
large application you really don't you
really want to have the luxury of being
able to refactor your code and use all
the autocomplete sand and that kind of
stuff from from your IDE there is a
really nice automated way of building
communication over the wire called booth
or PC you can call the JavaScript
natively from your code so it really is
the in the red with other JavaScript
frameworks our existing JavaScript rain
works and then there is a really nice
kind of development and debugging mode
i'm going to be showing that a bit later
on but i would say that the most
interesting body in this framework is
that it's really really optimized so
Google guys have used tons of time in
making that the output of the from the
compiler super fast
and super scalable so you probably can
write much better JavaScript using
google web fluid compiler than write
JavaScript natively it makes so many
optimizations downsides are it's a
compiler and compilation is quite slow
sometimes for a large application it
might take like 10 minutes to compile
your application that's pretty
frustrating it's quite complex Beast
it's around 1 million code lines and it
has been really optimized for Google by
Google guys and they have not been
optimizing for for other rich enterprise
developer that much so adopting the
framework for for a over its enterprise
team might have some rough edges and the
widgets are not the best but there are
nice widget libraries around like sensor
dxd is quite nice widget library for for
a good so what is relationship to goo it
has been such that we have been using
google web toolkit as a rendering engine
involved in so basically boring as a
product has been depending on good
couple years ago google announced that
they they move the control over the
framework to a set of companies who
together stare the framework for words
that set of companies being Google's
themselves red-hot Valen senza and a
couple of others that are kind of
setting the direction folder for the
framework so what we did at the same
time was that we kind of took a full
copy of work if you will of google web
toolkit put that inside warren and of
course that being a fork what we tried
to do we try to push back all the fixes
old changes to the framework to the
mainline good that effectively makes
what in good compatible so if you have a
good application you could basically
test take that and replies with water
libraries and basically have the same
thing so no benefit over there but that
will
of open the gate for starting to also go
to the server side and building hybrid
solution so let's look take a look of
the architecture of point of view for
voting application you always have the
server-side user interface running on a
web server and some kind of back-end
server or you might be running these in
the same server as well or same jvm if
you will you are busy composing your UI
already made UI components that has
plain old java classes like buttons and
crease and so forth for each of these
classes you have a client-side
counterpart so for the service I button
you also have a button widget on the
client side and these two guys are
keeping themselves instinct so you don't
have to worry about the communication
between these two guys on the Boston
there is of course seeming interesting
thing is that you can also build you
eyes on the client side it put you you I
logic on the client side but if you are
building watching on the client side
that you need some kind of service to
fetch data from and then this glitter pc
comes back to the picture so that's the
architectural pod let me show like an
example application out of that so what
I wanted to do was basically build super
simple crud view for an address book and
to do that four times so do once on the
server side you I once on the client
side with good or PC once on the client
side with voting connectors that's kind
of the built-in mechanism involving for
for communication and then do one
offline mode but I failed I didn't have
time to do the offline mode but there
are other three parts all over there so
the back end is basically super simple I
could actually show that from from
eclipse it just to give you a big better
picture of it so
what we are having over there is
basically simple address poachers with
last name and first name and so forth so
this is just plain stupid bean and our
service is pretty simple we can get
adversary's store addresses delete
addresses so like really simple backend
for an address book okay so then I
implemented first two different versions
of the UI first with Warren and then
with practically google web toolkit so
let's try the application first and then
take a look of the implementation for
the server-side version and then compare
that to the client-side version so I
should be having actually be properly
should be running with this as well
so I basically put all these three
different approaches in one application
so this is the server-side version there
is just the table that basically lazy
load addresses from the server side I
can choose an address maybe to choose
one from the top I can edit it save it
and so forth send the client-side
version with the good air pc is
basically the same it actually going to
do the same back and so I have this fool
over here on and can edit that as well
and then I have the volume connector
that should be basically like pixel
identical to the previous one so let's
take a look of the server-side version
first services versus basically test one
class so this is one uicomponent made as
a composite basically putting one's of
your component on the screen these are
living in the discomposed component we
get started by building layout in this
case we just do them programmatically
instead of XML or anything like that we
can also use XML or compost visually but
here we just set component on the screen
and configure them somehow yep yeah sure
so we're here yeah basically I'm only
importing bought in UI components then
some data binding components from
boarding and navigation component at it
exactly that the code would be pretty
close to swing and the first thing was
going to set up the layout somehow then
we are connecting this to the back end
basically we are asking the service to
get addresses from the back end we are
adding these
on just basically being item contains a
wrapper around any any collection and we
are binding this directly to the data
grid on the screen so we have this
address list over here and we are
setting the data source for the address
list just take the the list from the
back end wrap that around with the beam
item container and bind this to date the
sorcerer ok then we were upped the
accent listeners for the edit button
what happens we when we click a button
and I guess the only thing to note over
here is that what we can do we can
because we are running this on the
server side we can do a direct call to
the backend and we can expect reliable
answer from the back end soon chronology
so we don't have to do any kind of
assume Chronos callbacks over here and
then we just modified the UI has as soon
as we wish these are pretty much the
same and I guess rest of it is not that
interesting so there is I just wanted to
kind of be following good you as UX
practices like hiding these components
over here until I click edit button and
then hiding this so like small finishing
touches on top of it the forum itself
over there it's just bunch of a UI
components that I have bound with with
my field group it's a mechanism
involving that allows you to take a
group of UI components and buying these
to accommodate the sauce and then you
have like transfer externality you can
commit and discard and buffer things
automatically and that's it so that's
that's the server side part or service
our implementation so if you take a look
of the clients at implementation the UI
is pretty much the same I didn't put
that many finishing touches so
over here so I'm not like hiding parts
of the UI as it was a pretty hard thing
to do with these UI components and the
layouts are not stretching properly but
it's from a function at the point of
view it's pretty much the same so let's
take a look of that version so it would
be good or PC example and their address
book editor so this is pretty much the
same as the server-side version so this
is also a composite component we are
using a bit different components these
are now from google web toolkit so these
are not boring component but google web
toolkit components so instead of having
a text field over there we are calling
that text box but pretty much the same
we are doing or imitating or UI in the
similar fashion it's building the layout
then a first differences start to happen
like when we are anything the address
list it takes up quite a bit more code
than this 34 line valen version because
that that's not like any any kind of
architectural difference this is more of
a question of the of the expressiveness
of those UI widgets so this sale table
is not having as many feature war in
table but in the end of the day they are
pretty much the same from the from the
kind of high level perspective then the
result one major difference is that when
we are wiring out these action handlers
over here for each action we actually
launched a synchronous action so when
when this button gets clicked we
actually create let's see over here an
assume Chronos call back to the server
so we are doing an 8x call and went to a
text call returns we either say that
hey we just failed to conduct the server
or we assume Colonel I synchronously
update something on the screen so we
instead of being able to synchronously
access something from the server we have
to do astronauts callbacks and the rest
is pretty much the same the service our
version was 190 lines and this is 270
lines but I didn't put all the finishing
touches over here so I guess it should
be more like 350 lines or so if I will
complete it fully so that's like the you
I thought but the thing is that we don't
we also read connection to the server
side and we somehow need to put this
thing on the on the screen so first of
all we on the server side we need some
page that Varrick I'll put this
component in this setting i'm calling it
a view and use avoided view class for it
it would be a pure boot application you
will put basically unsteady gait in my
page for initiating the application then
in in poor good application we you would
have an entry point java class that
basically creates this uicomponent so
that you actually have something on the
screen so you need like three different
pieces of over there the morning of the
server-side version being on the server
side it's already on debate so you don't
have to do anything extra to to show
that then you need service service here
would be defined as an interface
defining those what kind of services you
are publishing through web api and then
you have the implemented service of
course in this case it goes with servlet
and there is handy earpieces servlet
class in in google web toolkit that
helps you to implement and RPC service
then complicate the organic important
thing happens this service is
synchronous and because web is not
synchronous you have to kind of define a
synchronous version of your service as
well and after that goo it can generate
you a proxy class that implements this
internal service but as you see the
picture it it's quite a bit of in this
kind of middle communication layer there
is quite a bit of a part that you have
the built in order to build the same
thing so let's take a look of the from
the codes are how it looks like so first
of all we had this view that just puts
the component on the screen it's pretty
simple it's just put it on the under on
the screen then we have this connector
that basically initiates the component
it says good create and creates a new
widget so this some boilerplate code
more or less for the service the service
basically defines what kind of API calls
we are publishing the net and from which
URL you can find these so we just define
that header isn't this URL that you can
where you can go and then do a chest
cold and then you get get to call these
and the synchronous version of that is
basically exactly the same but instead
of having a return value for for a call
you are moving those to be awesome cross
callbacks okay and then the
implementation of the of the service
this is basically just a remote service
servlet where you implement your service
interface and force for its call it
basically somehow translate that that to
a call to back-end so it's really
straight for
but for getting addresses you just get
the back and get the address it from
their son somehow wrap this around with
some transfer objects and send these
back or return these over here and then
the google web toolkit remote server
service servlet takes over the control
line and she realizes these and since
these over the wire and that's basically
it so that's the good RPC was not the
same thing so if you are kind of
estimating the complexity over here in
the client-side version we have four
classes two interfaces around 500 lines
of code and server-side version 190
lines of code one class it gives you
something like 3x complexity in this
example and it's actually I think that
the same kind of multiplier applies for
like real application as well because
you have the true do more layer or some
more boilerplate code when you're coding
on the client side and this is not just
about Google web toolkit also about any
kind of client-side implementation what
in any kind of framework you are using
on the client side you have to do those
layers we also have in involving a
communication mechanism of its own this
is mostly designed for server-side
framework for for the guys who are
implementing new widget for the
framework but it's pretty unique so I
think I could show it to you so
basically on the server side you have to
have some kind of combo let's say button
component on the clients that you have
the same button widget this button which
that is basically Google app to get
widget on the client side add to connect
these two guys together you put the
connector class in between this
connector class is basically responsible
for moving client user events from the
client side the server side
sending data back from the from the
server to the to the clients I like
setting the pie dough for the gap for
the button so we have to weigh RPC
mechanism over there for doing
traditional stuff sending stuff from the
server side to client side or clients
out the server side but we also have
state objects and these are pretty
interesting make mechanism so this is
any kind of plain Java object that you
are updating from the server side it's
shared between client on the server side
so any changes you make to State on the
server side automatically gets sent to
the client side and the client gets
notified you don't have to do any extra
over there you just set the state
somehow and that way it gives you a
really powerful way of pushing data from
the server to the client side and most
of the time you are just doing callbacks
for user events over the air pc from
client to the server side so those
callbacks would look like this you just
define an LPC interface it's pretty much
the same as in Google GWT RPC with one
difference there is no return value this
is like one way communications and
because of that you don't have to define
a synchronous interfaces so on the
client side you basically asked wanting
to create the proxy glass out of this
interface and you start to use it you
just call it body implements that they
interface that you have designed the
designed automatically and on the server
side you implement a in the face and do
something when this call is is received
so the same picture again so now there
is on the right side it's exactly the
same picture as you saw already on the
client on the left side it's basically
the same thing implemented with the war
in communication mechanism so instead of
having
assume crows call box over here what we
are doing is that we are basically
sending the address list over the state
and then we are sending RPC calls to two
directions pretty much the same
complexity in both cases but there is
one kind of extra benefit for for doing
it in this type of way if you are doing
it like that what you get for free is
push so involved in we have implemented
a pretty powerful push mechanism that
support WebSocket supports HTTP
streaming supports polling and it
automatically detects what you brought
what your browser can do and and start
using those mechanism so if you are
using what in connectors or if you are
doing what server side you is you
basically get pushed for free so let me
show that to you how you could basically
implant push basically implement web
sockets for your application I take the
UI part over here and what I do is right
at push over there save and reload and
now it's running over WebSockets so it's
pretty simple to start using server push
and and this is basically needed or at
least this one way air pc interfaces are
needed because we really want to sorry
really want to be able to from the
server side called the back to the
client side we basically want to push
stuff from the server side reply inside
so it cannot be test callbacks
actually I could even prove this one
let's see I'll put it in the debug mode
involve you get this going to debug
window and if you look at the
communication over here it says that
it's it's using WebSockets if I would be
using ie8 for the same application it
should probably be using HTTP streaming
so it kind of no sponsor servers and
tries to figure out how to work around
any limitations limitations on those
servers to enable web sockets
ok that the next thing would be offline
unfortunate i don't have implementation
for offline in this example yet but even
so I wanted to kind of least what kind
of things you would need to be able to
write offline mode so first of all you
have to be writing things on the client
side if you're writing thing of the
server side you cannot connect to server
anyways so we could use the client-side
version as a basis for for offline view
we need some kind of way to detect
offline in the XML obligation that I've
shown it was using product code called
war in parts kit that provides a bunch
of UI components for mobile applications
and it has built-in offline detection if
you are not using that they should build
off line detection somehow and some kind
of offline bootstrapping god what we are
how we actually are starting up our
offline application basically
calculating cache manifest files and
doing some kind of bootstrapping HTML
code for offline application we probably
need somewhere local storage as well if
you want to show some data on the screen
some kind of way ready to synchronize
this data store it with the server side
this is really application specific so i
would claim that that frameworks while
they can make it a bit easier if they
really can solve this problem yes so low
caste or 18 as in html5 spec teresa
longer storage and so in this parking
application what happened was when i was
writing a ticket it saved the ticket the
browser local storage database when we
went online it compared client and
server databases and synchronized to
chases from the client side the servers
and that was totally customized logic
and it's it really needed if you want to
build an offline mode and if you have
having a lot of date on the service are
you probably want don't want to copy all
of that data to the client side so to
you have the short the data somehow but
i would say the end outcome is that you
how to build quite a pile of stuff on
top of the client-side version my gut
feeling is that it should be at least
twice the complexity of building the
client-side version so if they are
having around 500 lines of code for this
client side version my guess is that it
would be at least thousand lines for
offline version of this chronic you I it
isn't that's the point so I'll get back
to that in a sec so if they are if we
would believe that that the offline mode
will be twice the complexity of the of
the client-side mode or client side view
and we know or have measured in this
case that the client side would be three
times the complexity of the server side
view that we can lead that the offline
mode would be or offline view would be
at least 5 times 6 times the complexity
of the server side view and that is
basically the key so if you are building
a replication in such way that we are
using server side views for most of the
application and only using offline views
when we really really really want to
have those of line features then they
could basically combine the benefit the
deposit doesn't have to be offline can
benefit out of this really productive
programming model of the server side and
they still can have those paths that we
really need on the offline mode for the
for the application and a combined these
in one package so if you go back to the
chorus and think that this would be the
the application frameworks clearly this
this traditional mersin depends it would
be that client-side framework where you
have three different layers you have
full control over everything so it's
pretty good on that respect and it will
be offline ready right out of the box
because you have clients and application
you
only have to be building this offline
storage and super notation on top of
that but the downside is that you have
to build these three layers so it's
pretty expensive to drive or build on
the other hand the set beside you is
they are basically only one layer so
they are pretty cheap to drive or build
but they are limited in a way that you
can drive goes to coast being offline on
the way so in a way you have to have a
server connection you have to have this
data grid of beta grid sorry the power
grid for such a car but if you come by
these two part in one car or application
you can choose which views are you're
going to be implementing in three layers
which views you are going to be
implementing in in one layer and that
way I would claim that you would save a
lot of work if you can implement most of
the application on the server side and
only put this five times effort in the
views that really need to be offline
offline was test an example over there
you could also any any of the reasons
for being on the client side would have
the same trick so basically if you need
a low latency for one view it doesn't
make sense to build whole application on
the client side if you don't need that
Lolita C for these views ok how much
time do we have do you want to have like
quick intro dividing as well or it's up
to you guys silence
so just got a quick pointers about
voting today we are in 7.1 version so
this is not the new framework we
actually started in year two thousand
already build this framework and release
the first version in 2002 so it's as a
bit of history behind it while you eat
the optimization target for goo it is
clearly scalability and being as
efficient as possible for us the
optimization target is combining rich
user experience we develop a
Productivity I'll show you a bit of demo
so how many you have seen one in sampler
for guys so this is maybe I just put it
like full screen
oops
so this is a way of kind of seeing what
kind of features are involved in you can
basically go through different UI
components let's take any example from
here like date picker you can try it out
see how it works and then you can take a
look of the how its implemented or
should be why don't these are all free
component that the whole framework is
free and apache licensed so you could
take a look of the source code how this
example was implemented so you are kind
of learning out of the examples you can
try to conjure that example somehow
let's say let's say some other local
over there run you can enable and
disable features and then you can go
from component to component to see how
this work and there are quite a few
components over there so I don't go
through these but it there is also like
other type of samples like let's say the
air pc mechanism that they took a look
of you can see how it works here is the
clients at widget to do list widget and
the server's IP for it and we can try
out how how we are going to modify or
sending over THX goes all over the wire
so you can actually use or inspect the
dome and see how how things work on it
the hood as well what else I could show
you of course of course in eater I
wanted to have a bit non-traditional UI
for it because it is mostly used for
demo learning purposes so you can have a
bit of play more play for you I for it
and then people have been
this is really hard to navigate so and
then nobody is normally going to finding
this site map from here so we have to
probably figure out some some other kind
of you I but I just want to have like
PlayStation but you I for for this one I
glow social be more real-world looking
at sample application so this is an
application that is more like typical
avoiding application you are putting
tons of component on the screen having
like lot of data things like lazy
loading crew million lives of data is
fully automated you just create a new
data Creed and connected data source you
can also hear everything you are seeing
on the screen is free yes clearly
doubting me yeah we have let me show you
so basically we have three commercial
components at the moment charting
libraries is commercial bar in cots get
this mobile UI library it is commercial
and and then they have test records and
testing tool based on selling for
recording UI tests that is commercial
but we they have been really striking in
in having most of it fully free and
apache license no no everything is
web-based html5 yeah so let me show you
an example all of that so let's take oh
this is so can i zoom it a bit
nope
so how do a resume but so wrongly these
you is is built with violent arch kid so
what it gives you is like native looking
uicomponent helpers for building offline
or detecting offline and components that
like are optimized for mobile devices
taking using Hardware x-rays or duration
where possible and that kind of stuff
that said all of the voting applications
that you build with free very framework
to work and mobile as well so it it's
not necessary to have these components
for for building mobile applications
these are just a bit like ektron on top
of the cake not at the moment so this is
mostly optimized for based on
applications and it seems that the html5
is powerful for enough for further based
on applications just to kind of write
you can wrap volume applications with
phonegap if you want to let's say scan a
barcode and want to have the scanning
done real time so so it is possible to
do but it's of course adds complexity
for your obligation let's see ya here
exactly the same application run on ipad
so basically the same application runs
as is on or mobile device as well of
course if i would be running this on
iphone the experience would be pretty
pretty bad because of the screen size it
is this is not designed for for iphone
screen but it's up to you how you are
designing your application and there are
responsive features involved as well so
that you can stretch the layout and and
fifty
is in the in the screen so actually may
be a good show this in practice so let's
see it sparking them are you so already
on mobile but if I'm using that on a
normal web browser it basically has two
columns over here if I make it a bit
narrower than your it kind of switching
the one column and so forth but it's up
to you to define how the layout should
behave all of these are in memory or are
in yeah they are basically github and if
you go dividing that comes last tutorial
there are links for this as well so one
of the I guess the most probable things
in what is that there is a huge
community around it and these guys have
been building a lot of UI components so
nowadays there are 400 add-ons
forwarding for example how you are using
these these atoms let's take a paper
stack around that is pretty useless
layout basically puts your components on
top of each other on a sticky notes so
you basically could put components it
over there and then kind of wipe debate
is between those components it gives you
like exit code example how to use it and
after that you can just cut and paste
the poem definition to your project or
just drag and drop the component to your
project maybe I'll give super quick code
them as well because I guess that one of
the great things is the development
cycle so just going to show that if I'm
creating a new project and let's see our
new protease over there
and start it on my web server like this
and let's see what was the name of the
project / host
so now I have this application running
over here and and and first thing that
we we know this is that because this is
real job on the server side what we can
do is that we can put breakpoints in my
code and we don't clicking something
over here like this it actually stops
the breakpoint and I can inspect what's
happening over there so you have like
the full Java tooling available for you
another thing is that you can modify the
code so let's see now I'm kind of saying
thank you for clicking so let's see
thank you it's a jerk save and continue
clicking over there and it automatically
updates so the kind of cycle for
developing is pretty fast you can kind
of go back and forth between the codon
and web browser easily and as you
already saw the components are pretty
powerful so let's create a super quick
demo file because we on the server side
we can do crazy stuff like like access
file system let's see I have some some
files on my temp directory
so now I'm accessing these files from a
directory and then I can just put these
on the screens let's say layout odd
component new table component and table
camera could say like like ducks and I
tests showed the dogs from my file
system so two lines of code actually
this is an example I had never tried out
you'll see if it works so now no I'm
listing documents right directly out of
my file system so these components are
pretty powerful and you can kind of
start building your application like
piece by piece and seeing changes on the
screen immediately but I guess we are
running out of time so let's not code
anything extra for for now I just
mention a couple of things that we are
have lately added to voting so one of
the things is that there is sauce
compiler I don't know who knows sauce
kookai so this is a really awesome way
of structuring your CSS and then we did
craziest thing we wanted to have like
notation on top of CSS took the i would
say top one project for that over there
in the world God sauce and instead of
using their comp battery we implemented
a compiler in Java because we wanted to
have that in the product packets so
there is a sauce come pouring in there
you can build adults with JavaScript as
well so obviously you can do that in
Java with google web toolkit but you can
also use JavaScript language nowadays
involving there are several push
mechanism and now we are working on a
really nice great component that is
going to be out in part the one that
I would clay mr. like best data grid in
the world but we'll see in in one
quarter a quarter one yeah there is a
like early preview version downloadable
today but it's not usable yet so how do
you get started basically there is
tutorials on the web we have plugins for
all major IDs so for eclipse you go to
the marketplace for ID idea its built-in
for netbeans there it's on the NetBeans
plug in central or plug-in portal there
is maven archetypes but I would say that
the best way to get stories book of
boring this is a 700-page book basically
documenting everything avoiding and you
can download for free from wad com or if
you are seeing our croon on some
conference we probably are giving out of
hard hard copies of the book as well so
but that tend to be most of the time
outdated because after you print it it's
going to be outdated in two weeks anyway
so and the whole framework is appetizing
than free for any kind of applications
and there are quite a bit of community
we don't know exact number how many
developers we have in the community we
are seeing a 150,000 unique visitors
each month on the developer portal so
that's one indication of the community
sighs yeah that's it any questions yeah
I guess so we can use you can use any
java computable server or portal and I
have seen people do pretty crazy stuff
like packaging bought in to be run on
Android device natively basically
running a teddy bear surgery on the
Android directly so that's possible I've
also seen in the past some products that
have been packaging body knows as a
desktop application but I don't know
whether that's a good approach so most
of the world is going to web anyway so
but basically any kind of Java
compatible server will do that can so
servlets anything else ok thank you guys
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>