<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Microservices: Patterns and Practices Panel | Coder Coacher - Coaching Coders</title><meta content="Microservices: Patterns and Practices Panel - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Microservices: Patterns and Practices Panel</b></h2><h5 class="post__date">2018-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V326FFuSEZw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome back to the micro-services
patterns and practices track so we have
all of the speakers save one but that's
cool to talk about yeah here you go yeah
come on up we have all the speakers this
is great
awesome all five of us yeah so very
informal like I didn't you know
correctly this is you know what you want
to hear from us so I think we're gonna
try to figure out a way to have a mic
for you and a mic for us awesome we have
to I can be a runner around or of things
and maybe I'll ask for another person to
volunteer to help me with that actually
I'll do I'll keep this one great cool
fire away
how do you manage your data when you
when you're doing green flickering
deployment so for instance you might
have a version that writes new records
in that the old version doesn't
understand and how does the old version
know it's not an error it's actually
it's actual real data okay do you guys
have it I actually have an answer for
that but why don't you guys take a stab
at it first the red/black deployments at
Netflix whenever there are data changes
like when you have microservice changes
you can do the red/black deployment it's
stateless it's not a problem
but when you have Micro data changes
especially for Cassandra right Cassandra
is schema-less
so even if you are adding a new column
or changing schema you don't necessarily
need to do TDL to change the schema you
can directly keep inserting into the new
data set with the new column family new
new column so that's that's one way the
other way is also we help build like if
they have to do migration from one
column family to another we helped them
build tools like we own the client
libraries so it's easy for our
application users to do dual writes that
writing to the old as well as the new
and we provide tools like fork lifter
which can lift the data from one source
to the destination but not all red-black
deploy
need changes where we are moving data
around at least that's what Netflix has
yeah I mean I would just add I mean I
think sort of zero downtime deployments
constrain the types of changes that you
can make at the database level so you
could add like a nullable column for
instance but you can't just drop a
column so it's sort of yeah carefully
make changes and and decoupled database
schema changes from from like your zero
downtime deployments yeah so don't do
what you just said I mean I'm not even
kidding what you did I mean I'm you know
what you did was you broke the interface
you made it you made a data to you made
a non backward-compatible data change
and you exposed it to other people so
and you did it in a way in like
in-between a minor you know release so
if people are familiar with semantic
versioning what you just described was a
non backward-compatible major version
change does it make sense what I'm
saying we used to produce data in this
form now we produce it in this non
backward-compatible other form so don't
do that what you can do is what Chris
said which is depending and we can talk
in detail about the particular change
you wanted to make there are lots of
ways to make backward compatible changes
again add a add an optional field I mean
we need to talk about it in a little bit
more detail sadly but yeah so the idea
is that you you know as a service owner
your primary job is never to break your
the other people that use your service
so you're never allowed to break clients
you're never allowed to pretend which
clients are like consumers of your
events I think that's a good I mean
there's lots of detail behind that
answer but Italy conceptually does it
make sense yeah cool
all right way in the back actually I'm
gonna go here first I'm gonna get to you
next so one of the things that we have
found hard is deciding boundary context
from microservices it could be as easy
as like okay we are having orders but
then
could be five types of orders and now we
know micro-service is a monolith after a
while how do you decide boundary context
so that it's good enough after a couple
years I mean mostly is probably gonna be
informed by your development practice
and your development divisions right
rather than any strict semantic thing
you try to guess from the get-go
right I mean I tend to think of
microservices as emergent patterns that
come out of the need for decoupling you
know I I don't have a micro service
caliper on me it's so it's you know it
takes effort but usually you know the
decoupling works at development team
boundaries pretty well or or at
functional responsibilities within
development teams and you know that's
where I would start yeah I would sort of
say that this is one of the hardest
problems bait I mean and it's really not
specific to micro services you know this
is basically another way of rephrasing
it it's like what what are the
boundaries of my module right and I
think picking module boundaries is is
difficult and and unfortunately there's
no sort of kind of mechanical process
that if you apply it you will come up
with a perfect kind of set of module you
know module boundaries so like in the
case of services it's like yeah most of
them are organized around particular
business objects right like order
management and customer management and
so on but you I mean that's kind of your
first guess and you go with that and if
later on you find out that some service
has got too big then hopefully at that
point there is some clear enough
boundary between the two internal parts
of that module so that you can split it
in a meaningful way and then just to
sort of echo echo what Lewis said I mean
basically to me ace you know the point
of a service is to enable a small team
of developers to deliver rapidly and
safely and
so it's like of a module you know the
service gets too big that really means
the team that's developing it has got
too big and they're weighed down by
communication overhead and so you kind
of want to split the team and you want
to split the code so they can go back to
being a small nimble team again I have
one more thought and then I'm gonna go
to the back to the guy who had that
other question so one of the things that
I assert because I believe it is
probably if you are you know the five
person startup you might not want to
start with micro services part of the
why is that it's still a little bit
complicated maybe a lot complicated to
build a distributed system and there are
a lot I mean everybody's questions here
are around lots of different things that
are complicated and probably when you're
small you want to think about doing
something different but another part of
it is you really have to understand your
domain and be able to decompose it in a
reasonable way before you do micro
services does it make sense because like
micro services are just a sort of
physical manifestation of a you know
decomposition of your domain and so I
have found because I have tried and
failed to do this many times my first
cut at a new problem and you know
defining what I think the decomposition
of the domain is like I mess it up all
the time and I have like gray hair no
hair like I've been doing this for a
while so so yeah there so there are I
like to say there are two rare
exceptions to the rule of maybe don't
start with micro services when you're a
tiny the first is if you're if your MVP
if you're like most our minimal valuable
product requires scale so if you're
building the Heroku competitor for
example like you're building Internet
infrastructure you better scale from the
beginning like that is a requirement but
the other is if you already know your
domain super well so the examples there
and I can think of one great example is
like people building new banks right so
new bank from Brazil who gave the first
talk yesterday and the architectures
you've always wondered about track they
are starting with micro services why
because the decomposition of the banking
domain we have known for 50 years and
there are a bunch of other
similar people in London I always forget
the name of the company but they start
with Microsoft's because the components
that are involved in a bank are really
well understood but for the 99% case of
the rest of us we don't know our domain
well enough and that's why this is such
an important problem we know that we are
a monolithic application and we know
that we want to get to business context
types of services but where does that
line drawn is it a product level of API
level micro service level where is that
line is it just what feels right so yeah
that's a that is a hard question but I
think one of the ways to sort of help
think about it is actually something
Randy said earlier right which is don't
think about the size of a micro service
in terms of its lines of code think
about the scope and how do you define
scope well you need to understand what
it is you're trying to achieve at a high
level you know one or two sentences and
so I always like to think about and you
know this actually goes the question
before around how do you know if if an
API is done right it's really a
negotiation between the user of a
service and the team that delivers that
service right you need to track the
usage if if your users are happy then
you're done and and well yeah assuming
you don't have to change it every every
five minutes right and so yeah and so it
it really helps to think in terms of
that framing understanding who the user
of the service is and and and going from
there and from from that perspective you
can like just try a lot of different
kinds of AP is that will that will sort
of serve the same mission
and figure out what you need and again
track use you know track how successful
you're making your users in order to
measure your progress as you sort of
iterate through the difficult design
space so that's what I would say so this
is a little bit of a flip response but I
don't mean in any aggressive way do you
guys know in your you guys build one
class like one like language class in
Java or whatever no right how do you
figure out how to build and what the
scope of the individual classes are this
is rhetorical because like like that's a
design thing like okay the class is a
single responsibility you know we try to
make the interface relatively minimal we
try not to be too chatty so the reason
why I asked it in that way is not to put
you on the spot in any way but I've had
this Congress that people again that
work for me are totally laughing right
now because this is a come this is a
thing that I've done many times with my
team where we I mean this is a legit
thing to say mam microservices like
we've never built services before have
you built classes have you built like
interfaces like within the particular
you know language environment that you
are oh yeah we've totally done that how
do you figure out what goes in and out
they're like oh that's so two per simple
like we've been able to do that and we
refine it over time that is the answer
does it make sense like you know way
more than you think about how to design
services if you design if you know how
to design classes for the most part you
know how to design services the only
difference is recognizing that you can't
be as chatty with services as you can be
with something that's in process in your
in your well in your process does that
make sense but other than that you
already know I mean you already know if
you know how to build applications which
you totally do by who was on your on
your badge you already know a lot more
than you think you do about building
services yeah I mean sort of
decomposition applies at many levels
right like you you know in a sense you
decompose methods you decompose classes
packages modules and then and so sort of
Micra services is just yet another level
in that kind of hierarchy um one comment
I would add though is that I mean
I think sort of microservices tie kind
of have this important relationship with
team structure as well like for me I'm
you know the kind of well this I think
there's two models for micro-services
there's like the super fine-grained
model which seems to be like one service
per developer which seems to be
happening at some companies right well
when you have like thousands of services
I mean that's sort of that order of
magnitude whereas another way of
thinking about services is that a small
enough quote application that a team can
remain nimble and agile right and that's
sort of another that's kind of a much
kind of a coarser grain model of micro
services and so that kind of impacts
decomposition so yeah I mean it I think
it's probably a common problem for a lot
of people in the room that they have a a
a monolith yak that they want to shave
you know that's totally fine
like like start shaving where you think
shaving adds value right and stop
shaving when you aren't getting any more
value right it's okay to have a monolith
if it's doing what it's supposed to do I
know that might be heresy here but right
I mean if it's doing what it's supposed
to do if it's not shave it right and
there's you know iterate sorry cuz this
was an excellent question at the break I
will shut up after this the excellent
question was more or less hey our micro
services worth it and answer for most of
us maybe not right it's total I mean
again as I tried to say in my talk like
it's the 0.1% 0.01% that get to really
large where you absolutely I think
there's no way Google Amazon Netflix
stitch fix works at you know works
without some flavor of thing we'll call
micro services but much smaller
organisations if you don't have a huge
team if you don't have a huge load like
it's totally legitimate to stick with a
monolith like there's nothing wrong with
that the question has to be like when
should I move to micro services I don't
know when should you like when
are you reaching the point when your
development velocity slows down where
you're unable to scale things
independently where you know you're
unable to have different parts of the
system of all the different rates like
that's the time where you like that's
the wall that you have to like scale
with micro-services but if you're I mean
if you're happy I'm happy let's say it
that way and I want to add to that like
you know if your development velocity is
not where it needs to be I would
actually start to review your
development practices before switching
the micro-services so for instance if
you're not doing automated testing
thoroughly right and and I think
probably 70 plus percent of
organizations according to I think it
was a source lab report and not have not
like completely embraced automated
testing and and so if you're one of
those work on that first and then you
know once you've got the hang of that
and you you really are able to automate
as much as possible then think about the
micro service architecture you know it's
kind of like try running or walking
before you before you run yeah that's a
great point excuse me that's a great
point and a great thing to do is just it
doesn't need to be super heavyweight
who's just track where you spend your
time right if you're doing if you're
doing lots of manual testing and that's
slowing you down
you don't necessarily sort of think
about that on a day to day basis and you
know if you're if you're spending a lot
of time wrestling with particular areas
of your monolith you know maybe that's
the time you should start shaving that
particular patch of yak
so I think you know Randy gave a couple
examples of why you might want to do
that scale being kind of one of the more
obvious ones that's quoted in the
industry I think there are other reasons
right security it's mainly a big reason
why you might want to shave your
monolith because you have two things
that shouldn't be stuck together into
the same trust domain that's a really
big reason the development experience is
is clearly one right I mean release
velocity is a big deal so there's a
variety of reasons out there then you
know you guys know your domain you know
what's going on in your domain you
should be able to reason about those
reasons to make these types of decisions
yeah it's interesting and from my
perspective I think you know micro
services are primarily a way to tackle
complexity rather than scale scaling I
mean obviously it is a way to scale but
complexity is first yeah the question
are long the can you guys maybe comment
on what some of the patterns are that
teams are using to get to micro services
do I start in the middle where it's like
you know it really matters and it's a
it's an important object or to do it do
I do it on the side where it really
doesn't make a big difference and can I
just slap like you know a REST API on an
existing app and call it a micro service
sure well you know if you if you're you
know yearly bonus depends on having a
micro service
[Laughter]
but oh I was just gonna make a joke but
no I mean might you know microserver you
know this I I this term micro service
really does get heavily abused right
like this notion can I can we use a
micro service for that is sort of just
kind of the wrong notion I mean from my
perspective you know that you know
microservice or micro service is a
shorthand for the micro service
architecture which is an architectural
style for an application so it's all
about having a system but I mean one one
one way that one thing to think about is
if Mac so you've got this massive
monolith right and if there's one part
of it that's like under very very active
development and in other parts that are
like you never touch then if you want to
extract them out you know if you want to
build a micro service or a service then
then you know extract out the parts of
your application that are frequently
changing because that will give you the
sort of biggest bang for the buck you
know if you think about your monolith
that's on the slow track of development
and then anything you've extracted out
as a micro service is on the fast track
you know rapid deploys and and and all
of that so you want to you know invest
the effort in those areas that really
really make a difference so as always I
have thoughts so here are my thoughts
the step so we're gonna make some
architectural change from a monolith to
microservices so first we need to prove
to ourselves that this fancy you know
millennial way of doing micro services
is actually a thing actually going to
work in our environment right so the
step zero is to do a pilot and the way I
like to think about that is let's take a
vertical end-to-end like actual
experience that matters to our business
like I don't know what your business is
but like let's imagine you have users
and you know something that actually
matters to users and build that in the
new way
so it could legitimately legitimately be
some new thing that you're gonna build
in a new way or you're gonna rebuild a
thing that already exists in the new way
either way take something that is a
vertical end-to-end thing and build it
in the new way why for several reasons
first we're doing the pilot because we
want to de-risk it and we want to learn
all the things we don't yet know about
this new micro service thing right so
we're doing it as a pilot rather than
starting with you know rebuilding the
entire infrastructure we do a vertical
end-to-end user experience because we
actually want to be able to be focused
on some particular thing and that tells
us what we need to do and what we don't
need to do does it make sense like if we
choose something that doesn't matter
like well we don't know what's in or out
does it make sense like if we choose
something that's actually useful then
that will help us to focus on what is
the minimal thing that we need to do to
get our job done and the other reason
why we choose something useful is if
this doesn't work at the loop at the
worst we've provided some value to our
customers does that make sense so that's
the step zero that pilot now that we now
that that pilot is successful and we
have learned all these things about how
to do things in a new way let's call it
micro services now the steps one through
n are take the take the things that are
actually that have the highest return on
investment not the easiest things not
necessarily the hardest things but the
things that have the highest return on
investment and we convert those to the
new way first so this is a bit I'm in
sort of a trending like over you know
like consume or like over arch all the
things all the comments that people have
been making so like think about the
areas that are really fast changing
maybe that's the area that has the
highest ROI or maybe it's the part of
your site that that has the highest
revenue for example like that might be
an area where it would be really
valuable to have that be able to move
faster because maybe we can make more
revenue does that make sense
so you start it's you've done the pilot
so you've de-risked it and now the step
one is have the thing that has the
highest return on investment then you do
the second highest then you do the third
highest and you keep going until you run
out of patience or you run out of
resources to put against this tree
architecture and the reason why you've
done it in that order is if you run out
before you're done
that's cool because the rivers the
residual monolith that still exists is
something that you don't care too much
about does it make sense like it doesn't
have there wasn't the ROI it didn't kind
of go above the bar of what it would
take for us to you know get motivated to
convert it to micro services and that's
exactly what they did
so when eBay was can that people who
were here or have heard me talk before I
talk about like eBay had this monster
C++ monolith and then they broke it up
into mini applications written in Java
and the way they approached that ryoga
tech chure so it wasn't micro services
but the principle is the same they once
they did a pilot and convince themselves
that Java could work in the eBay
infrastructure and you know with eBay
skillset and people and all that kind of
stuff then they basically reverse sorted
the site by like which page it like the
site they took the pages on the site and
reversed sort of them by revenue
contribution so the top revenue
contributing page they actually
converted that first not because they
desperately wanted to like have the
greatest risk but because if and when
they ran out of like patience money
resources whatever they at least would
have done that most valuable thing first
does it make sense and by the time even
by the time I left there in 2011 they
had started the Ryoka tech chure and
like I don't know 2000 or 2002 or
something about a wit and they had
mostly finished it by I want to say 2007
maybe 2006 took him a while but even at
the time I left as far as I know in 2011
there were still things that were on
that v2 like C++ monolith architecture
but there were things that like nobody
used they were super simple they didn't
change right so like there was no ROI to
convert it to the new way there you go
my question is about the the inner
communication between micro services so
we do talk about having events so
service a would talk to service B I'm
here by doing so yeah so so what if for
say a business critical services like
say a credit card processing right and
say
we see a lot of patterns by say Kafka or
other brokers that hey once I received
the once the message is in the broker
then there are ways to you know recover
or you know like retry but what's the
recommendation to ensure that hey the
credit processing service does issue at
the event I see for example Kafka has
now kefka connect which assume that hey
with every DB commit or every DB
transaction it could publish straight to
Kafka but what if your business object
is not the same as what you have in your
DB so I just wanted to get your ideas
here services owning the source of truth
so each application service is the
source of truth for the data it's
serving right so for example for payment
processing in a Netflix's case I don't
think they use Kafka for that event
think they have different data store
especially primarily they are using
transactional data store for that
payment processing but basically the
idea is each service is owning the piece
of data it's it's responsible for and is
the source of truth for that right so
and that's how the interactions happen
like other services will ask the service
instead of directly either copying the
data set or having multiple copies in in
their back end I mean I think there's
several parts to it so one is atomically
publishing a message when the data
changes so essentially kind of like the
kind of conceptually there's a
transaction involving updating the
database and publishing a message and so
one of the things I'm going to cover in
my talk which is next though apparently
the track host is not going to be there
because he's giving a different talk so
anyway yeah so there's this whole thing
around transactional what I call
transactional messaging which is a way
to which is kind of a super interesting
topic and
so it ends up reliably being published
to the message broker so that's you know
step one and then step two your message
broker obviously has to be reliable so
that's what Randi was talking about with
at least once delivery and though then
yeah then that the risk consumer end you
need item potent event or message
handling to ensure the correct semantics
and that that might just involve keeping
literally keeping track of all of the
message IDs that you've seen recently
yeah it's a whole complex topic which
some of which I'm going to talk about
later this afternoon some of which I
cover in my book microservice patterns
shameless plug I just wanted add a
thought just to reference back to the
you know it it's like designing classes
I think this area of ownership is a
ownership and the whole area of
communication right where this whole
event thing and that's where transfer
you're transferring responsibility for
ownership of some data and that's where
this where micro services get the most
different from designing classes or one
of the areas where they get the most
different from designing sort of
traditional class api's because you
don't have to worry about you don't have
this same sort of locality of data in
the context of a you know a class
hierarchy so it's just something to keep
an eye out for just a follow-up question
I guess a bit of a dovetail on the last
one related to the event-driven
architecture can you share your thoughts
from the panel on the use of either pass
by value pass by reference on those
messages and how the consumers work with
that message and maybe your thoughts on
how how to handle ordering of those
Oh III can give my opinion which might
also be slightly heretical here but this
might be influenced by Google's scale we
mostly don't do it most service to
service communication is not reconciled
through a broker right we we use things
like retries and network level things to
get scale by not hitting storage you
know it so again this is one of those
scale questions right if persistent
queues and storage gives you reliability
that you need at your application level
at scale then you should use it but I
think at certain scales some of those
patterns might become a bit more
limiting particularly depending on the
amount of work waiting for that right so
that it's it's not that we're anti that
pattern per se we do use that pattern
and you know in particular we make sure
we use that pattern encapsulated behind
an API with a known like a clear
segmentation of responsibility but for
the most part we don't do it we don't do
rendevouz we don't do that type of thing
I can't believe you don't use Kafka we
have things that look like it yeah no I
mean yeah no that was a joke but after
the Kafka seems fashionable so right
here rightly or wrongly so for me like
so when you when we've been talking
about event in my brain what I've
translated that into is domain events
which are a concept from domain driven
design so if you go read one of the DDD
books you know they they've you know
like implementing DDD by Bourne Vernon
or Vernon born you know that actually
has a whole chapter I think it is on
domain events and and so and you know
and in terms of how much data you have
in you should include in an event you
have a choice right like if an order is
created you could just Inc publish the
order ID but that's not much used to a
consumer because they would then have to
go get that order and so in general
there's this concept of event enrichment
that says put useful
data that will be typically useful to a
consumer in in the event and for me yeah
like when you publish in an order
created event just stuff the order
details in there and then of course if
you're using event sourcing where events
are your storage mechanism for your
domain objects you have no choice except
to put the necessary data in that and
then no your other point was ordering
yes and I think ordered at least once
delivery of domain events is really
really important because you know if
they arrive out of order then you're
gonna have pretty weird behavior I mean
there might be other situations where
you don't care about delivery and you
can just pub/sub an event but or
ordering is usually quite important you
have you ask the question which is how
do I deal with event delivery where I
might get the thing multiple times and
how do I deal with event ordering so
both of those problems obviously you
don't have when you're in process and
when you are you know doing messaging
across a distributed system like you
have those problems and yeah I mean I
think we've all given parts of the
answer I guess I would say I mean I keep
threatening to do this event masterclass
because like these questions like every
single time we give this you know I talk
about this stuff you should do it at
least once there you go
well played well played
so yeah let's see again so on delivery
you can have at most once or at least
once if you care about your event you
want at least once right so that is on
failure I deliver it two times three
times n times most once is basically for
logging data things that on fail you you
want to drop so that's like it happens
either a one time or zero time so unfair
you drop it again that's not that's not
domain events do not fall in that
category typically but you know logging
things are yeah so that's the first
thing and then obviously you get the
same multiple times so now you have to
be idempotent in other words the
consumer has to be able to correctly
process the same event potentially
multiple times lots of techniques there
CRD T's or
thing you should look into if if you are
kept up at night by these kinds of
problems conflict conflict-free
replicated data types and then in terms
of event ordering a one of several ways
to deal with it so you can either try to
deal with event ordering in the bus yeah
that's not so great another way to deal
with it is to have events be the
notification of a thing happening and
then you go and read back to the service
that produced the event for the current
state of things that these are all legit
ways of handling the problem and think
about this these answers as less there's
one there's like Randy's way to do it
versus Chris's way to do it versus
Louis's there's like there is a space of
possible solutions to this problem and
what you really should take away from it
is don't try to solve this yourself by
reasoning from first principles because
I have tried that many times like oh
this looks easy like no it's super is
not actually but lots of good people
have done lots of thinking about this
for decades so I guess I would just
suggest going into oh one more thing
Martin Fowler of refactoring Fame gave a
wonderful keynote it's pretty shorts
like 18 minutes at go to Chicago this
year it's on YouTube and it's some
flavor of like all the different things
of event architecture it's about a
venture of an architecture and he does
in his wonderful way very clearly he
goes through the pros and cons of events
as notification events that carry the
data with it event sourcing etc so like
that's a that's well worth your 18
minutes to check out I want to throw in
a cautionary tale or honestly you're
powerful but you know I gave a talk
earlier and I talked about superpowers
and beware of superpowers event brokers
or superpowers all right be very careful
when you put things into queues if you
don't know where they're gonna come out
or how they're gonna come out or who
they're gonna come out to if you don't
know the answers to those questions
you probably shouldn't put things in a
queue until you can answer those
questions right if you have data that
you care about or your users care about
you need to be able to at least reason
about those things to some
now I know event brokers have been
pitched as a way to give operators
control so that they can answer those
questions validate that okay hey
question from here again so let's look
at some evolution all right so initially
when the web started everybody was
writing interesting apps then came rails
and MVC and rest and people started
writing that and we hit scale at large
monolithic apps slowing us down today
the buzzword bang bandwagon is
micro-services you go anywhere you
cannot walk two feet into a company and
not hear micro-services so what if we
just step back if we just step back and
say what are some things that you
foresee will happen for the micro
service train saturates
what's next micro functions did not
already happen so I just want just
wanted to see what step back and see
from a different zoom out lens what's
next what will happen what do you think
will happen hypothetically I'll give the
meta answer and then I'll get you guys
fill it in the meta answer is look at
what Google is doing now Amazon is doing
now Netflix is doing now because but I
mean meaning no shame like if you're ant
sick asking that question I mean I'm
just gonna be flipped like if you're
asking that question you're five years
or ten years behind these people and
that's a good thing because you don't
have to experience and like reason about
those things from first principles you
can look at what you know what these
larger architectures are sharing that's
that's part of the answer yeah I mean
that's an interesting one I mean that
there is at some level there is sort of
a limit beyond which it doesn't
meaningfully make sense to decompose a
module right so like if you go back to
you know some of the classic work in
object-oriented design the common
closure principle right it says that
things for the same the change for the
same reason should be packaged together
right and so if you and what that means
is that if you decompose a package into
two two packages and really the
split this business concept across those
two packages then whenever that business
concept changes you're changing that
both of those packages so you're gonna
see this lockstep and so that's kind of
this certainly the tomaters it's like
pattern in an anti pattern in the micro
service architecture distributed
monolith where you're really releasing
large number of multiple services
simultaneously because of that so that's
one part which is sort of from a logical
perspective and then you could but then
you know from a just sort of nuts and
bolts technical thing you can certainly
say that like when it comes to
deployment right our unit of deployment
has been getting you know it's a lot
more increasingly lighter weight and
more ephemeral right so like ten years
ago if you wanted to deploy something
you had to go get a physical machine or
15 years ago anyway
now you just deploy a lambda on AWS
right and you know that's like you know
it's such a short amount of time that's
like a radical transformation in how we
deploy things and so that that to me is
one kind of huge trend though even from
a design point of view there's some you
know there is this you kind of this
common closure principle you kind of
have to keep in mind though so there's
there's a way I like to think about this
question that's I think very
complementary with this but sort of a
little bit of a different perspective
and that's thinking about it in terms of
the trends of sort of how many people
you need to accomplish something because
if you look at the transition from
monolith to microservices sort of
through the organizational lens it's
almost like a shift in the division of
labor right you're you're taking the
output of you know a team and
engineering team of thousands of people
and you're fundamentally assembling the
output of that work in a different way
into a single coherent whole and the
trend has been like if you look at you
know what ten years ago the the size of
a team it took to deliver a given
service right I mean today
a teenager could do the same thing like
out of his parents basement in a weekend
and so or at least close to that all
right and so I think that the limit of
this really comes down to okay
right what's the point where that team
size you know you can effectively stop
shrinking that it's it's how much sort
of a single developer can can absorb and
accomplish until you throw in something
like AI which you know I'm sure people
are doing now well I mean oh wait can I
just respond I mean one thing that's
interesting is I you know I don't know
whether the the productivity of an
innovative individual developer writing
code has improved right like like
writing creating brand new code because
I think you know I look back and some
things have changed right like machines
have got faster and bigger you know if
we get stuck there's Google or Stack
Overflow and then there's all this open
source stuff so we can quickly get you
know as assemble a bunch of libraries
together and if we get stuck we Google
at Google the answer but in terms of
writing code from scratch I feel like
it's still an individual developer
muddling along somehow scratching their
head and and and and if that hasn't
changed you know we don't we haven't had
a Moore's law for software development
in that regard so you know if we're in
the word realm of predictions you know I
think some of the answer is sitting
outside there in the vendor booths right
more and more of your code is running on
the same network and I don't mean yours
I mean all of you at the same time right
you're all putting your code into big
cloud vendors your code is much more
local with everybody else in this room
than it was before right so you have
this really interesting networking
effect right micro services aren't just
a way for you to build services it's
also a way for you to consume services
that other people have built for you so
I think you know when I look out there
and I see vendors
certain certain types of services the
thing that strikes me is that they're
smaller versions of things that bigger
vendors used to sell right I'm pretty
sure I look at the APM space when I see
that I think you'll probably see that
trend continue where there will be more
micro vendors right there will be more
market places around acquiring services
that help you do interesting things
somebody asked me today about
geolocation today right you can buy
geolocation as a service right it's a
tiny little service it was very very
little in terms of an API and a huge
amount in terms of the backend I think
that's one thing that we may expect to
see going forward I think those there's
two answers SPARC atha so those two
responses Park I thought of me and
that's yeah you're absolutely right I
don't think an individual developer
writes more lines of code because I
think they spend but there's still a way
more productive and that's because they
spend a lot of time figuring out how to
assemble other things and the other
things that you just mentioned or what
you just mentioned is is an example of
sort of that marketplace of other things
to assemble so so when I log into an
application like Netflix it's a pretty
frictionless user experience you know I
log in one time I don't get a sense I'm
logging into the micro service for my
user profile and then I don't log into
or re-experience the my customer history
etc so how in micro services
architecture do you maintain this
frictionless UI because most of us are
writing applications that span multiple
multiple services but from a user
standpoint it's really just one thing
that they're trying to one application
they're trying to go to so how do I
maintain the advantages of a share
nothing architecture where I can deploy
independently I don't create all these
dependencies between them but at the
same time I'm maintaining a user
experience as frictionless that's
unified that has the same consistent
look and feel so thanks sure
hello yeah so the way to look at that is
like there are different tiers in the
micro service layer as well so there is
front-end which is taking all the user
traffic and then you have middle tier
and then back in tier which is basically
your membership and all the core
services which give that data set to you
so in terms of the UI integration there
is a lot of interaction between these
services but at this at any given time
the point of the source of truth is just
one service right so in in terms of
interactions with the UI all our UI team
and I am NOT
I don't have a lot of insights into the
UI layer but they do a great job in
making sure all the interactions between
these micro services and and the result
sets they are getting in the UI are
seamless basically there's a lot of work
which goes on behind the scenes but but
each micro service is not related to the
other so that ways you know which
service to call so though there is a lot
of interaction you have fallbacks as
well so from the UI point of view you
don't see that you are having a degraded
experience so for example if you're not
able to hit we are not able to give you
your personalized low Lumos list of
movies to watch for being that service
if you are not able to go to that
service we may fall you back to a
fallback page which is which is a
generic low lumo so you may not
experience degraded service you may not
think that you are seeing
you're not seeing your active list of
movies but within that service it's
basically giving you the fallback
experience so great so we are out of
time that was an awesome set of
questions thank you so much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>