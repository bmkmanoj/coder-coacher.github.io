<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Yehuda Katz: The Future of the Client-Side Web | Coder Coacher - Coaching Coders</title><meta content="Yehuda Katz: The Future of the Client-Side Web - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Yehuda Katz: The Future of the Client-Side Web</b></h2><h5 class="post__date">2013-06-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EcyxXPILO8E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so i'm here to talk today about the
future of the web this is obviously a
very large topic and so I'm going to
narrow the focus down to one particular
trend that I think is very interesting
and something that I think if you
understand it will really help to shape
your understanding of what every all the
things that are happening on the
platform all the news that you read
about the platform so first of all you
might be asking why do I have anything
to say about the future of the web
honestly I don't really I have no
special insights into it but I am
involved pretty much up and down the
stack in terms of web stuff so I have a
company that builds web applications but
I also work on web framework I'm also
involved in the standards organizations
that make JavaScript and also the
technical advisory group for the whole
w3c so I'm pretty actively involved in a
lot of parts of what's happening in
Sanders and I think I'm pretty uniquely
suited to give a sense of what the whole
the big pictures so in the early 1800s
France was undergoing a lot of turmoil
and between 1800 1830 there was a lot of
political upheaval but one thing that
they did manage to get right one thing
that they did manage to get done at
least was there canal system and then
they woke up in 1830 after spending
decades on their canal system they
noticed that nobody cared about canals
anymore and said what we really need to
do next is we need to build a series of
railroads and they said the way we're
going to build this series of railroads
is we're going to do it centrally we're
going to start from Paris and we're
going to build very straight lines very
centrally managed lines across the
entire the entire France and we're going
to be very careful about not involving
any local areas we're going to do
straight lines we're not going to have a
lot of redundancy we're going to build
something that's fast that's efficient
that we can centrally managed centrally
control that riddhi itself from Paris
and they actually did manage to build a
very nice technical achievement of a
centrally managed real railroad system
but in 1870 when Bismarck invaded France
they ended up getting the worse for it
because while while the Prussians had a
very poor railroad system from the
perspective of elegance and beauty I was
not centrally managed they had a lot of
redundancy it had a lot of complexity it
was very easy for the Prussians to rear
out around parts of the system that got
nuked that got I'm not nuked in 1870 but
that got destroyed while in France if
you took out Paris or you took out part
of the system it was very difficult for
people to actually go from one place to
another so this this railroad system
which has which is known as the Legrand
star after the Creator Victor legrande
seemed to have all the benefits of a
nice system it was it was built by the
greatest minds the biggest minds and it
but it didn't end up working it didn't
end up solving the problem because of
the fact that it ended up being a little
bit much to centrally manage and it end
up losing to a system that was much more
ad hoc that was much more ugly that was
much more redundant but it ended up
working this story comes from a book
called future perfect I would recommend
reading it if you have not and it I read
this book sort of as I was thinking
about giving this talk and it really
helped right it helped me understand the
trends that are going on in in the web
platform so one thing that's really
great about the web platform in general
is that it started off as a
decentralized system anybody could write
a website anybody could put a website on
the on the network you don't have to get
permission from anybody there are very
very few central systems and this was a
really really nice aspect of the of the
web system it was sort of like the the
Prussian railroad system was ugly was an
elegant wasn't like gopher centrally
managed you have to get permission to
get a Lincoln maybe you have broken
links but at the end of the day there's
a lot of redundancy many copies keeps
things safe etc but somehow when we got
past the initial web and we started
doing standardization we've actually
gotten into a bad place which is that
we've now created our own legrande stars
in the standards process so because of
the fact that the web browsers needed a
place to coordinate centrally and
because of the fact that there's so much
craziness in the existing
implementations of web browsers what has
ended up happened
is that for the past five or 10 years
the innovation has been driven centrally
through the html5 process and it has
given us a lot of good things it has
given us a lot of progress but it means
that we're spending a lot of time trying
to centrally manage innovation in areas
where it may not be appropriate so here
is one example there is a thing called
main main content which eventually
became content a lot of centralized
effort and energy was spent
standardizing main content even got its
own it's even got its own bugzilla
component called the main content
component all this for a single tag so
many many people were centrally trying
to manage whether or not people should
use a main tag in HTML and remember you
can use a main tag if you want just fine
all browsers don't care but people but
the standards process found itself in
this weird position where it was trying
to decide whether or not it made sense
for everybody to have a main component
and what we end up at what ends up
happening is that we have we spend a lot
of time trying to centrally manage these
things and then we end up with people
who want to do something a little bit
different so for example if you want
momentum scroll on a mobile application
you end up having to rebuild tons of the
entire layout system because we built a
very centrally managed well understood
system that is designed for particular
use cases and if you don't have those
exact use cases there's really no hooks
into the system you basically have to go
and start from scratch you have to build
your own scrolling system if you just
want to get a little bit of momentum
scroll now it hasn't always worked like
this historically we've actually had a
lot of good salaat of good libraries
that got created to build on top of
things that were already in place so
jQuery is a really good example this
there was a lot of stuff that the Dom
didn't do exactly as we might have liked
the API wasn't very good it was hard to
use confusing didn't compose very well
and we were able to basically solve that
in libraries solve in a library space
another example of this is the picture
element so as you probably know retina
displays are becoming very popular on
the platform
and obviously html5 didn't think of the
of dealing with retina displays ahead of
time it had to be dealt with quickly and
people who are in the responsive design
community basically said okay we have a
solution we have this picture element
and they tried to go to the standard
process to get a standardized so they
went to the CSS working group they went
to the HTML working group and they said
we have this proposal for a picture
element and of course immediately
everything installed there was an
argument the HTML guy said they wanted a
different way than the way the the
people who had spent the last year
trying to work on it wants it to do it
and I don't really know who's right but
what I do know is that at the end of the
day what happened was the guys who are
working on the picture element basically
just went and wrote a library they wrote
picture fill which works exactly the
same as the picture element supposed to
work it's written in JavaScript it's
only 20 30 lines of JavaScript and it
actually solves the problem and so we as
a platform as the web platform are most
effective when we enable this type of
innovation we're most effective when
when retina displays come out and we
need a quick solution we're most
effective when someone could write 20 or
30 lines of JavaScript and actually ship
something and not have to spend years
arguing with standards bodies now
there's one really there's a visceral
thing if you've been doing this stuff
for a while which is that if you
actually try to build something like
jQuery or picture fill often it really
is terrible it doesn't feel good you end
up hacking in deep you end up having to
touch areas they have nothing to do with
the area that you're dealing with you
built if you build a picture library
like pick your fill it probably doesn't
play that well with other libraries that
maybe are doing similar or even not very
similar things you have to be careful
about how you listen for events so this
whole thing Walt Purdue it has produced
a lot of innovation in a decentralized
way things like jQuery picture fill and
many many other libraries actually
doesn't feel good to write it but it's
not something that many people can do
it's something that you really have to
be an expert to do and I think as a
general rule web developers front-end
developers prefer a decentralized design
we prefer when we have the appropriate
hooks that are necessary to go in and
surgically do something so actually the
picture of the library does you make use
of a few surgical looks that that make
it pretty easy for it to do its job some
of which are
knew it could it could be even better
and I'll talk about that later but
things like jQuery actually are get get
pretty you have to get pretty invasive
things like polymer which is a new
google library which tries to add in
support for custom elements gets pretty
invasive so what really what we prefer
is a decentralized design we like things
like picture film we like things like
jquery and we prefer them over having
the platform and argue about how to do a
particular API so obviously the platform
is necessary to do thing to expose
certain capabilities like the light like
hardware support or an HTML parser in
the first place but in general we prefer
to have libraries do these things so why
do we prefer to have libraries do things
i think it's self-evident but i'm going
to lay out a few of the reasons one of
the reasons is that we elect the poll
platform iterate without risk so if you
talk to web browser vendors they often
use the phrase don't break the web and
what they mean by that is that it's very
hard for them to add new features of the
platform quickly because of the fact
that once they add a feature the
platform comes very hard to take it out
so even things like the WebKit prefix
CSS properties or WebKit javascript api
s are very hard to remove because people
have come to rely on them and then maybe
firefox has to implement WebKit prefix
things simply because the web has come
to rely on it so browser vendors
actually it's very difficult for browser
vendors to add new features quickly even
in cases where there's some urgency like
the case of responsive design
experimentation via libraries doesn't
really have this problem if you can
experiment via libraries then you're in
a pretty good place another really good
reason why we like libraries is that
they allow us to solve domain specific
problems so we have some cases where we
just hard-coded them into the platform
like math ml you can write math in your
in HTML basically but there's a whole
long tail of domain-specific problems
that really should be solved not in the
platform but should be solved by someone
who has expertise in them and you don't
want to bottleneck that into you don't
want to bottle that bottleneck then that
into the standards process also
eventually after jQuery existed for a
really long time the browser was able to
standardize around the selector engine
and they created a feature called
queries left
all because of the fact of Jake where I
had already and other libraries had
already iterated on selector engines it
was pretty easy to see what the API
should look like so the browser vendor
didn't have to guess what the API might
look like and then clunk alee iterate as
people maybe didn't like it the browser
vendor was able to basically take a look
at what the browser said the libraries
have done over a couple of years and
then bring the feature in with native
support I think one thing that's that's
quite important is often it feels like
there's urgency to get some stuff done
so for example responsive design again
or offline support feels we're junt and
often that causes the standards process
to want to standardize around a
particular scenario so you know about a
particular offline scenario so you solve
it using a particular solution and then
if somebody doesn't have that exact
scenario they're kind of stuck they have
to go back around the standards wheel
and convince somebody in a sandwich
process to add another scenario so
really what we prefers to have a few
basic primitives in the platform and
then allow the allow libraries to
experiment to explore and not rush the
standards process into making a decision
that they're going to regret later and
finally I think in general which the way
you should think about all these things
is that they allow us to have a better
feedback loop between people writing
JavaScript code or platform code and
people designing the platform right now
the feedback is try to put something
behind the flag in Chrome hopefully
somebody will look at it obviously you
can't chip its users six months later
you probably get a little bit of
feedback maybe if everyone agrees you
can advance it into you can advance it
into the main stable branch hopefully
it's not too late to fix things at this
point now that it's in the real world
you get some feedback you have to be
very careful what you change of course
all these things don't exist in library
so if the browser vendor was to make a
library like google has done with
polymer and mozilla has done with x tags
it's going to be a lot easier for the
browser vendor to learn things that they
made mistakes about and they'll be able
to quickly change it and if you don't
want the new version of x tags just keep
running with the old version of x tags
jas or polymer notch is so we can do we
can get a lot tighter a feedback loop we
can explore ideas that browser vendors
have because frankly browser vendors
have a pretty good sense of what the
platform needs but they don't always get
the API right
and just to go back around I think all
this stuff sounds great but in practice
it sucks to write the code it sucks to
write the code so really what I'm here
to tell you is I think a lot of what the
platform is doing over the past year or
two and over the next few years it's
going to be making it suck less to have
this type of flow to have this type of
workflow and I want to use a particular
concrete example about app cache so app
cache is this feature that the browser
created in order to support offline and
you can go look at it over here there's
a thing called offline web applications
so the stamp there's a centrally planned
legrande star here is how you should do
offline applications and there's many
pages here and a lot of thought that
went into it so we get and this is a
common pattern in the browser we get
centrally planned new capabilities so we
have a new capability which is the
ability to serve an HTML page without
being online so you can go to google com
hit enter when you're offline and and
you get a page which was not possible
before but it's hidden behind all this
centrally planned very very specific
very very scenario specific story and
really what you would like is the
ability to just have that capability
access it directly so how did we end up
here how do we end up in this situation
so let me go through how it works to
access to websites web page using your
browser so let's say I type in you to
cast com I hit enter so the first thing
that happens in the current browser is
the browser says okay I need to make an
HTTP connection and everything about
that HTTP connection is completely
hidden from you in in JavaScript it's
completely hidden from you even in any
kind of higher level API and each GP
request is made eventually comes back
and you end up with a page being shown a
little bit later as you're parsing the
HTML you're going to see an image again
the browser is going to make an HTTP
request completely opaque to you make a
request come back and then you get the
the image right so the important thing
to notice here is that this whole thing
is a black box there's an HTTP thing
going on and it's completely opaque to
you so then the obvious thing to do if
you're Ian hixxy and you're trying to
add offline support is you say okay so
clearly that part of the system is where
offline support is needed let me add a
new
api a new high level API let's make it a
manifest and if you give me this
manifest I'm going to change my HTTP
behavior to do something different
unfortunately the thing that he came up
with didn't actually solve a lot of real
use cases so there was a number of
seminars that were happen trying to
trying to centrally fix the problem
called fixing app cache or fixing
offline many in person seminars
workshops etc and one of the things that
came out of this workshop was this
ticket that was open by Anna van
kesteren that basically was targeting
one particular scenario one particular
scenario which is I have a blog i would
like to blog to work offline but when
i'm online i just want to go to the
website i don't want to be serving stale
content when i'm online but i just want
i want off on to work this was reported
in 2011 it was that was already way too
late that was already when there were
seminars called fixing app cache more
than six months later after I very very
long back and forth hixxy said I've
added the idea to what WG speck maybe
it's implemented in some browsers now in
2013 a year later but I it's not
implemented in all browsers and it's
really just one particular spot fix for
one particular problem and it took an
entire year to even make a little bit of
headway after we everyone already agreed
that it was so broken that we needed to
again have seminars so this is not
really I don't think this is tenable I
think I think everyone knows after doing
this top-down centralized planning way
of adding new capabilities to the
platform the platform people browser
vendors in particular are very
frustrated by this I think people feel
trapped by the fact that they know they
can't break the web so they can't
iterate fast but on the flip side of
that they know that if they don't enter
a fast they're losing ground to other
platforms and so there's this real
there's a strong problem and and and
this is the answer the answer is
something like what Alex Russell from
chrome announced recently which is the
navigation controller so this is his
repo notice that he put a repo on github
and there's many issues that have been
opened and there a pull request and
there's open discussion you look like
you have a question you know it's it's
an open discussion about a new feature
a lot of back and forth that happened
it's a low level feature and how does
this little oval feature work well what
happens is when i type in unicast calm
and i hit enter what happens is the
first thing that happens is we check to
see if there's any javascript code
registered now this javascript code
doesn't obviously does not run inside of
your page because that would be a
chicken-and-egg problem this is
JavaScript code that runs outside of
your page and what is called a shared
worker so another thread basically and
the page says okay controller do you
have you got a cat stuck on and probably
what the controller will do at first is
it will say no I don't have it go make a
normal HTTP request HTTP request is made
HTTP request is returned and we're back
in business so note the difference
between this and the old model in the
old model we still had this capability
but that controller was completely
opaque it was something that someone had
to decide in the w3c someone had to make
a standard about it in order to make
this work at all and now what we're
saying is let's stop trying to figure
out all the use cases up front let's
just expose that capability we already
know we could expose it securely we
already know mostly that we could expose
it efficiently but we should just stop
trying to guess because we're guessing
wrong we're constantly guessing wrong
and then what happens when you when you
get to an image so similarly you go to
the controller you ask the controller
the controller makes a request to the
server returns and then you show the
image so so far this is pretty much
identical to what we had before actually
what we had before even with that
offline support but let's look at how
how awful and support might work so
offline support might work you go to you
two cats com you would enter and maybe
the controller already has something
cached maybe it doesn't actually care if
you're offline or not maybe it does care
if you're offline this is just
JavaScript code it could decide to do
whatever it wants to do it could decide
to implement that I always want my blog
when i'm online to go to the server but
i always want to each store from the
cash when i'm offline it has access to
cash in primitives right so now we can
actually figure out what the
requirements are we can figure out what
the requirements are in a way that
allows us to iterate quickly and we can
do we can figure out what the
requirements are without having to go
back to hixxy and convince him about
some particular edge case and if people
don't like where it ends up iterating
they can just keep using the old
JavaScript library
so it works the same way and again
images go to the controller come back
and show the image so the important
thing here is that this is not saying
that we don't want app cache right so
app cache have a nice property of being
a manifest that had a lot of semantics
around atomicity that sounds great it's
great for us to have features like app
cache it's even great for browsers to be
inventing the ideas of how those things
should work what's not great is for for
the standard process to have a monopoly
on how you're allowed to use these new
capabilities also if there are domain
specific problems like I'm trying to be
be a blog or I'm trying to be facebook
or I am I you know on Wikipedia or I
have some math specific stuff that maybe
has different offline requirements than
if I'm showing code maybe Ruby code or
Java code in the browser you know an
editor might have different offline
requirements than a blog and this allows
us to actually explore all those spaces
allows you to have a library that's
maybe for doing offline code editing
that does specific offline support for
that use case and maybe over time we
find that there's a lot of commonalities
maybe we put that stuff in the platform
but we don't have to worry that we
screwed it up that it's in the platform
and outs too late so I think this is
this is a really good example of where
things are going in general it's with
looking at okay we have a new capability
we want to expose this new capability
let's stop trying to guess let's just
expose the low-level primitive and let
the ecosystem figure out what's up
another really strong example is custom
elements so you might have heard of the
polymer library if not check it out so
this is a google library that they
created basically to flesh out the idea
of custom elements because of the fact
that the standard process was just
taking too long so Google had an idea
for custom elements for data binding and
they were just having trouble getting it
to move quickly through the standards
process probably for good reason it was
a big complicated project and what they
did is they said okay we're just going
to write a JavaScript library it's going
to be very invasive because that's how
you have to do some of these low-level
stuff today but we're going to show
everybody how it works we're going to
iterate on it we're going to let the
community figure out what's going on and
then we'll eventually move it back into
the standards process polymer they
announced it at Google i/o actually so
this is actually
sort of my personal end goal for custom
elements if you don't know any
JavaScript that's fine i'll i'll try to
walk you through it a little bit so
first of all the top two lines are new
import syntax which is coming from the
JavaScript side so this one slide
actually encapsulates a lot of things
that are coming in the future that make
it really easy to do more low-level
stuff without getting super invasive so
importing from from packages or modules
is a thing that's that's coming very
soon it's coming in es6 so we can
basically not have to store everything
on the on the global that's great that's
a good starting point but then you can
see here class syntax so that's also new
class syntax but what's really cool
about this is that you're extending a
native element so even today with fake
classes the javascript take classes that
use prototypal inheritance there's not
really any good way to subclass HTML
elements because they use this internal
C++ struct you really can't get access
to it so part of the process of creating
classes as first-class things in the
language is also figuring out what it
means to subclass raw elements so in
this case I'm subclassing a canvas
element the canvas element is just is
just a raw drawing context so we have
things like images like the divs we have
SVG but the platform also today in 2013
and for quite many years before that has
a thing called a canvas element which is
just draw whatever you want and so what
we've done here is we said okay I am
ready I'm going to register a new tag
called custom image and here is the
implementation it's a subclass of canvas
element and what we're going to do is as
soon as the tag is inserted to the page
and that's going to happen when custom
image is seen by the HTML parser it's
going to go call that ready callback
that ready callback is going to make a
request to fetch that's going to return
a stream it's going to pipe that into
something that converts it into an image
bitmap stream type it into the canvas
and call it a day so why is this cool so
obviously first of all you could
actually do basically this functionality
today using a lot of JavaScript so you
could go scan the Dom looking for stuff
when that when things change you can try
to use mutation observers to notice when
things get added you could trigger your
own callbacks you could make ajax
requests against some source and you
could try to convert into a stream using
funk
you could use another epi to draw right
but but all that actually has a lot of
tax it has it's a lot very heavy it
involves a lot of different api's that
may compose poorly with other things
that are happening on the page where
this is really isolated this is
basically a very low level mechanism but
it it's a very low level mechanism that
does pretty much exactly what you want
and actually one thing that is
interesting about this fetch method so
something that you may or may not know
is that in the browser when you make a
request for some data you basically have
two options you make a request for some
data using something like xhr which lets
you see the response and if you do that
you could only make requests to your own
domain or domains that have opted in and
then you could also just use an image
tag directly and if you do that you can
make a the browser will basically handle
all the stream all the the image data
but you can't look at it so you can get
an image on the screen with a
cross-domain image that's how a script
tag works the same way that's how you
put in advertisements or whatever but
you can never look at the contents and
the interesting thing about this fetch
API here is that this fetch API actually
has the ability to return an opaque
stream so the opaque stream is basically
something that works pretty much like
this the image tag you made an HTTP
request was totally legal to make it you
can't see the contents but you can pipe
it directly into some other primitive
that knows how to handle it so the
specific details here are not are not
that important but what is important is
that the idea is that we're really
getting into the low level we're not
breaking the security model right the
security model is very important and we
don't want to break how the web works
but we do want to get as low level as
possible to give you the ability to
reimplement image to re-implement script
tag to re-implement audio tags to
reimplement input type equals range we
want you to be able to do all these
things but to do that we really need to
not to stop exposing all these
capabilities as some particular side
effect of executing some markup and
really just give you the low level
feature give you the low-level API so I
think where things are going in general
is that the standards process is
increasingly focusing on capabilities on
new on brand new capabilities getting
giving you access to hardware giving you
the ability to hook into the HTML parser
maybe giving you the ability to hook
into CSS
itself which is much harder problem at
any of this and we need standards bodies
to do this because we don't want to get
access to the louisville features in
inconsistent ways we really need the
browsers to get together and talk about
how to do it we want the things to be
secure we want them to be efficient
right so we really need standards bodies
to focus on capabilities on the flip
side of this increasingly developers are
using the capabilities that are given to
us to iterate on higher level api's
we've seen things like people have built
things like em script in which takes any
C code and compile them into JavaScript
now you might think that that was always
possible but it really wasn't it
required a bunch of new api's around
low-level memory management so you
there's a API called array buffer which
lets you basically allocate a big blob
of memory and just right into it
efficiently so we have a lot of these
things that are starting to happen where
developers are using these lower
primitives that are given to us to
iterate on higher level api's and
increasingly the standards bodies are
getting cut out of the process that
nobody really standardized em scripting
which is the thing it's an lvm thing
that takes anything that goes to the lvm
and dumps out javascript on the back and
nobody standardized that that just
happened because of the fact that the
primitives were available and in fact
that whole process it's good that it
wasn't standardized because it's been
iterating a lot to get improvements to
work with a sm j s which is a standard a
way of getting very very good
performance out of a subset of
javascript code so what we really want
is we want these level primitives and
then we want to let the developer
community go to work so there's a java
conference I think Java basically did
this I think Java early on decided that
they weren't going to focus so much on a
lot of high-level api's but more about
just giving low level primitives that
are needed and and now the ml vm project
the things like invoke dynamic and and
giving access to a whole bunch of new
features are also continuing that
process of saying we know that a lot of
people are building languages on top of
the JVM let's not try to guess what
those things are let's just think about
what low-level parameters that we need
and that's increasingly happening in the
platform the web platform and one thing
that I think is very sort of the missing
pieces discussion in general is
essentially what happened with polymer
so when you start off thinking about
this topic there's sort of a weird gap
which
is so you could imagine in a browser
implementing a low-level feature like
array buffer and then supposedly the
developer community feels to do
something with it but that really
involves developers taking some time out
of their day to look at the primitive
and try to figure out what is what is
going on here what is the point of this
what does the browser want me to do with
this and what's increasingly starting to
happen so M scripting is actually a
project that was heavily funded by
Mozilla also a sm j s polymer is heavily
funded by google what's increasingly
starting to happen is that browsers are
saying we've given you these primitives
and we have a good idea of what we think
we should do with it we have some ideas
for a high level API now we could just
go put these things into the browser but
we're afraid you know we don't want to
make mistakes we've made too many
mistakes already so what we're going to
do is we're going to write a library
like polymer like I'm scripting and
we're going to give it to you the
developer community and help you help us
work on it and maybe in a few years if
we iterate it enough and we realize that
there's a lot of consistency around what
we've come to and there's a lot of
agreement maybe then that's a good time
to bring it into the platform maybe we
shouldn't maybe that's a good time to
avoid downloading a lot of JavaScript
that everyone has to download and you
can see some of that happening with
jquery actually in sort of on a
different level increasingly features
that jquery required like the ability to
match on selectors to find things by
selector a bunch of dom api's
increasingly these things are actually
added to the platform so you shouldn't
necessarily expect that things are going
to be adopted whole hog like just
standardizing jQuery would be a little
bit crazy but looking at what it is that
these libraries are doing is crucial and
I think I just want to repeat the fact
that one of the biggest wins for this is
actually not for things like jQuery
which are very generic and in theory the
platform could do you get away with it
you have these big libraries fine what
really what this really what this stuff
really does is it allows domain specific
communities little communities that are
working on things like math things like
code to build their own abstractions so
today if you want to build a code editor
or something like that it's not gonna be
easy to do it using markup so if you
want to build if you want to put ruby in
the Dom or java in the Dom it's not so
easy to do with using markup because we
don't really have good tools for it
we're going to have to
of classes it gets super ugly people
don't really want to write that but with
new tools with web components which lets
you write custom elements with hooks
into the parser with low level low level
a drawing api's maybe hooks into CSS you
can easily imagine that little
communities that have no business
getting things standardized to the w3c
will be able to build their own little
jargon their own little vocabulary for
their own stuff in high-level ways and I
think ultimately what is extremely
crucial is I talked a lot about low
level JavaScript API eyes but really
this is not about low level JavaScript
API eyes this isn't about everyone
writing a lot more JavaScript really
what this is about is helping a few
people build high level api's for
everybody else right so jQuery didn't
make it so that everyone wrote more
JavaScript than if they were writing
using Dom jQuery made it easier to write
less JavaScript by using the tools that
were already available and especially
when you can hook directly into the
declarative form when you go directly
into markup I think we'll definitely see
increasing numbers of people that build
for their little community enough tools
to move forward without having to
involve the standards process the web
basically got started with the radical
idea that document office shouldn't need
permission from a central authority to
publish things why not apply the same
ideas to standards the standards process
itself thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>