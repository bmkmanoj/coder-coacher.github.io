<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>An Intro to Pattern Matching in Scala | Coder Coacher - Coaching Coders</title><meta content="An Intro to Pattern Matching in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>An Intro to Pattern Matching in Scala</b></h2><h5 class="post__date">2015-02-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1vxIRkYZfmc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay I'm Brian clapper I'm a
independent consultant I run
user group and I teach Scala and play
and a few other things for new circle
and today what we're going to talk about
is is a feature of Scala that I think is
one of the killer features it's one of
the most interesting capabilities in the
language so those of you coming from a
Java background might find this
particularly interesting because even
with Java 8 there's nothing like this in
Java so we're gonna start talking about
something called apply and update this
is this is a setup for the cool feature
that we're going to be talking about
Scala permits you to make make anything
callable as if it were a function so if
I've got a class or I've got an object
if that object has an apply function on
it then I can call it as if it were a
function so for instance if you look up
here on the slide here we're calling
something called f and this looks just
like a function call exactly like a
function call but really what Scala does
is it looks at that it says is f really
a function no it's not okay does f have
an apply function if it does then it
maps this call into an apply call
alright so that's if that's if you call
it in this fashion it also permits the
the function call to appear on the
assignment side of an equal sign so in
the second instance here it looks as
though we're assigning some value to a
function call but really what's
happening is Scala D sugars that and
that's the term we typically typically
call is D sugaring this is syntactic
sugar for this F dot update call so it
calls F dot update and it passes in the
arguments that you give it over here on
the left followed by the value now where
this is typically used a very common
example is we're updating a map or an
array so this next example down here
shows that we have created a mutable
hash map which corresponds to a Java
typical Java hash map and now we're
going to assign the key Bob the value
100 and because of the update syntax we
get this natural assignment right there
okay we don't have to say scores dot put
we don't have to make any weird function
call
we're just saying hey assign scores sub
Bob the value of 100
all right so far nothing really slick
about this I mean it's kind of nice the
compiler does this for you but you know
of what of what value is this all right
so the one on one use for the apply
method is typically in what scholar
calls a companion object whenever you
create a class in Scala so here's an
example of a class called fraction you
can create what's called a companion
object now an object for those of you
not familiar with it in Scala is a
singleton it's kind of like a static
class is in Java but it isn't really a
static class it truly is a singleton so
if I put an apply method on my companion
object fraction note what this apply
method does this apply method basically
says you're going to give me a numerator
and a denominator and I'm going to
create a fraction for you out of that so
this allows me to create new fraction
objects without the use of the new
keyword which is kind of nice because
this leads to a little bit more of a
readable syntax when you're stringing a
lot of these things together looking
down here instead of saying new fraction
3 comma 4 star new fraction 2 comma 5
the new in that would be sin it's kind
of visual noise you don't really need it
so the the apply method allows us to to
use to call these things and create them
without needing the new so that's one
that's one advantage to this and again
this is all lead into the cool feature
so we're not - the cool feature yet
where we're going with this is something
called uh apply so just as there's an
apply method scala also has this idea of
a nun apply method so think about an
apply method as taking a bunch of
discrete parameters and assembling them
into an object that's the typical use of
it so what's the reverse of that I have
an object and I want to disassemble that
object into those original discreet
parameters
that's unapplied so for instance on
apply is used for what Scala calls
extractors and this is an example of an
extractor here I've got a fraction 3/4
times a fraction 2/5 and I can do that
because of operator overloading
something we're not going to talk too
much about right now and then on this
side I'm assigning it
to fraction a B and what's ecology
sugars this into is basically fraction
dot uh apply of the resulting fraction
and so the bottom line here is that this
VAR this statement right here pulls out
a and B automatically it extracts them
right out of this fraction subsequent to
this statement in the code I can now
refer to a and B without having to
assign them anywhere they're extracted
right out of the fraction into local
variables where this is most commonly
used as in a pattern match and pattern
matching is where we're going with this
pattern matching is the whole point of
all of this is so that we can talk about
this so how do I build a none apply
method basically this is it it goes on
the companion object we put def on apply
and here's the input the input is a
fraction in this case so we run applying
the fraction we're going to be taking
the fraction apart into its pieces now
in order for this to work properly we
have to return an indication of whether
or not we were able to find something to
extract so what we're saying here is
we're gonna return an option an option
is none meaning there's nothing there or
some which contains the result so in
this case we're returning none if the
denominator is zero it makes no sense to
pull apart a fraction if the denominator
is zero because that's an illegal
fraction you can't divide by zero so if
for some reason somebody's constructed a
denominator of zero this extractor is
going to return nothing and fail so we
return a none otherwise we're going to
return the pieces in an ask Allah to
pool which is a read-only heterogeneous
collection so here's the input numerator
and the input denominator collect it up
in a tuple and then wrapped up in a sum
which is the opposite of a none this is
all you need to do to build a none apply
and as soon as you do that you can start
doing pattern matching stuff on this
we're gonna look at that in just a
moment so the key here to remember as we
start talking about pattern matching is
apply a none apply they are cool they
are key to doing a pattern matching in
Scala all right we can have extractors
with multiple arguments
so here's a nun apply that takes an
input of a string so the problem is that
Scala doesn't provide the ability to do
a one tuple it has two tuples three
tuples four tuples what if my extractor
is only extracting one thing well the
answer there is there's a special case
don't put it in a tuple here we're
returning an option of a single integer
not an option of the tuple so we're
going to try to unup lion umber by
parsing the string that you get it and
if that fails we're gonna return a none
we're gonna catch the exception return a
none so in this case the sum does not
include a tuple sum just includes the
thing that we're trying to return and
with this in place I can then do
something like this okay Val number n is
equal to this string and and will be set
to two the value of that number if the
parse succeeds okay and again this is
just an example this is not the common
use case of this the more common use
case is something like this where you
you use it in a pattern match so let's
keep moving there's one more piece that
we need to look at and that's called
unup lycée on apply' is intended to
pull out always the same number of
things so in the case of fraction we
always know we want to take apart a
fraction into two pieces the numerator
and the denominator but what if we want
to take apart something that is of
indeterminate length like an array or a
list some kind of a sequence in that
case we can't use a none apply because
to take apart an array I might be taking
apart something that has one element or
15 elements so in that case Scala looks
for something called an apply seek seek
being in this case shorthand for
sequence so we call it if we do a none
apply seek we provide to that capability
then we can allow an indeterminate
number of matches so this matched down
here for instance take apart a name if
the name contains two elements a first
name in the last name I want to run this
case match if the name contains three
elements a first middle and last I want
to run this match if if it's a certain
kind of Dutch name so that the first
element is captured here followed by the
string van
followed by the string der and then
followed by a last name like James van
der Linden or something then it will
match this case so in this case the UH
apply seek allows us to do an
indeterminate level of matching all
right so that's the background and with
that background in place now we can
start to talk about pattern matching so
now we're to the cool part pattern
matching in case classes pattern
matching is sort of like a better switch
statement okay those of you coming from
Java or C or C++ you're used to the C
style switch statement when you switch
off of a value in those languages that
value has to be integral it has to be a
number of some kind and characters count
as a number there are small numbers
stored in a byte usually right or in the
case of Java stored in a 16-bit utf-16
representation but they're still
integral so you can think of the pattern
matching is sort of like a C style
switch so if you look at this example
here this doesn't look much different
than a switch in Java or C or C++ we've
got a character and if it matches a plus
sign then we're gonna run the first case
if it matches a minus sign we're gonna
run the second case if it matches
anything else and the underscore is sort
of sort of the default case then you
know we're gonna run the last case now
there are couple differences here that
you don't see in Java there's no break
statement here
there's no fall through ok so the case
matches don't fall through to the next
one so you don't need to have a break
statement they don't work that way when
a case has matched the code next to the
case gets run and then the match is done
right so we can because this is Scala
and every expression in Scala has a
value we can take the result of this
match which is an expression and we can
assign that to to a vowel so if I don't
want to use like up at the top here I'm
actually assigning it to a bar well we
don't like to use bars in Scala we like
to use immutable variables so that's
okay I can just do it this way run the
match each
ends with an expression these
expressions then whichever one fires
that'll be the return value of the case
the result of the case or the match
expression which we can then assign to
sign and we can match any type okay this
is the this is where we start to stray
away from from Java we can match with
any type at all
not just numeric stuff so these this is
an enumerated type called color I can
match against the colors but even more
interesting I can be I can match against
I can add guard statements
okay so typically in C if I want to
match all the numbers I'll have multiple
cases and because these cases fall
through if there's no break statement
then no matter which one gets matched 0
1 2 etc up to 9 it'll fall through and
run the code associated with the 9
because of the fall through without fall
through we can't do this in Scala but
what we can do is the following down
here we can say ok if it matches A+ set
the sine variable to 1 if it matches a -
set the sine variable to negative 1 if
it's any other character as long as it's
a digit so this is a guard condition
case anything but only if the character
is a digit run the digit code otherwise
and that's our otherwise at the bottom
so these guard conditions then allow us
the same flexibility with a different
syntax and that guard condition can be
any boolean expression at all ok now the
other thing to note here is that
patterns are always matched top to
bottom so if there are two patterns that
happen to match the same thing the first
one wins
alright now let's let's continue because
this gets even more interesting here's a
case where I can actually use a variable
in the pattern so I can say does string
sub I match a + do this as a matter of -
do this if it matches anything else
though I would like to capture that
anything else in this CH variable so
that I can do stuff with it
ok this is also something that cannot be
done very cleanly in in Java if at all
right so I can I can use the variable
name even in the guard
I can add this here if it matches
anything else but if that anything else
is a digit so now I've captured that
character here and I'm using it in the
guard condition okay so there's more to
this though I can use this to
deconstruct types this is one of the
cool things that you can do here this is
why in Scala we never use the the
equivalent of the instance of operator
that we use in Java and Scala I can just
do this object match all right is it an
integer well in capture its value in X
and do something with it is it a string
capture its value in s and do something
with it is it anything of that's a big
integer in other words if it's a big
integer I don't want to capture the
value I just want to return int max
value and if it's anything else return a
zero I can decompose types in this
pattern match capability this is really
really useful and it's a heck of a lot
more readable than a bunch of cascaded
ifs where you say hey if if odd is
instance of this else if objet instance
of string this way you've got a nice
little table that decomposes it now the
one thing you can't do is is this kind
of thing you can't decompose generics
like this I can't say hey is this thing
a map of string to int you can't do that
that won't work
because of a limitation in the JVM it
erases these generic types so you don't
have the option you don't have this
information it's just simply not
available this won't work but you can
match a map and say look I know I can't
look up the matched generic types but I
can still match a map so you can do that
it gets more interesting than that
though this is where we get back to our
extractors okay so now what we've seen
so far is the ability to use the match
capability to do standard switch style
stuff and we've seen that it also allows
us to do reflection we can determine the
type of the thing that we're looking at
but when you throw in unapplied on apply
seek now you can begin to do things like
what we see on the screen here
so I have an array I want to do
something to this array depending on the
shape of the array so here we have an
array we're saying hey look at it the
first case says does this array a match
an array with a single element that has
a value 0 that's a very specific match
does it match an array that contains one
element and that element has the value 0
if so the first case fires the second
case fires if the array matches an array
with two elements so case number two
here array XY says that will match if
the array passed into the match has two
elements and then will capture those two
elements in X&amp;amp;Y
we will extract those two elements out
of the array what's happening is
unapplied is being called on the array
and if it matches those two elements
come out they come out and they end up
in X&amp;amp;Y and now we can play with them the
third match basically says match any
other array with stuck but it must start
with the zero and have any number of
elements afterwards so that under source
star is sort of a magic incantation that
says variable number of things matching
so the third case will give us an array
that starts with a zero but has multiple
things after that and then we've got our
fall through at the bottom the case
underscore so and it's always good to
have a fall through if you don't have a
fall through you'll get a runtime error
if something doesn't match any of the
cases other things that we can do are
lists have a special syntax for
extraction they use this thing called a
con same operator but basically what
this means is I you think of this as a
list constructor nil is a special
constant that means empty list so if I'm
matching a list type I can use this
operator and I can say does it match a
list that begins with 0 and has no
nothing after it then run this does it
match a list that starts with X is
followed by Y and then followed by the
empty list well this is a list of two
elements so I want to capture x and y
and play with them does it match a list
that starts with 0 and then has a list
you know the remainder of the list after
it which I'm capturing in tail then do
this
otherwise do this so this is the same
match for a list as the array match is
up at the top all right and then finally
you can even do this same deconstruction
with the tuple so let's say I have a
2-tuple this may be a 2-tuple of
integers here is this does it match a
tuple where the first element is zero
and I don't care what the second element
is yes if so run this case does it match
a case where the first element is
something which I'm going to capture and
why and the second element is a zero if
so run this case otherwise neither one
is zero run the final case okay so now
we're getting into a really powerful
abstraction you can use this for so many
different things in Scala so we've seen
how we can use these patterns to match
arrays lists and tuples but it gets even
better than that regular expressions
provide their own unup life's and unn
applies so I can do something like this
those of you who've used regular
expressions are familiar with this
parenthesis construct in here it's a
it's a matching group it doesn't
contribute to the pattern match but it
says look if this pattern matches then
extract the matched pieces so that I can
get at them later so this says you know
if if this regular expression starts
with any number of digits followed by a
blank followed by any number of
lowercase characters then that the whole
regular expression will match but the
digits would be captured in Group one
and the lowercase characters will be
captured in group two and almost every
regular expression library out there
both supports this and then provides the
ability for you after the match to say
okay give me Group one and group two but
because Scala has this uh apply and unn
apply seek and this pattern matching
capability they've implemented the Scala
regular expression class to allow you to
deconstruct it in a more readable
fashion so that I can say take this
string 99 bottles and match it against
this regular expression pattern if it
matches then extract Group 1 into num
and group 2 into item
this is much easier and much more
natural and you can see how this would
be very useful for building complicated
parsers it makes this sort of thing very
very easy we can use these patterns in
variable declarations as well to
deconstruct things so I can deconstruct
a tuple into its constituent elements by
just doing this kind of a simple
assignment and it's the same sort of
extraction that's going on I can also
begin to has this nice operator other
languages refer to this as the div mod
operator so if you divide a big int by
10 I mean sorry if you divide big int of
10 by 3 you're going to get a quotient
and a remainder
well this operator returns them both as
a tuple which I can deconstruct in one
statement like this this is similar to
you can do this in languages like Ruby
and Python and it's a very clean and
very simple and very readable syntax
unfortunately you can't do it in Java so
this also allows me to do something like
this I have an array I don't know how
long this array is but I do know that it
has at least two elements in it and I
want those two first elements and I
don't care about the rest of the array I
can use this syntax to extract it to
break that array apart instead of sub
scripting into the ray and saying give
me the first element array sub 0 and
give me the second element array sub 1 I
can just deconstruct it like this it's a
very clean way to pull the thing apart
okay so one one more place where we can
use pattern matching is in for loop
alright so here's a for loop we if you
take the course with us we will already
have discussed this in great detail so
here's a case where I'm looping over a
Java system systems I get properties
which returns a Java util properties up
here this little bit in blue is more
Scala magic that automatically allows us
basically to map a properties object
automatically into a Scala map and then
we can loop over that map now what is a
map a map is a set of key value pairs so
when you loop over a map in Scala the
map Christ just feeds you back these key
value pairs but I can deconstruct those
on the fly in the for loop here this is
a form of the pattern matching
so that I don't have to say okay now
I've got this tuple let me take it apart
it can be taken apart right here in the
for loop this can also be used to do
pattern matching on the fly so I can say
hey loop over these properties as a map
but only give me keys and values where
the value is the empty string alright so
this is an implied filter because of the
pattern matching here and this is
exactly the same as if I had used a
guard condition in the bottom here hey
loop over the map assign the key to K
the value to V but only if V is equal to
the empty string both of these things
are equivalent and this first one in the
middle here works because of pattern
matching so what you should take away
from this is that pattern matching is an
extremely powerful feature in this
language provides you the programmer
with an amazing amount of power to do
all kinds of matches with a very concise
and very readable syntax and because
it's all just syntactic sugar for
unapplied and on apply seek as you build
out your own classes you can build
pattern matching into them and they will
automatically work with these with these
matches it's an amazing feature and you
will not find this feature in java for
my part when i have to go back and
program java i really miss this feature
now this is just the tiniest bit of what
the the new circle scholar course will
cover so if you want to find more
interesting cool powerful features that
this language provides check out some of
the new circle Scala offerings and
that's our introduction to pattern
matching for today
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>