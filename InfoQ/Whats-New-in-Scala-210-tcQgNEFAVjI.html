<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New in Scala 2.10 | Coder Coacher - Coaching Coders</title><meta content="What's New in Scala 2.10 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/InfoQ/">InfoQ</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New in Scala 2.10</b></h2><h5 class="post__date">2013-05-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tcQgNEFAVjI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">presenting good great thanks for the
where you go introduction I like see
thanks for the invite and wow thanks for
coming out I should have poured a beer
instead of some water or something
that's a lot of people so these are not
the classic scala stairs but if you ever
have a chance go see the sofa bland
tower and lows on it's made of wood and
a couple of screws here and there I
think it's pretty cool anyway so I don't
have discounts for trainings right now
but I do have something that's almost as
good maybe even better probably more fun
so Scala days in New York this year
it'll be mid-june and if you write that
down or you know Google this thing I'm
sure google has indexed my slides by now
so you can you know along with everybody
else out there get a nice discount I
just want to show you the website real
quick it's kind of dangerous when you go
to it because you're bound not to come
out as soon as the Wi-Fi wants to work
with me Mike see more designer did a
great job we just finished the program
so not during my talk but have a look
and sign up so in addition to thanking
the host and and the organizers of the
of the meetup also really like to thank
our contributors a quick link to github
here so we have about a this will give
you the top hundred and this is about a
decade worth of contributions to scala
and you definitely see i don't know what
happened here but there is like a spike
and commit traffic oh yeah that's type
safe so there's a lot of you in the room
maybe even that are in this list so
thanks a lot for your contributions for
your issues that you've reported for
your mailing list for your kind answers
yeah i'm not going to read those numbers
but i'm very excited to see that I were
hard at work making sure that our
infrastructure can deal
with all those poor request so i also
like a controversy and i'm going to
start with well maybe this isn't
controversial maybe it is i'm going to
say scala's simple and i'm going to give
you evidence to the contrary during this
talk and then i'm going to refute that
evidence and i'll try to kind of come
back to my claim as it goes with
controversy feel free to disagree
interrupt yella questions you know
what's at stake yeah comments it doesn't
even have to be questioned ok so it's
gonna I'm going to do my best to make it
super interactive I'd really appreciate
when ever stopped me when it's not clear
hit the fast-forward button when I get
into a rant or something so I'm serious
about this and we spend a lot of time
thinking about this there's a lot of
surface area around scala but we feel it
all comes back to a nice elegant core
and that's because Scala is a unifier we
didn't just tack functions on to Java we
figured out how to fuse functions and
objects together and figure out what the
right scales are for these abstractions
and i think that's that's kind of the
theme in learning Scala is when is it
appropriate to use a function when is it
appropriate to to compose traits when
you know when do you when you mutate
when shouldn't you and that's definitely
a challenge for the community and for us
as educators to explain that better and
I think a lot of the confusion about
complexity comes from from making these
choices so it also unifies
experimentation I don't know just
curious who's used to scala rappelled
before see yeah that's what I thought
yeah i love the repple i think that's
that's just great and you know the same
kind of code that you write their to
same compiler that you're running you
know you can do large-scale development
without as well and I think that's
another nice unification that's often
forgotten so I'm going to venture into
demo territory
um wow that looks pretty small can you
read that or no no do you mind if I just
quickly kind of I I even learn CSS for
this talk can you believe it so oh I I
would claim that's true yes because now
I have to kind of grep everywhere and
figure out where the font size is for
that thing and pretty sure I looked it
up before maybe it's here yeah there we
go so like I said I'm gonna hit you with
my CSS book that I don't have so don't
worry if you ever claim that scholars
and supposed to see almost feels as good
as fixing a bug in skala see to say
anyway so let's print some stuff to
prove that this is not scripted I'm just
going to take a suggestion and this
counts for the book if you have a good
suggestion for my print line you may win
a book so what should i print nothing
okay nothing that's too bad you had your
chance but not going to win anything
right so this thing is sending to
the repple and you know the repple is
doing it staying with it and sending it
back i also learned websockets this
weekend it was great fun so that's what
I'm going to be doing during this talk
and if anybody has questions about scala
i'll be happy to address them in this
little box here if you want to try
something or no not so much okay that's
what I thought great so behind the
scenes using unfiltered because that's
the first Google hit that i got for web
sockets and then i copy pasted some
deprecated code the WebSocket server is
apparently deprecated but i couldn't
figure out how to do it better and
shorter mean so you open a socket you
get the repple and you pass a partial
function to the WebSocket constructor
which is defined using a pattern match
here there's no match statement because
you're just constructing a partial
function literal and I just showed you
two cases there is a closed
but it's not super interesting so you
can open a socket you can receive a
message which has some text and then I
interpret that text and send it back to
all my sockets I don't really care about
security own you of any of that it's
running a local host we could possibly
go wrong oh yeah no that's what's going
to go wrong with increasing your font
size okay so this is the interpreter
part yeah I'm glad you asked Jamie I
didn't that's an excellent question I'm
pretty sure I can do that I've been yeah
that's in default CSS I love those names
keywords what color would you like white
that should do it well you know it's
just wide it's not very inspiring I
spent so much time tweaking all these
colors no more color changes okay so I
know I said you could interrupt me
whenever but I take it back so we're
gonna interpret the data we get in is
just separated by colons so we're just
calling into this Java function that's
going to give us back an array doesn't
matter we can also pattern match and
arrays I want the first thing before it
it calm to be run and then that's gonna
I'm going to put that in a variable
that's going to be my source code that I
got from my for my JavaScript on the on
the server on a server very loosely I
just you know on the client I mean sorry
and so I'm gonna redirect the output
stream from the interpreter and I make
I'll make a string out of it and that's
what I'm going to send back you might
also notice some funky pattern matching
going on around here with regexes and
string interpolation that's new in 210
and it looks crazy I'm going to explain
it later any questions so far any other
color requests no
so there's links on the on the slides to
the full code and so on that won't bore
you with that but so this is just
calling in to the to the to the scholar
rapel buts that's part of the scale
compiler jar into 11 it will be a
separate jar because we're kind of
working on slimming down or jars um so
I'll come back to this since I promised
you you could interrupt me at any time I
kind of have to hedge my bets and tell
you everything about Scott 210 in the
next five slides and then we'll just
kind of go off and rants and tangents
and so on so i'll just give you the list
you probably read yourself so the
rewritten pattern matcher i had a lot of
fun doing that last year so basically
just threw it all the code and started
from scratch well actually first we
started and then like into 11 now we
thrown out the code it's still into 10
if you want it under ex old Pat Matt
string interpolation I'll talk about
that because I think it's really neat to
the way we did it I won't talk about
value class as much because I don't
think it's very neat right now but I'll
take questions about it if you if you
insist and Blissett classes are great
feature imports allowing you to kind of
trim down the sub sort of scale that
you're using in your project you know
beginning Scala programmers might not
want to define implicit conversions all
over the place it's really cool that you
can use in so ever you were expecting a
string but maybe you know should be
programmed in a different language if
you want to do that CSS or something I
don't care um futures and promises
awesome I know a lot of you who are
actually doing you know the amateur
coding I was doing this weekend rely on
that for for scaling we have dependent
method types at me as a type theory geek
really likes and you can bake cakes with
that really nicely and we switch to ASM
instead of our hand rolled FJ BG that is
while we hardly kind of know you too bad
too well and then there's some
experimental stuff actually the first
bullet is an experimental but it's
really cool to experiment with so I kind
of put it in this category reflection is
experimental everybody did you hear it
experimental I mean I really like that
you're using it but
probably going to change it we're gonna
fix stuff in there and same thing with
macros so I think I'll of macros the
things are great I was very skeptical
from the beginning I have to say but I
think people been doing a lot of cool
stuff and we're still thinking about how
to do it just right in just ask Allah
way so don't bet the house yet on macros
as all I can say there will be some kind
of micros I think that's that's pretty
much for sure so yeah like I said we
wrote from scratch a lot of
long-standing bugs i'm sure people using
play or unfiltered have seen the
exponential bytecode explosions when you
nest uh yeah did you see them or they
have a question sorry why do you need
reflection oh that's that's pretty
philosophical um well so reflection is
really about turning your program into
data like you know what Lisp kind of
does without even mentioning as a
separate thing we'd like to reflect over
our stuff because we're you know kind of
all philosophers as programmers so I'm
sorry I really want to give you a
practical answer can you elaborate a
little bit on uh-huh yeah so for example
this talk Oh Oh pattern matching well
your pattern match on the structures you
get back from reflection but you can't
really use pattern matching until you
have an object in your hands right
reflection gets the thing from meta to
to base level to data so that you can
actually pattern match on it without
reflection there is no way to go between
those two levels so reflection is your
handle on kind of what's out there
around you that you like the ether take
em touch if you don't have reflection
and then you get reflection and you
suddenly you can say hey here's a tree
and this is actually tree that's in my
program so usually you can't really get
reason about what line number you're on
or you know what like the tree of your
argument looks like you get the value
that the tree evaluates to but you don't
get to see the tree with reflection you
can reason about all these things right
okay yeah so I mean it's like java
reflection but kind of to the max so it
exposes the compiler API to you
essentially so you you get to see all
the same data structures that the
compiler sees through slightly
simplified lens yes it's it's only you
can only look you can use byte code
sorry yeah i mean the byte code has been
compiled already so i mean you can use
all the stuff that you that you would I
mean you could use it to write your own
aop engine but the actual bike up
rewriting isn't that's not we don't do
that for you we just give you a way to
say like hey or these types of types hey
what's in this tree create a new tree
type check it stuff like that so we can
do everything the compiler does except
if you want to write it to disk you'll
have to do that yourself sorry that's
not what reflection is about if you want
to change those class files you know
that's the Java platform that's why we
love Java right we have all these
facilities for is that we don't need we
don't need to do that does that answer
your question or yeah okay okay I was
just buying some time to think of an
answer I'm sorry about the kind of slow
start there so um pattern matching right
so exponential space blow up with my is
one of my favorite bugs in the pattern
matcher you write a very innocuous
looking an apply or actually don't even
see don't apply just write a pattern on
list all of a sudden yeah you get you
run out of byte codes in your method and
people get really confused about that
and there's a lot of so you can google
it and you can find a lot of hits about
that so that's fixed now so don't worry
about it i saw and filtered has some
complaints about that in their docs but
if you're running on to 10 that's not a
problem anymore and the implementation
is actually something that we understand
now and are actively working on on
improving it into 11 doing some neat
stuff there okay so what kind of is new
in the pattern matcher is that
extractors which are those unapplied
method calls that we'll see in a second
there now also subject to
in Richmond I can't say the other thing
anymore you know like the MTV show about
rides and making them pretty so
enriching methods something they can do
also in patterns now and we'll put that
to good use later I've sorry if this is
not making any kind of sense I'll have
an example of that later and we're using
a little SAT solver into pattern matcher
to give you really nice error messages
of when you match on something it says
hey did you think of this case or this
case is never going to be hit I also
have some examples of that and if you
want to do really crazy stuff you can
virtualize your matches and you can kind
of reflect on your match but I won't go
into that end this talk but if that's
kind of this kind of stuff you like to
do in the weekend I would click on that
link and play with it so um pattern
matching can be quite exhausting and you
know especially making sure that you
covered all your cases exhaustively uh I
just love puns so when you run this
actually the it's going to crash but you
can't see it because someone made me
increase the font size probably can do
something like this no oh no it's not
going to crash because I actually don't
run it I'll make it crash later so the
compiler is actually saying hey dude the
match is not exhaustive what happens if
you pass in a nun so first all this is
familiar syntax to everybody right you
would have stopped me if it wasn't ok so
let me see if I can navigate in this
thing right so check none because this
is one of the counter examples that the
set solver came up with for for you know
not crashing so let's try and see what
happens oh yeah now we get a whole
other kind of problem so luckily i can
still scroll around so yeah you get a
match error because we weren't
anticipating getting a nun i'm sure
you've seen is if you use pattern
matching in non trivial cases before so
I'm just going to clear that box good
thing that's in there and we'll just
handle that case as well
and now we're all good okay it may still
fail because you're not handling all
kinds of thingies in some so what's the
last bit and this doesn't count for a
book but if you get a ride I'll be
really happy so what is the missing case
here i'll give you the case for free hey
sure let's see I ass great job everybody
yeah so that's exhaustive ateam at
checking for you the pattern matcher and
so just let me take a moment to come
back to the theme of the night here is
that scholars unifier and then the dust
simple is kind of my my theorem because
if you unify everything together is kind
of like this very small core that you
need to understand and everything kind
of generalizes from that so extractors
reconcile pattern matching which people
in the Oh community in the beginning
we're like why would you want to break
encapsulation just to be you know
conveniently look at lists who does that
anyway I mean just you know write a for
loop or something don't forget to
increase your counter so who well the
research that was done at epfl where
scholars develop came up with a with a
nice idea of implementing extractors
which let you configure the way that you
actually decompose the stuff that you've
composed so you know constructors like
make data extractors that you unmake
data really is sort of kind of the dual
extractors return options because they
might not match and that's why use
option for and that creates overhead but
we have some thoughts and very concrete
thoughts on how to fix this with value
classes that I'm not going to talk about
unless you make me and we'll do that in
211 yeah we also have an idea how to fix
that so actually chuckle boxing doesn't
necessarily happen when you when you a
pattern match on
a case class we just go directly to the
field accesses of the case class and we
want to generalize that mechanism that
you can supply your own field
accessories that are used for pattern
matching so you don't have to put stuff
in a tuple only to then just decompose
tuple again and roughly the same thing
for options except that there you really
need to say yes or no so you use valley
classes to to get rid of the overhead of
the of the option box so a kind of a
neat way to define an extractor is well
really all you need for to declare your
own pattern and I stands for integer
just you know try to make it it's a good
thing I was anticipating font increases
so it didn't use too many tokens so when
your value I has a method on apply and
it takes a string for example and
returns an option of int it can be used
as a pattern so what this match here
really amounts to is saying hey I don't
unapplied 10 now match on that result if
it was successful and it was a 10 then
we're all good so this allows you to
kind of hook in and kind of intercept
really like it's kind of a 0 p in a way
the matching mechanism and say no
compiler this is what I want you to do
not whatever stupid logic you have which
in this case would say hey does this not
this is not a case class right so you
told up tribes based on work by Twitter
that they've that they had we're pretty
happy with so thank you Twitter for
contributing and yeah I don't know we
can just run this stuff or take
questions about it make it crash or yeah
so again we're not fully exhaustive
obviously questions anything
um no I wouldn't say that they've
they've enjoyed working with them for
you know making sure that futures for
example that we were using fit well with
the futures that they are using and the
same for try but i wouldn't say they've
they've contributed you know usage
they're one of the really early adopters
and that that's that's been great for us
but i would say that's that's roughly
the main thing i am in other so you know
when i went from fail whale to non fail
whale that's kind of roughly coincides
with the switch to scar I just kind of
right I mean I'm allowed to say these
things okay so that's kind of roughly
all I have to say about pattern matching
simple stuff now string interpolation
who's used up before into 10 I guess
some people are using to 10 okay a
couple people so not everybody will be
bored with this okay great so let's say
you want to create a string that says
how many bottles of beer you have on
your wall somewhere and you're right a
first version that just you know takes
any string and it plugs it in to another
string so what this does really say hey
use the simple string interpolator take
a variable called n and just plop it in
here instead of the variable then
someone else can sometimes like no no no
that's really unsafe you might you know
say no bottles of beer or something set
of zero we can have that so I want an
integer so i'll write dollar and and
then % d which is the printf formateur
so you have an F string it string
interpreter interpolator I'm just going
to call inner Paul if that's okay with
everybody it's too complicated and
actually the cool thing about this is
that the compiler will actually say hey
this has to be an integer and in this
case luckily we supplied one so here the
compile again site nope can't do that
and I'll prove it too if it fits on the
screen right so the compiler says oh you
gave me a double a sneaky sneaky I was
expecting an integer and it's actually
not the compiler who's saying that which
is the cool thing it's a macro
and I'm kind of going to work my way to
explaining how this mechanism works so
how does string interpolation work well
you drop those dollar prefix let's call
them holes in your string those are
becoming variables pack the other parts
in a string context which is a case
class in a standard library and then
call the interpol thingy which is named
into prefix by whatever is you know SF
or whatever you want it does it's not
built into the language that's how we
keep it simple if you want to add
another one I'll show you how in a
couple minutes and then those holes are
passed as arguments about things so
you're free to do whatever you want so
it's a good thing these things are
editable so what the compiler generates
for you with or D sugars this too is a
create a string context this is what's
left before the first variable you want
to interpolate and this is the rest of
your string dot s which came from what
you can't read up there in the
conveniently colored comment and that's
that we just we define that with the
prefect's to this string and then
whatever we wanted to pass it in this
case the variable n but you can really
put in anything and somewhere in the
standard library we gave you a couple of
string interpolators for free and you
can buy more from typesafe no I'm
kidding you can implement them yourself
and so the s1 is standard and you can
just you know call it directly and
that's all there is to it see some
puzzled faces some like yeah I do this
all day questions about this why is it
important why's train interpolation
important why is the district okay sure
that's totally fair and that was our
position for the last decade roughly
until 210 came around and martin figured
out a way how to do this the scala way
and before we were writing stuff like
um man someone explaining why does
cursor doesn't work no javascript why do
you mock me so so we would have this
convention that you would just write and
plus and so on right and you can you can
do that I mean just think away the rest
your eye I noticed myself writing error
messages for example and I'm sorry about
that some of them are crappier because
it's just a pain to compose strings with
plus sorry yeah so you can use a format
so you can write all your stuff first
and then make sure that everything
matches up with the format that comes
after it and you don't see where what
expression goes into your format so Oh
was it going to explain about the tree
and then to type or the type and then
the tree or was it and then you know
it's just I just want everything
together when these things are there I
think it's great that you can see the
string is it's going to be as a
prototype of what it's going to be right
there in your code you get completion in
the IDE because those those holes in
there actually expressions so that all
integrates seamlessly because this
rewrite is happening behind the scenes
and ID knows about rewrites in general
so it'll just give you code completion
on that you can write your own
interpolators yes you can like todos
those interpreted strings or first class
you can you can abstract over them and
put different languages in there yeah
good question yeah that's definitely
important yep okay I'm glad I could
convince you you know you're from now
you're like on the lead for the for the
thing it's edging towards you
yeah well there you'll definitely beat
me because I just I just and square my
way through everything oh sorry I didn't
see that
no because you're free to define that
method no matter how you would like you
can make it a macro and like not omit
that code at all based on compile-time
decisions you can make it a compile a
call by name argument and do the same
thing as you would do in your in your
normal logging framework where you just
don't invoke the closure and cross your
fingers at hot spot will say oh I he's
not calling this it'll be good is that
what you're saying or okay yeah so
that's I think pretty much all taken
care of so for example the formatter the
printf style Interpol thingy will
actually compile to format so there's a
macro in the standard library that does
the standard printf style type checking
so it'll infer the types from the format
specifiers and text that you have enough
arguments and then compiles it to an
optimal format blah call that you should
never write again okay and I'm not going
to go into the micro details unless you
make me i have a link right there it's
really convenient if you want to see it
but you know again this is not there's
very little magic going on here it's
just another macro call and you can
implement your own interpolator with a
macro and do the same thing Mike roads
are experimental though say yes and you
mean in the implementation of to 10 how
many macros are there none unless I'm
mistaken Greg no they're not yeah so but
those are part of the standard lot oh
sorry so yes part of standard library
there's a couple micro is that you can
use but to actually build the compiler
like the compiler itself doesn't use any
macros I thought that's what you meant
yeah like okay the macro implementation
uses macros itself but if you don't
touch macros you won't the compiler
won't use them gratuitously that I think
is a precise statement is that sorry is
that what you meant or
so yeah there's there's a couple of
these in the library and mostly they're
into experimental stuffers for the
macros themselves that is basically just
a large suite of macros to help you deal
with so there's a core I don't want to
turn this into micro talk mostly because
I haven't done much with micros myself
to be honest but serious is the score
abstraction which likes to go from meta
to to data which called reify and then
everything else around it is just
implemented on top of that as macros as
a library to reify in a vowel it's just
like splice and unspliced and other and
other macro languages yeah so but we
don't really there's a couple of things
like this in here when it's not
mission-critical we were happy to
experiment with that but since micro sim
cells experimental we didn't really yes
yeah yeah so that's coming next
generation so there's a ton of stuff
like slick is not part of the
distribution that's something that we're
developing now scala async I mean
there's a ton of cool stuff being done
with micros it's even on top of 210 so
not necessarily for the next release but
it's not technically part of the core
distribution but so slick is the is a
database access API that we have and
Scala async is a cool way of getting rid
of forum like not having to do with for
comprehensions when dealing with futures
and just kind of right in direct style
instead of mon addicts ow that's also
you based on macros so you don't have to
use the CPS plugin anymore thank God
sorry I like see ya yes but no micros
our experiment that's the official stats
okay thank you okay so now I just kind
of want to go all crazy with this and
show you what you like the extent you
can take this too just because on our
way to implementing this I'll show you
implicit classes I'll show you kind of
how to pattern matcher works under the
hood and you know these are like the new
features into 10 so let's say you kind
of want to do to reverse so you have the
string and you want to decompose and
find how many bottles are in there so
before
we wrote this string interpolated string
and this is going to be our for reg ex
which is not part of the standard
library so we're going to implement it
ourselves and we're just going to have
we want this to become a pattern that
says any number of digits could be 0
actually maybe I should have thought
about that a little bit longer and then
we're just going to match to ok so is
the intent clear of what we're trying to
do all right I you may disagree with
something like this I'm just kind of
using it to illustrate their actual
bigger kind of data structure that you
might want to decompose this way that
make more sense than regular expressions
so in general what it means to be forced
first class means that you can be store
it in a variable and passed around so
functions are first class which means
they're just objects just put them in a
variable past min as an argument it
doesn't matter Scala is simple like that
you don't have to think about
limitations like can I put that there
can i put that there can i nest this
method in there sure you can it's all
regular don't memorize all these
exceptions that you have to deal with in
a language that restricts you to first
order so the higher-order thing in my
opinion is part of the simplicity story
where you say well don't worry about you
know abstracting over stuff will let you
abstract that it's not just the
simplicity it's also a matter of power
of abstraction and actually decomposing
your code base that way so I can just
rip this pattern out put it there and
i'll come back to the slide to prove it
to you once we've implemented all of
this and run it so you can tell them
totally making this up and you know now
we're just matching on this pattern
which won't return any data because it
just says yes or no does that make sense
question um well yeah that's a minor
nitpick I actually struggled with that
myself to be honest with you the pattern
syntax what I should have written here
was the empty brands after that but it
looks really ugly and there is a I think
I would classify it as a bug that we
didn't require those premises back there
Scala will as you know infer for you
that you forgot like the dummy like
empty parentheses
and it's a little bit stricter about
that and patterns because we didn't use
to do this kind of off and so here it
says hey that's an identifier I am
expecting brandis's because you don't
otherwise it's going to look it's not
going to look for the technical reason
is it won't look for a nun apply if you
don't if it doesn't look like an apply
yeah sorry yeah you can yeah definitely
yeah so and that would have been nicer
because that way I wouldn't have fallen
into that pitfall I'll show that that's
that's kind of going to be the
combination of my of my of my rant here
to show you how you could do that and
keep in mind that regular expressions is
just an example that fits on a slide I'm
sure you can think of Jason XML actual
source code as quasi quoting where you
like to pattern match on these things
and just immediately just like with
string interpolation when you're
constructing data you want to see how
everything fits together together rather
than in different parts you want to also
want to see that when you're decomposing
ok so my kind of the idea of figuring
out how to do this one you know when
you're hacking this kind of weird stuff
it's like okay well if this works I know
how to make the previous thing work so
let's proceed by induction so the dish
sugaring that i showed you before for
the I extractor we're really what you're
doing is on the on the selector of the
match you're calling this unapplied in
this case it son apply seek because we
want to be able to return multiple
values later when i'm going to
generalize this because in principle
regular expression could have multiple
groups so we want to be defining an
apply seek not a nun apply because you
don't know how many statically there are
with the macro you could generate a nun
apply and statically say this is going
to give you a tuple of four because
there are four groups and your reg ex I
don't want to push it that far so uh no
place seek is simply a generalization of
unapplied i showed you before which will
give you a summer nun basically saying
well I match or I don't match I guess
you can still read the slides right I
matter I don't match and this is how
many sub patterns that I matched and
these are their values so this is
exactly the same thing as a previous
slide I'm just kind of gray
working my way to something that just
looks like method calls which is another
pattern in here that really all this
syntactic sugar that you're getting once
you understand a translation you can
just kind of reason back to well how do
method calls work and everybody kind of
knows how method calls work so my my
what I'm saying there is that that's
really all you have to understand method
calls and how you get back there right
so that's what that gives you and so now
the D string as i showed you before for
the interpolated string will look like
this so now we have the problem reduced
to well i need to be able to call a
method i need to be able to add a method
are two string context because my string
interpolator is called our that was my
prefects for my for my string and i want
to be able to use this in a pattern so
it needs to be an extractor is what we
call it which is just any value that has
an unapplied and apply seek method in
this case it's going to be a nun apply
seek so this is the method that
customizes the compilers behavior and
says hey this is data here's how you
decompose it okay so that's the final
challenge and this is where implicit
classes come in they make it really easy
to add methods to existing classes so
before you would write implicit dev
convert blah to other blonde and take
your blog and return the other blah and
then make a new anonymous class now all
we really do is say well okay you want
to make a new class and instances of art
context are going to be available
wherever you have instances of string
context and the compiler is really
looking for one of the former and not
the latter that's what you have right
now well just create a new class I
create a new instance of this class
excuse me and continue with that that's
what the implicit thing says it says
make constructor calls to this class
implicit whenever I have something of
type string context but actually I need
something with an R in there and this
class tends to have it so let's
instantiate this class and continue with
the wrapper ok the compiler will do that
for you we can do it manually there's
another just another D sugaring so
there's a lot of magic going on there
but it's not that magical we tell you
how it works ok
questions about that so that's how you
enrich your classes with new methods and
networks for everything is I mean I use
this four-string context but you can do
that for other stuff as well I mean
doesn't matter their java objects or
anything really so now we have our our
method which is that call before they
were trying to get it to compile we just
need to we just need to give you
something that has a nun apply sig
method and it just so happens the reg ex
thing in or centered library is an
extractor like that already so i'm just
going to return that ok so implicit
class again is a little bit of syntactic
sugar that encapsulate the best
practices that people were doing with
implicit conversions and I think this is
something that is pretty safe to use in
your own code I would not recommend in
writing your own implicit vows or
implicit deaths unless you're really
thinking about this deeply and know
what's going to happen that's why I mean
we'll come back to that later that's why
we allow you to disable that feature
because it makes code bases harder to
understand this is this gives you
extension methods essentially a cleaner
version of expansion ok so I'm going to
run this and does define the art context
clause and I'm just quickly going to go
back and run the original code so now it
says yeah sure that matches so slightly
more dangerous live coding let's say we
want to capture this group and call it n
right so we actually want to get that
number out of there
yes okay so we had 10 bottles oh thank
you thank you well that won't get you to
a book either but I'll remember your
faces thank you for clapping um okay so
it does work okay and yeah I just want
to kind of rent a little bit longer
about type inference and value inference
which are kind of unified the idea of
hey I have this explicit stuff that's
required but really compiler you should
be able to figure this out on your own
don't make me type all this and that's
what implicit sorry that's what type
inference does for you they're really
wanting the same thing and actually in
the compiler they're integrated with
each other so implicit search will drive
type inference that's how for example
the collections are implemented in Scala
so that you when you map something over
a string you get a string bag actually a
lot as long as their characters when
their ends you get a sikh events this
mechanism follows from the unification
of type inference and value inference
which we usually call implicit search so
there's a lot of really cool stuff you
can do with that again i would i would
tread very very carefully but if you
want to come back to this i would
definitely recommend googling any of
these things and having a look at it so
really cool test frameworks like specs
for example use this technique a lot to
let you write really declarative test
suite so looks like I swapped some
slides around there I'm sorry about that
so yes so the final culmination is the
one liner that will let you define a
variable n which is an integer that's
the I extractor that we had before and
you know get whatever number is in there
out so pattern matching a pattern like
that can be used in any location where
you're expecting a variable not in an
argument position because that's just
too weird but this is just excuse me
syntactic sugar for a one line pattern
match that matches this pattern and then
gets a variable out and puts in a new
local variable so now that we've
implemented this that works as well okay
so now you just get an N it's actually
integer because
be wrapped around like there's this uh
pattern now that's an integer that takes
a string here and says oh is this is
this possible as an end yes then match
otherwise no you're going to match her
yes well I don't know I think so i dunno
i think it works let's see sorry yeah
yeah I'll just I'm just going to copy
paste if you don't mind scroll around a
little bit we're just going to call this
M because i'm just that imaginative can
see my cursor and doesn't help oh i'm at
the beginning sorry this is like
extremely actually i'm using code mirror
for this and its really pretty cool so
i'm going to call this other variable m
and didn't mess up anything else and
then i'll just put 11 in there and there
you go so yeah so it just generalized
like that i was a little bit worried but
i'm pretty sure i implement that
correctly okay so you know this is all
pretty crazy when you do when you apply
it like that but think of a domain where
you work a lot with decomposing
unstructured data and making it
structured and making it typed again and
would you rather do it in one place
where you kind of see prototypically
while you're expecting and getting like
the holes out of that immediately or
would you rather just I don't know
compose a lot of function calls and say
get first hole get second hole and so on
so again you have to use these things
two digits judiciously depending on why
you're implementing and where you are in
your project but I think this is pretty
cool stuff so other people think so as
well and they're implementing Kwazii
quotes and and stuff like that with it
so I guess a lot of people say well
Scala got a lot better actually have no
idea how am i doing on time ok so when
do we start
sir okay well I don't have too many more
slides because I've been talking really
fast so as I think it's going to be okay
but just so you know feel free to ask
more questions so yes Scala to ten got
bigger can you can you can stole that
simple or you know is that really
becoming complex or complicated or you
know should it be simplistic should it
really be like oh this is a string
interpolation we just bolted this on for
you and sorry don't pass it around don't
define your own you know we don't we're
not going to do type in prison though so
we have my course as well but yeah you
can't use those with string
interpolation I mean I guess you can to
see where I'm going with this from my
opinion when you're learning a new
feature that's a big investment and you
want to get as much bang for your buck
as you can get so when you learn a new
feature like that you really wanted to
integrate with all those other features
and I think that's what we're doing with
all these Scott features that I've
mentioned before is we just we don't
just like balt everything together we
actually spent a lot of time thinking
about how this can be reduced to what
Scala really is about and how that once
you understand this mechanism it becomes
intuitive for you to use it and I'm not
claiming we're perfect but that's what
we're striving for so and I guess the
main point there is that since these are
all method calls you can develop your
own libraries where you can use this
mechanism and define what makes sense to
you so I've kind of focused on like the
new sparkly things that are in scale to
10 that I'm excited about all of the
stable features that you're using every
day to develop your applications those
were in 29 those were in 28 that's not
what this talk was about I just want to
tell I mean I want to emphasize that
where you know despite all this cool
hacking and there you know the first
thing on their mind is you know we r
prime attic language people are getting
 done with it so Java interop is
important you know balance it against
making programming fun not an easy thing
a legacy I mean Scala is 10 years old
how do you balance that with sanity
people want new toys how do you balance
that with simplicity so this is where we
are right now and we're really looking
for like looking forward into 11 to
further simplifying and making Scala
faster and smaller but this is really
very much or drive so also
matic in the sense that we don't say hey
immutability is the future multi core is
the future we believe that but if you
want to mutate that's fine and a lot of
times very like locally your method will
loop cleaner if you just mutate just
don't do it at a large scale it's not a
good idea so for example you know Scala
has this new neat futures concept and
you're saying well let's unify mutation
and a synchronicity because we can unify
things in sky right so i hacked sorry
this is red this is bad this is a bar
and I it specifically had to CSS to show
red for VARs even though sometimes
they're okay and so you know you can do
this you can write a future that writes
12 x and you can write a future that
writes to 2y and then you run can run it
a couple times and see what values you
get you know that's not recommended and
we make it really easy for you and
seamless to write code to good way and
you know that's what you should stick to
I guess the point that I'm making here
is that it's really not up to scala as
the language to say hey you can never
use mutation that's something that you
know you should decide for yourself so
maybe it would be simpler if you just
disallowed us but sometimes you know you
can get an extra inch of performance out
of there so you know sometimes you get
one sometimes to get zero sometimes you
get one again something to get to it's
fun but I wouldn't do it oh yeah no I
went to wrong direction right sorry
about the flickering just got me all
confused right so futures since we're on
the topic i am not a I'm not so much of
a asynchronous kind of guy or
distributed computing but futures are
really cool because they're like monads
is what you'll hear in this column eel
is wow that doesn't really we don't care
about that I'm serious we really don't
care it's great that whenever you see
future in there it makes you think twice
right i mean like is this actually going
to be available in the future like how
long is it going to take me to get this
this is something where types help your
programming and say hey think about this
is going to take a while before you get
this maybe you'll never get it maybe
there'll be an
error usually you know types get out of
your way I've specifically omitted a lot
of the types in the presentation to show
you that you don't need to write them
but a lot of times it's good to think
about them and say oh this is a future
and this actually lets us gives you give
you a lot of nice syntax so this is what
you get with futures you can say well do
this and in parallel do that and then
when they both come together give you
fuse the results with some magical +
operator and now with scale at scala
async which is not technically part of
210 but it's built on top of 210 and
macros you can write it even even more
succinctly so there's this async keyword
which is a macro and you just write in
direct style you say well I have this
this future here this other future here
and now I want to wait for the result of
that and await the result of that and
then when i get them I'm just going to
combine them so no more funky arrows and
your fours and when do I write the
semicolon or not I quickly just wanted
to say that you know like with all these
complications here you can actually
disallow some of the features in there
so sip 18 helps you keep it simple you
can say well I don't want any postfix
operators I want any reflective calls
which made you can curse some runtime
overhead from structural types I don't
want to I don't want to let my my
programmers as a manager define implicit
conversions and there's a whole kind of
whole other things so for example we
have this dynamic trait wear anything
that you want to call in it is fine and
that you do by extending dynamic and
then whenever the method isn't defined
in that thing it's rewritten to an
applied and imma call I won't go into it
since I'm running out of time but then
you confuse that with macros and
actually again statically say well this
is a valid call or not at compile time I
encourage you to google for this kind of
stuff I love it it's great and doing it
is on a sunday afternoon whenever you
have to sew on 211 our focus is very
much on making it smaller faster and
Stabler elected aft punk song roughly
and so we're modularizing the standard
library in the compiler so to get your
contributions more readily for the
interpreter or scala doc or our testing
infrastructure will be spun off to
different projects we're very much work
Greg Greg who's working on incremental
compiler because a batch compilation in
Scala we know is slow but there are a
lot of tricks you can do with
incremental compilation and we can make
that we know how to make out a lot
better to give you a much better
experience in you know in IntelliJ it
eclipse plugin zinc there's maven
plugins for that SBT uses that of course
so that's another component zinc that
will we have spun off and are improving
and that we're happy to work with
everybody who wants to integrate that
and you know just also just get simply
better bad performance and so I kind of
put that in there to go out with a bang
this is my last slide so yes the default
target will be java 6 but we're at work
we're working on a Java 7 and 8 back-end
that has a lot of clever tricks using
invoke dynamic for you know
interoperating with sams and java 8 is
something that we can do while compilot
java 6 for example but leveraging their
performance increases probably not going
to happen until java aid and that's
going to be Scala 212 so if you want to
participate in that debate sorry too
late to 11 is coming out in about six
months but I think I'm pretty I'm pretty
confident java 6 is going to be around
for a little bit longer and we'll be
ready for for java 8 into 12 which is
only about a year away year and a half
so thanks all for your questions during
the talk time permitting happy to take
more
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>